
saml21g18b_sensor_board_demo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0001c1b4  00000000  00000000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000001a4  20000000  0001c1b4  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .lpram        00000000  30000000  30000000  000301a4  2**0
                  CONTENTS
  3 .bss          00002730  200001a4  0001c358  000301a4  2**2
                  ALLOC
  4 .stack        00002004  200028d4  0001ea88  000301a4  2**0
                  ALLOC
  5 .ARM.attributes 00000028  00000000  00000000  000301a4  2**0
                  CONTENTS, READONLY
  6 .comment      000000b4  00000000  00000000  000301cc  2**0
                  CONTENTS, READONLY
  7 .debug_info   0009e98b  00000000  00000000  00030280  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000e2d9  00000000  00000000  000cec0b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0002b650  00000000  00000000  000dcee4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00001fe8  00000000  00000000  00108534  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00002430  00000000  00000000  0010a51c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0003820a  00000000  00000000  0010c94c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00040dbc  00000000  00000000  00144b56  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000c13ff  00000000  00000000  00185912  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00006594  00000000  00000000  00246d14  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:
/* ! [setup] */

/*! \brief Example application entry function.
 */
touch_ret_t touch_sensors_init(void)
{
       0:	200048d8 	.word	0x200048d8
	touch_ret_t touch_ret = TOUCH_SUCCESS;

	/* Setup and enable generic clock source for PTC module. */
	touch_configure_ptc_clock();
       4:	0000dead 	.word	0x0000dead

	touch_time.measurement_period_ms = DEF_TOUCH_MEASUREMENT_PERIOD_MS;
       8:	0000dea9 	.word	0x0000dea9
       c:	0000dea9 	.word	0x0000dea9
	...
touch_ret_t touch_sensors_config(void)
{
	touch_ret_t touch_ret = TOUCH_SUCCESS;
	sensor_id_t sensor_id;

	touch_ret = touch_selfcap_sensor_config(SENSOR_TYPE_KEY, CHANNEL_0,CHANNEL_0, NO_AKS_GROUP, 12u, HYST_25,RES_8_BIT, &sensor_id);
      2c:	0000dea9 	.word	0x0000dea9
	...
      38:	0000dea9 	.word	0x0000dea9
      3c:	0000dea9 	.word	0x0000dea9
	if (touch_ret != TOUCH_SUCCESS)
      40:	0000dea9 	.word	0x0000dea9
      44:	0000b559 	.word	0x0000b559
	{
		while (1) ;
	}


	touch_ret = touch_selfcap_sensor_config(SENSOR_TYPE_KEY, CHANNEL_1,CHANNEL_1, NO_AKS_GROUP, 12u, HYST_25,RES_8_BIT, &sensor_id);
      48:	0000c3f9 	.word	0x0000c3f9
      4c:	0000c5fd 	.word	0x0000c5fd
      50:	0000dea9 	.word	0x0000dea9
      54:	0000dea9 	.word	0x0000dea9
      58:	0000dea9 	.word	0x0000dea9
      5c:	0000c1ad 	.word	0x0000c1ad
      60:	0000cc51 	.word	0x0000cc51
	if (touch_ret != TOUCH_SUCCESS)
      64:	0000cc61 	.word	0x0000cc61
      68:	0000cc71 	.word	0x0000cc71
	{
		while (1) ;
	}


	touch_ret = touch_selfcap_sensor_config(SENSOR_TYPE_LUMP, CHANNEL_2,CHANNEL_2, NO_AKS_GROUP, 12u, HYST_50,RES_8_BIT, &sensor_id);
      6c:	0000cc81 	.word	0x0000cc81
      70:	0000cc91 	.word	0x0000cc91
      74:	0000cca1 	.word	0x0000cca1
      78:	0000dea9 	.word	0x0000dea9
      7c:	0000dea9 	.word	0x0000dea9
      80:	0000dea9 	.word	0x0000dea9
      84:	0000db39 	.word	0x0000db39
	if (touch_ret != TOUCH_SUCCESS)
      88:	0000db49 	.word	0x0000db49
	...
	 * for PTC operation as given in DEF_MUTLCAP_CLK_PRESCALE and
	 * DEF_MUTLCAP_SENSE_RESISTOR
	 *
	 */
	touch_ret = touch_selfcap_sensors_calibrate(DEF_SELF_AUTO_TUNE_VALUE);
	if (touch_ret != TOUCH_SUCCESS) {
      94:	0000db59 	.word	0x0000db59
      98:	0000ac79 	.word	0x0000ac79
		while (1u) {    /* Check API Error return code. */
		}
	}

	return (touch_ret);
}
      9c:	0000dea9 	.word	0x0000dea9
      a0:	0000dea9 	.word	0x0000dea9
      a4:	0000f6e5 	.word	0x0000f6e5
      a8:	0000dea9 	.word	0x0000dea9
      ac:	0000dea9 	.word	0x0000dea9
      b0:	00000000 	.word	0x00000000

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
					   if ((p_selfcap_measure_data->p_sensor_states[0] != 0) )
                       {
						    if(drift_wakeup==1)
						    {
							    set_time_to_measure_count();
								drift_wakeup=0;
      b8:	7823      	ldrb	r3, [r4, #0]
								sleep_Enable=0;
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
						    }

							if(snsrs_disabled==1)
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
						    {
                                snsrs_disabled=0;
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
								for(counter=0;counter<DEF_SELFCAP_NUM_SENSORS;counter++)
								{

									if(counter!=DEF_LOWPOWER_SENSOR_ID)
									{
										touch_ret_lp=touch_selfcap_sensor_reenable(counter,0);//NO_RECAL_RE_EN
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	200001a4 	.word	0x200001a4

										if(touch_ret_lp!=TOUCH_SUCCESS)
      d4:	00000000 	.word	0x00000000
								for(counter=0;counter<DEF_SELFCAP_NUM_SENSORS;counter++)
								{

									if(counter!=DEF_LOWPOWER_SENSOR_ID)
									{
										touch_ret_lp=touch_selfcap_sensor_reenable(counter,0);//NO_RECAL_RE_EN
      d8:	0001c1b4 	.word	0x0001c1b4

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}

										if(touch_ret_lp!=TOUCH_SUCCESS)
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
						else
						{
							turn_off_touch_led();
						}

					   if((advertisement_timer >= (BLE_ADVERTISEMENT_TIMEOUT/DEF_TOUCH_MEASUREMENT_PERIOD_MS)) || (power_up_flag == true))					   
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
                       {
						   if(power_up_flag == false)
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
						   {
							   	/* stop BLE advertising */
							   	at_ble_adv_stop();
     104:	200001a8 	.word	0x200001a8
							   	started_advertising = false;
     108:	0001c1b4 	.word	0x0001c1b4
								/* disable uart to save power */
								disable_usart();
     10c:	0001c1b4 	.word	0x0001c1b4
								/* disable i2c peripheral */
								disable_i2c();
     110:	00000000 	.word	0x00000000

00000114 <nvm_set_config>:
	if (error_code != STATUS_OK) {
		return error_code;
	}

	*((uint32_t *)NVMCTRL_AUX0_ADDRESS) = fusebits[0];
    *(((uint32_t *)NVMCTRL_AUX0_ADDRESS) + 1) = fusebits[1];
     114:	b510      	push	{r4, lr}
     116:	4a1f      	ldr	r2, [pc, #124]	; (194 <nvm_set_config+0x80>)
     118:	6991      	ldr	r1, [r2, #24]
     11a:	2304      	movs	r3, #4
     11c:	430b      	orrs	r3, r1
     11e:	6193      	str	r3, [r2, #24]
     120:	4b1d      	ldr	r3, [pc, #116]	; (198 <nvm_set_config+0x84>)
     122:	8b19      	ldrh	r1, [r3, #24]
     124:	2220      	movs	r2, #32
     126:	32ff      	adds	r2, #255	; 0xff
     128:	430a      	orrs	r2, r1
     12a:	831a      	strh	r2, [r3, #24]
     12c:	7d1a      	ldrb	r2, [r3, #20]
     12e:	2305      	movs	r3, #5
     130:	07d2      	lsls	r2, r2, #31
     132:	d52c      	bpl.n	18e <nvm_set_config+0x7a>
     134:	7801      	ldrb	r1, [r0, #0]
     136:	0209      	lsls	r1, r1, #8
     138:	22c0      	movs	r2, #192	; 0xc0
     13a:	0092      	lsls	r2, r2, #2
     13c:	4011      	ands	r1, r2

	error_code = nvm_execute_command(NVM_COMMAND_WRITE_AUX_ROW,NVMCTRL_AUX0_ADDRESS,0);
     13e:	7842      	ldrb	r2, [r0, #1]
     140:	01d2      	lsls	r2, r2, #7
     142:	33fa      	adds	r3, #250	; 0xfa
     144:	4013      	ands	r3, r2
	if (error_code != STATUS_OK) {
		return error_code;
     146:	4319      	orrs	r1, r3
	}

	return error_code;
}
     148:	7882      	ldrb	r2, [r0, #2]
     14a:	0052      	lsls	r2, r2, #1
     14c:	231e      	movs	r3, #30
     14e:	401a      	ands	r2, r3
     150:	000b      	movs	r3, r1
     152:	4313      	orrs	r3, r2
     154:	78c2      	ldrb	r2, [r0, #3]
     156:	0492      	lsls	r2, r2, #18
     158:	2180      	movs	r1, #128	; 0x80
     15a:	02c9      	lsls	r1, r1, #11
     15c:	400a      	ands	r2, r1
     15e:	4313      	orrs	r3, r2
     160:	7902      	ldrb	r2, [r0, #4]
     162:	0412      	lsls	r2, r2, #16
     164:	21c0      	movs	r1, #192	; 0xc0
     166:	0289      	lsls	r1, r1, #10
     168:	400a      	ands	r2, r1
     16a:	4313      	orrs	r3, r2
     16c:	4a0a      	ldr	r2, [pc, #40]	; (198 <nvm_set_config+0x84>)
     16e:	6053      	str	r3, [r2, #4]
     170:	6893      	ldr	r3, [r2, #8]
     172:	035b      	lsls	r3, r3, #13
     174:	0f5b      	lsrs	r3, r3, #29
     176:	4909      	ldr	r1, [pc, #36]	; (19c <nvm_set_config+0x88>)
     178:	2408      	movs	r4, #8
     17a:	409c      	lsls	r4, r3
     17c:	800c      	strh	r4, [r1, #0]
     17e:	6893      	ldr	r3, [r2, #8]
     180:	804b      	strh	r3, [r1, #2]
     182:	7843      	ldrb	r3, [r0, #1]
     184:	710b      	strb	r3, [r1, #4]
     186:	8b13      	ldrh	r3, [r2, #24]
     188:	05db      	lsls	r3, r3, #23
     18a:	0fdb      	lsrs	r3, r3, #31
     18c:	011b      	lsls	r3, r3, #4
     18e:	0018      	movs	r0, r3
	if (nvm_module->STATUS.reg & NVMCTRL_STATUS_SB) {
		return STATUS_ERR_IO;
	}

	return STATUS_OK;
}
     190:	bd10      	pop	{r4, pc}
     192:	46c0      	nop			; (mov r8, r8)
     194:	40000400 	.word	0x40000400
     198:	41004000 	.word	0x41004000
     19c:	200001c0 	.word	0x200001c0

000001a0 <nvm_execute_command>:
 */
enum status_code nvm_execute_command(
		const enum nvm_command command,
		const uint32_t address,
		const uint32_t parameter)
{
     1a0:	b530      	push	{r4, r5, lr}
     1a2:	0004      	movs	r4, r0
	uint32_t temp;

	/* Check that the address given is valid  */
	if (address > ((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)
     1a4:	4a22      	ldr	r2, [pc, #136]	; (230 <nvm_execute_command+0x90>)
     1a6:	8810      	ldrh	r0, [r2, #0]
     1a8:	8853      	ldrh	r3, [r2, #2]
     1aa:	4343      	muls	r3, r0
     1ac:	428b      	cmp	r3, r1
     1ae:	d20b      	bcs.n	1c8 <nvm_execute_command+0x28>
		&& !(address >= NVMCTRL_AUX0_ADDRESS && address <= NVMCTRL_AUX1_ADDRESS )){
     1b0:	2280      	movs	r2, #128	; 0x80
     1b2:	0192      	lsls	r2, r2, #6
     1b4:	4b1f      	ldr	r3, [pc, #124]	; (234 <nvm_execute_command+0x94>)
     1b6:	18cb      	adds	r3, r1, r3
     1b8:	4293      	cmp	r3, r2
     1ba:	d905      	bls.n	1c8 <nvm_execute_command+0x28>
#ifdef FEATURE_NVM_RWWEE
		if (address >= ((uint32_t)NVMCTRL_RWW_EEPROM_SIZE + NVMCTRL_RWW_EEPROM_ADDR)
			|| address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
     1bc:	2018      	movs	r0, #24

	/* Check that the address given is valid  */
	if (address > ((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)
		&& !(address >= NVMCTRL_AUX0_ADDRESS && address <= NVMCTRL_AUX1_ADDRESS )){
#ifdef FEATURE_NVM_RWWEE
		if (address >= ((uint32_t)NVMCTRL_RWW_EEPROM_SIZE + NVMCTRL_RWW_EEPROM_ADDR)
     1be:	4a1e      	ldr	r2, [pc, #120]	; (238 <nvm_execute_command+0x98>)
     1c0:	4b1e      	ldr	r3, [pc, #120]	; (23c <nvm_execute_command+0x9c>)
     1c2:	18cb      	adds	r3, r1, r3
     1c4:	4293      	cmp	r3, r2
     1c6:	d831      	bhi.n	22c <nvm_execute_command+0x8c>

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;

	/* turn off cache before issuing flash commands */
	temp = nvm_module->CTRLB.reg;
     1c8:	4b1d      	ldr	r3, [pc, #116]	; (240 <nvm_execute_command+0xa0>)
     1ca:	685d      	ldr	r5, [r3, #4]
#if (SAMC20) || (SAMC21)
	nvm_module->CTRLB.reg = ((temp &(~(NVMCTRL_CTRLB_CACHEDIS(0x2)))) 
							| NVMCTRL_CTRLB_CACHEDIS(0x1));
#else
	nvm_module->CTRLB.reg = temp | NVMCTRL_CTRLB_CACHEDIS;
     1cc:	2280      	movs	r2, #128	; 0x80
     1ce:	02d2      	lsls	r2, r2, #11
     1d0:	432a      	orrs	r2, r5
     1d2:	605a      	str	r2, [r3, #4]
#endif

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
     1d4:	8b18      	ldrh	r0, [r3, #24]
     1d6:	2220      	movs	r2, #32
     1d8:	32ff      	adds	r2, #255	; 0xff
     1da:	4302      	orrs	r2, r0
     1dc:	831a      	strh	r2, [r3, #24]
static inline bool nvm_is_ready(void)
{
	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;

	return nvm_module->INTFLAG.reg & NVMCTRL_INTFLAG_READY;
     1de:	7d1b      	ldrb	r3, [r3, #20]

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
		return STATUS_BUSY;
     1e0:	2005      	movs	r0, #5

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
     1e2:	07db      	lsls	r3, r3, #31
     1e4:	d522      	bpl.n	22c <nvm_execute_command+0x8c>
		return STATUS_BUSY;
	}

	switch (command) {
     1e6:	2c45      	cmp	r4, #69	; 0x45
     1e8:	d81f      	bhi.n	22a <nvm_execute_command+0x8a>
     1ea:	00a3      	lsls	r3, r4, #2
     1ec:	4a15      	ldr	r2, [pc, #84]	; (244 <nvm_execute_command+0xa4>)
     1ee:	58d3      	ldr	r3, [r2, r3]
     1f0:	469f      	mov	pc, r3
		/* Commands requiring address (protected) */
		case NVM_COMMAND_ERASE_AUX_ROW:
		case NVM_COMMAND_WRITE_AUX_ROW:

			/* Auxiliary space cannot be accessed if the security bit is set */
			if (nvm_module->STATUS.reg & NVMCTRL_STATUS_SB) {
     1f2:	4b13      	ldr	r3, [pc, #76]	; (240 <nvm_execute_command+0xa0>)
     1f4:	8b1b      	ldrh	r3, [r3, #24]
				return STATUS_ERR_IO;
     1f6:	2010      	movs	r0, #16
		/* Commands requiring address (protected) */
		case NVM_COMMAND_ERASE_AUX_ROW:
		case NVM_COMMAND_WRITE_AUX_ROW:

			/* Auxiliary space cannot be accessed if the security bit is set */
			if (nvm_module->STATUS.reg & NVMCTRL_STATUS_SB) {
     1f8:	05db      	lsls	r3, r3, #23
     1fa:	d417      	bmi.n	22c <nvm_execute_command+0x8c>
				return STATUS_ERR_IO;
			}

			/* Set address, command will be issued elsewhere */
			nvm_module->ADDR.reg = (uintptr_t)&NVM_MEMORY[address / 4];
     1fc:	0889      	lsrs	r1, r1, #2
     1fe:	0049      	lsls	r1, r1, #1
     200:	4b0f      	ldr	r3, [pc, #60]	; (240 <nvm_execute_command+0xa0>)
     202:	61d9      	str	r1, [r3, #28]
			break;
     204:	e003      	b.n	20e <nvm_execute_command+0x6e>
		case NVM_COMMAND_RWWEE_ERASE_ROW:
		case NVM_COMMAND_RWWEE_WRITE_PAGE:
#endif

			/* Set address, command will be issued elsewhere */
			nvm_module->ADDR.reg = (uintptr_t)&NVM_MEMORY[address / 4];
     206:	0889      	lsrs	r1, r1, #2
     208:	0049      	lsls	r1, r1, #1
     20a:	4b0d      	ldr	r3, [pc, #52]	; (240 <nvm_execute_command+0xa0>)
     20c:	61d9      	str	r1, [r3, #28]
		default:
			return STATUS_ERR_INVALID_ARG;
	}

	/* Set command */
	nvm_module->CTRLA.reg = command | NVMCTRL_CTRLA_CMDEX_KEY;
     20e:	20a5      	movs	r0, #165	; 0xa5
     210:	0200      	lsls	r0, r0, #8
     212:	4304      	orrs	r4, r0
     214:	4b0a      	ldr	r3, [pc, #40]	; (240 <nvm_execute_command+0xa0>)
     216:	801c      	strh	r4, [r3, #0]
     218:	0019      	movs	r1, r3

	/* Wait for the NVM controller to become ready */
	while (!nvm_is_ready()) {
     21a:	2201      	movs	r2, #1
     21c:	7d0b      	ldrb	r3, [r1, #20]
     21e:	4213      	tst	r3, r2
     220:	d0fc      	beq.n	21c <nvm_execute_command+0x7c>
	}

	/* restore the setting */
	nvm_module->CTRLB.reg = temp;
     222:	4b07      	ldr	r3, [pc, #28]	; (240 <nvm_execute_command+0xa0>)
     224:	605d      	str	r5, [r3, #4]

	return STATUS_OK;
     226:	2000      	movs	r0, #0
     228:	e000      	b.n	22c <nvm_execute_command+0x8c>
		case NVM_COMMAND_ENTER_LOW_POWER_MODE:
		case NVM_COMMAND_EXIT_LOW_POWER_MODE:
			break;

		default:
			return STATUS_ERR_INVALID_ARG;
     22a:	2017      	movs	r0, #23

	/* restore the setting */
	nvm_module->CTRLB.reg = temp;

	return STATUS_OK;
}
     22c:	bd30      	pop	{r4, r5, pc}
     22e:	46c0      	nop			; (mov r8, r8)
     230:	200001c0 	.word	0x200001c0
     234:	ff7fc000 	.word	0xff7fc000
     238:	00001fff 	.word	0x00001fff
     23c:	ffc00000 	.word	0xffc00000
     240:	41004000 	.word	0x41004000
     244:	00012d78 	.word	0x00012d78

00000248 <nvm_write_buffer>:
 */
enum status_code nvm_write_buffer(
		const uint32_t destination_address,
		const uint8_t *buffer,
		uint16_t length)
{
     248:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	bool is_rww_eeprom = false;
#endif

	/* Check if the destination address is valid */
	if (destination_address >
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
     24a:	4b2e      	ldr	r3, [pc, #184]	; (304 <nvm_write_buffer+0xbc>)
     24c:	881c      	ldrh	r4, [r3, #0]
#ifdef FEATURE_NVM_RWWEE
	bool is_rww_eeprom = false;
#endif

	/* Check if the destination address is valid */
	if (destination_address >
     24e:	885b      	ldrh	r3, [r3, #2]
     250:	4363      	muls	r3, r4
     252:	4283      	cmp	r3, r0
     254:	d207      	bcs.n	266 <nvm_write_buffer+0x1e>
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
#ifdef FEATURE_NVM_RWWEE
		if (destination_address >= ((uint32_t)NVMCTRL_RWW_EEPROM_SIZE + NVMCTRL_RWW_EEPROM_ADDR)
			|| destination_address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
     256:	2518      	movs	r5, #24

	/* Check if the destination address is valid */
	if (destination_address >
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
#ifdef FEATURE_NVM_RWWEE
		if (destination_address >= ((uint32_t)NVMCTRL_RWW_EEPROM_SIZE + NVMCTRL_RWW_EEPROM_ADDR)
     258:	4e2b      	ldr	r6, [pc, #172]	; (308 <nvm_write_buffer+0xc0>)
     25a:	4b2c      	ldr	r3, [pc, #176]	; (30c <nvm_write_buffer+0xc4>)
     25c:	18c3      	adds	r3, r0, r3
			|| destination_address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
		}
		is_rww_eeprom = true;
     25e:	2701      	movs	r7, #1

	/* Check if the destination address is valid */
	if (destination_address >
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
#ifdef FEATURE_NVM_RWWEE
		if (destination_address >= ((uint32_t)NVMCTRL_RWW_EEPROM_SIZE + NVMCTRL_RWW_EEPROM_ADDR)
     260:	42b3      	cmp	r3, r6
     262:	d901      	bls.n	268 <nvm_write_buffer+0x20>
     264:	e04c      	b.n	300 <nvm_write_buffer+0xb8>
		const uint32_t destination_address,
		const uint8_t *buffer,
		uint16_t length)
{
#ifdef FEATURE_NVM_RWWEE
	bool is_rww_eeprom = false;
     266:	2700      	movs	r7, #0
		return STATUS_ERR_BAD_ADDRESS;
#endif
	}

	/* Check if the write address not aligned to the start of a page */
	if (destination_address & (_nvm_dev.page_size - 1)) {
     268:	1e63      	subs	r3, r4, #1
		return STATUS_ERR_BAD_ADDRESS;
     26a:	2518      	movs	r5, #24
		return STATUS_ERR_BAD_ADDRESS;
#endif
	}

	/* Check if the write address not aligned to the start of a page */
	if (destination_address & (_nvm_dev.page_size - 1)) {
     26c:	4218      	tst	r0, r3
     26e:	d147      	bne.n	300 <nvm_write_buffer+0xb8>
		return STATUS_ERR_BAD_ADDRESS;
	}

	/* Check if the write length is longer than a NVM page */
	if (length > _nvm_dev.page_size) {
		return STATUS_ERR_INVALID_ARG;
     270:	3d01      	subs	r5, #1
	if (destination_address & (_nvm_dev.page_size - 1)) {
		return STATUS_ERR_BAD_ADDRESS;
	}

	/* Check if the write length is longer than a NVM page */
	if (length > _nvm_dev.page_size) {
     272:	4294      	cmp	r4, r2
     274:	d344      	bcc.n	300 <nvm_write_buffer+0xb8>
     276:	4b26      	ldr	r3, [pc, #152]	; (310 <nvm_write_buffer+0xc8>)
     278:	7d1b      	ldrb	r3, [r3, #20]
	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
		return STATUS_BUSY;
     27a:	3d12      	subs	r5, #18

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
     27c:	07db      	lsls	r3, r3, #31
     27e:	d53f      	bpl.n	300 <nvm_write_buffer+0xb8>
		return STATUS_BUSY;
	}

	/* Erase the page buffer before buffering new data */
	nvm_module->CTRLA.reg = NVM_COMMAND_PAGE_BUFFER_CLEAR | NVMCTRL_CTRLA_CMDEX_KEY;
     280:	4c24      	ldr	r4, [pc, #144]	; (314 <nvm_write_buffer+0xcc>)
     282:	4b23      	ldr	r3, [pc, #140]	; (310 <nvm_write_buffer+0xc8>)
     284:	801c      	strh	r4, [r3, #0]
     286:	001d      	movs	r5, r3

	/* Check if the module is busy */
	while (!nvm_is_ready()) {
     288:	2401      	movs	r4, #1
     28a:	7d2b      	ldrb	r3, [r5, #20]
     28c:	4223      	tst	r3, r4
     28e:	d0fc      	beq.n	28a <nvm_write_buffer+0x42>
		/* Force-wait for the buffer clear to complete */
	}

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
     290:	4c1f      	ldr	r4, [pc, #124]	; (310 <nvm_write_buffer+0xc8>)
     292:	8b25      	ldrh	r5, [r4, #24]
     294:	2320      	movs	r3, #32
     296:	33ff      	adds	r3, #255	; 0xff
     298:	432b      	orrs	r3, r5
     29a:	8323      	strh	r3, [r4, #24]

	uint32_t nvm_address = destination_address / 2;
     29c:	0846      	lsrs	r6, r0, #1

	/* NVM _must_ be accessed as a series of 16-bit words, perform manual copy
	 * to ensure alignment */
	for (uint16_t i = 0; i < length; i += 2) {
     29e:	2a00      	cmp	r2, #0
     2a0:	d029      	beq.n	2f6 <nvm_write_buffer+0xae>
     2a2:	0076      	lsls	r6, r6, #1
     2a4:	2300      	movs	r3, #0
		/* Copy first byte of the 16-bit chunk to the temporary buffer */
		data = buffer[i];

		/* If we are not at the end of a write request with an odd byte count,
		 * store the next byte of data as well */
		if (i < (length - 1)) {
     2a6:	1e54      	subs	r4, r2, #1
     2a8:	46a4      	mov	ip, r4
	 * to ensure alignment */
	for (uint16_t i = 0; i < length; i += 2) {
		uint16_t data;

		/* Copy first byte of the 16-bit chunk to the temporary buffer */
		data = buffer[i];
     2aa:	5ccd      	ldrb	r5, [r1, r3]

		/* If we are not at the end of a write request with an odd byte count,
		 * store the next byte of data as well */
		if (i < (length - 1)) {
     2ac:	4563      	cmp	r3, ip
     2ae:	db01      	blt.n	2b4 <nvm_write_buffer+0x6c>
	 * to ensure alignment */
	for (uint16_t i = 0; i < length; i += 2) {
		uint16_t data;

		/* Copy first byte of the 16-bit chunk to the temporary buffer */
		data = buffer[i];
     2b0:	b2ac      	uxth	r4, r5
     2b2:	e003      	b.n	2bc <nvm_write_buffer+0x74>

		/* If we are not at the end of a write request with an odd byte count,
		 * store the next byte of data as well */
		if (i < (length - 1)) {
			data |= (buffer[i + 1] << 8);
     2b4:	18cc      	adds	r4, r1, r3
     2b6:	7864      	ldrb	r4, [r4, #1]
     2b8:	0224      	lsls	r4, r4, #8
     2ba:	432c      	orrs	r4, r5
		}

		/* Store next 16-bit chunk to the NVM memory space */
		NVM_MEMORY[nvm_address++] = data;
     2bc:	8034      	strh	r4, [r6, #0]

	uint32_t nvm_address = destination_address / 2;

	/* NVM _must_ be accessed as a series of 16-bit words, perform manual copy
	 * to ensure alignment */
	for (uint16_t i = 0; i < length; i += 2) {
     2be:	3302      	adds	r3, #2
     2c0:	b29b      	uxth	r3, r3
     2c2:	3602      	adds	r6, #2
     2c4:	429a      	cmp	r2, r3
     2c6:	d8f0      	bhi.n	2aa <nvm_write_buffer+0x62>
	}

	/* If automatic page write mode is enable, then perform a manual NVM
	 * write when the length of data to be programmed is less than page size
	 */
	if ((_nvm_dev.manual_page_write == false) && (length < NVMCTRL_PAGE_SIZE)) {
     2c8:	4b0e      	ldr	r3, [pc, #56]	; (304 <nvm_write_buffer+0xbc>)
     2ca:	791b      	ldrb	r3, [r3, #4]
		return nvm_execute_command(NVM_COMMAND_WRITE_PAGE,
				destination_address, 0);
#endif
	}

	return STATUS_OK;
     2cc:	2500      	movs	r5, #0
	}

	/* If automatic page write mode is enable, then perform a manual NVM
	 * write when the length of data to be programmed is less than page size
	 */
	if ((_nvm_dev.manual_page_write == false) && (length < NVMCTRL_PAGE_SIZE)) {
     2ce:	2b00      	cmp	r3, #0
     2d0:	d116      	bne.n	300 <nvm_write_buffer+0xb8>
     2d2:	2a3f      	cmp	r2, #63	; 0x3f
     2d4:	d814      	bhi.n	300 <nvm_write_buffer+0xb8>
#ifdef FEATURE_NVM_RWWEE
	 return ((is_rww_eeprom) ?
     2d6:	2f00      	cmp	r7, #0
     2d8:	d006      	beq.n	2e8 <nvm_write_buffer+0xa0>
     2da:	2200      	movs	r2, #0
     2dc:	0001      	movs	r1, r0
     2de:	201c      	movs	r0, #28
     2e0:	4b0d      	ldr	r3, [pc, #52]	; (318 <nvm_write_buffer+0xd0>)
     2e2:	4798      	blx	r3
     2e4:	0005      	movs	r5, r0
     2e6:	e00b      	b.n	300 <nvm_write_buffer+0xb8>
     2e8:	2200      	movs	r2, #0
     2ea:	0001      	movs	r1, r0
     2ec:	2004      	movs	r0, #4
     2ee:	4b0a      	ldr	r3, [pc, #40]	; (318 <nvm_write_buffer+0xd0>)
     2f0:	4798      	blx	r3
     2f2:	0005      	movs	r5, r0
     2f4:	e004      	b.n	300 <nvm_write_buffer+0xb8>
	}

	/* If automatic page write mode is enable, then perform a manual NVM
	 * write when the length of data to be programmed is less than page size
	 */
	if ((_nvm_dev.manual_page_write == false) && (length < NVMCTRL_PAGE_SIZE)) {
     2f6:	4b03      	ldr	r3, [pc, #12]	; (304 <nvm_write_buffer+0xbc>)
     2f8:	791b      	ldrb	r3, [r3, #4]
		return nvm_execute_command(NVM_COMMAND_WRITE_PAGE,
				destination_address, 0);
#endif
	}

	return STATUS_OK;
     2fa:	2500      	movs	r5, #0
	}

	/* If automatic page write mode is enable, then perform a manual NVM
	 * write when the length of data to be programmed is less than page size
	 */
	if ((_nvm_dev.manual_page_write == false) && (length < NVMCTRL_PAGE_SIZE)) {
     2fc:	2b00      	cmp	r3, #0
     2fe:	d0ea      	beq.n	2d6 <nvm_write_buffer+0x8e>
				destination_address, 0);
#endif
	}

	return STATUS_OK;
}
     300:	0028      	movs	r0, r5
     302:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     304:	200001c0 	.word	0x200001c0
     308:	00001fff 	.word	0x00001fff
     30c:	ffc00000 	.word	0xffc00000
     310:	41004000 	.word	0x41004000
     314:	ffffa544 	.word	0xffffa544
     318:	000001a1 	.word	0x000001a1

0000031c <nvm_read_buffer>:
 */
enum status_code nvm_read_buffer(
		const uint32_t source_address,
		uint8_t *const buffer,
		uint16_t length)
{
     31c:	b570      	push	{r4, r5, r6, lr}
	/* Check if the source address is valid */
	if (source_address >
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
     31e:	4b1c      	ldr	r3, [pc, #112]	; (390 <nvm_read_buffer+0x74>)
     320:	881c      	ldrh	r4, [r3, #0]
		const uint32_t source_address,
		uint8_t *const buffer,
		uint16_t length)
{
	/* Check if the source address is valid */
	if (source_address >
     322:	885b      	ldrh	r3, [r3, #2]
     324:	4363      	muls	r3, r4
     326:	4283      	cmp	r3, r0
     328:	d205      	bcs.n	336 <nvm_read_buffer+0x1a>
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
#ifdef FEATURE_NVM_RWWEE
		if (source_address >= ((uint32_t)NVMCTRL_RWW_EEPROM_SIZE + NVMCTRL_RWW_EEPROM_ADDR)
			|| source_address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
     32a:	2518      	movs	r5, #24
{
	/* Check if the source address is valid */
	if (source_address >
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
#ifdef FEATURE_NVM_RWWEE
		if (source_address >= ((uint32_t)NVMCTRL_RWW_EEPROM_SIZE + NVMCTRL_RWW_EEPROM_ADDR)
     32c:	4e19      	ldr	r6, [pc, #100]	; (394 <nvm_read_buffer+0x78>)
     32e:	4b1a      	ldr	r3, [pc, #104]	; (398 <nvm_read_buffer+0x7c>)
     330:	18c3      	adds	r3, r0, r3
     332:	42b3      	cmp	r3, r6
     334:	d829      	bhi.n	38a <nvm_read_buffer+0x6e>
		return STATUS_ERR_BAD_ADDRESS;
#endif
	}

	/* Check if the read address is not aligned to the start of a page */
	if (source_address & (_nvm_dev.page_size - 1)) {
     336:	1e63      	subs	r3, r4, #1
		return STATUS_ERR_BAD_ADDRESS;
     338:	2518      	movs	r5, #24
		return STATUS_ERR_BAD_ADDRESS;
#endif
	}

	/* Check if the read address is not aligned to the start of a page */
	if (source_address & (_nvm_dev.page_size - 1)) {
     33a:	4218      	tst	r0, r3
     33c:	d125      	bne.n	38a <nvm_read_buffer+0x6e>
		return STATUS_ERR_BAD_ADDRESS;
	}

	/* Check if the write length is longer than a NVM page */
	if (length > _nvm_dev.page_size) {
		return STATUS_ERR_INVALID_ARG;
     33e:	3d01      	subs	r5, #1
	if (source_address & (_nvm_dev.page_size - 1)) {
		return STATUS_ERR_BAD_ADDRESS;
	}

	/* Check if the write length is longer than a NVM page */
	if (length > _nvm_dev.page_size) {
     340:	4294      	cmp	r4, r2
     342:	d322      	bcc.n	38a <nvm_read_buffer+0x6e>
     344:	4b15      	ldr	r3, [pc, #84]	; (39c <nvm_read_buffer+0x80>)
     346:	7d1b      	ldrb	r3, [r3, #20]
	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
		return STATUS_BUSY;
     348:	3d12      	subs	r5, #18

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
     34a:	07db      	lsls	r3, r3, #31
     34c:	d51d      	bpl.n	38a <nvm_read_buffer+0x6e>
		return STATUS_BUSY;
	}

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
     34e:	4c13      	ldr	r4, [pc, #76]	; (39c <nvm_read_buffer+0x80>)
     350:	8b25      	ldrh	r5, [r4, #24]
     352:	2320      	movs	r3, #32
     354:	33ff      	adds	r3, #255	; 0xff
     356:	432b      	orrs	r3, r5
     358:	8323      	strh	r3, [r4, #24]

	uint32_t page_address = source_address / 2;
     35a:	0840      	lsrs	r0, r0, #1

	/* NVM _must_ be accessed as a series of 16-bit words, perform manual copy
	 * to ensure alignment */
	for (uint16_t i = 0; i < length; i += 2) {
     35c:	2a00      	cmp	r2, #0
     35e:	d013      	beq.n	388 <nvm_read_buffer+0x6c>
     360:	0040      	lsls	r0, r0, #1
     362:	2500      	movs	r5, #0
		/* Copy first byte of the 16-bit chunk to the destination buffer */
		buffer[i] = (data & 0xFF);

		/* If we are not at the end of a read request with an odd byte count,
		 * store the next byte of data as well */
		if (i < (length - 1)) {
     364:	1e56      	subs	r6, r2, #1
     366:	182b      	adds	r3, r5, r0

	/* NVM _must_ be accessed as a series of 16-bit words, perform manual copy
	 * to ensure alignment */
	for (uint16_t i = 0; i < length; i += 2) {
		/* Fetch next 16-bit chunk from the NVM memory space */
		uint16_t data = NVM_MEMORY[page_address++];
     368:	881c      	ldrh	r4, [r3, #0]
     36a:	b2a4      	uxth	r4, r4

		/* Copy first byte of the 16-bit chunk to the destination buffer */
		buffer[i] = (data & 0xFF);
     36c:	042b      	lsls	r3, r5, #16
     36e:	0c1b      	lsrs	r3, r3, #16
     370:	54cc      	strb	r4, [r1, r3]

		/* If we are not at the end of a read request with an odd byte count,
		 * store the next byte of data as well */
		if (i < (length - 1)) {
     372:	42b3      	cmp	r3, r6
     374:	da02      	bge.n	37c <nvm_read_buffer+0x60>
			buffer[i + 1] = (data >> 8);
     376:	18cb      	adds	r3, r1, r3
     378:	0a24      	lsrs	r4, r4, #8
     37a:	705c      	strb	r4, [r3, #1]
     37c:	3502      	adds	r5, #2

	uint32_t page_address = source_address / 2;

	/* NVM _must_ be accessed as a series of 16-bit words, perform manual copy
	 * to ensure alignment */
	for (uint16_t i = 0; i < length; i += 2) {
     37e:	b2ab      	uxth	r3, r5
     380:	429a      	cmp	r2, r3
     382:	d8f0      	bhi.n	366 <nvm_read_buffer+0x4a>
		if (i < (length - 1)) {
			buffer[i + 1] = (data >> 8);
		}
	}

	return STATUS_OK;
     384:	2500      	movs	r5, #0
     386:	e000      	b.n	38a <nvm_read_buffer+0x6e>
     388:	2500      	movs	r5, #0
}
     38a:	0028      	movs	r0, r5
     38c:	bd70      	pop	{r4, r5, r6, pc}
     38e:	46c0      	nop			; (mov r8, r8)
     390:	200001c0 	.word	0x200001c0
     394:	00001fff 	.word	0x00001fff
     398:	ffc00000 	.word	0xffc00000
     39c:	41004000 	.word	0x41004000

000003a0 <nvm_erase_row>:
 *                                 acceptable range of the NVM memory region or
 *                                 not aligned to the start of a row
 */
enum status_code nvm_erase_row(
		const uint32_t row_address)
{
     3a0:	b510      	push	{r4, lr}
		bool is_rww_eeprom = false;
#endif

	/* Check if the row address is valid */
	if (row_address >
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
     3a2:	4a18      	ldr	r2, [pc, #96]	; (404 <nvm_erase_row+0x64>)
     3a4:	8813      	ldrh	r3, [r2, #0]
#ifdef FEATURE_NVM_RWWEE
		bool is_rww_eeprom = false;
#endif

	/* Check if the row address is valid */
	if (row_address >
     3a6:	8852      	ldrh	r2, [r2, #2]
     3a8:	435a      	muls	r2, r3
     3aa:	4282      	cmp	r2, r0
     3ac:	d207      	bcs.n	3be <nvm_erase_row+0x1e>
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
#ifdef FEATURE_NVM_RWWEE
		if (row_address >= ((uint32_t)NVMCTRL_RWW_EEPROM_SIZE + NVMCTRL_RWW_EEPROM_ADDR)
			|| row_address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
     3ae:	2218      	movs	r2, #24

	/* Check if the row address is valid */
	if (row_address >
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
#ifdef FEATURE_NVM_RWWEE
		if (row_address >= ((uint32_t)NVMCTRL_RWW_EEPROM_SIZE + NVMCTRL_RWW_EEPROM_ADDR)
     3b0:	4c15      	ldr	r4, [pc, #84]	; (408 <nvm_erase_row+0x68>)
     3b2:	4916      	ldr	r1, [pc, #88]	; (40c <nvm_erase_row+0x6c>)
     3b4:	1841      	adds	r1, r0, r1
     3b6:	42a1      	cmp	r1, r4
     3b8:	d822      	bhi.n	400 <nvm_erase_row+0x60>
			|| row_address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
		}
		is_rww_eeprom = true;
     3ba:	2101      	movs	r1, #1
     3bc:	e000      	b.n	3c0 <nvm_erase_row+0x20>
 */
enum status_code nvm_erase_row(
		const uint32_t row_address)
{
#ifdef FEATURE_NVM_RWWEE
		bool is_rww_eeprom = false;
     3be:	2100      	movs	r1, #0
		return STATUS_ERR_BAD_ADDRESS;
#endif
	}

	/* Check if the address to erase is not aligned to the start of a row */
	if (row_address & ((_nvm_dev.page_size * NVMCTRL_ROW_PAGES) - 1)) {
     3c0:	009b      	lsls	r3, r3, #2
     3c2:	3b01      	subs	r3, #1
		return STATUS_ERR_BAD_ADDRESS;
     3c4:	2218      	movs	r2, #24
		return STATUS_ERR_BAD_ADDRESS;
#endif
	}

	/* Check if the address to erase is not aligned to the start of a row */
	if (row_address & ((_nvm_dev.page_size * NVMCTRL_ROW_PAGES) - 1)) {
     3c6:	4218      	tst	r0, r3
     3c8:	d11a      	bne.n	400 <nvm_erase_row+0x60>
     3ca:	4b11      	ldr	r3, [pc, #68]	; (410 <nvm_erase_row+0x70>)
     3cc:	7d1b      	ldrb	r3, [r3, #20]
	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
		return STATUS_BUSY;
     3ce:	3a13      	subs	r2, #19

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
     3d0:	07db      	lsls	r3, r3, #31
     3d2:	d515      	bpl.n	400 <nvm_erase_row+0x60>
		return STATUS_BUSY;
	}

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
     3d4:	4b0e      	ldr	r3, [pc, #56]	; (410 <nvm_erase_row+0x70>)
     3d6:	8b1c      	ldrh	r4, [r3, #24]
     3d8:	2220      	movs	r2, #32
     3da:	32ff      	adds	r2, #255	; 0xff
     3dc:	4322      	orrs	r2, r4
     3de:	831a      	strh	r2, [r3, #24]

	/* Set address and command */
	nvm_module->ADDR.reg  = (uintptr_t)&NVM_MEMORY[row_address / 4];
     3e0:	0880      	lsrs	r0, r0, #2
     3e2:	0040      	lsls	r0, r0, #1
     3e4:	61d8      	str	r0, [r3, #28]
		NVM_MEMORY[row_address / 2] = 0x0;
	}
#endif

#ifdef FEATURE_NVM_RWWEE
	nvm_module->CTRLA.reg = ((is_rww_eeprom) ?
     3e6:	2900      	cmp	r1, #0
     3e8:	d101      	bne.n	3ee <nvm_erase_row+0x4e>
     3ea:	4a0a      	ldr	r2, [pc, #40]	; (414 <nvm_erase_row+0x74>)
     3ec:	e000      	b.n	3f0 <nvm_erase_row+0x50>
     3ee:	4a0a      	ldr	r2, [pc, #40]	; (418 <nvm_erase_row+0x78>)
     3f0:	4b07      	ldr	r3, [pc, #28]	; (410 <nvm_erase_row+0x70>)
     3f2:	801a      	strh	r2, [r3, #0]
     3f4:	0019      	movs	r1, r3
								(NVM_COMMAND_ERASE_ROW | NVMCTRL_CTRLA_CMDEX_KEY));
#else
	nvm_module->CTRLA.reg = NVM_COMMAND_ERASE_ROW | NVMCTRL_CTRLA_CMDEX_KEY;
#endif

	while (!nvm_is_ready()) {
     3f6:	2201      	movs	r2, #1
     3f8:	7d0b      	ldrb	r3, [r1, #20]
     3fa:	4213      	tst	r3, r2
     3fc:	d0fc      	beq.n	3f8 <nvm_erase_row+0x58>
	}

	return STATUS_OK;
     3fe:	2200      	movs	r2, #0
}
     400:	0010      	movs	r0, r2
     402:	bd10      	pop	{r4, pc}
     404:	200001c0 	.word	0x200001c0
     408:	00001fff 	.word	0x00001fff
     40c:	ffc00000 	.word	0xffc00000
     410:	41004000 	.word	0x41004000
     414:	0000a502 	.word	0x0000a502
     418:	0000a51a 	.word	0x0000a51a

0000041c <nvm_get_parameters>:

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
     41c:	4b16      	ldr	r3, [pc, #88]	; (478 <nvm_get_parameters+0x5c>)
     41e:	8b19      	ldrh	r1, [r3, #24]
     420:	2220      	movs	r2, #32
     422:	32ff      	adds	r2, #255	; 0xff
     424:	430a      	orrs	r2, r1
     426:	831a      	strh	r2, [r3, #24]

	/* Read out from the PARAM register */
	uint32_t param_reg = nvm_module->PARAM.reg;
     428:	689b      	ldr	r3, [r3, #8]

	/* Mask out page size exponent and convert to a number of bytes */
	parameters->page_size =
     42a:	0359      	lsls	r1, r3, #13
     42c:	0f49      	lsrs	r1, r1, #29
     42e:	2208      	movs	r2, #8
     430:	408a      	lsls	r2, r1
     432:	7002      	strb	r2, [r0, #0]
			8 << ((param_reg & NVMCTRL_PARAM_PSZ_Msk) >> NVMCTRL_PARAM_PSZ_Pos);

	/* Mask out number of pages count */
	parameters->nvm_number_of_pages =
     434:	8043      	strh	r3, [r0, #2]
			(param_reg & NVMCTRL_PARAM_NVMP_Msk) >> NVMCTRL_PARAM_NVMP_Pos;

#ifdef FEATURE_NVM_RWWEE
	/* Mask out rwwee number of pages count */
	parameters->rww_eeprom_number_of_pages =
     436:	0d1b      	lsrs	r3, r3, #20
     438:	8183      	strh	r3, [r0, #12]
			(param_reg & NVMCTRL_PARAM_RWWEEP_Msk) >> NVMCTRL_PARAM_RWWEEP_Pos;
#endif

	/* Read the current EEPROM fuse value from the USER row */
	uint16_t eeprom_fuse_value =
			(NVM_USER_MEMORY[NVMCTRL_FUSES_EEPROM_SIZE_Pos / 16] &
     43a:	4b10      	ldr	r3, [pc, #64]	; (47c <nvm_get_parameters+0x60>)
     43c:	881b      	ldrh	r3, [r3, #0]
			NVMCTRL_FUSES_EEPROM_SIZE_Msk) >> NVMCTRL_FUSES_EEPROM_SIZE_Pos;
     43e:	065b      	lsls	r3, r3, #25
     440:	0f5b      	lsrs	r3, r3, #29

	/* Translate the EEPROM fuse byte value to a number of NVM pages */
	if (eeprom_fuse_value == 7) {
     442:	b29a      	uxth	r2, r3
     444:	2a07      	cmp	r2, #7
     446:	d102      	bne.n	44e <nvm_get_parameters+0x32>
		parameters->eeprom_number_of_pages = 0;
     448:	2300      	movs	r3, #0
     44a:	6043      	str	r3, [r0, #4]
     44c:	e004      	b.n	458 <nvm_get_parameters+0x3c>
	}
	else {
		parameters->eeprom_number_of_pages =
     44e:	2206      	movs	r2, #6
     450:	1ad2      	subs	r2, r2, r3
     452:	2304      	movs	r3, #4
     454:	4093      	lsls	r3, r2
     456:	6043      	str	r3, [r0, #4]
				NVMCTRL_ROW_PAGES << (6 - eeprom_fuse_value);
	}

	/* Read the current BOOTSZ fuse value from the USER row */
	uint16_t boot_fuse_value =
			(NVM_USER_MEMORY[NVMCTRL_FUSES_BOOTPROT_Pos / 16] &
     458:	4b08      	ldr	r3, [pc, #32]	; (47c <nvm_get_parameters+0x60>)
     45a:	881a      	ldrh	r2, [r3, #0]
		parameters->eeprom_number_of_pages =
				NVMCTRL_ROW_PAGES << (6 - eeprom_fuse_value);
	}

	/* Read the current BOOTSZ fuse value from the USER row */
	uint16_t boot_fuse_value =
     45c:	2307      	movs	r3, #7
     45e:	4013      	ands	r3, r2
			(NVM_USER_MEMORY[NVMCTRL_FUSES_BOOTPROT_Pos / 16] &
			NVMCTRL_FUSES_BOOTPROT_Msk) >> NVMCTRL_FUSES_BOOTPROT_Pos;

	/* Translate the BOOTSZ fuse byte value to a number of NVM pages */
	if (boot_fuse_value == 7) {
     460:	2b07      	cmp	r3, #7
     462:	d102      	bne.n	46a <nvm_get_parameters+0x4e>
		parameters->bootloader_number_of_pages = 0;
     464:	2300      	movs	r3, #0
     466:	6083      	str	r3, [r0, #8]
     468:	e004      	b.n	474 <nvm_get_parameters+0x58>
	}
	else {
		parameters->bootloader_number_of_pages =
     46a:	2207      	movs	r2, #7
     46c:	1ad2      	subs	r2, r2, r3
     46e:	2304      	movs	r3, #4
     470:	4093      	lsls	r3, r2
     472:	6083      	str	r3, [r0, #8]
				NVMCTRL_ROW_PAGES << (7 - boot_fuse_value);
	}
}
     474:	4770      	bx	lr
     476:	46c0      	nop			; (mov r8, r8)
     478:	41004000 	.word	0x41004000
     47c:	00804000 	.word	0x00804000

00000480 <initialise_button>:
extern uint8 gDefaultKey[M2M_MAX_PSK_LEN];
extern uint8 gUuid[AWS_COGNITO_UUID_LEN];


void initialise_button(void)
{
     480:	b530      	push	{r4, r5, lr}
     482:	b083      	sub	sp, #12
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
     484:	ac01      	add	r4, sp, #4
     486:	2300      	movs	r3, #0
     488:	7023      	strb	r3, [r4, #0]
	config->input_pull = PORT_PIN_PULL_UP;
	config->powersave  = false;
     48a:	70a3      	strb	r3, [r4, #2]
	
	/* Set buttons as inputs */
	struct port_config config_port_pin;
	port_get_config_defaults(&config_port_pin);
	config_port_pin.direction = PORT_PIN_DIR_INPUT;
	config_port_pin.input_pull = PORT_PIN_PULL_DOWN;
     48c:	3302      	adds	r3, #2
     48e:	7063      	strb	r3, [r4, #1]
	port_pin_set_config(SW1_PIN, &config_port_pin);
     490:	0021      	movs	r1, r4
     492:	200b      	movs	r0, #11
     494:	4d04      	ldr	r5, [pc, #16]	; (4a8 <initialise_button+0x28>)
     496:	47a8      	blx	r5
	port_pin_set_config(SW2_PIN, &config_port_pin);
     498:	0021      	movs	r1, r4
     49a:	202a      	movs	r0, #42	; 0x2a
     49c:	47a8      	blx	r5
	port_pin_set_config(SW3_PIN, &config_port_pin);
     49e:	0021      	movs	r1, r4
     4a0:	202b      	movs	r0, #43	; 0x2b
     4a2:	47a8      	blx	r5

}
     4a4:	b003      	add	sp, #12
     4a6:	bd30      	pop	{r4, r5, pc}
     4a8:	0000c7c5 	.word	0x0000c7c5

000004ac <buttonInitCheck>:

void buttonInitCheck()
{
     4ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		const uint8_t gpio_pin)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	return (port_base->IN.reg & pin_mask);
     4ae:	4b26      	ldr	r3, [pc, #152]	; (548 <buttonInitCheck+0x9c>)
     4b0:	6a1b      	ldr	r3, [r3, #32]
	
	if(SW2_ACTIVE == port_pin_get_input_level(SW2_PIN)){	// Enter WINC1500 FW programming mode
     4b2:	055b      	lsls	r3, r3, #21
     4b4:	d504      	bpl.n	4c0 <buttonInitCheck+0x14>
		
		led_ctrl_set_color(LED_COLOR_GREEN, LED_MODE_BLINK_NORMAL);
     4b6:	2103      	movs	r1, #3
     4b8:	2001      	movs	r0, #1
     4ba:	4b24      	ldr	r3, [pc, #144]	; (54c <buttonInitCheck+0xa0>)
     4bc:	4798      	blx	r3
     4be:	e7fe      	b.n	4be <buttonInitCheck+0x12>
     4c0:	4b23      	ldr	r3, [pc, #140]	; (550 <buttonInitCheck+0xa4>)
     4c2:	6a1b      	ldr	r3, [r3, #32]
		while(1) {
			
		}
	}
	
	if(SW1_ACTIVE == port_pin_get_input_level(SW1_PIN)){
     4c4:	051b      	lsls	r3, r3, #20
     4c6:	d506      	bpl.n	4d6 <buttonInitCheck+0x2a>
		setWiFiStates(WIFI_TASK_SWITCH_TO_AP);
     4c8:	2006      	movs	r0, #6
     4ca:	4b22      	ldr	r3, [pc, #136]	; (554 <buttonInitCheck+0xa8>)
     4cc:	4798      	blx	r3
		printf("Set as AP mode\r\n");
     4ce:	4822      	ldr	r0, [pc, #136]	; (558 <buttonInitCheck+0xac>)
     4d0:	4b22      	ldr	r3, [pc, #136]	; (55c <buttonInitCheck+0xb0>)
     4d2:	4798      	blx	r3
     4d4:	e036      	b.n	544 <buttonInitCheck+0x98>
		//{
		//	memset((uint32_t*)&whiteListDevices,0,sizeof(whiteListDevices));
		//	nv_flash_write(WHITE_LIST_PAGE_ADDRESS,WHITE_LIST_PAGE,(uint32_t*)(&whiteListDevices),sizeof(whiteListDevices));
		//}
		#if 1
		printf("Read config page\r\n");
     4d6:	4822      	ldr	r0, [pc, #136]	; (560 <buttonInitCheck+0xb4>)
     4d8:	4b20      	ldr	r3, [pc, #128]	; (55c <buttonInitCheck+0xb0>)
     4da:	4798      	blx	r3
		nvm_get_config_data(&wifi_nvm_data);
     4dc:	4c21      	ldr	r4, [pc, #132]	; (564 <buttonInitCheck+0xb8>)
     4de:	0020      	movs	r0, r4
     4e0:	4b21      	ldr	r3, [pc, #132]	; (568 <buttonInitCheck+0xbc>)
     4e2:	4798      	blx	r3
		//nv_flash_read(CONFIG_PAGE_ADDRESS,CONFIG_PAGE,(uint32_t*)(&wifi_nvm_data),sizeof(wifi_nvm_data));
		
		if (wifi_nvm_data.ssid[0] != 0xFF && wifi_nvm_data.ssid[0] != 0)
     4e4:	7863      	ldrb	r3, [r4, #1]
     4e6:	3b01      	subs	r3, #1
     4e8:	b2db      	uxtb	r3, r3
     4ea:	2bfd      	cmp	r3, #253	; 0xfd
     4ec:	d82a      	bhi.n	544 <buttonInitCheck+0x98>
		{
			
			printf("ssid=%s, ssidlen=%d\r\n", wifi_nvm_data.ssid, wifi_nvm_data.ssidlen);
     4ee:	4c1d      	ldr	r4, [pc, #116]	; (564 <buttonInitCheck+0xb8>)
     4f0:	2722      	movs	r7, #34	; 0x22
     4f2:	5de2      	ldrb	r2, [r4, r7]
     4f4:	1c66      	adds	r6, r4, #1
     4f6:	0031      	movs	r1, r6
     4f8:	481c      	ldr	r0, [pc, #112]	; (56c <buttonInitCheck+0xc0>)
     4fa:	4d1d      	ldr	r5, [pc, #116]	; (570 <buttonInitCheck+0xc4>)
     4fc:	47a8      	blx	r5
			memcpy(gDefaultSSID, wifi_nvm_data.ssid, wifi_nvm_data.ssidlen);
     4fe:	5de2      	ldrb	r2, [r4, r7]
     500:	0031      	movs	r1, r6
     502:	481c      	ldr	r0, [pc, #112]	; (574 <buttonInitCheck+0xc8>)
     504:	4e1c      	ldr	r6, [pc, #112]	; (578 <buttonInitCheck+0xcc>)
     506:	47b0      	blx	r6
			printf("key=%s, keylen=%d\r\n", wifi_nvm_data.key, wifi_nvm_data.keylen);
     508:	3742      	adds	r7, #66	; 0x42
     50a:	5de2      	ldrb	r2, [r4, r7]
     50c:	491b      	ldr	r1, [pc, #108]	; (57c <buttonInitCheck+0xd0>)
     50e:	481c      	ldr	r0, [pc, #112]	; (580 <buttonInitCheck+0xd4>)
     510:	47a8      	blx	r5
			memcpy(gDefaultKey, wifi_nvm_data.key, wifi_nvm_data.keylen);
     512:	5de2      	ldrb	r2, [r4, r7]
     514:	4919      	ldr	r1, [pc, #100]	; (57c <buttonInitCheck+0xd0>)
     516:	481b      	ldr	r0, [pc, #108]	; (584 <buttonInitCheck+0xd8>)
     518:	47b0      	blx	r6
			printf("gAuthType=%d\r\n", wifi_nvm_data.authtype);
     51a:	3701      	adds	r7, #1
     51c:	5de1      	ldrb	r1, [r4, r7]
     51e:	481a      	ldr	r0, [pc, #104]	; (588 <buttonInitCheck+0xdc>)
     520:	47a8      	blx	r5
			gAuthType = wifi_nvm_data.authtype;
     522:	5de2      	ldrb	r2, [r4, r7]
     524:	4b19      	ldr	r3, [pc, #100]	; (58c <buttonInitCheck+0xe0>)
     526:	701a      	strb	r2, [r3, #0]
		
			printf("gUuid=%s, len=%d\r\n", wifi_nvm_data.uuid, strlen((const char*) wifi_nvm_data.uuid));
     528:	3466      	adds	r4, #102	; 0x66
     52a:	0020      	movs	r0, r4
     52c:	4f18      	ldr	r7, [pc, #96]	; (590 <buttonInitCheck+0xe4>)
     52e:	47b8      	blx	r7
     530:	0002      	movs	r2, r0
     532:	0021      	movs	r1, r4
     534:	4817      	ldr	r0, [pc, #92]	; (594 <buttonInitCheck+0xe8>)
     536:	47a8      	blx	r5
			memcpy(gUuid, wifi_nvm_data.uuid, strlen((const char*) wifi_nvm_data.uuid));
     538:	0020      	movs	r0, r4
     53a:	47b8      	blx	r7
     53c:	0002      	movs	r2, r0
     53e:	0021      	movs	r1, r4
     540:	4815      	ldr	r0, [pc, #84]	; (598 <buttonInitCheck+0xec>)
     542:	47b0      	blx	r6
		}
		#endif
	}
}
     544:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     546:	46c0      	nop			; (mov r8, r8)
     548:	40002880 	.word	0x40002880
     54c:	00002b19 	.word	0x00002b19
     550:	40002800 	.word	0x40002800
     554:	000039e1 	.word	0x000039e1
     558:	00012e90 	.word	0x00012e90
     55c:	00011aad 	.word	0x00011aad
     560:	00012ea0 	.word	0x00012ea0
     564:	20000244 	.word	0x20000244
     568:	00002e25 	.word	0x00002e25
     56c:	00012eb4 	.word	0x00012eb4
     570:	0001198d 	.word	0x0001198d
     574:	200008a4 	.word	0x200008a4
     578:	00011833 	.word	0x00011833
     57c:	20000267 	.word	0x20000267
     580:	00012ecc 	.word	0x00012ecc
     584:	200001f8 	.word	0x200001f8
     588:	00012ee0 	.word	0x00012ee0
     58c:	200002e8 	.word	0x200002e8
     590:	00011d75 	.word	0x00011d75
     594:	00012ef0 	.word	0x00012ef0
     598:	20000868 	.word	0x20000868

0000059c <cJSON_strcasecmp>:
static const char *ep;

const char *cJSON_GetErrorPtr(void) {return ep;}

static int cJSON_strcasecmp(const char *s1,const char *s2)
{
     59c:	b5f0      	push	{r4, r5, r6, r7, lr}
     59e:	4647      	mov	r7, r8
     5a0:	b480      	push	{r7}
	if (!s1) return (s1==s2)?0:1;if (!s2) return 1;
     5a2:	2800      	cmp	r0, #0
     5a4:	d103      	bne.n	5ae <cJSON_strcasecmp+0x12>
     5a6:	0008      	movs	r0, r1
     5a8:	1e41      	subs	r1, r0, #1
     5aa:	4188      	sbcs	r0, r1
     5ac:	e02f      	b.n	60e <cJSON_strcasecmp+0x72>
     5ae:	2900      	cmp	r1, #0
     5b0:	d02a      	beq.n	608 <cJSON_strcasecmp+0x6c>
	for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)	if(*s1 == 0)	return 0;
     5b2:	4b18      	ldr	r3, [pc, #96]	; (614 <cJSON_strcasecmp+0x78>)
     5b4:	681b      	ldr	r3, [r3, #0]
     5b6:	4698      	mov	r8, r3
     5b8:	2303      	movs	r3, #3
     5ba:	469c      	mov	ip, r3
     5bc:	e003      	b.n	5c6 <cJSON_strcasecmp+0x2a>
     5be:	2b00      	cmp	r3, #0
     5c0:	d024      	beq.n	60c <cJSON_strcasecmp+0x70>
     5c2:	3001      	adds	r0, #1
     5c4:	3101      	adds	r1, #1
     5c6:	7803      	ldrb	r3, [r0, #0]
     5c8:	4642      	mov	r2, r8
     5ca:	18d2      	adds	r2, r2, r3
     5cc:	7854      	ldrb	r4, [r2, #1]
     5ce:	4662      	mov	r2, ip
     5d0:	4014      	ands	r4, r2
     5d2:	001f      	movs	r7, r3
     5d4:	2c01      	cmp	r4, #1
     5d6:	d100      	bne.n	5da <cJSON_strcasecmp+0x3e>
     5d8:	3720      	adds	r7, #32
     5da:	780d      	ldrb	r5, [r1, #0]
     5dc:	4642      	mov	r2, r8
     5de:	1952      	adds	r2, r2, r5
     5e0:	7852      	ldrb	r2, [r2, #1]
     5e2:	4666      	mov	r6, ip
     5e4:	4032      	ands	r2, r6
     5e6:	002e      	movs	r6, r5
     5e8:	2a01      	cmp	r2, #1
     5ea:	d100      	bne.n	5ee <cJSON_strcasecmp+0x52>
     5ec:	3620      	adds	r6, #32
     5ee:	42b7      	cmp	r7, r6
     5f0:	d0e5      	beq.n	5be <cJSON_strcasecmp+0x22>
	return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);
     5f2:	0019      	movs	r1, r3
     5f4:	2c01      	cmp	r4, #1
     5f6:	d101      	bne.n	5fc <cJSON_strcasecmp+0x60>
     5f8:	3320      	adds	r3, #32
     5fa:	0019      	movs	r1, r3
     5fc:	0028      	movs	r0, r5
     5fe:	2a01      	cmp	r2, #1
     600:	d100      	bne.n	604 <cJSON_strcasecmp+0x68>
     602:	3020      	adds	r0, #32
     604:	1a08      	subs	r0, r1, r0
     606:	e002      	b.n	60e <cJSON_strcasecmp+0x72>

const char *cJSON_GetErrorPtr(void) {return ep;}

static int cJSON_strcasecmp(const char *s1,const char *s2)
{
	if (!s1) return (s1==s2)?0:1;if (!s2) return 1;
     608:	2001      	movs	r0, #1
     60a:	e000      	b.n	60e <cJSON_strcasecmp+0x72>
	for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)	if(*s1 == 0)	return 0;
     60c:	2000      	movs	r0, #0
	return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);
}
     60e:	bc04      	pop	{r2}
     610:	4690      	mov	r8, r2
     612:	bdf0      	pop	{r4, r5, r6, r7, pc}
     614:	2000013c 	.word	0x2000013c

00000618 <parse_hex4>:
	}
	return str;
}

static unsigned parse_hex4(const char *str)
{
     618:	b510      	push	{r4, lr}
     61a:	0001      	movs	r1, r0
	unsigned h=0;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
     61c:	7803      	ldrb	r3, [r0, #0]
     61e:	001a      	movs	r2, r3
     620:	3a30      	subs	r2, #48	; 0x30
     622:	2a09      	cmp	r2, #9
     624:	d801      	bhi.n	62a <parse_hex4+0x12>
     626:	0013      	movs	r3, r2
     628:	e00b      	b.n	642 <parse_hex4+0x2a>
     62a:	001a      	movs	r2, r3
     62c:	3a41      	subs	r2, #65	; 0x41
     62e:	2a05      	cmp	r2, #5
     630:	d801      	bhi.n	636 <parse_hex4+0x1e>
     632:	3b37      	subs	r3, #55	; 0x37
     634:	e005      	b.n	642 <parse_hex4+0x2a>
     636:	2000      	movs	r0, #0
     638:	001a      	movs	r2, r3
     63a:	3a61      	subs	r2, #97	; 0x61
     63c:	2a05      	cmp	r2, #5
     63e:	d842      	bhi.n	6c6 <parse_hex4+0xae>
     640:	3b57      	subs	r3, #87	; 0x57
	h=h<<4;str++;
     642:	011b      	lsls	r3, r3, #4
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
     644:	784a      	ldrb	r2, [r1, #1]
     646:	0010      	movs	r0, r2
     648:	3830      	subs	r0, #48	; 0x30
     64a:	2809      	cmp	r0, #9
     64c:	d801      	bhi.n	652 <parse_hex4+0x3a>
     64e:	18c3      	adds	r3, r0, r3
     650:	e00d      	b.n	66e <parse_hex4+0x56>
     652:	0010      	movs	r0, r2
     654:	3841      	subs	r0, #65	; 0x41
     656:	2805      	cmp	r0, #5
     658:	d802      	bhi.n	660 <parse_hex4+0x48>
     65a:	3a37      	subs	r2, #55	; 0x37
     65c:	18d3      	adds	r3, r2, r3
     65e:	e006      	b.n	66e <parse_hex4+0x56>
     660:	2000      	movs	r0, #0
     662:	0014      	movs	r4, r2
     664:	3c61      	subs	r4, #97	; 0x61
     666:	2c05      	cmp	r4, #5
     668:	d82d      	bhi.n	6c6 <parse_hex4+0xae>
     66a:	3a57      	subs	r2, #87	; 0x57
     66c:	18d3      	adds	r3, r2, r3
	h=h<<4;str++;
     66e:	011b      	lsls	r3, r3, #4
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
     670:	788a      	ldrb	r2, [r1, #2]
     672:	0010      	movs	r0, r2
     674:	3830      	subs	r0, #48	; 0x30
     676:	2809      	cmp	r0, #9
     678:	d801      	bhi.n	67e <parse_hex4+0x66>
     67a:	18c3      	adds	r3, r0, r3
     67c:	e00d      	b.n	69a <parse_hex4+0x82>
     67e:	0010      	movs	r0, r2
     680:	3841      	subs	r0, #65	; 0x41
     682:	2805      	cmp	r0, #5
     684:	d802      	bhi.n	68c <parse_hex4+0x74>
     686:	3a37      	subs	r2, #55	; 0x37
     688:	18d3      	adds	r3, r2, r3
     68a:	e006      	b.n	69a <parse_hex4+0x82>
     68c:	2000      	movs	r0, #0
     68e:	0014      	movs	r4, r2
     690:	3c61      	subs	r4, #97	; 0x61
     692:	2c05      	cmp	r4, #5
     694:	d817      	bhi.n	6c6 <parse_hex4+0xae>
     696:	3a57      	subs	r2, #87	; 0x57
     698:	18d3      	adds	r3, r2, r3
	h=h<<4;str++;
     69a:	011b      	lsls	r3, r3, #4
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
     69c:	78ca      	ldrb	r2, [r1, #3]
     69e:	0011      	movs	r1, r2
     6a0:	3930      	subs	r1, #48	; 0x30
     6a2:	2909      	cmp	r1, #9
     6a4:	d801      	bhi.n	6aa <parse_hex4+0x92>
     6a6:	18c8      	adds	r0, r1, r3
     6a8:	e00d      	b.n	6c6 <parse_hex4+0xae>
     6aa:	0011      	movs	r1, r2
     6ac:	3941      	subs	r1, #65	; 0x41
     6ae:	2905      	cmp	r1, #5
     6b0:	d802      	bhi.n	6b8 <parse_hex4+0xa0>
     6b2:	3a37      	subs	r2, #55	; 0x37
     6b4:	18d0      	adds	r0, r2, r3
     6b6:	e006      	b.n	6c6 <parse_hex4+0xae>
     6b8:	2000      	movs	r0, #0
     6ba:	0011      	movs	r1, r2
     6bc:	3961      	subs	r1, #97	; 0x61
     6be:	2905      	cmp	r1, #5
     6c0:	d801      	bhi.n	6c6 <parse_hex4+0xae>
     6c2:	3a57      	subs	r2, #87	; 0x57
     6c4:	18d0      	adds	r0, r2, r3
	return h;
}
     6c6:	bd10      	pop	{r4, pc}

000006c8 <parse_string>:

/* Parse the input text into an unescaped cstring, and populate item. */
static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
static const char *parse_string(cJSON *item,const char *str)
{
     6c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     6ca:	465f      	mov	r7, fp
     6cc:	4656      	mov	r6, sl
     6ce:	464d      	mov	r5, r9
     6d0:	4644      	mov	r4, r8
     6d2:	b4f0      	push	{r4, r5, r6, r7}
     6d4:	0007      	movs	r7, r0
	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
     6d6:	1c4c      	adds	r4, r1, #1
	if (*str!='\"') {ep=str;return 0;}	/* not a string! */
     6d8:	780b      	ldrb	r3, [r1, #0]
     6da:	2b22      	cmp	r3, #34	; 0x22
     6dc:	d00a      	beq.n	6f4 <parse_string+0x2c>
     6de:	4b68      	ldr	r3, [pc, #416]	; (880 <parse_string+0x1b8>)
     6e0:	6019      	str	r1, [r3, #0]
     6e2:	2000      	movs	r0, #0
     6e4:	e0c6      	b.n	874 <parse_string+0x1ac>
	
	while (*ptr!='\"' && *ptr && ++len) if (*ptr++ == '\\') ptr++;	/* Skip escaped quotes. */
     6e6:	2b5c      	cmp	r3, #92	; 0x5c
     6e8:	d001      	beq.n	6ee <parse_string+0x26>
     6ea:	3101      	adds	r1, #1
     6ec:	e000      	b.n	6f0 <parse_string+0x28>
     6ee:	3102      	adds	r1, #2
     6f0:	3201      	adds	r2, #1
     6f2:	e001      	b.n	6f8 <parse_string+0x30>
     6f4:	0021      	movs	r1, r4
     6f6:	2200      	movs	r2, #0
     6f8:	0010      	movs	r0, r2
     6fa:	780b      	ldrb	r3, [r1, #0]
     6fc:	2b22      	cmp	r3, #34	; 0x22
     6fe:	d004      	beq.n	70a <parse_string+0x42>
     700:	2b00      	cmp	r3, #0
     702:	d002      	beq.n	70a <parse_string+0x42>
     704:	1c50      	adds	r0, r2, #1
     706:	d1ee      	bne.n	6e6 <parse_string+0x1e>
     708:	2000      	movs	r0, #0
	
	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
     70a:	3001      	adds	r0, #1
     70c:	4b5d      	ldr	r3, [pc, #372]	; (884 <parse_string+0x1bc>)
     70e:	681b      	ldr	r3, [r3, #0]
     710:	4798      	blx	r3
     712:	1e06      	subs	r6, r0, #0
	if (!out) return 0;
     714:	d100      	bne.n	718 <parse_string+0x50>
     716:	e091      	b.n	83c <parse_string+0x174>
     718:	0005      	movs	r5, r0
				case 'r': *ptr2++='\r';	break;
				case 't': *ptr2++='\t';	break;
				case 'u':	 /* transcode utf16 to utf8. */
					uc=parse_hex4(ptr+1);ptr+=4;	/* get the unicode char. */

					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)	break;	/* check for invalid.	*/
     71a:	4b5b      	ldr	r3, [pc, #364]	; (888 <parse_string+0x1c0>)
     71c:	469a      	mov	sl, r3
						uc2=parse_hex4(ptr+3);ptr+=6;
						if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/
						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
					}

					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
     71e:	4b5b      	ldr	r3, [pc, #364]	; (88c <parse_string+0x1c4>)
     720:	469b      	mov	fp, r3
     722:	2302      	movs	r3, #2
     724:	4698      	mov	r8, r3
     726:	e079      	b.n	81c <parse_string+0x154>
	if (!out) return 0;
	
	ptr=str+1;ptr2=out;
	while (*ptr!='\"' && *ptr)
	{
		if (*ptr!='\\') *ptr2++=*ptr++;
     728:	2b5c      	cmp	r3, #92	; 0x5c
     72a:	d003      	beq.n	734 <parse_string+0x6c>
     72c:	3401      	adds	r4, #1
     72e:	702b      	strb	r3, [r5, #0]
     730:	3501      	adds	r5, #1
     732:	e073      	b.n	81c <parse_string+0x154>
		else
		{
			ptr++;
     734:	1c62      	adds	r2, r4, #1
			switch (*ptr)
     736:	7861      	ldrb	r1, [r4, #1]
     738:	000b      	movs	r3, r1
     73a:	3b62      	subs	r3, #98	; 0x62
     73c:	b2d8      	uxtb	r0, r3
     73e:	2813      	cmp	r0, #19
     740:	d869      	bhi.n	816 <parse_string+0x14e>
     742:	0083      	lsls	r3, r0, #2
     744:	4852      	ldr	r0, [pc, #328]	; (890 <parse_string+0x1c8>)
     746:	58c3      	ldr	r3, [r0, r3]
     748:	469f      	mov	pc, r3
			{
				case 'b': *ptr2++='\b';	break;
     74a:	2308      	movs	r3, #8
     74c:	702b      	strb	r3, [r5, #0]
     74e:	3501      	adds	r5, #1
     750:	e063      	b.n	81a <parse_string+0x152>
				case 'f': *ptr2++='\f';	break;
     752:	230c      	movs	r3, #12
     754:	702b      	strb	r3, [r5, #0]
     756:	3501      	adds	r5, #1
     758:	e05f      	b.n	81a <parse_string+0x152>
				case 'n': *ptr2++='\n';	break;
     75a:	230a      	movs	r3, #10
     75c:	702b      	strb	r3, [r5, #0]
     75e:	3501      	adds	r5, #1
     760:	e05b      	b.n	81a <parse_string+0x152>
				case 'r': *ptr2++='\r';	break;
     762:	230d      	movs	r3, #13
     764:	702b      	strb	r3, [r5, #0]
     766:	3501      	adds	r5, #1
     768:	e057      	b.n	81a <parse_string+0x152>
				case 't': *ptr2++='\t';	break;
     76a:	2309      	movs	r3, #9
     76c:	702b      	strb	r3, [r5, #0]
     76e:	3501      	adds	r5, #1
     770:	e053      	b.n	81a <parse_string+0x152>
				case 'u':	 /* transcode utf16 to utf8. */
					uc=parse_hex4(ptr+1);ptr+=4;	/* get the unicode char. */
     772:	1ca0      	adds	r0, r4, #2
     774:	4b47      	ldr	r3, [pc, #284]	; (894 <parse_string+0x1cc>)
     776:	4798      	blx	r3
     778:	4681      	mov	r9, r0
     77a:	1d62      	adds	r2, r4, #5

					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)	break;	/* check for invalid.	*/
     77c:	4b46      	ldr	r3, [pc, #280]	; (898 <parse_string+0x1d0>)
     77e:	444b      	add	r3, r9
     780:	4553      	cmp	r3, sl
     782:	d94a      	bls.n	81a <parse_string+0x152>
     784:	2800      	cmp	r0, #0
     786:	d048      	beq.n	81a <parse_string+0x152>

					if (uc>=0xD800 && uc<=0xDBFF)	/* UTF16 surrogate pairs.	*/
     788:	4b44      	ldr	r3, [pc, #272]	; (89c <parse_string+0x1d4>)
     78a:	444b      	add	r3, r9
     78c:	4553      	cmp	r3, sl
     78e:	d81a      	bhi.n	7c6 <parse_string+0xfe>
					{
						if (ptr[1]!='\\' || ptr[2]!='u')	break;	/* missing second-half of surrogate.	*/
     790:	79a3      	ldrb	r3, [r4, #6]
     792:	2b5c      	cmp	r3, #92	; 0x5c
     794:	d141      	bne.n	81a <parse_string+0x152>
     796:	79e3      	ldrb	r3, [r4, #7]
     798:	2b75      	cmp	r3, #117	; 0x75
     79a:	d13e      	bne.n	81a <parse_string+0x152>
						uc2=parse_hex4(ptr+3);ptr+=6;
     79c:	0020      	movs	r0, r4
     79e:	3008      	adds	r0, #8
     7a0:	4b3c      	ldr	r3, [pc, #240]	; (894 <parse_string+0x1cc>)
     7a2:	4798      	blx	r3
     7a4:	0022      	movs	r2, r4
     7a6:	320b      	adds	r2, #11
						if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/
     7a8:	4b3b      	ldr	r3, [pc, #236]	; (898 <parse_string+0x1d0>)
     7aa:	18c3      	adds	r3, r0, r3
     7ac:	4553      	cmp	r3, sl
     7ae:	d834      	bhi.n	81a <parse_string+0x152>
						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
     7b0:	464b      	mov	r3, r9
     7b2:	0299      	lsls	r1, r3, #10
     7b4:	4b3a      	ldr	r3, [pc, #232]	; (8a0 <parse_string+0x1d8>)
     7b6:	400b      	ands	r3, r1
     7b8:	0580      	lsls	r0, r0, #22
     7ba:	0d80      	lsrs	r0, r0, #22
     7bc:	4303      	orrs	r3, r0
     7be:	2180      	movs	r1, #128	; 0x80
     7c0:	0249      	lsls	r1, r1, #9
     7c2:	4689      	mov	r9, r1
     7c4:	4499      	add	r9, r3
					}

					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
     7c6:	464b      	mov	r3, r9
     7c8:	2b7f      	cmp	r3, #127	; 0x7f
     7ca:	d939      	bls.n	840 <parse_string+0x178>
     7cc:	45d9      	cmp	r9, fp
     7ce:	d94d      	bls.n	86c <parse_string+0x1a4>
     7d0:	4b34      	ldr	r3, [pc, #208]	; (8a4 <parse_string+0x1dc>)
     7d2:	4599      	cmp	r9, r3
     7d4:	d946      	bls.n	864 <parse_string+0x19c>
     7d6:	e037      	b.n	848 <parse_string+0x180>
					
					switch (len) {
						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
     7d8:	1e4d      	subs	r5, r1, #1
     7da:	243f      	movs	r4, #63	; 0x3f
     7dc:	4649      	mov	r1, r9
     7de:	400c      	ands	r4, r1
     7e0:	2180      	movs	r1, #128	; 0x80
     7e2:	4249      	negs	r1, r1
     7e4:	430c      	orrs	r4, r1
     7e6:	702c      	strb	r4, [r5, #0]
     7e8:	4649      	mov	r1, r9
     7ea:	0989      	lsrs	r1, r1, #6
     7ec:	4689      	mov	r9, r1
						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
     7ee:	3d01      	subs	r5, #1
     7f0:	213f      	movs	r1, #63	; 0x3f
     7f2:	464c      	mov	r4, r9
     7f4:	4021      	ands	r1, r4
     7f6:	2480      	movs	r4, #128	; 0x80
     7f8:	4264      	negs	r4, r4
     7fa:	4321      	orrs	r1, r4
     7fc:	7029      	strb	r1, [r5, #0]
     7fe:	4649      	mov	r1, r9
     800:	0989      	lsrs	r1, r1, #6
     802:	4689      	mov	r9, r1
						case 1: *--ptr2 =(uc | firstByteMark[len]);
     804:	1e6c      	subs	r4, r5, #1
     806:	4928      	ldr	r1, [pc, #160]	; (8a8 <parse_string+0x1e0>)
     808:	5c09      	ldrb	r1, [r1, r0]
     80a:	4648      	mov	r0, r9
     80c:	4301      	orrs	r1, r0
     80e:	7021      	strb	r1, [r4, #0]
					}
					ptr2+=len;
     810:	3b01      	subs	r3, #1
     812:	18ed      	adds	r5, r5, r3
					break;
     814:	e001      	b.n	81a <parse_string+0x152>
				default:  *ptr2++=*ptr; break;
     816:	7029      	strb	r1, [r5, #0]
     818:	3501      	adds	r5, #1
			}
			ptr++;
     81a:	1c54      	adds	r4, r2, #1
	
	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
	if (!out) return 0;
	
	ptr=str+1;ptr2=out;
	while (*ptr!='\"' && *ptr)
     81c:	7823      	ldrb	r3, [r4, #0]
     81e:	2b22      	cmp	r3, #34	; 0x22
     820:	d001      	beq.n	826 <parse_string+0x15e>
     822:	2b00      	cmp	r3, #0
     824:	d180      	bne.n	728 <parse_string+0x60>
				default:  *ptr2++=*ptr; break;
			}
			ptr++;
		}
	}
	*ptr2=0;
     826:	2300      	movs	r3, #0
     828:	702b      	strb	r3, [r5, #0]
	if (*ptr=='\"') ptr++;
     82a:	7820      	ldrb	r0, [r4, #0]
     82c:	3822      	subs	r0, #34	; 0x22
     82e:	4243      	negs	r3, r0
     830:	4158      	adcs	r0, r3
	item->valuestring=out;
     832:	613e      	str	r6, [r7, #16]
	item->type=cJSON_String;
     834:	2304      	movs	r3, #4
     836:	60fb      	str	r3, [r7, #12]
	return ptr;
     838:	1820      	adds	r0, r4, r0
     83a:	e01b      	b.n	874 <parse_string+0x1ac>
	if (*str!='\"') {ep=str;return 0;}	/* not a string! */
	
	while (*ptr!='\"' && *ptr && ++len) if (*ptr++ == '\\') ptr++;	/* Skip escaped quotes. */
	
	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
	if (!out) return 0;
     83c:	2000      	movs	r0, #0
     83e:	e019      	b.n	874 <parse_string+0x1ac>
						uc2=parse_hex4(ptr+3);ptr+=6;
						if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/
						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
					}

					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
     840:	3501      	adds	r5, #1
     842:	2301      	movs	r3, #1
     844:	2001      	movs	r0, #1
     846:	e7dd      	b.n	804 <parse_string+0x13c>
					
					switch (len) {
						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
     848:	1ce9      	adds	r1, r5, #3
     84a:	233f      	movs	r3, #63	; 0x3f
     84c:	4648      	mov	r0, r9
     84e:	4003      	ands	r3, r0
     850:	2080      	movs	r0, #128	; 0x80
     852:	4240      	negs	r0, r0
     854:	4303      	orrs	r3, r0
     856:	70eb      	strb	r3, [r5, #3]
     858:	464b      	mov	r3, r9
     85a:	099b      	lsrs	r3, r3, #6
     85c:	4699      	mov	r9, r3
						uc2=parse_hex4(ptr+3);ptr+=6;
						if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/
						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
					}

					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
     85e:	2304      	movs	r3, #4
     860:	3084      	adds	r0, #132	; 0x84
     862:	e7b9      	b.n	7d8 <parse_string+0x110>
     864:	1ce9      	adds	r1, r5, #3
     866:	2303      	movs	r3, #3
     868:	2003      	movs	r0, #3
     86a:	e7b5      	b.n	7d8 <parse_string+0x110>
     86c:	3502      	adds	r5, #2
     86e:	4643      	mov	r3, r8
     870:	4640      	mov	r0, r8
     872:	e7bc      	b.n	7ee <parse_string+0x126>
	*ptr2=0;
	if (*ptr=='\"') ptr++;
	item->valuestring=out;
	item->type=cJSON_String;
	return ptr;
}
     874:	bc3c      	pop	{r2, r3, r4, r5}
     876:	4690      	mov	r8, r2
     878:	4699      	mov	r9, r3
     87a:	46a2      	mov	sl, r4
     87c:	46ab      	mov	fp, r5
     87e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     880:	200001c8 	.word	0x200001c8
     884:	20000004 	.word	0x20000004
     888:	000003ff 	.word	0x000003ff
     88c:	000007ff 	.word	0x000007ff
     890:	00012f3c 	.word	0x00012f3c
     894:	00000619 	.word	0x00000619
     898:	ffff2400 	.word	0xffff2400
     89c:	ffff2800 	.word	0xffff2800
     8a0:	000ffc00 	.word	0x000ffc00
     8a4:	0000ffff 	.word	0x0000ffff
     8a8:	00012fc4 	.word	0x00012fc4

000008ac <skip>:
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
     8ac:	2800      	cmp	r0, #0
     8ae:	d00a      	beq.n	8c6 <skip+0x1a>
     8b0:	7803      	ldrb	r3, [r0, #0]
     8b2:	3b01      	subs	r3, #1
     8b4:	2b1f      	cmp	r3, #31
     8b6:	d806      	bhi.n	8c6 <skip+0x1a>
     8b8:	3001      	adds	r0, #1
     8ba:	2800      	cmp	r0, #0
     8bc:	d003      	beq.n	8c6 <skip+0x1a>
     8be:	7803      	ldrb	r3, [r0, #0]
     8c0:	3b01      	subs	r3, #1
     8c2:	2b1f      	cmp	r3, #31
     8c4:	d9f8      	bls.n	8b8 <skip+0xc>
     8c6:	4770      	bx	lr

000008c8 <cJSON_New_Item>:
	cJSON_free	 = (hooks->free_fn)?hooks->free_fn:free;
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
     8c8:	b510      	push	{r4, lr}
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
     8ca:	4b06      	ldr	r3, [pc, #24]	; (8e4 <cJSON_New_Item+0x1c>)
     8cc:	681b      	ldr	r3, [r3, #0]
     8ce:	2028      	movs	r0, #40	; 0x28
     8d0:	4798      	blx	r3
     8d2:	1e04      	subs	r4, r0, #0
	if (node) memset(node,0,sizeof(cJSON));
     8d4:	d003      	beq.n	8de <cJSON_New_Item+0x16>
     8d6:	2228      	movs	r2, #40	; 0x28
     8d8:	2100      	movs	r1, #0
     8da:	4b03      	ldr	r3, [pc, #12]	; (8e8 <cJSON_New_Item+0x20>)
     8dc:	4798      	blx	r3
	return node;
}
     8de:	0020      	movs	r0, r4
     8e0:	bd10      	pop	{r4, pc}
     8e2:	46c0      	nop			; (mov r8, r8)
     8e4:	20000004 	.word	0x20000004
     8e8:	00011845 	.word	0x00011845

000008ec <parse_value>:
}


/* Parser core - when encountering text, process appropriately. */
static const char *parse_value(cJSON *item,const char *value)
{
     8ec:	b5f0      	push	{r4, r5, r6, r7, lr}
     8ee:	465f      	mov	r7, fp
     8f0:	4656      	mov	r6, sl
     8f2:	464d      	mov	r5, r9
     8f4:	4644      	mov	r4, r8
     8f6:	b4f0      	push	{r4, r5, r6, r7}
     8f8:	b087      	sub	sp, #28
     8fa:	0005      	movs	r5, r0
     8fc:	1e0c      	subs	r4, r1, #0
	if (!value)						return 0;	/* Fail on null. */
     8fe:	d100      	bne.n	902 <parse_value+0x16>
     900:	e1bc      	b.n	c7c <parse_value+0x390>
	if (!strncmp(value,"null",4))	{ item->type=cJSON_NULL;  return value+4; }
     902:	2204      	movs	r2, #4
     904:	49ca      	ldr	r1, [pc, #808]	; (c30 <parse_value+0x344>)
     906:	0020      	movs	r0, r4
     908:	4bca      	ldr	r3, [pc, #808]	; (c34 <parse_value+0x348>)
     90a:	4798      	blx	r3
     90c:	2800      	cmp	r0, #0
     90e:	d103      	bne.n	918 <parse_value+0x2c>
     910:	2302      	movs	r3, #2
     912:	60eb      	str	r3, [r5, #12]
     914:	1d20      	adds	r0, r4, #4
     916:	e1c6      	b.n	ca6 <parse_value+0x3ba>
	if (!strncmp(value,"false",5))	{ item->type=cJSON_False; return value+5; }
     918:	2205      	movs	r2, #5
     91a:	49c7      	ldr	r1, [pc, #796]	; (c38 <parse_value+0x34c>)
     91c:	0020      	movs	r0, r4
     91e:	4bc5      	ldr	r3, [pc, #788]	; (c34 <parse_value+0x348>)
     920:	4798      	blx	r3
     922:	2800      	cmp	r0, #0
     924:	d103      	bne.n	92e <parse_value+0x42>
     926:	2300      	movs	r3, #0
     928:	60eb      	str	r3, [r5, #12]
     92a:	1d60      	adds	r0, r4, #5
     92c:	e1bb      	b.n	ca6 <parse_value+0x3ba>
	if (!strncmp(value,"true",4))	{ item->type=cJSON_True; item->valueint=1;	return value+4; }
     92e:	2204      	movs	r2, #4
     930:	49c2      	ldr	r1, [pc, #776]	; (c3c <parse_value+0x350>)
     932:	0020      	movs	r0, r4
     934:	4bbf      	ldr	r3, [pc, #764]	; (c34 <parse_value+0x348>)
     936:	4798      	blx	r3
     938:	2800      	cmp	r0, #0
     93a:	d104      	bne.n	946 <parse_value+0x5a>
     93c:	2301      	movs	r3, #1
     93e:	60eb      	str	r3, [r5, #12]
     940:	616b      	str	r3, [r5, #20]
     942:	1d20      	adds	r0, r4, #4
     944:	e1af      	b.n	ca6 <parse_value+0x3ba>
	if (*value=='\"')				{ return parse_string(item,value); }
     946:	7823      	ldrb	r3, [r4, #0]
     948:	2b22      	cmp	r3, #34	; 0x22
     94a:	d104      	bne.n	956 <parse_value+0x6a>
     94c:	0021      	movs	r1, r4
     94e:	0028      	movs	r0, r5
     950:	4bbb      	ldr	r3, [pc, #748]	; (c40 <parse_value+0x354>)
     952:	4798      	blx	r3
     954:	e1a7      	b.n	ca6 <parse_value+0x3ba>
	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
     956:	2b2d      	cmp	r3, #45	; 0x2d
     958:	d005      	beq.n	966 <parse_value+0x7a>
     95a:	001a      	movs	r2, r3
     95c:	3a30      	subs	r2, #48	; 0x30
     95e:	2a09      	cmp	r2, #9
     960:	d900      	bls.n	964 <parse_value+0x78>
     962:	e0bf      	b.n	ae4 <parse_value+0x1f8>
     964:	e005      	b.n	972 <parse_value+0x86>
/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;

	if (*num=='-') sign=-1,num++;	/* Has sign? */
     966:	3401      	adds	r4, #1
     968:	2200      	movs	r2, #0
     96a:	4bb6      	ldr	r3, [pc, #728]	; (c44 <parse_value+0x358>)
     96c:	9204      	str	r2, [sp, #16]
     96e:	9305      	str	r3, [sp, #20]
     970:	e003      	b.n	97a <parse_value+0x8e>
}

/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
     972:	2200      	movs	r2, #0
     974:	4bb4      	ldr	r3, [pc, #720]	; (c48 <parse_value+0x35c>)
     976:	9204      	str	r2, [sp, #16]
     978:	9305      	str	r3, [sp, #20]

	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
     97a:	7823      	ldrb	r3, [r4, #0]
     97c:	3b30      	subs	r3, #48	; 0x30
     97e:	4259      	negs	r1, r3
     980:	4159      	adcs	r1, r3
     982:	1864      	adds	r4, r4, r1
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
     984:	7823      	ldrb	r3, [r4, #0]
     986:	3b31      	subs	r3, #49	; 0x31
     988:	2b08      	cmp	r3, #8
     98a:	d81d      	bhi.n	9c8 <parse_value+0xdc>
     98c:	2200      	movs	r2, #0
     98e:	2300      	movs	r3, #0
     990:	49ae      	ldr	r1, [pc, #696]	; (c4c <parse_value+0x360>)
     992:	468a      	mov	sl, r1
     994:	4fae      	ldr	r7, [pc, #696]	; (c50 <parse_value+0x364>)
     996:	4eaf      	ldr	r6, [pc, #700]	; (c54 <parse_value+0x368>)
     998:	0010      	movs	r0, r2
     99a:	0019      	movs	r1, r3
     99c:	46a9      	mov	r9, r5
     99e:	2200      	movs	r2, #0
     9a0:	4bad      	ldr	r3, [pc, #692]	; (c58 <parse_value+0x36c>)
     9a2:	47d0      	blx	sl
     9a4:	9000      	str	r0, [sp, #0]
     9a6:	9101      	str	r1, [sp, #4]
     9a8:	3401      	adds	r4, #1
     9aa:	1e63      	subs	r3, r4, #1
     9ac:	7818      	ldrb	r0, [r3, #0]
     9ae:	3830      	subs	r0, #48	; 0x30
     9b0:	47b8      	blx	r7
     9b2:	9a00      	ldr	r2, [sp, #0]
     9b4:	9b01      	ldr	r3, [sp, #4]
     9b6:	47b0      	blx	r6
     9b8:	7823      	ldrb	r3, [r4, #0]
     9ba:	3b30      	subs	r3, #48	; 0x30
     9bc:	2b09      	cmp	r3, #9
     9be:	d9ee      	bls.n	99e <parse_value+0xb2>
     9c0:	9000      	str	r0, [sp, #0]
     9c2:	9101      	str	r1, [sp, #4]
     9c4:	464d      	mov	r5, r9
     9c6:	e003      	b.n	9d0 <parse_value+0xe4>
}

/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
     9c8:	2200      	movs	r2, #0
     9ca:	2300      	movs	r3, #0
     9cc:	9200      	str	r2, [sp, #0]
     9ce:	9301      	str	r3, [sp, #4]

	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
     9d0:	7823      	ldrb	r3, [r4, #0]
     9d2:	2b2e      	cmp	r3, #46	; 0x2e
     9d4:	d12d      	bne.n	a32 <parse_value+0x146>
     9d6:	7863      	ldrb	r3, [r4, #1]
     9d8:	3b30      	subs	r3, #48	; 0x30
     9da:	2b09      	cmp	r3, #9
     9dc:	d852      	bhi.n	a84 <parse_value+0x198>
     9de:	3401      	adds	r4, #1
}

/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
     9e0:	2200      	movs	r2, #0
     9e2:	2300      	movs	r3, #0
     9e4:	9202      	str	r2, [sp, #8]
     9e6:	9303      	str	r3, [sp, #12]

	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
     9e8:	4b98      	ldr	r3, [pc, #608]	; (c4c <parse_value+0x360>)
     9ea:	4699      	mov	r9, r3
     9ec:	4b98      	ldr	r3, [pc, #608]	; (c50 <parse_value+0x364>)
     9ee:	4698      	mov	r8, r3
     9f0:	4f98      	ldr	r7, [pc, #608]	; (c54 <parse_value+0x368>)
     9f2:	4e9a      	ldr	r6, [pc, #616]	; (c5c <parse_value+0x370>)
     9f4:	46ab      	mov	fp, r5
     9f6:	2200      	movs	r2, #0
     9f8:	4b97      	ldr	r3, [pc, #604]	; (c58 <parse_value+0x36c>)
     9fa:	9800      	ldr	r0, [sp, #0]
     9fc:	9901      	ldr	r1, [sp, #4]
     9fe:	47c8      	blx	r9
     a00:	9000      	str	r0, [sp, #0]
     a02:	9101      	str	r1, [sp, #4]
     a04:	3401      	adds	r4, #1
     a06:	1e63      	subs	r3, r4, #1
     a08:	7818      	ldrb	r0, [r3, #0]
     a0a:	3830      	subs	r0, #48	; 0x30
     a0c:	47c0      	blx	r8
     a0e:	9a00      	ldr	r2, [sp, #0]
     a10:	9b01      	ldr	r3, [sp, #4]
     a12:	47b8      	blx	r7
     a14:	9000      	str	r0, [sp, #0]
     a16:	9101      	str	r1, [sp, #4]
     a18:	2200      	movs	r2, #0
     a1a:	4b8b      	ldr	r3, [pc, #556]	; (c48 <parse_value+0x35c>)
     a1c:	9802      	ldr	r0, [sp, #8]
     a1e:	9903      	ldr	r1, [sp, #12]
     a20:	47b0      	blx	r6
     a22:	9002      	str	r0, [sp, #8]
     a24:	9103      	str	r1, [sp, #12]
     a26:	7823      	ldrb	r3, [r4, #0]
     a28:	3b30      	subs	r3, #48	; 0x30
     a2a:	2b09      	cmp	r3, #9
     a2c:	d9e3      	bls.n	9f6 <parse_value+0x10a>
     a2e:	465d      	mov	r5, fp
     a30:	e003      	b.n	a3a <parse_value+0x14e>
}

/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
     a32:	2200      	movs	r2, #0
     a34:	2300      	movs	r3, #0
     a36:	9202      	str	r2, [sp, #8]
     a38:	9303      	str	r3, [sp, #12]

	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
	if (*num=='e' || *num=='E')		/* Exponent? */
     a3a:	7823      	ldrb	r3, [r4, #0]
     a3c:	2220      	movs	r2, #32
     a3e:	4393      	bics	r3, r2
     a40:	2b45      	cmp	r3, #69	; 0x45
     a42:	d126      	bne.n	a92 <parse_value+0x1a6>
	{	num++;if (*num=='+') num++;	else if (*num=='-') signsubscale=-1,num++;		/* With sign? */
     a44:	7863      	ldrb	r3, [r4, #1]
     a46:	2b2b      	cmp	r3, #43	; 0x2b
     a48:	d102      	bne.n	a50 <parse_value+0x164>
     a4a:	3402      	adds	r4, #2
}

/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
     a4c:	2701      	movs	r7, #1
     a4e:	e007      	b.n	a60 <parse_value+0x174>
	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
	if (*num=='e' || *num=='E')		/* Exponent? */
	{	num++;if (*num=='+') num++;	else if (*num=='-') signsubscale=-1,num++;		/* With sign? */
     a50:	2b2d      	cmp	r3, #45	; 0x2d
     a52:	d002      	beq.n	a5a <parse_value+0x16e>
     a54:	3401      	adds	r4, #1
}

/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
     a56:	2701      	movs	r7, #1
     a58:	e002      	b.n	a60 <parse_value+0x174>
	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
	if (*num=='e' || *num=='E')		/* Exponent? */
	{	num++;if (*num=='+') num++;	else if (*num=='-') signsubscale=-1,num++;		/* With sign? */
     a5a:	3402      	adds	r4, #2
     a5c:	2701      	movs	r7, #1
     a5e:	427f      	negs	r7, r7
		while (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');	/* Number? */
     a60:	7823      	ldrb	r3, [r4, #0]
     a62:	001a      	movs	r2, r3
     a64:	3a30      	subs	r2, #48	; 0x30
     a66:	2a09      	cmp	r2, #9
     a68:	d816      	bhi.n	a98 <parse_value+0x1ac>
     a6a:	2600      	movs	r6, #0
     a6c:	00b2      	lsls	r2, r6, #2
     a6e:	1996      	adds	r6, r2, r6
     a70:	0076      	lsls	r6, r6, #1
     a72:	3401      	adds	r4, #1
     a74:	3b30      	subs	r3, #48	; 0x30
     a76:	199e      	adds	r6, r3, r6
     a78:	7823      	ldrb	r3, [r4, #0]
     a7a:	001a      	movs	r2, r3
     a7c:	3a30      	subs	r2, #48	; 0x30
     a7e:	2a09      	cmp	r2, #9
     a80:	d9f4      	bls.n	a6c <parse_value+0x180>
     a82:	e00a      	b.n	a9a <parse_value+0x1ae>
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;

	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
     a84:	2200      	movs	r2, #0
     a86:	2300      	movs	r3, #0
     a88:	9202      	str	r2, [sp, #8]
     a8a:	9303      	str	r3, [sp, #12]
}

/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
     a8c:	2701      	movs	r7, #1
     a8e:	2600      	movs	r6, #0
     a90:	e003      	b.n	a9a <parse_value+0x1ae>
     a92:	2701      	movs	r7, #1
     a94:	2600      	movs	r6, #0
     a96:	e000      	b.n	a9a <parse_value+0x1ae>
	if (*num=='0') num++;			/* is zero */
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
	if (*num=='e' || *num=='E')		/* Exponent? */
	{	num++;if (*num=='+') num++;	else if (*num=='-') signsubscale=-1,num++;		/* With sign? */
		while (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');	/* Number? */
     a98:	2600      	movs	r6, #0
	}

	n=sign*n*pow(10.0,(scale+subscale*signsubscale));	/* number = +/- number.fraction * 10^+/- exponent */
     a9a:	4b6c      	ldr	r3, [pc, #432]	; (c4c <parse_value+0x360>)
     a9c:	469a      	mov	sl, r3
     a9e:	9a00      	ldr	r2, [sp, #0]
     aa0:	9b01      	ldr	r3, [sp, #4]
     aa2:	9804      	ldr	r0, [sp, #16]
     aa4:	9905      	ldr	r1, [sp, #20]
     aa6:	47d0      	blx	sl
     aa8:	9000      	str	r0, [sp, #0]
     aaa:	9101      	str	r1, [sp, #4]
     aac:	4377      	muls	r7, r6
     aae:	0038      	movs	r0, r7
     ab0:	4b67      	ldr	r3, [pc, #412]	; (c50 <parse_value+0x364>)
     ab2:	4798      	blx	r3
     ab4:	9a02      	ldr	r2, [sp, #8]
     ab6:	9b03      	ldr	r3, [sp, #12]
     ab8:	4e66      	ldr	r6, [pc, #408]	; (c54 <parse_value+0x368>)
     aba:	47b0      	blx	r6
     abc:	0002      	movs	r2, r0
     abe:	000b      	movs	r3, r1
     ac0:	2000      	movs	r0, #0
     ac2:	4965      	ldr	r1, [pc, #404]	; (c58 <parse_value+0x36c>)
     ac4:	4e66      	ldr	r6, [pc, #408]	; (c60 <parse_value+0x374>)
     ac6:	47b0      	blx	r6
     ac8:	0002      	movs	r2, r0
     aca:	000b      	movs	r3, r1
     acc:	9800      	ldr	r0, [sp, #0]
     ace:	9901      	ldr	r1, [sp, #4]
     ad0:	47d0      	blx	sl
	
	item->valuedouble=n;
     ad2:	61a8      	str	r0, [r5, #24]
     ad4:	61e9      	str	r1, [r5, #28]
	item->valueint=(int)n;
     ad6:	4b63      	ldr	r3, [pc, #396]	; (c64 <parse_value+0x378>)
     ad8:	4798      	blx	r3
     ada:	6168      	str	r0, [r5, #20]
	item->type=cJSON_Number;
     adc:	2303      	movs	r3, #3
     ade:	60eb      	str	r3, [r5, #12]
	if (!value)						return 0;	/* Fail on null. */
	if (!strncmp(value,"null",4))	{ item->type=cJSON_NULL;  return value+4; }
	if (!strncmp(value,"false",5))	{ item->type=cJSON_False; return value+5; }
	if (!strncmp(value,"true",4))	{ item->type=cJSON_True; item->valueint=1;	return value+4; }
	if (*value=='\"')				{ return parse_string(item,value); }
	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
     ae0:	0020      	movs	r0, r4
     ae2:	e0e0      	b.n	ca6 <parse_value+0x3ba>
	if (*value=='[')				{ return parse_array(item,value); }
     ae4:	2b5b      	cmp	r3, #91	; 0x5b
     ae6:	d13b      	bne.n	b60 <parse_value+0x274>
static const char *parse_array(cJSON *item,const char *value)
{
	cJSON *child;
	if (*value!='[')	{ep=value;return 0;}	/* not an array! */

	item->type=cJSON_Array;
     ae8:	3b56      	subs	r3, #86	; 0x56
     aea:	60eb      	str	r3, [r5, #12]
	value=skip(value+1);
     aec:	1c60      	adds	r0, r4, #1
     aee:	4b5e      	ldr	r3, [pc, #376]	; (c68 <parse_value+0x37c>)
     af0:	4798      	blx	r3
     af2:	0004      	movs	r4, r0
	if (*value==']') return value+1;	/* empty array. */
     af4:	7803      	ldrb	r3, [r0, #0]
     af6:	3001      	adds	r0, #1
     af8:	2b5d      	cmp	r3, #93	; 0x5d
     afa:	d100      	bne.n	afe <parse_value+0x212>
     afc:	e0d3      	b.n	ca6 <parse_value+0x3ba>

	item->child=child=cJSON_New_Item();
     afe:	4b5b      	ldr	r3, [pc, #364]	; (c6c <parse_value+0x380>)
     b00:	4798      	blx	r3
     b02:	1e06      	subs	r6, r0, #0
     b04:	60a8      	str	r0, [r5, #8]
	if (!item->child) return 0;		 /* memory fail */
     b06:	d100      	bne.n	b0a <parse_value+0x21e>
     b08:	e0ba      	b.n	c80 <parse_value+0x394>
	value=skip(parse_value(child,skip(value)));	/* skip any spacing, get the value. */
     b0a:	0020      	movs	r0, r4
     b0c:	4c56      	ldr	r4, [pc, #344]	; (c68 <parse_value+0x37c>)
     b0e:	47a0      	blx	r4
     b10:	0001      	movs	r1, r0
     b12:	0030      	movs	r0, r6
     b14:	f7ff feea 	bl	8ec <parse_value>
     b18:	47a0      	blx	r4
     b1a:	1e04      	subs	r4, r0, #0
	if (!value) return 0;
     b1c:	d100      	bne.n	b20 <parse_value+0x234>
     b1e:	e0b1      	b.n	c84 <parse_value+0x398>

	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item())) return 0; 	/* memory fail */
     b20:	4b52      	ldr	r3, [pc, #328]	; (c6c <parse_value+0x380>)
     b22:	4698      	mov	r8, r3
		child->next=new_item;new_item->prev=child;child=new_item;
		value=skip(parse_value(child,skip(value+1)));
     b24:	4f50      	ldr	r7, [pc, #320]	; (c68 <parse_value+0x37c>)
     b26:	e010      	b.n	b4a <parse_value+0x25e>
	if (!value) return 0;

	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item())) return 0; 	/* memory fail */
     b28:	47c0      	blx	r8
     b2a:	1e05      	subs	r5, r0, #0
     b2c:	d100      	bne.n	b30 <parse_value+0x244>
     b2e:	e0ab      	b.n	c88 <parse_value+0x39c>
		child->next=new_item;new_item->prev=child;child=new_item;
     b30:	6030      	str	r0, [r6, #0]
     b32:	6046      	str	r6, [r0, #4]
		value=skip(parse_value(child,skip(value+1)));
     b34:	1c60      	adds	r0, r4, #1
     b36:	47b8      	blx	r7
     b38:	0001      	movs	r1, r0
     b3a:	0028      	movs	r0, r5
     b3c:	f7ff fed6 	bl	8ec <parse_value>
     b40:	47b8      	blx	r7
     b42:	1e04      	subs	r4, r0, #0
		if (!value) return 0;	/* memory fail */
     b44:	d100      	bne.n	b48 <parse_value+0x25c>
     b46:	e0a1      	b.n	c8c <parse_value+0x3a0>

	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item())) return 0; 	/* memory fail */
		child->next=new_item;new_item->prev=child;child=new_item;
     b48:	002e      	movs	r6, r5
	item->child=child=cJSON_New_Item();
	if (!item->child) return 0;		 /* memory fail */
	value=skip(parse_value(child,skip(value)));	/* skip any spacing, get the value. */
	if (!value) return 0;

	while (*value==',')
     b4a:	7823      	ldrb	r3, [r4, #0]
     b4c:	2b2c      	cmp	r3, #44	; 0x2c
     b4e:	d0eb      	beq.n	b28 <parse_value+0x23c>
		child->next=new_item;new_item->prev=child;child=new_item;
		value=skip(parse_value(child,skip(value+1)));
		if (!value) return 0;	/* memory fail */
	}

	if (*value==']') return value+1;	/* end of array */
     b50:	2b5d      	cmp	r3, #93	; 0x5d
     b52:	d101      	bne.n	b58 <parse_value+0x26c>
     b54:	1c60      	adds	r0, r4, #1
     b56:	e0a6      	b.n	ca6 <parse_value+0x3ba>
	ep=value;return 0;	/* malformed. */
     b58:	4b45      	ldr	r3, [pc, #276]	; (c70 <parse_value+0x384>)
     b5a:	601c      	str	r4, [r3, #0]
     b5c:	2000      	movs	r0, #0
     b5e:	e0a2      	b.n	ca6 <parse_value+0x3ba>
	if (!strncmp(value,"false",5))	{ item->type=cJSON_False; return value+5; }
	if (!strncmp(value,"true",4))	{ item->type=cJSON_True; item->valueint=1;	return value+4; }
	if (*value=='\"')				{ return parse_string(item,value); }
	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
	if (*value=='[')				{ return parse_array(item,value); }
	if (*value=='{')				{ return parse_object(item,value); }
     b60:	2b7b      	cmp	r3, #123	; 0x7b
     b62:	d000      	beq.n	b66 <parse_value+0x27a>
     b64:	e086      	b.n	c74 <parse_value+0x388>
static const char *parse_object(cJSON *item,const char *value)
{
	cJSON *child;
	if (*value!='{')	{ep=value;return 0;}	/* not an object! */
	
	item->type=cJSON_Object;
     b66:	3b75      	subs	r3, #117	; 0x75
     b68:	60eb      	str	r3, [r5, #12]
	value=skip(value+1);
     b6a:	1c60      	adds	r0, r4, #1
     b6c:	4b3e      	ldr	r3, [pc, #248]	; (c68 <parse_value+0x37c>)
     b6e:	4798      	blx	r3
     b70:	0004      	movs	r4, r0
	if (*value=='}') return value+1;	/* empty array. */
     b72:	7803      	ldrb	r3, [r0, #0]
     b74:	3001      	adds	r0, #1
     b76:	2b7d      	cmp	r3, #125	; 0x7d
     b78:	d100      	bne.n	b7c <parse_value+0x290>
     b7a:	e094      	b.n	ca6 <parse_value+0x3ba>
	
	item->child=child=cJSON_New_Item();
     b7c:	4b3b      	ldr	r3, [pc, #236]	; (c6c <parse_value+0x380>)
     b7e:	4798      	blx	r3
     b80:	1e07      	subs	r7, r0, #0
     b82:	60a8      	str	r0, [r5, #8]
	if (!item->child) return 0;
     b84:	d100      	bne.n	b88 <parse_value+0x29c>
     b86:	e083      	b.n	c90 <parse_value+0x3a4>
	value=skip(parse_string(child,skip(value)));
     b88:	0020      	movs	r0, r4
     b8a:	4c37      	ldr	r4, [pc, #220]	; (c68 <parse_value+0x37c>)
     b8c:	47a0      	blx	r4
     b8e:	0001      	movs	r1, r0
     b90:	0038      	movs	r0, r7
     b92:	4b2b      	ldr	r3, [pc, #172]	; (c40 <parse_value+0x354>)
     b94:	4798      	blx	r3
     b96:	47a0      	blx	r4
	if (!value) return 0;
     b98:	2800      	cmp	r0, #0
     b9a:	d100      	bne.n	b9e <parse_value+0x2b2>
     b9c:	e07a      	b.n	c94 <parse_value+0x3a8>
	child->string=child->valuestring;child->valuestring=0;
     b9e:	693b      	ldr	r3, [r7, #16]
     ba0:	623b      	str	r3, [r7, #32]
     ba2:	2300      	movs	r3, #0
     ba4:	613b      	str	r3, [r7, #16]
	if (*value!=':') {ep=value;return 0;}	/* fail! */
     ba6:	7803      	ldrb	r3, [r0, #0]
     ba8:	2b3a      	cmp	r3, #58	; 0x3a
     baa:	d003      	beq.n	bb4 <parse_value+0x2c8>
     bac:	4b30      	ldr	r3, [pc, #192]	; (c70 <parse_value+0x384>)
     bae:	6018      	str	r0, [r3, #0]
     bb0:	2000      	movs	r0, #0
     bb2:	e078      	b.n	ca6 <parse_value+0x3ba>
	value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
     bb4:	3001      	adds	r0, #1
     bb6:	4c2c      	ldr	r4, [pc, #176]	; (c68 <parse_value+0x37c>)
     bb8:	47a0      	blx	r4
     bba:	0001      	movs	r1, r0
     bbc:	0038      	movs	r0, r7
     bbe:	f7ff fe95 	bl	8ec <parse_value>
     bc2:	47a0      	blx	r4
     bc4:	1e04      	subs	r4, r0, #0
	if (!value) return 0;
     bc6:	d067      	beq.n	c98 <parse_value+0x3ac>
	
	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
     bc8:	4b28      	ldr	r3, [pc, #160]	; (c6c <parse_value+0x380>)
     bca:	4699      	mov	r9, r3
		child->next=new_item;new_item->prev=child;child=new_item;
		value=skip(parse_string(child,skip(value+1)));
     bcc:	4e26      	ldr	r6, [pc, #152]	; (c68 <parse_value+0x37c>)
     bce:	4b1c      	ldr	r3, [pc, #112]	; (c40 <parse_value+0x354>)
     bd0:	4698      	mov	r8, r3
     bd2:	e022      	b.n	c1a <parse_value+0x32e>
	if (!value) return 0;
	
	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
     bd4:	47c8      	blx	r9
     bd6:	1e05      	subs	r5, r0, #0
     bd8:	d060      	beq.n	c9c <parse_value+0x3b0>
		child->next=new_item;new_item->prev=child;child=new_item;
     bda:	6038      	str	r0, [r7, #0]
     bdc:	6047      	str	r7, [r0, #4]
		value=skip(parse_string(child,skip(value+1)));
     bde:	1c60      	adds	r0, r4, #1
     be0:	47b0      	blx	r6
     be2:	0001      	movs	r1, r0
     be4:	0028      	movs	r0, r5
     be6:	47c0      	blx	r8
     be8:	47b0      	blx	r6
		if (!value) return 0;
     bea:	2800      	cmp	r0, #0
     bec:	d058      	beq.n	ca0 <parse_value+0x3b4>
		child->string=child->valuestring;child->valuestring=0;
     bee:	692b      	ldr	r3, [r5, #16]
     bf0:	622b      	str	r3, [r5, #32]
     bf2:	2300      	movs	r3, #0
     bf4:	612b      	str	r3, [r5, #16]
		if (*value!=':') {ep=value;return 0;}	/* fail! */
     bf6:	7803      	ldrb	r3, [r0, #0]
     bf8:	2b3a      	cmp	r3, #58	; 0x3a
     bfa:	d003      	beq.n	c04 <parse_value+0x318>
     bfc:	4b1c      	ldr	r3, [pc, #112]	; (c70 <parse_value+0x384>)
     bfe:	6018      	str	r0, [r3, #0]
     c00:	2000      	movs	r0, #0
     c02:	e050      	b.n	ca6 <parse_value+0x3ba>
		value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
     c04:	3001      	adds	r0, #1
     c06:	4c18      	ldr	r4, [pc, #96]	; (c68 <parse_value+0x37c>)
     c08:	47a0      	blx	r4
     c0a:	0001      	movs	r1, r0
     c0c:	0028      	movs	r0, r5
     c0e:	f7ff fe6d 	bl	8ec <parse_value>
     c12:	47a0      	blx	r4
     c14:	1e04      	subs	r4, r0, #0
		if (!value) return 0;
     c16:	d045      	beq.n	ca4 <parse_value+0x3b8>
	
	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
		child->next=new_item;new_item->prev=child;child=new_item;
     c18:	002f      	movs	r7, r5
	child->string=child->valuestring;child->valuestring=0;
	if (*value!=':') {ep=value;return 0;}	/* fail! */
	value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
	if (!value) return 0;
	
	while (*value==',')
     c1a:	7823      	ldrb	r3, [r4, #0]
     c1c:	2b2c      	cmp	r3, #44	; 0x2c
     c1e:	d0d9      	beq.n	bd4 <parse_value+0x2e8>
		if (*value!=':') {ep=value;return 0;}	/* fail! */
		value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
		if (!value) return 0;
	}
	
	if (*value=='}') return value+1;	/* end of array */
     c20:	2b7d      	cmp	r3, #125	; 0x7d
     c22:	d101      	bne.n	c28 <parse_value+0x33c>
     c24:	1c60      	adds	r0, r4, #1
     c26:	e03e      	b.n	ca6 <parse_value+0x3ba>
	ep=value;return 0;	/* malformed. */
     c28:	4b11      	ldr	r3, [pc, #68]	; (c70 <parse_value+0x384>)
     c2a:	601c      	str	r4, [r3, #0]
     c2c:	2000      	movs	r0, #0
     c2e:	e03a      	b.n	ca6 <parse_value+0x3ba>
     c30:	000133cc 	.word	0x000133cc
     c34:	00011d83 	.word	0x00011d83
     c38:	000133d4 	.word	0x000133d4
     c3c:	000133dc 	.word	0x000133dc
     c40:	000006c9 	.word	0x000006c9
     c44:	bff00000 	.word	0xbff00000
     c48:	3ff00000 	.word	0x3ff00000
     c4c:	00010a8d 	.word	0x00010a8d
     c50:	000116d5 	.word	0x000116d5
     c54:	0000fbed 	.word	0x0000fbed
     c58:	40240000 	.word	0x40240000
     c5c:	00010f81 	.word	0x00010f81
     c60:	0000e4c5 	.word	0x0000e4c5
     c64:	00011669 	.word	0x00011669
     c68:	000008ad 	.word	0x000008ad
     c6c:	000008c9 	.word	0x000008c9
     c70:	200001c8 	.word	0x200001c8
	if (*value=='\"')				{ return parse_string(item,value); }
	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
	if (*value=='[')				{ return parse_array(item,value); }
	if (*value=='{')				{ return parse_object(item,value); }

	ep=value;return 0;	/* failure. */
     c74:	4b0f      	ldr	r3, [pc, #60]	; (cb4 <parse_value+0x3c8>)
     c76:	601c      	str	r4, [r3, #0]
     c78:	2000      	movs	r0, #0
     c7a:	e014      	b.n	ca6 <parse_value+0x3ba>


/* Parser core - when encountering text, process appropriately. */
static const char *parse_value(cJSON *item,const char *value)
{
	if (!value)						return 0;	/* Fail on null. */
     c7c:	2000      	movs	r0, #0
     c7e:	e012      	b.n	ca6 <parse_value+0x3ba>
	item->type=cJSON_Array;
	value=skip(value+1);
	if (*value==']') return value+1;	/* empty array. */

	item->child=child=cJSON_New_Item();
	if (!item->child) return 0;		 /* memory fail */
     c80:	2000      	movs	r0, #0
     c82:	e010      	b.n	ca6 <parse_value+0x3ba>
	value=skip(parse_value(child,skip(value)));	/* skip any spacing, get the value. */
	if (!value) return 0;
     c84:	2000      	movs	r0, #0
     c86:	e00e      	b.n	ca6 <parse_value+0x3ba>

	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item())) return 0; 	/* memory fail */
     c88:	2000      	movs	r0, #0
     c8a:	e00c      	b.n	ca6 <parse_value+0x3ba>
		child->next=new_item;new_item->prev=child;child=new_item;
		value=skip(parse_value(child,skip(value+1)));
		if (!value) return 0;	/* memory fail */
     c8c:	2000      	movs	r0, #0
     c8e:	e00a      	b.n	ca6 <parse_value+0x3ba>
	item->type=cJSON_Object;
	value=skip(value+1);
	if (*value=='}') return value+1;	/* empty array. */
	
	item->child=child=cJSON_New_Item();
	if (!item->child) return 0;
     c90:	2000      	movs	r0, #0
     c92:	e008      	b.n	ca6 <parse_value+0x3ba>
	value=skip(parse_string(child,skip(value)));
	if (!value) return 0;
     c94:	2000      	movs	r0, #0
     c96:	e006      	b.n	ca6 <parse_value+0x3ba>
	child->string=child->valuestring;child->valuestring=0;
	if (*value!=':') {ep=value;return 0;}	/* fail! */
	value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
	if (!value) return 0;
     c98:	2000      	movs	r0, #0
     c9a:	e004      	b.n	ca6 <parse_value+0x3ba>
	
	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
     c9c:	2000      	movs	r0, #0
     c9e:	e002      	b.n	ca6 <parse_value+0x3ba>
		child->next=new_item;new_item->prev=child;child=new_item;
		value=skip(parse_string(child,skip(value+1)));
		if (!value) return 0;
     ca0:	2000      	movs	r0, #0
     ca2:	e000      	b.n	ca6 <parse_value+0x3ba>
		child->string=child->valuestring;child->valuestring=0;
		if (*value!=':') {ep=value;return 0;}	/* fail! */
		value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
		if (!value) return 0;
     ca4:	2000      	movs	r0, #0
	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
	if (*value=='[')				{ return parse_array(item,value); }
	if (*value=='{')				{ return parse_object(item,value); }

	ep=value;return 0;	/* failure. */
}
     ca6:	b007      	add	sp, #28
     ca8:	bc3c      	pop	{r2, r3, r4, r5}
     caa:	4690      	mov	r8, r2
     cac:	4699      	mov	r9, r3
     cae:	46a2      	mov	sl, r4
     cb0:	46ab      	mov	fp, r5
     cb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
     cb4:	200001c8 	.word	0x200001c8

00000cb8 <ensure>:
static int pow2gt (int x)	{	--x;	x|=x>>1;	x|=x>>2;	x|=x>>4;	x|=x>>8;	x|=x>>16;	return x+1;	}

typedef struct {char *buffer; int length; int offset; } printbuffer;

static char* ensure(printbuffer *p,int needed)
{
     cb8:	b570      	push	{r4, r5, r6, lr}
     cba:	1e04      	subs	r4, r0, #0
	char *newbuffer;int newsize;
	if (!p || !p->buffer) return 0;
     cbc:	d030      	beq.n	d20 <ensure+0x68>
     cbe:	6800      	ldr	r0, [r0, #0]
     cc0:	2800      	cmp	r0, #0
     cc2:	d02e      	beq.n	d22 <ensure+0x6a>
	needed+=p->offset;
     cc4:	68a3      	ldr	r3, [r4, #8]
     cc6:	1859      	adds	r1, r3, r1
	if (needed<=p->length) return p->buffer+p->offset;
     cc8:	6862      	ldr	r2, [r4, #4]
     cca:	18c0      	adds	r0, r0, r3
     ccc:	4291      	cmp	r1, r2
     cce:	dd28      	ble.n	d22 <ensure+0x6a>
	item->valueint=(int)n;
	item->type=cJSON_Number;
	return num;
}

static int pow2gt (int x)	{	--x;	x|=x>>1;	x|=x>>2;	x|=x>>4;	x|=x>>8;	x|=x>>16;	return x+1;	}
     cd0:	3901      	subs	r1, #1
     cd2:	104d      	asrs	r5, r1, #1
     cd4:	430d      	orrs	r5, r1
     cd6:	10ab      	asrs	r3, r5, #2
     cd8:	431d      	orrs	r5, r3
     cda:	112b      	asrs	r3, r5, #4
     cdc:	431d      	orrs	r5, r3
     cde:	122b      	asrs	r3, r5, #8
     ce0:	431d      	orrs	r5, r3
     ce2:	142b      	asrs	r3, r5, #16
     ce4:	431d      	orrs	r5, r3
     ce6:	3501      	adds	r5, #1
	if (!p || !p->buffer) return 0;
	needed+=p->offset;
	if (needed<=p->length) return p->buffer+p->offset;

	newsize=pow2gt(needed);
	newbuffer=(char*)cJSON_malloc(newsize);
     ce8:	4b0e      	ldr	r3, [pc, #56]	; (d24 <ensure+0x6c>)
     cea:	681b      	ldr	r3, [r3, #0]
     cec:	0028      	movs	r0, r5
     cee:	4798      	blx	r3
     cf0:	1e06      	subs	r6, r0, #0
	if (!newbuffer) {cJSON_free(p->buffer);p->length=0,p->buffer=0;return 0;}
     cf2:	d108      	bne.n	d06 <ensure+0x4e>
     cf4:	4b0c      	ldr	r3, [pc, #48]	; (d28 <ensure+0x70>)
     cf6:	681b      	ldr	r3, [r3, #0]
     cf8:	6820      	ldr	r0, [r4, #0]
     cfa:	4798      	blx	r3
     cfc:	2300      	movs	r3, #0
     cfe:	6063      	str	r3, [r4, #4]
     d00:	6023      	str	r3, [r4, #0]
     d02:	2000      	movs	r0, #0
     d04:	e00d      	b.n	d22 <ensure+0x6a>
	if (newbuffer) memcpy(newbuffer,p->buffer,p->length);
     d06:	6862      	ldr	r2, [r4, #4]
     d08:	6821      	ldr	r1, [r4, #0]
     d0a:	4b08      	ldr	r3, [pc, #32]	; (d2c <ensure+0x74>)
     d0c:	4798      	blx	r3
	cJSON_free(p->buffer);
     d0e:	4b06      	ldr	r3, [pc, #24]	; (d28 <ensure+0x70>)
     d10:	681b      	ldr	r3, [r3, #0]
     d12:	6820      	ldr	r0, [r4, #0]
     d14:	4798      	blx	r3
	p->length=newsize;
     d16:	6065      	str	r5, [r4, #4]
	p->buffer=newbuffer;
     d18:	6026      	str	r6, [r4, #0]
	return newbuffer+p->offset;
     d1a:	68a0      	ldr	r0, [r4, #8]
     d1c:	1830      	adds	r0, r6, r0
     d1e:	e000      	b.n	d22 <ensure+0x6a>
typedef struct {char *buffer; int length; int offset; } printbuffer;

static char* ensure(printbuffer *p,int needed)
{
	char *newbuffer;int newsize;
	if (!p || !p->buffer) return 0;
     d20:	2000      	movs	r0, #0
	if (newbuffer) memcpy(newbuffer,p->buffer,p->length);
	cJSON_free(p->buffer);
	p->length=newsize;
	p->buffer=newbuffer;
	return newbuffer+p->offset;
}
     d22:	bd70      	pop	{r4, r5, r6, pc}
     d24:	20000004 	.word	0x20000004
     d28:	20000000 	.word	0x20000000
     d2c:	00011833 	.word	0x00011833

00000d30 <cJSON_strdup>:

static void *(*cJSON_malloc)(size_t sz) = malloc;
static void (*cJSON_free)(void *ptr) = free;

static char* cJSON_strdup(const char* str)
{
     d30:	b570      	push	{r4, r5, r6, lr}
     d32:	0006      	movs	r6, r0
      size_t len;
      char* copy;

      len = strlen(str) + 1;
     d34:	4b07      	ldr	r3, [pc, #28]	; (d54 <cJSON_strdup+0x24>)
     d36:	4798      	blx	r3
     d38:	1c44      	adds	r4, r0, #1
      if (!(copy = (char*)cJSON_malloc(len))) return 0;
     d3a:	4b07      	ldr	r3, [pc, #28]	; (d58 <cJSON_strdup+0x28>)
     d3c:	681b      	ldr	r3, [r3, #0]
     d3e:	0020      	movs	r0, r4
     d40:	4798      	blx	r3
     d42:	1e05      	subs	r5, r0, #0
     d44:	d003      	beq.n	d4e <cJSON_strdup+0x1e>
      memcpy(copy,str,len);
     d46:	0022      	movs	r2, r4
     d48:	0031      	movs	r1, r6
     d4a:	4b04      	ldr	r3, [pc, #16]	; (d5c <cJSON_strdup+0x2c>)
     d4c:	4798      	blx	r3
      return copy;
}
     d4e:	0028      	movs	r0, r5
     d50:	bd70      	pop	{r4, r5, r6, pc}
     d52:	46c0      	nop			; (mov r8, r8)
     d54:	00011d75 	.word	0x00011d75
     d58:	20000004 	.word	0x20000004
     d5c:	00011833 	.word	0x00011833

00000d60 <update>:
	p->buffer=newbuffer;
	return newbuffer+p->offset;
}

static int update(printbuffer *p)
{
     d60:	b510      	push	{r4, lr}
	char *str;
	if (!p || !p->buffer) return 0;
     d62:	2800      	cmp	r0, #0
     d64:	d008      	beq.n	d78 <update+0x18>
     d66:	6803      	ldr	r3, [r0, #0]
     d68:	2b00      	cmp	r3, #0
     d6a:	d007      	beq.n	d7c <update+0x1c>
	str=p->buffer+p->offset;
     d6c:	6884      	ldr	r4, [r0, #8]
	return p->offset+strlen(str);
     d6e:	1918      	adds	r0, r3, r4
     d70:	4b03      	ldr	r3, [pc, #12]	; (d80 <update+0x20>)
     d72:	4798      	blx	r3
     d74:	1820      	adds	r0, r4, r0
     d76:	e002      	b.n	d7e <update+0x1e>
}

static int update(printbuffer *p)
{
	char *str;
	if (!p || !p->buffer) return 0;
     d78:	2000      	movs	r0, #0
     d7a:	e000      	b.n	d7e <update+0x1e>
     d7c:	2000      	movs	r0, #0
	str=p->buffer+p->offset;
	return p->offset+strlen(str);
}
     d7e:	bd10      	pop	{r4, pc}
     d80:	00011d75 	.word	0x00011d75

00000d84 <print_number>:

/* Render the number nicely from the given item into a string. */
static char *print_number(cJSON *item,printbuffer *p)
{
     d84:	b5f0      	push	{r4, r5, r6, r7, lr}
     d86:	4647      	mov	r7, r8
     d88:	b480      	push	{r7}
     d8a:	b082      	sub	sp, #8
     d8c:	0007      	movs	r7, r0
     d8e:	9101      	str	r1, [sp, #4]
	char *str=0;
	double d=item->valuedouble;
     d90:	6984      	ldr	r4, [r0, #24]
     d92:	69c5      	ldr	r5, [r0, #28]
	if (d==0)
     d94:	2200      	movs	r2, #0
     d96:	2300      	movs	r3, #0
     d98:	0020      	movs	r0, r4
     d9a:	0029      	movs	r1, r5
     d9c:	4e55      	ldr	r6, [pc, #340]	; (ef4 <print_number+0x170>)
     d9e:	47b0      	blx	r6
     da0:	2800      	cmp	r0, #0
     da2:	d016      	beq.n	dd2 <print_number+0x4e>
	{
		if (p)	str=ensure(p,2);
     da4:	9b01      	ldr	r3, [sp, #4]
     da6:	2b00      	cmp	r3, #0
     da8:	d005      	beq.n	db6 <print_number+0x32>
     daa:	2102      	movs	r1, #2
     dac:	0018      	movs	r0, r3
     dae:	4b52      	ldr	r3, [pc, #328]	; (ef8 <print_number+0x174>)
     db0:	4798      	blx	r3
     db2:	0006      	movs	r6, r0
     db4:	e004      	b.n	dc0 <print_number+0x3c>
		else	str=(char*)cJSON_malloc(2);	/* special case for 0. */
     db6:	4b51      	ldr	r3, [pc, #324]	; (efc <print_number+0x178>)
     db8:	681b      	ldr	r3, [r3, #0]
     dba:	2002      	movs	r0, #2
     dbc:	4798      	blx	r3
     dbe:	0006      	movs	r6, r0
		if (str) strcpy(str,"0");
     dc0:	2e00      	cmp	r6, #0
     dc2:	d100      	bne.n	dc6 <print_number+0x42>
     dc4:	e090      	b.n	ee8 <print_number+0x164>
     dc6:	2202      	movs	r2, #2
     dc8:	494d      	ldr	r1, [pc, #308]	; (f00 <print_number+0x17c>)
     dca:	0030      	movs	r0, r6
     dcc:	4b4d      	ldr	r3, [pc, #308]	; (f04 <print_number+0x180>)
     dce:	4798      	blx	r3
     dd0:	e08a      	b.n	ee8 <print_number+0x164>
	}
	else if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)
     dd2:	6978      	ldr	r0, [r7, #20]
     dd4:	4b4c      	ldr	r3, [pc, #304]	; (f08 <print_number+0x184>)
     dd6:	4798      	blx	r3
     dd8:	0022      	movs	r2, r4
     dda:	002b      	movs	r3, r5
     ddc:	4e4b      	ldr	r6, [pc, #300]	; (f0c <print_number+0x188>)
     dde:	47b0      	blx	r6
     de0:	0006      	movs	r6, r0
     de2:	004b      	lsls	r3, r1, #1
     de4:	469c      	mov	ip, r3
     de6:	2200      	movs	r2, #0
     de8:	4b49      	ldr	r3, [pc, #292]	; (f10 <print_number+0x18c>)
     dea:	0030      	movs	r0, r6
     dec:	4666      	mov	r6, ip
     dee:	0871      	lsrs	r1, r6, #1
     df0:	4e48      	ldr	r6, [pc, #288]	; (f14 <print_number+0x190>)
     df2:	47b0      	blx	r6
     df4:	2800      	cmp	r0, #0
     df6:	d024      	beq.n	e42 <print_number+0xbe>
     df8:	4a47      	ldr	r2, [pc, #284]	; (f18 <print_number+0x194>)
     dfa:	4b48      	ldr	r3, [pc, #288]	; (f1c <print_number+0x198>)
     dfc:	0020      	movs	r0, r4
     dfe:	0029      	movs	r1, r5
     e00:	47b0      	blx	r6
     e02:	2800      	cmp	r0, #0
     e04:	d01d      	beq.n	e42 <print_number+0xbe>
     e06:	2200      	movs	r2, #0
     e08:	4b45      	ldr	r3, [pc, #276]	; (f20 <print_number+0x19c>)
     e0a:	0020      	movs	r0, r4
     e0c:	0029      	movs	r1, r5
     e0e:	4e45      	ldr	r6, [pc, #276]	; (f24 <print_number+0x1a0>)
     e10:	47b0      	blx	r6
     e12:	2800      	cmp	r0, #0
     e14:	d015      	beq.n	e42 <print_number+0xbe>
	{
		if (p)	str=ensure(p,21);
     e16:	9b01      	ldr	r3, [sp, #4]
     e18:	2b00      	cmp	r3, #0
     e1a:	d005      	beq.n	e28 <print_number+0xa4>
     e1c:	2115      	movs	r1, #21
     e1e:	0018      	movs	r0, r3
     e20:	4b35      	ldr	r3, [pc, #212]	; (ef8 <print_number+0x174>)
     e22:	4798      	blx	r3
     e24:	0006      	movs	r6, r0
     e26:	e004      	b.n	e32 <print_number+0xae>
		else	str=(char*)cJSON_malloc(21);	/* 2^64+1 can be represented in 21 chars. */
     e28:	4b34      	ldr	r3, [pc, #208]	; (efc <print_number+0x178>)
     e2a:	681b      	ldr	r3, [r3, #0]
     e2c:	2015      	movs	r0, #21
     e2e:	4798      	blx	r3
     e30:	0006      	movs	r6, r0
		if (str)	sprintf(str,"%d",item->valueint);
     e32:	2e00      	cmp	r6, #0
     e34:	d058      	beq.n	ee8 <print_number+0x164>
     e36:	697a      	ldr	r2, [r7, #20]
     e38:	493b      	ldr	r1, [pc, #236]	; (f28 <print_number+0x1a4>)
     e3a:	0030      	movs	r0, r6
     e3c:	4b3b      	ldr	r3, [pc, #236]	; (f2c <print_number+0x1a8>)
     e3e:	4798      	blx	r3
     e40:	e052      	b.n	ee8 <print_number+0x164>
	}
	else
	{
		if (p)	str=ensure(p,64);
     e42:	9b01      	ldr	r3, [sp, #4]
     e44:	2b00      	cmp	r3, #0
     e46:	d005      	beq.n	e54 <print_number+0xd0>
     e48:	2140      	movs	r1, #64	; 0x40
     e4a:	0018      	movs	r0, r3
     e4c:	4b2a      	ldr	r3, [pc, #168]	; (ef8 <print_number+0x174>)
     e4e:	4798      	blx	r3
     e50:	0006      	movs	r6, r0
     e52:	e004      	b.n	e5e <print_number+0xda>
		else	str=(char*)cJSON_malloc(64);	/* This is a nice tradeoff. */
     e54:	4b29      	ldr	r3, [pc, #164]	; (efc <print_number+0x178>)
     e56:	681b      	ldr	r3, [r3, #0]
     e58:	2040      	movs	r0, #64	; 0x40
     e5a:	4798      	blx	r3
     e5c:	0006      	movs	r6, r0
		if (str)
     e5e:	2e00      	cmp	r6, #0
     e60:	d042      	beq.n	ee8 <print_number+0x164>
		{
			if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)sprintf(str,"%.0f",d);
     e62:	0020      	movs	r0, r4
     e64:	0029      	movs	r1, r5
     e66:	4b32      	ldr	r3, [pc, #200]	; (f30 <print_number+0x1ac>)
     e68:	4798      	blx	r3
     e6a:	0022      	movs	r2, r4
     e6c:	002b      	movs	r3, r5
     e6e:	4f27      	ldr	r7, [pc, #156]	; (f0c <print_number+0x188>)
     e70:	47b8      	blx	r7
     e72:	9001      	str	r0, [sp, #4]
     e74:	004f      	lsls	r7, r1, #1
     e76:	2200      	movs	r2, #0
     e78:	4b25      	ldr	r3, [pc, #148]	; (f10 <print_number+0x18c>)
     e7a:	9801      	ldr	r0, [sp, #4]
     e7c:	0879      	lsrs	r1, r7, #1
     e7e:	4f25      	ldr	r7, [pc, #148]	; (f14 <print_number+0x190>)
     e80:	47b8      	blx	r7
     e82:	2800      	cmp	r0, #0
     e84:	d00f      	beq.n	ea6 <print_number+0x122>
     e86:	006f      	lsls	r7, r5, #1
     e88:	4a2a      	ldr	r2, [pc, #168]	; (f34 <print_number+0x1b0>)
     e8a:	4b2b      	ldr	r3, [pc, #172]	; (f38 <print_number+0x1b4>)
     e8c:	0020      	movs	r0, r4
     e8e:	0879      	lsrs	r1, r7, #1
     e90:	4f2a      	ldr	r7, [pc, #168]	; (f3c <print_number+0x1b8>)
     e92:	47b8      	blx	r7
     e94:	2800      	cmp	r0, #0
     e96:	d006      	beq.n	ea6 <print_number+0x122>
     e98:	0022      	movs	r2, r4
     e9a:	002b      	movs	r3, r5
     e9c:	4928      	ldr	r1, [pc, #160]	; (f40 <print_number+0x1bc>)
     e9e:	0030      	movs	r0, r6
     ea0:	4c22      	ldr	r4, [pc, #136]	; (f2c <print_number+0x1a8>)
     ea2:	47a0      	blx	r4
     ea4:	e020      	b.n	ee8 <print_number+0x164>
			else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)			sprintf(str,"%e",d);
     ea6:	006f      	lsls	r7, r5, #1
     ea8:	087b      	lsrs	r3, r7, #1
     eaa:	001f      	movs	r7, r3
     eac:	4a25      	ldr	r2, [pc, #148]	; (f44 <print_number+0x1c0>)
     eae:	4b26      	ldr	r3, [pc, #152]	; (f48 <print_number+0x1c4>)
     eb0:	0020      	movs	r0, r4
     eb2:	9701      	str	r7, [sp, #4]
     eb4:	0039      	movs	r1, r7
     eb6:	4f21      	ldr	r7, [pc, #132]	; (f3c <print_number+0x1b8>)
     eb8:	47b8      	blx	r7
     eba:	2800      	cmp	r0, #0
     ebc:	d107      	bne.n	ece <print_number+0x14a>
     ebe:	2200      	movs	r2, #0
     ec0:	4b22      	ldr	r3, [pc, #136]	; (f4c <print_number+0x1c8>)
     ec2:	0020      	movs	r0, r4
     ec4:	9901      	ldr	r1, [sp, #4]
     ec6:	4f22      	ldr	r7, [pc, #136]	; (f50 <print_number+0x1cc>)
     ec8:	47b8      	blx	r7
     eca:	2800      	cmp	r0, #0
     ecc:	d006      	beq.n	edc <print_number+0x158>
     ece:	0022      	movs	r2, r4
     ed0:	002b      	movs	r3, r5
     ed2:	4920      	ldr	r1, [pc, #128]	; (f54 <print_number+0x1d0>)
     ed4:	0030      	movs	r0, r6
     ed6:	4c15      	ldr	r4, [pc, #84]	; (f2c <print_number+0x1a8>)
     ed8:	47a0      	blx	r4
     eda:	e005      	b.n	ee8 <print_number+0x164>
			else												sprintf(str,"%f",d);
     edc:	0022      	movs	r2, r4
     ede:	002b      	movs	r3, r5
     ee0:	491d      	ldr	r1, [pc, #116]	; (f58 <print_number+0x1d4>)
     ee2:	0030      	movs	r0, r6
     ee4:	4c11      	ldr	r4, [pc, #68]	; (f2c <print_number+0x1a8>)
     ee6:	47a0      	blx	r4
		}
	}
	return str;
}
     ee8:	0030      	movs	r0, r6
     eea:	b002      	add	sp, #8
     eec:	bc04      	pop	{r2}
     eee:	4690      	mov	r8, r2
     ef0:	bdf0      	pop	{r4, r5, r6, r7, pc}
     ef2:	46c0      	nop			; (mov r8, r8)
     ef4:	0000fb39 	.word	0x0000fb39
     ef8:	00000cb9 	.word	0x00000cb9
     efc:	20000004 	.word	0x20000004
     f00:	000133e4 	.word	0x000133e4
     f04:	00011833 	.word	0x00011833
     f08:	000116d5 	.word	0x000116d5
     f0c:	00010f81 	.word	0x00010f81
     f10:	3cb00000 	.word	0x3cb00000
     f14:	0000fb59 	.word	0x0000fb59
     f18:	ffc00000 	.word	0xffc00000
     f1c:	41dfffff 	.word	0x41dfffff
     f20:	c1e00000 	.word	0xc1e00000
     f24:	0000fb81 	.word	0x0000fb81
     f28:	000133e8 	.word	0x000133e8
     f2c:	00011c59 	.word	0x00011c59
     f30:	0000e395 	.word	0x0000e395
     f34:	e4c2f344 	.word	0xe4c2f344
     f38:	4c63e9e4 	.word	0x4c63e9e4
     f3c:	0000fb45 	.word	0x0000fb45
     f40:	000133ec 	.word	0x000133ec
     f44:	a0b5ed8d 	.word	0xa0b5ed8d
     f48:	3eb0c6f7 	.word	0x3eb0c6f7
     f4c:	41cdcd65 	.word	0x41cdcd65
     f50:	0000fb6d 	.word	0x0000fb6d
     f54:	000133f4 	.word	0x000133f4
     f58:	000133f8 	.word	0x000133f8

00000f5c <print_string_ptr>:
							0,0,0,0,	0,0,0,0,	0,0,0,0,	0,0,0,0,	0,0,0,0,	0,0,0,0,	0,0,0,0,	0,0,0,0,
							0,0,0,0,	0,0,0,0,	0,0,0,0,	0,0,0,0,	0,0,0,0,	0,0,0,0,	0,0,0,0,	0,0,0,0};

/* Render the cstring provided to an escaped version that can be printed. */
static char *print_string_ptr(const char *str,printbuffer *p)
{
     f5c:	b5f0      	push	{r4, r5, r6, r7, lr}
     f5e:	465f      	mov	r7, fp
     f60:	b480      	push	{r7}
     f62:	b082      	sub	sp, #8
     f64:	0002      	movs	r2, r0
     f66:	9000      	str	r0, [sp, #0]
     f68:	9101      	str	r1, [sp, #4]
	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;
	
	ptr=str;while (*ptr) flag|=escapable[*ptr++];
     f6a:	7806      	ldrb	r6, [r0, #0]
     f6c:	2e00      	cmp	r6, #0
     f6e:	d00c      	beq.n	f8a <print_string_ptr+0x2e>
     f70:	0033      	movs	r3, r6
     f72:	2100      	movs	r1, #0
     f74:	4861      	ldr	r0, [pc, #388]	; (10fc <print_string_ptr+0x1a0>)
     f76:	3201      	adds	r2, #1
     f78:	009b      	lsls	r3, r3, #2
     f7a:	581b      	ldr	r3, [r3, r0]
     f7c:	4319      	orrs	r1, r3
     f7e:	7813      	ldrb	r3, [r2, #0]
     f80:	2b00      	cmp	r3, #0
     f82:	d1f8      	bne.n	f76 <print_string_ptr+0x1a>
	if (!flag)
     f84:	2900      	cmp	r1, #0
     f86:	d121      	bne.n	fcc <print_string_ptr+0x70>
     f88:	e000      	b.n	f8c <print_string_ptr+0x30>
/* Render the cstring provided to an escaped version that can be printed. */
static char *print_string_ptr(const char *str,printbuffer *p)
{
	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;
	
	ptr=str;while (*ptr) flag|=escapable[*ptr++];
     f8a:	9a00      	ldr	r2, [sp, #0]
	if (!flag)
	{
		len=ptr-str;
     f8c:	9b00      	ldr	r3, [sp, #0]
     f8e:	1ad6      	subs	r6, r2, r3
		if (p) out=ensure(p,len+3);
     f90:	9b01      	ldr	r3, [sp, #4]
     f92:	2b00      	cmp	r3, #0
     f94:	d005      	beq.n	fa2 <print_string_ptr+0x46>
     f96:	1cf1      	adds	r1, r6, #3
     f98:	0018      	movs	r0, r3
     f9a:	4b59      	ldr	r3, [pc, #356]	; (1100 <print_string_ptr+0x1a4>)
     f9c:	4798      	blx	r3
     f9e:	0005      	movs	r5, r0
     fa0:	e004      	b.n	fac <print_string_ptr+0x50>
		else		out=(char*)cJSON_malloc(len+3);
     fa2:	1cf0      	adds	r0, r6, #3
     fa4:	4b57      	ldr	r3, [pc, #348]	; (1104 <print_string_ptr+0x1a8>)
     fa6:	681b      	ldr	r3, [r3, #0]
     fa8:	4798      	blx	r3
     faa:	0005      	movs	r5, r0
		if (!out) return 0;
     fac:	2d00      	cmp	r5, #0
     fae:	d100      	bne.n	fb2 <print_string_ptr+0x56>
     fb0:	e09b      	b.n	10ea <print_string_ptr+0x18e>
		ptr2=out;*ptr2++='\"';
     fb2:	1c6f      	adds	r7, r5, #1
     fb4:	2422      	movs	r4, #34	; 0x22
     fb6:	702c      	strb	r4, [r5, #0]
		strcpy(ptr2,str);
     fb8:	9900      	ldr	r1, [sp, #0]
     fba:	0038      	movs	r0, r7
     fbc:	4b52      	ldr	r3, [pc, #328]	; (1108 <print_string_ptr+0x1ac>)
     fbe:	4798      	blx	r3
		ptr2[len]='\"';
     fc0:	55bc      	strb	r4, [r7, r6]
		ptr2[len+1]=0;
     fc2:	19ba      	adds	r2, r7, r6
     fc4:	2300      	movs	r3, #0
     fc6:	7053      	strb	r3, [r2, #1]
		return out;
     fc8:	0028      	movs	r0, r5
     fca:	e093      	b.n	10f4 <print_string_ptr+0x198>
	}
	
	if (!str)
     fcc:	9b00      	ldr	r3, [sp, #0]
     fce:	2b00      	cmp	r3, #0
     fd0:	d116      	bne.n	1000 <print_string_ptr+0xa4>
	{
		if (p)	out=ensure(p,3);
     fd2:	9b01      	ldr	r3, [sp, #4]
     fd4:	2b00      	cmp	r3, #0
     fd6:	d005      	beq.n	fe4 <print_string_ptr+0x88>
     fd8:	2103      	movs	r1, #3
     fda:	0018      	movs	r0, r3
     fdc:	4b48      	ldr	r3, [pc, #288]	; (1100 <print_string_ptr+0x1a4>)
     fde:	4798      	blx	r3
     fe0:	0005      	movs	r5, r0
     fe2:	e004      	b.n	fee <print_string_ptr+0x92>
		else	out=(char*)cJSON_malloc(3);
     fe4:	4b47      	ldr	r3, [pc, #284]	; (1104 <print_string_ptr+0x1a8>)
     fe6:	681b      	ldr	r3, [r3, #0]
     fe8:	2003      	movs	r0, #3
     fea:	4798      	blx	r3
     fec:	0005      	movs	r5, r0
		if (!out) return 0;
     fee:	2d00      	cmp	r5, #0
     ff0:	d07d      	beq.n	10ee <print_string_ptr+0x192>
		strcpy(out,"\"\"");
     ff2:	2203      	movs	r2, #3
     ff4:	4945      	ldr	r1, [pc, #276]	; (110c <print_string_ptr+0x1b0>)
     ff6:	0028      	movs	r0, r5
     ff8:	4b45      	ldr	r3, [pc, #276]	; (1110 <print_string_ptr+0x1b4>)
     ffa:	4798      	blx	r3
		return out;
     ffc:	0028      	movs	r0, r5
     ffe:	e079      	b.n	10f4 <print_string_ptr+0x198>
    1000:	9c00      	ldr	r4, [sp, #0]
    1002:	2501      	movs	r5, #1
    1004:	2700      	movs	r7, #0
	}
	ptr=str;while ((token=*ptr) && ++len) {if (strchr("\"\\\b\f\n\r\t",token)) len++; else if (token<32) len+=5;ptr++;}
    1006:	4b43      	ldr	r3, [pc, #268]	; (1114 <print_string_ptr+0x1b8>)
    1008:	469b      	mov	fp, r3
    100a:	0031      	movs	r1, r6
    100c:	4842      	ldr	r0, [pc, #264]	; (1118 <print_string_ptr+0x1bc>)
    100e:	47d8      	blx	fp
    1010:	2800      	cmp	r0, #0
    1012:	d001      	beq.n	1018 <print_string_ptr+0xbc>
    1014:	3702      	adds	r7, #2
    1016:	e003      	b.n	1020 <print_string_ptr+0xc4>
    1018:	3706      	adds	r7, #6
    101a:	2e1f      	cmp	r6, #31
    101c:	d900      	bls.n	1020 <print_string_ptr+0xc4>
    101e:	002f      	movs	r7, r5
    1020:	3401      	adds	r4, #1
    1022:	7826      	ldrb	r6, [r4, #0]
    1024:	2e00      	cmp	r6, #0
    1026:	d003      	beq.n	1030 <print_string_ptr+0xd4>
    1028:	1c7d      	adds	r5, r7, #1
    102a:	2d00      	cmp	r5, #0
    102c:	d1ed      	bne.n	100a <print_string_ptr+0xae>
    102e:	002f      	movs	r7, r5
	
	if (p)	out=ensure(p,len+3);
    1030:	9b01      	ldr	r3, [sp, #4]
    1032:	2b00      	cmp	r3, #0
    1034:	d005      	beq.n	1042 <print_string_ptr+0xe6>
    1036:	1cf9      	adds	r1, r7, #3
    1038:	0018      	movs	r0, r3
    103a:	4b31      	ldr	r3, [pc, #196]	; (1100 <print_string_ptr+0x1a4>)
    103c:	4798      	blx	r3
    103e:	0006      	movs	r6, r0
    1040:	e004      	b.n	104c <print_string_ptr+0xf0>
	else	out=(char*)cJSON_malloc(len+3);
    1042:	1cf8      	adds	r0, r7, #3
    1044:	4b2f      	ldr	r3, [pc, #188]	; (1104 <print_string_ptr+0x1a8>)
    1046:	681b      	ldr	r3, [r3, #0]
    1048:	4798      	blx	r3
    104a:	0006      	movs	r6, r0
	if (!out) return 0;
    104c:	2e00      	cmp	r6, #0
    104e:	d050      	beq.n	10f2 <print_string_ptr+0x196>

	ptr2=out;ptr=str;
	*ptr2++='\"';
    1050:	1c75      	adds	r5, r6, #1
    1052:	2322      	movs	r3, #34	; 0x22
    1054:	7033      	strb	r3, [r6, #0]
    1056:	9c00      	ldr	r4, [sp, #0]
	while (*ptr)
	{
		if ((unsigned char)*ptr>31 && *ptr!='\"' && *ptr!='\\') *ptr2++=*ptr++;
		else
		{
			*ptr2++='\\';
    1058:	275c      	movs	r7, #92	; 0x5c
	else	out=(char*)cJSON_malloc(len+3);
	if (!out) return 0;

	ptr2=out;ptr=str;
	*ptr2++='\"';
	while (*ptr)
    105a:	e03c      	b.n	10d6 <print_string_ptr+0x17a>
	{
		if ((unsigned char)*ptr>31 && *ptr!='\"' && *ptr!='\\') *ptr2++=*ptr++;
    105c:	2b1f      	cmp	r3, #31
    105e:	d906      	bls.n	106e <print_string_ptr+0x112>
    1060:	2b22      	cmp	r3, #34	; 0x22
    1062:	d004      	beq.n	106e <print_string_ptr+0x112>
    1064:	2b5c      	cmp	r3, #92	; 0x5c
    1066:	d002      	beq.n	106e <print_string_ptr+0x112>
    1068:	702b      	strb	r3, [r5, #0]
    106a:	3501      	adds	r5, #1
    106c:	e032      	b.n	10d4 <print_string_ptr+0x178>
		else
		{
			*ptr2++='\\';
    106e:	702f      	strb	r7, [r5, #0]
			switch (token=*ptr++)
    1070:	7812      	ldrb	r2, [r2, #0]
    1072:	2a0c      	cmp	r2, #12
    1074:	d019      	beq.n	10aa <print_string_ptr+0x14e>
    1076:	d806      	bhi.n	1086 <print_string_ptr+0x12a>
    1078:	2a09      	cmp	r2, #9
    107a:	d022      	beq.n	10c2 <print_string_ptr+0x166>
    107c:	2a0a      	cmp	r2, #10
    107e:	d018      	beq.n	10b2 <print_string_ptr+0x156>
    1080:	2a08      	cmp	r2, #8
    1082:	d122      	bne.n	10ca <print_string_ptr+0x16e>
    1084:	e00d      	b.n	10a2 <print_string_ptr+0x146>
    1086:	2a22      	cmp	r2, #34	; 0x22
    1088:	d007      	beq.n	109a <print_string_ptr+0x13e>
    108a:	2a5c      	cmp	r2, #92	; 0x5c
    108c:	d002      	beq.n	1094 <print_string_ptr+0x138>
    108e:	2a0d      	cmp	r2, #13
    1090:	d11b      	bne.n	10ca <print_string_ptr+0x16e>
    1092:	e012      	b.n	10ba <print_string_ptr+0x15e>
			{
				case '\\':	*ptr2++='\\';	break;
    1094:	706f      	strb	r7, [r5, #1]
    1096:	3502      	adds	r5, #2
    1098:	e01c      	b.n	10d4 <print_string_ptr+0x178>
				case '\"':	*ptr2++='\"';	break;
    109a:	2322      	movs	r3, #34	; 0x22
    109c:	706b      	strb	r3, [r5, #1]
    109e:	3502      	adds	r5, #2
    10a0:	e018      	b.n	10d4 <print_string_ptr+0x178>
				case '\b':	*ptr2++='b';	break;
    10a2:	2362      	movs	r3, #98	; 0x62
    10a4:	706b      	strb	r3, [r5, #1]
    10a6:	3502      	adds	r5, #2
    10a8:	e014      	b.n	10d4 <print_string_ptr+0x178>
				case '\f':	*ptr2++='f';	break;
    10aa:	2366      	movs	r3, #102	; 0x66
    10ac:	706b      	strb	r3, [r5, #1]
    10ae:	3502      	adds	r5, #2
    10b0:	e010      	b.n	10d4 <print_string_ptr+0x178>
				case '\n':	*ptr2++='n';	break;
    10b2:	236e      	movs	r3, #110	; 0x6e
    10b4:	706b      	strb	r3, [r5, #1]
    10b6:	3502      	adds	r5, #2
    10b8:	e00c      	b.n	10d4 <print_string_ptr+0x178>
				case '\r':	*ptr2++='r';	break;
    10ba:	2372      	movs	r3, #114	; 0x72
    10bc:	706b      	strb	r3, [r5, #1]
    10be:	3502      	adds	r5, #2
    10c0:	e008      	b.n	10d4 <print_string_ptr+0x178>
				case '\t':	*ptr2++='t';	break;
    10c2:	2374      	movs	r3, #116	; 0x74
    10c4:	706b      	strb	r3, [r5, #1]
    10c6:	3502      	adds	r5, #2
    10c8:	e004      	b.n	10d4 <print_string_ptr+0x178>
				default: sprintf(ptr2,"u%04x",token);ptr2+=5;	break;	/* escape and print */
    10ca:	1c68      	adds	r0, r5, #1
    10cc:	4913      	ldr	r1, [pc, #76]	; (111c <print_string_ptr+0x1c0>)
    10ce:	4b14      	ldr	r3, [pc, #80]	; (1120 <print_string_ptr+0x1c4>)
    10d0:	4798      	blx	r3
    10d2:	3506      	adds	r5, #6
    10d4:	3401      	adds	r4, #1
    10d6:	0022      	movs	r2, r4
	else	out=(char*)cJSON_malloc(len+3);
	if (!out) return 0;

	ptr2=out;ptr=str;
	*ptr2++='\"';
	while (*ptr)
    10d8:	7823      	ldrb	r3, [r4, #0]
    10da:	2b00      	cmp	r3, #0
    10dc:	d1be      	bne.n	105c <print_string_ptr+0x100>
				case '\t':	*ptr2++='t';	break;
				default: sprintf(ptr2,"u%04x",token);ptr2+=5;	break;	/* escape and print */
			}
		}
	}
	*ptr2++='\"';*ptr2++=0;
    10de:	3322      	adds	r3, #34	; 0x22
    10e0:	702b      	strb	r3, [r5, #0]
    10e2:	2300      	movs	r3, #0
    10e4:	706b      	strb	r3, [r5, #1]
	return out;
    10e6:	0030      	movs	r0, r6
    10e8:	e004      	b.n	10f4 <print_string_ptr+0x198>
	if (!flag)
	{
		len=ptr-str;
		if (p) out=ensure(p,len+3);
		else		out=(char*)cJSON_malloc(len+3);
		if (!out) return 0;
    10ea:	0028      	movs	r0, r5
    10ec:	e002      	b.n	10f4 <print_string_ptr+0x198>
	
	if (!str)
	{
		if (p)	out=ensure(p,3);
		else	out=(char*)cJSON_malloc(3);
		if (!out) return 0;
    10ee:	0028      	movs	r0, r5
    10f0:	e000      	b.n	10f4 <print_string_ptr+0x198>
	}
	ptr=str;while ((token=*ptr) && ++len) {if (strchr("\"\\\b\f\n\r\t",token)) len++; else if (token<32) len+=5;ptr++;}
	
	if (p)	out=ensure(p,len+3);
	else	out=(char*)cJSON_malloc(len+3);
	if (!out) return 0;
    10f2:	2000      	movs	r0, #0
			}
		}
	}
	*ptr2++='\"';*ptr2++=0;
	return out;
}
    10f4:	b002      	add	sp, #8
    10f6:	bc04      	pop	{r2}
    10f8:	4693      	mov	fp, r2
    10fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    10fc:	00012fcc 	.word	0x00012fcc
    1100:	00000cb9 	.word	0x00000cb9
    1104:	20000004 	.word	0x20000004
    1108:	00011d65 	.word	0x00011d65
    110c:	000133fc 	.word	0x000133fc
    1110:	00011833 	.word	0x00011833
    1114:	00011d35 	.word	0x00011d35
    1118:	00013400 	.word	0x00013400
    111c:	00013408 	.word	0x00013408
    1120:	00011c59 	.word	0x00011c59

00001124 <print_value>:
	ep=value;return 0;	/* failure. */
}

/* Render a value to text. */
static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)
{
    1124:	b570      	push	{r4, r5, r6, lr}
	char *out=0;
	if (!item) return 0;
    1126:	2800      	cmp	r0, #0
    1128:	d05f      	beq.n	11ea <print_value+0xc6>
	if (p)
    112a:	2b00      	cmp	r3, #0
    112c:	d039      	beq.n	11a2 <print_value+0x7e>
	{
		switch ((item->type)&255)
    112e:	7b04      	ldrb	r4, [r0, #12]
    1130:	2c06      	cmp	r4, #6
    1132:	d85c      	bhi.n	11ee <print_value+0xca>
    1134:	00a4      	lsls	r4, r4, #2
    1136:	4d31      	ldr	r5, [pc, #196]	; (11fc <print_value+0xd8>)
    1138:	592c      	ldr	r4, [r5, r4]
    113a:	46a7      	mov	pc, r4
		{
			case cJSON_NULL:	{out=ensure(p,5);	if (out) strcpy(out,"null");	break;}
    113c:	2105      	movs	r1, #5
    113e:	0018      	movs	r0, r3
    1140:	4b2f      	ldr	r3, [pc, #188]	; (1200 <print_value+0xdc>)
    1142:	4798      	blx	r3
    1144:	1e04      	subs	r4, r0, #0
    1146:	d054      	beq.n	11f2 <print_value+0xce>
    1148:	2205      	movs	r2, #5
    114a:	492e      	ldr	r1, [pc, #184]	; (1204 <print_value+0xe0>)
    114c:	4b2e      	ldr	r3, [pc, #184]	; (1208 <print_value+0xe4>)
    114e:	4798      	blx	r3
    1150:	0020      	movs	r0, r4
    1152:	e052      	b.n	11fa <print_value+0xd6>
			case cJSON_False:	{out=ensure(p,6);	if (out) strcpy(out,"false");	break;}
    1154:	2106      	movs	r1, #6
    1156:	0018      	movs	r0, r3
    1158:	4b29      	ldr	r3, [pc, #164]	; (1200 <print_value+0xdc>)
    115a:	4798      	blx	r3
    115c:	1e04      	subs	r4, r0, #0
    115e:	d049      	beq.n	11f4 <print_value+0xd0>
    1160:	2206      	movs	r2, #6
    1162:	492a      	ldr	r1, [pc, #168]	; (120c <print_value+0xe8>)
    1164:	4b28      	ldr	r3, [pc, #160]	; (1208 <print_value+0xe4>)
    1166:	4798      	blx	r3
    1168:	0020      	movs	r0, r4
    116a:	e046      	b.n	11fa <print_value+0xd6>
			case cJSON_True:	{out=ensure(p,5);	if (out) strcpy(out,"true");	break;}
    116c:	2105      	movs	r1, #5
    116e:	0018      	movs	r0, r3
    1170:	4b23      	ldr	r3, [pc, #140]	; (1200 <print_value+0xdc>)
    1172:	4798      	blx	r3
    1174:	1e04      	subs	r4, r0, #0
    1176:	d03e      	beq.n	11f6 <print_value+0xd2>
    1178:	2205      	movs	r2, #5
    117a:	4925      	ldr	r1, [pc, #148]	; (1210 <print_value+0xec>)
    117c:	4b22      	ldr	r3, [pc, #136]	; (1208 <print_value+0xe4>)
    117e:	4798      	blx	r3
    1180:	0020      	movs	r0, r4
    1182:	e03a      	b.n	11fa <print_value+0xd6>
			case cJSON_Number:	out=print_number(item,p);break;
    1184:	0019      	movs	r1, r3
    1186:	4b23      	ldr	r3, [pc, #140]	; (1214 <print_value+0xf0>)
    1188:	4798      	blx	r3
    118a:	e036      	b.n	11fa <print_value+0xd6>
	}
	*ptr2++='\"';*ptr2++=0;
	return out;
}
/* Invote print_string_ptr (which is useful) on an item. */
static char *print_string(cJSON *item,printbuffer *p)	{return print_string_ptr(item->valuestring,p);}
    118c:	6900      	ldr	r0, [r0, #16]
    118e:	0019      	movs	r1, r3
    1190:	4b21      	ldr	r3, [pc, #132]	; (1218 <print_value+0xf4>)
    1192:	4798      	blx	r3
		{
			case cJSON_NULL:	{out=ensure(p,5);	if (out) strcpy(out,"null");	break;}
			case cJSON_False:	{out=ensure(p,6);	if (out) strcpy(out,"false");	break;}
			case cJSON_True:	{out=ensure(p,5);	if (out) strcpy(out,"true");	break;}
			case cJSON_Number:	out=print_number(item,p);break;
			case cJSON_String:	out=print_string(item,p);break;
    1194:	e031      	b.n	11fa <print_value+0xd6>
			case cJSON_Array:	out=print_array(item,depth,fmt,p);break;
    1196:	4c21      	ldr	r4, [pc, #132]	; (121c <print_value+0xf8>)
    1198:	47a0      	blx	r4
    119a:	e02e      	b.n	11fa <print_value+0xd6>
			case cJSON_Object:	out=print_object(item,depth,fmt,p);break;
    119c:	4c20      	ldr	r4, [pc, #128]	; (1220 <print_value+0xfc>)
    119e:	47a0      	blx	r4
    11a0:	e02b      	b.n	11fa <print_value+0xd6>
		}
	}
	else
	{
		switch ((item->type)&255)
    11a2:	7b03      	ldrb	r3, [r0, #12]
    11a4:	2b06      	cmp	r3, #6
    11a6:	d827      	bhi.n	11f8 <print_value+0xd4>
    11a8:	009b      	lsls	r3, r3, #2
    11aa:	4c1e      	ldr	r4, [pc, #120]	; (1224 <print_value+0x100>)
    11ac:	58e3      	ldr	r3, [r4, r3]
    11ae:	469f      	mov	pc, r3
		{
			case cJSON_NULL:	out=cJSON_strdup("null");	break;
    11b0:	4814      	ldr	r0, [pc, #80]	; (1204 <print_value+0xe0>)
    11b2:	4b1d      	ldr	r3, [pc, #116]	; (1228 <print_value+0x104>)
    11b4:	4798      	blx	r3
    11b6:	e020      	b.n	11fa <print_value+0xd6>
			case cJSON_False:	out=cJSON_strdup("false");break;
    11b8:	4814      	ldr	r0, [pc, #80]	; (120c <print_value+0xe8>)
    11ba:	4b1b      	ldr	r3, [pc, #108]	; (1228 <print_value+0x104>)
    11bc:	4798      	blx	r3
    11be:	e01c      	b.n	11fa <print_value+0xd6>
			case cJSON_True:	out=cJSON_strdup("true"); break;
    11c0:	4813      	ldr	r0, [pc, #76]	; (1210 <print_value+0xec>)
    11c2:	4b19      	ldr	r3, [pc, #100]	; (1228 <print_value+0x104>)
    11c4:	4798      	blx	r3
    11c6:	e018      	b.n	11fa <print_value+0xd6>
			case cJSON_Number:	out=print_number(item,0);break;
    11c8:	2100      	movs	r1, #0
    11ca:	4b12      	ldr	r3, [pc, #72]	; (1214 <print_value+0xf0>)
    11cc:	4798      	blx	r3
    11ce:	e014      	b.n	11fa <print_value+0xd6>
	}
	*ptr2++='\"';*ptr2++=0;
	return out;
}
/* Invote print_string_ptr (which is useful) on an item. */
static char *print_string(cJSON *item,printbuffer *p)	{return print_string_ptr(item->valuestring,p);}
    11d0:	6900      	ldr	r0, [r0, #16]
    11d2:	2100      	movs	r1, #0
    11d4:	4b10      	ldr	r3, [pc, #64]	; (1218 <print_value+0xf4>)
    11d6:	4798      	blx	r3
		{
			case cJSON_NULL:	out=cJSON_strdup("null");	break;
			case cJSON_False:	out=cJSON_strdup("false");break;
			case cJSON_True:	out=cJSON_strdup("true"); break;
			case cJSON_Number:	out=print_number(item,0);break;
			case cJSON_String:	out=print_string(item,0);break;
    11d8:	e00f      	b.n	11fa <print_value+0xd6>
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
    11da:	2300      	movs	r3, #0
    11dc:	4c0f      	ldr	r4, [pc, #60]	; (121c <print_value+0xf8>)
    11de:	47a0      	blx	r4
    11e0:	e00b      	b.n	11fa <print_value+0xd6>
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
    11e2:	2300      	movs	r3, #0
    11e4:	4c0e      	ldr	r4, [pc, #56]	; (1220 <print_value+0xfc>)
    11e6:	47a0      	blx	r4
    11e8:	e007      	b.n	11fa <print_value+0xd6>

/* Render a value to text. */
static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)
{
	char *out=0;
	if (!item) return 0;
    11ea:	2000      	movs	r0, #0
    11ec:	e005      	b.n	11fa <print_value+0xd6>
}

/* Render a value to text. */
static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)
{
	char *out=0;
    11ee:	2000      	movs	r0, #0
    11f0:	e003      	b.n	11fa <print_value+0xd6>
    11f2:	e002      	b.n	11fa <print_value+0xd6>
    11f4:	e001      	b.n	11fa <print_value+0xd6>
    11f6:	e000      	b.n	11fa <print_value+0xd6>
    11f8:	2000      	movs	r0, #0
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
		}
	}
	return out;
}
    11fa:	bd70      	pop	{r4, r5, r6, pc}
    11fc:	00012f8c 	.word	0x00012f8c
    1200:	00000cb9 	.word	0x00000cb9
    1204:	000133cc 	.word	0x000133cc
    1208:	00011833 	.word	0x00011833
    120c:	000133d4 	.word	0x000133d4
    1210:	000133dc 	.word	0x000133dc
    1214:	00000d85 	.word	0x00000d85
    1218:	00000f5d 	.word	0x00000f5d
    121c:	000017ad 	.word	0x000017ad
    1220:	0000122d 	.word	0x0000122d
    1224:	00012fa8 	.word	0x00012fa8
    1228:	00000d31 	.word	0x00000d31

0000122c <print_object>:
	ep=value;return 0;	/* malformed. */
}

/* Render an object to text. */
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)
{
    122c:	b5f0      	push	{r4, r5, r6, r7, lr}
    122e:	465f      	mov	r7, fp
    1230:	4656      	mov	r6, sl
    1232:	464d      	mov	r5, r9
    1234:	4644      	mov	r4, r8
    1236:	b4f0      	push	{r4, r5, r6, r7}
    1238:	b089      	sub	sp, #36	; 0x24
    123a:	0006      	movs	r6, r0
    123c:	9101      	str	r1, [sp, #4]
    123e:	4693      	mov	fp, r2
    1240:	001c      	movs	r4, r3
	char **entries=0,**names=0;
	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;
	cJSON *child=item->child;
    1242:	6883      	ldr	r3, [r0, #8]
	int numentries=0,fail=0;
	size_t tmplen=0;
	/* Count the number of entries. */
	while (child) numentries++,child=child->next;
    1244:	2b00      	cmp	r3, #0
    1246:	d008      	beq.n	125a <print_object+0x2e>
    1248:	2700      	movs	r7, #0
    124a:	e000      	b.n	124e <print_object+0x22>
    124c:	002f      	movs	r7, r5
    124e:	1c7d      	adds	r5, r7, #1
    1250:	681b      	ldr	r3, [r3, #0]
    1252:	2b00      	cmp	r3, #0
    1254:	d1fa      	bne.n	124c <print_object+0x20>
	/* Explicitly handle empty object case */
	if (!numentries)
    1256:	2d00      	cmp	r5, #0
    1258:	d133      	bne.n	12c2 <print_object+0x96>
	{
		if (p) out=ensure(p,fmt?depth+4:3);
    125a:	2c00      	cmp	r4, #0
    125c:	d009      	beq.n	1272 <print_object+0x46>
    125e:	2103      	movs	r1, #3
    1260:	465b      	mov	r3, fp
    1262:	2b00      	cmp	r3, #0
    1264:	d001      	beq.n	126a <print_object+0x3e>
    1266:	9b01      	ldr	r3, [sp, #4]
    1268:	1d19      	adds	r1, r3, #4
    126a:	0020      	movs	r0, r4
    126c:	4bc9      	ldr	r3, [pc, #804]	; (1594 <print_object+0x368>)
    126e:	4798      	blx	r3
    1270:	e008      	b.n	1284 <print_object+0x58>
		else	out=(char*)cJSON_malloc(fmt?depth+4:3);
    1272:	4bc9      	ldr	r3, [pc, #804]	; (1598 <print_object+0x36c>)
    1274:	681b      	ldr	r3, [r3, #0]
    1276:	2003      	movs	r0, #3
    1278:	465a      	mov	r2, fp
    127a:	2a00      	cmp	r2, #0
    127c:	d001      	beq.n	1282 <print_object+0x56>
    127e:	9a01      	ldr	r2, [sp, #4]
    1280:	1d10      	adds	r0, r2, #4
    1282:	4798      	blx	r3
		if (!out)	return 0;
    1284:	2800      	cmp	r0, #0
    1286:	d100      	bne.n	128a <print_object+0x5e>
    1288:	e1cd      	b.n	1626 <print_object+0x3fa>
		ptr=out;*ptr++='{';
    128a:	237b      	movs	r3, #123	; 0x7b
    128c:	7003      	strb	r3, [r0, #0]
		if (fmt) {*ptr++='\n';for (i=0;i<depth-1;i++) *ptr++='\t';}
    128e:	465b      	mov	r3, fp
	if (!numentries)
	{
		if (p) out=ensure(p,fmt?depth+4:3);
		else	out=(char*)cJSON_malloc(fmt?depth+4:3);
		if (!out)	return 0;
		ptr=out;*ptr++='{';
    1290:	1c44      	adds	r4, r0, #1
		if (fmt) {*ptr++='\n';for (i=0;i<depth-1;i++) *ptr++='\t';}
    1292:	2b00      	cmp	r3, #0
    1294:	d010      	beq.n	12b8 <print_object+0x8c>
    1296:	1c84      	adds	r4, r0, #2
    1298:	230a      	movs	r3, #10
    129a:	7043      	strb	r3, [r0, #1]
    129c:	9a01      	ldr	r2, [sp, #4]
    129e:	0013      	movs	r3, r2
    12a0:	3b01      	subs	r3, #1
    12a2:	2b00      	cmp	r3, #0
    12a4:	dd08      	ble.n	12b8 <print_object+0x8c>
    12a6:	0023      	movs	r3, r4
    12a8:	3a01      	subs	r2, #1
    12aa:	18a4      	adds	r4, r4, r2
    12ac:	0021      	movs	r1, r4
    12ae:	2209      	movs	r2, #9
    12b0:	701a      	strb	r2, [r3, #0]
    12b2:	3301      	adds	r3, #1
    12b4:	4299      	cmp	r1, r3
    12b6:	d1fb      	bne.n	12b0 <print_object+0x84>
		*ptr++='}';*ptr++=0;
    12b8:	237d      	movs	r3, #125	; 0x7d
    12ba:	7023      	strb	r3, [r4, #0]
    12bc:	2300      	movs	r3, #0
    12be:	7063      	strb	r3, [r4, #1]
		return out;
    12c0:	e25f      	b.n	1782 <print_object+0x556>
	}
	if (p)
    12c2:	2c00      	cmp	r4, #0
    12c4:	d100      	bne.n	12c8 <print_object+0x9c>
    12c6:	e0a6      	b.n	1416 <print_object+0x1ea>
	{
		/* Compose the output: */
		i=p->offset;
    12c8:	68a3      	ldr	r3, [r4, #8]
    12ca:	9302      	str	r3, [sp, #8]
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
    12cc:	465b      	mov	r3, fp
    12ce:	2b00      	cmp	r3, #0
    12d0:	d000      	beq.n	12d4 <print_object+0xa8>
    12d2:	e1ca      	b.n	166a <print_object+0x43e>
    12d4:	2102      	movs	r1, #2
    12d6:	0020      	movs	r0, r4
    12d8:	4bae      	ldr	r3, [pc, #696]	; (1594 <print_object+0x368>)
    12da:	4798      	blx	r3
    12dc:	2800      	cmp	r0, #0
    12de:	d100      	bne.n	12e2 <print_object+0xb6>
    12e0:	e1a3      	b.n	162a <print_object+0x3fe>
		*ptr++='{';	if (fmt) *ptr++='\n';	*ptr=0;	p->offset+=len;
    12e2:	237b      	movs	r3, #123	; 0x7b
    12e4:	7003      	strb	r3, [r0, #0]
    12e6:	2300      	movs	r3, #0
    12e8:	7043      	strb	r3, [r0, #1]
    12ea:	68a3      	ldr	r3, [r4, #8]
    12ec:	3301      	adds	r3, #1
    12ee:	60a3      	str	r3, [r4, #8]
		child=item->child;depth++;
    12f0:	68b6      	ldr	r6, [r6, #8]
    12f2:	9b01      	ldr	r3, [sp, #4]
    12f4:	1c5f      	adds	r7, r3, #1
		while (child)
    12f6:	2e00      	cmp	r6, #0
    12f8:	d100      	bne.n	12fc <print_object+0xd0>
    12fa:	e1ca      	b.n	1692 <print_object+0x466>
    12fc:	465b      	mov	r3, fp
    12fe:	425a      	negs	r2, r3
    1300:	4153      	adcs	r3, r2
    1302:	2202      	movs	r2, #2
    1304:	1ad3      	subs	r3, r2, r3
    1306:	4698      	mov	r8, r3
				ptr=ensure(p,depth);	if (!ptr) return 0;
				for (j=0;j<depth;j++) *ptr++='\t';
				p->offset+=depth;
			}
			print_string_ptr(child->string,p);
			p->offset=update(p);
    1308:	4ba4      	ldr	r3, [pc, #656]	; (159c <print_object+0x370>)
    130a:	469a      	mov	sl, r3
			
			len=fmt?2:1;
			ptr=ensure(p,len);	if (!ptr) return 0;
    130c:	4ba1      	ldr	r3, [pc, #644]	; (1594 <print_object+0x368>)
    130e:	4699      	mov	r9, r3
    1310:	9700      	str	r7, [sp, #0]
    1312:	465d      	mov	r5, fp
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
		*ptr++='{';	if (fmt) *ptr++='\n';	*ptr=0;	p->offset+=len;
		child=item->child;depth++;
		while (child)
		{
			if (fmt)
    1314:	2d00      	cmp	r5, #0
    1316:	d100      	bne.n	131a <print_object+0xee>
    1318:	e1ae      	b.n	1678 <print_object+0x44c>
			{
				ptr=ensure(p,depth);	if (!ptr) return 0;
    131a:	9f00      	ldr	r7, [sp, #0]
    131c:	0039      	movs	r1, r7
    131e:	0020      	movs	r0, r4
    1320:	4b9c      	ldr	r3, [pc, #624]	; (1594 <print_object+0x368>)
    1322:	4798      	blx	r3
    1324:	2800      	cmp	r0, #0
    1326:	d100      	bne.n	132a <print_object+0xfe>
    1328:	e181      	b.n	162e <print_object+0x402>
				for (j=0;j<depth;j++) *ptr++='\t';
    132a:	2f00      	cmp	r7, #0
    132c:	dd08      	ble.n	1340 <print_object+0x114>
    132e:	0003      	movs	r3, r0
    1330:	46bc      	mov	ip, r7
    1332:	4460      	add	r0, ip
    1334:	2209      	movs	r2, #9
    1336:	701a      	strb	r2, [r3, #0]
    1338:	3301      	adds	r3, #1
    133a:	4283      	cmp	r3, r0
    133c:	d1fb      	bne.n	1336 <print_object+0x10a>
    133e:	9700      	str	r7, [sp, #0]
				p->offset+=depth;
    1340:	68a3      	ldr	r3, [r4, #8]
    1342:	9a00      	ldr	r2, [sp, #0]
    1344:	4694      	mov	ip, r2
    1346:	4463      	add	r3, ip
    1348:	60a3      	str	r3, [r4, #8]
			}
			print_string_ptr(child->string,p);
    134a:	0021      	movs	r1, r4
    134c:	6a30      	ldr	r0, [r6, #32]
    134e:	4b94      	ldr	r3, [pc, #592]	; (15a0 <print_object+0x374>)
    1350:	4798      	blx	r3
			p->offset=update(p);
    1352:	0020      	movs	r0, r4
    1354:	4b91      	ldr	r3, [pc, #580]	; (159c <print_object+0x370>)
    1356:	4798      	blx	r3
    1358:	60a0      	str	r0, [r4, #8]
			
			len=fmt?2:1;
			ptr=ensure(p,len);	if (!ptr) return 0;
    135a:	4641      	mov	r1, r8
    135c:	0020      	movs	r0, r4
    135e:	4b8d      	ldr	r3, [pc, #564]	; (1594 <print_object+0x368>)
    1360:	4798      	blx	r3
    1362:	2800      	cmp	r0, #0
    1364:	d000      	beq.n	1368 <print_object+0x13c>
    1366:	e1f5      	b.n	1754 <print_object+0x528>
    1368:	e163      	b.n	1632 <print_object+0x406>
			*ptr++=':';if (fmt) *ptr++='\t';
			p->offset+=len;
    136a:	68a3      	ldr	r3, [r4, #8]
    136c:	4443      	add	r3, r8
    136e:	60a3      	str	r3, [r4, #8]
			
			print_value(child,depth,fmt,p);
    1370:	0023      	movs	r3, r4
    1372:	002a      	movs	r2, r5
    1374:	9900      	ldr	r1, [sp, #0]
    1376:	0030      	movs	r0, r6
    1378:	4f8a      	ldr	r7, [pc, #552]	; (15a4 <print_object+0x378>)
    137a:	47b8      	blx	r7
			p->offset=update(p);
    137c:	0020      	movs	r0, r4
    137e:	4b87      	ldr	r3, [pc, #540]	; (159c <print_object+0x370>)
    1380:	4798      	blx	r3
    1382:	60a0      	str	r0, [r4, #8]

			len=(fmt?1:0)+(child->next?1:0);
    1384:	6833      	ldr	r3, [r6, #0]
    1386:	1e5a      	subs	r2, r3, #1
    1388:	4193      	sbcs	r3, r2
    138a:	002a      	movs	r2, r5
    138c:	1e51      	subs	r1, r2, #1
    138e:	418a      	sbcs	r2, r1
    1390:	469b      	mov	fp, r3
    1392:	4493      	add	fp, r2
			ptr=ensure(p,len+1); if (!ptr) return 0;
    1394:	465b      	mov	r3, fp
    1396:	1c59      	adds	r1, r3, #1
    1398:	0020      	movs	r0, r4
    139a:	4b7e      	ldr	r3, [pc, #504]	; (1594 <print_object+0x368>)
    139c:	4798      	blx	r3
    139e:	2800      	cmp	r0, #0
    13a0:	d100      	bne.n	13a4 <print_object+0x178>
    13a2:	e148      	b.n	1636 <print_object+0x40a>
			if (child->next) *ptr++=',';
    13a4:	6833      	ldr	r3, [r6, #0]
    13a6:	2b00      	cmp	r3, #0
    13a8:	d003      	beq.n	13b2 <print_object+0x186>
    13aa:	1c43      	adds	r3, r0, #1
    13ac:	222c      	movs	r2, #44	; 0x2c
    13ae:	7002      	strb	r2, [r0, #0]
    13b0:	e000      	b.n	13b4 <print_object+0x188>
			
			print_value(child,depth,fmt,p);
			p->offset=update(p);

			len=(fmt?1:0)+(child->next?1:0);
			ptr=ensure(p,len+1); if (!ptr) return 0;
    13b2:	0003      	movs	r3, r0
			if (child->next) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
    13b4:	2d00      	cmp	r5, #0
    13b6:	d002      	beq.n	13be <print_object+0x192>
    13b8:	220a      	movs	r2, #10
    13ba:	701a      	strb	r2, [r3, #0]
    13bc:	3301      	adds	r3, #1
    13be:	2200      	movs	r2, #0
    13c0:	701a      	strb	r2, [r3, #0]
			p->offset+=len;
    13c2:	68a3      	ldr	r3, [r4, #8]
    13c4:	445b      	add	r3, fp
    13c6:	60a3      	str	r3, [r4, #8]
			child=child->next;
    13c8:	6836      	ldr	r6, [r6, #0]
		/* Compose the output: */
		i=p->offset;
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
		*ptr++='{';	if (fmt) *ptr++='\n';	*ptr=0;	p->offset+=len;
		child=item->child;depth++;
		while (child)
    13ca:	2e00      	cmp	r6, #0
    13cc:	d1a2      	bne.n	1314 <print_object+0xe8>
			if (child->next) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
			p->offset+=len;
			child=child->next;
		}
		ptr=ensure(p,fmt?(depth+1):2);	 if (!ptr) return 0;
    13ce:	2d00      	cmp	r5, #0
    13d0:	d100      	bne.n	13d4 <print_object+0x1a8>
    13d2:	e15e      	b.n	1692 <print_object+0x466>
    13d4:	9e01      	ldr	r6, [sp, #4]
    13d6:	1cb1      	adds	r1, r6, #2
    13d8:	0020      	movs	r0, r4
    13da:	4b6e      	ldr	r3, [pc, #440]	; (1594 <print_object+0x368>)
    13dc:	4798      	blx	r3
    13de:	0005      	movs	r5, r0
    13e0:	2000      	movs	r0, #0
    13e2:	2d00      	cmp	r5, #0
    13e4:	d100      	bne.n	13e8 <print_object+0x1bc>
    13e6:	e1cc      	b.n	1782 <print_object+0x556>
		if (fmt)	for (i=0;i<depth-1;i++) *ptr++='\t';
    13e8:	2e00      	cmp	r6, #0
    13ea:	dd09      	ble.n	1400 <print_object+0x1d4>
    13ec:	002b      	movs	r3, r5
    13ee:	46b4      	mov	ip, r6
    13f0:	4465      	add	r5, ip
    13f2:	0029      	movs	r1, r5
    13f4:	2209      	movs	r2, #9
    13f6:	701a      	strb	r2, [r3, #0]
    13f8:	3301      	adds	r3, #1
    13fa:	4299      	cmp	r1, r3
    13fc:	d1fb      	bne.n	13f6 <print_object+0x1ca>
    13fe:	e001      	b.n	1404 <print_object+0x1d8>
    1400:	2300      	movs	r3, #0
    1402:	9301      	str	r3, [sp, #4]
		*ptr++='}';*ptr=0;
    1404:	237d      	movs	r3, #125	; 0x7d
    1406:	702b      	strb	r3, [r5, #0]
    1408:	2300      	movs	r3, #0
    140a:	706b      	strb	r3, [r5, #1]
		out=(p->buffer)+i;
    140c:	6820      	ldr	r0, [r4, #0]
    140e:	9b01      	ldr	r3, [sp, #4]
    1410:	469c      	mov	ip, r3
    1412:	4460      	add	r0, ip
    1414:	e1b5      	b.n	1782 <print_object+0x556>
	}
	else
	{
		/* Allocate space for the names and the objects */
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
    1416:	00ac      	lsls	r4, r5, #2
    1418:	4b5f      	ldr	r3, [pc, #380]	; (1598 <print_object+0x36c>)
    141a:	681b      	ldr	r3, [r3, #0]
    141c:	0020      	movs	r0, r4
    141e:	4798      	blx	r3
    1420:	9004      	str	r0, [sp, #16]
		if (!entries) return 0;
    1422:	2800      	cmp	r0, #0
    1424:	d100      	bne.n	1428 <print_object+0x1fc>
    1426:	e108      	b.n	163a <print_object+0x40e>
		names=(char**)cJSON_malloc(numentries*sizeof(char*));
    1428:	4b5b      	ldr	r3, [pc, #364]	; (1598 <print_object+0x36c>)
    142a:	681b      	ldr	r3, [r3, #0]
    142c:	0020      	movs	r0, r4
    142e:	4798      	blx	r3
    1430:	9005      	str	r0, [sp, #20]
		if (!names) {cJSON_free(entries);return 0;}
    1432:	2800      	cmp	r0, #0
    1434:	d105      	bne.n	1442 <print_object+0x216>
    1436:	4b5c      	ldr	r3, [pc, #368]	; (15a8 <print_object+0x37c>)
    1438:	681b      	ldr	r3, [r3, #0]
    143a:	9804      	ldr	r0, [sp, #16]
    143c:	4798      	blx	r3
    143e:	2000      	movs	r0, #0
    1440:	e19f      	b.n	1782 <print_object+0x556>
		memset(entries,0,sizeof(char*)*numentries);
    1442:	0022      	movs	r2, r4
    1444:	2100      	movs	r1, #0
    1446:	9804      	ldr	r0, [sp, #16]
    1448:	4b58      	ldr	r3, [pc, #352]	; (15ac <print_object+0x380>)
    144a:	4698      	mov	r8, r3
    144c:	4798      	blx	r3
		memset(names,0,sizeof(char*)*numentries);
    144e:	0022      	movs	r2, r4
    1450:	2100      	movs	r1, #0
    1452:	9805      	ldr	r0, [sp, #20]
    1454:	47c0      	blx	r8

		/* Collect all the results into our arrays: */
		child=item->child;depth++;if (fmt) len+=depth;
    1456:	68b6      	ldr	r6, [r6, #8]
    1458:	9b01      	ldr	r3, [sp, #4]
    145a:	1c5a      	adds	r2, r3, #1
    145c:	9200      	str	r2, [sp, #0]

/* Render an object to text. */
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)
{
	char **entries=0,**names=0;
	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;
    145e:	2207      	movs	r2, #7
    1460:	0010      	movs	r0, r2
		if (!names) {cJSON_free(entries);return 0;}
		memset(entries,0,sizeof(char*)*numentries);
		memset(names,0,sizeof(char*)*numentries);

		/* Collect all the results into our arrays: */
		child=item->child;depth++;if (fmt) len+=depth;
    1462:	465a      	mov	r2, fp
    1464:	2a00      	cmp	r2, #0
    1466:	d001      	beq.n	146c <print_object+0x240>
    1468:	3308      	adds	r3, #8
    146a:	0018      	movs	r0, r3
		while (child)
    146c:	2e00      	cmp	r6, #0
    146e:	d100      	bne.n	1472 <print_object+0x246>
    1470:	e180      	b.n	1774 <print_object+0x548>
    1472:	2300      	movs	r3, #0
    1474:	465a      	mov	r2, fp
    1476:	2a00      	cmp	r2, #0
    1478:	d001      	beq.n	147e <print_object+0x252>
    147a:	9b01      	ldr	r3, [sp, #4]
    147c:	3303      	adds	r3, #3
    147e:	9306      	str	r3, [sp, #24]
    1480:	9b05      	ldr	r3, [sp, #20]
    1482:	469a      	mov	sl, r3
    1484:	9b04      	ldr	r3, [sp, #16]
    1486:	4699      	mov	r9, r3
		{
			names[i]=str=print_string_ptr(child->string,0);
			entries[i++]=ret=print_value(child,depth,fmt,0);
			if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
    1488:	2300      	movs	r3, #0
    148a:	9307      	str	r3, [sp, #28]
		/* Collect all the results into our arrays: */
		child=item->child;depth++;if (fmt) len+=depth;
		while (child)
		{
			names[i]=str=print_string_ptr(child->string,0);
			entries[i++]=ret=print_value(child,depth,fmt,0);
    148c:	4b45      	ldr	r3, [pc, #276]	; (15a4 <print_object+0x378>)
    148e:	4698      	mov	r8, r3
			if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
    1490:	464b      	mov	r3, r9
    1492:	46a9      	mov	r9, r5
    1494:	4652      	mov	r2, sl
    1496:	46ba      	mov	sl, r7
    1498:	4659      	mov	r1, fp
    149a:	9103      	str	r1, [sp, #12]
    149c:	4683      	mov	fp, r0
    149e:	0017      	movs	r7, r2
    14a0:	001d      	movs	r5, r3

		/* Collect all the results into our arrays: */
		child=item->child;depth++;if (fmt) len+=depth;
		while (child)
		{
			names[i]=str=print_string_ptr(child->string,0);
    14a2:	2100      	movs	r1, #0
    14a4:	6a30      	ldr	r0, [r6, #32]
    14a6:	4b3e      	ldr	r3, [pc, #248]	; (15a0 <print_object+0x374>)
    14a8:	4798      	blx	r3
    14aa:	0004      	movs	r4, r0
    14ac:	6038      	str	r0, [r7, #0]
			entries[i++]=ret=print_value(child,depth,fmt,0);
    14ae:	2300      	movs	r3, #0
    14b0:	9a03      	ldr	r2, [sp, #12]
    14b2:	9900      	ldr	r1, [sp, #0]
    14b4:	0030      	movs	r0, r6
    14b6:	47c0      	blx	r8
    14b8:	6028      	str	r0, [r5, #0]
			if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
    14ba:	2c00      	cmp	r4, #0
    14bc:	d010      	beq.n	14e0 <print_object+0x2b4>
    14be:	2800      	cmp	r0, #0
    14c0:	d011      	beq.n	14e6 <print_object+0x2ba>
    14c2:	4b3b      	ldr	r3, [pc, #236]	; (15b0 <print_object+0x384>)
    14c4:	4798      	blx	r3
    14c6:	9002      	str	r0, [sp, #8]
    14c8:	0020      	movs	r0, r4
    14ca:	4b39      	ldr	r3, [pc, #228]	; (15b0 <print_object+0x384>)
    14cc:	4798      	blx	r3
    14ce:	9b06      	ldr	r3, [sp, #24]
    14d0:	3302      	adds	r3, #2
    14d2:	445b      	add	r3, fp
    14d4:	9a02      	ldr	r2, [sp, #8]
    14d6:	4694      	mov	ip, r2
    14d8:	4463      	add	r3, ip
    14da:	469b      	mov	fp, r3
    14dc:	4483      	add	fp, r0
    14de:	e004      	b.n	14ea <print_object+0x2be>
    14e0:	2301      	movs	r3, #1
    14e2:	9307      	str	r3, [sp, #28]
    14e4:	e001      	b.n	14ea <print_object+0x2be>
    14e6:	2301      	movs	r3, #1
    14e8:	9307      	str	r3, [sp, #28]
			child=child->next;
    14ea:	6836      	ldr	r6, [r6, #0]
    14ec:	3704      	adds	r7, #4
    14ee:	3504      	adds	r5, #4
		memset(entries,0,sizeof(char*)*numentries);
		memset(names,0,sizeof(char*)*numentries);

		/* Collect all the results into our arrays: */
		child=item->child;depth++;if (fmt) len+=depth;
		while (child)
    14f0:	2e00      	cmp	r6, #0
    14f2:	d1d6      	bne.n	14a2 <print_object+0x276>
    14f4:	4658      	mov	r0, fp
    14f6:	464d      	mov	r5, r9
    14f8:	4657      	mov	r7, sl
    14fa:	9b03      	ldr	r3, [sp, #12]
    14fc:	469b      	mov	fp, r3
			if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
			child=child->next;
		}
		
		/* Try to allocate the output string */
		if (!fail)	out=(char*)cJSON_malloc(len);
    14fe:	9b07      	ldr	r3, [sp, #28]
    1500:	2b00      	cmp	r3, #0
    1502:	d100      	bne.n	1506 <print_object+0x2da>
    1504:	e136      	b.n	1774 <print_object+0x548>
		if (!out) fail=1;

		/* Handle failure */
		if (fail)
		{
			for (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}
    1506:	2d00      	cmp	r5, #0
    1508:	dd15      	ble.n	1536 <print_object+0x30a>
    150a:	2400      	movs	r4, #0
    150c:	2600      	movs	r6, #0
    150e:	4b26      	ldr	r3, [pc, #152]	; (15a8 <print_object+0x37c>)
    1510:	4698      	mov	r8, r3
    1512:	001f      	movs	r7, r3
    1514:	9b05      	ldr	r3, [sp, #20]
    1516:	5918      	ldr	r0, [r3, r4]
    1518:	2800      	cmp	r0, #0
    151a:	d002      	beq.n	1522 <print_object+0x2f6>
    151c:	4643      	mov	r3, r8
    151e:	681b      	ldr	r3, [r3, #0]
    1520:	4798      	blx	r3
    1522:	9b04      	ldr	r3, [sp, #16]
    1524:	5918      	ldr	r0, [r3, r4]
    1526:	2800      	cmp	r0, #0
    1528:	d001      	beq.n	152e <print_object+0x302>
    152a:	683b      	ldr	r3, [r7, #0]
    152c:	4798      	blx	r3
    152e:	3601      	adds	r6, #1
    1530:	3404      	adds	r4, #4
    1532:	42b5      	cmp	r5, r6
    1534:	d1ee      	bne.n	1514 <print_object+0x2e8>
			cJSON_free(names);cJSON_free(entries);
    1536:	4c1c      	ldr	r4, [pc, #112]	; (15a8 <print_object+0x37c>)
    1538:	9805      	ldr	r0, [sp, #20]
    153a:	6823      	ldr	r3, [r4, #0]
    153c:	4798      	blx	r3
    153e:	6823      	ldr	r3, [r4, #0]
    1540:	9804      	ldr	r0, [sp, #16]
    1542:	4798      	blx	r3
			return 0;
    1544:	2000      	movs	r0, #0
    1546:	e11c      	b.n	1782 <print_object+0x556>
		}
		
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
    1548:	9a06      	ldr	r2, [sp, #24]
    154a:	1c96      	adds	r6, r2, #2
    154c:	230a      	movs	r3, #10
    154e:	7053      	strb	r3, [r2, #1]
    1550:	2300      	movs	r3, #0
    1552:	7093      	strb	r3, [r2, #2]
		for (i=0;i<numentries;i++)
    1554:	2d00      	cmp	r5, #0
    1556:	dc00      	bgt.n	155a <print_object+0x32e>
    1558:	e0a4      	b.n	16a4 <print_object+0x478>
    155a:	9b05      	ldr	r3, [sp, #20]
    155c:	4699      	mov	r9, r3
    155e:	9b04      	ldr	r3, [sp, #16]
    1560:	4698      	mov	r8, r3
		if (!out) fail=1;

		/* Handle failure */
		if (fail)
		{
			for (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}
    1562:	2300      	movs	r3, #0
    1564:	469a      	mov	sl, r3
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
			*ptr++=':';if (fmt) *ptr++='\t';
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
    1566:	4644      	mov	r4, r8
    1568:	9502      	str	r5, [sp, #8]
    156a:	9703      	str	r7, [sp, #12]
		
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
    156c:	465b      	mov	r3, fp
    156e:	2b00      	cmp	r3, #0
    1570:	d100      	bne.n	1574 <print_object+0x348>
    1572:	e0d0      	b.n	1716 <print_object+0x4ea>
    1574:	9b00      	ldr	r3, [sp, #0]
    1576:	2b00      	cmp	r3, #0
    1578:	dc00      	bgt.n	157c <print_object+0x350>
    157a:	e0ab      	b.n	16d4 <print_object+0x4a8>
    157c:	0033      	movs	r3, r6
    157e:	9a01      	ldr	r2, [sp, #4]
    1580:	3201      	adds	r2, #1
    1582:	18b6      	adds	r6, r6, r2
    1584:	0031      	movs	r1, r6
    1586:	2209      	movs	r2, #9
    1588:	701a      	strb	r2, [r3, #0]
    158a:	3301      	adds	r3, #1
    158c:	4299      	cmp	r1, r3
    158e:	d1fb      	bne.n	1588 <print_object+0x35c>
    1590:	e0a0      	b.n	16d4 <print_object+0x4a8>
    1592:	46c0      	nop			; (mov r8, r8)
    1594:	00000cb9 	.word	0x00000cb9
    1598:	20000004 	.word	0x20000004
    159c:	00000d61 	.word	0x00000d61
    15a0:	00000f5d 	.word	0x00000f5d
    15a4:	00001125 	.word	0x00001125
    15a8:	20000000 	.word	0x20000000
    15ac:	00011845 	.word	0x00011845
    15b0:	00011d75 	.word	0x00011d75
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
			*ptr++=':';if (fmt) *ptr++='\t';
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
			if (i!=numentries-1) *ptr++=',';
    15b4:	1c6e      	adds	r6, r5, #1
    15b6:	232c      	movs	r3, #44	; 0x2c
    15b8:	702b      	strb	r3, [r5, #0]
			if (fmt) *ptr++='\n';*ptr=0;
    15ba:	465b      	mov	r3, fp
    15bc:	2b00      	cmp	r3, #0
    15be:	d002      	beq.n	15c6 <print_object+0x39a>
    15c0:	230a      	movs	r3, #10
    15c2:	7033      	strb	r3, [r6, #0]
    15c4:	3601      	adds	r6, #1
    15c6:	2300      	movs	r3, #0
    15c8:	7033      	strb	r3, [r6, #0]
			cJSON_free(names[i]);cJSON_free(entries[i]);
    15ca:	4643      	mov	r3, r8
    15cc:	6818      	ldr	r0, [r3, #0]
    15ce:	4d70      	ldr	r5, [pc, #448]	; (1790 <print_object+0x564>)
    15d0:	682b      	ldr	r3, [r5, #0]
    15d2:	4798      	blx	r3
    15d4:	6838      	ldr	r0, [r7, #0]
    15d6:	682b      	ldr	r3, [r5, #0]
    15d8:	4798      	blx	r3
			return 0;
		}
		
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
		for (i=0;i<numentries;i++)
    15da:	2301      	movs	r3, #1
    15dc:	469c      	mov	ip, r3
    15de:	44e2      	add	sl, ip
    15e0:	3303      	adds	r3, #3
    15e2:	469c      	mov	ip, r3
    15e4:	44e1      	add	r9, ip
    15e6:	3404      	adds	r4, #4
    15e8:	9b02      	ldr	r3, [sp, #8]
    15ea:	4553      	cmp	r3, sl
    15ec:	dcbe      	bgt.n	156c <print_object+0x340>
			if (i!=numentries-1) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
			cJSON_free(names[i]);cJSON_free(entries[i]);
		}
		
		cJSON_free(names);cJSON_free(entries);
    15ee:	4c68      	ldr	r4, [pc, #416]	; (1790 <print_object+0x564>)
    15f0:	9805      	ldr	r0, [sp, #20]
    15f2:	6823      	ldr	r3, [r4, #0]
    15f4:	4798      	blx	r3
    15f6:	6823      	ldr	r3, [r4, #0]
    15f8:	9804      	ldr	r0, [sp, #16]
    15fa:	4798      	blx	r3
		if (fmt) for (i=0;i<depth-1;i++) *ptr++='\t';
    15fc:	465b      	mov	r3, fp
    15fe:	2b00      	cmp	r3, #0
    1600:	d00b      	beq.n	161a <print_object+0x3ee>
    1602:	9a01      	ldr	r2, [sp, #4]
    1604:	2a00      	cmp	r2, #0
    1606:	dd08      	ble.n	161a <print_object+0x3ee>
    1608:	0033      	movs	r3, r6
    160a:	4694      	mov	ip, r2
    160c:	4466      	add	r6, ip
    160e:	0031      	movs	r1, r6
    1610:	2209      	movs	r2, #9
    1612:	701a      	strb	r2, [r3, #0]
    1614:	3301      	adds	r3, #1
    1616:	428b      	cmp	r3, r1
    1618:	d1fb      	bne.n	1612 <print_object+0x3e6>
		*ptr++='}';*ptr++=0;
    161a:	237d      	movs	r3, #125	; 0x7d
    161c:	7033      	strb	r3, [r6, #0]
    161e:	2300      	movs	r3, #0
    1620:	7073      	strb	r3, [r6, #1]
			if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
			child=child->next;
		}
		
		/* Try to allocate the output string */
		if (!fail)	out=(char*)cJSON_malloc(len);
    1622:	9806      	ldr	r0, [sp, #24]
    1624:	e0ad      	b.n	1782 <print_object+0x556>
	/* Explicitly handle empty object case */
	if (!numentries)
	{
		if (p) out=ensure(p,fmt?depth+4:3);
		else	out=(char*)cJSON_malloc(fmt?depth+4:3);
		if (!out)	return 0;
    1626:	2000      	movs	r0, #0
    1628:	e0ab      	b.n	1782 <print_object+0x556>
	}
	if (p)
	{
		/* Compose the output: */
		i=p->offset;
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
    162a:	2000      	movs	r0, #0
    162c:	e0a9      	b.n	1782 <print_object+0x556>
		child=item->child;depth++;
		while (child)
		{
			if (fmt)
			{
				ptr=ensure(p,depth);	if (!ptr) return 0;
    162e:	2000      	movs	r0, #0
    1630:	e0a7      	b.n	1782 <print_object+0x556>
			}
			print_string_ptr(child->string,p);
			p->offset=update(p);
			
			len=fmt?2:1;
			ptr=ensure(p,len);	if (!ptr) return 0;
    1632:	2000      	movs	r0, #0
    1634:	e0a5      	b.n	1782 <print_object+0x556>
			
			print_value(child,depth,fmt,p);
			p->offset=update(p);

			len=(fmt?1:0)+(child->next?1:0);
			ptr=ensure(p,len+1); if (!ptr) return 0;
    1636:	2000      	movs	r0, #0
    1638:	e0a3      	b.n	1782 <print_object+0x556>
	}
	else
	{
		/* Allocate space for the names and the objects */
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!entries) return 0;
    163a:	2000      	movs	r0, #0
    163c:	e0a1      	b.n	1782 <print_object+0x556>
	}
	if (p)
	{
		/* Compose the output: */
		i=p->offset;
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
    163e:	2000      	movs	r0, #0
    1640:	e09f      	b.n	1782 <print_object+0x556>
			}
			print_string_ptr(child->string,p);
			p->offset=update(p);
			
			len=fmt?2:1;
			ptr=ensure(p,len);	if (!ptr) return 0;
    1642:	2000      	movs	r0, #0
    1644:	e09d      	b.n	1782 <print_object+0x556>
			if (child->next) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
			p->offset+=len;
			child=child->next;
		}
		ptr=ensure(p,fmt?(depth+1):2);	 if (!ptr) return 0;
    1646:	2000      	movs	r0, #0
    1648:	e09b      	b.n	1782 <print_object+0x556>
	if (p)
	{
		/* Compose the output: */
		i=p->offset;
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
		*ptr++='{';	if (fmt) *ptr++='\n';	*ptr=0;	p->offset+=len;
    164a:	237b      	movs	r3, #123	; 0x7b
    164c:	7003      	strb	r3, [r0, #0]
    164e:	3b71      	subs	r3, #113	; 0x71
    1650:	7043      	strb	r3, [r0, #1]
    1652:	2300      	movs	r3, #0
    1654:	7083      	strb	r3, [r0, #2]
    1656:	68a3      	ldr	r3, [r4, #8]
    1658:	3302      	adds	r3, #2
    165a:	60a3      	str	r3, [r4, #8]
		child=item->child;depth++;
    165c:	68b6      	ldr	r6, [r6, #8]
    165e:	9b01      	ldr	r3, [sp, #4]
    1660:	1c5f      	adds	r7, r3, #1
		while (child)
    1662:	2e00      	cmp	r6, #0
    1664:	d000      	beq.n	1668 <print_object+0x43c>
    1666:	e649      	b.n	12fc <print_object+0xd0>
    1668:	e6b4      	b.n	13d4 <print_object+0x1a8>
	}
	if (p)
	{
		/* Compose the output: */
		i=p->offset;
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
    166a:	2103      	movs	r1, #3
    166c:	0020      	movs	r0, r4
    166e:	4b49      	ldr	r3, [pc, #292]	; (1794 <print_object+0x568>)
    1670:	4798      	blx	r3
    1672:	2800      	cmp	r0, #0
    1674:	d1e9      	bne.n	164a <print_object+0x41e>
    1676:	e7e2      	b.n	163e <print_object+0x412>
			{
				ptr=ensure(p,depth);	if (!ptr) return 0;
				for (j=0;j<depth;j++) *ptr++='\t';
				p->offset+=depth;
			}
			print_string_ptr(child->string,p);
    1678:	0021      	movs	r1, r4
    167a:	6a30      	ldr	r0, [r6, #32]
    167c:	4b46      	ldr	r3, [pc, #280]	; (1798 <print_object+0x56c>)
    167e:	4798      	blx	r3
			p->offset=update(p);
    1680:	0020      	movs	r0, r4
    1682:	47d0      	blx	sl
    1684:	60a0      	str	r0, [r4, #8]
			
			len=fmt?2:1;
			ptr=ensure(p,len);	if (!ptr) return 0;
    1686:	4641      	mov	r1, r8
    1688:	0020      	movs	r0, r4
    168a:	47c8      	blx	r9
    168c:	2800      	cmp	r0, #0
    168e:	d166      	bne.n	175e <print_object+0x532>
    1690:	e7d7      	b.n	1642 <print_object+0x416>
			if (child->next) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
			p->offset+=len;
			child=child->next;
		}
		ptr=ensure(p,fmt?(depth+1):2);	 if (!ptr) return 0;
    1692:	2102      	movs	r1, #2
    1694:	0020      	movs	r0, r4
    1696:	4b3f      	ldr	r3, [pc, #252]	; (1794 <print_object+0x568>)
    1698:	4798      	blx	r3
    169a:	1e05      	subs	r5, r0, #0
    169c:	d0d3      	beq.n	1646 <print_object+0x41a>
		return out;
	}
	if (p)
	{
		/* Compose the output: */
		i=p->offset;
    169e:	9b02      	ldr	r3, [sp, #8]
    16a0:	9301      	str	r3, [sp, #4]
    16a2:	e6af      	b.n	1404 <print_object+0x1d8>
			if (i!=numentries-1) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
			cJSON_free(names[i]);cJSON_free(entries[i]);
		}
		
		cJSON_free(names);cJSON_free(entries);
    16a4:	4c3a      	ldr	r4, [pc, #232]	; (1790 <print_object+0x564>)
    16a6:	9805      	ldr	r0, [sp, #20]
    16a8:	6823      	ldr	r3, [r4, #0]
    16aa:	4798      	blx	r3
    16ac:	6823      	ldr	r3, [r4, #0]
    16ae:	9804      	ldr	r0, [sp, #16]
    16b0:	4798      	blx	r3
    16b2:	e7a6      	b.n	1602 <print_object+0x3d6>
    16b4:	4c36      	ldr	r4, [pc, #216]	; (1790 <print_object+0x564>)
    16b6:	9805      	ldr	r0, [sp, #20]
    16b8:	6823      	ldr	r3, [r4, #0]
    16ba:	4798      	blx	r3
    16bc:	6823      	ldr	r3, [r4, #0]
    16be:	9804      	ldr	r0, [sp, #16]
    16c0:	4798      	blx	r3
    16c2:	e7aa      	b.n	161a <print_object+0x3ee>
			cJSON_free(names);cJSON_free(entries);
			return 0;
		}
		
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
    16c4:	9a06      	ldr	r2, [sp, #24]
    16c6:	1c56      	adds	r6, r2, #1
    16c8:	2300      	movs	r3, #0
    16ca:	7053      	strb	r3, [r2, #1]
		for (i=0;i<numentries;i++)
    16cc:	2d00      	cmp	r5, #0
    16ce:	dd00      	ble.n	16d2 <print_object+0x4a6>
    16d0:	e743      	b.n	155a <print_object+0x32e>
    16d2:	e7ef      	b.n	16b4 <print_object+0x488>
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
    16d4:	46c8      	mov	r8, r9
    16d6:	464b      	mov	r3, r9
    16d8:	681f      	ldr	r7, [r3, #0]
    16da:	0038      	movs	r0, r7
    16dc:	4b2f      	ldr	r3, [pc, #188]	; (179c <print_object+0x570>)
    16de:	4798      	blx	r3
    16e0:	0005      	movs	r5, r0
    16e2:	0002      	movs	r2, r0
    16e4:	0039      	movs	r1, r7
    16e6:	0030      	movs	r0, r6
    16e8:	4b2d      	ldr	r3, [pc, #180]	; (17a0 <print_object+0x574>)
    16ea:	4798      	blx	r3
    16ec:	1976      	adds	r6, r6, r5
			*ptr++=':';if (fmt) *ptr++='\t';
    16ee:	233a      	movs	r3, #58	; 0x3a
    16f0:	7033      	strb	r3, [r6, #0]
    16f2:	1cb5      	adds	r5, r6, #2
    16f4:	3b31      	subs	r3, #49	; 0x31
    16f6:	7073      	strb	r3, [r6, #1]
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
    16f8:	0027      	movs	r7, r4
    16fa:	6821      	ldr	r1, [r4, #0]
    16fc:	0028      	movs	r0, r5
    16fe:	4b29      	ldr	r3, [pc, #164]	; (17a4 <print_object+0x578>)
    1700:	4798      	blx	r3
    1702:	6820      	ldr	r0, [r4, #0]
    1704:	4b25      	ldr	r3, [pc, #148]	; (179c <print_object+0x570>)
    1706:	4798      	blx	r3
    1708:	182d      	adds	r5, r5, r0
			if (i!=numentries-1) *ptr++=',';
    170a:	9b03      	ldr	r3, [sp, #12]
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
			*ptr++=':';if (fmt) *ptr++='\t';
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
    170c:	002e      	movs	r6, r5
			if (i!=numentries-1) *ptr++=',';
    170e:	459a      	cmp	sl, r3
    1710:	d100      	bne.n	1714 <print_object+0x4e8>
    1712:	e755      	b.n	15c0 <print_object+0x394>
    1714:	e74e      	b.n	15b4 <print_object+0x388>
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
    1716:	46c8      	mov	r8, r9
    1718:	464b      	mov	r3, r9
    171a:	681d      	ldr	r5, [r3, #0]
    171c:	0028      	movs	r0, r5
    171e:	4b1f      	ldr	r3, [pc, #124]	; (179c <print_object+0x570>)
    1720:	4798      	blx	r3
    1722:	0007      	movs	r7, r0
    1724:	0002      	movs	r2, r0
    1726:	0029      	movs	r1, r5
    1728:	0030      	movs	r0, r6
    172a:	4b1d      	ldr	r3, [pc, #116]	; (17a0 <print_object+0x574>)
    172c:	4798      	blx	r3
			*ptr++=':';if (fmt) *ptr++='\t';
    172e:	1c7d      	adds	r5, r7, #1
    1730:	1975      	adds	r5, r6, r5
    1732:	233a      	movs	r3, #58	; 0x3a
    1734:	55f3      	strb	r3, [r6, r7]
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
    1736:	0027      	movs	r7, r4
    1738:	6821      	ldr	r1, [r4, #0]
    173a:	0028      	movs	r0, r5
    173c:	4b19      	ldr	r3, [pc, #100]	; (17a4 <print_object+0x578>)
    173e:	4798      	blx	r3
    1740:	6820      	ldr	r0, [r4, #0]
    1742:	4b16      	ldr	r3, [pc, #88]	; (179c <print_object+0x570>)
    1744:	4798      	blx	r3
    1746:	182d      	adds	r5, r5, r0
			if (i!=numentries-1) *ptr++=',';
    1748:	9b03      	ldr	r3, [sp, #12]
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
			*ptr++=':';if (fmt) *ptr++='\t';
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
    174a:	002e      	movs	r6, r5
			if (i!=numentries-1) *ptr++=',';
    174c:	459a      	cmp	sl, r3
    174e:	d100      	bne.n	1752 <print_object+0x526>
    1750:	e739      	b.n	15c6 <print_object+0x39a>
    1752:	e72f      	b.n	15b4 <print_object+0x388>
			print_string_ptr(child->string,p);
			p->offset=update(p);
			
			len=fmt?2:1;
			ptr=ensure(p,len);	if (!ptr) return 0;
			*ptr++=':';if (fmt) *ptr++='\t';
    1754:	233a      	movs	r3, #58	; 0x3a
    1756:	7003      	strb	r3, [r0, #0]
    1758:	3b31      	subs	r3, #49	; 0x31
    175a:	7043      	strb	r3, [r0, #1]
    175c:	e605      	b.n	136a <print_object+0x13e>
    175e:	233a      	movs	r3, #58	; 0x3a
    1760:	7003      	strb	r3, [r0, #0]
    1762:	e602      	b.n	136a <print_object+0x13e>
			cJSON_free(names);cJSON_free(entries);
			return 0;
		}
		
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
    1764:	237b      	movs	r3, #123	; 0x7b
    1766:	9a06      	ldr	r2, [sp, #24]
    1768:	7013      	strb	r3, [r2, #0]
    176a:	465b      	mov	r3, fp
    176c:	2b00      	cmp	r3, #0
    176e:	d000      	beq.n	1772 <print_object+0x546>
    1770:	e6ea      	b.n	1548 <print_object+0x31c>
    1772:	e7a7      	b.n	16c4 <print_object+0x498>
			if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
			child=child->next;
		}
		
		/* Try to allocate the output string */
		if (!fail)	out=(char*)cJSON_malloc(len);
    1774:	4b0c      	ldr	r3, [pc, #48]	; (17a8 <print_object+0x57c>)
    1776:	681b      	ldr	r3, [r3, #0]
    1778:	4798      	blx	r3
    177a:	9006      	str	r0, [sp, #24]
		if (!out) fail=1;
    177c:	2800      	cmp	r0, #0
    177e:	d1f1      	bne.n	1764 <print_object+0x538>
    1780:	e6c1      	b.n	1506 <print_object+0x2da>
		cJSON_free(names);cJSON_free(entries);
		if (fmt) for (i=0;i<depth-1;i++) *ptr++='\t';
		*ptr++='}';*ptr++=0;
	}
	return out;	
}
    1782:	b009      	add	sp, #36	; 0x24
    1784:	bc3c      	pop	{r2, r3, r4, r5}
    1786:	4690      	mov	r8, r2
    1788:	4699      	mov	r9, r3
    178a:	46a2      	mov	sl, r4
    178c:	46ab      	mov	fp, r5
    178e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1790:	20000000 	.word	0x20000000
    1794:	00000cb9 	.word	0x00000cb9
    1798:	00000f5d 	.word	0x00000f5d
    179c:	00011d75 	.word	0x00011d75
    17a0:	00011833 	.word	0x00011833
    17a4:	00011d65 	.word	0x00011d65
    17a8:	20000004 	.word	0x20000004

000017ac <print_array>:
	ep=value;return 0;	/* malformed. */
}

/* Render an array to text */
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)
{
    17ac:	b5f0      	push	{r4, r5, r6, r7, lr}
    17ae:	465f      	mov	r7, fp
    17b0:	4656      	mov	r6, sl
    17b2:	464d      	mov	r5, r9
    17b4:	4644      	mov	r4, r8
    17b6:	b4f0      	push	{r4, r5, r6, r7}
    17b8:	b085      	sub	sp, #20
    17ba:	0007      	movs	r7, r0
    17bc:	468a      	mov	sl, r1
    17be:	9200      	str	r2, [sp, #0]
    17c0:	001e      	movs	r6, r3
	char **entries;
	char *out=0,*ptr,*ret;int len=5;
	cJSON *child=item->child;
    17c2:	6883      	ldr	r3, [r0, #8]
	int numentries=0,i=0,fail=0;
	size_t tmplen=0;
	
	/* How many entries in the array? */
	while (child) numentries++,child=child->next;
    17c4:	2b00      	cmp	r3, #0
    17c6:	d008      	beq.n	17da <print_array+0x2e>
    17c8:	2500      	movs	r5, #0
    17ca:	e000      	b.n	17ce <print_array+0x22>
    17cc:	0025      	movs	r5, r4
    17ce:	1c6c      	adds	r4, r5, #1
    17d0:	681b      	ldr	r3, [r3, #0]
    17d2:	2b00      	cmp	r3, #0
    17d4:	d1fa      	bne.n	17cc <print_array+0x20>
	/* Explicitly handle numentries==0 */
	if (!numentries)
    17d6:	2c00      	cmp	r4, #0
    17d8:	d116      	bne.n	1808 <print_array+0x5c>
	{
		if (p)	out=ensure(p,3);
    17da:	2e00      	cmp	r6, #0
    17dc:	d005      	beq.n	17ea <print_array+0x3e>
    17de:	2103      	movs	r1, #3
    17e0:	0030      	movs	r0, r6
    17e2:	4b91      	ldr	r3, [pc, #580]	; (1a28 <print_array+0x27c>)
    17e4:	4798      	blx	r3
    17e6:	0004      	movs	r4, r0
    17e8:	e004      	b.n	17f4 <print_array+0x48>
		else	out=(char*)cJSON_malloc(3);
    17ea:	4b90      	ldr	r3, [pc, #576]	; (1a2c <print_array+0x280>)
    17ec:	681b      	ldr	r3, [r3, #0]
    17ee:	2003      	movs	r0, #3
    17f0:	4798      	blx	r3
    17f2:	0004      	movs	r4, r0
		if (out) strcpy(out,"[]");
    17f4:	2c00      	cmp	r4, #0
    17f6:	d100      	bne.n	17fa <print_array+0x4e>
    17f8:	e0e0      	b.n	19bc <print_array+0x210>
    17fa:	2203      	movs	r2, #3
    17fc:	498c      	ldr	r1, [pc, #560]	; (1a30 <print_array+0x284>)
    17fe:	0020      	movs	r0, r4
    1800:	4b8c      	ldr	r3, [pc, #560]	; (1a34 <print_array+0x288>)
    1802:	4798      	blx	r3
		return out;
    1804:	0020      	movs	r0, r4
    1806:	e108      	b.n	1a1a <print_array+0x26e>
	}

	if (p)
    1808:	2e00      	cmp	r6, #0
    180a:	d03d      	beq.n	1888 <print_array+0xdc>
	{
		/* Compose the output array. */
		i=p->offset;
    180c:	68b3      	ldr	r3, [r6, #8]
    180e:	4699      	mov	r9, r3
		ptr=ensure(p,1);if (!ptr) return 0;	*ptr='[';	p->offset++;
    1810:	2101      	movs	r1, #1
    1812:	0030      	movs	r0, r6
    1814:	4b84      	ldr	r3, [pc, #528]	; (1a28 <print_array+0x27c>)
    1816:	4798      	blx	r3
    1818:	2800      	cmp	r0, #0
    181a:	d100      	bne.n	181e <print_array+0x72>
    181c:	e0d0      	b.n	19c0 <print_array+0x214>
    181e:	235b      	movs	r3, #91	; 0x5b
    1820:	7003      	strb	r3, [r0, #0]
    1822:	68b3      	ldr	r3, [r6, #8]
    1824:	3301      	adds	r3, #1
    1826:	60b3      	str	r3, [r6, #8]
		child=item->child;
    1828:	68bc      	ldr	r4, [r7, #8]
		while (child && !fail)
    182a:	2c00      	cmp	r4, #0
    182c:	d01e      	beq.n	186c <print_array+0xc0>
		{
			print_value(child,depth+1,fmt,p);
    182e:	4f82      	ldr	r7, [pc, #520]	; (1a38 <print_array+0x28c>)
			p->offset=update(p);
    1830:	4d82      	ldr	r5, [pc, #520]	; (1a3c <print_array+0x290>)
			if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}
    1832:	4b7d      	ldr	r3, [pc, #500]	; (1a28 <print_array+0x27c>)
    1834:	469b      	mov	fp, r3
		i=p->offset;
		ptr=ensure(p,1);if (!ptr) return 0;	*ptr='[';	p->offset++;
		child=item->child;
		while (child && !fail)
		{
			print_value(child,depth+1,fmt,p);
    1836:	4653      	mov	r3, sl
    1838:	1c59      	adds	r1, r3, #1
    183a:	0033      	movs	r3, r6
    183c:	9a00      	ldr	r2, [sp, #0]
    183e:	4690      	mov	r8, r2
    1840:	0020      	movs	r0, r4
    1842:	47b8      	blx	r7
			p->offset=update(p);
    1844:	0030      	movs	r0, r6
    1846:	47a8      	blx	r5
    1848:	60b0      	str	r0, [r6, #8]
			if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}
    184a:	6823      	ldr	r3, [r4, #0]
    184c:	2b00      	cmp	r3, #0
    184e:	d00d      	beq.n	186c <print_array+0xc0>
    1850:	4643      	mov	r3, r8
    1852:	2b00      	cmp	r3, #0
    1854:	d000      	beq.n	1858 <print_array+0xac>
    1856:	e0c4      	b.n	19e2 <print_array+0x236>
    1858:	e0cf      	b.n	19fa <print_array+0x24e>
    185a:	2200      	movs	r2, #0
    185c:	700a      	strb	r2, [r1, #0]
    185e:	68b2      	ldr	r2, [r6, #8]
    1860:	4694      	mov	ip, r2
    1862:	4463      	add	r3, ip
    1864:	60b3      	str	r3, [r6, #8]
			child=child->next;
    1866:	6824      	ldr	r4, [r4, #0]
	{
		/* Compose the output array. */
		i=p->offset;
		ptr=ensure(p,1);if (!ptr) return 0;	*ptr='[';	p->offset++;
		child=item->child;
		while (child && !fail)
    1868:	2c00      	cmp	r4, #0
    186a:	d1e4      	bne.n	1836 <print_array+0x8a>
			print_value(child,depth+1,fmt,p);
			p->offset=update(p);
			if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}
			child=child->next;
		}
		ptr=ensure(p,2);if (!ptr) return 0;	*ptr++=']';*ptr=0;
    186c:	2102      	movs	r1, #2
    186e:	0030      	movs	r0, r6
    1870:	4b6d      	ldr	r3, [pc, #436]	; (1a28 <print_array+0x27c>)
    1872:	4798      	blx	r3
    1874:	2800      	cmp	r0, #0
    1876:	d100      	bne.n	187a <print_array+0xce>
    1878:	e0a4      	b.n	19c4 <print_array+0x218>
    187a:	235d      	movs	r3, #93	; 0x5d
    187c:	7003      	strb	r3, [r0, #0]
    187e:	2300      	movs	r3, #0
    1880:	7043      	strb	r3, [r0, #1]
		out=(p->buffer)+i;
    1882:	6830      	ldr	r0, [r6, #0]
    1884:	4448      	add	r0, r9
    1886:	e0c8      	b.n	1a1a <print_array+0x26e>
	}
	else
	{
		/* Allocate an array to hold the values for each */
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
    1888:	00a6      	lsls	r6, r4, #2
    188a:	4b68      	ldr	r3, [pc, #416]	; (1a2c <print_array+0x280>)
    188c:	681b      	ldr	r3, [r3, #0]
    188e:	0030      	movs	r0, r6
    1890:	4798      	blx	r3
    1892:	9002      	str	r0, [sp, #8]
		if (!entries) return 0;
    1894:	2800      	cmp	r0, #0
    1896:	d100      	bne.n	189a <print_array+0xee>
    1898:	e096      	b.n	19c8 <print_array+0x21c>
		memset(entries,0,numentries*sizeof(char*));
    189a:	0032      	movs	r2, r6
    189c:	2100      	movs	r1, #0
    189e:	0006      	movs	r6, r0
    18a0:	4b67      	ldr	r3, [pc, #412]	; (1a40 <print_array+0x294>)
    18a2:	4798      	blx	r3
		/* Retrieve all the results: */
		child=item->child;
    18a4:	68bf      	ldr	r7, [r7, #8]
		while (child && !fail)
    18a6:	2f00      	cmp	r7, #0
    18a8:	d025      	beq.n	18f6 <print_array+0x14a>
    18aa:	46b1      	mov	r9, r6
    18ac:	2605      	movs	r6, #5
		{
			ret=print_value(child,depth+1,fmt,0);
    18ae:	4653      	mov	r3, sl
    18b0:	3301      	adds	r3, #1
    18b2:	9301      	str	r3, [sp, #4]
    18b4:	4b60      	ldr	r3, [pc, #384]	; (1a38 <print_array+0x28c>)
    18b6:	469a      	mov	sl, r3
			entries[i++]=ret;
			if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
    18b8:	4b62      	ldr	r3, [pc, #392]	; (1a44 <print_array+0x298>)
    18ba:	469b      	mov	fp, r3
    18bc:	46a0      	mov	r8, r4
    18be:	464c      	mov	r4, r9
    18c0:	46a9      	mov	r9, r5
    18c2:	9d00      	ldr	r5, [sp, #0]
		memset(entries,0,numentries*sizeof(char*));
		/* Retrieve all the results: */
		child=item->child;
		while (child && !fail)
		{
			ret=print_value(child,depth+1,fmt,0);
    18c4:	2300      	movs	r3, #0
    18c6:	002a      	movs	r2, r5
    18c8:	9901      	ldr	r1, [sp, #4]
    18ca:	0038      	movs	r0, r7
    18cc:	47d0      	blx	sl
			entries[i++]=ret;
    18ce:	6020      	str	r0, [r4, #0]
			if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
    18d0:	2800      	cmp	r0, #0
    18d2:	d100      	bne.n	18d6 <print_array+0x12a>
    18d4:	e099      	b.n	1a0a <print_array+0x25e>
    18d6:	47d8      	blx	fp
    18d8:	002b      	movs	r3, r5
    18da:	1e5a      	subs	r2, r3, #1
    18dc:	4193      	sbcs	r3, r2
    18de:	3302      	adds	r3, #2
    18e0:	199e      	adds	r6, r3, r6
    18e2:	1836      	adds	r6, r6, r0
			child=child->next;
    18e4:	683f      	ldr	r7, [r7, #0]
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!entries) return 0;
		memset(entries,0,numentries*sizeof(char*));
		/* Retrieve all the results: */
		child=item->child;
		while (child && !fail)
    18e6:	2f00      	cmp	r7, #0
    18e8:	d000      	beq.n	18ec <print_array+0x140>
    18ea:	e08c      	b.n	1a06 <print_array+0x25a>
    18ec:	4644      	mov	r4, r8
    18ee:	464d      	mov	r5, r9
			if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
			child=child->next;
		}
		
		/* If we didn't fail, try to malloc the output string */
		if (!fail)	out=(char*)cJSON_malloc(len);
    18f0:	2f00      	cmp	r7, #0
    18f2:	d10b      	bne.n	190c <print_array+0x160>
    18f4:	e001      	b.n	18fa <print_array+0x14e>
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)
{
	char **entries;
	char *out=0,*ptr,*ret;int len=5;
	cJSON *child=item->child;
	int numentries=0,i=0,fail=0;
    18f6:	2700      	movs	r7, #0

/* Render an array to text */
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)
{
	char **entries;
	char *out=0,*ptr,*ret;int len=5;
    18f8:	2605      	movs	r6, #5
			if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
			child=child->next;
		}
		
		/* If we didn't fail, try to malloc the output string */
		if (!fail)	out=(char*)cJSON_malloc(len);
    18fa:	4b4c      	ldr	r3, [pc, #304]	; (1a2c <print_array+0x280>)
    18fc:	681b      	ldr	r3, [r3, #0]
    18fe:	0030      	movs	r0, r6
    1900:	4798      	blx	r3
    1902:	9003      	str	r0, [sp, #12]
		/* If that fails, we fail. */
		if (!out) fail=1;
    1904:	2800      	cmp	r0, #0
    1906:	d001      	beq.n	190c <print_array+0x160>

		/* Handle failure. */
		if (fail)
    1908:	2f00      	cmp	r7, #0
    190a:	d013      	beq.n	1934 <print_array+0x188>
		{
			for (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);
    190c:	2c00      	cmp	r4, #0
    190e:	dd0b      	ble.n	1928 <print_array+0x17c>
    1910:	9e02      	ldr	r6, [sp, #8]
    1912:	2500      	movs	r5, #0
    1914:	4f4c      	ldr	r7, [pc, #304]	; (1a48 <print_array+0x29c>)
    1916:	6830      	ldr	r0, [r6, #0]
    1918:	2800      	cmp	r0, #0
    191a:	d001      	beq.n	1920 <print_array+0x174>
    191c:	683b      	ldr	r3, [r7, #0]
    191e:	4798      	blx	r3
    1920:	3501      	adds	r5, #1
    1922:	3604      	adds	r6, #4
    1924:	42ac      	cmp	r4, r5
    1926:	d1f6      	bne.n	1916 <print_array+0x16a>
			cJSON_free(entries);
    1928:	4b47      	ldr	r3, [pc, #284]	; (1a48 <print_array+0x29c>)
    192a:	681b      	ldr	r3, [r3, #0]
    192c:	9802      	ldr	r0, [sp, #8]
    192e:	4798      	blx	r3
			return 0;
    1930:	2000      	movs	r0, #0
    1932:	e072      	b.n	1a1a <print_array+0x26e>
		}
		
		/* Compose the output array. */
		*out='[';
    1934:	235b      	movs	r3, #91	; 0x5b
    1936:	9a03      	ldr	r2, [sp, #12]
    1938:	7013      	strb	r3, [r2, #0]
		ptr=out+1;*ptr=0;
    193a:	1c57      	adds	r7, r2, #1
    193c:	2300      	movs	r3, #0
    193e:	7053      	strb	r3, [r2, #1]
		for (i=0;i<numentries;i++)
    1940:	2c00      	cmp	r4, #0
    1942:	dd31      	ble.n	19a8 <print_array+0x1fc>
    1944:	9b02      	ldr	r3, [sp, #8]
    1946:	4699      	mov	r9, r3
    1948:	2300      	movs	r3, #0
    194a:	4698      	mov	r8, r3
		{
			tmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;
			if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}
			cJSON_free(entries[i]);
    194c:	4b3e      	ldr	r3, [pc, #248]	; (1a48 <print_array+0x29c>)
    194e:	469b      	mov	fp, r3
    1950:	9401      	str	r4, [sp, #4]
    1952:	464e      	mov	r6, r9
    1954:	46aa      	mov	sl, r5
    1956:	4645      	mov	r5, r8
    1958:	9b00      	ldr	r3, [sp, #0]
    195a:	4698      	mov	r8, r3
    195c:	46b1      	mov	r9, r6
		/* Compose the output array. */
		*out='[';
		ptr=out+1;*ptr=0;
		for (i=0;i<numentries;i++)
		{
			tmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;
    195e:	6833      	ldr	r3, [r6, #0]
    1960:	9300      	str	r3, [sp, #0]
    1962:	0018      	movs	r0, r3
    1964:	4a37      	ldr	r2, [pc, #220]	; (1a44 <print_array+0x298>)
    1966:	4790      	blx	r2
    1968:	0004      	movs	r4, r0
    196a:	0002      	movs	r2, r0
    196c:	9900      	ldr	r1, [sp, #0]
    196e:	0038      	movs	r0, r7
    1970:	4b30      	ldr	r3, [pc, #192]	; (1a34 <print_array+0x288>)
    1972:	4798      	blx	r3
    1974:	193c      	adds	r4, r7, r4
			if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}
    1976:	45aa      	cmp	sl, r5
    1978:	d00b      	beq.n	1992 <print_array+0x1e6>
    197a:	232c      	movs	r3, #44	; 0x2c
    197c:	7023      	strb	r3, [r4, #0]
    197e:	4643      	mov	r3, r8
    1980:	1c67      	adds	r7, r4, #1
    1982:	2b00      	cmp	r3, #0
    1984:	d002      	beq.n	198c <print_array+0x1e0>
    1986:	1ca7      	adds	r7, r4, #2
    1988:	2320      	movs	r3, #32
    198a:	7063      	strb	r3, [r4, #1]
    198c:	2300      	movs	r3, #0
    198e:	703b      	strb	r3, [r7, #0]
    1990:	e000      	b.n	1994 <print_array+0x1e8>
		/* Compose the output array. */
		*out='[';
		ptr=out+1;*ptr=0;
		for (i=0;i<numentries;i++)
		{
			tmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;
    1992:	0027      	movs	r7, r4
			if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}
			cJSON_free(entries[i]);
    1994:	464b      	mov	r3, r9
    1996:	6818      	ldr	r0, [r3, #0]
    1998:	465b      	mov	r3, fp
    199a:	681b      	ldr	r3, [r3, #0]
    199c:	4798      	blx	r3
		}
		
		/* Compose the output array. */
		*out='[';
		ptr=out+1;*ptr=0;
		for (i=0;i<numentries;i++)
    199e:	3501      	adds	r5, #1
    19a0:	3604      	adds	r6, #4
    19a2:	9b01      	ldr	r3, [sp, #4]
    19a4:	42ab      	cmp	r3, r5
    19a6:	d1d9      	bne.n	195c <print_array+0x1b0>
		{
			tmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;
			if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}
			cJSON_free(entries[i]);
		}
		cJSON_free(entries);
    19a8:	4b27      	ldr	r3, [pc, #156]	; (1a48 <print_array+0x29c>)
    19aa:	681b      	ldr	r3, [r3, #0]
    19ac:	9802      	ldr	r0, [sp, #8]
    19ae:	4798      	blx	r3
		*ptr++=']';*ptr++=0;
    19b0:	235d      	movs	r3, #93	; 0x5d
    19b2:	703b      	strb	r3, [r7, #0]
    19b4:	2300      	movs	r3, #0
    19b6:	707b      	strb	r3, [r7, #1]
			if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
			child=child->next;
		}
		
		/* If we didn't fail, try to malloc the output string */
		if (!fail)	out=(char*)cJSON_malloc(len);
    19b8:	9803      	ldr	r0, [sp, #12]
    19ba:	e02e      	b.n	1a1a <print_array+0x26e>
	if (!numentries)
	{
		if (p)	out=ensure(p,3);
		else	out=(char*)cJSON_malloc(3);
		if (out) strcpy(out,"[]");
		return out;
    19bc:	0020      	movs	r0, r4
    19be:	e02c      	b.n	1a1a <print_array+0x26e>

	if (p)
	{
		/* Compose the output array. */
		i=p->offset;
		ptr=ensure(p,1);if (!ptr) return 0;	*ptr='[';	p->offset++;
    19c0:	2000      	movs	r0, #0
    19c2:	e02a      	b.n	1a1a <print_array+0x26e>
			print_value(child,depth+1,fmt,p);
			p->offset=update(p);
			if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}
			child=child->next;
		}
		ptr=ensure(p,2);if (!ptr) return 0;	*ptr++=']';*ptr=0;
    19c4:	2000      	movs	r0, #0
    19c6:	e028      	b.n	1a1a <print_array+0x26e>
	}
	else
	{
		/* Allocate an array to hold the values for each */
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!entries) return 0;
    19c8:	2000      	movs	r0, #0
    19ca:	e026      	b.n	1a1a <print_array+0x26e>
		child=item->child;
		while (child && !fail)
		{
			print_value(child,depth+1,fmt,p);
			p->offset=update(p);
			if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}
    19cc:	2000      	movs	r0, #0
    19ce:	e024      	b.n	1a1a <print_array+0x26e>
    19d0:	2000      	movs	r0, #0
    19d2:	e022      	b.n	1a1a <print_array+0x26e>
    19d4:	232c      	movs	r3, #44	; 0x2c
    19d6:	7003      	strb	r3, [r0, #0]
    19d8:	1c81      	adds	r1, r0, #2
    19da:	3b0c      	subs	r3, #12
    19dc:	7043      	strb	r3, [r0, #1]
    19de:	3b1e      	subs	r3, #30
    19e0:	e73b      	b.n	185a <print_array+0xae>
    19e2:	2103      	movs	r1, #3
    19e4:	0030      	movs	r0, r6
    19e6:	4b10      	ldr	r3, [pc, #64]	; (1a28 <print_array+0x27c>)
    19e8:	4798      	blx	r3
    19ea:	2800      	cmp	r0, #0
    19ec:	d1f2      	bne.n	19d4 <print_array+0x228>
    19ee:	e7ed      	b.n	19cc <print_array+0x220>
    19f0:	1c41      	adds	r1, r0, #1
    19f2:	232c      	movs	r3, #44	; 0x2c
    19f4:	7003      	strb	r3, [r0, #0]
    19f6:	3b2b      	subs	r3, #43	; 0x2b
    19f8:	e72f      	b.n	185a <print_array+0xae>
    19fa:	2102      	movs	r1, #2
    19fc:	0030      	movs	r0, r6
    19fe:	47d8      	blx	fp
    1a00:	2800      	cmp	r0, #0
    1a02:	d1f5      	bne.n	19f0 <print_array+0x244>
    1a04:	e7e4      	b.n	19d0 <print_array+0x224>
    1a06:	3404      	adds	r4, #4
    1a08:	e75c      	b.n	18c4 <print_array+0x118>
    1a0a:	4644      	mov	r4, r8
    1a0c:	464d      	mov	r5, r9
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!entries) return 0;
		memset(entries,0,numentries*sizeof(char*));
		/* Retrieve all the results: */
		child=item->child;
		while (child && !fail)
    1a0e:	683b      	ldr	r3, [r7, #0]
    1a10:	2b00      	cmp	r3, #0
    1a12:	d000      	beq.n	1a16 <print_array+0x26a>
    1a14:	e77a      	b.n	190c <print_array+0x160>
		{
			ret=print_value(child,depth+1,fmt,0);
			entries[i++]=ret;
			if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
    1a16:	2701      	movs	r7, #1
    1a18:	e76a      	b.n	18f0 <print_array+0x144>
		}
		cJSON_free(entries);
		*ptr++=']';*ptr++=0;
	}
	return out;	
}
    1a1a:	b005      	add	sp, #20
    1a1c:	bc3c      	pop	{r2, r3, r4, r5}
    1a1e:	4690      	mov	r8, r2
    1a20:	4699      	mov	r9, r3
    1a22:	46a2      	mov	sl, r4
    1a24:	46ab      	mov	fp, r5
    1a26:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1a28:	00000cb9 	.word	0x00000cb9
    1a2c:	20000004 	.word	0x20000004
    1a30:	00013410 	.word	0x00013410
    1a34:	00011833 	.word	0x00011833
    1a38:	00001125 	.word	0x00001125
    1a3c:	00000d61 	.word	0x00000d61
    1a40:	00011845 	.word	0x00011845
    1a44:	00011d75 	.word	0x00011d75
    1a48:	20000000 	.word	0x20000000

00001a4c <cJSON_GetErrorPtr>:
#include <ctype.h>
#include "cJSON.h"

static const char *ep;

const char *cJSON_GetErrorPtr(void) {return ep;}
    1a4c:	4b01      	ldr	r3, [pc, #4]	; (1a54 <cJSON_GetErrorPtr+0x8>)
    1a4e:	6818      	ldr	r0, [r3, #0]
    1a50:	4770      	bx	lr
    1a52:	46c0      	nop			; (mov r8, r8)
    1a54:	200001c8 	.word	0x200001c8

00001a58 <cJSON_Delete>:
	return node;
}

/* Delete a cJSON structure. */
void cJSON_Delete(cJSON *c)
{
    1a58:	b5f0      	push	{r4, r5, r6, r7, lr}
    1a5a:	4647      	mov	r7, r8
    1a5c:	b480      	push	{r7}
    1a5e:	1e04      	subs	r4, r0, #0
	cJSON *next;
	while (c)
    1a60:	d022      	beq.n	1aa8 <cJSON_Delete+0x50>
	{
		next=c->next;
		if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);
		if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);
    1a62:	4b13      	ldr	r3, [pc, #76]	; (1ab0 <cJSON_Delete+0x58>)
    1a64:	4698      	mov	r8, r3
		if (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);
    1a66:	001f      	movs	r7, r3
		cJSON_free(c);
    1a68:	001e      	movs	r6, r3
void cJSON_Delete(cJSON *c)
{
	cJSON *next;
	while (c)
	{
		next=c->next;
    1a6a:	6825      	ldr	r5, [r4, #0]
		if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);
    1a6c:	68e3      	ldr	r3, [r4, #12]
    1a6e:	05db      	lsls	r3, r3, #23
    1a70:	d40d      	bmi.n	1a8e <cJSON_Delete+0x36>
    1a72:	68a0      	ldr	r0, [r4, #8]
    1a74:	2800      	cmp	r0, #0
    1a76:	d004      	beq.n	1a82 <cJSON_Delete+0x2a>
    1a78:	f7ff ffee 	bl	1a58 <cJSON_Delete>
		if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);
    1a7c:	68e3      	ldr	r3, [r4, #12]
    1a7e:	05db      	lsls	r3, r3, #23
    1a80:	d405      	bmi.n	1a8e <cJSON_Delete+0x36>
    1a82:	6920      	ldr	r0, [r4, #16]
    1a84:	2800      	cmp	r0, #0
    1a86:	d002      	beq.n	1a8e <cJSON_Delete+0x36>
    1a88:	4643      	mov	r3, r8
    1a8a:	681b      	ldr	r3, [r3, #0]
    1a8c:	4798      	blx	r3
		if (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);
    1a8e:	68e3      	ldr	r3, [r4, #12]
    1a90:	059b      	lsls	r3, r3, #22
    1a92:	d404      	bmi.n	1a9e <cJSON_Delete+0x46>
    1a94:	6a20      	ldr	r0, [r4, #32]
    1a96:	2800      	cmp	r0, #0
    1a98:	d001      	beq.n	1a9e <cJSON_Delete+0x46>
    1a9a:	683b      	ldr	r3, [r7, #0]
    1a9c:	4798      	blx	r3
		cJSON_free(c);
    1a9e:	0020      	movs	r0, r4
    1aa0:	6833      	ldr	r3, [r6, #0]
    1aa2:	4798      	blx	r3
		c=next;
    1aa4:	1e2c      	subs	r4, r5, #0

/* Delete a cJSON structure. */
void cJSON_Delete(cJSON *c)
{
	cJSON *next;
	while (c)
    1aa6:	d1e0      	bne.n	1a6a <cJSON_Delete+0x12>
		if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);
		if (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);
		cJSON_free(c);
		c=next;
	}
}
    1aa8:	bc04      	pop	{r2}
    1aaa:	4690      	mov	r8, r2
    1aac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1aae:	46c0      	nop			; (mov r8, r8)
    1ab0:	20000000 	.word	0x20000000

00001ab4 <cJSON_ParseWithOpts>:
/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}

/* Parse an object - create a new root, and populate. */
cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)
{
    1ab4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1ab6:	0005      	movs	r5, r0
    1ab8:	000e      	movs	r6, r1
    1aba:	0017      	movs	r7, r2
	const char *end=0;
	cJSON *c=cJSON_New_Item();
    1abc:	4b16      	ldr	r3, [pc, #88]	; (1b18 <cJSON_ParseWithOpts+0x64>)
    1abe:	4798      	blx	r3
    1ac0:	0004      	movs	r4, r0
	ep=0;
    1ac2:	2200      	movs	r2, #0
    1ac4:	4b15      	ldr	r3, [pc, #84]	; (1b1c <cJSON_ParseWithOpts+0x68>)
    1ac6:	601a      	str	r2, [r3, #0]
	if (!c) return 0;       /* memory fail */
    1ac8:	2800      	cmp	r0, #0
    1aca:	d021      	beq.n	1b10 <cJSON_ParseWithOpts+0x5c>

	end=parse_value(c,skip(value));
    1acc:	0028      	movs	r0, r5
    1ace:	4b14      	ldr	r3, [pc, #80]	; (1b20 <cJSON_ParseWithOpts+0x6c>)
    1ad0:	4798      	blx	r3
    1ad2:	0001      	movs	r1, r0
    1ad4:	0020      	movs	r0, r4
    1ad6:	4b13      	ldr	r3, [pc, #76]	; (1b24 <cJSON_ParseWithOpts+0x70>)
    1ad8:	4798      	blx	r3
    1ada:	1e05      	subs	r5, r0, #0
	if (!end)	{cJSON_Delete(c);return 0;}	/* parse failure. ep is set. */
    1adc:	d104      	bne.n	1ae8 <cJSON_ParseWithOpts+0x34>
    1ade:	0020      	movs	r0, r4
    1ae0:	4b11      	ldr	r3, [pc, #68]	; (1b28 <cJSON_ParseWithOpts+0x74>)
    1ae2:	4798      	blx	r3
    1ae4:	2000      	movs	r0, #0
    1ae6:	e016      	b.n	1b16 <cJSON_ParseWithOpts+0x62>

	/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
	if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);ep=end;return 0;}}
    1ae8:	2f00      	cmp	r7, #0
    1aea:	d00c      	beq.n	1b06 <cJSON_ParseWithOpts+0x52>
    1aec:	4b0c      	ldr	r3, [pc, #48]	; (1b20 <cJSON_ParseWithOpts+0x6c>)
    1aee:	4798      	blx	r3
    1af0:	0005      	movs	r5, r0
    1af2:	7803      	ldrb	r3, [r0, #0]
    1af4:	2b00      	cmp	r3, #0
    1af6:	d006      	beq.n	1b06 <cJSON_ParseWithOpts+0x52>
    1af8:	0020      	movs	r0, r4
    1afa:	4b0b      	ldr	r3, [pc, #44]	; (1b28 <cJSON_ParseWithOpts+0x74>)
    1afc:	4798      	blx	r3
    1afe:	4b07      	ldr	r3, [pc, #28]	; (1b1c <cJSON_ParseWithOpts+0x68>)
    1b00:	601d      	str	r5, [r3, #0]
    1b02:	2000      	movs	r0, #0
    1b04:	e007      	b.n	1b16 <cJSON_ParseWithOpts+0x62>
	if (return_parse_end) *return_parse_end=end;
    1b06:	2e00      	cmp	r6, #0
    1b08:	d004      	beq.n	1b14 <cJSON_ParseWithOpts+0x60>
    1b0a:	6035      	str	r5, [r6, #0]
	return c;
    1b0c:	0020      	movs	r0, r4
    1b0e:	e002      	b.n	1b16 <cJSON_ParseWithOpts+0x62>
cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)
{
	const char *end=0;
	cJSON *c=cJSON_New_Item();
	ep=0;
	if (!c) return 0;       /* memory fail */
    1b10:	2000      	movs	r0, #0
    1b12:	e000      	b.n	1b16 <cJSON_ParseWithOpts+0x62>
	if (!end)	{cJSON_Delete(c);return 0;}	/* parse failure. ep is set. */

	/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
	if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);ep=end;return 0;}}
	if (return_parse_end) *return_parse_end=end;
	return c;
    1b14:	0020      	movs	r0, r4
}
    1b16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1b18:	000008c9 	.word	0x000008c9
    1b1c:	200001c8 	.word	0x200001c8
    1b20:	000008ad 	.word	0x000008ad
    1b24:	000008ed 	.word	0x000008ed
    1b28:	00001a59 	.word	0x00001a59

00001b2c <cJSON_Parse>:
/* Default options for cJSON_Parse */
cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}
    1b2c:	b510      	push	{r4, lr}
    1b2e:	2200      	movs	r2, #0
    1b30:	2100      	movs	r1, #0
    1b32:	4b01      	ldr	r3, [pc, #4]	; (1b38 <cJSON_Parse+0xc>)
    1b34:	4798      	blx	r3
    1b36:	bd10      	pop	{r4, pc}
    1b38:	00001ab5 	.word	0x00001ab5

00001b3c <cJSON_Print>:

/* Render a cJSON item/entity/structure to text. */
char *cJSON_Print(cJSON *item)				{return print_value(item,0,1,0);}
    1b3c:	b510      	push	{r4, lr}
    1b3e:	2300      	movs	r3, #0
    1b40:	2201      	movs	r2, #1
    1b42:	2100      	movs	r1, #0
    1b44:	4c01      	ldr	r4, [pc, #4]	; (1b4c <cJSON_Print+0x10>)
    1b46:	47a0      	blx	r4
    1b48:	bd10      	pop	{r4, pc}
    1b4a:	46c0      	nop			; (mov r8, r8)
    1b4c:	00001125 	.word	0x00001125

00001b50 <cJSON_GetArraySize>:
	}
	return out;	
}

/* Get Array size/item / object item. */
int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
    1b50:	6883      	ldr	r3, [r0, #8]
    1b52:	2b00      	cmp	r3, #0
    1b54:	d005      	beq.n	1b62 <cJSON_GetArraySize+0x12>
    1b56:	2000      	movs	r0, #0
    1b58:	3001      	adds	r0, #1
    1b5a:	681b      	ldr	r3, [r3, #0]
    1b5c:	2b00      	cmp	r3, #0
    1b5e:	d1fb      	bne.n	1b58 <cJSON_GetArraySize+0x8>
    1b60:	e000      	b.n	1b64 <cJSON_GetArraySize+0x14>
    1b62:	2000      	movs	r0, #0
    1b64:	4770      	bx	lr
    1b66:	46c0      	nop			; (mov r8, r8)

00001b68 <cJSON_GetArrayItem>:
cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
    1b68:	6880      	ldr	r0, [r0, #8]
    1b6a:	2800      	cmp	r0, #0
    1b6c:	d007      	beq.n	1b7e <cJSON_GetArrayItem+0x16>
    1b6e:	2900      	cmp	r1, #0
    1b70:	dd05      	ble.n	1b7e <cJSON_GetArrayItem+0x16>
    1b72:	3901      	subs	r1, #1
    1b74:	6800      	ldr	r0, [r0, #0]
    1b76:	2800      	cmp	r0, #0
    1b78:	d001      	beq.n	1b7e <cJSON_GetArrayItem+0x16>
    1b7a:	2900      	cmp	r1, #0
    1b7c:	d1f9      	bne.n	1b72 <cJSON_GetArrayItem+0xa>
    1b7e:	4770      	bx	lr

00001b80 <cJSON_GetObjectItem>:
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}
    1b80:	b570      	push	{r4, r5, r6, lr}
    1b82:	000d      	movs	r5, r1
    1b84:	6884      	ldr	r4, [r0, #8]
    1b86:	2c00      	cmp	r4, #0
    1b88:	d104      	bne.n	1b94 <cJSON_GetObjectItem+0x14>
    1b8a:	e009      	b.n	1ba0 <cJSON_GetObjectItem+0x20>
    1b8c:	6824      	ldr	r4, [r4, #0]
    1b8e:	2c00      	cmp	r4, #0
    1b90:	d101      	bne.n	1b96 <cJSON_GetObjectItem+0x16>
    1b92:	e005      	b.n	1ba0 <cJSON_GetObjectItem+0x20>
    1b94:	4e03      	ldr	r6, [pc, #12]	; (1ba4 <cJSON_GetObjectItem+0x24>)
    1b96:	0029      	movs	r1, r5
    1b98:	6a20      	ldr	r0, [r4, #32]
    1b9a:	47b0      	blx	r6
    1b9c:	2800      	cmp	r0, #0
    1b9e:	d1f5      	bne.n	1b8c <cJSON_GetObjectItem+0xc>
    1ba0:	0020      	movs	r0, r4
    1ba2:	bd70      	pop	{r4, r5, r6, pc}
    1ba4:	0000059d 	.word	0x0000059d

00001ba8 <cJSON_AddItemToArray>:
static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
/* Utility for handling references. */
static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}

/* Add item to array/object. */
void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
    1ba8:	6883      	ldr	r3, [r0, #8]
    1baa:	2900      	cmp	r1, #0
    1bac:	d00f      	beq.n	1bce <cJSON_AddItemToArray+0x26>
    1bae:	2b00      	cmp	r3, #0
    1bb0:	d101      	bne.n	1bb6 <cJSON_AddItemToArray+0xe>
    1bb2:	6081      	str	r1, [r0, #8]
    1bb4:	e00b      	b.n	1bce <cJSON_AddItemToArray+0x26>
    1bb6:	681a      	ldr	r2, [r3, #0]
    1bb8:	2a00      	cmp	r2, #0
    1bba:	d101      	bne.n	1bc0 <cJSON_AddItemToArray+0x18>
    1bbc:	e004      	b.n	1bc8 <cJSON_AddItemToArray+0x20>
    1bbe:	001a      	movs	r2, r3
    1bc0:	6813      	ldr	r3, [r2, #0]
    1bc2:	2b00      	cmp	r3, #0
    1bc4:	d1fb      	bne.n	1bbe <cJSON_AddItemToArray+0x16>
    1bc6:	e000      	b.n	1bca <cJSON_AddItemToArray+0x22>
    1bc8:	001a      	movs	r2, r3
int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
    1bca:	6011      	str	r1, [r2, #0]
    1bcc:	604a      	str	r2, [r1, #4]
/* Utility for handling references. */
static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}

/* Add item to array/object. */
void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
    1bce:	4770      	bx	lr

00001bd0 <cJSON_AddItemToObject>:
void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
    1bd0:	b570      	push	{r4, r5, r6, lr}
    1bd2:	0005      	movs	r5, r0
    1bd4:	000e      	movs	r6, r1
    1bd6:	1e14      	subs	r4, r2, #0
    1bd8:	d00d      	beq.n	1bf6 <cJSON_AddItemToObject+0x26>
    1bda:	6a10      	ldr	r0, [r2, #32]
    1bdc:	2800      	cmp	r0, #0
    1bde:	d002      	beq.n	1be6 <cJSON_AddItemToObject+0x16>
    1be0:	4b05      	ldr	r3, [pc, #20]	; (1bf8 <cJSON_AddItemToObject+0x28>)
    1be2:	681b      	ldr	r3, [r3, #0]
    1be4:	4798      	blx	r3
    1be6:	0030      	movs	r0, r6
    1be8:	4b04      	ldr	r3, [pc, #16]	; (1bfc <cJSON_AddItemToObject+0x2c>)
    1bea:	4798      	blx	r3
    1bec:	6220      	str	r0, [r4, #32]
    1bee:	0021      	movs	r1, r4
    1bf0:	0028      	movs	r0, r5
    1bf2:	4b03      	ldr	r3, [pc, #12]	; (1c00 <cJSON_AddItemToObject+0x30>)
    1bf4:	4798      	blx	r3
    1bf6:	bd70      	pop	{r4, r5, r6, pc}
    1bf8:	20000000 	.word	0x20000000
    1bfc:	00000d31 	.word	0x00000d31
    1c00:	00001ba9 	.word	0x00001ba9

00001c04 <cJSON_CreateNumber>:
/* Create basic types: */
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
    1c04:	b5d0      	push	{r4, r6, r7, lr}
    1c06:	0006      	movs	r6, r0
    1c08:	000f      	movs	r7, r1
    1c0a:	4b07      	ldr	r3, [pc, #28]	; (1c28 <cJSON_CreateNumber+0x24>)
    1c0c:	4798      	blx	r3
    1c0e:	1e04      	subs	r4, r0, #0
    1c10:	d008      	beq.n	1c24 <cJSON_CreateNumber+0x20>
    1c12:	2303      	movs	r3, #3
    1c14:	60c3      	str	r3, [r0, #12]
    1c16:	6186      	str	r6, [r0, #24]
    1c18:	61c7      	str	r7, [r0, #28]
    1c1a:	0030      	movs	r0, r6
    1c1c:	0039      	movs	r1, r7
    1c1e:	4b03      	ldr	r3, [pc, #12]	; (1c2c <cJSON_CreateNumber+0x28>)
    1c20:	4798      	blx	r3
    1c22:	6160      	str	r0, [r4, #20]
    1c24:	0020      	movs	r0, r4
    1c26:	bdd0      	pop	{r4, r6, r7, pc}
    1c28:	000008c9 	.word	0x000008c9
    1c2c:	00011669 	.word	0x00011669

00001c30 <cJSON_CreateString>:
cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
    1c30:	b570      	push	{r4, r5, r6, lr}
    1c32:	0005      	movs	r5, r0
    1c34:	4b05      	ldr	r3, [pc, #20]	; (1c4c <cJSON_CreateString+0x1c>)
    1c36:	4798      	blx	r3
    1c38:	1e04      	subs	r4, r0, #0
    1c3a:	d005      	beq.n	1c48 <cJSON_CreateString+0x18>
    1c3c:	2304      	movs	r3, #4
    1c3e:	60c3      	str	r3, [r0, #12]
    1c40:	0028      	movs	r0, r5
    1c42:	4b03      	ldr	r3, [pc, #12]	; (1c50 <cJSON_CreateString+0x20>)
    1c44:	4798      	blx	r3
    1c46:	6120      	str	r0, [r4, #16]
    1c48:	0020      	movs	r0, r4
    1c4a:	bd70      	pop	{r4, r5, r6, pc}
    1c4c:	000008c9 	.word	0x000008c9
    1c50:	00000d31 	.word	0x00000d31

00001c54 <cJSON_CreateArray>:
cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
    1c54:	b510      	push	{r4, lr}
    1c56:	4b03      	ldr	r3, [pc, #12]	; (1c64 <cJSON_CreateArray+0x10>)
    1c58:	4798      	blx	r3
    1c5a:	2800      	cmp	r0, #0
    1c5c:	d001      	beq.n	1c62 <cJSON_CreateArray+0xe>
    1c5e:	2305      	movs	r3, #5
    1c60:	60c3      	str	r3, [r0, #12]
    1c62:	bd10      	pop	{r4, pc}
    1c64:	000008c9 	.word	0x000008c9

00001c68 <cJSON_CreateObject>:
cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}
    1c68:	b510      	push	{r4, lr}
    1c6a:	4b03      	ldr	r3, [pc, #12]	; (1c78 <cJSON_CreateObject+0x10>)
    1c6c:	4798      	blx	r3
    1c6e:	2800      	cmp	r0, #0
    1c70:	d001      	beq.n	1c76 <cJSON_CreateObject+0xe>
    1c72:	2306      	movs	r3, #6
    1c74:	60c3      	str	r3, [r0, #12]
    1c76:	bd10      	pop	{r4, pc}
    1c78:	000008c9 	.word	0x000008c9

00001c7c <MQTTcallbackHandler>:
			printf("Manual Reconnect Failed - %d", rc);
		}
	}
}

static int32_t MQTTcallbackHandler(MQTTCallbackParams params) {
    1c7c:	b084      	sub	sp, #16
    1c7e:	b5f0      	push	{r4, r5, r6, r7, lr}
    1c80:	b085      	sub	sp, #20
    1c82:	900a      	str	r0, [sp, #40]	; 0x28
    1c84:	910b      	str	r1, [sp, #44]	; 0x2c
    1c86:	920c      	str	r2, [sp, #48]	; 0x30
    1c88:	930d      	str	r3, [sp, #52]	; 0x34
    1c8a:	9003      	str	r0, [sp, #12]
    1c8c:	b28c      	uxth	r4, r1
    1c8e:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    1c90:	9f0f      	ldr	r7, [sp, #60]	; 0x3c

	printf("Subscribe callback");
    1c92:	480c      	ldr	r0, [pc, #48]	; (1cc4 <MQTTcallbackHandler+0x48>)
    1c94:	4e0c      	ldr	r6, [pc, #48]	; (1cc8 <MQTTcallbackHandler+0x4c>)
    1c96:	47b0      	blx	r6
	printf("%.*s\t%.*s",
    1c98:	9500      	str	r5, [sp, #0]
    1c9a:	003b      	movs	r3, r7
    1c9c:	9a03      	ldr	r2, [sp, #12]
    1c9e:	0021      	movs	r1, r4
    1ca0:	480a      	ldr	r0, [pc, #40]	; (1ccc <MQTTcallbackHandler+0x50>)
    1ca2:	47b0      	blx	r6
	(int)params.TopicNameLen, params.pTopicName,
	(int)params.MessageParams.PayloadLen, (char*)params.MessageParams.pPayload);
	printf("\n\r");
    1ca4:	480a      	ldr	r0, [pc, #40]	; (1cd0 <MQTTcallbackHandler+0x54>)
    1ca6:	47b0      	blx	r6
	
	mqtt_subscribe_cb((int)params.TopicNameLen, params.pTopicName, (int)params.MessageParams.PayloadLen, (char*)params.MessageParams.pPayload);
    1ca8:	4b0a      	ldr	r3, [pc, #40]	; (1cd4 <MQTTcallbackHandler+0x58>)
    1caa:	681e      	ldr	r6, [r3, #0]
    1cac:	002b      	movs	r3, r5
    1cae:	003a      	movs	r2, r7
    1cb0:	9903      	ldr	r1, [sp, #12]
    1cb2:	0020      	movs	r0, r4
    1cb4:	47b0      	blx	r6
	return 0;
}
    1cb6:	2000      	movs	r0, #0
    1cb8:	b005      	add	sp, #20
    1cba:	bcf0      	pop	{r4, r5, r6, r7}
    1cbc:	bc08      	pop	{r3}
    1cbe:	b004      	add	sp, #16
    1cc0:	4718      	bx	r3
    1cc2:	46c0      	nop			; (mov r8, r8)
    1cc4:	00013440 	.word	0x00013440
    1cc8:	0001198d 	.word	0x0001198d
    1ccc:	00013454 	.word	0x00013454
    1cd0:	00013460 	.word	0x00013460
    1cd4:	200001cc 	.word	0x200001cc

00001cd8 <disconnectCallbackHandler>:
static bool toggle = false;

static void (*mqtt_subscribe_cb)(int topic_len, char* topic_name, int payload_len, char* payload);


static void disconnectCallbackHandler(void) {
    1cd8:	b510      	push	{r4, lr}
	printf("MQTT Disconnect");
    1cda:	480d      	ldr	r0, [pc, #52]	; (1d10 <disconnectCallbackHandler+0x38>)
    1cdc:	4b0d      	ldr	r3, [pc, #52]	; (1d14 <disconnectCallbackHandler+0x3c>)
    1cde:	4798      	blx	r3
	IoT_Error_t rc = NONE_ERROR;
	if(aws_iot_is_autoreconnect_enabled()){
    1ce0:	4b0d      	ldr	r3, [pc, #52]	; (1d18 <disconnectCallbackHandler+0x40>)
    1ce2:	4798      	blx	r3
    1ce4:	2800      	cmp	r0, #0
    1ce6:	d003      	beq.n	1cf0 <disconnectCallbackHandler+0x18>
		printf("Auto Reconnect is enabled, Reconnecting attempt will start now");
    1ce8:	480c      	ldr	r0, [pc, #48]	; (1d1c <disconnectCallbackHandler+0x44>)
    1cea:	4b0a      	ldr	r3, [pc, #40]	; (1d14 <disconnectCallbackHandler+0x3c>)
    1cec:	4798      	blx	r3
    1cee:	e00e      	b.n	1d0e <disconnectCallbackHandler+0x36>
		}else{
		printf("Auto Reconnect not enabled. Starting manual reconnect...");
    1cf0:	480b      	ldr	r0, [pc, #44]	; (1d20 <disconnectCallbackHandler+0x48>)
    1cf2:	4b08      	ldr	r3, [pc, #32]	; (1d14 <disconnectCallbackHandler+0x3c>)
    1cf4:	4798      	blx	r3
		rc = aws_iot_mqtt_attempt_reconnect();
    1cf6:	4b0b      	ldr	r3, [pc, #44]	; (1d24 <disconnectCallbackHandler+0x4c>)
    1cf8:	4798      	blx	r3
		if(RECONNECT_SUCCESSFUL == rc){
    1cfa:	2801      	cmp	r0, #1
    1cfc:	d103      	bne.n	1d06 <disconnectCallbackHandler+0x2e>
			printf("Manual Reconnect Successful");
    1cfe:	480a      	ldr	r0, [pc, #40]	; (1d28 <disconnectCallbackHandler+0x50>)
    1d00:	4b04      	ldr	r3, [pc, #16]	; (1d14 <disconnectCallbackHandler+0x3c>)
    1d02:	4798      	blx	r3
    1d04:	e003      	b.n	1d0e <disconnectCallbackHandler+0x36>
			}else{
			printf("Manual Reconnect Failed - %d", rc);
    1d06:	0001      	movs	r1, r0
    1d08:	4808      	ldr	r0, [pc, #32]	; (1d2c <disconnectCallbackHandler+0x54>)
    1d0a:	4b02      	ldr	r3, [pc, #8]	; (1d14 <disconnectCallbackHandler+0x3c>)
    1d0c:	4798      	blx	r3
		}
	}
}
    1d0e:	bd10      	pop	{r4, pc}
    1d10:	00013464 	.word	0x00013464
    1d14:	0001198d 	.word	0x0001198d
    1d18:	00007afd 	.word	0x00007afd
    1d1c:	00013474 	.word	0x00013474
    1d20:	000134b4 	.word	0x000134b4
    1d24:	00007a95 	.word	0x00007a95
    1d28:	000134f0 	.word	0x000134f0
    1d2c:	0001350c 	.word	0x0001350c

00001d30 <cloud_connect>:
	free(out);
	
}

Cloud_RC cloud_connect()
{
    1d30:	b570      	push	{r4, r5, r6, lr}
	IoT_Error_t rc = NONE_ERROR;
	
	gethostbyname((uint8_t *)HostAddress);
    1d32:	4d2d      	ldr	r5, [pc, #180]	; (1de8 <cloud_connect+0xb8>)
    1d34:	0028      	movs	r0, r5
    1d36:	4b2d      	ldr	r3, [pc, #180]	; (1dec <cloud_connect+0xbc>)
    1d38:	4798      	blx	r3
	
	connectParams = MQTTConnectParamsDefault;
    1d3a:	4c2d      	ldr	r4, [pc, #180]	; (1df0 <cloud_connect+0xc0>)
    1d3c:	2248      	movs	r2, #72	; 0x48
    1d3e:	492d      	ldr	r1, [pc, #180]	; (1df4 <cloud_connect+0xc4>)
    1d40:	0020      	movs	r0, r4
    1d42:	4b2d      	ldr	r3, [pc, #180]	; (1df8 <cloud_connect+0xc8>)
    1d44:	4798      	blx	r3
	subParams = MQTTSubscribeParamsDefault;
    1d46:	4a2d      	ldr	r2, [pc, #180]	; (1dfc <cloud_connect+0xcc>)
    1d48:	4b2d      	ldr	r3, [pc, #180]	; (1e00 <cloud_connect+0xd0>)
    1d4a:	cb43      	ldmia	r3!, {r0, r1, r6}
    1d4c:	c243      	stmia	r2!, {r0, r1, r6}
	Msg = MQTTMessageParamsDefault;
    1d4e:	4a2d      	ldr	r2, [pc, #180]	; (1e04 <cloud_connect+0xd4>)
    1d50:	4b2d      	ldr	r3, [pc, #180]	; (1e08 <cloud_connect+0xd8>)
    1d52:	cb43      	ldmia	r3!, {r0, r1, r6}
    1d54:	c243      	stmia	r2!, {r0, r1, r6}
    1d56:	681b      	ldr	r3, [r3, #0]
    1d58:	6013      	str	r3, [r2, #0]
	Params = MQTTPublishParamsDefault;
    1d5a:	492c      	ldr	r1, [pc, #176]	; (1e0c <cloud_connect+0xdc>)
    1d5c:	4b2c      	ldr	r3, [pc, #176]	; (1e10 <cloud_connect+0xe0>)
    1d5e:	000a      	movs	r2, r1
    1d60:	cb43      	ldmia	r3!, {r0, r1, r6}
    1d62:	c243      	stmia	r2!, {r0, r1, r6}
    1d64:	cb03      	ldmia	r3!, {r0, r1}
    1d66:	c203      	stmia	r2!, {r0, r1}
			
	connectParams.KeepAliveInterval_sec = 10;
    1d68:	230a      	movs	r3, #10
    1d6a:	84e3      	strh	r3, [r4, #38]	; 0x26
	connectParams.isCleansession = true;
    1d6c:	2201      	movs	r2, #1
    1d6e:	331e      	adds	r3, #30
    1d70:	54e2      	strb	r2, [r4, r3]
	connectParams.MQTTVersion = MQTT_3_1_1;
    1d72:	2104      	movs	r1, #4
    1d74:	3b04      	subs	r3, #4
    1d76:	54e1      	strb	r1, [r4, r3]
	connectParams.pClientID = gAwsMqttClientId;
    1d78:	4b26      	ldr	r3, [pc, #152]	; (1e14 <cloud_connect+0xe4>)
    1d7a:	61a3      	str	r3, [r4, #24]
	connectParams.pHostURL = HostAddress;
    1d7c:	6065      	str	r5, [r4, #4]
	connectParams.port = port;
    1d7e:	4b26      	ldr	r3, [pc, #152]	; (1e18 <cloud_connect+0xe8>)
    1d80:	681b      	ldr	r3, [r3, #0]
    1d82:	8123      	strh	r3, [r4, #8]
	connectParams.isWillMsgPresent = false;
    1d84:	2300      	movs	r3, #0
    1d86:	3125      	adds	r1, #37	; 0x25
    1d88:	5463      	strb	r3, [r4, r1]
	connectParams.pRootCALocation = NULL;
    1d8a:	60e3      	str	r3, [r4, #12]
	connectParams.pDeviceCertLocation = NULL;
    1d8c:	6123      	str	r3, [r4, #16]
	connectParams.pDevicePrivateKeyLocation = NULL;
    1d8e:	6163      	str	r3, [r4, #20]
	connectParams.mqttCommandTimeout_ms = 5000;
    1d90:	4b22      	ldr	r3, [pc, #136]	; (1e1c <cloud_connect+0xec>)
    1d92:	63a3      	str	r3, [r4, #56]	; 0x38
	connectParams.tlsHandshakeTimeout_ms = 5000;
    1d94:	63e3      	str	r3, [r4, #60]	; 0x3c
	connectParams.isSSLHostnameVerify = true; // ensure this is set to true for production
    1d96:	2340      	movs	r3, #64	; 0x40
    1d98:	54e2      	strb	r2, [r4, r3]
	connectParams.disconnectHandler = disconnectCallbackHandler;
    1d9a:	4b21      	ldr	r3, [pc, #132]	; (1e20 <cloud_connect+0xf0>)
    1d9c:	6463      	str	r3, [r4, #68]	; 0x44
			
	if(gbConnectedWifi && receivedTime)
    1d9e:	4b21      	ldr	r3, [pc, #132]	; (1e24 <cloud_connect+0xf4>)
    1da0:	781b      	ldrb	r3, [r3, #0]
		}
		
		return rc;

	}
	return rc;
    1da2:	2000      	movs	r0, #0
	connectParams.mqttCommandTimeout_ms = 5000;
	connectParams.tlsHandshakeTimeout_ms = 5000;
	connectParams.isSSLHostnameVerify = true; // ensure this is set to true for production
	connectParams.disconnectHandler = disconnectCallbackHandler;
			
	if(gbConnectedWifi && receivedTime)
    1da4:	2b00      	cmp	r3, #0
    1da6:	d01e      	beq.n	1de6 <cloud_connect+0xb6>
    1da8:	4b1f      	ldr	r3, [pc, #124]	; (1e28 <cloud_connect+0xf8>)
    1daa:	781b      	ldrb	r3, [r3, #0]
    1dac:	2b00      	cmp	r3, #0
    1dae:	d01a      	beq.n	1de6 <cloud_connect+0xb6>
	{
		//sslEnableCertExpirationCheck(0);
		printf("Connecting...");
    1db0:	481e      	ldr	r0, [pc, #120]	; (1e2c <cloud_connect+0xfc>)
    1db2:	4b1f      	ldr	r3, [pc, #124]	; (1e30 <cloud_connect+0x100>)
    1db4:	4798      	blx	r3
		rc = aws_iot_mqtt_connect(&connectParams);
    1db6:	480e      	ldr	r0, [pc, #56]	; (1df0 <cloud_connect+0xc0>)
    1db8:	4b1e      	ldr	r3, [pc, #120]	; (1e34 <cloud_connect+0x104>)
    1dba:	4798      	blx	r3
    1dbc:	1e04      	subs	r4, r0, #0
		if (NONE_ERROR != rc) {
    1dbe:	d008      	beq.n	1dd2 <cloud_connect+0xa2>
			printf("Error(%d) connecting to %s:%d", rc, connectParams.pHostURL, connectParams.port);
    1dc0:	4a0b      	ldr	r2, [pc, #44]	; (1df0 <cloud_connect+0xc0>)
    1dc2:	8913      	ldrh	r3, [r2, #8]
    1dc4:	6852      	ldr	r2, [r2, #4]
    1dc6:	0001      	movs	r1, r0
    1dc8:	481b      	ldr	r0, [pc, #108]	; (1e38 <cloud_connect+0x108>)
    1dca:	4d19      	ldr	r5, [pc, #100]	; (1e30 <cloud_connect+0x100>)
    1dcc:	47a8      	blx	r5
			return rc;
    1dce:	0020      	movs	r0, r4
    1dd0:	e009      	b.n	1de6 <cloud_connect+0xb6>
		/*
		* Enable Auto Reconnect functionality. Minimum and Maximum time of Exponential backoff are set in aws_iot_config.h
		*  #AWS_IOT_MQTT_MIN_RECONNECT_WAIT_INTERVAL
		*  #AWS_IOT_MQTT_MAX_RECONNECT_WAIT_INTERVAL
		*/
		rc = aws_iot_mqtt_autoreconnect_set_status(true);
    1dd2:	2001      	movs	r0, #1
    1dd4:	4b19      	ldr	r3, [pc, #100]	; (1e3c <cloud_connect+0x10c>)
    1dd6:	4798      	blx	r3
    1dd8:	1e04      	subs	r4, r0, #0
		if (NONE_ERROR != rc) {
    1dda:	d004      	beq.n	1de6 <cloud_connect+0xb6>
			printf("Unable to set Auto Reconnect to true - %d", rc);
    1ddc:	0001      	movs	r1, r0
    1dde:	4818      	ldr	r0, [pc, #96]	; (1e40 <cloud_connect+0x110>)
    1de0:	4b13      	ldr	r3, [pc, #76]	; (1e30 <cloud_connect+0x100>)
    1de2:	4798      	blx	r3
			return rc;
    1de4:	0020      	movs	r0, r4
		
		return rc;

	}
	return rc;
}
    1de6:	bd70      	pop	{r4, r5, r6, pc}
    1de8:	20000008 	.word	0x20000008
    1dec:	000071dd 	.word	0x000071dd
    1df0:	20001b8c 	.word	0x20001b8c
    1df4:	00015224 	.word	0x00015224
    1df8:	00011833 	.word	0x00011833
    1dfc:	20001b80 	.word	0x20001b80
    1e00:	00015218 	.word	0x00015218
    1e04:	20001b70 	.word	0x20001b70
    1e08:	000151dc 	.word	0x000151dc
    1e0c:	20001b5c 	.word	0x20001b5c
    1e10:	000151c8 	.word	0x000151c8
    1e14:	20001a44 	.word	0x20001a44
    1e18:	20000108 	.word	0x20000108
    1e1c:	00001388 	.word	0x00001388
    1e20:	00001cd9 	.word	0x00001cd9
    1e24:	200001f7 	.word	0x200001f7
    1e28:	200002e6 	.word	0x200002e6
    1e2c:	0001352c 	.word	0x0001352c
    1e30:	0001198d 	.word	0x0001198d
    1e34:	00007879 	.word	0x00007879
    1e38:	0001353c 	.word	0x0001353c
    1e3c:	00007add 	.word	0x00007add
    1e40:	0001355c 	.word	0x0001355c

00001e44 <cloud_mqtt_yield>:

Cloud_RC cloud_mqtt_yield(int timeout)
{
    1e44:	b510      	push	{r4, lr}
	IoT_Error_t rc = NONE_ERROR;
	rc = aws_iot_mqtt_yield(timeout);
    1e46:	4b01      	ldr	r3, [pc, #4]	; (1e4c <cloud_mqtt_yield+0x8>)
    1e48:	4798      	blx	r3
	return rc;
}
    1e4a:	bd10      	pop	{r4, pc}
    1e4c:	00007a2d 	.word	0x00007a2d

00001e50 <cloud_mqtt_publish>:

Cloud_RC cloud_mqtt_publish(char* channel, void* message)
{
    1e50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1e52:	0006      	movs	r6, r0

static void jsonMessagePublish(char* channel, cJSON *message)
{
	IoT_Error_t rc = NONE_ERROR;
	char* out;
	out = cJSON_Print(message);
    1e54:	0008      	movs	r0, r1
    1e56:	4b0f      	ldr	r3, [pc, #60]	; (1e94 <cloud_mqtt_publish+0x44>)
    1e58:	4798      	blx	r3
    1e5a:	0005      	movs	r5, r0
	Msg.qos = QOS_0;
    1e5c:	4c0e      	ldr	r4, [pc, #56]	; (1e98 <cloud_mqtt_publish+0x48>)
    1e5e:	2300      	movs	r3, #0
    1e60:	7023      	strb	r3, [r4, #0]
	Msg.PayloadLen = strlen(out) + 1;
    1e62:	4b0e      	ldr	r3, [pc, #56]	; (1e9c <cloud_mqtt_publish+0x4c>)
    1e64:	4798      	blx	r3
    1e66:	1c42      	adds	r2, r0, #1
    1e68:	60e2      	str	r2, [r4, #12]
	Msg.pPayload = (void *)out ;
    1e6a:	60a5      	str	r5, [r4, #8]
	Params.pTopic = (char*)channel;
    1e6c:	480c      	ldr	r0, [pc, #48]	; (1ea0 <cloud_mqtt_publish+0x50>)
    1e6e:	0003      	movs	r3, r0
    1e70:	c340      	stmia	r3!, {r6}
	Params.MessageParams = Msg;
    1e72:	ccc2      	ldmia	r4!, {r1, r6, r7}
    1e74:	c3c2      	stmia	r3!, {r1, r6, r7}
    1e76:	601a      	str	r2, [r3, #0]
	rc = aws_iot_mqtt_publish(&Params);
    1e78:	4b0a      	ldr	r3, [pc, #40]	; (1ea4 <cloud_mqtt_publish+0x54>)
    1e7a:	4798      	blx	r3
	if (rc != NONE_ERROR)
    1e7c:	2800      	cmp	r0, #0
    1e7e:	d003      	beq.n	1e88 <cloud_mqtt_publish+0x38>
	printf("aws_iot_mqtt_publish() error, rc = %d\n", rc);
    1e80:	0001      	movs	r1, r0
    1e82:	4809      	ldr	r0, [pc, #36]	; (1ea8 <cloud_mqtt_publish+0x58>)
    1e84:	4b09      	ldr	r3, [pc, #36]	; (1eac <cloud_mqtt_publish+0x5c>)
    1e86:	4798      	blx	r3
	free(out);
    1e88:	0028      	movs	r0, r5
    1e8a:	4b09      	ldr	r3, [pc, #36]	; (1eb0 <cloud_mqtt_publish+0x60>)
    1e8c:	4798      	blx	r3
	IoT_Error_t rc = NONE_ERROR;
	jsonMessagePublish(channel, message);
	
	return rc;
	
}
    1e8e:	2000      	movs	r0, #0
    1e90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1e92:	46c0      	nop			; (mov r8, r8)
    1e94:	00001b3d 	.word	0x00001b3d
    1e98:	20001b70 	.word	0x20001b70
    1e9c:	00011d75 	.word	0x00011d75
    1ea0:	20001b5c 	.word	0x20001b5c
    1ea4:	000079f1 	.word	0x000079f1
    1ea8:	00013588 	.word	0x00013588
    1eac:	0001198d 	.word	0x0001198d
    1eb0:	00011801 	.word	0x00011801

00001eb4 <cloud_mqtt_subscribe>:

Cloud_RC cloud_mqtt_subscribe(char* channel, void* cb)
{
    1eb4:	b510      	push	{r4, lr}
	IoT_Error_t rc = NONE_ERROR;
	
	mqtt_subscribe_cb = cb;
    1eb6:	4b0c      	ldr	r3, [pc, #48]	; (1ee8 <cloud_mqtt_subscribe+0x34>)
    1eb8:	6019      	str	r1, [r3, #0]
	
	subParams.mHandler = MQTTcallbackHandler;
    1eba:	4c0c      	ldr	r4, [pc, #48]	; (1eec <cloud_mqtt_subscribe+0x38>)
    1ebc:	4b0c      	ldr	r3, [pc, #48]	; (1ef0 <cloud_mqtt_subscribe+0x3c>)
    1ebe:	60a3      	str	r3, [r4, #8]
	subParams.pTopic = (char*)channel;
    1ec0:	6020      	str	r0, [r4, #0]
	subParams.qos = QOS_0;
    1ec2:	2300      	movs	r3, #0
    1ec4:	7123      	strb	r3, [r4, #4]

	if (NONE_ERROR == rc) {
		printf("Subscribing...");
    1ec6:	480b      	ldr	r0, [pc, #44]	; (1ef4 <cloud_mqtt_subscribe+0x40>)
    1ec8:	4b0b      	ldr	r3, [pc, #44]	; (1ef8 <cloud_mqtt_subscribe+0x44>)
    1eca:	4798      	blx	r3
		rc = aws_iot_mqtt_subscribe(&subParams);
    1ecc:	0020      	movs	r0, r4
    1ece:	4b0b      	ldr	r3, [pc, #44]	; (1efc <cloud_mqtt_subscribe+0x48>)
    1ed0:	4798      	blx	r3
    1ed2:	1e04      	subs	r4, r0, #0
		if (NONE_ERROR != rc) {
    1ed4:	d002      	beq.n	1edc <cloud_mqtt_subscribe+0x28>
			printf("Error subscribing\r\n");
    1ed6:	480a      	ldr	r0, [pc, #40]	; (1f00 <cloud_mqtt_subscribe+0x4c>)
    1ed8:	4b0a      	ldr	r3, [pc, #40]	; (1f04 <cloud_mqtt_subscribe+0x50>)
    1eda:	4798      	blx	r3
		}
	}
	printf("Subscription success\r\n");
    1edc:	480a      	ldr	r0, [pc, #40]	; (1f08 <cloud_mqtt_subscribe+0x54>)
    1ede:	4b09      	ldr	r3, [pc, #36]	; (1f04 <cloud_mqtt_subscribe+0x50>)
    1ee0:	4798      	blx	r3
	
	return rc;
	
}
    1ee2:	0020      	movs	r0, r4
    1ee4:	bd10      	pop	{r4, pc}
    1ee6:	46c0      	nop			; (mov r8, r8)
    1ee8:	200001cc 	.word	0x200001cc
    1eec:	20001b80 	.word	0x20001b80
    1ef0:	00001c7d 	.word	0x00001c7d
    1ef4:	000135b0 	.word	0x000135b0
    1ef8:	0001198d 	.word	0x0001198d
    1efc:	000079c1 	.word	0x000079c1
    1f00:	000135c0 	.word	0x000135c0
    1f04:	00011aad 	.word	0x00011aad
    1f08:	000135d4 	.word	0x000135d4

00001f0c <cloud_create_topic>:

Cloud_RC cloud_create_topic(char* full_path, char* device_type, char* device_id, char* topic_name)
{
    1f0c:	b510      	push	{r4, lr}
    1f0e:	b082      	sub	sp, #8
	IoT_Error_t rc = NONE_ERROR;
	
	sprintf(full_path, "winc1500Iot/%s/%s/%s\0", device_type, device_id, topic_name);
    1f10:	9300      	str	r3, [sp, #0]
    1f12:	0013      	movs	r3, r2
    1f14:	000a      	movs	r2, r1
    1f16:	4903      	ldr	r1, [pc, #12]	; (1f24 <cloud_create_topic+0x18>)
    1f18:	4c03      	ldr	r4, [pc, #12]	; (1f28 <cloud_create_topic+0x1c>)
    1f1a:	47a0      	blx	r4
	
	return rc;
	
}
    1f1c:	2000      	movs	r0, #0
    1f1e:	b002      	add	sp, #8
    1f20:	bd10      	pop	{r4, pc}
    1f22:	46c0      	nop			; (mov r8, r8)
    1f24:	00013414 	.word	0x00013414
    1f28:	00011c59 	.word	0x00011c59

00001f2c <cloud_create_search_topic>:

Cloud_RC cloud_create_search_topic(char* full_path, char* acct_uuid, char* topic_name)
{
    1f2c:	b510      	push	{r4, lr}
    1f2e:	0013      	movs	r3, r2
	IoT_Error_t rc = NONE_ERROR;
	sprintf(full_path, "winc1500Iot/%s/%s\0",acct_uuid, topic_name);
    1f30:	000a      	movs	r2, r1
    1f32:	4903      	ldr	r1, [pc, #12]	; (1f40 <cloud_create_search_topic+0x14>)
    1f34:	3118      	adds	r1, #24
    1f36:	4c03      	ldr	r4, [pc, #12]	; (1f44 <cloud_create_search_topic+0x18>)
    1f38:	47a0      	blx	r4
	return rc;
	
}
    1f3a:	2000      	movs	r0, #0
    1f3c:	bd10      	pop	{r4, pc}
    1f3e:	46c0      	nop			; (mov r8, r8)
    1f40:	00013414 	.word	0x00013414
    1f44:	00011c59 	.word	0x00011c59

00001f48 <get_env_sensor_data_from_chip>:




static void get_env_sensor_data_from_chip(environment_data_t *env_data)
{
    1f48:	b510      	push	{r4, lr}
    1f4a:	b084      	sub	sp, #16
    1f4c:	0004      	movs	r4, r0
	s32 env_temperature;
	u32 env_pressure;
	u32 env_humidity;
	uint16_t als_data;
	
	bme280_set_power_mode(BME280_FORCED_MODE);
    1f4e:	2001      	movs	r0, #1
    1f50:	4b15      	ldr	r3, [pc, #84]	; (1fa8 <get_env_sensor_data_from_chip+0x60>)
    1f52:	4798      	blx	r3
	
	if(ERROR == bme280_read_pressure_temperature_humidity(&env_pressure, &env_temperature, &env_humidity)){
    1f54:	aa01      	add	r2, sp, #4
    1f56:	a903      	add	r1, sp, #12
    1f58:	a802      	add	r0, sp, #8
    1f5a:	4b14      	ldr	r3, [pc, #80]	; (1fac <get_env_sensor_data_from_chip+0x64>)
    1f5c:	4798      	blx	r3
    1f5e:	1c43      	adds	r3, r0, #1
    1f60:	d105      	bne.n	1f6e <get_env_sensor_data_from_chip+0x26>
		//error
		DBG_LOG("Reading BME280 has failed");
    1f62:	4813      	ldr	r0, [pc, #76]	; (1fb0 <get_env_sensor_data_from_chip+0x68>)
    1f64:	4b13      	ldr	r3, [pc, #76]	; (1fb4 <get_env_sensor_data_from_chip+0x6c>)
    1f66:	4798      	blx	r3
    1f68:	4813      	ldr	r0, [pc, #76]	; (1fb8 <get_env_sensor_data_from_chip+0x70>)
    1f6a:	4b14      	ldr	r3, [pc, #80]	; (1fbc <get_env_sensor_data_from_chip+0x74>)
    1f6c:	4798      	blx	r3
	}
	if(STATUS_OK != veml60xx_read_alsdata(&als_data)){
    1f6e:	466b      	mov	r3, sp
    1f70:	1c98      	adds	r0, r3, #2
    1f72:	4b13      	ldr	r3, [pc, #76]	; (1fc0 <get_env_sensor_data_from_chip+0x78>)
    1f74:	4798      	blx	r3
    1f76:	2800      	cmp	r0, #0
    1f78:	d005      	beq.n	1f86 <get_env_sensor_data_from_chip+0x3e>
		//error
		DBG_LOG("Reading VEML60xx has failed");
    1f7a:	480d      	ldr	r0, [pc, #52]	; (1fb0 <get_env_sensor_data_from_chip+0x68>)
    1f7c:	4b0d      	ldr	r3, [pc, #52]	; (1fb4 <get_env_sensor_data_from_chip+0x6c>)
    1f7e:	4798      	blx	r3
    1f80:	4810      	ldr	r0, [pc, #64]	; (1fc4 <get_env_sensor_data_from_chip+0x7c>)
    1f82:	4b0e      	ldr	r3, [pc, #56]	; (1fbc <get_env_sensor_data_from_chip+0x74>)
    1f84:	4798      	blx	r3
	}
	
	/* Temperature: No data processing required for Temperature data. Data with resolution 0.01(x100) directly txd*/
	env_data->temperature = (int16_t)env_temperature;
    1f86:	9b03      	ldr	r3, [sp, #12]
    1f88:	8023      	strh	r3, [r4, #0]
	/* Pressure: Returns pressure in Pa as unsigned 32 bit integer. Output value of ?6386?equals 96386 Pa = 963.86 hPa*/
	env_data->pressure = (uint16_t)(env_pressure / 100);
    1f8a:	2164      	movs	r1, #100	; 0x64
    1f8c:	9802      	ldr	r0, [sp, #8]
    1f8e:	4b0e      	ldr	r3, [pc, #56]	; (1fc8 <get_env_sensor_data_from_chip+0x80>)
    1f90:	4798      	blx	r3
    1f92:	8060      	strh	r0, [r4, #2]
	/*ALS: lx/step = 0.07 */
	///env_data->uv = ((uint32_t)(als_data) * 7000 / 100000));
	env_data->uv = ((uint32_t)als_data * 7000);
    1f94:	466b      	mov	r3, sp
    1f96:	885a      	ldrh	r2, [r3, #2]
    1f98:	4b0c      	ldr	r3, [pc, #48]	; (1fcc <get_env_sensor_data_from_chip+0x84>)
    1f9a:	4353      	muls	r3, r2
    1f9c:	6063      	str	r3, [r4, #4]
	//printf("\r\ntest=%d\r\n",(uint32_t) als_data);
	/* Humidity: An output value of 42313 represents 42313 / 1024 = 41.321 %rH*/
	env_data->humidity = (uint8_t)(env_humidity / 1024);
    1f9e:	9b01      	ldr	r3, [sp, #4]
    1fa0:	0a9b      	lsrs	r3, r3, #10
    1fa2:	7223      	strb	r3, [r4, #8]
}
    1fa4:	b004      	add	sp, #16
    1fa6:	bd10      	pop	{r4, pc}
    1fa8:	0000bd0d 	.word	0x0000bd0d
    1fac:	0000b771 	.word	0x0000b771
    1fb0:	000140b0 	.word	0x000140b0
    1fb4:	00011aad 	.word	0x00011aad
    1fb8:	000135ec 	.word	0x000135ec
    1fbc:	0001198d 	.word	0x0001198d
    1fc0:	00002f8d 	.word	0x00002f8d
    1fc4:	00013608 	.word	0x00013608
    1fc8:	0000f82d 	.word	0x0000f82d
    1fcc:	00001b58 	.word	0x00001b58

00001fd0 <env_sensor_data_init>:

void env_sensor_data_init()
{
    1fd0:	b510      	push	{r4, lr}
    1fd2:	b084      	sub	sp, #16
	environment_data_t environment_data;
	
	get_env_sensor_data_from_chip(&environment_data);
    1fd4:	ac01      	add	r4, sp, #4
    1fd6:	0020      	movs	r0, r4
    1fd8:	4b07      	ldr	r3, [pc, #28]	; (1ff8 <env_sensor_data_init+0x28>)
    1fda:	4798      	blx	r3
	
	gi16Disp_temperature = environment_data.temperature;
    1fdc:	8822      	ldrh	r2, [r4, #0]
    1fde:	4b07      	ldr	r3, [pc, #28]	; (1ffc <env_sensor_data_init+0x2c>)
    1fe0:	801a      	strh	r2, [r3, #0]
	gu8Disp_humidity = environment_data.humidity;
    1fe2:	7a22      	ldrb	r2, [r4, #8]
    1fe4:	4b06      	ldr	r3, [pc, #24]	; (2000 <STACK_SIZE>)
    1fe6:	701a      	strb	r2, [r3, #0]
	gu32Disp_uv	= environment_data.uv;
    1fe8:	4b06      	ldr	r3, [pc, #24]	; (2004 <STACK_SIZE+0x4>)
    1fea:	6862      	ldr	r2, [r4, #4]
    1fec:	601a      	str	r2, [r3, #0]
	gu16Disp_pressure = environment_data.pressure;
    1fee:	8862      	ldrh	r2, [r4, #2]
    1ff0:	4b05      	ldr	r3, [pc, #20]	; (2008 <STACK_SIZE+0x8>)
    1ff2:	801a      	strh	r2, [r3, #0]
	
	return;
}
    1ff4:	b004      	add	sp, #16
    1ff6:	bd10      	pop	{r4, pc}
    1ff8:	00001f49 	.word	0x00001f49
    1ffc:	20001c3c 	.word	0x20001c3c
    2000:	20001be8 	.word	0x20001be8
    2004:	20001c38 	.word	0x20001c38
    2008:	20001c3e 	.word	0x20001c3e

0000200c <env_sensor_execute>:



void env_sensor_execute()
{
    200c:	b530      	push	{r4, r5, lr}
    200e:	b087      	sub	sp, #28
	static int uv_not_equal_cnt;
	
	unsigned char updateFlag = 0;
	
	environment_data_t environment_data;
	get_env_sensor_data_from_chip(&environment_data);
    2010:	ac03      	add	r4, sp, #12
    2012:	0020      	movs	r0, r4
    2014:	4b47      	ldr	r3, [pc, #284]	; (2134 <env_sensor_execute+0x128>)
    2016:	4798      	blx	r3
	printf("DBG2: temperature = %d, humidity = %d, uv = %lu, pressure = %d\r\n", environment_data.temperature, environment_data.humidity, environment_data.uv, environment_data.pressure);
    2018:	7a22      	ldrb	r2, [r4, #8]
    201a:	2300      	movs	r3, #0
    201c:	5ee1      	ldrsh	r1, [r4, r3]
    201e:	8863      	ldrh	r3, [r4, #2]
    2020:	9300      	str	r3, [sp, #0]
    2022:	6863      	ldr	r3, [r4, #4]
    2024:	4844      	ldr	r0, [pc, #272]	; (2138 <env_sensor_execute+0x12c>)
    2026:	4d45      	ldr	r5, [pc, #276]	; (213c <env_sensor_execute+0x130>)
    2028:	47a8      	blx	r5
	
	// check temperature
	if (pre_temp != environment_data.temperature)
    202a:	2300      	movs	r3, #0
    202c:	5ee2      	ldrsh	r2, [r4, r3]
    202e:	4b44      	ldr	r3, [pc, #272]	; (2140 <env_sensor_execute+0x134>)
    2030:	2100      	movs	r1, #0
    2032:	5e5b      	ldrsh	r3, [r3, r1]
    2034:	4293      	cmp	r3, r2
    2036:	d006      	beq.n	2046 <env_sensor_execute+0x3a>
	{
		temp_cnt = 0;
    2038:	2100      	movs	r1, #0
    203a:	4b42      	ldr	r3, [pc, #264]	; (2144 <env_sensor_execute+0x138>)
    203c:	6019      	str	r1, [r3, #0]
		pre_temp = environment_data.temperature;
    203e:	4b40      	ldr	r3, [pc, #256]	; (2140 <env_sensor_execute+0x134>)
    2040:	801a      	strh	r2, [r3, #0]
	static int uv_cnt;
	static int pressure_cnt;
	
	static int uv_not_equal_cnt;
	
	unsigned char updateFlag = 0;
    2042:	2300      	movs	r3, #0
    2044:	e010      	b.n	2068 <env_sensor_execute+0x5c>
	{
		temp_cnt = 0;
		pre_temp = environment_data.temperature;
	}
	else
		temp_cnt++;
    2046:	4b3f      	ldr	r3, [pc, #252]	; (2144 <env_sensor_execute+0x138>)
    2048:	6819      	ldr	r1, [r3, #0]
    204a:	3101      	adds	r1, #1
    204c:	6019      	str	r1, [r3, #0]
	static int uv_cnt;
	static int pressure_cnt;
	
	static int uv_not_equal_cnt;
	
	unsigned char updateFlag = 0;
    204e:	2300      	movs	r3, #0
		pre_temp = environment_data.temperature;
	}
	else
		temp_cnt++;
	
	if ((temp_cnt >= TEMP_DISP_COUNTER) && gi16Disp_temperature!= pre_temp)
    2050:	2900      	cmp	r1, #0
    2052:	dd09      	ble.n	2068 <env_sensor_execute+0x5c>
    2054:	4b3c      	ldr	r3, [pc, #240]	; (2148 <env_sensor_execute+0x13c>)
    2056:	2100      	movs	r1, #0
    2058:	5e5b      	ldrsh	r3, [r3, r1]
    205a:	4293      	cmp	r3, r2
    205c:	d003      	beq.n	2066 <env_sensor_execute+0x5a>
	{
		gi16Disp_temperature = pre_temp;
    205e:	4b3a      	ldr	r3, [pc, #232]	; (2148 <env_sensor_execute+0x13c>)
    2060:	801a      	strh	r2, [r3, #0]
		updateFlag |= TEMP_UPDATE_BIT; 
    2062:	2301      	movs	r3, #1
    2064:	e000      	b.n	2068 <env_sensor_execute+0x5c>
	static int uv_cnt;
	static int pressure_cnt;
	
	static int uv_not_equal_cnt;
	
	unsigned char updateFlag = 0;
    2066:	2300      	movs	r3, #0
		gi16Disp_temperature = pre_temp;
		updateFlag |= TEMP_UPDATE_BIT; 
	}
	
	// check humidity
	if (pre_hum != environment_data.humidity)
    2068:	aa03      	add	r2, sp, #12
    206a:	7a12      	ldrb	r2, [r2, #8]
    206c:	4937      	ldr	r1, [pc, #220]	; (214c <env_sensor_execute+0x140>)
    206e:	7809      	ldrb	r1, [r1, #0]
    2070:	4291      	cmp	r1, r2
    2072:	d005      	beq.n	2080 <env_sensor_execute+0x74>
	{
		hum_cnt = 0;
    2074:	2000      	movs	r0, #0
    2076:	4936      	ldr	r1, [pc, #216]	; (2150 <env_sensor_execute+0x144>)
    2078:	6008      	str	r0, [r1, #0]
		pre_hum = environment_data.humidity;
    207a:	4934      	ldr	r1, [pc, #208]	; (214c <env_sensor_execute+0x140>)
    207c:	700a      	strb	r2, [r1, #0]
    207e:	e00d      	b.n	209c <env_sensor_execute+0x90>
	}
	else
		hum_cnt++;
    2080:	4833      	ldr	r0, [pc, #204]	; (2150 <env_sensor_execute+0x144>)
    2082:	6801      	ldr	r1, [r0, #0]
    2084:	3101      	adds	r1, #1
    2086:	6001      	str	r1, [r0, #0]
	
	if ((hum_cnt >= HUM_DISP_COUNTER) && gu8Disp_humidity!= pre_hum)
    2088:	2900      	cmp	r1, #0
    208a:	dd07      	ble.n	209c <env_sensor_execute+0x90>
    208c:	4931      	ldr	r1, [pc, #196]	; (2154 <env_sensor_execute+0x148>)
    208e:	7809      	ldrb	r1, [r1, #0]
    2090:	4291      	cmp	r1, r2
    2092:	d003      	beq.n	209c <env_sensor_execute+0x90>
	{
		gu8Disp_humidity = pre_hum;
    2094:	492f      	ldr	r1, [pc, #188]	; (2154 <env_sensor_execute+0x148>)
    2096:	700a      	strb	r2, [r1, #0]
		updateFlag |= HUM_UPDATE_BIT; 
    2098:	2202      	movs	r2, #2
    209a:	4313      	orrs	r3, r2
	}
	
	// check uv
	if (pre_uv != environment_data.uv)
    209c:	9a04      	ldr	r2, [sp, #16]
    209e:	492e      	ldr	r1, [pc, #184]	; (2158 <env_sensor_execute+0x14c>)
    20a0:	6809      	ldr	r1, [r1, #0]
    20a2:	428a      	cmp	r2, r1
    20a4:	d00b      	beq.n	20be <env_sensor_execute+0xb2>
	{
		uv_cnt = 0;
    20a6:	2000      	movs	r0, #0
    20a8:	492c      	ldr	r1, [pc, #176]	; (215c <env_sensor_execute+0x150>)
    20aa:	6008      	str	r0, [r1, #0]
		pre_uv = environment_data.uv;
    20ac:	492a      	ldr	r1, [pc, #168]	; (2158 <env_sensor_execute+0x14c>)
    20ae:	600a      	str	r2, [r1, #0]
		uv_not_equal_cnt++;
    20b0:	492b      	ldr	r1, [pc, #172]	; (2160 <env_sensor_execute+0x154>)
    20b2:	680a      	ldr	r2, [r1, #0]
    20b4:	3201      	adds	r2, #1
    20b6:	600a      	str	r2, [r1, #0]
	else
	{
		uv_cnt++;
		uv_not_equal_cnt = 0;
	}
	if (((uv_cnt >= UV_DISP_COUNTER) && gu32Disp_uv!= pre_uv) || (uv_not_equal_cnt >1))
    20b8:	2a01      	cmp	r2, #1
    20ba:	dc0d      	bgt.n	20d8 <env_sensor_execute+0xcc>
    20bc:	e015      	b.n	20ea <env_sensor_execute+0xde>
		pre_uv = environment_data.uv;
		uv_not_equal_cnt++;
	}
	else
	{
		uv_cnt++;
    20be:	4827      	ldr	r0, [pc, #156]	; (215c <env_sensor_execute+0x150>)
    20c0:	6801      	ldr	r1, [r0, #0]
    20c2:	3101      	adds	r1, #1
    20c4:	6001      	str	r1, [r0, #0]
		uv_not_equal_cnt = 0;
    20c6:	2400      	movs	r4, #0
    20c8:	4825      	ldr	r0, [pc, #148]	; (2160 <env_sensor_execute+0x154>)
    20ca:	6004      	str	r4, [r0, #0]
	}
	if (((uv_cnt >= UV_DISP_COUNTER) && gu32Disp_uv!= pre_uv) || (uv_not_equal_cnt >1))
    20cc:	2900      	cmp	r1, #0
    20ce:	dd0c      	ble.n	20ea <env_sensor_execute+0xde>
    20d0:	4924      	ldr	r1, [pc, #144]	; (2164 <env_sensor_execute+0x158>)
    20d2:	6809      	ldr	r1, [r1, #0]
    20d4:	428a      	cmp	r2, r1
    20d6:	d008      	beq.n	20ea <env_sensor_execute+0xde>
	//if (((uv_cnt >= UV_DISP_COUNTER) && gu32Disp_uv!= pre_uv))
	{
		gu32Disp_uv = pre_uv;
    20d8:	4a1f      	ldr	r2, [pc, #124]	; (2158 <env_sensor_execute+0x14c>)
    20da:	6811      	ldr	r1, [r2, #0]
    20dc:	4a21      	ldr	r2, [pc, #132]	; (2164 <env_sensor_execute+0x158>)
    20de:	6011      	str	r1, [r2, #0]
		updateFlag |= UV_UPDATE_BIT; 
    20e0:	2204      	movs	r2, #4
    20e2:	4313      	orrs	r3, r2
		uv_not_equal_cnt = 0;
    20e4:	2100      	movs	r1, #0
    20e6:	4a1e      	ldr	r2, [pc, #120]	; (2160 <env_sensor_execute+0x154>)
    20e8:	6011      	str	r1, [r2, #0]
	}
	
	// check pressure
	if (pre_pressure != environment_data.pressure)
    20ea:	aa03      	add	r2, sp, #12
    20ec:	8852      	ldrh	r2, [r2, #2]
    20ee:	491e      	ldr	r1, [pc, #120]	; (2168 <env_sensor_execute+0x15c>)
    20f0:	8809      	ldrh	r1, [r1, #0]
    20f2:	4291      	cmp	r1, r2
    20f4:	d005      	beq.n	2102 <env_sensor_execute+0xf6>
	{
		pressure_cnt = 0;
    20f6:	2000      	movs	r0, #0
    20f8:	491c      	ldr	r1, [pc, #112]	; (216c <env_sensor_execute+0x160>)
    20fa:	6008      	str	r0, [r1, #0]
		pre_pressure = environment_data.pressure;
    20fc:	491a      	ldr	r1, [pc, #104]	; (2168 <env_sensor_execute+0x15c>)
    20fe:	800a      	strh	r2, [r1, #0]
    2100:	e00d      	b.n	211e <env_sensor_execute+0x112>
	}
	else
		pressure_cnt++;
    2102:	481a      	ldr	r0, [pc, #104]	; (216c <env_sensor_execute+0x160>)
    2104:	6801      	ldr	r1, [r0, #0]
    2106:	3101      	adds	r1, #1
    2108:	6001      	str	r1, [r0, #0]
	
	if ((pressure_cnt >= PRESSURE_DISP_COUNTER) && gu16Disp_pressure!= pre_pressure)
    210a:	2900      	cmp	r1, #0
    210c:	dd07      	ble.n	211e <env_sensor_execute+0x112>
    210e:	4918      	ldr	r1, [pc, #96]	; (2170 <env_sensor_execute+0x164>)
    2110:	8809      	ldrh	r1, [r1, #0]
    2112:	4291      	cmp	r1, r2
    2114:	d003      	beq.n	211e <env_sensor_execute+0x112>
	{
		gu16Disp_pressure = pre_pressure;
    2116:	4916      	ldr	r1, [pc, #88]	; (2170 <env_sensor_execute+0x164>)
    2118:	800a      	strh	r2, [r1, #0]
		updateFlag |= PRESSURE_UPDATE_BIT; 
    211a:	2208      	movs	r2, #8
    211c:	4313      	orrs	r3, r2
	}
		
	if (updateFlag > 0)
    211e:	2b00      	cmp	r3, #0
    2120:	d005      	beq.n	212e <env_sensor_execute+0x122>
		env_sensor_update_cb(environment_data, updateFlag);
    2122:	4a14      	ldr	r2, [pc, #80]	; (2174 <env_sensor_execute+0x168>)
    2124:	6814      	ldr	r4, [r2, #0]
    2126:	9803      	ldr	r0, [sp, #12]
    2128:	9904      	ldr	r1, [sp, #16]
    212a:	9a05      	ldr	r2, [sp, #20]
    212c:	47a0      	blx	r4
	
}
    212e:	b007      	add	sp, #28
    2130:	bd30      	pop	{r4, r5, pc}
    2132:	46c0      	nop			; (mov r8, r8)
    2134:	00001f49 	.word	0x00001f49
    2138:	00013624 	.word	0x00013624
    213c:	0001198d 	.word	0x0001198d
    2140:	200001f4 	.word	0x200001f4
    2144:	200001f0 	.word	0x200001f0
    2148:	20001c3c 	.word	0x20001c3c
    214c:	200001e8 	.word	0x200001e8
    2150:	200001e4 	.word	0x200001e4
    2154:	20001be8 	.word	0x20001be8
    2158:	200001ec 	.word	0x200001ec
    215c:	200001d8 	.word	0x200001d8
    2160:	200001d0 	.word	0x200001d0
    2164:	20001c38 	.word	0x20001c38
    2168:	200001d4 	.word	0x200001d4
    216c:	200001e0 	.word	0x200001e0
    2170:	20001c3e 	.word	0x20001c3e
    2174:	200001dc 	.word	0x200001dc

00002178 <get_env_sensor_data_for_display>:

void get_env_sensor_data_for_display(environment_data_t *env_data)
{
	env_data->temperature = gi16Disp_temperature;
    2178:	4b06      	ldr	r3, [pc, #24]	; (2194 <get_env_sensor_data_for_display+0x1c>)
    217a:	2200      	movs	r2, #0
    217c:	5e9b      	ldrsh	r3, [r3, r2]
    217e:	8003      	strh	r3, [r0, #0]
	env_data->humidity = gu8Disp_humidity;
    2180:	4b05      	ldr	r3, [pc, #20]	; (2198 <get_env_sensor_data_for_display+0x20>)
    2182:	781b      	ldrb	r3, [r3, #0]
    2184:	7203      	strb	r3, [r0, #8]
	env_data->uv = gu32Disp_uv;
    2186:	4b05      	ldr	r3, [pc, #20]	; (219c <get_env_sensor_data_for_display+0x24>)
    2188:	681b      	ldr	r3, [r3, #0]
    218a:	6043      	str	r3, [r0, #4]
	env_data->pressure = gu16Disp_pressure;
    218c:	4b04      	ldr	r3, [pc, #16]	; (21a0 <get_env_sensor_data_for_display+0x28>)
    218e:	881b      	ldrh	r3, [r3, #0]
    2190:	8043      	strh	r3, [r0, #2]
	
}
    2192:	4770      	bx	lr
    2194:	20001c3c 	.word	0x20001c3c
    2198:	20001be8 	.word	0x20001be8
    219c:	20001c38 	.word	0x20001c38
    21a0:	20001c3e 	.word	0x20001c3e

000021a4 <register_env_sensor_udpate_callback_handler>:

void register_env_sensor_udpate_callback_handler(void* cb)
{
	env_sensor_update_cb = cb;
    21a4:	4b01      	ldr	r3, [pc, #4]	; (21ac <register_env_sensor_udpate_callback_handler+0x8>)
    21a6:	6018      	str	r0, [r3, #0]
    21a8:	4770      	bx	lr
    21aa:	46c0      	nop			; (mov r8, r8)
    21ac:	200001dc 	.word	0x200001dc

000021b0 <set_prov_state>:
}


void set_prov_state(prov_state_t state)
{
	prov_state = state;
    21b0:	4b01      	ldr	r3, [pc, #4]	; (21b8 <set_prov_state+0x8>)
    21b2:	7018      	strb	r0, [r3, #0]
}
    21b4:	4770      	bx	lr
    21b6:	46c0      	nop			; (mov r8, r8)
    21b8:	200001f6 	.word	0x200001f6

000021bc <get_prov_state>:

prov_state_t get_prov_state(void)
{
	return prov_state;
    21bc:	4b01      	ldr	r3, [pc, #4]	; (21c4 <get_prov_state+0x8>)
    21be:	7818      	ldrb	r0, [r3, #0]
}
    21c0:	4770      	bx	lr
    21c2:	46c0      	nop			; (mov r8, r8)
    21c4:	200001f6 	.word	0x200001f6

000021c8 <parse_iot_cmd>:


void parse_iot_cmd(SOCKET sock, uint8_t cmd, uint8_t *cmd_param, cmd_resp_t *cmd_resp)
{
    21c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    21ca:	465f      	mov	r7, fp
    21cc:	4656      	mov	r6, sl
    21ce:	464d      	mov	r5, r9
    21d0:	4644      	mov	r4, r8
    21d2:	b4f0      	push	{r4, r5, r6, r7}
    21d4:	0014      	movs	r4, r2
    21d6:	001d      	movs	r5, r3
	iot_status_code_t cmd_status_code = OPT_SUCCESS;
	switch (cmd)
    21d8:	2901      	cmp	r1, #1
    21da:	d000      	beq.n	21de <parse_iot_cmd+0x16>
    21dc:	e0d5      	b.n	238a <parse_iot_cmd+0x1c2>
	{
		
		case WIFI_NODE_DISCOVER:
		{
			printf("WIFI_NODE_DISCOVER receive\r\n");
    21de:	486e      	ldr	r0, [pc, #440]	; (2398 <parse_iot_cmd+0x1d0>)
    21e0:	4b6e      	ldr	r3, [pc, #440]	; (239c <parse_iot_cmd+0x1d4>)
    21e2:	4798      	blx	r3
			if (memcmp(cmd_param, DISCOVERY_PARAM, DISCOVERY_PARAM_LEN) == 0) {
    21e4:	2214      	movs	r2, #20
    21e6:	496e      	ldr	r1, [pc, #440]	; (23a0 <parse_iot_cmd+0x1d8>)
    21e8:	0020      	movs	r0, r4
    21ea:	4b6e      	ldr	r3, [pc, #440]	; (23a4 <parse_iot_cmd+0x1dc>)
    21ec:	4798      	blx	r3
    21ee:	2800      	cmp	r0, #0
    21f0:	d122      	bne.n	2238 <parse_iot_cmd+0x70>
					printf("WIFI_NODE_DISCOVER DISC PARAM receive\r\n");
    21f2:	486d      	ldr	r0, [pc, #436]	; (23a8 <parse_iot_cmd+0x1e0>)
    21f4:	4b69      	ldr	r3, [pc, #420]	; (239c <parse_iot_cmd+0x1d4>)
    21f6:	4798      	blx	r3
					// provision not done, in AP mode
					if (prov_state == PROV_WAITING || prov_state == PROV_INIT) {
    21f8:	4b6c      	ldr	r3, [pc, #432]	; (23ac <parse_iot_cmd+0x1e4>)
    21fa:	781b      	ldrb	r3, [r3, #0]
    21fc:	2b01      	cmp	r3, #1
    21fe:	d900      	bls.n	2202 <parse_iot_cmd+0x3a>
    2200:	e0c3      	b.n	238a <parse_iot_cmd+0x1c2>
						prov_state = PROV_INIT;
    2202:	2201      	movs	r2, #1
    2204:	4b69      	ldr	r3, [pc, #420]	; (23ac <parse_iot_cmd+0x1e4>)
    2206:	701a      	strb	r2, [r3, #0]
						printf("WIFI_NODE_DISCOVER DISC PARAM log2\r\n");
    2208:	4869      	ldr	r0, [pc, #420]	; (23b0 <parse_iot_cmd+0x1e8>)
    220a:	4b64      	ldr	r3, [pc, #400]	; (239c <parse_iot_cmd+0x1d4>)
    220c:	4798      	blx	r3
	#endif
	#define PARAM_LEN   DISCOVERY_RESP_PARAM_LEN
	#define HEADER_LEN  DISCOVERY_RESP_HDR_LEN
	#define CMD_ID      WIFI_NODE_DISC_RESP
	uint8_t *send_buffer = (uint8_t *)&cmd_resp->data;
	_FILL_IOT_HEADER_
    220e:	235a      	movs	r3, #90	; 0x5a
    2210:	70ab      	strb	r3, [r5, #2]
    2212:	3b4a      	subs	r3, #74	; 0x4a
    2214:	70eb      	strb	r3, [r5, #3]
    2216:	2300      	movs	r3, #0
    2218:	712b      	strb	r3, [r5, #4]
    221a:	2281      	movs	r2, #129	; 0x81
    221c:	71aa      	strb	r2, [r5, #6]
    221e:	71eb      	strb	r3, [r5, #7]
    2220:	722b      	strb	r3, [r5, #8]
    2222:	726b      	strb	r3, [r5, #9]
    2224:	72ab      	strb	r3, [r5, #10]
	memcpy(&send_buffer[HEADER_LEN + DISCOVERY_RESP_PARAM_OFFSET], \
    2226:	0028      	movs	r0, r5
    2228:	300b      	adds	r0, #11
    222a:	3a7b      	subs	r2, #123	; 0x7b
    222c:	4961      	ldr	r1, [pc, #388]	; (23b4 <parse_iot_cmd+0x1ec>)
    222e:	4b62      	ldr	r3, [pc, #392]	; (23b8 <parse_iot_cmd+0x1f0>)
    2230:	4798      	blx	r3
	gMacaddr, MAC_ADDR_C_ATTR1_LEN);
	_FILL_IOT_FRAME_LENGTH_
    2232:	2313      	movs	r3, #19
    2234:	802b      	strh	r3, [r5, #0]
    2236:	e0a8      	b.n	238a <parse_iot_cmd+0x1c2>
						printf("WIFI_NODE_DISCOVER DISC PARAM log2\r\n");
						wifi_discovery_resp(cmd_resp);
					}
					
			}
			else if (memcmp(cmd_param, PROVCONF_PARAM_HDR, PROVCONF_PARAM_HDR_LEN) == 0) {
    2238:	2207      	movs	r2, #7
    223a:	4960      	ldr	r1, [pc, #384]	; (23bc <parse_iot_cmd+0x1f4>)
    223c:	0020      	movs	r0, r4
    223e:	4b59      	ldr	r3, [pc, #356]	; (23a4 <parse_iot_cmd+0x1dc>)
    2240:	4798      	blx	r3
    2242:	2800      	cmp	r0, #0
    2244:	d16f      	bne.n	2326 <parse_iot_cmd+0x15e>
				printf("WIFI_NODE_DISCOVERY PROVCONF PARAM receive\r\n");
    2246:	485e      	ldr	r0, [pc, #376]	; (23c0 <parse_iot_cmd+0x1f8>)
    2248:	4b54      	ldr	r3, [pc, #336]	; (239c <parse_iot_cmd+0x1d4>)
    224a:	4798      	blx	r3
				if (prov_state == PROV_INIT) {
    224c:	4b57      	ldr	r3, [pc, #348]	; (23ac <parse_iot_cmd+0x1e4>)
    224e:	781b      	ldrb	r3, [r3, #0]
    2250:	2b01      	cmp	r3, #1
    2252:	d164      	bne.n	231e <parse_iot_cmd+0x156>
					uint8_t ssidlength = *(cmd_param + PROVCONF_PARAM_HDR_LEN);
    2254:	79e6      	ldrb	r6, [r4, #7]
					memcpy((char *)gDefaultSSID, (char *)(cmd_param + PROV_SSID_OFFSET), ssidlength);
    2256:	0021      	movs	r1, r4
    2258:	3108      	adds	r1, #8
    225a:	0032      	movs	r2, r6
    225c:	4859      	ldr	r0, [pc, #356]	; (23c4 <parse_iot_cmd+0x1fc>)
    225e:	4b56      	ldr	r3, [pc, #344]	; (23b8 <parse_iot_cmd+0x1f0>)
    2260:	469b      	mov	fp, r3
    2262:	4798      	blx	r3
					gDefaultSSID[ssidlength] = 0; // last byte '/n'
    2264:	2300      	movs	r3, #0
    2266:	469a      	mov	sl, r3
    2268:	4b56      	ldr	r3, [pc, #344]	; (23c4 <parse_iot_cmd+0x1fc>)
    226a:	4652      	mov	r2, sl
    226c:	559a      	strb	r2, [r3, r6]
					uint8_t pswlength = *(cmd_param + PROV_SSID_OFFSET + ssidlength);
    226e:	19a3      	adds	r3, r4, r6
    2270:	7a1f      	ldrb	r7, [r3, #8]
					uint8_t pswoffset = PROV_SSID_OFFSET + ssidlength + sizeof(pswlength);
					memcpy((char *)gDefaultKey, (char *)(cmd_param + pswoffset), pswlength);
    2272:	0031      	movs	r1, r6
    2274:	3109      	adds	r1, #9
    2276:	b2c9      	uxtb	r1, r1
    2278:	1861      	adds	r1, r4, r1
    227a:	003a      	movs	r2, r7
    227c:	4852      	ldr	r0, [pc, #328]	; (23c8 <parse_iot_cmd+0x200>)
    227e:	47d8      	blx	fp
					gDefaultKey[pswlength] = 0; // last byte '/n'
    2280:	4b51      	ldr	r3, [pc, #324]	; (23c8 <parse_iot_cmd+0x200>)
    2282:	4652      	mov	r2, sl
    2284:	55da      	strb	r2, [r3, r7]
					uint8_t authtype = *(cmd_param + PROV_SSID_OFFSET + ssidlength + 1 + pswlength);
    2286:	19f1      	adds	r1, r6, r7
    2288:	1863      	adds	r3, r4, r1
    228a:	7a5a      	ldrb	r2, [r3, #9]
    228c:	4690      	mov	r8, r2
					uint8_t uuidlength = *(cmd_param + PROV_SSID_OFFSET + ssidlength + 1 + pswlength + 1);
    228e:	7a9b      	ldrb	r3, [r3, #10]
    2290:	4699      	mov	r9, r3
					memcpy((char *)gUuid, (char *)(cmd_param + PROV_SSID_OFFSET + ssidlength + 1 + pswlength + 1 + 1), uuidlength);
    2292:	310b      	adds	r1, #11
    2294:	1861      	adds	r1, r4, r1
    2296:	001a      	movs	r2, r3
    2298:	484c      	ldr	r0, [pc, #304]	; (23cc <parse_iot_cmd+0x204>)
    229a:	47d8      	blx	fp
					gUuid[uuidlength] = 0;
    229c:	4b4b      	ldr	r3, [pc, #300]	; (23cc <parse_iot_cmd+0x204>)
    229e:	464a      	mov	r2, r9
    22a0:	4651      	mov	r1, sl
    22a2:	5499      	strb	r1, [r3, r2]
					
					printf("gDefaultSSID=%s\r\n", gDefaultSSID);
    22a4:	4947      	ldr	r1, [pc, #284]	; (23c4 <parse_iot_cmd+0x1fc>)
    22a6:	484a      	ldr	r0, [pc, #296]	; (23d0 <parse_iot_cmd+0x208>)
    22a8:	4c4a      	ldr	r4, [pc, #296]	; (23d4 <parse_iot_cmd+0x20c>)
    22aa:	47a0      	blx	r4
					printf("gDefaultKey=%s\r\n", gDefaultKey);
    22ac:	4946      	ldr	r1, [pc, #280]	; (23c8 <parse_iot_cmd+0x200>)
    22ae:	484a      	ldr	r0, [pc, #296]	; (23d8 <parse_iot_cmd+0x210>)
    22b0:	47a0      	blx	r4
					printf("authtype=%d\r\n", authtype);
    22b2:	4641      	mov	r1, r8
    22b4:	4849      	ldr	r0, [pc, #292]	; (23dc <parse_iot_cmd+0x214>)
    22b6:	47a0      	blx	r4
					printf("gUuid=%s\r\n", gUuid);
    22b8:	4944      	ldr	r1, [pc, #272]	; (23cc <parse_iot_cmd+0x204>)
    22ba:	4849      	ldr	r0, [pc, #292]	; (23e0 <parse_iot_cmd+0x218>)
    22bc:	47a0      	blx	r4
					if (((authtype <= M2M_WIFI_SEC_802_1X && authtype > M2M_WIFI_SEC_OPEN && pswlength) ||
    22be:	4643      	mov	r3, r8
    22c0:	3b02      	subs	r3, #2
    22c2:	2b02      	cmp	r3, #2
    22c4:	d802      	bhi.n	22cc <parse_iot_cmd+0x104>
    22c6:	2f00      	cmp	r7, #0
    22c8:	d105      	bne.n	22d6 <parse_iot_cmd+0x10e>
    22ca:	e05a      	b.n	2382 <parse_iot_cmd+0x1ba>
    22cc:	4643      	mov	r3, r8
    22ce:	2b01      	cmp	r3, #1
    22d0:	d121      	bne.n	2316 <parse_iot_cmd+0x14e>
					(authtype == M2M_WIFI_SEC_OPEN && pswlength == 0)) && ssidlength){
    22d2:	2f00      	cmp	r7, #0
    22d4:	d11f      	bne.n	2316 <parse_iot_cmd+0x14e>
    22d6:	2e00      	cmp	r6, #0
    22d8:	d01d      	beq.n	2316 <parse_iot_cmd+0x14e>
						gAuthType = authtype;
    22da:	4b42      	ldr	r3, [pc, #264]	; (23e4 <parse_iot_cmd+0x21c>)
    22dc:	4642      	mov	r2, r8
    22de:	701a      	strb	r2, [r3, #0]
						printf("wifi_provision_resp\r\n");
    22e0:	4841      	ldr	r0, [pc, #260]	; (23e8 <parse_iot_cmd+0x220>)
    22e2:	4b2e      	ldr	r3, [pc, #184]	; (239c <parse_iot_cmd+0x1d4>)
    22e4:	4798      	blx	r3
	#endif
	#define PARAM_LEN   PROV_RESP_PARAM_LEN
	#define HEADER_LEN  PROV_RESP_HDR_LEN
	#define CMD_ID      WIFI_NODE_DISC_RESP
	uint8_t *send_buffer = (uint8_t *)&cmd_resp->data;
	_FILL_IOT_HEADER_
    22e6:	235a      	movs	r3, #90	; 0x5a
    22e8:	70ab      	strb	r3, [r5, #2]
    22ea:	3b4d      	subs	r3, #77	; 0x4d
    22ec:	70eb      	strb	r3, [r5, #3]
    22ee:	2300      	movs	r3, #0
    22f0:	712b      	strb	r3, [r5, #4]
    22f2:	2281      	movs	r2, #129	; 0x81
    22f4:	71aa      	strb	r2, [r5, #6]
    22f6:	71eb      	strb	r3, [r5, #7]
    22f8:	722b      	strb	r3, [r5, #8]
    22fa:	726b      	strb	r3, [r5, #9]
    22fc:	72ab      	strb	r3, [r5, #10]
	memcpy(&send_buffer[HEADER_LEN + PROV_RESP_PARAM_OFFSET], \
    22fe:	0028      	movs	r0, r5
    2300:	300b      	adds	r0, #11
    2302:	3a7a      	subs	r2, #122	; 0x7a
    2304:	4939      	ldr	r1, [pc, #228]	; (23ec <parse_iot_cmd+0x224>)
    2306:	4b2c      	ldr	r3, [pc, #176]	; (23b8 <parse_iot_cmd+0x1f0>)
    2308:	4798      	blx	r3
	PROV_RESP_PARAM, PROV_RESP_PARAM_LEN);
	_FILL_IOT_FRAME_LENGTH_
    230a:	2310      	movs	r3, #16
    230c:	802b      	strh	r3, [r5, #0]
					if (((authtype <= M2M_WIFI_SEC_802_1X && authtype > M2M_WIFI_SEC_OPEN && pswlength) ||
					(authtype == M2M_WIFI_SEC_OPEN && pswlength == 0)) && ssidlength){
						gAuthType = authtype;
						printf("wifi_provision_resp\r\n");
						wifi_provision_resp(cmd_resp);
						prov_state = PROV_CONFIG;
    230e:	2202      	movs	r2, #2
    2310:	4b26      	ldr	r3, [pc, #152]	; (23ac <parse_iot_cmd+0x1e4>)
    2312:	701a      	strb	r2, [r3, #0]
    2314:	e039      	b.n	238a <parse_iot_cmd+0x1c2>
					}
					else {
						// invalid wifi auth type / ssid length / psw length
						prov_state = PROV_INIT;
    2316:	2201      	movs	r2, #1
    2318:	4b24      	ldr	r3, [pc, #144]	; (23ac <parse_iot_cmd+0x1e4>)
    231a:	701a      	strb	r2, [r3, #0]
    231c:	e035      	b.n	238a <parse_iot_cmd+0x1c2>
						cmd_status_code = INVALID_VALUE;
					}
				}
				else {
					prov_state = PROV_INIT;
    231e:	2201      	movs	r2, #1
    2320:	4b22      	ldr	r3, [pc, #136]	; (23ac <parse_iot_cmd+0x1e4>)
    2322:	701a      	strb	r2, [r3, #0]
    2324:	e031      	b.n	238a <parse_iot_cmd+0x1c2>
					cmd_status_code = PROV_BUSY_ERR;
				}
			}
			else if (memcmp(cmd_param, PROVDONE_PARAM_HDR, PROVDONE_PARAM_HDR_LEN) == 0) {
    2326:	2207      	movs	r2, #7
    2328:	4931      	ldr	r1, [pc, #196]	; (23f0 <parse_iot_cmd+0x228>)
    232a:	0020      	movs	r0, r4
    232c:	4b1d      	ldr	r3, [pc, #116]	; (23a4 <parse_iot_cmd+0x1dc>)
    232e:	4798      	blx	r3
    2330:	2800      	cmp	r0, #0
    2332:	d122      	bne.n	237a <parse_iot_cmd+0x1b2>
				if (prov_state == PROV_CONFIG) {
    2334:	4b1d      	ldr	r3, [pc, #116]	; (23ac <parse_iot_cmd+0x1e4>)
    2336:	781b      	ldrb	r3, [r3, #0]
    2338:	2b02      	cmp	r3, #2
    233a:	d11a      	bne.n	2372 <parse_iot_cmd+0x1aa>
	#endif
	#define PARAM_LEN   PROV_RESP_PARAM_LEN
	#define HEADER_LEN  PROV_RESP_HDR_LEN
	#define CMD_ID      WIFI_NODE_DISC_RESP
	uint8_t *send_buffer = (uint8_t *)&cmd_resp->data;
	_FILL_IOT_HEADER_
    233c:	3358      	adds	r3, #88	; 0x58
    233e:	70ab      	strb	r3, [r5, #2]
    2340:	3b4d      	subs	r3, #77	; 0x4d
    2342:	70eb      	strb	r3, [r5, #3]
    2344:	2300      	movs	r3, #0
    2346:	712b      	strb	r3, [r5, #4]
    2348:	2281      	movs	r2, #129	; 0x81
    234a:	71aa      	strb	r2, [r5, #6]
    234c:	71eb      	strb	r3, [r5, #7]
    234e:	722b      	strb	r3, [r5, #8]
    2350:	726b      	strb	r3, [r5, #9]
    2352:	72ab      	strb	r3, [r5, #10]
	memcpy(&send_buffer[HEADER_LEN + PROV_RESP_PARAM_OFFSET], \
    2354:	0028      	movs	r0, r5
    2356:	300b      	adds	r0, #11
    2358:	3a7a      	subs	r2, #122	; 0x7a
    235a:	4924      	ldr	r1, [pc, #144]	; (23ec <parse_iot_cmd+0x224>)
    235c:	4b16      	ldr	r3, [pc, #88]	; (23b8 <parse_iot_cmd+0x1f0>)
    235e:	4798      	blx	r3
	PROV_RESP_PARAM, PROV_RESP_PARAM_LEN);
	_FILL_IOT_FRAME_LENGTH_
    2360:	2310      	movs	r3, #16
    2362:	802b      	strh	r3, [r5, #0]
				}
			}
			else if (memcmp(cmd_param, PROVDONE_PARAM_HDR, PROVDONE_PARAM_HDR_LEN) == 0) {
				if (prov_state == PROV_CONFIG) {
					wifi_provision_resp(cmd_resp);
					prov_state = PROV_DONE;
    2364:	2203      	movs	r2, #3
    2366:	4b11      	ldr	r3, [pc, #68]	; (23ac <parse_iot_cmd+0x1e4>)
    2368:	701a      	strb	r2, [r3, #0]
					printf("prov_state = PROV_DONE\r\n");
    236a:	4822      	ldr	r0, [pc, #136]	; (23f4 <parse_iot_cmd+0x22c>)
    236c:	4b0b      	ldr	r3, [pc, #44]	; (239c <parse_iot_cmd+0x1d4>)
    236e:	4798      	blx	r3
    2370:	e00b      	b.n	238a <parse_iot_cmd+0x1c2>
				}
				else {
					prov_state = PROV_INIT;
    2372:	2201      	movs	r2, #1
    2374:	4b0d      	ldr	r3, [pc, #52]	; (23ac <parse_iot_cmd+0x1e4>)
    2376:	701a      	strb	r2, [r3, #0]
    2378:	e007      	b.n	238a <parse_iot_cmd+0x1c2>
					cmd_status_code = PROV_BUSY_ERR;
				}
			}
			else {
				prov_state = PROV_INIT;
    237a:	2201      	movs	r2, #1
    237c:	4b0b      	ldr	r3, [pc, #44]	; (23ac <parse_iot_cmd+0x1e4>)
    237e:	701a      	strb	r2, [r3, #0]
				cmd_status_code = INVALID_VALUE;
			}
		}
		break;
	}
	return;
    2380:	e003      	b.n	238a <parse_iot_cmd+0x1c2>
					
					printf("gDefaultSSID=%s\r\n", gDefaultSSID);
					printf("gDefaultKey=%s\r\n", gDefaultKey);
					printf("authtype=%d\r\n", authtype);
					printf("gUuid=%s\r\n", gUuid);
					if (((authtype <= M2M_WIFI_SEC_802_1X && authtype > M2M_WIFI_SEC_OPEN && pswlength) ||
    2382:	4643      	mov	r3, r8
    2384:	2b01      	cmp	r3, #1
    2386:	d1c6      	bne.n	2316 <parse_iot_cmd+0x14e>
    2388:	e7a5      	b.n	22d6 <parse_iot_cmd+0x10e>
			}
		}
		break;
	}
	return;
}
    238a:	bc3c      	pop	{r2, r3, r4, r5}
    238c:	4690      	mov	r8, r2
    238e:	4699      	mov	r9, r3
    2390:	46a2      	mov	sl, r4
    2392:	46ab      	mov	fp, r5
    2394:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2396:	46c0      	nop			; (mov r8, r8)
    2398:	00013668 	.word	0x00013668
    239c:	00011aad 	.word	0x00011aad
    23a0:	00013684 	.word	0x00013684
    23a4:	00011815 	.word	0x00011815
    23a8:	0001369c 	.word	0x0001369c
    23ac:	200001f6 	.word	0x200001f6
    23b0:	000136c4 	.word	0x000136c4
    23b4:	20002228 	.word	0x20002228
    23b8:	00011833 	.word	0x00011833
    23bc:	000136e8 	.word	0x000136e8
    23c0:	000136f0 	.word	0x000136f0
    23c4:	200008a4 	.word	0x200008a4
    23c8:	200001f8 	.word	0x200001f8
    23cc:	20000868 	.word	0x20000868
    23d0:	0001371c 	.word	0x0001371c
    23d4:	0001198d 	.word	0x0001198d
    23d8:	00013730 	.word	0x00013730
    23dc:	00013744 	.word	0x00013744
    23e0:	00013754 	.word	0x00013754
    23e4:	200002e8 	.word	0x200002e8
    23e8:	00013760 	.word	0x00013760
    23ec:	00013778 	.word	0x00013778
    23f0:	00013780 	.word	0x00013780
    23f4:	00013788 	.word	0x00013788

000023f8 <iot_message_get_info_count>:
#include "main.h"

extern uint8 gUuid[AWS_COGNITO_UUID_LEN];

int iot_message_get_info_count(char* json_msg)
{
    23f8:	b570      	push	{r4, r5, r6, lr}
	cJSON *json;
	cJSON *json_command;
	cJSON *json_info_array;
	int info_cnt;
	
	json=cJSON_Parse(json_msg);
    23fa:	4b13      	ldr	r3, [pc, #76]	; (2448 <iot_message_get_info_count+0x50>)
    23fc:	4798      	blx	r3
    23fe:	1e04      	subs	r4, r0, #0
		
	if (!json) {
    2400:	d107      	bne.n	2412 <iot_message_get_info_count+0x1a>
		printf("Error when decode json: [%s]\n",cJSON_GetErrorPtr());
    2402:	4b12      	ldr	r3, [pc, #72]	; (244c <iot_message_get_info_count+0x54>)
    2404:	4798      	blx	r3
    2406:	0001      	movs	r1, r0
    2408:	4811      	ldr	r0, [pc, #68]	; (2450 <iot_message_get_info_count+0x58>)
    240a:	4b12      	ldr	r3, [pc, #72]	; (2454 <iot_message_get_info_count+0x5c>)
    240c:	4798      	blx	r3
		return 0;
    240e:	2000      	movs	r0, #0
    2410:	e019      	b.n	2446 <iot_message_get_info_count+0x4e>
	}
	

	json_command = cJSON_GetObjectItem(json,ATTR_COMMAND_NAME);
    2412:	4911      	ldr	r1, [pc, #68]	; (2458 <iot_message_get_info_count+0x60>)
    2414:	4b11      	ldr	r3, [pc, #68]	; (245c <iot_message_get_info_count+0x64>)
    2416:	4798      	blx	r3
    2418:	0005      	movs	r5, r0
	printf("DBG command = %s\n", json_command->valuestring);
    241a:	6901      	ldr	r1, [r0, #16]
    241c:	4810      	ldr	r0, [pc, #64]	; (2460 <iot_message_get_info_count+0x68>)
    241e:	4b0d      	ldr	r3, [pc, #52]	; (2454 <iot_message_get_info_count+0x5c>)
    2420:	4798      	blx	r3
	
	if (0 == strcmp(json_command->valuestring,CMD_UPDATE))
    2422:	6928      	ldr	r0, [r5, #16]
    2424:	490f      	ldr	r1, [pc, #60]	; (2464 <iot_message_get_info_count+0x6c>)
    2426:	4b10      	ldr	r3, [pc, #64]	; (2468 <iot_message_get_info_count+0x70>)
    2428:	4798      	blx	r3
		json_info_array = cJSON_GetObjectItem(json,ATTR_INFO_NAME);
		info_cnt = cJSON_GetArraySize(json_info_array);
		
	}
	else 
		info_cnt = 0;
    242a:	2500      	movs	r5, #0
	

	json_command = cJSON_GetObjectItem(json,ATTR_COMMAND_NAME);
	printf("DBG command = %s\n", json_command->valuestring);
	
	if (0 == strcmp(json_command->valuestring,CMD_UPDATE))
    242c:	2800      	cmp	r0, #0
    242e:	d106      	bne.n	243e <iot_message_get_info_count+0x46>
	{
		json_info_array = cJSON_GetObjectItem(json,ATTR_INFO_NAME);
    2430:	490e      	ldr	r1, [pc, #56]	; (246c <iot_message_get_info_count+0x74>)
    2432:	0020      	movs	r0, r4
    2434:	4b09      	ldr	r3, [pc, #36]	; (245c <iot_message_get_info_count+0x64>)
    2436:	4798      	blx	r3
		info_cnt = cJSON_GetArraySize(json_info_array);
    2438:	4b0d      	ldr	r3, [pc, #52]	; (2470 <iot_message_get_info_count+0x78>)
    243a:	4798      	blx	r3
    243c:	0005      	movs	r5, r0
		
	}
	else 
		info_cnt = 0;
	
	cJSON_Delete(json);	
    243e:	0020      	movs	r0, r4
    2440:	4b0c      	ldr	r3, [pc, #48]	; (2474 <iot_message_get_info_count+0x7c>)
    2442:	4798      	blx	r3
	
	return info_cnt;
    2444:	0028      	movs	r0, r5
}
    2446:	bd70      	pop	{r4, r5, r6, pc}
    2448:	00001b2d 	.word	0x00001b2d
    244c:	00001a4d 	.word	0x00001a4d
    2450:	000137a0 	.word	0x000137a0
    2454:	0001198d 	.word	0x0001198d
    2458:	000137c0 	.word	0x000137c0
    245c:	00001b81 	.word	0x00001b81
    2460:	000137c8 	.word	0x000137c8
    2464:	000137dc 	.word	0x000137dc
    2468:	00011d51 	.word	0x00011d51
    246c:	000137e4 	.word	0x000137e4
    2470:	00001b51 	.word	0x00001b51
    2474:	00001a59 	.word	0x00001a59

00002478 <iot_message_parser_info_data>:


Iot_Message_RC iot_message_parser_info_data(char* json_msg, int array_idx, char* dataType, int* value)
{
    2478:	b5f0      	push	{r4, r5, r6, r7, lr}
    247a:	b083      	sub	sp, #12
    247c:	000d      	movs	r5, r1
    247e:	9200      	str	r2, [sp, #0]
    2480:	001e      	movs	r6, r3
	cJSON *json_info;
	cJSON *json_data_type;
	
	Iot_Message_RC ret;
	
	json=cJSON_Parse(json_msg);
    2482:	4b23      	ldr	r3, [pc, #140]	; (2510 <iot_message_parser_info_data+0x98>)
    2484:	4798      	blx	r3
    2486:	1e04      	subs	r4, r0, #0
	
	if (!json) {
    2488:	d107      	bne.n	249a <iot_message_parser_info_data+0x22>
		printf("Error when decode json: [%s]\n",cJSON_GetErrorPtr());
    248a:	4b22      	ldr	r3, [pc, #136]	; (2514 <iot_message_parser_info_data+0x9c>)
    248c:	4798      	blx	r3
    248e:	0001      	movs	r1, r0
    2490:	4821      	ldr	r0, [pc, #132]	; (2518 <iot_message_parser_info_data+0xa0>)
    2492:	4b22      	ldr	r3, [pc, #136]	; (251c <iot_message_parser_info_data+0xa4>)
    2494:	4798      	blx	r3
		return IOT_MSG_RC_DECODE_FAIL;
    2496:	2002      	movs	r0, #2
    2498:	e037      	b.n	250a <iot_message_parser_info_data+0x92>
	}
	

	json_command = cJSON_GetObjectItem(json,ATTR_COMMAND_NAME);
    249a:	4921      	ldr	r1, [pc, #132]	; (2520 <iot_message_parser_info_data+0xa8>)
    249c:	4b21      	ldr	r3, [pc, #132]	; (2524 <iot_message_parser_info_data+0xac>)
    249e:	4798      	blx	r3
    24a0:	0007      	movs	r7, r0
	printf("DBG command = %s\n", json_command->valuestring);
    24a2:	6901      	ldr	r1, [r0, #16]
    24a4:	4820      	ldr	r0, [pc, #128]	; (2528 <iot_message_parser_info_data+0xb0>)
    24a6:	4b1d      	ldr	r3, [pc, #116]	; (251c <iot_message_parser_info_data+0xa4>)
    24a8:	4798      	blx	r3
	
	if (0 == strcmp(json_command->valuestring,CMD_UPDATE))
    24aa:	6938      	ldr	r0, [r7, #16]
    24ac:	491f      	ldr	r1, [pc, #124]	; (252c <iot_message_parser_info_data+0xb4>)
    24ae:	4b20      	ldr	r3, [pc, #128]	; (2530 <iot_message_parser_info_data+0xb8>)
    24b0:	4798      	blx	r3
    24b2:	2800      	cmp	r0, #0
    24b4:	d124      	bne.n	2500 <iot_message_parser_info_data+0x88>
	{
		json_info_array = cJSON_GetObjectItem(json,ATTR_INFO_NAME);
    24b6:	491f      	ldr	r1, [pc, #124]	; (2534 <iot_message_parser_info_data+0xbc>)
    24b8:	0020      	movs	r0, r4
    24ba:	4b1a      	ldr	r3, [pc, #104]	; (2524 <iot_message_parser_info_data+0xac>)
    24bc:	4798      	blx	r3
    24be:	0007      	movs	r7, r0
		int j = cJSON_GetArraySize(json_info_array);
    24c0:	4b1d      	ldr	r3, [pc, #116]	; (2538 <iot_message_parser_info_data+0xc0>)
    24c2:	4798      	blx	r3
		if (array_idx >= j)
    24c4:	42a8      	cmp	r0, r5
    24c6:	dc04      	bgt.n	24d2 <iot_message_parser_info_data+0x5a>
		{
			cJSON_Delete(json);
    24c8:	0020      	movs	r0, r4
    24ca:	4b1c      	ldr	r3, [pc, #112]	; (253c <iot_message_parser_info_data+0xc4>)
    24cc:	4798      	blx	r3
			return IOT_MSG_RC_FAIL;
    24ce:	2001      	movs	r0, #1
    24d0:	e01b      	b.n	250a <iot_message_parser_info_data+0x92>
		}
		json_info = cJSON_GetArrayItem(json_info_array, array_idx);
    24d2:	0029      	movs	r1, r5
    24d4:	0038      	movs	r0, r7
    24d6:	4b1a      	ldr	r3, [pc, #104]	; (2540 <iot_message_parser_info_data+0xc8>)
    24d8:	4798      	blx	r3
		json_data_type = cJSON_GetObjectItem(json_info, ATTR_DATATYPE_NAME);
    24da:	491a      	ldr	r1, [pc, #104]	; (2544 <iot_message_parser_info_data+0xcc>)
    24dc:	9001      	str	r0, [sp, #4]
    24de:	4f11      	ldr	r7, [pc, #68]	; (2524 <iot_message_parser_info_data+0xac>)
    24e0:	47b8      	blx	r7
    24e2:	0005      	movs	r5, r0
		//json_data_value = cJSON_GetObjectItem(json_info, ATTR_VALUE_NAME);
		//int data_value = cJSON_GetObjectItem(json_info, ATTR_VALUE_NAME)->valueint;
		*value = cJSON_GetObjectItem(json_info, ATTR_VALUE_NAME)->valueint;
    24e4:	4918      	ldr	r1, [pc, #96]	; (2548 <iot_message_parser_info_data+0xd0>)
    24e6:	9801      	ldr	r0, [sp, #4]
    24e8:	47b8      	blx	r7
    24ea:	6941      	ldr	r1, [r0, #20]
    24ec:	6031      	str	r1, [r6, #0]
		printf("DBG temp = %d\r\n", *value);
    24ee:	4817      	ldr	r0, [pc, #92]	; (254c <iot_message_parser_info_data+0xd4>)
    24f0:	4b0a      	ldr	r3, [pc, #40]	; (251c <iot_message_parser_info_data+0xa4>)
    24f2:	4798      	blx	r3
		
		strcpy(dataType, json_data_type->valuestring);
    24f4:	6929      	ldr	r1, [r5, #16]
    24f6:	9800      	ldr	r0, [sp, #0]
    24f8:	4b15      	ldr	r3, [pc, #84]	; (2550 <iot_message_parser_info_data+0xd8>)
    24fa:	4798      	blx	r3
		ret = IOT_MSG_RC_SUCCESS;
    24fc:	2500      	movs	r5, #0
    24fe:	e000      	b.n	2502 <iot_message_parser_info_data+0x8a>
	}
	else
		ret = IOT_MSG_RC_DECODE_FAIL;
    2500:	2502      	movs	r5, #2
	
	cJSON_Delete(json);
    2502:	0020      	movs	r0, r4
    2504:	4b0d      	ldr	r3, [pc, #52]	; (253c <iot_message_parser_info_data+0xc4>)
    2506:	4798      	blx	r3
	
	return ret;
    2508:	0028      	movs	r0, r5
	
}
    250a:	b003      	add	sp, #12
    250c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    250e:	46c0      	nop			; (mov r8, r8)
    2510:	00001b2d 	.word	0x00001b2d
    2514:	00001a4d 	.word	0x00001a4d
    2518:	000137a0 	.word	0x000137a0
    251c:	0001198d 	.word	0x0001198d
    2520:	000137c0 	.word	0x000137c0
    2524:	00001b81 	.word	0x00001b81
    2528:	000137c8 	.word	0x000137c8
    252c:	000137dc 	.word	0x000137dc
    2530:	00011d51 	.word	0x00011d51
    2534:	000137e4 	.word	0x000137e4
    2538:	00001b51 	.word	0x00001b51
    253c:	00001a59 	.word	0x00001a59
    2540:	00001b69 	.word	0x00001b69
    2544:	000137ec 	.word	0x000137ec
    2548:	000137f8 	.word	0x000137f8
    254c:	00013800 	.word	0x00013800
    2550:	00011d65 	.word	0x00011d65

00002554 <iot_message_parser_cmd_type>:
	
	return IOT_MSG_RC_SUCCESS;
}

Iot_Msg_Command iot_message_parser_cmd_type(char* json_msg)
{
    2554:	b570      	push	{r4, r5, r6, lr}
	cJSON *json;
	cJSON *json_command, *json_subcommand;
	Iot_Msg_Command cmd;
	
	json=cJSON_Parse(json_msg);
    2556:	4b32      	ldr	r3, [pc, #200]	; (2620 <iot_message_parser_cmd_type+0xcc>)
    2558:	4798      	blx	r3
    255a:	1e05      	subs	r5, r0, #0
	
	if (!json) {
    255c:	d107      	bne.n	256e <iot_message_parser_cmd_type+0x1a>
		printf("Error when decode json: [%s]\n",cJSON_GetErrorPtr());
    255e:	4b31      	ldr	r3, [pc, #196]	; (2624 <iot_message_parser_cmd_type+0xd0>)
    2560:	4798      	blx	r3
    2562:	0001      	movs	r1, r0
    2564:	4830      	ldr	r0, [pc, #192]	; (2628 <iot_message_parser_cmd_type+0xd4>)
    2566:	4b31      	ldr	r3, [pc, #196]	; (262c <iot_message_parser_cmd_type+0xd8>)
    2568:	4798      	blx	r3
		return MSG_CMD_UNKNOWN;
    256a:	2009      	movs	r0, #9
    256c:	e057      	b.n	261e <iot_message_parser_cmd_type+0xca>
	}
	
	json_command = cJSON_GetObjectItem(json,ATTR_COMMAND_NAME);
    256e:	4930      	ldr	r1, [pc, #192]	; (2630 <iot_message_parser_cmd_type+0xdc>)
    2570:	4b30      	ldr	r3, [pc, #192]	; (2634 <iot_message_parser_cmd_type+0xe0>)
    2572:	4798      	blx	r3
    2574:	0004      	movs	r4, r0
	printf("DBG command = %s\n", json_command->valuestring);
    2576:	6901      	ldr	r1, [r0, #16]
    2578:	482f      	ldr	r0, [pc, #188]	; (2638 <iot_message_parser_cmd_type+0xe4>)
    257a:	4b2c      	ldr	r3, [pc, #176]	; (262c <iot_message_parser_cmd_type+0xd8>)
    257c:	4798      	blx	r3
	
	
	if (0 == strcmp(json_command->valuestring,CMD_UPDATE))
    257e:	6926      	ldr	r6, [r4, #16]
    2580:	492e      	ldr	r1, [pc, #184]	; (263c <iot_message_parser_cmd_type+0xe8>)
    2582:	0030      	movs	r0, r6
    2584:	4b2e      	ldr	r3, [pc, #184]	; (2640 <iot_message_parser_cmd_type+0xec>)
    2586:	4798      	blx	r3
		cmd = MSG_CMD_UPDATE;
    2588:	2402      	movs	r4, #2
	
	json_command = cJSON_GetObjectItem(json,ATTR_COMMAND_NAME);
	printf("DBG command = %s\n", json_command->valuestring);
	
	
	if (0 == strcmp(json_command->valuestring,CMD_UPDATE))
    258a:	2800      	cmp	r0, #0
    258c:	d043      	beq.n	2616 <iot_message_parser_cmd_type+0xc2>
		cmd = MSG_CMD_UPDATE;
	else if (0 == strcmp(json_command->valuestring,CMD_SEARCH))
    258e:	492d      	ldr	r1, [pc, #180]	; (2644 <iot_message_parser_cmd_type+0xf0>)
    2590:	0030      	movs	r0, r6
    2592:	4b2b      	ldr	r3, [pc, #172]	; (2640 <iot_message_parser_cmd_type+0xec>)
    2594:	4798      	blx	r3
		cmd = MSG_CMD_SEARCH;	
    2596:	2400      	movs	r4, #0
	printf("DBG command = %s\n", json_command->valuestring);
	
	
	if (0 == strcmp(json_command->valuestring,CMD_UPDATE))
		cmd = MSG_CMD_UPDATE;
	else if (0 == strcmp(json_command->valuestring,CMD_SEARCH))
    2598:	2800      	cmp	r0, #0
    259a:	d03c      	beq.n	2616 <iot_message_parser_cmd_type+0xc2>
		cmd = MSG_CMD_SEARCH;	
	else if (0 == strcmp(json_command->valuestring,CMD_GET))
    259c:	492a      	ldr	r1, [pc, #168]	; (2648 <iot_message_parser_cmd_type+0xf4>)
    259e:	0030      	movs	r0, r6
    25a0:	4b27      	ldr	r3, [pc, #156]	; (2640 <iot_message_parser_cmd_type+0xec>)
    25a2:	4798      	blx	r3
		cmd = MSG_CMD_GET;
    25a4:	3401      	adds	r4, #1
	
	if (0 == strcmp(json_command->valuestring,CMD_UPDATE))
		cmd = MSG_CMD_UPDATE;
	else if (0 == strcmp(json_command->valuestring,CMD_SEARCH))
		cmd = MSG_CMD_SEARCH;	
	else if (0 == strcmp(json_command->valuestring,CMD_GET))
    25a6:	2800      	cmp	r0, #0
    25a8:	d035      	beq.n	2616 <iot_message_parser_cmd_type+0xc2>
		cmd = MSG_CMD_GET;
	else if (0 == strcmp(json_command->valuestring,CMD_SEARCHRESP))
    25aa:	4928      	ldr	r1, [pc, #160]	; (264c <iot_message_parser_cmd_type+0xf8>)
    25ac:	0030      	movs	r0, r6
    25ae:	4b24      	ldr	r3, [pc, #144]	; (2640 <iot_message_parser_cmd_type+0xec>)
    25b0:	4798      	blx	r3
		cmd = MSG_CMD_SEARCHRESP;
    25b2:	3402      	adds	r4, #2
		cmd = MSG_CMD_UPDATE;
	else if (0 == strcmp(json_command->valuestring,CMD_SEARCH))
		cmd = MSG_CMD_SEARCH;	
	else if (0 == strcmp(json_command->valuestring,CMD_GET))
		cmd = MSG_CMD_GET;
	else if (0 == strcmp(json_command->valuestring,CMD_SEARCHRESP))
    25b4:	2800      	cmp	r0, #0
    25b6:	d02e      	beq.n	2616 <iot_message_parser_cmd_type+0xc2>
		cmd = MSG_CMD_SEARCHRESP;
	else if (0 == strcmp(json_command->valuestring,CMD_REPORTALLINFO))
    25b8:	4925      	ldr	r1, [pc, #148]	; (2650 <iot_message_parser_cmd_type+0xfc>)
    25ba:	0030      	movs	r0, r6
    25bc:	4b20      	ldr	r3, [pc, #128]	; (2640 <iot_message_parser_cmd_type+0xec>)
    25be:	4798      	blx	r3
		cmd = MSG_CMD_REPORTALLINFO;
    25c0:	3401      	adds	r4, #1
		cmd = MSG_CMD_SEARCH;	
	else if (0 == strcmp(json_command->valuestring,CMD_GET))
		cmd = MSG_CMD_GET;
	else if (0 == strcmp(json_command->valuestring,CMD_SEARCHRESP))
		cmd = MSG_CMD_SEARCHRESP;
	else if (0 == strcmp(json_command->valuestring,CMD_REPORTALLINFO))
    25c2:	2800      	cmp	r0, #0
    25c4:	d027      	beq.n	2616 <iot_message_parser_cmd_type+0xc2>
		cmd = MSG_CMD_REPORTALLINFO;
	else if (0 == strcmp(json_command->valuestring,CMD_REPORTINFO))
    25c6:	4923      	ldr	r1, [pc, #140]	; (2654 <iot_message_parser_cmd_type+0x100>)
    25c8:	0030      	movs	r0, r6
    25ca:	4b1d      	ldr	r3, [pc, #116]	; (2640 <iot_message_parser_cmd_type+0xec>)
    25cc:	4798      	blx	r3
		cmd = MSG_CMD_REPORTINFO;
    25ce:	2400      	movs	r4, #0
		cmd = MSG_CMD_GET;
	else if (0 == strcmp(json_command->valuestring,CMD_SEARCHRESP))
		cmd = MSG_CMD_SEARCHRESP;
	else if (0 == strcmp(json_command->valuestring,CMD_REPORTALLINFO))
		cmd = MSG_CMD_REPORTALLINFO;
	else if (0 == strcmp(json_command->valuestring,CMD_REPORTINFO))
    25d0:	2800      	cmp	r0, #0
    25d2:	d020      	beq.n	2616 <iot_message_parser_cmd_type+0xc2>
		cmd = MSG_CMD_REPORTINFO;
	else if (0 == strcmp(json_command->valuestring,CMD_REPORTDISCONNECT))	
    25d4:	4920      	ldr	r1, [pc, #128]	; (2658 <iot_message_parser_cmd_type+0x104>)
    25d6:	0030      	movs	r0, r6
    25d8:	4b19      	ldr	r3, [pc, #100]	; (2640 <iot_message_parser_cmd_type+0xec>)
    25da:	4798      	blx	r3
		cmd = MSG_CMD_REPORTDISCONNECT;
    25dc:	3405      	adds	r4, #5
		cmd = MSG_CMD_SEARCHRESP;
	else if (0 == strcmp(json_command->valuestring,CMD_REPORTALLINFO))
		cmd = MSG_CMD_REPORTALLINFO;
	else if (0 == strcmp(json_command->valuestring,CMD_REPORTINFO))
		cmd = MSG_CMD_REPORTINFO;
	else if (0 == strcmp(json_command->valuestring,CMD_REPORTDISCONNECT))	
    25de:	2800      	cmp	r0, #0
    25e0:	d019      	beq.n	2616 <iot_message_parser_cmd_type+0xc2>
		cmd = MSG_CMD_REPORTDISCONNECT;
	else if (0 == strcmp(json_command->valuestring,CMD_CONTROL))
    25e2:	491e      	ldr	r1, [pc, #120]	; (265c <iot_message_parser_cmd_type+0x108>)
    25e4:	0030      	movs	r0, r6
    25e6:	4b16      	ldr	r3, [pc, #88]	; (2640 <iot_message_parser_cmd_type+0xec>)
    25e8:	4798      	blx	r3
			cmd = MSG_SUBCMD_ADDNODE;
		else if (0 == strcmp(json_subcommand->valuestring,CMD_GET_3D_PLOT_DATA))
			cmd = MSG_SUBCMD_GET_3D_PLOT_DATA;
	}
	else 
		cmd = MSG_CMD_UNKNOWN;
    25ea:	3404      	adds	r4, #4
		cmd = MSG_CMD_REPORTALLINFO;
	else if (0 == strcmp(json_command->valuestring,CMD_REPORTINFO))
		cmd = MSG_CMD_REPORTINFO;
	else if (0 == strcmp(json_command->valuestring,CMD_REPORTDISCONNECT))	
		cmd = MSG_CMD_REPORTDISCONNECT;
	else if (0 == strcmp(json_command->valuestring,CMD_CONTROL))
    25ec:	2800      	cmp	r0, #0
    25ee:	d112      	bne.n	2616 <iot_message_parser_cmd_type+0xc2>
	{
		json_subcommand = cJSON_GetObjectItem(json,ATTR_SUBCOMMAND_NAME);
    25f0:	491b      	ldr	r1, [pc, #108]	; (2660 <iot_message_parser_cmd_type+0x10c>)
    25f2:	0028      	movs	r0, r5
    25f4:	4b0f      	ldr	r3, [pc, #60]	; (2634 <iot_message_parser_cmd_type+0xe0>)
    25f6:	4798      	blx	r3
		if (0 == strcmp(json_subcommand->valuestring,CMD_ADD_NODE))
    25f8:	6906      	ldr	r6, [r0, #16]
    25fa:	491a      	ldr	r1, [pc, #104]	; (2664 <iot_message_parser_cmd_type+0x110>)
    25fc:	0030      	movs	r0, r6
    25fe:	4b10      	ldr	r3, [pc, #64]	; (2640 <iot_message_parser_cmd_type+0xec>)
    2600:	4798      	blx	r3
			cmd = MSG_SUBCMD_ADDNODE;
    2602:	3c02      	subs	r4, #2
	else if (0 == strcmp(json_command->valuestring,CMD_REPORTDISCONNECT))	
		cmd = MSG_CMD_REPORTDISCONNECT;
	else if (0 == strcmp(json_command->valuestring,CMD_CONTROL))
	{
		json_subcommand = cJSON_GetObjectItem(json,ATTR_SUBCOMMAND_NAME);
		if (0 == strcmp(json_subcommand->valuestring,CMD_ADD_NODE))
    2604:	2800      	cmp	r0, #0
    2606:	d006      	beq.n	2616 <iot_message_parser_cmd_type+0xc2>
			cmd = MSG_SUBCMD_ADDNODE;
		else if (0 == strcmp(json_subcommand->valuestring,CMD_GET_3D_PLOT_DATA))
    2608:	4917      	ldr	r1, [pc, #92]	; (2668 <iot_message_parser_cmd_type+0x114>)
    260a:	0030      	movs	r0, r6
    260c:	4b0c      	ldr	r3, [pc, #48]	; (2640 <iot_message_parser_cmd_type+0xec>)
    260e:	4798      	blx	r3
    2610:	2800      	cmp	r0, #0
    2612:	d100      	bne.n	2616 <iot_message_parser_cmd_type+0xc2>
			cmd = MSG_SUBCMD_GET_3D_PLOT_DATA;
    2614:	3401      	adds	r4, #1
	}
	else 
		cmd = MSG_CMD_UNKNOWN;
	
	cJSON_Delete(json);	
    2616:	0028      	movs	r0, r5
    2618:	4b14      	ldr	r3, [pc, #80]	; (266c <iot_message_parser_cmd_type+0x118>)
    261a:	4798      	blx	r3
	
	return cmd;
    261c:	0020      	movs	r0, r4
}		
    261e:	bd70      	pop	{r4, r5, r6, pc}
    2620:	00001b2d 	.word	0x00001b2d
    2624:	00001a4d 	.word	0x00001a4d
    2628:	000137a0 	.word	0x000137a0
    262c:	0001198d 	.word	0x0001198d
    2630:	000137c0 	.word	0x000137c0
    2634:	00001b81 	.word	0x00001b81
    2638:	000137c8 	.word	0x000137c8
    263c:	000137dc 	.word	0x000137dc
    2640:	00011d51 	.word	0x00011d51
    2644:	00013844 	.word	0x00013844
    2648:	0001384c 	.word	0x0001384c
    264c:	00013850 	.word	0x00013850
    2650:	0001385c 	.word	0x0001385c
    2654:	0001386c 	.word	0x0001386c
    2658:	00013878 	.word	0x00013878
    265c:	0001388c 	.word	0x0001388c
    2660:	00013894 	.word	0x00013894
    2664:	000138a0 	.word	0x000138a0
    2668:	000138a8 	.word	0x000138a8
    266c:	00001a59 	.word	0x00001a59

00002670 <iot_message_searchResp_with_temp_uv>:
	cJSON_Delete(json);	
	return 0;
}

cJSON* iot_message_searchResp_with_temp_uv(char* device_type, char* mac_addr, int temp, int uv )
{
    2670:	b5f0      	push	{r4, r5, r6, r7, lr}
    2672:	465f      	mov	r7, fp
    2674:	4656      	mov	r6, sl
    2676:	b4c0      	push	{r6, r7}
    2678:	b085      	sub	sp, #20
    267a:	0007      	movs	r7, r0
    267c:	000e      	movs	r6, r1
    267e:	9202      	str	r2, [sp, #8]
    2680:	9303      	str	r3, [sp, #12]
	cJSON *json2CloudData;
	cJSON *json2CloudNodeData;
	cJSON *json2CloudDataArray1;
	
	json2CloudData=cJSON_CreateObject();
    2682:	4b2f      	ldr	r3, [pc, #188]	; (2740 <iot_message_searchResp_with_temp_uv+0xd0>)
    2684:	4798      	blx	r3
    2686:	9000      	str	r0, [sp, #0]
	

	if(json2CloudData == NULL)
    2688:	2800      	cmp	r0, #0
    268a:	d103      	bne.n	2694 <iot_message_searchResp_with_temp_uv+0x24>
	{
		printf("json2CloudData malloc fail");
    268c:	482d      	ldr	r0, [pc, #180]	; (2744 <iot_message_searchResp_with_temp_uv+0xd4>)
    268e:	4b2e      	ldr	r3, [pc, #184]	; (2748 <iot_message_searchResp_with_temp_uv+0xd8>)
    2690:	4798      	blx	r3
    2692:	e7fe      	b.n	2692 <iot_message_searchResp_with_temp_uv+0x22>
		while(1);
	}
	
	cJSON_AddStringToObject(json2CloudData, ATTR_DEVNAME_NAME, DEVICE_NAME);
    2694:	482d      	ldr	r0, [pc, #180]	; (274c <iot_message_searchResp_with_temp_uv+0xdc>)
    2696:	4c2e      	ldr	r4, [pc, #184]	; (2750 <iot_message_searchResp_with_temp_uv+0xe0>)
    2698:	47a0      	blx	r4
    269a:	0002      	movs	r2, r0
    269c:	492d      	ldr	r1, [pc, #180]	; (2754 <iot_message_searchResp_with_temp_uv+0xe4>)
    269e:	9800      	ldr	r0, [sp, #0]
    26a0:	4d2d      	ldr	r5, [pc, #180]	; (2758 <iot_message_searchResp_with_temp_uv+0xe8>)
    26a2:	47a8      	blx	r5
	cJSON_AddStringToObject(json2CloudData, ATTR_COMMAND_NAME, CMD_SEARCHRESP);
    26a4:	482d      	ldr	r0, [pc, #180]	; (275c <iot_message_searchResp_with_temp_uv+0xec>)
    26a6:	47a0      	blx	r4
    26a8:	0002      	movs	r2, r0
    26aa:	492d      	ldr	r1, [pc, #180]	; (2760 <iot_message_searchResp_with_temp_uv+0xf0>)
    26ac:	9800      	ldr	r0, [sp, #0]
    26ae:	47a8      	blx	r5
	cJSON_AddStringToObject(json2CloudData, ATTR_DEVTYPE_NAME, device_type);
    26b0:	0038      	movs	r0, r7
    26b2:	47a0      	blx	r4
    26b4:	0002      	movs	r2, r0
    26b6:	492b      	ldr	r1, [pc, #172]	; (2764 <iot_message_searchResp_with_temp_uv+0xf4>)
    26b8:	9f00      	ldr	r7, [sp, #0]
    26ba:	0038      	movs	r0, r7
    26bc:	47a8      	blx	r5
	cJSON_AddStringToObject(json2CloudData, ATTR_MAC_ADDR_NAME, mac_addr);
    26be:	0030      	movs	r0, r6
    26c0:	47a0      	blx	r4
    26c2:	0002      	movs	r2, r0
    26c4:	4928      	ldr	r1, [pc, #160]	; (2768 <iot_message_searchResp_with_temp_uv+0xf8>)
    26c6:	9700      	str	r7, [sp, #0]
    26c8:	0038      	movs	r0, r7
    26ca:	47a8      	blx	r5
	
	json2CloudDataArray1=cJSON_CreateArray();
    26cc:	4b27      	ldr	r3, [pc, #156]	; (276c <iot_message_searchResp_with_temp_uv+0xfc>)
    26ce:	4798      	blx	r3
    26d0:	9001      	str	r0, [sp, #4]
	json2CloudNodeData=cJSON_CreateObject();
    26d2:	4b1b      	ldr	r3, [pc, #108]	; (2740 <iot_message_searchResp_with_temp_uv+0xd0>)
    26d4:	469b      	mov	fp, r3
    26d6:	4798      	blx	r3
    26d8:	0006      	movs	r6, r0
	
	cJSON_AddStringToObject(json2CloudNodeData, "dataType", TEMP_DATATYPE_NAME);
    26da:	4825      	ldr	r0, [pc, #148]	; (2770 <iot_message_searchResp_with_temp_uv+0x100>)
    26dc:	47a0      	blx	r4
    26de:	0002      	movs	r2, r0
    26e0:	4924      	ldr	r1, [pc, #144]	; (2774 <iot_message_searchResp_with_temp_uv+0x104>)
    26e2:	0030      	movs	r0, r6
    26e4:	47a8      	blx	r5
	cJSON_AddNumberToObject(json2CloudNodeData, "value", temp);
    26e6:	4b24      	ldr	r3, [pc, #144]	; (2778 <iot_message_searchResp_with_temp_uv+0x108>)
    26e8:	469a      	mov	sl, r3
    26ea:	9802      	ldr	r0, [sp, #8]
    26ec:	4798      	blx	r3
    26ee:	4f23      	ldr	r7, [pc, #140]	; (277c <iot_message_searchResp_with_temp_uv+0x10c>)
    26f0:	47b8      	blx	r7
    26f2:	0002      	movs	r2, r0
    26f4:	4922      	ldr	r1, [pc, #136]	; (2780 <iot_message_searchResp_with_temp_uv+0x110>)
    26f6:	0030      	movs	r0, r6
    26f8:	47a8      	blx	r5
	cJSON_AddItemToArray(json2CloudDataArray1, json2CloudNodeData);
    26fa:	0031      	movs	r1, r6
    26fc:	9801      	ldr	r0, [sp, #4]
    26fe:	4e21      	ldr	r6, [pc, #132]	; (2784 <iot_message_searchResp_with_temp_uv+0x114>)
    2700:	47b0      	blx	r6
	
	json2CloudNodeData=cJSON_CreateObject();
    2702:	47d8      	blx	fp
    2704:	9002      	str	r0, [sp, #8]
	cJSON_AddStringToObject(json2CloudNodeData, "dataType", UV_DATATYPE_NAME);
    2706:	4820      	ldr	r0, [pc, #128]	; (2788 <iot_message_searchResp_with_temp_uv+0x118>)
    2708:	47a0      	blx	r4
    270a:	0002      	movs	r2, r0
    270c:	4919      	ldr	r1, [pc, #100]	; (2774 <iot_message_searchResp_with_temp_uv+0x104>)
    270e:	9c02      	ldr	r4, [sp, #8]
    2710:	0020      	movs	r0, r4
    2712:	47a8      	blx	r5
	cJSON_AddNumberToObject(json2CloudNodeData, "value", uv);
    2714:	9803      	ldr	r0, [sp, #12]
    2716:	47d0      	blx	sl
    2718:	47b8      	blx	r7
    271a:	0002      	movs	r2, r0
    271c:	4918      	ldr	r1, [pc, #96]	; (2780 <iot_message_searchResp_with_temp_uv+0x110>)
    271e:	0020      	movs	r0, r4
    2720:	47a8      	blx	r5
	cJSON_AddItemToArray(json2CloudDataArray1, json2CloudNodeData);
    2722:	0021      	movs	r1, r4
    2724:	9c01      	ldr	r4, [sp, #4]
    2726:	0020      	movs	r0, r4
    2728:	47b0      	blx	r6
	
	cJSON_AddItemToObject(json2CloudData, "info", json2CloudDataArray1);
    272a:	0022      	movs	r2, r4
    272c:	4917      	ldr	r1, [pc, #92]	; (278c <iot_message_searchResp_with_temp_uv+0x11c>)
    272e:	9c00      	ldr	r4, [sp, #0]
    2730:	0020      	movs	r0, r4
    2732:	47a8      	blx	r5
	return json2CloudData;
}
    2734:	0020      	movs	r0, r4
    2736:	b005      	add	sp, #20
    2738:	bc0c      	pop	{r2, r3}
    273a:	4692      	mov	sl, r2
    273c:	469b      	mov	fp, r3
    273e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2740:	00001c69 	.word	0x00001c69
    2744:	000138f8 	.word	0x000138f8
    2748:	0001198d 	.word	0x0001198d
    274c:	00013914 	.word	0x00013914
    2750:	00001c31 	.word	0x00001c31
    2754:	00013920 	.word	0x00013920
    2758:	00001bd1 	.word	0x00001bd1
    275c:	00013850 	.word	0x00013850
    2760:	000137c0 	.word	0x000137c0
    2764:	00013928 	.word	0x00013928
    2768:	00013810 	.word	0x00013810
    276c:	00001c55 	.word	0x00001c55
    2770:	00013930 	.word	0x00013930
    2774:	000137ec 	.word	0x000137ec
    2778:	000116d5 	.word	0x000116d5
    277c:	00001c05 	.word	0x00001c05
    2780:	000137f8 	.word	0x000137f8
    2784:	00001ba9 	.word	0x00001ba9
    2788:	00013938 	.word	0x00013938
    278c:	000137e4 	.word	0x000137e4

00002790 <iot_message_reportAllInfo>:
	return json2CloudData;
}


cJSON* iot_message_reportAllInfo(char* device_type, char* mac_addr, int num_of_data, NodeInfo data[])
{
    2790:	b5f0      	push	{r4, r5, r6, r7, lr}
    2792:	465f      	mov	r7, fp
    2794:	4656      	mov	r6, sl
    2796:	464d      	mov	r5, r9
    2798:	4644      	mov	r4, r8
    279a:	b4f0      	push	{r4, r5, r6, r7}
    279c:	b085      	sub	sp, #20
    279e:	0007      	movs	r7, r0
    27a0:	9101      	str	r1, [sp, #4]
    27a2:	4691      	mov	r9, r2
    27a4:	9303      	str	r3, [sp, #12]
	cJSON *json2CloudData;
	cJSON *json2CloudNodeData;
	cJSON *json2CloudDataArray1;
	
	json2CloudData=cJSON_CreateObject();
    27a6:	4b30      	ldr	r3, [pc, #192]	; (2868 <iot_message_reportAllInfo+0xd8>)
    27a8:	4798      	blx	r3
    27aa:	0004      	movs	r4, r0
	//json2CloudNodeData=cJSON_CreateObject();
	json2CloudDataArray1=cJSON_CreateArray();
    27ac:	4b2f      	ldr	r3, [pc, #188]	; (286c <iot_message_reportAllInfo+0xdc>)
    27ae:	4798      	blx	r3
    27b0:	9002      	str	r0, [sp, #8]

	if((json2CloudData == NULL) || (json2CloudDataArray1 == NULL))
    27b2:	2c00      	cmp	r4, #0
    27b4:	d001      	beq.n	27ba <iot_message_reportAllInfo+0x2a>
    27b6:	2800      	cmp	r0, #0
    27b8:	d103      	bne.n	27c2 <iot_message_reportAllInfo+0x32>
	{
		printf("json2CloudData malloc fail");
    27ba:	482d      	ldr	r0, [pc, #180]	; (2870 <iot_message_reportAllInfo+0xe0>)
    27bc:	4b2d      	ldr	r3, [pc, #180]	; (2874 <iot_message_reportAllInfo+0xe4>)
    27be:	4798      	blx	r3
    27c0:	e7fe      	b.n	27c0 <iot_message_reportAllInfo+0x30>
		while(1);
	}
	
	cJSON_AddStringToObject(json2CloudData, ATTR_DEVNAME_NAME, DEVICE_NAME);
    27c2:	482d      	ldr	r0, [pc, #180]	; (2878 <iot_message_reportAllInfo+0xe8>)
    27c4:	4e2d      	ldr	r6, [pc, #180]	; (287c <iot_message_reportAllInfo+0xec>)
    27c6:	47b0      	blx	r6
    27c8:	0002      	movs	r2, r0
    27ca:	492d      	ldr	r1, [pc, #180]	; (2880 <iot_message_reportAllInfo+0xf0>)
    27cc:	0020      	movs	r0, r4
    27ce:	4d2d      	ldr	r5, [pc, #180]	; (2884 <iot_message_reportAllInfo+0xf4>)
    27d0:	47a8      	blx	r5
	cJSON_AddStringToObject(json2CloudData, ATTR_UUID_NAME, gUuid);
    27d2:	482d      	ldr	r0, [pc, #180]	; (2888 <iot_message_reportAllInfo+0xf8>)
    27d4:	47b0      	blx	r6
    27d6:	0002      	movs	r2, r0
    27d8:	492c      	ldr	r1, [pc, #176]	; (288c <iot_message_reportAllInfo+0xfc>)
    27da:	0020      	movs	r0, r4
    27dc:	47a8      	blx	r5
	cJSON_AddStringToObject(json2CloudData, ATTR_COMMAND_NAME, CMD_REPORTALLINFO);
    27de:	482c      	ldr	r0, [pc, #176]	; (2890 <iot_message_reportAllInfo+0x100>)
    27e0:	47b0      	blx	r6
    27e2:	0002      	movs	r2, r0
    27e4:	492b      	ldr	r1, [pc, #172]	; (2894 <iot_message_reportAllInfo+0x104>)
    27e6:	0020      	movs	r0, r4
    27e8:	47a8      	blx	r5
	cJSON_AddStringToObject(json2CloudData, ATTR_DEVTYPE_NAME, device_type);
    27ea:	0038      	movs	r0, r7
    27ec:	47b0      	blx	r6
    27ee:	0002      	movs	r2, r0
    27f0:	4929      	ldr	r1, [pc, #164]	; (2898 <iot_message_reportAllInfo+0x108>)
    27f2:	0020      	movs	r0, r4
    27f4:	47a8      	blx	r5
	cJSON_AddStringToObject(json2CloudData, ATTR_MAC_ADDR_NAME, mac_addr);
    27f6:	9801      	ldr	r0, [sp, #4]
    27f8:	47b0      	blx	r6
    27fa:	0002      	movs	r2, r0
    27fc:	4927      	ldr	r1, [pc, #156]	; (289c <iot_message_reportAllInfo+0x10c>)
    27fe:	0020      	movs	r0, r4
    2800:	47a8      	blx	r5

	for (int i=0; i<num_of_data; i++)
    2802:	464b      	mov	r3, r9
    2804:	2b00      	cmp	r3, #0
    2806:	dd21      	ble.n	284c <iot_message_reportAllInfo+0xbc>
    2808:	9d03      	ldr	r5, [sp, #12]
    280a:	2600      	movs	r6, #0
	{
		json2CloudNodeData=cJSON_CreateObject();
    280c:	4b16      	ldr	r3, [pc, #88]	; (2868 <iot_message_reportAllInfo+0xd8>)
    280e:	469b      	mov	fp, r3
		
		cJSON_AddStringToObject(json2CloudNodeData, "dataType", data[i].dataType);
    2810:	4f1a      	ldr	r7, [pc, #104]	; (287c <iot_message_reportAllInfo+0xec>)
    2812:	4b23      	ldr	r3, [pc, #140]	; (28a0 <iot_message_reportAllInfo+0x110>)
    2814:	4698      	mov	r8, r3
	cJSON_AddStringToObject(json2CloudData, ATTR_DEVTYPE_NAME, device_type);
	cJSON_AddStringToObject(json2CloudData, ATTR_MAC_ADDR_NAME, mac_addr);

	for (int i=0; i<num_of_data; i++)
	{
		json2CloudNodeData=cJSON_CreateObject();
    2816:	47d8      	blx	fp
    2818:	9001      	str	r0, [sp, #4]
		
		cJSON_AddStringToObject(json2CloudNodeData, "dataType", data[i].dataType);
    281a:	0028      	movs	r0, r5
    281c:	47b8      	blx	r7
    281e:	0002      	movs	r2, r0
    2820:	4641      	mov	r1, r8
    2822:	9801      	ldr	r0, [sp, #4]
    2824:	4b17      	ldr	r3, [pc, #92]	; (2884 <iot_message_reportAllInfo+0xf4>)
    2826:	469a      	mov	sl, r3
    2828:	4798      	blx	r3
		cJSON_AddNumberToObject(json2CloudNodeData, "value", data[i].value);
    282a:	6a28      	ldr	r0, [r5, #32]
    282c:	4b1d      	ldr	r3, [pc, #116]	; (28a4 <iot_message_reportAllInfo+0x114>)
    282e:	4798      	blx	r3
    2830:	4b1d      	ldr	r3, [pc, #116]	; (28a8 <iot_message_reportAllInfo+0x118>)
    2832:	4798      	blx	r3
    2834:	0002      	movs	r2, r0
    2836:	491d      	ldr	r1, [pc, #116]	; (28ac <iot_message_reportAllInfo+0x11c>)
    2838:	9801      	ldr	r0, [sp, #4]
    283a:	47d0      	blx	sl
	
		cJSON_AddItemToArray(json2CloudDataArray1, json2CloudNodeData);
    283c:	9901      	ldr	r1, [sp, #4]
    283e:	9802      	ldr	r0, [sp, #8]
    2840:	4b1b      	ldr	r3, [pc, #108]	; (28b0 <iot_message_reportAllInfo+0x120>)
    2842:	4798      	blx	r3
	cJSON_AddStringToObject(json2CloudData, ATTR_UUID_NAME, gUuid);
	cJSON_AddStringToObject(json2CloudData, ATTR_COMMAND_NAME, CMD_REPORTALLINFO);
	cJSON_AddStringToObject(json2CloudData, ATTR_DEVTYPE_NAME, device_type);
	cJSON_AddStringToObject(json2CloudData, ATTR_MAC_ADDR_NAME, mac_addr);

	for (int i=0; i<num_of_data; i++)
    2844:	3601      	adds	r6, #1
    2846:	3524      	adds	r5, #36	; 0x24
    2848:	45b1      	cmp	r9, r6
    284a:	d1e4      	bne.n	2816 <iot_message_reportAllInfo+0x86>
	
		cJSON_AddItemToArray(json2CloudDataArray1, json2CloudNodeData);
		
	}
	
	cJSON_AddItemToObject(json2CloudData, "info", json2CloudDataArray1);
    284c:	9a02      	ldr	r2, [sp, #8]
    284e:	4919      	ldr	r1, [pc, #100]	; (28b4 <iot_message_reportAllInfo+0x124>)
    2850:	0020      	movs	r0, r4
    2852:	4b0c      	ldr	r3, [pc, #48]	; (2884 <iot_message_reportAllInfo+0xf4>)
    2854:	4798      	blx	r3
	
	return json2CloudData;

}
    2856:	0020      	movs	r0, r4
    2858:	b005      	add	sp, #20
    285a:	bc3c      	pop	{r2, r3, r4, r5}
    285c:	4690      	mov	r8, r2
    285e:	4699      	mov	r9, r3
    2860:	46a2      	mov	sl, r4
    2862:	46ab      	mov	fp, r5
    2864:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2866:	46c0      	nop			; (mov r8, r8)
    2868:	00001c69 	.word	0x00001c69
    286c:	00001c55 	.word	0x00001c55
    2870:	000138f8 	.word	0x000138f8
    2874:	0001198d 	.word	0x0001198d
    2878:	00013914 	.word	0x00013914
    287c:	00001c31 	.word	0x00001c31
    2880:	00013920 	.word	0x00013920
    2884:	00001bd1 	.word	0x00001bd1
    2888:	20000868 	.word	0x20000868
    288c:	0001393c 	.word	0x0001393c
    2890:	0001385c 	.word	0x0001385c
    2894:	000137c0 	.word	0x000137c0
    2898:	00013928 	.word	0x00013928
    289c:	00013810 	.word	0x00013810
    28a0:	000137ec 	.word	0x000137ec
    28a4:	000116d5 	.word	0x000116d5
    28a8:	00001c05 	.word	0x00001c05
    28ac:	000137f8 	.word	0x000137f8
    28b0:	00001ba9 	.word	0x00001ba9
    28b4:	000137e4 	.word	0x000137e4

000028b8 <iot_message_reportInfo>:


cJSON* iot_message_reportInfo(char* device_type, char* mac_addr, int report_data_num, NodeInfo data_info[])
{
    28b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    28ba:	465f      	mov	r7, fp
    28bc:	4656      	mov	r6, sl
    28be:	464d      	mov	r5, r9
    28c0:	4644      	mov	r4, r8
    28c2:	b4f0      	push	{r4, r5, r6, r7}
    28c4:	b085      	sub	sp, #20
    28c6:	0007      	movs	r7, r0
    28c8:	9101      	str	r1, [sp, #4]
    28ca:	4691      	mov	r9, r2
    28cc:	9303      	str	r3, [sp, #12]
	cJSON *json2CloudData;
	cJSON *json2CloudNodeData;
	cJSON *json2CloudDataArray1;
	
	json2CloudData=cJSON_CreateObject();
    28ce:	4b30      	ldr	r3, [pc, #192]	; (2990 <iot_message_reportInfo+0xd8>)
    28d0:	4798      	blx	r3
    28d2:	0004      	movs	r4, r0
	json2CloudDataArray1=cJSON_CreateArray();
    28d4:	4b2f      	ldr	r3, [pc, #188]	; (2994 <iot_message_reportInfo+0xdc>)
    28d6:	4798      	blx	r3
    28d8:	9002      	str	r0, [sp, #8]

	if((json2CloudData == NULL) || (json2CloudDataArray1 == NULL))
    28da:	2c00      	cmp	r4, #0
    28dc:	d001      	beq.n	28e2 <iot_message_reportInfo+0x2a>
    28de:	2800      	cmp	r0, #0
    28e0:	d103      	bne.n	28ea <iot_message_reportInfo+0x32>
	{
		printf("json2CloudData malloc fail");
    28e2:	482d      	ldr	r0, [pc, #180]	; (2998 <iot_message_reportInfo+0xe0>)
    28e4:	4b2d      	ldr	r3, [pc, #180]	; (299c <iot_message_reportInfo+0xe4>)
    28e6:	4798      	blx	r3
    28e8:	e7fe      	b.n	28e8 <iot_message_reportInfo+0x30>
		while(1);
	}
	
	cJSON_AddStringToObject(json2CloudData, ATTR_DEVNAME_NAME, DEVICE_NAME);
    28ea:	482d      	ldr	r0, [pc, #180]	; (29a0 <iot_message_reportInfo+0xe8>)
    28ec:	4e2d      	ldr	r6, [pc, #180]	; (29a4 <iot_message_reportInfo+0xec>)
    28ee:	47b0      	blx	r6
    28f0:	0002      	movs	r2, r0
    28f2:	492d      	ldr	r1, [pc, #180]	; (29a8 <iot_message_reportInfo+0xf0>)
    28f4:	0020      	movs	r0, r4
    28f6:	4d2d      	ldr	r5, [pc, #180]	; (29ac <iot_message_reportInfo+0xf4>)
    28f8:	47a8      	blx	r5
	cJSON_AddStringToObject(json2CloudData, ATTR_UUID_NAME, gUuid);
    28fa:	482d      	ldr	r0, [pc, #180]	; (29b0 <iot_message_reportInfo+0xf8>)
    28fc:	47b0      	blx	r6
    28fe:	0002      	movs	r2, r0
    2900:	492c      	ldr	r1, [pc, #176]	; (29b4 <iot_message_reportInfo+0xfc>)
    2902:	0020      	movs	r0, r4
    2904:	47a8      	blx	r5
	cJSON_AddStringToObject(json2CloudData, ATTR_COMMAND_NAME, CMD_REPORTINFO);
    2906:	482c      	ldr	r0, [pc, #176]	; (29b8 <iot_message_reportInfo+0x100>)
    2908:	47b0      	blx	r6
    290a:	0002      	movs	r2, r0
    290c:	492b      	ldr	r1, [pc, #172]	; (29bc <iot_message_reportInfo+0x104>)
    290e:	0020      	movs	r0, r4
    2910:	47a8      	blx	r5
	cJSON_AddStringToObject(json2CloudData, ATTR_DEVTYPE_NAME, device_type);
    2912:	0038      	movs	r0, r7
    2914:	47b0      	blx	r6
    2916:	0002      	movs	r2, r0
    2918:	4929      	ldr	r1, [pc, #164]	; (29c0 <iot_message_reportInfo+0x108>)
    291a:	0020      	movs	r0, r4
    291c:	47a8      	blx	r5
	cJSON_AddStringToObject(json2CloudData, ATTR_MAC_ADDR_NAME, mac_addr);
    291e:	9801      	ldr	r0, [sp, #4]
    2920:	47b0      	blx	r6
    2922:	0002      	movs	r2, r0
    2924:	4927      	ldr	r1, [pc, #156]	; (29c4 <iot_message_reportInfo+0x10c>)
    2926:	0020      	movs	r0, r4
    2928:	47a8      	blx	r5


	for (int i=0; i<report_data_num; i++)
    292a:	464b      	mov	r3, r9
    292c:	2b00      	cmp	r3, #0
    292e:	dd21      	ble.n	2974 <iot_message_reportInfo+0xbc>
    2930:	9d03      	ldr	r5, [sp, #12]
    2932:	2600      	movs	r6, #0
	{
		json2CloudNodeData=cJSON_CreateObject();
    2934:	4b16      	ldr	r3, [pc, #88]	; (2990 <iot_message_reportInfo+0xd8>)
    2936:	469b      	mov	fp, r3
		
		cJSON_AddStringToObject(json2CloudNodeData, "dataType", data_info[i].dataType);
    2938:	4f1a      	ldr	r7, [pc, #104]	; (29a4 <iot_message_reportInfo+0xec>)
    293a:	4b23      	ldr	r3, [pc, #140]	; (29c8 <iot_message_reportInfo+0x110>)
    293c:	4698      	mov	r8, r3
	cJSON_AddStringToObject(json2CloudData, ATTR_MAC_ADDR_NAME, mac_addr);


	for (int i=0; i<report_data_num; i++)
	{
		json2CloudNodeData=cJSON_CreateObject();
    293e:	47d8      	blx	fp
    2940:	9001      	str	r0, [sp, #4]
		
		cJSON_AddStringToObject(json2CloudNodeData, "dataType", data_info[i].dataType);
    2942:	0028      	movs	r0, r5
    2944:	47b8      	blx	r7
    2946:	0002      	movs	r2, r0
    2948:	4641      	mov	r1, r8
    294a:	9801      	ldr	r0, [sp, #4]
    294c:	4b17      	ldr	r3, [pc, #92]	; (29ac <iot_message_reportInfo+0xf4>)
    294e:	469a      	mov	sl, r3
    2950:	4798      	blx	r3
		cJSON_AddNumberToObject(json2CloudNodeData, "value", data_info[i].value);
    2952:	6a28      	ldr	r0, [r5, #32]
    2954:	4b1d      	ldr	r3, [pc, #116]	; (29cc <iot_message_reportInfo+0x114>)
    2956:	4798      	blx	r3
    2958:	4b1d      	ldr	r3, [pc, #116]	; (29d0 <iot_message_reportInfo+0x118>)
    295a:	4798      	blx	r3
    295c:	0002      	movs	r2, r0
    295e:	491d      	ldr	r1, [pc, #116]	; (29d4 <iot_message_reportInfo+0x11c>)
    2960:	9801      	ldr	r0, [sp, #4]
    2962:	47d0      	blx	sl
		
		cJSON_AddItemToArray(json2CloudDataArray1, json2CloudNodeData);
    2964:	9901      	ldr	r1, [sp, #4]
    2966:	9802      	ldr	r0, [sp, #8]
    2968:	4b1b      	ldr	r3, [pc, #108]	; (29d8 <iot_message_reportInfo+0x120>)
    296a:	4798      	blx	r3
	cJSON_AddStringToObject(json2CloudData, ATTR_COMMAND_NAME, CMD_REPORTINFO);
	cJSON_AddStringToObject(json2CloudData, ATTR_DEVTYPE_NAME, device_type);
	cJSON_AddStringToObject(json2CloudData, ATTR_MAC_ADDR_NAME, mac_addr);


	for (int i=0; i<report_data_num; i++)
    296c:	3601      	adds	r6, #1
    296e:	3524      	adds	r5, #36	; 0x24
    2970:	45b1      	cmp	r9, r6
    2972:	d1e4      	bne.n	293e <iot_message_reportInfo+0x86>
		cJSON_AddItemToArray(json2CloudDataArray1, json2CloudNodeData);
		
	}
	//printf("\r\n[%s] info=%s\r\n", __func__, data_info[0].dataType);
	
	cJSON_AddItemToObject(json2CloudData, "info", json2CloudDataArray1);
    2974:	9a02      	ldr	r2, [sp, #8]
    2976:	4919      	ldr	r1, [pc, #100]	; (29dc <iot_message_reportInfo+0x124>)
    2978:	0020      	movs	r0, r4
    297a:	4b0c      	ldr	r3, [pc, #48]	; (29ac <iot_message_reportInfo+0xf4>)
    297c:	4798      	blx	r3
	
	return json2CloudData;
}
    297e:	0020      	movs	r0, r4
    2980:	b005      	add	sp, #20
    2982:	bc3c      	pop	{r2, r3, r4, r5}
    2984:	4690      	mov	r8, r2
    2986:	4699      	mov	r9, r3
    2988:	46a2      	mov	sl, r4
    298a:	46ab      	mov	fp, r5
    298c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    298e:	46c0      	nop			; (mov r8, r8)
    2990:	00001c69 	.word	0x00001c69
    2994:	00001c55 	.word	0x00001c55
    2998:	000138f8 	.word	0x000138f8
    299c:	0001198d 	.word	0x0001198d
    29a0:	00013914 	.word	0x00013914
    29a4:	00001c31 	.word	0x00001c31
    29a8:	00013920 	.word	0x00013920
    29ac:	00001bd1 	.word	0x00001bd1
    29b0:	20000868 	.word	0x20000868
    29b4:	0001393c 	.word	0x0001393c
    29b8:	0001386c 	.word	0x0001386c
    29bc:	000137c0 	.word	0x000137c0
    29c0:	00013928 	.word	0x00013928
    29c4:	00013810 	.word	0x00013810
    29c8:	000137ec 	.word	0x000137ec
    29cc:	000116d5 	.word	0x000116d5
    29d0:	00001c05 	.word	0x00001c05
    29d4:	000137f8 	.word	0x000137f8
    29d8:	00001ba9 	.word	0x00001ba9
    29dc:	000137e4 	.word	0x000137e4

000029e0 <toggleLED>:
Led_Color gu8Color;


void toggleLED()
{
	if (gu8OnOffState == 1)
    29e0:	4b1e      	ldr	r3, [pc, #120]	; (2a5c <toggleLED+0x7c>)
    29e2:	781b      	ldrb	r3, [r3, #0]
    29e4:	2b01      	cmp	r3, #1
    29e6:	d10d      	bne.n	2a04 <toggleLED+0x24>
	{
		
		gu8OnOffState = 0;
    29e8:	2200      	movs	r2, #0
    29ea:	4b1c      	ldr	r3, [pc, #112]	; (2a5c <toggleLED+0x7c>)
    29ec:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    29ee:	4b1c      	ldr	r3, [pc, #112]	; (2a60 <toggleLED+0x80>)
    29f0:	2280      	movs	r2, #128	; 0x80
    29f2:	0312      	lsls	r2, r2, #12
    29f4:	619a      	str	r2, [r3, #24]
    29f6:	2280      	movs	r2, #128	; 0x80
    29f8:	0212      	lsls	r2, r2, #8
    29fa:	619a      	str	r2, [r3, #24]
    29fc:	2280      	movs	r2, #128	; 0x80
    29fe:	01d2      	lsls	r2, r2, #7
    2a00:	619a      	str	r2, [r3, #24]
    2a02:	e029      	b.n	2a58 <toggleLED+0x78>
		port_pin_set_output_level(GREEN_LED, 1);
		port_pin_set_output_level(RED_LED, 1);
	}
	else
	{
		gu8OnOffState = 1;
    2a04:	2201      	movs	r2, #1
    2a06:	4b15      	ldr	r3, [pc, #84]	; (2a5c <toggleLED+0x7c>)
    2a08:	701a      	strb	r2, [r3, #0]
		port_pin_set_output_level(BLUE_LED, gu8Blue);
    2a0a:	4b16      	ldr	r3, [pc, #88]	; (2a64 <toggleLED+0x84>)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    2a0c:	781b      	ldrb	r3, [r3, #0]
    2a0e:	2b00      	cmp	r3, #0
    2a10:	d004      	beq.n	2a1c <toggleLED+0x3c>
		port_base->OUTSET.reg = pin_mask;
    2a12:	2280      	movs	r2, #128	; 0x80
    2a14:	0312      	lsls	r2, r2, #12
    2a16:	4b12      	ldr	r3, [pc, #72]	; (2a60 <toggleLED+0x80>)
    2a18:	619a      	str	r2, [r3, #24]
    2a1a:	e003      	b.n	2a24 <toggleLED+0x44>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    2a1c:	2280      	movs	r2, #128	; 0x80
    2a1e:	0312      	lsls	r2, r2, #12
    2a20:	4b0f      	ldr	r3, [pc, #60]	; (2a60 <toggleLED+0x80>)
    2a22:	615a      	str	r2, [r3, #20]
		port_pin_set_output_level(GREEN_LED, gu8Green);
    2a24:	4b10      	ldr	r3, [pc, #64]	; (2a68 <toggleLED+0x88>)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    2a26:	781b      	ldrb	r3, [r3, #0]
    2a28:	2b00      	cmp	r3, #0
    2a2a:	d004      	beq.n	2a36 <toggleLED+0x56>
		port_base->OUTSET.reg = pin_mask;
    2a2c:	2280      	movs	r2, #128	; 0x80
    2a2e:	0212      	lsls	r2, r2, #8
    2a30:	4b0b      	ldr	r3, [pc, #44]	; (2a60 <toggleLED+0x80>)
    2a32:	619a      	str	r2, [r3, #24]
    2a34:	e003      	b.n	2a3e <toggleLED+0x5e>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    2a36:	2280      	movs	r2, #128	; 0x80
    2a38:	0212      	lsls	r2, r2, #8
    2a3a:	4b09      	ldr	r3, [pc, #36]	; (2a60 <toggleLED+0x80>)
    2a3c:	615a      	str	r2, [r3, #20]
		port_pin_set_output_level(RED_LED, gu8Red);
    2a3e:	4b0b      	ldr	r3, [pc, #44]	; (2a6c <toggleLED+0x8c>)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    2a40:	781b      	ldrb	r3, [r3, #0]
    2a42:	2b00      	cmp	r3, #0
    2a44:	d004      	beq.n	2a50 <toggleLED+0x70>
		port_base->OUTSET.reg = pin_mask;
    2a46:	2280      	movs	r2, #128	; 0x80
    2a48:	01d2      	lsls	r2, r2, #7
    2a4a:	4b05      	ldr	r3, [pc, #20]	; (2a60 <toggleLED+0x80>)
    2a4c:	619a      	str	r2, [r3, #24]
    2a4e:	e003      	b.n	2a58 <toggleLED+0x78>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    2a50:	2280      	movs	r2, #128	; 0x80
    2a52:	01d2      	lsls	r2, r2, #7
    2a54:	4b02      	ldr	r3, [pc, #8]	; (2a60 <toggleLED+0x80>)
    2a56:	615a      	str	r2, [r3, #20]
	}
}
    2a58:	4770      	bx	lr
    2a5a:	46c0      	nop			; (mov r8, r8)
    2a5c:	20001c41 	.word	0x20001c41
    2a60:	40002800 	.word	0x40002800
    2a64:	20001c42 	.word	0x20001c42
    2a68:	20001c40 	.word	0x20001c40
    2a6c:	20001c44 	.word	0x20001c44

00002a70 <initialise_led>:
	port_pin_set_output_level(GREEN_LED, 1);
	port_pin_set_output_level(RED_LED, 1);
}

void initialise_led(void)
{
    2a70:	b570      	push	{r4, r5, r6, lr}
    2a72:	b082      	sub	sp, #8
	gu8Blue = 0;
    2a74:	4e1f      	ldr	r6, [pc, #124]	; (2af4 <initialise_led+0x84>)
    2a76:	2200      	movs	r2, #0
    2a78:	7032      	strb	r2, [r6, #0]
	gu8Green = 1;
    2a7a:	2301      	movs	r3, #1
    2a7c:	491e      	ldr	r1, [pc, #120]	; (2af8 <initialise_led+0x88>)
    2a7e:	700b      	strb	r3, [r1, #0]
	gu8Red = 1;
    2a80:	491e      	ldr	r1, [pc, #120]	; (2afc <initialise_led+0x8c>)
    2a82:	700b      	strb	r3, [r1, #0]
	gu8Color = LED_COLOR_BLUE;
    2a84:	491e      	ldr	r1, [pc, #120]	; (2b00 <initialise_led+0x90>)
    2a86:	700a      	strb	r2, [r1, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    2a88:	ac01      	add	r4, sp, #4
    2a8a:	7063      	strb	r3, [r4, #1]
	config->powersave  = false;
    2a8c:	70a2      	strb	r2, [r4, #2]
	
	/* led port pin initialization */
	struct port_config config_port_pin;
	port_get_config_defaults(&config_port_pin);
	config_port_pin.direction = PORT_PIN_DIR_OUTPUT;
    2a8e:	7023      	strb	r3, [r4, #0]
	port_pin_set_config(BLUE_LED, &config_port_pin);
    2a90:	0021      	movs	r1, r4
    2a92:	2013      	movs	r0, #19
    2a94:	4d1b      	ldr	r5, [pc, #108]	; (2b04 <initialise_led+0x94>)
    2a96:	47a8      	blx	r5
	port_pin_set_config(GREEN_LED, &config_port_pin);
    2a98:	0021      	movs	r1, r4
    2a9a:	200f      	movs	r0, #15
    2a9c:	47a8      	blx	r5
	port_pin_set_config(RED_LED, &config_port_pin);
    2a9e:	0021      	movs	r1, r4
    2aa0:	200e      	movs	r0, #14
    2aa2:	47a8      	blx	r5
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    2aa4:	7833      	ldrb	r3, [r6, #0]
    2aa6:	2b00      	cmp	r3, #0
    2aa8:	d004      	beq.n	2ab4 <initialise_led+0x44>
		port_base->OUTSET.reg = pin_mask;
    2aaa:	2280      	movs	r2, #128	; 0x80
    2aac:	0312      	lsls	r2, r2, #12
    2aae:	4b16      	ldr	r3, [pc, #88]	; (2b08 <initialise_led+0x98>)
    2ab0:	619a      	str	r2, [r3, #24]
    2ab2:	e003      	b.n	2abc <initialise_led+0x4c>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    2ab4:	2280      	movs	r2, #128	; 0x80
    2ab6:	0312      	lsls	r2, r2, #12
    2ab8:	4b13      	ldr	r3, [pc, #76]	; (2b08 <initialise_led+0x98>)
    2aba:	615a      	str	r2, [r3, #20]
	port_pin_set_output_level(BLUE_LED, gu8Blue);
	port_pin_set_output_level(GREEN_LED, gu8Green);
    2abc:	4b0e      	ldr	r3, [pc, #56]	; (2af8 <initialise_led+0x88>)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    2abe:	781b      	ldrb	r3, [r3, #0]
    2ac0:	2b00      	cmp	r3, #0
    2ac2:	d004      	beq.n	2ace <initialise_led+0x5e>
		port_base->OUTSET.reg = pin_mask;
    2ac4:	2280      	movs	r2, #128	; 0x80
    2ac6:	0212      	lsls	r2, r2, #8
    2ac8:	4b0f      	ldr	r3, [pc, #60]	; (2b08 <initialise_led+0x98>)
    2aca:	619a      	str	r2, [r3, #24]
    2acc:	e003      	b.n	2ad6 <initialise_led+0x66>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    2ace:	2280      	movs	r2, #128	; 0x80
    2ad0:	0212      	lsls	r2, r2, #8
    2ad2:	4b0d      	ldr	r3, [pc, #52]	; (2b08 <initialise_led+0x98>)
    2ad4:	615a      	str	r2, [r3, #20]
	port_pin_set_output_level(RED_LED, gu8Red);
    2ad6:	4b09      	ldr	r3, [pc, #36]	; (2afc <initialise_led+0x8c>)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    2ad8:	781b      	ldrb	r3, [r3, #0]
    2ada:	2b00      	cmp	r3, #0
    2adc:	d004      	beq.n	2ae8 <initialise_led+0x78>
		port_base->OUTSET.reg = pin_mask;
    2ade:	2280      	movs	r2, #128	; 0x80
    2ae0:	01d2      	lsls	r2, r2, #7
    2ae2:	4b09      	ldr	r3, [pc, #36]	; (2b08 <initialise_led+0x98>)
    2ae4:	619a      	str	r2, [r3, #24]
    2ae6:	e003      	b.n	2af0 <initialise_led+0x80>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    2ae8:	2280      	movs	r2, #128	; 0x80
    2aea:	01d2      	lsls	r2, r2, #7
    2aec:	4b06      	ldr	r3, [pc, #24]	; (2b08 <initialise_led+0x98>)
    2aee:	615a      	str	r2, [r3, #20]
}
    2af0:	b002      	add	sp, #8
    2af2:	bd70      	pop	{r4, r5, r6, pc}
    2af4:	20001c42 	.word	0x20001c42
    2af8:	20001c40 	.word	0x20001c40
    2afc:	20001c44 	.word	0x20001c44
    2b00:	20001c43 	.word	0x20001c43
    2b04:	0000c7c5 	.word	0x0000c7c5
    2b08:	40002800 	.word	0x40002800

00002b0c <led_ctrl_get_color>:


Led_Color led_ctrl_get_color()
{
	return gu8Color;
    2b0c:	4b01      	ldr	r3, [pc, #4]	; (2b14 <led_ctrl_get_color+0x8>)
    2b0e:	7818      	ldrb	r0, [r3, #0]
}
    2b10:	4770      	bx	lr
    2b12:	46c0      	nop			; (mov r8, r8)
    2b14:	20001c43 	.word	0x20001c43

00002b18 <led_ctrl_set_color>:


void led_ctrl_set_color(Led_Color color, Led_Mode mode)
{
	switch(color)
    2b18:	2806      	cmp	r0, #6
    2b1a:	d853      	bhi.n	2bc4 <led_ctrl_set_color+0xac>
    2b1c:	0080      	lsls	r0, r0, #2
    2b1e:	4b42      	ldr	r3, [pc, #264]	; (2c28 <led_ctrl_set_color+0x110>)
    2b20:	581b      	ldr	r3, [r3, r0]
    2b22:	469f      	mov	pc, r3
	{
		case LED_COLOR_BLUE:
			gu8Blue = 0;
    2b24:	2300      	movs	r3, #0
    2b26:	4a41      	ldr	r2, [pc, #260]	; (2c2c <led_ctrl_set_color+0x114>)
    2b28:	7013      	strb	r3, [r2, #0]
			gu8Green = 1;
    2b2a:	2201      	movs	r2, #1
    2b2c:	4840      	ldr	r0, [pc, #256]	; (2c30 <led_ctrl_set_color+0x118>)
    2b2e:	7002      	strb	r2, [r0, #0]
			gu8Red = 1;
    2b30:	4840      	ldr	r0, [pc, #256]	; (2c34 <led_ctrl_set_color+0x11c>)
    2b32:	7002      	strb	r2, [r0, #0]
			gu8Color = LED_COLOR_BLUE;
    2b34:	4a40      	ldr	r2, [pc, #256]	; (2c38 <led_ctrl_set_color+0x120>)
    2b36:	7013      	strb	r3, [r2, #0]
			break;
    2b38:	e044      	b.n	2bc4 <led_ctrl_set_color+0xac>
		case LED_COLOR_GREEN:
			gu8Blue = 1;
    2b3a:	2301      	movs	r3, #1
    2b3c:	4a3b      	ldr	r2, [pc, #236]	; (2c2c <led_ctrl_set_color+0x114>)
    2b3e:	7013      	strb	r3, [r2, #0]
			gu8Green = 0;
    2b40:	2000      	movs	r0, #0
    2b42:	4a3b      	ldr	r2, [pc, #236]	; (2c30 <led_ctrl_set_color+0x118>)
    2b44:	7010      	strb	r0, [r2, #0]
			gu8Red = 1;
    2b46:	4a3b      	ldr	r2, [pc, #236]	; (2c34 <led_ctrl_set_color+0x11c>)
    2b48:	7013      	strb	r3, [r2, #0]
			gu8Color = LED_COLOR_GREEN;
    2b4a:	4a3b      	ldr	r2, [pc, #236]	; (2c38 <led_ctrl_set_color+0x120>)
    2b4c:	7013      	strb	r3, [r2, #0]
			break;
    2b4e:	e039      	b.n	2bc4 <led_ctrl_set_color+0xac>
		case LED_COLOR_RED:
			gu8Blue = 1;
    2b50:	2301      	movs	r3, #1
    2b52:	4a36      	ldr	r2, [pc, #216]	; (2c2c <led_ctrl_set_color+0x114>)
    2b54:	7013      	strb	r3, [r2, #0]
			gu8Green = 1;
    2b56:	4a36      	ldr	r2, [pc, #216]	; (2c30 <led_ctrl_set_color+0x118>)
    2b58:	7013      	strb	r3, [r2, #0]
			gu8Red = 0;
    2b5a:	2200      	movs	r2, #0
    2b5c:	4b35      	ldr	r3, [pc, #212]	; (2c34 <led_ctrl_set_color+0x11c>)
    2b5e:	701a      	strb	r2, [r3, #0]
			gu8Color = LED_COLOR_RED;
    2b60:	3202      	adds	r2, #2
    2b62:	4b35      	ldr	r3, [pc, #212]	; (2c38 <led_ctrl_set_color+0x120>)
    2b64:	701a      	strb	r2, [r3, #0]
			break;
    2b66:	e02d      	b.n	2bc4 <led_ctrl_set_color+0xac>
		case LED_COLOR_YELLOW:
			gu8Blue = 1;
    2b68:	2201      	movs	r2, #1
    2b6a:	4b30      	ldr	r3, [pc, #192]	; (2c2c <led_ctrl_set_color+0x114>)
    2b6c:	701a      	strb	r2, [r3, #0]
			gu8Green = 0;
    2b6e:	2300      	movs	r3, #0
    2b70:	4a2f      	ldr	r2, [pc, #188]	; (2c30 <led_ctrl_set_color+0x118>)
    2b72:	7013      	strb	r3, [r2, #0]
			gu8Red = 0;
    2b74:	4a2f      	ldr	r2, [pc, #188]	; (2c34 <led_ctrl_set_color+0x11c>)
    2b76:	7013      	strb	r3, [r2, #0]
			gu8Color = LED_COLOR_YELLOW;
    2b78:	2203      	movs	r2, #3
    2b7a:	4b2f      	ldr	r3, [pc, #188]	; (2c38 <led_ctrl_set_color+0x120>)
    2b7c:	701a      	strb	r2, [r3, #0]
			break;
    2b7e:	e021      	b.n	2bc4 <led_ctrl_set_color+0xac>
		case LED_COLOR_Magneta:
			gu8Blue = 0;
    2b80:	2300      	movs	r3, #0
    2b82:	4a2a      	ldr	r2, [pc, #168]	; (2c2c <led_ctrl_set_color+0x114>)
    2b84:	7013      	strb	r3, [r2, #0]
			gu8Green = 1;
    2b86:	2001      	movs	r0, #1
    2b88:	4a29      	ldr	r2, [pc, #164]	; (2c30 <led_ctrl_set_color+0x118>)
    2b8a:	7010      	strb	r0, [r2, #0]
			gu8Red = 0;
    2b8c:	4a29      	ldr	r2, [pc, #164]	; (2c34 <led_ctrl_set_color+0x11c>)
    2b8e:	7013      	strb	r3, [r2, #0]
			gu8Color = LED_COLOR_Magneta;
    2b90:	2204      	movs	r2, #4
    2b92:	4b29      	ldr	r3, [pc, #164]	; (2c38 <led_ctrl_set_color+0x120>)
    2b94:	701a      	strb	r2, [r3, #0]
			break;
    2b96:	e015      	b.n	2bc4 <led_ctrl_set_color+0xac>
		case LED_COLOR_Cyan:
			gu8Blue = 0;
    2b98:	2300      	movs	r3, #0
    2b9a:	4a24      	ldr	r2, [pc, #144]	; (2c2c <led_ctrl_set_color+0x114>)
    2b9c:	7013      	strb	r3, [r2, #0]
			gu8Green = 0;
    2b9e:	4a24      	ldr	r2, [pc, #144]	; (2c30 <led_ctrl_set_color+0x118>)
    2ba0:	7013      	strb	r3, [r2, #0]
			gu8Red = 1;
    2ba2:	2201      	movs	r2, #1
    2ba4:	4b23      	ldr	r3, [pc, #140]	; (2c34 <led_ctrl_set_color+0x11c>)
    2ba6:	701a      	strb	r2, [r3, #0]
			gu8Color = LED_COLOR_Cyan;
    2ba8:	3204      	adds	r2, #4
    2baa:	4b23      	ldr	r3, [pc, #140]	; (2c38 <led_ctrl_set_color+0x120>)
    2bac:	701a      	strb	r2, [r3, #0]
			break;
    2bae:	e009      	b.n	2bc4 <led_ctrl_set_color+0xac>
		case LED_COLOR_WHTIE:
			gu8Blue = 1;
    2bb0:	2301      	movs	r3, #1
    2bb2:	4a1e      	ldr	r2, [pc, #120]	; (2c2c <led_ctrl_set_color+0x114>)
    2bb4:	7013      	strb	r3, [r2, #0]
			gu8Green = 1;
    2bb6:	4a1e      	ldr	r2, [pc, #120]	; (2c30 <led_ctrl_set_color+0x118>)
    2bb8:	7013      	strb	r3, [r2, #0]
			gu8Red = 1;
    2bba:	4a1e      	ldr	r2, [pc, #120]	; (2c34 <led_ctrl_set_color+0x11c>)
    2bbc:	7013      	strb	r3, [r2, #0]
			gu8Color = LED_COLOR_WHTIE;
    2bbe:	2206      	movs	r2, #6
    2bc0:	4b1d      	ldr	r3, [pc, #116]	; (2c38 <led_ctrl_set_color+0x120>)
    2bc2:	701a      	strb	r2, [r3, #0]
		default:
			break;
		
	}
	
	if (mode == LED_MODE_NONE)
    2bc4:	2900      	cmp	r1, #0
    2bc6:	d12b      	bne.n	2c20 <led_ctrl_set_color+0x108>
	{
		if (gu8OnOffState == 1)
    2bc8:	4b1c      	ldr	r3, [pc, #112]	; (2c3c <led_ctrl_set_color+0x124>)
    2bca:	781b      	ldrb	r3, [r3, #0]
    2bcc:	2b01      	cmp	r3, #1
    2bce:	d129      	bne.n	2c24 <led_ctrl_set_color+0x10c>
}

static inline void turnOnLED(void)
{
	gu8OnOffState = 1;
	port_pin_set_output_level(BLUE_LED, gu8Blue);
    2bd0:	4b16      	ldr	r3, [pc, #88]	; (2c2c <led_ctrl_set_color+0x114>)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    2bd2:	781b      	ldrb	r3, [r3, #0]
    2bd4:	2b00      	cmp	r3, #0
    2bd6:	d004      	beq.n	2be2 <led_ctrl_set_color+0xca>
		port_base->OUTSET.reg = pin_mask;
    2bd8:	2280      	movs	r2, #128	; 0x80
    2bda:	0312      	lsls	r2, r2, #12
    2bdc:	4b18      	ldr	r3, [pc, #96]	; (2c40 <led_ctrl_set_color+0x128>)
    2bde:	619a      	str	r2, [r3, #24]
    2be0:	e003      	b.n	2bea <led_ctrl_set_color+0xd2>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    2be2:	2280      	movs	r2, #128	; 0x80
    2be4:	0312      	lsls	r2, r2, #12
    2be6:	4b16      	ldr	r3, [pc, #88]	; (2c40 <led_ctrl_set_color+0x128>)
    2be8:	615a      	str	r2, [r3, #20]
	port_pin_set_output_level(GREEN_LED, gu8Green);
    2bea:	4b11      	ldr	r3, [pc, #68]	; (2c30 <led_ctrl_set_color+0x118>)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    2bec:	781b      	ldrb	r3, [r3, #0]
    2bee:	2b00      	cmp	r3, #0
    2bf0:	d004      	beq.n	2bfc <led_ctrl_set_color+0xe4>
		port_base->OUTSET.reg = pin_mask;
    2bf2:	2280      	movs	r2, #128	; 0x80
    2bf4:	0212      	lsls	r2, r2, #8
    2bf6:	4b12      	ldr	r3, [pc, #72]	; (2c40 <led_ctrl_set_color+0x128>)
    2bf8:	619a      	str	r2, [r3, #24]
    2bfa:	e003      	b.n	2c04 <led_ctrl_set_color+0xec>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    2bfc:	2280      	movs	r2, #128	; 0x80
    2bfe:	0212      	lsls	r2, r2, #8
    2c00:	4b0f      	ldr	r3, [pc, #60]	; (2c40 <led_ctrl_set_color+0x128>)
    2c02:	615a      	str	r2, [r3, #20]
	port_pin_set_output_level(RED_LED, gu8Red);
    2c04:	4b0b      	ldr	r3, [pc, #44]	; (2c34 <led_ctrl_set_color+0x11c>)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    2c06:	781b      	ldrb	r3, [r3, #0]
    2c08:	2b00      	cmp	r3, #0
    2c0a:	d004      	beq.n	2c16 <led_ctrl_set_color+0xfe>
		port_base->OUTSET.reg = pin_mask;
    2c0c:	2280      	movs	r2, #128	; 0x80
    2c0e:	01d2      	lsls	r2, r2, #7
    2c10:	4b0b      	ldr	r3, [pc, #44]	; (2c40 <led_ctrl_set_color+0x128>)
    2c12:	619a      	str	r2, [r3, #24]
    2c14:	e006      	b.n	2c24 <led_ctrl_set_color+0x10c>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    2c16:	2280      	movs	r2, #128	; 0x80
    2c18:	01d2      	lsls	r2, r2, #7
    2c1a:	4b09      	ldr	r3, [pc, #36]	; (2c40 <led_ctrl_set_color+0x128>)
    2c1c:	615a      	str	r2, [r3, #20]
    2c1e:	e001      	b.n	2c24 <led_ctrl_set_color+0x10c>
		if (gu8OnOffState == 1)
			turnOnLED();	// color change take effect
		return;
	}
	
	gu8LedMode = mode;
    2c20:	4b08      	ldr	r3, [pc, #32]	; (2c44 <led_ctrl_set_color+0x12c>)
    2c22:	7019      	strb	r1, [r3, #0]
	
}
    2c24:	4770      	bx	lr
    2c26:	46c0      	nop			; (mov r8, r8)
    2c28:	00013958 	.word	0x00013958
    2c2c:	20001c42 	.word	0x20001c42
    2c30:	20001c40 	.word	0x20001c40
    2c34:	20001c44 	.word	0x20001c44
    2c38:	20001c43 	.word	0x20001c43
    2c3c:	20001c41 	.word	0x20001c41
    2c40:	40002800 	.word	0x40002800
    2c44:	20001c45 	.word	0x20001c45

00002c48 <led_ctrl_set_mode>:

void led_ctrl_set_mode(Led_Mode mode)
{
	gu8LedMode = mode;
    2c48:	4b1f      	ldr	r3, [pc, #124]	; (2cc8 <led_ctrl_set_mode+0x80>)
    2c4a:	7018      	strb	r0, [r3, #0]
	switch (mode)
    2c4c:	2801      	cmp	r0, #1
    2c4e:	d002      	beq.n	2c56 <led_ctrl_set_mode+0xe>
    2c50:	2802      	cmp	r0, #2
    2c52:	d00e      	beq.n	2c72 <led_ctrl_set_mode+0x2a>
    2c54:	e037      	b.n	2cc6 <led_ctrl_set_mode+0x7e>
	port_pin_set_output_level(RED_LED, gu8Red);
}

static inline void turnOffLED(void)
{
	gu8OnOffState = 0;
    2c56:	2200      	movs	r2, #0
    2c58:	4b1c      	ldr	r3, [pc, #112]	; (2ccc <led_ctrl_set_mode+0x84>)
    2c5a:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    2c5c:	4b1c      	ldr	r3, [pc, #112]	; (2cd0 <led_ctrl_set_mode+0x88>)
    2c5e:	2280      	movs	r2, #128	; 0x80
    2c60:	0312      	lsls	r2, r2, #12
    2c62:	619a      	str	r2, [r3, #24]
    2c64:	2280      	movs	r2, #128	; 0x80
    2c66:	0212      	lsls	r2, r2, #8
    2c68:	619a      	str	r2, [r3, #24]
    2c6a:	2280      	movs	r2, #128	; 0x80
    2c6c:	01d2      	lsls	r2, r2, #7
    2c6e:	619a      	str	r2, [r3, #24]
    2c70:	e029      	b.n	2cc6 <led_ctrl_set_mode+0x7e>
	}
}

static inline void turnOnLED(void)
{
	gu8OnOffState = 1;
    2c72:	2201      	movs	r2, #1
    2c74:	4b15      	ldr	r3, [pc, #84]	; (2ccc <led_ctrl_set_mode+0x84>)
    2c76:	701a      	strb	r2, [r3, #0]
	port_pin_set_output_level(BLUE_LED, gu8Blue);
    2c78:	4b16      	ldr	r3, [pc, #88]	; (2cd4 <led_ctrl_set_mode+0x8c>)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    2c7a:	781b      	ldrb	r3, [r3, #0]
    2c7c:	2b00      	cmp	r3, #0
    2c7e:	d004      	beq.n	2c8a <led_ctrl_set_mode+0x42>
		port_base->OUTSET.reg = pin_mask;
    2c80:	2280      	movs	r2, #128	; 0x80
    2c82:	0312      	lsls	r2, r2, #12
    2c84:	4b12      	ldr	r3, [pc, #72]	; (2cd0 <led_ctrl_set_mode+0x88>)
    2c86:	619a      	str	r2, [r3, #24]
    2c88:	e003      	b.n	2c92 <led_ctrl_set_mode+0x4a>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    2c8a:	2280      	movs	r2, #128	; 0x80
    2c8c:	0312      	lsls	r2, r2, #12
    2c8e:	4b10      	ldr	r3, [pc, #64]	; (2cd0 <led_ctrl_set_mode+0x88>)
    2c90:	615a      	str	r2, [r3, #20]
	port_pin_set_output_level(GREEN_LED, gu8Green);
    2c92:	4b11      	ldr	r3, [pc, #68]	; (2cd8 <led_ctrl_set_mode+0x90>)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    2c94:	781b      	ldrb	r3, [r3, #0]
    2c96:	2b00      	cmp	r3, #0
    2c98:	d004      	beq.n	2ca4 <led_ctrl_set_mode+0x5c>
		port_base->OUTSET.reg = pin_mask;
    2c9a:	2280      	movs	r2, #128	; 0x80
    2c9c:	0212      	lsls	r2, r2, #8
    2c9e:	4b0c      	ldr	r3, [pc, #48]	; (2cd0 <led_ctrl_set_mode+0x88>)
    2ca0:	619a      	str	r2, [r3, #24]
    2ca2:	e003      	b.n	2cac <led_ctrl_set_mode+0x64>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    2ca4:	2280      	movs	r2, #128	; 0x80
    2ca6:	0212      	lsls	r2, r2, #8
    2ca8:	4b09      	ldr	r3, [pc, #36]	; (2cd0 <led_ctrl_set_mode+0x88>)
    2caa:	615a      	str	r2, [r3, #20]
	port_pin_set_output_level(RED_LED, gu8Red);
    2cac:	4b0b      	ldr	r3, [pc, #44]	; (2cdc <led_ctrl_set_mode+0x94>)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    2cae:	781b      	ldrb	r3, [r3, #0]
    2cb0:	2b00      	cmp	r3, #0
    2cb2:	d004      	beq.n	2cbe <led_ctrl_set_mode+0x76>
		port_base->OUTSET.reg = pin_mask;
    2cb4:	2280      	movs	r2, #128	; 0x80
    2cb6:	01d2      	lsls	r2, r2, #7
    2cb8:	4b05      	ldr	r3, [pc, #20]	; (2cd0 <led_ctrl_set_mode+0x88>)
    2cba:	619a      	str	r2, [r3, #24]
    2cbc:	e003      	b.n	2cc6 <led_ctrl_set_mode+0x7e>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    2cbe:	2280      	movs	r2, #128	; 0x80
    2cc0:	01d2      	lsls	r2, r2, #7
    2cc2:	4b03      	ldr	r3, [pc, #12]	; (2cd0 <led_ctrl_set_mode+0x88>)
    2cc4:	615a      	str	r2, [r3, #20]
		
		default:
			break;
	}

}
    2cc6:	4770      	bx	lr
    2cc8:	20001c45 	.word	0x20001c45
    2ccc:	20001c41 	.word	0x20001c41
    2cd0:	40002800 	.word	0x40002800
    2cd4:	20001c42 	.word	0x20001c42
    2cd8:	20001c40 	.word	0x20001c40
    2cdc:	20001c44 	.word	0x20001c44

00002ce0 <set_motion_sensor_update_timer>:
	return;
}

void set_motion_sensor_update_timer(unsigned char time)	// arg time is in second unit
{
	rotation_data_timer = time; // 5 second timeout to update 
    2ce0:	4b01      	ldr	r3, [pc, #4]	; (2ce8 <set_motion_sensor_update_timer+0x8>)
    2ce2:	7018      	strb	r0, [r3, #0]
}
    2ce4:	4770      	bx	lr
    2ce6:	46c0      	nop			; (mov r8, r8)
    2ce8:	20002545 	.word	0x20002545

00002cec <motion_sensor_execute>:

void motion_sensor_execute()
{
    2cec:	b530      	push	{r4, r5, lr}
    2cee:	b083      	sub	sp, #12
	
	if (rotation_data_timer > 0)
    2cf0:	4b14      	ldr	r3, [pc, #80]	; (2d44 <motion_sensor_execute+0x58>)
    2cf2:	781b      	ldrb	r3, [r3, #0]
    2cf4:	2b00      	cmp	r3, #0
    2cf6:	d023      	beq.n	2d40 <motion_sensor_execute+0x54>
	{
		DBG_LOG("\r\nprocess motion\r\n");
    2cf8:	4d13      	ldr	r5, [pc, #76]	; (2d48 <motion_sensor_execute+0x5c>)
    2cfa:	0028      	movs	r0, r5
    2cfc:	4c13      	ldr	r4, [pc, #76]	; (2d4c <motion_sensor_execute+0x60>)
    2cfe:	47a0      	blx	r4
    2d00:	4813      	ldr	r0, [pc, #76]	; (2d50 <motion_sensor_execute+0x64>)
    2d02:	47a0      	blx	r4
		process_motion_sensor_data();
    2d04:	4b13      	ldr	r3, [pc, #76]	; (2d54 <motion_sensor_execute+0x68>)
    2d06:	4798      	blx	r3
		DBG_LOG("rotation data = %d, %d, %d, %d\r\n", quaternion_data.w, quaternion_data.x, quaternion_data.y, quaternion_data.z);
    2d08:	0028      	movs	r0, r5
    2d0a:	47a0      	blx	r4
    2d0c:	4c12      	ldr	r4, [pc, #72]	; (2d58 <motion_sensor_execute+0x6c>)
    2d0e:	2202      	movs	r2, #2
    2d10:	5ea3      	ldrsh	r3, [r4, r2]
    2d12:	2100      	movs	r1, #0
    2d14:	5e62      	ldrsh	r2, [r4, r1]
    2d16:	2006      	movs	r0, #6
    2d18:	5e21      	ldrsh	r1, [r4, r0]
    2d1a:	2504      	movs	r5, #4
    2d1c:	5f60      	ldrsh	r0, [r4, r5]
    2d1e:	9000      	str	r0, [sp, #0]
    2d20:	480e      	ldr	r0, [pc, #56]	; (2d5c <motion_sensor_execute+0x70>)
    2d22:	4d0f      	ldr	r5, [pc, #60]	; (2d60 <motion_sensor_execute+0x74>)
    2d24:	47a8      	blx	r5
		
		rotation_vector_update_cb(quaternion_data, rotation_data_timer);
    2d26:	4b07      	ldr	r3, [pc, #28]	; (2d44 <motion_sensor_execute+0x58>)
    2d28:	781a      	ldrb	r2, [r3, #0]
    2d2a:	8823      	ldrh	r3, [r4, #0]
    2d2c:	8860      	ldrh	r0, [r4, #2]
    2d2e:	0400      	lsls	r0, r0, #16
    2d30:	4318      	orrs	r0, r3
    2d32:	88a3      	ldrh	r3, [r4, #4]
    2d34:	88e1      	ldrh	r1, [r4, #6]
    2d36:	0409      	lsls	r1, r1, #16
    2d38:	4319      	orrs	r1, r3
    2d3a:	4b0a      	ldr	r3, [pc, #40]	; (2d64 <motion_sensor_execute+0x78>)
    2d3c:	681b      	ldr	r3, [r3, #0]
    2d3e:	4798      	blx	r3
	}
}
    2d40:	b003      	add	sp, #12
    2d42:	bd30      	pop	{r4, r5, pc}
    2d44:	20002545 	.word	0x20002545
    2d48:	000140b0 	.word	0x000140b0
    2d4c:	00011aad 	.word	0x00011aad
    2d50:	00013974 	.word	0x00013974
    2d54:	00009c3d 	.word	0x00009c3d
    2d58:	200023a8 	.word	0x200023a8
    2d5c:	00013988 	.word	0x00013988
    2d60:	0001198d 	.word	0x0001198d
    2d64:	20001c48 	.word	0x20001c48

00002d68 <register_rotation_vector_udpate_callback_handler>:

void register_rotation_vector_udpate_callback_handler(void* cb)
{
	rotation_vector_update_cb = cb;
    2d68:	4b01      	ldr	r3, [pc, #4]	; (2d70 <register_rotation_vector_udpate_callback_handler+0x8>)
    2d6a:	6018      	str	r0, [r3, #0]
    2d6c:	4770      	bx	lr
    2d6e:	46c0      	nop			; (mov r8, r8)
    2d70:	20001c48 	.word	0x20001c48

00002d74 <nvm_init>:
#define FLASH_NVDS_SIZE		1500
#define TEST_PAGE_ADDR     (FLASH_NB_OF_PAGES - 16) * NVMCTRL_PAGE_SIZE

uint8_t NVDS_Data[FLASH_NVDS_SIZE];
int nvm_init(void)
{
    2d74:	b510      	push	{r4, lr}
    2d76:	b082      	sub	sp, #8
{
	/* Sanity check the parameters */
	Assert(config);

	/* Write the default configuration for the NVM configuration */
	config->sleep_power_mode  = NVM_SLEEP_POWER_MODE_WAKEONACCESS;
    2d78:	2200      	movs	r2, #0
    2d7a:	466b      	mov	r3, sp
    2d7c:	701a      	strb	r2, [r3, #0]
	config->manual_page_write = true;
	config->wait_states       = NVMCTRL->CTRLB.bit.RWS;
    2d7e:	4b0b      	ldr	r3, [pc, #44]	; (2dac <nvm_init+0x38>)
    2d80:	685b      	ldr	r3, [r3, #4]
    2d82:	06db      	lsls	r3, r3, #27
    2d84:	0f1b      	lsrs	r3, r3, #28
    2d86:	4669      	mov	r1, sp
    2d88:	708b      	strb	r3, [r1, #2]
	config->disable_cache     = false;
    2d8a:	70ca      	strb	r2, [r1, #3]
#if (SAMC20) || (SAMC21)
	config->disable_rww_cache = false;
#endif
	config->cache_readmode    = NVM_CACHE_READMODE_NO_MISS_PENALTY;
    2d8c:	710a      	strb	r2, [r1, #4]

	/* Set wait state to 1 */
	//config.wait_states = 1;

	/* Enable automatic page write mode */
	config.manual_page_write = false;
    2d8e:	704a      	strb	r2, [r1, #1]

	/* Set the NVM configuration */
	status = nvm_set_config(&config);
    2d90:	4668      	mov	r0, sp
    2d92:	4b07      	ldr	r3, [pc, #28]	; (2db0 <nvm_init+0x3c>)
    2d94:	4798      	blx	r3
    2d96:	0004      	movs	r4, r0

	/* Validate the initialization */
	//test_assert_true(test, status == STATUS_OK,
	//"NVM Initialization error");

	DBG_LOG("status = %d", status);
    2d98:	4806      	ldr	r0, [pc, #24]	; (2db4 <nvm_init+0x40>)
    2d9a:	4b07      	ldr	r3, [pc, #28]	; (2db8 <nvm_init+0x44>)
    2d9c:	4798      	blx	r3
    2d9e:	0021      	movs	r1, r4
    2da0:	4806      	ldr	r0, [pc, #24]	; (2dbc <nvm_init+0x48>)
    2da2:	4b07      	ldr	r3, [pc, #28]	; (2dc0 <nvm_init+0x4c>)
    2da4:	4798      	blx	r3
	
	return status;
}
    2da6:	0020      	movs	r0, r4
    2da8:	b002      	add	sp, #8
    2daa:	bd10      	pop	{r4, pc}
    2dac:	41004000 	.word	0x41004000
    2db0:	00000115 	.word	0x00000115
    2db4:	000140b0 	.word	0x000140b0
    2db8:	00011aad 	.word	0x00011aad
    2dbc:	000139ac 	.word	0x000139ac
    2dc0:	0001198d 	.word	0x0001198d

00002dc4 <nvds_erase>:

int nvds_erase(void)//sector erase
{
    2dc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t len_buf=FLASH_PAGE_SIZE;
	int ret;
	//uint8_t read_buf[len_buf];
	//uint8_t write_buf[len_buf];

	DBG_LOG("nvds_erase start\r\n");
    2dc6:	480e      	ldr	r0, [pc, #56]	; (2e00 <nvds_erase+0x3c>)
    2dc8:	4c0e      	ldr	r4, [pc, #56]	; (2e04 <nvds_erase+0x40>)
    2dca:	47a0      	blx	r4
    2dcc:	480e      	ldr	r0, [pc, #56]	; (2e08 <nvds_erase+0x44>)
    2dce:	47a0      	blx	r4

	
	memset(NVDS_Data,0xff,sizeof(NVDS_Data));
    2dd0:	4a0e      	ldr	r2, [pc, #56]	; (2e0c <nvds_erase+0x48>)
    2dd2:	21ff      	movs	r1, #255	; 0xff
    2dd4:	480e      	ldr	r0, [pc, #56]	; (2e10 <nvds_erase+0x4c>)
    2dd6:	4b0f      	ldr	r3, [pc, #60]	; (2e14 <nvds_erase+0x50>)
    2dd8:	4798      	blx	r3
    2dda:	24ff      	movs	r4, #255	; 0xff
    2ddc:	02a4      	lsls	r4, r4, #10
	for(i=0;i<16;i++)
	{
		nvm_erase_row((unsigned long)(TEST_PAGE_ADDR+i*NVMCTRL_PAGE_SIZE));
    2dde:	4f0e      	ldr	r7, [pc, #56]	; (2e18 <nvds_erase+0x54>)
		ret = nvm_write_buffer((unsigned long)(TEST_PAGE_ADDR+i*NVMCTRL_PAGE_SIZE),
    2de0:	4e0b      	ldr	r6, [pc, #44]	; (2e10 <nvds_erase+0x4c>)
    2de2:	4d0e      	ldr	r5, [pc, #56]	; (2e1c <nvds_erase+0x58>)

	
	memset(NVDS_Data,0xff,sizeof(NVDS_Data));
	for(i=0;i<16;i++)
	{
		nvm_erase_row((unsigned long)(TEST_PAGE_ADDR+i*NVMCTRL_PAGE_SIZE));
    2de4:	0020      	movs	r0, r4
    2de6:	47b8      	blx	r7
		ret = nvm_write_buffer((unsigned long)(TEST_PAGE_ADDR+i*NVMCTRL_PAGE_SIZE),
    2de8:	4b0d      	ldr	r3, [pc, #52]	; (2e20 <nvds_erase+0x5c>)
    2dea:	18e1      	adds	r1, r4, r3
    2dec:	1989      	adds	r1, r1, r6
    2dee:	2240      	movs	r2, #64	; 0x40
    2df0:	0020      	movs	r0, r4
    2df2:	47a8      	blx	r5
    2df4:	3440      	adds	r4, #64	; 0x40

	DBG_LOG("nvds_erase start\r\n");

	
	memset(NVDS_Data,0xff,sizeof(NVDS_Data));
	for(i=0;i<16;i++)
    2df6:	2380      	movs	r3, #128	; 0x80
    2df8:	02db      	lsls	r3, r3, #11
    2dfa:	429c      	cmp	r4, r3
    2dfc:	d1f2      	bne.n	2de4 <nvds_erase+0x20>
		nvm_erase_row((unsigned long)(TEST_PAGE_ADDR+i*NVMCTRL_PAGE_SIZE));
		ret = nvm_write_buffer((unsigned long)(TEST_PAGE_ADDR+i*NVMCTRL_PAGE_SIZE),
		(uint8_t *)&NVDS_Data[i*NVMCTRL_PAGE_SIZE],
		NVMCTRL_PAGE_SIZE);
	}
}
    2dfe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2e00:	000140b0 	.word	0x000140b0
    2e04:	00011aad 	.word	0x00011aad
    2e08:	000139b8 	.word	0x000139b8
    2e0c:	000005dc 	.word	0x000005dc
    2e10:	20001c4c 	.word	0x20001c4c
    2e14:	00011845 	.word	0x00011845
    2e18:	000003a1 	.word	0x000003a1
    2e1c:	00000249 	.word	0x00000249
    2e20:	fffc0400 	.word	0xfffc0400

00002e24 <nvm_get_config_data>:


void nvm_get_config_data(wifi_nvm_data_t* config_data)
{
    2e24:	b5f0      	push	{r4, r5, r6, r7, lr}
    2e26:	b087      	sub	sp, #28
    2e28:	9001      	str	r0, [sp, #4]
	uint32_t i;
	//uint32_t len_buf=FLASH_PAGE_SIZE;
	//uint8_t read_buf[len_buf];

	
	DBG_LOG("nvds_read start\r\n");
    2e2a:	4e18      	ldr	r6, [pc, #96]	; (2e8c <nvm_get_config_data+0x68>)
    2e2c:	0030      	movs	r0, r6
    2e2e:	4c18      	ldr	r4, [pc, #96]	; (2e90 <nvm_get_config_data+0x6c>)
    2e30:	47a0      	blx	r4
    2e32:	4818      	ldr	r0, [pc, #96]	; (2e94 <nvm_get_config_data+0x70>)
    2e34:	47a0      	blx	r4
	//nvm_init();
	struct nvm_parameters parameters;
	nvm_get_parameters(&parameters);
    2e36:	a802      	add	r0, sp, #8
    2e38:	4b17      	ldr	r3, [pc, #92]	; (2e98 <nvm_get_config_data+0x74>)
    2e3a:	4798      	blx	r3
	DBG_LOG("nvm page_size = %d\n", parameters.page_size);
    2e3c:	0030      	movs	r0, r6
    2e3e:	47a0      	blx	r4
    2e40:	ab02      	add	r3, sp, #8
    2e42:	7819      	ldrb	r1, [r3, #0]
    2e44:	4815      	ldr	r0, [pc, #84]	; (2e9c <nvm_get_config_data+0x78>)
    2e46:	4f16      	ldr	r7, [pc, #88]	; (2ea0 <nvm_get_config_data+0x7c>)
    2e48:	47b8      	blx	r7
	DBG_LOG("nvm no_of_page = %d\n", parameters.nvm_number_of_pages);
    2e4a:	0030      	movs	r0, r6
    2e4c:	47a0      	blx	r4
    2e4e:	ab02      	add	r3, sp, #8
    2e50:	8859      	ldrh	r1, [r3, #2]
    2e52:	4814      	ldr	r0, [pc, #80]	; (2ea4 <nvm_get_config_data+0x80>)
    2e54:	47b8      	blx	r7
	
	memset(NVDS_Data,0,sizeof(NVDS_Data));
    2e56:	4a14      	ldr	r2, [pc, #80]	; (2ea8 <nvm_get_config_data+0x84>)
    2e58:	2100      	movs	r1, #0
    2e5a:	4814      	ldr	r0, [pc, #80]	; (2eac <nvm_get_config_data+0x88>)
    2e5c:	4b14      	ldr	r3, [pc, #80]	; (2eb0 <nvm_get_config_data+0x8c>)
    2e5e:	4798      	blx	r3
    2e60:	24ff      	movs	r4, #255	; 0xff
    2e62:	02a4      	lsls	r4, r4, #10

	for(i=0;i<16;i++)
	{
		nvm_read_buffer((unsigned long)(TEST_PAGE_ADDR+i*NVMCTRL_PAGE_SIZE),
    2e64:	4d11      	ldr	r5, [pc, #68]	; (2eac <nvm_get_config_data+0x88>)
    2e66:	4f13      	ldr	r7, [pc, #76]	; (2eb4 <nvm_get_config_data+0x90>)
	DBG_LOG("nvm page_size = %d\n", parameters.page_size);
	DBG_LOG("nvm no_of_page = %d\n", parameters.nvm_number_of_pages);
	
	memset(NVDS_Data,0,sizeof(NVDS_Data));

	for(i=0;i<16;i++)
    2e68:	2680      	movs	r6, #128	; 0x80
    2e6a:	02f6      	lsls	r6, r6, #11
	{
		nvm_read_buffer((unsigned long)(TEST_PAGE_ADDR+i*NVMCTRL_PAGE_SIZE),
    2e6c:	4b12      	ldr	r3, [pc, #72]	; (2eb8 <nvm_get_config_data+0x94>)
    2e6e:	18e1      	adds	r1, r4, r3
    2e70:	1949      	adds	r1, r1, r5
    2e72:	2240      	movs	r2, #64	; 0x40
    2e74:	0020      	movs	r0, r4
    2e76:	47b8      	blx	r7
    2e78:	3440      	adds	r4, #64	; 0x40
	DBG_LOG("nvm page_size = %d\n", parameters.page_size);
	DBG_LOG("nvm no_of_page = %d\n", parameters.nvm_number_of_pages);
	
	memset(NVDS_Data,0,sizeof(NVDS_Data));

	for(i=0;i<16;i++)
    2e7a:	42b4      	cmp	r4, r6
    2e7c:	d1f6      	bne.n	2e6c <nvm_get_config_data+0x48>
		nvm_read_buffer((unsigned long)(TEST_PAGE_ADDR+i*NVMCTRL_PAGE_SIZE),
		(uint8_t *)&NVDS_Data[i*NVMCTRL_PAGE_SIZE],
		NVMCTRL_PAGE_SIZE);
	}

	memcpy((uint8_t *)config_data,NVDS_Data,sizeof(wifi_nvm_data_t));
    2e7e:	22a2      	movs	r2, #162	; 0xa2
    2e80:	490a      	ldr	r1, [pc, #40]	; (2eac <nvm_get_config_data+0x88>)
    2e82:	9801      	ldr	r0, [sp, #4]
    2e84:	4b0d      	ldr	r3, [pc, #52]	; (2ebc <nvm_get_config_data+0x98>)
    2e86:	4798      	blx	r3
}
    2e88:	b007      	add	sp, #28
    2e8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2e8c:	000140b0 	.word	0x000140b0
    2e90:	00011aad 	.word	0x00011aad
    2e94:	000139cc 	.word	0x000139cc
    2e98:	0000041d 	.word	0x0000041d
    2e9c:	000139e0 	.word	0x000139e0
    2ea0:	0001198d 	.word	0x0001198d
    2ea4:	000139f4 	.word	0x000139f4
    2ea8:	000005dc 	.word	0x000005dc
    2eac:	20001c4c 	.word	0x20001c4c
    2eb0:	00011845 	.word	0x00011845
    2eb4:	0000031d 	.word	0x0000031d
    2eb8:	fffc0400 	.word	0xfffc0400
    2ebc:	00011833 	.word	0x00011833

00002ec0 <nvm_store_config_data>:


void nvm_store_config_data(wifi_nvm_data_t config_data)
{
    2ec0:	b084      	sub	sp, #16
    2ec2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2ec4:	9006      	str	r0, [sp, #24]
    2ec6:	9107      	str	r1, [sp, #28]
    2ec8:	9208      	str	r2, [sp, #32]
    2eca:	9309      	str	r3, [sp, #36]	; 0x24
	uint32_t delay = 0;
	uint32_t i;
	
	nvds_erase();
    2ecc:	4b16      	ldr	r3, [pc, #88]	; (2f28 <nvm_store_config_data+0x68>)
    2ece:	4798      	blx	r3
	//DBG_LOG("ble_device_count write:%d",ble_device_count);
	memset(NVDS_Data,0,sizeof(NVDS_Data));
    2ed0:	4f16      	ldr	r7, [pc, #88]	; (2f2c <nvm_store_config_data+0x6c>)
    2ed2:	4a17      	ldr	r2, [pc, #92]	; (2f30 <nvm_store_config_data+0x70>)
    2ed4:	2100      	movs	r1, #0
    2ed6:	0038      	movs	r0, r7
    2ed8:	4b16      	ldr	r3, [pc, #88]	; (2f34 <nvm_store_config_data+0x74>)
    2eda:	4798      	blx	r3
	//if(len<=FLASH_NVDS_SIZE)
	//	memcpy(NVDS_Data,data,len);
	DBG_LOG("nvds data len:%d",sizeof(wifi_nvm_data_t));
    2edc:	4e16      	ldr	r6, [pc, #88]	; (2f38 <nvm_store_config_data+0x78>)
    2ede:	0030      	movs	r0, r6
    2ee0:	4d16      	ldr	r5, [pc, #88]	; (2f3c <nvm_store_config_data+0x7c>)
    2ee2:	47a8      	blx	r5
    2ee4:	21a2      	movs	r1, #162	; 0xa2
    2ee6:	4816      	ldr	r0, [pc, #88]	; (2f40 <nvm_store_config_data+0x80>)
    2ee8:	4c16      	ldr	r4, [pc, #88]	; (2f44 <nvm_store_config_data+0x84>)
    2eea:	47a0      	blx	r4
	memcpy(NVDS_Data,(uint8_t *)&config_data,sizeof(wifi_nvm_data_t));
    2eec:	22a2      	movs	r2, #162	; 0xa2
    2eee:	a906      	add	r1, sp, #24
    2ef0:	0038      	movs	r0, r7
    2ef2:	4b15      	ldr	r3, [pc, #84]	; (2f48 <nvm_store_config_data+0x88>)
    2ef4:	4798      	blx	r3
	
	DBG_LOG("ssid = %s", config_data.ssid);
    2ef6:	0030      	movs	r0, r6
    2ef8:	47a8      	blx	r5
    2efa:	2119      	movs	r1, #25
    2efc:	4469      	add	r1, sp
    2efe:	4813      	ldr	r0, [pc, #76]	; (2f4c <nvm_store_config_data+0x8c>)
    2f00:	47a0      	blx	r4
    2f02:	24ff      	movs	r4, #255	; 0xff
    2f04:	02a4      	lsls	r4, r4, #10
	
	
	for(i=0;i<16;i++)
	{
		nvm_write_buffer((unsigned long)(TEST_PAGE_ADDR+i*NVMCTRL_PAGE_SIZE),
    2f06:	4f09      	ldr	r7, [pc, #36]	; (2f2c <nvm_store_config_data+0x6c>)
    2f08:	4e11      	ldr	r6, [pc, #68]	; (2f50 <nvm_store_config_data+0x90>)
	memcpy(NVDS_Data,(uint8_t *)&config_data,sizeof(wifi_nvm_data_t));
	
	DBG_LOG("ssid = %s", config_data.ssid);
	
	
	for(i=0;i<16;i++)
    2f0a:	2580      	movs	r5, #128	; 0x80
    2f0c:	02ed      	lsls	r5, r5, #11
	{
		nvm_write_buffer((unsigned long)(TEST_PAGE_ADDR+i*NVMCTRL_PAGE_SIZE),
    2f0e:	4b11      	ldr	r3, [pc, #68]	; (2f54 <nvm_store_config_data+0x94>)
    2f10:	18e1      	adds	r1, r4, r3
    2f12:	19c9      	adds	r1, r1, r7
    2f14:	2240      	movs	r2, #64	; 0x40
    2f16:	0020      	movs	r0, r4
    2f18:	47b0      	blx	r6
    2f1a:	3440      	adds	r4, #64	; 0x40
	memcpy(NVDS_Data,(uint8_t *)&config_data,sizeof(wifi_nvm_data_t));
	
	DBG_LOG("ssid = %s", config_data.ssid);
	
	
	for(i=0;i<16;i++)
    2f1c:	42ac      	cmp	r4, r5
    2f1e:	d1f6      	bne.n	2f0e <nvm_store_config_data+0x4e>
	}
	memset(&config_data,0,sizeof(wifi_nvm_data_t));
	memcpy((uint8_t *)&config_data,NVDS_Data,sizeof(wifi_nvm_data_t));
#endif
	
}
    2f20:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2f22:	bc08      	pop	{r3}
    2f24:	b004      	add	sp, #16
    2f26:	4718      	bx	r3
    2f28:	00002dc5 	.word	0x00002dc5
    2f2c:	20001c4c 	.word	0x20001c4c
    2f30:	000005dc 	.word	0x000005dc
    2f34:	00011845 	.word	0x00011845
    2f38:	000140b0 	.word	0x000140b0
    2f3c:	00011aad 	.word	0x00011aad
    2f40:	00013a0c 	.word	0x00013a0c
    2f44:	0001198d 	.word	0x0001198d
    2f48:	00011833 	.word	0x00011833
    2f4c:	00013a20 	.word	0x00013a20
    2f50:	00000249 	.word	0x00000249
    2f54:	fffc0400 	.word	0xfffc0400

00002f58 <veml60xx_init>:
#include <asf.h>
#include "veml60xx.h"
#include "conf_sensor.h"

enum status_code veml60xx_init(void)
{
    2f58:	b500      	push	{lr}
    2f5a:	b085      	sub	sp, #20
	
	uint8_t buffer[3];
	buffer[0] = VEML60xx_CONFIG_CMD_CODE;
    2f5c:	aa03      	add	r2, sp, #12
    2f5e:	2300      	movs	r3, #0
    2f60:	7013      	strb	r3, [r2, #0]
	buffer[1] = VEML60xx_INIT_VALUE_LSB;  //Config LSB value
    2f62:	7053      	strb	r3, [r2, #1]
	buffer[2] = VEML60xx_INIT_VALUE_MSB;
    2f64:	7093      	strb	r3, [r2, #2]
	
	enum status_code sensor_wr_status = STATUS_BUSY;
	
	/* Set up internal EEPROM addr write */
	struct i2c_master_packet sensor_wr_packet = {
    2f66:	2110      	movs	r1, #16
    2f68:	4668      	mov	r0, sp
    2f6a:	8001      	strh	r1, [r0, #0]
    2f6c:	390d      	subs	r1, #13
    2f6e:	8041      	strh	r1, [r0, #2]
    2f70:	9201      	str	r2, [sp, #4]
    2f72:	7203      	strb	r3, [r0, #8]
    2f74:	7243      	strb	r3, [r0, #9]
    2f76:	7283      	strb	r3, [r0, #10]
		.ten_bit_address = false,
		.high_speed      = false,
		.hs_master_code  = 0x0,
	};
	
	sensor_wr_status = i2c_master_write_packet_wait(&i2c_master_instance,&sensor_wr_packet);
    2f78:	4669      	mov	r1, sp
    2f7a:	4802      	ldr	r0, [pc, #8]	; (2f84 <veml60xx_init+0x2c>)
    2f7c:	4b02      	ldr	r3, [pc, #8]	; (2f88 <veml60xx_init+0x30>)
    2f7e:	4798      	blx	r3
	

	return sensor_wr_status;
}
    2f80:	b005      	add	sp, #20
    2f82:	bd00      	pop	{pc}
    2f84:	20001c04 	.word	0x20001c04
    2f88:	0000b279 	.word	0x0000b279

00002f8c <veml60xx_read_alsdata>:
#endif
/*---------------------------------------------*/
/*Function to read the ALS data from veml60xx*/
/*---------------------------------------------*/
enum status_code veml60xx_read_alsdata (uint16_t *als_data)
{
    2f8c:	b510      	push	{r4, lr}
    2f8e:	b088      	sub	sp, #32
    2f90:	0004      	movs	r4, r0
	
	enum status_code sensor_wr_status = STATUS_BUSY;
	enum status_code sensor_rd_status = STATUS_BUSY;
	uint8_t cmd = VEML60xx_ALSDATA_CMD_CODE;
    2f92:	231f      	movs	r3, #31
    2f94:	446b      	add	r3, sp
    2f96:	2204      	movs	r2, #4
    2f98:	701a      	strb	r2, [r3, #0]
	uint8_t buffer[2] = {0};
    2f9a:	2100      	movs	r1, #0
    2f9c:	aa07      	add	r2, sp, #28
    2f9e:	8011      	strh	r1, [r2, #0]
	uint16_t temp = 0;
	
	/* Set up internal EEPROM addr write */
	struct i2c_master_packet sensor_wr_packet = {
    2fa0:	a904      	add	r1, sp, #16
    2fa2:	2210      	movs	r2, #16
    2fa4:	800a      	strh	r2, [r1, #0]
    2fa6:	3a0f      	subs	r2, #15
    2fa8:	804a      	strh	r2, [r1, #2]
    2faa:	604b      	str	r3, [r1, #4]
    2fac:	2300      	movs	r3, #0
    2fae:	2200      	movs	r2, #0
    2fb0:	720a      	strb	r2, [r1, #8]
    2fb2:	724b      	strb	r3, [r1, #9]
    2fb4:	728b      	strb	r3, [r1, #10]
		.ten_bit_address = false,
		.high_speed      = false,
		.hs_master_code  = 0x0,
	};
	
	sensor_wr_status = i2c_master_write_packet_wait_no_stop(&i2c_master_instance,
    2fb6:	480e      	ldr	r0, [pc, #56]	; (2ff0 <veml60xx_read_alsdata+0x64>)
    2fb8:	4b0e      	ldr	r3, [pc, #56]	; (2ff4 <veml60xx_read_alsdata+0x68>)
    2fba:	4798      	blx	r3
    2fbc:	1e03      	subs	r3, r0, #0
	&sensor_wr_packet);
	
	if (sensor_wr_status != STATUS_OK){
    2fbe:	d115      	bne.n	2fec <veml60xx_read_alsdata+0x60>
		return sensor_wr_status;
	}
	
	/* Set up internal EEPROM addr write */
	struct i2c_master_packet sensor_rd_packet = {
    2fc0:	a901      	add	r1, sp, #4
    2fc2:	3310      	adds	r3, #16
    2fc4:	800b      	strh	r3, [r1, #0]
    2fc6:	3b0e      	subs	r3, #14
    2fc8:	804b      	strh	r3, [r1, #2]
    2fca:	ab07      	add	r3, sp, #28
    2fcc:	604b      	str	r3, [r1, #4]
    2fce:	2300      	movs	r3, #0
    2fd0:	720b      	strb	r3, [r1, #8]
    2fd2:	724b      	strb	r3, [r1, #9]
    2fd4:	728b      	strb	r3, [r1, #10]
		.ten_bit_address = false,
		.high_speed      = false,
		.hs_master_code  = 0x0,
	};
	
	sensor_rd_status = i2c_master_read_packet_wait(&i2c_master_instance,&sensor_rd_packet);
    2fd6:	4806      	ldr	r0, [pc, #24]	; (2ff0 <veml60xx_read_alsdata+0x64>)
    2fd8:	4b07      	ldr	r3, [pc, #28]	; (2ff8 <veml60xx_read_alsdata+0x6c>)
    2fda:	4798      	blx	r3
	
	if (sensor_rd_status != STATUS_OK){
    2fdc:	2800      	cmp	r0, #0
    2fde:	d105      	bne.n	2fec <veml60xx_read_alsdata+0x60>
		return sensor_rd_status;
	}
	
	temp = ((buffer[1] << 8) | buffer[0]);
    2fe0:	a907      	add	r1, sp, #28
	
	*als_data = temp;
    2fe2:	784b      	ldrb	r3, [r1, #1]
    2fe4:	021b      	lsls	r3, r3, #8
    2fe6:	7809      	ldrb	r1, [r1, #0]
    2fe8:	430b      	orrs	r3, r1
    2fea:	8023      	strh	r3, [r4, #0]
	
	return STATUS_OK;
	
    2fec:	b008      	add	sp, #32
    2fee:	bd10      	pop	{r4, pc}
    2ff0:	20001c04 	.word	0x20001c04
    2ff4:	0000b299 	.word	0x0000b299
    2ff8:	0000b259 	.word	0x0000b259

00002ffc <motionSensorCallbackHandler>:




static void motionSensorCallbackHandler(device_rotation_vector_t rotation_data, unsigned char flag)
{
    2ffc:	b5f0      	push	{r4, r5, r6, r7, lr}
    2ffe:	b0a9      	sub	sp, #164	; 0xa4
    3000:	000d      	movs	r5, r1
    3002:	466b      	mov	r3, sp
    3004:	80d9      	strh	r1, [r3, #6]
	cJSON* item;
	NodeInfo node_info[4];
	
	strcpy(node_info[0].dataType,ROTATION_W_DATATYPE_NAME);
    3006:	ab04      	add	r3, sp, #16
    3008:	4a14      	ldr	r2, [pc, #80]	; (305c <motionSensorCallbackHandler+0x60>)
    300a:	001e      	movs	r6, r3
    300c:	ca82      	ldmia	r2!, {r1, r7}
    300e:	c682      	stmia	r6!, {r1, r7}
	node_info[0].value = (int) rotation_data.w;
    3010:	142d      	asrs	r5, r5, #16
    3012:	621d      	str	r5, [r3, #32]
	strcpy(node_info[1].dataType,ROTATION_X_DATATYPE_NAME);
    3014:	ad0d      	add	r5, sp, #52	; 0x34
    3016:	4a12      	ldr	r2, [pc, #72]	; (3060 <motionSensorCallbackHandler+0x64>)
    3018:	ca42      	ldmia	r2!, {r1, r6}
    301a:	c542      	stmia	r5!, {r1, r6}
	node_info[1].value = (int) rotation_data.x;
    301c:	b204      	sxth	r4, r0
    301e:	645c      	str	r4, [r3, #68]	; 0x44
	strcpy(node_info[2].dataType,ROTATION_Y_DATATYPE_NAME);
    3020:	ac16      	add	r4, sp, #88	; 0x58
    3022:	4a10      	ldr	r2, [pc, #64]	; (3064 <motionSensorCallbackHandler+0x68>)
    3024:	ca22      	ldmia	r2!, {r1, r5}
    3026:	c422      	stmia	r4!, {r1, r5}
	node_info[2].value = (int) rotation_data.y;
    3028:	1400      	asrs	r0, r0, #16
    302a:	6698      	str	r0, [r3, #104]	; 0x68
	strcpy(node_info[3].dataType,ROTATION_Z_DATATYPE_NAME);
    302c:	a81f      	add	r0, sp, #124	; 0x7c
    302e:	4a0e      	ldr	r2, [pc, #56]	; (3068 <motionSensorCallbackHandler+0x6c>)
    3030:	ca12      	ldmia	r2!, {r1, r4}
    3032:	c012      	stmia	r0!, {r1, r4}
	node_info[3].value = (int) rotation_data.z;
    3034:	466a      	mov	r2, sp
    3036:	88d2      	ldrh	r2, [r2, #6]
    3038:	b211      	sxth	r1, r2
    303a:	228c      	movs	r2, #140	; 0x8c
    303c:	5099      	str	r1, [r3, r2]
	
	item = iot_message_reportInfo(DEVICE_TYPE, gAwsMqttClientId, 4, &node_info);
    303e:	3a88      	subs	r2, #136	; 0x88
    3040:	490a      	ldr	r1, [pc, #40]	; (306c <motionSensorCallbackHandler+0x70>)
    3042:	480b      	ldr	r0, [pc, #44]	; (3070 <motionSensorCallbackHandler+0x74>)
    3044:	4c0b      	ldr	r4, [pc, #44]	; (3074 <motionSensorCallbackHandler+0x78>)
    3046:	47a0      	blx	r4
    3048:	0004      	movs	r4, r0
	cloud_mqtt_publish(gPublish_Channel,item);
    304a:	0001      	movs	r1, r0
    304c:	480a      	ldr	r0, [pc, #40]	; (3078 <motionSensorCallbackHandler+0x7c>)
    304e:	4b0b      	ldr	r3, [pc, #44]	; (307c <motionSensorCallbackHandler+0x80>)
    3050:	4798      	blx	r3
	cJSON_Delete(item);
    3052:	0020      	movs	r0, r4
    3054:	4b0a      	ldr	r3, [pc, #40]	; (3080 <motionSensorCallbackHandler+0x84>)
    3056:	4798      	blx	r3

}
    3058:	b029      	add	sp, #164	; 0xa4
    305a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    305c:	00013ac4 	.word	0x00013ac4
    3060:	00013acc 	.word	0x00013acc
    3064:	00013ad4 	.word	0x00013ad4
    3068:	00013adc 	.word	0x00013adc
    306c:	20001a44 	.word	0x20001a44
    3070:	00013ae4 	.word	0x00013ae4
    3074:	000028b9 	.word	0x000028b9
    3078:	20001a54 	.word	0x20001a54
    307c:	00001e51 	.word	0x00001e51
    3080:	00001a59 	.word	0x00001a59

00003084 <EnvSensorCallbackHandler>:

static void EnvSensorCallbackHandler(environment_data_t sensor_data, unsigned char flag)
{
    3084:	b530      	push	{r4, r5, lr}
    3086:	b0a9      	sub	sp, #164	; 0xa4
    3088:	9001      	str	r0, [sp, #4]
    308a:	9102      	str	r1, [sp, #8]
    308c:	9203      	str	r2, [sp, #12]
	cJSON* item;
	NodeInfo node_info[4];
	int8_t cnt = 0;
    308e:	2200      	movs	r2, #0
	
	if (flag & TEMP_UPDATE_BIT)
    3090:	07d9      	lsls	r1, r3, #31
    3092:	d50a      	bpl.n	30aa <EnvSensorCallbackHandler+0x26>
	{
		strcpy(node_info[cnt].dataType,TEMP_DATATYPE_NAME);
    3094:	aa04      	add	r2, sp, #16
    3096:	492a      	ldr	r1, [pc, #168]	; (3140 <EnvSensorCallbackHandler+0xbc>)
    3098:	6808      	ldr	r0, [r1, #0]
    309a:	9004      	str	r0, [sp, #16]
    309c:	7909      	ldrb	r1, [r1, #4]
    309e:	7111      	strb	r1, [r2, #4]
		node_info[cnt].value = sensor_data.temperature;
    30a0:	a901      	add	r1, sp, #4
    30a2:	2000      	movs	r0, #0
    30a4:	5e09      	ldrsh	r1, [r1, r0]
    30a6:	910c      	str	r1, [sp, #48]	; 0x30
		cnt++;
    30a8:	2201      	movs	r2, #1
	}
	if (flag & HUM_UPDATE_BIT)
    30aa:	0799      	lsls	r1, r3, #30
    30ac:	d50b      	bpl.n	30c6 <EnvSensorCallbackHandler+0x42>
	{
		strcpy(node_info[cnt].dataType,HUM_DATATYPE_NAME);
    30ae:	ac04      	add	r4, sp, #16
    30b0:	00d1      	lsls	r1, r2, #3
    30b2:	1888      	adds	r0, r1, r2
    30b4:	0080      	lsls	r0, r0, #2
    30b6:	4d23      	ldr	r5, [pc, #140]	; (3144 <EnvSensorCallbackHandler+0xc0>)
    30b8:	5025      	str	r5, [r4, r0]
		node_info[cnt].value = sensor_data.humidity;
    30ba:	1821      	adds	r1, r4, r0
    30bc:	a801      	add	r0, sp, #4
    30be:	7a00      	ldrb	r0, [r0, #8]
    30c0:	6208      	str	r0, [r1, #32]
		cnt++;
    30c2:	3201      	adds	r2, #1
    30c4:	b252      	sxtb	r2, r2
	}
	if (flag & UV_UPDATE_BIT)
    30c6:	0759      	lsls	r1, r3, #29
    30c8:	d511      	bpl.n	30ee <EnvSensorCallbackHandler+0x6a>
	{
		strcpy(node_info[cnt].dataType,UV_DATATYPE_NAME);
    30ca:	00d1      	lsls	r1, r2, #3
    30cc:	1888      	adds	r0, r1, r2
    30ce:	0080      	lsls	r0, r0, #2
    30d0:	ac04      	add	r4, sp, #16
    30d2:	46a4      	mov	ip, r4
    30d4:	4460      	add	r0, ip
    30d6:	4c1c      	ldr	r4, [pc, #112]	; (3148 <EnvSensorCallbackHandler+0xc4>)
    30d8:	8825      	ldrh	r5, [r4, #0]
    30da:	8005      	strh	r5, [r0, #0]
    30dc:	78a4      	ldrb	r4, [r4, #2]
    30de:	7084      	strb	r4, [r0, #2]
		node_info[cnt].value = sensor_data.uv;
    30e0:	1889      	adds	r1, r1, r2
    30e2:	0089      	lsls	r1, r1, #2
    30e4:	4461      	add	r1, ip
    30e6:	9802      	ldr	r0, [sp, #8]
    30e8:	6208      	str	r0, [r1, #32]
		cnt++;
    30ea:	3201      	adds	r2, #1
    30ec:	b252      	sxtb	r2, r2
	}
	if (flag & PRESSURE_UPDATE_BIT)
    30ee:	071b      	lsls	r3, r3, #28
    30f0:	d513      	bpl.n	311a <EnvSensorCallbackHandler+0x96>
	{
		strcpy(node_info[cnt].dataType,PRESSURE_DATATYPE_NAME);
    30f2:	00d3      	lsls	r3, r2, #3
    30f4:	1899      	adds	r1, r3, r2
    30f6:	0089      	lsls	r1, r1, #2
    30f8:	a804      	add	r0, sp, #16
    30fa:	4684      	mov	ip, r0
    30fc:	4461      	add	r1, ip
    30fe:	4813      	ldr	r0, [pc, #76]	; (314c <EnvSensorCallbackHandler+0xc8>)
    3100:	c830      	ldmia	r0!, {r4, r5}
    3102:	c130      	stmia	r1!, {r4, r5}
    3104:	000c      	movs	r4, r1
    3106:	7801      	ldrb	r1, [r0, #0]
    3108:	7021      	strb	r1, [r4, #0]
		node_info[cnt].value = sensor_data.pressure;
    310a:	189b      	adds	r3, r3, r2
    310c:	009b      	lsls	r3, r3, #2
    310e:	4463      	add	r3, ip
    3110:	a901      	add	r1, sp, #4
    3112:	8849      	ldrh	r1, [r1, #2]
    3114:	6219      	str	r1, [r3, #32]
		cnt++;
    3116:	3201      	adds	r2, #1
    3118:	b252      	sxtb	r2, r2
	}
	
	item = iot_message_reportInfo(DEVICE_TYPE, gAwsMqttClientId, cnt, &node_info);
    311a:	ab04      	add	r3, sp, #16
    311c:	490c      	ldr	r1, [pc, #48]	; (3150 <EnvSensorCallbackHandler+0xcc>)
    311e:	480d      	ldr	r0, [pc, #52]	; (3154 <EnvSensorCallbackHandler+0xd0>)
    3120:	4c0d      	ldr	r4, [pc, #52]	; (3158 <EnvSensorCallbackHandler+0xd4>)
    3122:	47a0      	blx	r4
    3124:	0004      	movs	r4, r0
	cloud_mqtt_publish(gPublish_Channel,item);
    3126:	0001      	movs	r1, r0
    3128:	480c      	ldr	r0, [pc, #48]	; (315c <EnvSensorCallbackHandler+0xd8>)
    312a:	4d0d      	ldr	r5, [pc, #52]	; (3160 <EnvSensorCallbackHandler+0xdc>)
    312c:	47a8      	blx	r5
	cloud_mqtt_publish(gSearchResp_Channel,item);
    312e:	0021      	movs	r1, r4
    3130:	480c      	ldr	r0, [pc, #48]	; (3164 <EnvSensorCallbackHandler+0xe0>)
    3132:	47a8      	blx	r5
	cJSON_Delete(item);
    3134:	0020      	movs	r0, r4
    3136:	4b0c      	ldr	r3, [pc, #48]	; (3168 <EnvSensorCallbackHandler+0xe4>)
    3138:	4798      	blx	r3
}
    313a:	b029      	add	sp, #164	; 0xa4
    313c:	bd30      	pop	{r4, r5, pc}
    313e:	46c0      	nop			; (mov r8, r8)
    3140:	00013930 	.word	0x00013930
    3144:	006d7568 	.word	0x006d7568
    3148:	00013938 	.word	0x00013938
    314c:	00013af4 	.word	0x00013af4
    3150:	20001a44 	.word	0x20001a44
    3154:	00013ae4 	.word	0x00013ae4
    3158:	000028b9 	.word	0x000028b9
    315c:	20001a54 	.word	0x20001a54
    3160:	00001e51 	.word	0x00001e51
    3164:	20001a90 	.word	0x20001a90
    3168:	00001a59 	.word	0x00001a59

0000316c <wifiSwitchtoSTA>:
	}
}


static void wifiSwitchtoSTA(void)
{
    316c:	b510      	push	{r4, lr}
    316e:	b082      	sub	sp, #8

static void close_app_socket(void)
{
	int8_t ret = M2M_SUCCESS;

	if (provServerSocket != -1) {
    3170:	4b28      	ldr	r3, [pc, #160]	; (3214 <wifiSwitchtoSTA+0xa8>)
    3172:	2000      	movs	r0, #0
    3174:	5618      	ldrsb	r0, [r3, r0]
    3176:	1c43      	adds	r3, r0, #1
    3178:	d00a      	beq.n	3190 <wifiSwitchtoSTA+0x24>
		ret = close(provServerSocket);
    317a:	4b27      	ldr	r3, [pc, #156]	; (3218 <wifiSwitchtoSTA+0xac>)
    317c:	4798      	blx	r3
    317e:	0002      	movs	r2, r0
		printf("[AP] TCP server socket %d closed %d!\r\n", provServerSocket, ret);
    3180:	4c24      	ldr	r4, [pc, #144]	; (3214 <wifiSwitchtoSTA+0xa8>)
    3182:	2100      	movs	r1, #0
    3184:	5661      	ldrsb	r1, [r4, r1]
    3186:	4825      	ldr	r0, [pc, #148]	; (321c <wifiSwitchtoSTA+0xb0>)
    3188:	4b25      	ldr	r3, [pc, #148]	; (3220 <wifiSwitchtoSTA+0xb4>)
    318a:	4798      	blx	r3
		provServerSocket = -1;
    318c:	23ff      	movs	r3, #255	; 0xff
    318e:	7023      	strb	r3, [r4, #0]
static void wifiSwitchtoSTA(void)
{
	int8_t ret;
	
	close_app_socket();
	if (gAPEnabled) {
    3190:	4b24      	ldr	r3, [pc, #144]	; (3224 <wifiSwitchtoSTA+0xb8>)
    3192:	781b      	ldrb	r3, [r3, #0]
    3194:	2b00      	cmp	r3, #0
    3196:	d011      	beq.n	31bc <wifiSwitchtoSTA+0x50>
		ret = m2m_wifi_disable_ap();
    3198:	4b23      	ldr	r3, [pc, #140]	; (3228 <wifiSwitchtoSTA+0xbc>)
    319a:	4798      	blx	r3
		if (M2M_SUCCESS != ret) {
    319c:	2800      	cmp	r0, #0
    319e:	d003      	beq.n	31a8 <wifiSwitchtoSTA+0x3c>
			printf("main: m2m_wifi_disable_ap call error!\r\n");
    31a0:	4822      	ldr	r0, [pc, #136]	; (322c <wifiSwitchtoSTA+0xc0>)
    31a2:	4b23      	ldr	r3, [pc, #140]	; (3230 <wifiSwitchtoSTA+0xc4>)
    31a4:	4798      	blx	r3
			return;
    31a6:	e032      	b.n	320e <wifiSwitchtoSTA+0xa2>
		}
		else {
			printf("main: m2m_wifi_disable_ap call success!\r\n");
    31a8:	4822      	ldr	r0, [pc, #136]	; (3234 <wifiSwitchtoSTA+0xc8>)
    31aa:	4b21      	ldr	r3, [pc, #132]	; (3230 <wifiSwitchtoSTA+0xc4>)
    31ac:	4798      	blx	r3
		}
		gAPEnabled = 0;
    31ae:	2200      	movs	r2, #0
    31b0:	4b1c      	ldr	r3, [pc, #112]	; (3224 <wifiSwitchtoSTA+0xb8>)
    31b2:	701a      	strb	r2, [r3, #0]
		nm_bsp_sleep(500);
    31b4:	20fa      	movs	r0, #250	; 0xfa
    31b6:	0040      	lsls	r0, r0, #1
    31b8:	4b1f      	ldr	r3, [pc, #124]	; (3238 <wifiSwitchtoSTA+0xcc>)
    31ba:	4798      	blx	r3
	}
	if (wifi_states == WIFI_TASK_AP_CONNECTED) {
    31bc:	4b1f      	ldr	r3, [pc, #124]	; (323c <wifiSwitchtoSTA+0xd0>)
    31be:	781b      	ldrb	r3, [r3, #0]
    31c0:	2b08      	cmp	r3, #8
    31c2:	d106      	bne.n	31d2 <wifiSwitchtoSTA+0x66>
		// If there is station connected, wait M2M_WIFI_DISCONNECTED event
		printf("main: WIFI_TASK_SWITCHING_TO_STA\r\n");
    31c4:	481e      	ldr	r0, [pc, #120]	; (3240 <wifiSwitchtoSTA+0xd4>)
    31c6:	4b1a      	ldr	r3, [pc, #104]	; (3230 <wifiSwitchtoSTA+0xc4>)
    31c8:	4798      	blx	r3
		wifi_states = WIFI_TASK_SWITCHING_TO_STA;
    31ca:	2201      	movs	r2, #1
    31cc:	4b1b      	ldr	r3, [pc, #108]	; (323c <wifiSwitchtoSTA+0xd0>)
    31ce:	701a      	strb	r2, [r3, #0]
    31d0:	e01d      	b.n	320e <wifiSwitchtoSTA+0xa2>
	}
	else {
		printf("main: m2m_wifi_connect \r\n");
    31d2:	481c      	ldr	r0, [pc, #112]	; (3244 <wifiSwitchtoSTA+0xd8>)
    31d4:	4b16      	ldr	r3, [pc, #88]	; (3230 <wifiSwitchtoSTA+0xc4>)
    31d6:	4798      	blx	r3
		ret = m2m_wifi_connect((char *)gDefaultSSID, strlen((char *)gDefaultSSID), \
    31d8:	4c1b      	ldr	r4, [pc, #108]	; (3248 <wifiSwitchtoSTA+0xdc>)
    31da:	0020      	movs	r0, r4
    31dc:	4b1b      	ldr	r3, [pc, #108]	; (324c <wifiSwitchtoSTA+0xe0>)
    31de:	4798      	blx	r3
    31e0:	4b1b      	ldr	r3, [pc, #108]	; (3250 <wifiSwitchtoSTA+0xe4>)
    31e2:	781a      	ldrb	r2, [r3, #0]
    31e4:	b2c1      	uxtb	r1, r0
    31e6:	23ff      	movs	r3, #255	; 0xff
    31e8:	9300      	str	r3, [sp, #0]
    31ea:	4b1a      	ldr	r3, [pc, #104]	; (3254 <wifiSwitchtoSTA+0xe8>)
    31ec:	0020      	movs	r0, r4
    31ee:	4c1a      	ldr	r4, [pc, #104]	; (3258 <wifiSwitchtoSTA+0xec>)
    31f0:	47a0      	blx	r4
		gAuthType, (char *)gDefaultKey, M2M_WIFI_CH_ALL);
		if (M2M_SUCCESS != ret) {
    31f2:	2800      	cmp	r0, #0
    31f4:	d003      	beq.n	31fe <wifiSwitchtoSTA+0x92>
			printf("main: m2m_wifi_connect call error!\r\n");
    31f6:	4819      	ldr	r0, [pc, #100]	; (325c <wifiSwitchtoSTA+0xf0>)
    31f8:	4b0d      	ldr	r3, [pc, #52]	; (3230 <wifiSwitchtoSTA+0xc4>)
    31fa:	4798      	blx	r3
    31fc:	e7fe      	b.n	31fc <wifiSwitchtoSTA+0x90>
			while (1) {
			}
		}
		gu8WiFiMode = APP_STA;
    31fe:	2300      	movs	r3, #0
    3200:	4a17      	ldr	r2, [pc, #92]	; (3260 <wifiSwitchtoSTA+0xf4>)
    3202:	7013      	strb	r3, [r2, #0]
		wifi_states = WIFI_TASK_IDLE;
    3204:	4a0d      	ldr	r2, [pc, #52]	; (323c <wifiSwitchtoSTA+0xd0>)
    3206:	7013      	strb	r3, [r2, #0]
		set_prov_state(STA_INIT);
    3208:	2004      	movs	r0, #4
    320a:	4b16      	ldr	r3, [pc, #88]	; (3264 <wifiSwitchtoSTA+0xf8>)
    320c:	4798      	blx	r3
	}
}
    320e:	b002      	add	sp, #8
    3210:	bd10      	pop	{r4, pc}
    3212:	46c0      	nop			; (mov r8, r8)
    3214:	2000010c 	.word	0x2000010c
    3218:	00007141 	.word	0x00007141
    321c:	00013b00 	.word	0x00013b00
    3220:	0001198d 	.word	0x0001198d
    3224:	200002e7 	.word	0x200002e7
    3228:	000053b9 	.word	0x000053b9
    322c:	00013b28 	.word	0x00013b28
    3230:	00011aad 	.word	0x00011aad
    3234:	00013b50 	.word	0x00013b50
    3238:	00003e6d 	.word	0x00003e6d
    323c:	2000010d 	.word	0x2000010d
    3240:	00013b7c 	.word	0x00013b7c
    3244:	00013ba0 	.word	0x00013ba0
    3248:	200008a4 	.word	0x200008a4
    324c:	00011d75 	.word	0x00011d75
    3250:	200002e8 	.word	0x200002e8
    3254:	200001f8 	.word	0x200001f8
    3258:	00005365 	.word	0x00005365
    325c:	00013bbc 	.word	0x00013bbc
    3260:	20000864 	.word	0x20000864
    3264:	000021b1 	.word	0x000021b1

00003268 <wifi_cb>:
 * \param[in] pvMsg A pointer to a buffer containing the notification parameters
 * (if any). It should be casted to the correct data type corresponding to the
 * notification type.
 */
static void wifi_cb(uint8_t u8MsgType, void *pvMsg)
{
    3268:	b5f0      	push	{r4, r5, r6, r7, lr}
    326a:	b087      	sub	sp, #28
	switch (u8MsgType) {
    326c:	282c      	cmp	r0, #44	; 0x2c
    326e:	d005      	beq.n	327c <wifi_cb+0x14>
    3270:	2832      	cmp	r0, #50	; 0x32
    3272:	d039      	beq.n	32e8 <wifi_cb+0x80>
    3274:	281b      	cmp	r0, #27
    3276:	d000      	beq.n	327a <wifi_cb+0x12>
    3278:	e0a5      	b.n	33c6 <wifi_cb+0x15e>
    327a:	e09b      	b.n	33b4 <wifi_cb+0x14c>
	case M2M_WIFI_RESP_CON_STATE_CHANGED:
	{
		tstrM2mWifiStateChanged *pstrWifiState = (tstrM2mWifiStateChanged *)pvMsg;
		if (pstrWifiState->u8CurrState == M2M_WIFI_CONNECTED) {
    327c:	780b      	ldrb	r3, [r1, #0]
    327e:	2b01      	cmp	r3, #1
    3280:	d105      	bne.n	328e <wifi_cb+0x26>
			printf("wifi_cb: M2M_WIFI_RESP_CON_STATE_CHANGED: CONNECTED\r\n");
    3282:	4852      	ldr	r0, [pc, #328]	; (33cc <wifi_cb+0x164>)
    3284:	4b52      	ldr	r3, [pc, #328]	; (33d0 <wifi_cb+0x168>)
    3286:	4798      	blx	r3
			m2m_wifi_request_dhcp_client();
    3288:	4b52      	ldr	r3, [pc, #328]	; (33d4 <wifi_cb+0x16c>)
    328a:	4798      	blx	r3
    328c:	e09b      	b.n	33c6 <wifi_cb+0x15e>
		} else if (pstrWifiState->u8CurrState == M2M_WIFI_DISCONNECTED) {
    328e:	2b00      	cmp	r3, #0
    3290:	d000      	beq.n	3294 <wifi_cb+0x2c>
    3292:	e098      	b.n	33c6 <wifi_cb+0x15e>
			printf("wifi_cb: M2M_WIFI_RESP_CON_STATE_CHANGED: DISCONNECTED\r\n");
    3294:	4850      	ldr	r0, [pc, #320]	; (33d8 <wifi_cb+0x170>)
    3296:	4b4e      	ldr	r3, [pc, #312]	; (33d0 <wifi_cb+0x168>)
    3298:	4798      	blx	r3
			if (gu8WiFiMode == APP_AP)
    329a:	4b50      	ldr	r3, [pc, #320]	; (33dc <wifi_cb+0x174>)
    329c:	781b      	ldrb	r3, [r3, #0]
    329e:	2b01      	cmp	r3, #1
    32a0:	d111      	bne.n	32c6 <wifi_cb+0x5e>
			{
				if (wifi_states == WIFI_TASK_SWITCHING_TO_STA) {
    32a2:	4b4f      	ldr	r3, [pc, #316]	; (33e0 <wifi_cb+0x178>)
    32a4:	781b      	ldrb	r3, [r3, #0]
    32a6:	2b01      	cmp	r3, #1
    32a8:	d000      	beq.n	32ac <wifi_cb+0x44>
    32aa:	e08c      	b.n	33c6 <wifi_cb+0x15e>
					wifi_states = WIFI_TASK_STA_DISCONNECTED;
    32ac:	2209      	movs	r2, #9
    32ae:	4b4c      	ldr	r3, [pc, #304]	; (33e0 <wifi_cb+0x178>)
    32b0:	701a      	strb	r2, [r3, #0]
					printf("Switching to STA mode!\r\n");
    32b2:	484c      	ldr	r0, [pc, #304]	; (33e4 <wifi_cb+0x17c>)
    32b4:	4b46      	ldr	r3, [pc, #280]	; (33d0 <wifi_cb+0x168>)
    32b6:	4798      	blx	r3
					led_ctrl_set_color(LED_COLOR_BLUE, LED_MODE_BLINK_NORMAL);
    32b8:	2103      	movs	r1, #3
    32ba:	2000      	movs	r0, #0
    32bc:	4b4a      	ldr	r3, [pc, #296]	; (33e8 <wifi_cb+0x180>)
    32be:	4798      	blx	r3
					wifiSwitchtoSTA();	// Switch to STA mode if required
    32c0:	4b4a      	ldr	r3, [pc, #296]	; (33ec <wifi_cb+0x184>)
    32c2:	4798      	blx	r3
    32c4:	e07f      	b.n	33c6 <wifi_cb+0x15e>
				}
			}
			else
			{
				gbConnectedWifi = false;
    32c6:	2200      	movs	r2, #0
    32c8:	4b49      	ldr	r3, [pc, #292]	; (33f0 <wifi_cb+0x188>)
    32ca:	701a      	strb	r2, [r3, #0]
				m2m_wifi_connect((char *)gDefaultSSID, strlen((char *)gDefaultSSID), \
    32cc:	4c49      	ldr	r4, [pc, #292]	; (33f4 <wifi_cb+0x18c>)
    32ce:	0020      	movs	r0, r4
    32d0:	4b49      	ldr	r3, [pc, #292]	; (33f8 <wifi_cb+0x190>)
    32d2:	4798      	blx	r3
    32d4:	4b49      	ldr	r3, [pc, #292]	; (33fc <wifi_cb+0x194>)
    32d6:	781a      	ldrb	r2, [r3, #0]
    32d8:	b2c1      	uxtb	r1, r0
    32da:	23ff      	movs	r3, #255	; 0xff
    32dc:	9300      	str	r3, [sp, #0]
    32de:	4b48      	ldr	r3, [pc, #288]	; (3400 <wifi_cb+0x198>)
    32e0:	0020      	movs	r0, r4
    32e2:	4c48      	ldr	r4, [pc, #288]	; (3404 <wifi_cb+0x19c>)
    32e4:	47a0      	blx	r4
    32e6:	e06e      	b.n	33c6 <wifi_cb+0x15e>

	case M2M_WIFI_REQ_DHCP_CONF:
	{
		uint8_t *pu8IPAddress = (uint8_t *)pvMsg;
		/* Turn LED0 on to declare that IP address received. */
		printf("wifi_cb: M2M_WIFI_REQ_DHCP_CONF: IP is %u.%u.%u.%u\r\n",
    32e8:	788b      	ldrb	r3, [r1, #2]
    32ea:	784a      	ldrb	r2, [r1, #1]
    32ec:	7808      	ldrb	r0, [r1, #0]
    32ee:	78c9      	ldrb	r1, [r1, #3]
    32f0:	9100      	str	r1, [sp, #0]
    32f2:	0001      	movs	r1, r0
    32f4:	4844      	ldr	r0, [pc, #272]	; (3408 <wifi_cb+0x1a0>)
    32f6:	4c45      	ldr	r4, [pc, #276]	; (340c <wifi_cb+0x1a4>)
    32f8:	47a0      	blx	r4
				pu8IPAddress[0], pu8IPAddress[1], pu8IPAddress[2], pu8IPAddress[3]);
		gbConnectedWifi = true;
    32fa:	2201      	movs	r2, #1
    32fc:	4b3c      	ldr	r3, [pc, #240]	; (33f0 <wifi_cb+0x188>)
    32fe:	701a      	strb	r2, [r3, #0]

		led_ctrl_set_mode(LED_MODE_BLINK_FAST);
    3300:	2004      	movs	r0, #4
    3302:	4b43      	ldr	r3, [pc, #268]	; (3410 <wifi_cb+0x1a8>)
    3304:	4798      	blx	r3
		/* Obtain the IP Address by network name */
		///gethostbyname((uint8_t *)HostAddress);
		if (gu8WiFiMode == APP_AP)
    3306:	4b35      	ldr	r3, [pc, #212]	; (33dc <wifi_cb+0x174>)
    3308:	781b      	ldrb	r3, [r3, #0]
    330a:	2b01      	cmp	r3, #1
    330c:	d14f      	bne.n	33ae <wifi_cb+0x146>
{
	struct sockaddr_in	addr;
	int ret = -1;
	
	/* TCP Server. */
	if(provServerSocket == -1) {
    330e:	4b41      	ldr	r3, [pc, #260]	; (3414 <wifi_cb+0x1ac>)
    3310:	2000      	movs	r0, #0
    3312:	5618      	ldrsb	r0, [r3, r0]
    3314:	1c43      	adds	r3, r0, #1
    3316:	d142      	bne.n	339e <wifi_cb+0x136>
		if((provServerSocket = socket(AF_INET, SOCK_STREAM, 0)) >= 0) {
    3318:	2200      	movs	r2, #0
    331a:	2101      	movs	r1, #1
    331c:	3003      	adds	r0, #3
    331e:	4b3e      	ldr	r3, [pc, #248]	; (3418 <wifi_cb+0x1b0>)
    3320:	4798      	blx	r3
    3322:	4b3c      	ldr	r3, [pc, #240]	; (3414 <wifi_cb+0x1ac>)
    3324:	7018      	strb	r0, [r3, #0]
    3326:	2800      	cmp	r0, #0
    3328:	db2f      	blt.n	338a <wifi_cb+0x122>
			// Initialize socket address structure.
			addr.sin_family      = AF_INET;
    332a:	a902      	add	r1, sp, #8
    332c:	2302      	movs	r3, #2
    332e:	800b      	strh	r3, [r1, #0]
			addr.sin_port        = _htons(AP_TCP_SERVER_PORT);
    3330:	4b3a      	ldr	r3, [pc, #232]	; (341c <wifi_cb+0x1b4>)
    3332:	804b      	strh	r3, [r1, #2]
			addr.sin_addr.s_addr = 0;
    3334:	2300      	movs	r3, #0
    3336:	604b      	str	r3, [r1, #4]

			if((ret = bind(provServerSocket, (struct sockaddr*)&addr, sizeof(addr))) == 0) {
    3338:	2210      	movs	r2, #16
    333a:	4b39      	ldr	r3, [pc, #228]	; (3420 <wifi_cb+0x1b8>)
    333c:	4798      	blx	r3
    333e:	1e04      	subs	r4, r0, #0
    3340:	d109      	bne.n	3356 <wifi_cb+0xee>
				M2M_INFO("[AP] TCP socket bind success!\r\n");
    3342:	4838      	ldr	r0, [pc, #224]	; (3424 <wifi_cb+0x1bc>)
    3344:	4b31      	ldr	r3, [pc, #196]	; (340c <wifi_cb+0x1a4>)
    3346:	4798      	blx	r3
    3348:	4837      	ldr	r0, [pc, #220]	; (3428 <wifi_cb+0x1c0>)
    334a:	4b21      	ldr	r3, [pc, #132]	; (33d0 <wifi_cb+0x168>)
    334c:	4798      	blx	r3
    334e:	200d      	movs	r0, #13
    3350:	4b36      	ldr	r3, [pc, #216]	; (342c <wifi_cb+0x1c4>)
    3352:	4798      	blx	r3
    3354:	e027      	b.n	33a6 <wifi_cb+0x13e>
			}
			else {
				M2M_INFO("[AP] Bind Failed. Error code = %d\r\n", ret);
    3356:	4e33      	ldr	r6, [pc, #204]	; (3424 <wifi_cb+0x1bc>)
    3358:	0030      	movs	r0, r6
    335a:	4d2c      	ldr	r5, [pc, #176]	; (340c <wifi_cb+0x1a4>)
    335c:	47a8      	blx	r5
    335e:	0021      	movs	r1, r4
    3360:	4833      	ldr	r0, [pc, #204]	; (3430 <wifi_cb+0x1c8>)
    3362:	47a8      	blx	r5
    3364:	200d      	movs	r0, #13
    3366:	4f31      	ldr	r7, [pc, #196]	; (342c <wifi_cb+0x1c4>)
    3368:	47b8      	blx	r7
				close(provServerSocket);
    336a:	4c2a      	ldr	r4, [pc, #168]	; (3414 <wifi_cb+0x1ac>)
    336c:	2000      	movs	r0, #0
    336e:	5620      	ldrsb	r0, [r4, r0]
    3370:	4b30      	ldr	r3, [pc, #192]	; (3434 <wifi_cb+0x1cc>)
    3372:	4798      	blx	r3
				M2M_INFO("[AP] TCP server socket %d closed!\r\n", provServerSocket);
    3374:	0030      	movs	r0, r6
    3376:	47a8      	blx	r5
    3378:	2100      	movs	r1, #0
    337a:	5661      	ldrsb	r1, [r4, r1]
    337c:	482e      	ldr	r0, [pc, #184]	; (3438 <wifi_cb+0x1d0>)
    337e:	47a8      	blx	r5
    3380:	200d      	movs	r0, #13
    3382:	47b8      	blx	r7
				provServerSocket = -1;
    3384:	23ff      	movs	r3, #255	; 0xff
    3386:	7023      	strb	r3, [r4, #0]
    3388:	e00d      	b.n	33a6 <wifi_cb+0x13e>
			}
		}
		else {
			M2M_INFO("[AP] TCP Server Socket Creation Failed\r\n");
    338a:	4826      	ldr	r0, [pc, #152]	; (3424 <wifi_cb+0x1bc>)
    338c:	4b1f      	ldr	r3, [pc, #124]	; (340c <wifi_cb+0x1a4>)
    338e:	4798      	blx	r3
    3390:	482a      	ldr	r0, [pc, #168]	; (343c <wifi_cb+0x1d4>)
    3392:	4b0f      	ldr	r3, [pc, #60]	; (33d0 <wifi_cb+0x168>)
    3394:	4798      	blx	r3
    3396:	200d      	movs	r0, #13
    3398:	4b24      	ldr	r3, [pc, #144]	; (342c <wifi_cb+0x1c4>)
    339a:	4798      	blx	r3
    339c:	e003      	b.n	33a6 <wifi_cb+0x13e>
			return;
		}
	}
	else {
		accept(provServerSocket, NULL, 0);
    339e:	2200      	movs	r2, #0
    33a0:	2100      	movs	r1, #0
    33a2:	4b27      	ldr	r3, [pc, #156]	; (3440 <wifi_cb+0x1d8>)
    33a4:	4798      	blx	r3
		/* Obtain the IP Address by network name */
		///gethostbyname((uint8_t *)HostAddress);
		if (gu8WiFiMode == APP_AP)
		{
			start_AP_app();
			wifi_states = WIFI_TASK_AP_CONNECTED;
    33a6:	2208      	movs	r2, #8
    33a8:	4b0d      	ldr	r3, [pc, #52]	; (33e0 <wifi_cb+0x178>)
    33aa:	701a      	strb	r2, [r3, #0]
    33ac:	e00b      	b.n	33c6 <wifi_cb+0x15e>
		}
		else
			m2m_wifi_get_sytem_time();
    33ae:	4b25      	ldr	r3, [pc, #148]	; (3444 <wifi_cb+0x1dc>)
    33b0:	4798      	blx	r3
    33b2:	e008      	b.n	33c6 <wifi_cb+0x15e>
		break;
	}
	
	case M2M_WIFI_RESP_GET_SYS_TIME:
	{
		printf("Received time\r\n");
    33b4:	4824      	ldr	r0, [pc, #144]	; (3448 <wifi_cb+0x1e0>)
    33b6:	4b06      	ldr	r3, [pc, #24]	; (33d0 <wifi_cb+0x168>)
    33b8:	4798      	blx	r3
		receivedTime = true;
    33ba:	2201      	movs	r2, #1
    33bc:	4b23      	ldr	r3, [pc, #140]	; (344c <wifi_cb+0x1e4>)
    33be:	701a      	strb	r2, [r3, #0]
		wifi_states = WIFI_TASK_CONNECT_CLOUD;
    33c0:	3201      	adds	r2, #1
    33c2:	4b07      	ldr	r3, [pc, #28]	; (33e0 <wifi_cb+0x178>)
    33c4:	701a      	strb	r2, [r3, #0]
	default:
	{
		break;
	}
	}
}
    33c6:	b007      	add	sp, #28
    33c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    33ca:	46c0      	nop			; (mov r8, r8)
    33cc:	00013be0 	.word	0x00013be0
    33d0:	00011aad 	.word	0x00011aad
    33d4:	00005381 	.word	0x00005381
    33d8:	00013c18 	.word	0x00013c18
    33dc:	20000864 	.word	0x20000864
    33e0:	2000010d 	.word	0x2000010d
    33e4:	00013c50 	.word	0x00013c50
    33e8:	00002b19 	.word	0x00002b19
    33ec:	0000316d 	.word	0x0000316d
    33f0:	200001f7 	.word	0x200001f7
    33f4:	200008a4 	.word	0x200008a4
    33f8:	00011d75 	.word	0x00011d75
    33fc:	200002e8 	.word	0x200002e8
    3400:	200001f8 	.word	0x200001f8
    3404:	00005365 	.word	0x00005365
    3408:	00013c68 	.word	0x00013c68
    340c:	0001198d 	.word	0x0001198d
    3410:	00002c49 	.word	0x00002c49
    3414:	2000010c 	.word	0x2000010c
    3418:	00006cfd 	.word	0x00006cfd
    341c:	ffffc322 	.word	0xffffc322
    3420:	00006e81 	.word	0x00006e81
    3424:	00013ca0 	.word	0x00013ca0
    3428:	00013cac 	.word	0x00013cac
    342c:	000119c1 	.word	0x000119c1
    3430:	00013ccc 	.word	0x00013ccc
    3434:	00007141 	.word	0x00007141
    3438:	00013cf0 	.word	0x00013cf0
    343c:	00013d14 	.word	0x00013d14
    3440:	00006f61 	.word	0x00006f61
    3444:	00005401 	.word	0x00005401
    3448:	00013d3c 	.word	0x00013d3c
    344c:	200002e6 	.word	0x200002e6

00003450 <MQTTSubscribeCBCallbackHandler>:
	cJSON_Delete(item);
}


static void MQTTSubscribeCBCallbackHandler(int topic_len, char* topic_name, int payload_len, char* payload)
{
    3450:	b5f0      	push	{r4, r5, r6, r7, lr}
    3452:	b0bf      	sub	sp, #252	; 0xfc
    3454:	9003      	str	r0, [sp, #12]
    3456:	000e      	movs	r6, r1
    3458:	0017      	movs	r7, r2
    345a:	001c      	movs	r4, r3
	printf("%s In\n", __func__);
    345c:	4956      	ldr	r1, [pc, #344]	; (35b8 <MQTTSubscribeCBCallbackHandler+0x168>)
    345e:	4857      	ldr	r0, [pc, #348]	; (35bc <MQTTSubscribeCBCallbackHandler+0x16c>)
    3460:	4d57      	ldr	r5, [pc, #348]	; (35c0 <MQTTSubscribeCBCallbackHandler+0x170>)
    3462:	47a8      	blx	r5
	printf("%.*s\t%.*s",
    3464:	9400      	str	r4, [sp, #0]
    3466:	003b      	movs	r3, r7
    3468:	0032      	movs	r2, r6
    346a:	9903      	ldr	r1, [sp, #12]
    346c:	4855      	ldr	r0, [pc, #340]	; (35c4 <MQTTSubscribeCBCallbackHandler+0x174>)
    346e:	47a8      	blx	r5
	topic_len, topic_name, payload_len, payload);
	printf("\n\r");
    3470:	4855      	ldr	r0, [pc, #340]	; (35c8 <MQTTSubscribeCBCallbackHandler+0x178>)
    3472:	47a8      	blx	r5
	cJSON* item=NULL;
	char data_type[30];
	int data_value;

	
	Iot_Msg_Command cmd = iot_message_parser_cmd_type(payload);
    3474:	0020      	movs	r0, r4
    3476:	4b55      	ldr	r3, [pc, #340]	; (35cc <MQTTSubscribeCBCallbackHandler+0x17c>)
    3478:	4798      	blx	r3
	if (cmd == MSG_CMD_UPDATE)
    347a:	2802      	cmp	r0, #2
    347c:	d127      	bne.n	34ce <MQTTSubscribeCBCallbackHandler+0x7e>
	{
		int info_cnt = iot_message_get_info_count(payload);
    347e:	0020      	movs	r0, r4
    3480:	4b53      	ldr	r3, [pc, #332]	; (35d0 <MQTTSubscribeCBCallbackHandler+0x180>)
    3482:	4798      	blx	r3
		
		for (int i=0; i<info_cnt; i++)
    3484:	2800      	cmp	r0, #0
    3486:	dc00      	bgt.n	348a <MQTTSubscribeCBCallbackHandler+0x3a>
    3488:	e093      	b.n	35b2 <MQTTSubscribeCBCallbackHandler+0x162>
		{
			iot_message_parser_info_data(payload, i, data_type, &data_value);
    348a:	ab35      	add	r3, sp, #212	; 0xd4
    348c:	aa36      	add	r2, sp, #216	; 0xd8
    348e:	2100      	movs	r1, #0
    3490:	0020      	movs	r0, r4
    3492:	4c50      	ldr	r4, [pc, #320]	; (35d4 <MQTTSubscribeCBCallbackHandler+0x184>)
    3494:	47a0      	blx	r4
			printf("info --- dataType: %s, val: %d\n", data_type, data_value);
    3496:	9a35      	ldr	r2, [sp, #212]	; 0xd4
    3498:	a936      	add	r1, sp, #216	; 0xd8
    349a:	484f      	ldr	r0, [pc, #316]	; (35d8 <MQTTSubscribeCBCallbackHandler+0x188>)
    349c:	4b48      	ldr	r3, [pc, #288]	; (35c0 <MQTTSubscribeCBCallbackHandler+0x170>)
    349e:	4798      	blx	r3
			
			switch (data_value)
    34a0:	9b35      	ldr	r3, [sp, #212]	; 0xd4
    34a2:	2b01      	cmp	r3, #1
    34a4:	d009      	beq.n	34ba <MQTTSubscribeCBCallbackHandler+0x6a>
    34a6:	2b02      	cmp	r3, #2
    34a8:	d00c      	beq.n	34c4 <MQTTSubscribeCBCallbackHandler+0x74>
    34aa:	2b00      	cmp	r3, #0
    34ac:	d000      	beq.n	34b0 <MQTTSubscribeCBCallbackHandler+0x60>
    34ae:	e080      	b.n	35b2 <MQTTSubscribeCBCallbackHandler+0x162>
			{
				case 0:
					led_ctrl_set_color(LED_COLOR_BLUE, LED_MODE_NONE);
    34b0:	2100      	movs	r1, #0
    34b2:	2000      	movs	r0, #0
    34b4:	4b49      	ldr	r3, [pc, #292]	; (35dc <MQTTSubscribeCBCallbackHandler+0x18c>)
    34b6:	4798      	blx	r3
					break;
    34b8:	e07b      	b.n	35b2 <MQTTSubscribeCBCallbackHandler+0x162>
				case 1:
					led_ctrl_set_color(LED_COLOR_GREEN, LED_MODE_NONE);
    34ba:	2100      	movs	r1, #0
    34bc:	2001      	movs	r0, #1
    34be:	4b47      	ldr	r3, [pc, #284]	; (35dc <MQTTSubscribeCBCallbackHandler+0x18c>)
    34c0:	4798      	blx	r3
					break;
    34c2:	e076      	b.n	35b2 <MQTTSubscribeCBCallbackHandler+0x162>
				case 2:
					led_ctrl_set_color(LED_COLOR_YELLOW, LED_MODE_NONE);
    34c4:	2100      	movs	r1, #0
    34c6:	2003      	movs	r0, #3
    34c8:	4b44      	ldr	r3, [pc, #272]	; (35dc <MQTTSubscribeCBCallbackHandler+0x18c>)
    34ca:	4798      	blx	r3
					break;
    34cc:	e071      	b.n	35b2 <MQTTSubscribeCBCallbackHandler+0x162>
			}
			
			return;
		}
	}
	else if (cmd == MSG_CMD_SEARCH)
    34ce:	2800      	cmp	r0, #0
    34d0:	d11c      	bne.n	350c <MQTTSubscribeCBCallbackHandler+0xbc>
	{
		
		//item = iot_message_searchResp(DEVICE_TYPE,gAwsMqttClientId);
		environment_data_t env_data;
		get_env_sensor_data_for_display(&env_data);
    34d2:	ac08      	add	r4, sp, #32
    34d4:	0020      	movs	r0, r4
    34d6:	4b42      	ldr	r3, [pc, #264]	; (35e0 <MQTTSubscribeCBCallbackHandler+0x190>)
    34d8:	4798      	blx	r3
		DBG_LOG("DBG: temperature = %d, humidity = %d, uv = %d, pressure = %d\r\n", env_data.temperature, env_data.humidity, env_data.uv, env_data.pressure);
    34da:	4842      	ldr	r0, [pc, #264]	; (35e4 <MQTTSubscribeCBCallbackHandler+0x194>)
    34dc:	4b42      	ldr	r3, [pc, #264]	; (35e8 <MQTTSubscribeCBCallbackHandler+0x198>)
    34de:	4798      	blx	r3
    34e0:	7a22      	ldrb	r2, [r4, #8]
    34e2:	2300      	movs	r3, #0
    34e4:	5ee1      	ldrsh	r1, [r4, r3]
    34e6:	8863      	ldrh	r3, [r4, #2]
    34e8:	9300      	str	r3, [sp, #0]
    34ea:	6863      	ldr	r3, [r4, #4]
    34ec:	483f      	ldr	r0, [pc, #252]	; (35ec <MQTTSubscribeCBCallbackHandler+0x19c>)
    34ee:	4d34      	ldr	r5, [pc, #208]	; (35c0 <MQTTSubscribeCBCallbackHandler+0x170>)
    34f0:	47a8      	blx	r5
		
		item = iot_message_searchResp_with_temp_uv(DEVICE_TYPE,gAwsMqttClientId, env_data.temperature, env_data.uv);
    34f2:	6863      	ldr	r3, [r4, #4]
    34f4:	2100      	movs	r1, #0
    34f6:	5e62      	ldrsh	r2, [r4, r1]
    34f8:	493d      	ldr	r1, [pc, #244]	; (35f0 <MQTTSubscribeCBCallbackHandler+0x1a0>)
    34fa:	483e      	ldr	r0, [pc, #248]	; (35f4 <MQTTSubscribeCBCallbackHandler+0x1a4>)
    34fc:	4c3e      	ldr	r4, [pc, #248]	; (35f8 <MQTTSubscribeCBCallbackHandler+0x1a8>)
    34fe:	47a0      	blx	r4
    3500:	0004      	movs	r4, r0
		cloud_mqtt_publish(gSearchResp_Channel,item);
    3502:	0001      	movs	r1, r0
    3504:	483d      	ldr	r0, [pc, #244]	; (35fc <MQTTSubscribeCBCallbackHandler+0x1ac>)
    3506:	4b3e      	ldr	r3, [pc, #248]	; (3600 <MQTTSubscribeCBCallbackHandler+0x1b0>)
    3508:	4798      	blx	r3
    350a:	e04d      	b.n	35a8 <MQTTSubscribeCBCallbackHandler+0x158>
	}
	else if (cmd == MSG_CMD_GET)
    350c:	2801      	cmp	r0, #1
    350e:	d145      	bne.n	359c <MQTTSubscribeCBCallbackHandler+0x14c>
	{
		environment_data_t env_data;
		get_env_sensor_data_for_display(&env_data);
    3510:	ac05      	add	r4, sp, #20
    3512:	0020      	movs	r0, r4
    3514:	4b32      	ldr	r3, [pc, #200]	; (35e0 <MQTTSubscribeCBCallbackHandler+0x190>)
    3516:	4798      	blx	r3
		
		DBG_LOG("DBG: temperature = %d, humidity = %d, uv = %d, pressure = %d\r\n", env_data.temperature, env_data.humidity, env_data.uv, env_data.pressure);
    3518:	4832      	ldr	r0, [pc, #200]	; (35e4 <MQTTSubscribeCBCallbackHandler+0x194>)
    351a:	4b33      	ldr	r3, [pc, #204]	; (35e8 <MQTTSubscribeCBCallbackHandler+0x198>)
    351c:	4798      	blx	r3
    351e:	7a22      	ldrb	r2, [r4, #8]
    3520:	2300      	movs	r3, #0
    3522:	5ee1      	ldrsh	r1, [r4, r3]
    3524:	8863      	ldrh	r3, [r4, #2]
    3526:	9300      	str	r3, [sp, #0]
    3528:	6863      	ldr	r3, [r4, #4]
    352a:	4830      	ldr	r0, [pc, #192]	; (35ec <MQTTSubscribeCBCallbackHandler+0x19c>)
    352c:	4d24      	ldr	r5, [pc, #144]	; (35c0 <MQTTSubscribeCBCallbackHandler+0x170>)
    352e:	47a8      	blx	r5
		
		NodeInfo info[5];
		
		strcpy(info[0].dataType,TEMP_DATATYPE_NAME);
    3530:	ab08      	add	r3, sp, #32
    3532:	4a34      	ldr	r2, [pc, #208]	; (3604 <MQTTSubscribeCBCallbackHandler+0x1b4>)
    3534:	6811      	ldr	r1, [r2, #0]
    3536:	9108      	str	r1, [sp, #32]
    3538:	7912      	ldrb	r2, [r2, #4]
    353a:	711a      	strb	r2, [r3, #4]
		info[0].value = (int) env_data.temperature;
    353c:	2100      	movs	r1, #0
    353e:	5e62      	ldrsh	r2, [r4, r1]
    3540:	9210      	str	r2, [sp, #64]	; 0x40
		
		strcpy(info[1].dataType,HUM_DATATYPE_NAME);
    3542:	4a31      	ldr	r2, [pc, #196]	; (3608 <MQTTSubscribeCBCallbackHandler+0x1b8>)
    3544:	9211      	str	r2, [sp, #68]	; 0x44
		info[1].value = (int) env_data.humidity;
    3546:	7a22      	ldrb	r2, [r4, #8]
    3548:	9219      	str	r2, [sp, #100]	; 0x64
		
		strcpy(info[2].dataType,UV_DATATYPE_NAME);
    354a:	aa1a      	add	r2, sp, #104	; 0x68
    354c:	492f      	ldr	r1, [pc, #188]	; (360c <MQTTSubscribeCBCallbackHandler+0x1bc>)
    354e:	8808      	ldrh	r0, [r1, #0]
    3550:	8010      	strh	r0, [r2, #0]
    3552:	7889      	ldrb	r1, [r1, #2]
    3554:	7091      	strb	r1, [r2, #2]
		info[2].value = (int) env_data.uv;
    3556:	6862      	ldr	r2, [r4, #4]
    3558:	9222      	str	r2, [sp, #136]	; 0x88
		
		strcpy(info[3].dataType,PRESSURE_DATATYPE_NAME);
    355a:	a923      	add	r1, sp, #140	; 0x8c
    355c:	4a2c      	ldr	r2, [pc, #176]	; (3610 <MQTTSubscribeCBCallbackHandler+0x1c0>)
    355e:	ca21      	ldmia	r2!, {r0, r5}
    3560:	c121      	stmia	r1!, {r0, r5}
    3562:	7812      	ldrb	r2, [r2, #0]
    3564:	700a      	strb	r2, [r1, #0]
		info[3].value = (int) env_data.pressure;
    3566:	8861      	ldrh	r1, [r4, #2]
    3568:	228c      	movs	r2, #140	; 0x8c
    356a:	5099      	str	r1, [r3, r2]
		
		strcpy(info[4].dataType,LED1_DATATYPE_NAME);
    356c:	4b29      	ldr	r3, [pc, #164]	; (3614 <MQTTSubscribeCBCallbackHandler+0x1c4>)
    356e:	681a      	ldr	r2, [r3, #0]
    3570:	922c      	str	r2, [sp, #176]	; 0xb0
    3572:	791a      	ldrb	r2, [r3, #4]
    3574:	ab2c      	add	r3, sp, #176	; 0xb0
    3576:	711a      	strb	r2, [r3, #4]
		Led_Color color = led_ctrl_get_color();
    3578:	4b27      	ldr	r3, [pc, #156]	; (3618 <MQTTSubscribeCBCallbackHandler+0x1c8>)
    357a:	4798      	blx	r3
		if (color == LED_COLOR_YELLOW)	//align with the mobile APP option number, yellow is option number 2, blue is 0 and green is 1
    357c:	2803      	cmp	r0, #3
    357e:	d100      	bne.n	3582 <MQTTSubscribeCBCallbackHandler+0x132>
			color = 2;	
    3580:	3801      	subs	r0, #1
		info[4].value = color;
    3582:	9034      	str	r0, [sp, #208]	; 0xd0
		
		
		item = iot_message_reportAllInfo(DEVICE_TYPE, gAwsMqttClientId, 5, info);
    3584:	ab08      	add	r3, sp, #32
    3586:	2205      	movs	r2, #5
    3588:	4919      	ldr	r1, [pc, #100]	; (35f0 <MQTTSubscribeCBCallbackHandler+0x1a0>)
    358a:	481a      	ldr	r0, [pc, #104]	; (35f4 <MQTTSubscribeCBCallbackHandler+0x1a4>)
    358c:	4c23      	ldr	r4, [pc, #140]	; (361c <MQTTSubscribeCBCallbackHandler+0x1cc>)
    358e:	47a0      	blx	r4
    3590:	0004      	movs	r4, r0
		cloud_mqtt_publish(gPublish_Channel,item);
    3592:	0001      	movs	r1, r0
    3594:	4822      	ldr	r0, [pc, #136]	; (3620 <MQTTSubscribeCBCallbackHandler+0x1d0>)
    3596:	4b1a      	ldr	r3, [pc, #104]	; (3600 <MQTTSubscribeCBCallbackHandler+0x1b0>)
    3598:	4798      	blx	r3
    359a:	e005      	b.n	35a8 <MQTTSubscribeCBCallbackHandler+0x158>
		
	}
	else if (cmd == MSG_SUBCMD_GET_3D_PLOT_DATA)
    359c:	2808      	cmp	r0, #8
    359e:	d108      	bne.n	35b2 <MQTTSubscribeCBCallbackHandler+0x162>
	{
		set_motion_sensor_update_timer(5);
    35a0:	3803      	subs	r0, #3
    35a2:	4b20      	ldr	r3, [pc, #128]	; (3624 <MQTTSubscribeCBCallbackHandler+0x1d4>)
    35a4:	4798      	blx	r3
    35a6:	e004      	b.n	35b2 <MQTTSubscribeCBCallbackHandler+0x162>
	}
	
	if (item!=NULL)
    35a8:	2c00      	cmp	r4, #0
    35aa:	d002      	beq.n	35b2 <MQTTSubscribeCBCallbackHandler+0x162>
		cJSON_Delete(item);
    35ac:	0020      	movs	r0, r4
    35ae:	4b1e      	ldr	r3, [pc, #120]	; (3628 <MQTTSubscribeCBCallbackHandler+0x1d8>)
    35b0:	4798      	blx	r3
	
	return 0;
}
    35b2:	b03f      	add	sp, #252	; 0xfc
    35b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    35b6:	46c0      	nop			; (mov r8, r8)
    35b8:	00013aa4 	.word	0x00013aa4
    35bc:	00013944 	.word	0x00013944
    35c0:	0001198d 	.word	0x0001198d
    35c4:	00013454 	.word	0x00013454
    35c8:	00013460 	.word	0x00013460
    35cc:	00002555 	.word	0x00002555
    35d0:	000023f9 	.word	0x000023f9
    35d4:	00002479 	.word	0x00002479
    35d8:	00013d4c 	.word	0x00013d4c
    35dc:	00002b19 	.word	0x00002b19
    35e0:	00002179 	.word	0x00002179
    35e4:	000140b0 	.word	0x000140b0
    35e8:	00011aad 	.word	0x00011aad
    35ec:	00013d6c 	.word	0x00013d6c
    35f0:	20001a44 	.word	0x20001a44
    35f4:	00013ae4 	.word	0x00013ae4
    35f8:	00002671 	.word	0x00002671
    35fc:	20001a90 	.word	0x20001a90
    3600:	00001e51 	.word	0x00001e51
    3604:	00013930 	.word	0x00013930
    3608:	006d7568 	.word	0x006d7568
    360c:	00013938 	.word	0x00013938
    3610:	00013af4 	.word	0x00013af4
    3614:	00013dac 	.word	0x00013dac
    3618:	00002b0d 	.word	0x00002b0d
    361c:	00002791 	.word	0x00002791
    3620:	20001a54 	.word	0x20001a54
    3624:	00002ce1 	.word	0x00002ce1
    3628:	00001a59 	.word	0x00001a59

0000362c <parse_cmd_frame>:
		set_prov_state(STA_INIT);
	}
}

static void parse_cmd_frame(SOCKET sock, uint8 *provbuffer)
{
    362c:	b5f0      	push	{r4, r5, r6, r7, lr}
    362e:	4657      	mov	r7, sl
    3630:	464e      	mov	r6, r9
    3632:	b4c0      	push	{r6, r7}
    3634:	b0ed      	sub	sp, #436	; 0x1b4
    3636:	0004      	movs	r4, r0
    3638:	000d      	movs	r5, r1
	uint16_t cmd_length = _get_u16(provbuffer + CMD_LEN_OFFSET) + SOF_LEN + CMDLNTH_LEN;
	if (cmd_length > MIN_CMD_LEN && cmd_length < SOCKET_BUFFER_MAX_LENGTH){
    363a:	788b      	ldrb	r3, [r1, #2]
    363c:	021b      	lsls	r3, r3, #8
    363e:	784a      	ldrb	r2, [r1, #1]
    3640:	4313      	orrs	r3, r2
    3642:	3b07      	subs	r3, #7
    3644:	b29b      	uxth	r3, r3
    3646:	4a3d      	ldr	r2, [pc, #244]	; (373c <parse_cmd_frame+0x110>)
    3648:	4293      	cmp	r3, r2
    364a:	d872      	bhi.n	3732 <parse_cmd_frame+0x106>
		//crc32_calculate(provbuffer, cmd_length, &chksum);
		//uint32_t rx_chksum = _get_u32(provbuffer + cmd_length);
		uint32_t rx_chksum = 0;
		if (chksum == rx_chksum) {
			//M2M_INFO("CRC pass\r\n");
			uint8_t cmd_id =  *(provbuffer + CMD_ID_OFFSET);
    364c:	790e      	ldrb	r6, [r1, #4]
			cmd_resp_t cmd_response;
			memset(&cmd_response, 0, sizeof(cmd_response));
    364e:	228c      	movs	r2, #140	; 0x8c
    3650:	0052      	lsls	r2, r2, #1
    3652:	2100      	movs	r1, #0
    3654:	a826      	add	r0, sp, #152	; 0x98
    3656:	4b3a      	ldr	r3, [pc, #232]	; (3740 <parse_cmd_frame+0x114>)
    3658:	4798      	blx	r3
			// Parse IoT command
			parse_iot_cmd(sock, cmd_id, provbuffer + CMD_PARAM_OFFSET, &cmd_response);
    365a:	002a      	movs	r2, r5
    365c:	3209      	adds	r2, #9
    365e:	ab26      	add	r3, sp, #152	; 0x98
    3660:	0031      	movs	r1, r6
    3662:	0020      	movs	r0, r4
    3664:	4e37      	ldr	r6, [pc, #220]	; (3744 <parse_cmd_frame+0x118>)
    3666:	47b0      	blx	r6
			// Fill seq number
			cmd_response.data.base[CMD_SEQ_OFFSET] = *(provbuffer + CMD_SEQ_OFFSET);
    3668:	ae26      	add	r6, sp, #152	; 0x98
    366a:	78eb      	ldrb	r3, [r5, #3]
    366c:	7173      	strb	r3, [r6, #5]
			
			//To Do: Add checksum
			//crc32_calculate(cmd_response.data.base, cmd_response.length, &msg_check_sum);
			//memcpy(&cmd_response.data.base[cmd_response.length], &msg_check_sum, CHECKSUM_LEN);
			{
				DBG_LOG("send data, len = %d\r\n",cmd_response.length);
    366e:	4f36      	ldr	r7, [pc, #216]	; (3748 <parse_cmd_frame+0x11c>)
    3670:	0038      	movs	r0, r7
    3672:	4d36      	ldr	r5, [pc, #216]	; (374c <parse_cmd_frame+0x120>)
    3674:	47a8      	blx	r5
    3676:	8831      	ldrh	r1, [r6, #0]
    3678:	4835      	ldr	r0, [pc, #212]	; (3750 <parse_cmd_frame+0x124>)
    367a:	4b36      	ldr	r3, [pc, #216]	; (3754 <parse_cmd_frame+0x128>)
    367c:	4798      	blx	r3
				//send(sock, (void *)cmd_response.data.base, \
				//cmd_response.length + CHECKSUM_LEN, 0);
				//if (cmd_response.length == 19)
				{
					DBG_LOG("send !!\r\n");
    367e:	0038      	movs	r0, r7
    3680:	47a8      	blx	r5
    3682:	4835      	ldr	r0, [pc, #212]	; (3758 <parse_cmd_frame+0x12c>)
    3684:	47a8      	blx	r5
					send(sock, (void *)cmd_response.data.base, \
    3686:	8832      	ldrh	r2, [r6, #0]
    3688:	2300      	movs	r3, #0
    368a:	219a      	movs	r1, #154	; 0x9a
    368c:	4469      	add	r1, sp
    368e:	0020      	movs	r0, r4
    3690:	4c32      	ldr	r4, [pc, #200]	; (375c <parse_cmd_frame+0x130>)
    3692:	47a0      	blx	r4
					cmd_response.length, 0);
				}
			}
			if (get_prov_state() == PROV_DONE) {
    3694:	4b32      	ldr	r3, [pc, #200]	; (3760 <parse_cmd_frame+0x134>)
    3696:	4798      	blx	r3
    3698:	2803      	cmp	r0, #3
    369a:	d14a      	bne.n	3732 <parse_cmd_frame+0x106>
				nm_bsp_sleep(500);
    369c:	30f2      	adds	r0, #242	; 0xf2
    369e:	30ff      	adds	r0, #255	; 0xff
    36a0:	4b30      	ldr	r3, [pc, #192]	; (3764 <parse_cmd_frame+0x138>)
    36a2:	4798      	blx	r3
				// Store WiFi information in NVM before connecting.
				wifi_nvm_data.ssidlen = strlen((char *)gDefaultSSID);
    36a4:	4d30      	ldr	r5, [pc, #192]	; (3768 <parse_cmd_frame+0x13c>)
    36a6:	0028      	movs	r0, r5
    36a8:	4b30      	ldr	r3, [pc, #192]	; (376c <parse_cmd_frame+0x140>)
    36aa:	4699      	mov	r9, r3
    36ac:	4798      	blx	r3
    36ae:	4c30      	ldr	r4, [pc, #192]	; (3770 <parse_cmd_frame+0x144>)
    36b0:	2722      	movs	r7, #34	; 0x22
    36b2:	55e0      	strb	r0, [r4, r7]
				printf("SSID len=%d\r\n", wifi_nvm_data.ssidlen);
    36b4:	23ff      	movs	r3, #255	; 0xff
    36b6:	469a      	mov	sl, r3
    36b8:	0019      	movs	r1, r3
    36ba:	4001      	ands	r1, r0
    36bc:	482d      	ldr	r0, [pc, #180]	; (3774 <parse_cmd_frame+0x148>)
    36be:	4e25      	ldr	r6, [pc, #148]	; (3754 <parse_cmd_frame+0x128>)
    36c0:	47b0      	blx	r6
				memcpy(wifi_nvm_data.ssid, gDefaultSSID, wifi_nvm_data.ssidlen);
    36c2:	5de2      	ldrb	r2, [r4, r7]
    36c4:	0029      	movs	r1, r5
    36c6:	482c      	ldr	r0, [pc, #176]	; (3778 <parse_cmd_frame+0x14c>)
    36c8:	4d2c      	ldr	r5, [pc, #176]	; (377c <parse_cmd_frame+0x150>)
    36ca:	47a8      	blx	r5
				printf("SSID =%s\r\n", wifi_nvm_data.ssid);
    36cc:	492a      	ldr	r1, [pc, #168]	; (3778 <parse_cmd_frame+0x14c>)
    36ce:	482c      	ldr	r0, [pc, #176]	; (3780 <parse_cmd_frame+0x154>)
    36d0:	47b0      	blx	r6
				wifi_nvm_data.keylen = strlen((char *)gDefaultKey);
    36d2:	4f2c      	ldr	r7, [pc, #176]	; (3784 <parse_cmd_frame+0x158>)
    36d4:	0038      	movs	r0, r7
    36d6:	47c8      	blx	r9
    36d8:	0002      	movs	r2, r0
    36da:	2364      	movs	r3, #100	; 0x64
    36dc:	54e0      	strb	r0, [r4, r3]
				memcpy(wifi_nvm_data.key, gDefaultKey, wifi_nvm_data.keylen);
    36de:	0020      	movs	r0, r4
    36e0:	3023      	adds	r0, #35	; 0x23
    36e2:	4653      	mov	r3, sl
    36e4:	401a      	ands	r2, r3
    36e6:	0039      	movs	r1, r7
    36e8:	47a8      	blx	r5
				wifi_nvm_data.authtype = gAuthType;
    36ea:	4b27      	ldr	r3, [pc, #156]	; (3788 <parse_cmd_frame+0x15c>)
    36ec:	781a      	ldrb	r2, [r3, #0]
    36ee:	2365      	movs	r3, #101	; 0x65
    36f0:	54e2      	strb	r2, [r4, r3]
				wifi_nvm_data.valid = 1;
    36f2:	3b64      	subs	r3, #100	; 0x64
    36f4:	7023      	strb	r3, [r4, #0]
				memcpy(wifi_nvm_data.uuid,gUuid,strlen(gUuid));
    36f6:	4f25      	ldr	r7, [pc, #148]	; (378c <parse_cmd_frame+0x160>)
    36f8:	0038      	movs	r0, r7
    36fa:	47c8      	blx	r9
    36fc:	0002      	movs	r2, r0
    36fe:	0020      	movs	r0, r4
    3700:	3066      	adds	r0, #102	; 0x66
    3702:	0039      	movs	r1, r7
    3704:	47a8      	blx	r5
				
				//To Do:
				// Save wifi_nvm_data to flash
				nvm_store_config_data(wifi_nvm_data);
    3706:	0021      	movs	r1, r4
    3708:	3110      	adds	r1, #16
    370a:	2292      	movs	r2, #146	; 0x92
    370c:	4668      	mov	r0, sp
    370e:	47a8      	blx	r5
    3710:	6820      	ldr	r0, [r4, #0]
    3712:	6861      	ldr	r1, [r4, #4]
    3714:	68a2      	ldr	r2, [r4, #8]
    3716:	68e3      	ldr	r3, [r4, #12]
    3718:	4d1d      	ldr	r5, [pc, #116]	; (3790 <parse_cmd_frame+0x164>)
    371a:	47a8      	blx	r5
				///nv_flash_write(CONFIG_PAGE_ADDRESS,CONFIG_PAGE,(uint32_t*)(&wifi_nvm_data),sizeof(wifi_nvm_data));
				printf("Write config page\r\n");
    371c:	481d      	ldr	r0, [pc, #116]	; (3794 <parse_cmd_frame+0x168>)
    371e:	4b0b      	ldr	r3, [pc, #44]	; (374c <parse_cmd_frame+0x120>)
    3720:	4798      	blx	r3
				nvm_get_config_data(&wifi_nvm_data);
    3722:	0020      	movs	r0, r4
    3724:	4b1c      	ldr	r3, [pc, #112]	; (3798 <parse_cmd_frame+0x16c>)
    3726:	4798      	blx	r3
				printf("DBG SSID=%s\r\n", wifi_nvm_data.ssid);
    3728:	4913      	ldr	r1, [pc, #76]	; (3778 <parse_cmd_frame+0x14c>)
    372a:	481c      	ldr	r0, [pc, #112]	; (379c <parse_cmd_frame+0x170>)
    372c:	47b0      	blx	r6
				//To Do: 
				//Switch to STA mode after NVM store.
				wifiSwitchtoSTA();
    372e:	4b1c      	ldr	r3, [pc, #112]	; (37a0 <parse_cmd_frame+0x174>)
    3730:	4798      	blx	r3
		}
	}
	else {
		//send(get_session(session_num)->sock, (void *)"Msg length error!", strlen("Msg length error!"), 0);
	}
}
    3732:	b06d      	add	sp, #436	; 0x1b4
    3734:	bc0c      	pop	{r2, r3}
    3736:	4691      	mov	r9, r2
    3738:	469a      	mov	sl, r3
    373a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    373c:	0000056d 	.word	0x0000056d
    3740:	00011845 	.word	0x00011845
    3744:	000021c9 	.word	0x000021c9
    3748:	000140b0 	.word	0x000140b0
    374c:	00011aad 	.word	0x00011aad
    3750:	00013db4 	.word	0x00013db4
    3754:	0001198d 	.word	0x0001198d
    3758:	00013dcc 	.word	0x00013dcc
    375c:	00007015 	.word	0x00007015
    3760:	000021bd 	.word	0x000021bd
    3764:	00003e6d 	.word	0x00003e6d
    3768:	200008a4 	.word	0x200008a4
    376c:	00011d75 	.word	0x00011d75
    3770:	20000244 	.word	0x20000244
    3774:	00013dd8 	.word	0x00013dd8
    3778:	20000245 	.word	0x20000245
    377c:	00011833 	.word	0x00011833
    3780:	00013de8 	.word	0x00013de8
    3784:	200001f8 	.word	0x200001f8
    3788:	200002e8 	.word	0x200002e8
    378c:	20000868 	.word	0x20000868
    3790:	00002ec1 	.word	0x00002ec1
    3794:	00013df4 	.word	0x00013df4
    3798:	00002e25 	.word	0x00002e25
    379c:	00013e08 	.word	0x00013e08
    37a0:	0000316d 	.word	0x0000316d

000037a4 <m2m_wifi_socket_handler>:
 *  - tstrSocketConnectMsg
 *  - tstrSocketRecvMsg
 */

static void m2m_wifi_socket_handler(SOCKET sock, uint8 u8Msg, void *pvMsg)
{
    37a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    37a6:	0005      	movs	r5, r0
    37a8:	000c      	movs	r4, r1
    37aa:	0017      	movs	r7, r2
	int ret =-1;
	M2M_INFO(" %s In\n", __func__);("socket %d, event %d!\r\n", sock, u8Msg);
    37ac:	4872      	ldr	r0, [pc, #456]	; (3978 <m2m_wifi_socket_handler+0x1d4>)
    37ae:	4e73      	ldr	r6, [pc, #460]	; (397c <m2m_wifi_socket_handler+0x1d8>)
    37b0:	47b0      	blx	r6
    37b2:	4973      	ldr	r1, [pc, #460]	; (3980 <m2m_wifi_socket_handler+0x1dc>)
    37b4:	4873      	ldr	r0, [pc, #460]	; (3984 <m2m_wifi_socket_handler+0x1e0>)
    37b6:	47b0      	blx	r6
    37b8:	200d      	movs	r0, #13
    37ba:	4b73      	ldr	r3, [pc, #460]	; (3988 <m2m_wifi_socket_handler+0x1e4>)
    37bc:	4798      	blx	r3
	switch (u8Msg) {
    37be:	2c09      	cmp	r4, #9
    37c0:	d900      	bls.n	37c4 <m2m_wifi_socket_handler+0x20>
    37c2:	e0c3      	b.n	394c <m2m_wifi_socket_handler+0x1a8>
    37c4:	00a3      	lsls	r3, r4, #2
    37c6:	4a71      	ldr	r2, [pc, #452]	; (398c <m2m_wifi_socket_handler+0x1e8>)
    37c8:	58d3      	ldr	r3, [r2, r3]
    37ca:	469f      	mov	pc, r3
		case SOCKET_MSG_BIND:
		{
			/* TCP socket */
			if (provServerSocket == sock) {
    37cc:	4b70      	ldr	r3, [pc, #448]	; (3990 <m2m_wifi_socket_handler+0x1ec>)
    37ce:	2400      	movs	r4, #0
    37d0:	571c      	ldrsb	r4, [r3, r4]
    37d2:	42ac      	cmp	r4, r5
    37d4:	d000      	beq.n	37d8 <m2m_wifi_socket_handler+0x34>
    37d6:	e0ce      	b.n	3976 <m2m_wifi_socket_handler+0x1d2>
				tstrSocketBindMsg *pstrBind = (tstrSocketBindMsg*)pvMsg;
				if(pstrBind != NULL && pstrBind->status == 0) {
    37d8:	2f00      	cmp	r7, #0
    37da:	d01d      	beq.n	3818 <m2m_wifi_socket_handler+0x74>
    37dc:	2300      	movs	r3, #0
    37de:	56fb      	ldrsb	r3, [r7, r3]
    37e0:	2b00      	cmp	r3, #0
    37e2:	d11f      	bne.n	3824 <m2m_wifi_socket_handler+0x80>
					ret = listen(sock, 0);
    37e4:	2100      	movs	r1, #0
    37e6:	0020      	movs	r0, r4
    37e8:	4b6a      	ldr	r3, [pc, #424]	; (3994 <m2m_wifi_socket_handler+0x1f0>)
    37ea:	4798      	blx	r3
    37ec:	1e05      	subs	r5, r0, #0
					if(ret < 0) {
    37ee:	da09      	bge.n	3804 <m2m_wifi_socket_handler+0x60>
						M2M_INFO("Listen failure! Error = %d\r\n", ret);
    37f0:	4861      	ldr	r0, [pc, #388]	; (3978 <m2m_wifi_socket_handler+0x1d4>)
    37f2:	4c62      	ldr	r4, [pc, #392]	; (397c <m2m_wifi_socket_handler+0x1d8>)
    37f4:	47a0      	blx	r4
    37f6:	0029      	movs	r1, r5
    37f8:	4867      	ldr	r0, [pc, #412]	; (3998 <m2m_wifi_socket_handler+0x1f4>)
    37fa:	47a0      	blx	r4
    37fc:	200d      	movs	r0, #13
    37fe:	4b62      	ldr	r3, [pc, #392]	; (3988 <m2m_wifi_socket_handler+0x1e4>)
    3800:	4798      	blx	r3
    3802:	e0b8      	b.n	3976 <m2m_wifi_socket_handler+0x1d2>
					}
					else {
						M2M_INFO("TCP socket %d listen!\r\n", sock);
    3804:	485c      	ldr	r0, [pc, #368]	; (3978 <m2m_wifi_socket_handler+0x1d4>)
    3806:	4d5d      	ldr	r5, [pc, #372]	; (397c <m2m_wifi_socket_handler+0x1d8>)
    3808:	47a8      	blx	r5
    380a:	0021      	movs	r1, r4
    380c:	4863      	ldr	r0, [pc, #396]	; (399c <m2m_wifi_socket_handler+0x1f8>)
    380e:	47a8      	blx	r5
    3810:	200d      	movs	r0, #13
    3812:	4b5d      	ldr	r3, [pc, #372]	; (3988 <m2m_wifi_socket_handler+0x1e4>)
    3814:	4798      	blx	r3
    3816:	e0ae      	b.n	3976 <m2m_wifi_socket_handler+0x1d2>
					}
				}
				else {
					if (pstrBind->status != 0) M2M_INFO("TCP bind error %d!\r\n", pstrBind->status);
    3818:	2300      	movs	r3, #0
    381a:	781b      	ldrb	r3, [r3, #0]
    381c:	b25b      	sxtb	r3, r3
    381e:	2b00      	cmp	r3, #0
    3820:	d100      	bne.n	3824 <m2m_wifi_socket_handler+0x80>
    3822:	e0a8      	b.n	3976 <m2m_wifi_socket_handler+0x1d2>
    3824:	4854      	ldr	r0, [pc, #336]	; (3978 <m2m_wifi_socket_handler+0x1d4>)
    3826:	4c55      	ldr	r4, [pc, #340]	; (397c <m2m_wifi_socket_handler+0x1d8>)
    3828:	47a0      	blx	r4
    382a:	2100      	movs	r1, #0
    382c:	5679      	ldrsb	r1, [r7, r1]
    382e:	485c      	ldr	r0, [pc, #368]	; (39a0 <m2m_wifi_socket_handler+0x1fc>)
    3830:	47a0      	blx	r4
    3832:	200d      	movs	r0, #13
    3834:	4b54      	ldr	r3, [pc, #336]	; (3988 <m2m_wifi_socket_handler+0x1e4>)
    3836:	4798      	blx	r3
    3838:	e09d      	b.n	3976 <m2m_wifi_socket_handler+0x1d2>
		}
		break;
  
		case SOCKET_MSG_LISTEN:
		{
			if (provServerSocket == sock) {
    383a:	4b55      	ldr	r3, [pc, #340]	; (3990 <m2m_wifi_socket_handler+0x1ec>)
    383c:	781b      	ldrb	r3, [r3, #0]
    383e:	b25b      	sxtb	r3, r3
    3840:	42ab      	cmp	r3, r5
    3842:	d000      	beq.n	3846 <m2m_wifi_socket_handler+0xa2>
    3844:	e097      	b.n	3976 <m2m_wifi_socket_handler+0x1d2>
				tstrSocketListenMsg	*pstrListen = (tstrSocketListenMsg*)pvMsg;
				if(pstrListen != NULL && pstrListen->status == 0) {
    3846:	2f00      	cmp	r7, #0
    3848:	d012      	beq.n	3870 <m2m_wifi_socket_handler+0xcc>
    384a:	2300      	movs	r3, #0
    384c:	56fb      	ldrsb	r3, [r7, r3]
    384e:	2b00      	cmp	r3, #0
    3850:	d113      	bne.n	387a <m2m_wifi_socket_handler+0xd6>
					ret = accept(sock, NULL, 0);
    3852:	2200      	movs	r2, #0
    3854:	2100      	movs	r1, #0
    3856:	0028      	movs	r0, r5
    3858:	4b52      	ldr	r3, [pc, #328]	; (39a4 <m2m_wifi_socket_handler+0x200>)
    385a:	4798      	blx	r3
					M2M_INFO("TCP socket %d accept!\r\n", sock);
    385c:	4846      	ldr	r0, [pc, #280]	; (3978 <m2m_wifi_socket_handler+0x1d4>)
    385e:	4c47      	ldr	r4, [pc, #284]	; (397c <m2m_wifi_socket_handler+0x1d8>)
    3860:	47a0      	blx	r4
    3862:	0029      	movs	r1, r5
    3864:	4850      	ldr	r0, [pc, #320]	; (39a8 <m2m_wifi_socket_handler+0x204>)
    3866:	47a0      	blx	r4
    3868:	200d      	movs	r0, #13
    386a:	4b47      	ldr	r3, [pc, #284]	; (3988 <m2m_wifi_socket_handler+0x1e4>)
    386c:	4798      	blx	r3
    386e:	e082      	b.n	3976 <m2m_wifi_socket_handler+0x1d2>
				}
				else {
					if (pstrListen->status != 0) M2M_INFO("TCP listen error %d!\r\n", pstrListen->status);
    3870:	2300      	movs	r3, #0
    3872:	781b      	ldrb	r3, [r3, #0]
    3874:	b25b      	sxtb	r3, r3
    3876:	2b00      	cmp	r3, #0
    3878:	d07d      	beq.n	3976 <m2m_wifi_socket_handler+0x1d2>
    387a:	483f      	ldr	r0, [pc, #252]	; (3978 <m2m_wifi_socket_handler+0x1d4>)
    387c:	4c3f      	ldr	r4, [pc, #252]	; (397c <m2m_wifi_socket_handler+0x1d8>)
    387e:	47a0      	blx	r4
    3880:	2100      	movs	r1, #0
    3882:	5679      	ldrsb	r1, [r7, r1]
    3884:	4849      	ldr	r0, [pc, #292]	; (39ac <m2m_wifi_socket_handler+0x208>)
    3886:	47a0      	blx	r4
    3888:	200d      	movs	r0, #13
    388a:	4b3f      	ldr	r3, [pc, #252]	; (3988 <m2m_wifi_socket_handler+0x1e4>)
    388c:	4798      	blx	r3
    388e:	e072      	b.n	3976 <m2m_wifi_socket_handler+0x1d2>
		}
		break;
  
		case SOCKET_MSG_ACCEPT:
		{
			if (provServerSocket == sock) {
    3890:	4b3f      	ldr	r3, [pc, #252]	; (3990 <m2m_wifi_socket_handler+0x1ec>)
    3892:	781b      	ldrb	r3, [r3, #0]
    3894:	b25b      	sxtb	r3, r3
    3896:	42ab      	cmp	r3, r5
    3898:	d16d      	bne.n	3976 <m2m_wifi_socket_handler+0x1d2>
				tstrSocketAcceptMsg *pstrAccept = (tstrSocketAcceptMsg*)pvMsg;
				if(pstrAccept) {
    389a:	2f00      	cmp	r7, #0
    389c:	d014      	beq.n	38c8 <m2m_wifi_socket_handler+0x124>
					if (pstrAccept->sock >= 0) {
    389e:	2000      	movs	r0, #0
    38a0:	5638      	ldrsb	r0, [r7, r0]
    38a2:	2800      	cmp	r0, #0
    38a4:	db06      	blt.n	38b4 <m2m_wifi_socket_handler+0x110>
						if (i >= 7) {
							M2M_INFO("TCP socket full!\r\n");
							return;
						}		
						#endif				
						recv(pstrAccept->sock, gau8RxBuffer, sizeof(gau8RxBuffer), 0);
    38a6:	2300      	movs	r3, #0
    38a8:	22af      	movs	r2, #175	; 0xaf
    38aa:	00d2      	lsls	r2, r2, #3
    38ac:	4940      	ldr	r1, [pc, #256]	; (39b0 <m2m_wifi_socket_handler+0x20c>)
    38ae:	4c41      	ldr	r4, [pc, #260]	; (39b4 <m2m_wifi_socket_handler+0x210>)
    38b0:	47a0      	blx	r4
    38b2:	e060      	b.n	3976 <m2m_wifi_socket_handler+0x1d2>
					}
					else {
						M2M_INFO("accept sock error\r\n");
    38b4:	4830      	ldr	r0, [pc, #192]	; (3978 <m2m_wifi_socket_handler+0x1d4>)
    38b6:	4b31      	ldr	r3, [pc, #196]	; (397c <m2m_wifi_socket_handler+0x1d8>)
    38b8:	4798      	blx	r3
    38ba:	483f      	ldr	r0, [pc, #252]	; (39b8 <m2m_wifi_socket_handler+0x214>)
    38bc:	4b3f      	ldr	r3, [pc, #252]	; (39bc <m2m_wifi_socket_handler+0x218>)
    38be:	4798      	blx	r3
    38c0:	200d      	movs	r0, #13
    38c2:	4b31      	ldr	r3, [pc, #196]	; (3988 <m2m_wifi_socket_handler+0x1e4>)
    38c4:	4798      	blx	r3
    38c6:	e056      	b.n	3976 <m2m_wifi_socket_handler+0x1d2>
					}
				}
				else {
					M2M_INFO("accept error\r\n");
    38c8:	482b      	ldr	r0, [pc, #172]	; (3978 <m2m_wifi_socket_handler+0x1d4>)
    38ca:	4b2c      	ldr	r3, [pc, #176]	; (397c <m2m_wifi_socket_handler+0x1d8>)
    38cc:	4798      	blx	r3
    38ce:	483c      	ldr	r0, [pc, #240]	; (39c0 <m2m_wifi_socket_handler+0x21c>)
    38d0:	4b3a      	ldr	r3, [pc, #232]	; (39bc <m2m_wifi_socket_handler+0x218>)
    38d2:	4798      	blx	r3
    38d4:	200d      	movs	r0, #13
    38d6:	4b2c      	ldr	r3, [pc, #176]	; (3988 <m2m_wifi_socket_handler+0x1e4>)
    38d8:	4798      	blx	r3
    38da:	e04c      	b.n	3976 <m2m_wifi_socket_handler+0x1d2>
		break;
  
		case SOCKET_MSG_RECV:
		{
			tstrSocketRecvMsg *pstrRx = (tstrSocketRecvMsg*)pvMsg;
			if (pstrRx) {
    38dc:	2f00      	cmp	r7, #0
    38de:	d024      	beq.n	392a <m2m_wifi_socket_handler+0x186>
				if(pstrRx->pu8Buffer != NULL && pstrRx->s16BufferSize) {
    38e0:	6839      	ldr	r1, [r7, #0]
    38e2:	2900      	cmp	r1, #0
    38e4:	d015      	beq.n	3912 <m2m_wifi_socket_handler+0x16e>
    38e6:	2204      	movs	r2, #4
    38e8:	5ebb      	ldrsh	r3, [r7, r2]
    38ea:	2b00      	cmp	r3, #0
    38ec:	d011      	beq.n	3912 <m2m_wifi_socket_handler+0x16e>
					//tcpsendresponse(sock, pstrRx);
					printf("message = %s\r\n",pstrRx->pu8Buffer);
    38ee:	4835      	ldr	r0, [pc, #212]	; (39c4 <m2m_wifi_socket_handler+0x220>)
    38f0:	4b22      	ldr	r3, [pc, #136]	; (397c <m2m_wifi_socket_handler+0x1d8>)
    38f2:	4798      	blx	r3



static void tcpsendresponse(SOCKET sock, tstrSocketRecvMsg *pstrRx)
{
	uint8 *provbuffer = pstrRx->pu8Buffer;
    38f4:	6839      	ldr	r1, [r7, #0]
	
	if (provbuffer[0] == SOF_INDICATER) {
    38f6:	780b      	ldrb	r3, [r1, #0]
    38f8:	2b5a      	cmp	r3, #90	; 0x5a
    38fa:	d102      	bne.n	3902 <m2m_wifi_socket_handler+0x15e>
		// Plain text frame
		{
			parse_cmd_frame(sock, provbuffer);
    38fc:	0028      	movs	r0, r5
    38fe:	4b32      	ldr	r3, [pc, #200]	; (39c8 <m2m_wifi_socket_handler+0x224>)
    3900:	4798      	blx	r3
			if (pstrRx) {
				if(pstrRx->pu8Buffer != NULL && pstrRx->s16BufferSize) {
					//tcpsendresponse(sock, pstrRx);
					printf("message = %s\r\n",pstrRx->pu8Buffer);
					tcpsendresponse(sock, pstrRx);
					recv(sock, gau8RxBuffer, sizeof(gau8RxBuffer), SOCK_TIMEOUT);
    3902:	4b32      	ldr	r3, [pc, #200]	; (39cc <m2m_wifi_socket_handler+0x228>)
    3904:	22af      	movs	r2, #175	; 0xaf
    3906:	00d2      	lsls	r2, r2, #3
    3908:	4929      	ldr	r1, [pc, #164]	; (39b0 <m2m_wifi_socket_handler+0x20c>)
    390a:	0028      	movs	r0, r5
    390c:	4c29      	ldr	r4, [pc, #164]	; (39b4 <m2m_wifi_socket_handler+0x210>)
    390e:	47a0      	blx	r4
    3910:	e031      	b.n	3976 <m2m_wifi_socket_handler+0x1d2>
				}
				else {
					M2M_INFO("TCP Socket %d error: %d!\r\n", sock, pstrRx->s16BufferSize);
    3912:	4819      	ldr	r0, [pc, #100]	; (3978 <m2m_wifi_socket_handler+0x1d4>)
    3914:	4c19      	ldr	r4, [pc, #100]	; (397c <m2m_wifi_socket_handler+0x1d8>)
    3916:	47a0      	blx	r4
    3918:	2304      	movs	r3, #4
    391a:	5efa      	ldrsh	r2, [r7, r3]
    391c:	0029      	movs	r1, r5
    391e:	482c      	ldr	r0, [pc, #176]	; (39d0 <m2m_wifi_socket_handler+0x22c>)
    3920:	47a0      	blx	r4
    3922:	200d      	movs	r0, #13
    3924:	4b18      	ldr	r3, [pc, #96]	; (3988 <m2m_wifi_socket_handler+0x1e4>)
    3926:	4798      	blx	r3
    3928:	e025      	b.n	3976 <m2m_wifi_socket_handler+0x1d2>
				}
			}
			else {
				M2M_INFO("Empty stream!\r\n");
    392a:	4813      	ldr	r0, [pc, #76]	; (3978 <m2m_wifi_socket_handler+0x1d4>)
    392c:	4b13      	ldr	r3, [pc, #76]	; (397c <m2m_wifi_socket_handler+0x1d8>)
    392e:	4798      	blx	r3
    3930:	4828      	ldr	r0, [pc, #160]	; (39d4 <m2m_wifi_socket_handler+0x230>)
    3932:	4b22      	ldr	r3, [pc, #136]	; (39bc <m2m_wifi_socket_handler+0x218>)
    3934:	4798      	blx	r3
    3936:	200d      	movs	r0, #13
    3938:	4b13      	ldr	r3, [pc, #76]	; (3988 <m2m_wifi_socket_handler+0x1e4>)
    393a:	4798      	blx	r3
				recv(sock, gau8RxBuffer, sizeof(gau8RxBuffer), 0);
    393c:	2300      	movs	r3, #0
    393e:	22af      	movs	r2, #175	; 0xaf
    3940:	00d2      	lsls	r2, r2, #3
    3942:	491b      	ldr	r1, [pc, #108]	; (39b0 <m2m_wifi_socket_handler+0x20c>)
    3944:	0028      	movs	r0, r5
    3946:	4c1b      	ldr	r4, [pc, #108]	; (39b4 <m2m_wifi_socket_handler+0x210>)
    3948:	47a0      	blx	r4
    394a:	e014      	b.n	3976 <m2m_wifi_socket_handler+0x1d2>
		
		break;
		
		default:
			//WINC_PRINT("Other socket handler\r\n");
			if (u8Msg > SOCKET_MSG_RECVFROM) {
    394c:	2c09      	cmp	r4, #9
    394e:	d909      	bls.n	3964 <m2m_wifi_socket_handler+0x1c0>
				M2M_INFO("Unknown state %d\r\n", u8Msg);
    3950:	4809      	ldr	r0, [pc, #36]	; (3978 <m2m_wifi_socket_handler+0x1d4>)
    3952:	4d0a      	ldr	r5, [pc, #40]	; (397c <m2m_wifi_socket_handler+0x1d8>)
    3954:	47a8      	blx	r5
    3956:	0021      	movs	r1, r4
    3958:	481f      	ldr	r0, [pc, #124]	; (39d8 <m2m_wifi_socket_handler+0x234>)
    395a:	47a8      	blx	r5
    395c:	200d      	movs	r0, #13
    395e:	4b0a      	ldr	r3, [pc, #40]	; (3988 <m2m_wifi_socket_handler+0x1e4>)
    3960:	4798      	blx	r3
    3962:	e008      	b.n	3976 <m2m_wifi_socket_handler+0x1d2>
			}
			else {
				M2M_INFO("Not handled state %d\r\n", u8Msg);
    3964:	4804      	ldr	r0, [pc, #16]	; (3978 <m2m_wifi_socket_handler+0x1d4>)
    3966:	4d05      	ldr	r5, [pc, #20]	; (397c <m2m_wifi_socket_handler+0x1d8>)
    3968:	47a8      	blx	r5
    396a:	0021      	movs	r1, r4
    396c:	481b      	ldr	r0, [pc, #108]	; (39dc <m2m_wifi_socket_handler+0x238>)
    396e:	47a8      	blx	r5
    3970:	200d      	movs	r0, #13
    3972:	4b05      	ldr	r3, [pc, #20]	; (3988 <m2m_wifi_socket_handler+0x1e4>)
    3974:	4798      	blx	r3
			}
		break;
	}
}
    3976:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3978:	00013ca0 	.word	0x00013ca0
    397c:	0001198d 	.word	0x0001198d
    3980:	00013a7c 	.word	0x00013a7c
    3984:	00013e18 	.word	0x00013e18
    3988:	000119c1 	.word	0x000119c1
    398c:	00013a2c 	.word	0x00013a2c
    3990:	2000010c 	.word	0x2000010c
    3994:	00006f09 	.word	0x00006f09
    3998:	00013e20 	.word	0x00013e20
    399c:	00013e40 	.word	0x00013e40
    39a0:	00013e58 	.word	0x00013e58
    39a4:	00006f61 	.word	0x00006f61
    39a8:	00013e70 	.word	0x00013e70
    39ac:	00013e88 	.word	0x00013e88
    39b0:	200002ec 	.word	0x200002ec
    39b4:	000070ad 	.word	0x000070ad
    39b8:	00013ea0 	.word	0x00013ea0
    39bc:	00011aad 	.word	0x00011aad
    39c0:	00013eb4 	.word	0x00013eb4
    39c4:	00013ec4 	.word	0x00013ec4
    39c8:	0000362d 	.word	0x0000362d
    39cc:	000927c0 	.word	0x000927c0
    39d0:	00013ed4 	.word	0x00013ed4
    39d4:	00013ef0 	.word	0x00013ef0
    39d8:	00013f00 	.word	0x00013f00
    39dc:	00013f14 	.word	0x00013f14

000039e0 <setWiFiStates>:
	wifi_states = WIFI_TASK_IDLE;
}

void setWiFiStates(wifi_FSM_states state)
{
	wifi_states = state;
    39e0:	4b01      	ldr	r3, [pc, #4]	; (39e8 <setWiFiStates+0x8>)
    39e2:	7018      	strb	r0, [r3, #0]
	return;
}
    39e4:	4770      	bx	lr
    39e6:	46c0      	nop			; (mov r8, r8)
    39e8:	2000010d 	.word	0x2000010d

000039ec <getWiFiStates>:

wifi_FSM_states getWiFiStates()
{
	return wifi_states;
    39ec:	4b01      	ldr	r3, [pc, #4]	; (39f4 <getWiFiStates+0x8>)
    39ee:	7818      	ldrb	r0, [r3, #0]
}
    39f0:	4770      	bx	lr
    39f2:	46c0      	nop			; (mov r8, r8)
    39f4:	2000010d 	.word	0x2000010d

000039f8 <getWiFiMode>:

wifi_mode getWiFiMode()
{
	return gu8WiFiMode;
    39f8:	4b01      	ldr	r3, [pc, #4]	; (3a00 <getWiFiMode+0x8>)
    39fa:	7818      	ldrb	r0, [r3, #0]
}
    39fc:	4770      	bx	lr
    39fe:	46c0      	nop			; (mov r8, r8)
    3a00:	20000864 	.word	0x20000864

00003a04 <wifiInit>:
	//detSw0Sock = regButtonPressDetectCallback(buttonSW0Handle);
}


int wifiInit(void)
{
    3a04:	b5f0      	push	{r4, r5, r6, r7, lr}
    3a06:	b08b      	sub	sp, #44	; 0x2c
	DBG_LOG(" %s In\n", __func__);
    3a08:	4841      	ldr	r0, [pc, #260]	; (3b10 <wifiInit+0x10c>)
    3a0a:	4b42      	ldr	r3, [pc, #264]	; (3b14 <wifiInit+0x110>)
    3a0c:	4798      	blx	r3
    3a0e:	4942      	ldr	r1, [pc, #264]	; (3b18 <wifiInit+0x114>)
    3a10:	4842      	ldr	r0, [pc, #264]	; (3b1c <wifiInit+0x118>)
    3a12:	4b43      	ldr	r3, [pc, #268]	; (3b20 <wifiInit+0x11c>)
    3a14:	4798      	blx	r3
	
	tstrWifiInitParam param;
	int8_t ret;

	/* Initialize Wi-Fi parameters structure. */
	memset((uint8_t *)&param, 0, sizeof(tstrWifiInitParam));
    3a16:	2218      	movs	r2, #24
    3a18:	2100      	movs	r1, #0
    3a1a:	a804      	add	r0, sp, #16
    3a1c:	4b41      	ldr	r3, [pc, #260]	; (3b24 <wifiInit+0x120>)
    3a1e:	4798      	blx	r3

	/* Initialize Wi-Fi driver with data and status callbacks. */
	param.pfAppWifiCb = wifi_cb;
    3a20:	4b41      	ldr	r3, [pc, #260]	; (3b28 <wifiInit+0x124>)
    3a22:	9304      	str	r3, [sp, #16]
	
	ret = m2m_wifi_init(&param);
    3a24:	a804      	add	r0, sp, #16
    3a26:	4b41      	ldr	r3, [pc, #260]	; (3b2c <wifiInit+0x128>)
    3a28:	4798      	blx	r3
    3a2a:	1e01      	subs	r1, r0, #0
	if (M2M_SUCCESS != ret) {
    3a2c:	d003      	beq.n	3a36 <wifiInit+0x32>
		printf("main: m2m_wifi_init call error!(%d)\r\n", ret);
    3a2e:	4840      	ldr	r0, [pc, #256]	; (3b30 <wifiInit+0x12c>)
    3a30:	4b3b      	ldr	r3, [pc, #236]	; (3b20 <wifiInit+0x11c>)
    3a32:	4798      	blx	r3
    3a34:	e7fe      	b.n	3a34 <wifiInit+0x30>
		while (1) {
		}
	}

	/* Get MAC Address. */
	m2m_wifi_get_mac_address(gMacaddr);
    3a36:	4e3f      	ldr	r6, [pc, #252]	; (3b34 <wifiInit+0x130>)
    3a38:	0030      	movs	r0, r6
    3a3a:	4b3f      	ldr	r3, [pc, #252]	; (3b38 <wifiInit+0x134>)
    3a3c:	4798      	blx	r3
	DBG_LOG("MAC Address: %02X:%02X:%02X:%02X:%02X:%02X\r\n",
    3a3e:	4834      	ldr	r0, [pc, #208]	; (3b10 <wifiInit+0x10c>)
    3a40:	4d34      	ldr	r5, [pc, #208]	; (3b14 <wifiInit+0x110>)
    3a42:	47a8      	blx	r5
    3a44:	78b3      	ldrb	r3, [r6, #2]
    3a46:	7872      	ldrb	r2, [r6, #1]
    3a48:	7831      	ldrb	r1, [r6, #0]
    3a4a:	7970      	ldrb	r0, [r6, #5]
    3a4c:	9002      	str	r0, [sp, #8]
    3a4e:	7930      	ldrb	r0, [r6, #4]
    3a50:	9001      	str	r0, [sp, #4]
    3a52:	78f0      	ldrb	r0, [r6, #3]
    3a54:	9000      	str	r0, [sp, #0]
    3a56:	4839      	ldr	r0, [pc, #228]	; (3b3c <wifiInit+0x138>)
    3a58:	4f31      	ldr	r7, [pc, #196]	; (3b20 <wifiInit+0x11c>)
    3a5a:	47b8      	blx	r7
	gMacaddr[0], gMacaddr[1], gMacaddr[2],
	gMacaddr[3], gMacaddr[4], gMacaddr[5]);
		
	sprintf(gAwsMqttClientId, "%02x%02x%02x%02x%02x%02x", gMacaddr[0],gMacaddr[1],gMacaddr[2],gMacaddr[3],gMacaddr[4],gMacaddr[5] );
    3a5c:	7873      	ldrb	r3, [r6, #1]
    3a5e:	7832      	ldrb	r2, [r6, #0]
    3a60:	4c37      	ldr	r4, [pc, #220]	; (3b40 <wifiInit+0x13c>)
    3a62:	7971      	ldrb	r1, [r6, #5]
    3a64:	9103      	str	r1, [sp, #12]
    3a66:	7931      	ldrb	r1, [r6, #4]
    3a68:	9102      	str	r1, [sp, #8]
    3a6a:	78f1      	ldrb	r1, [r6, #3]
    3a6c:	9101      	str	r1, [sp, #4]
    3a6e:	78b1      	ldrb	r1, [r6, #2]
    3a70:	9100      	str	r1, [sp, #0]
    3a72:	4934      	ldr	r1, [pc, #208]	; (3b44 <wifiInit+0x140>)
    3a74:	0020      	movs	r0, r4
    3a76:	4e34      	ldr	r6, [pc, #208]	; (3b48 <wifiInit+0x144>)
    3a78:	47b0      	blx	r6
	gAwsMqttClientId[12] = 0;
    3a7a:	2300      	movs	r3, #0
    3a7c:	7323      	strb	r3, [r4, #12]
	DBG_LOG("gAwsMqttClientId Address: %s\r\n",gAwsMqttClientId);
    3a7e:	4824      	ldr	r0, [pc, #144]	; (3b10 <wifiInit+0x10c>)
    3a80:	47a8      	blx	r5
    3a82:	0021      	movs	r1, r4
    3a84:	4831      	ldr	r0, [pc, #196]	; (3b4c <wifiInit+0x148>)
    3a86:	47b8      	blx	r7
	//strcpy(gAwsMqttClientId,"f8f005e45e4c");
	
	cloud_create_topic(gSubscribe_Channel, DEVICE_TYPE, gAwsMqttClientId, SUBSCRIBE_TOPIC);
    3a88:	4b31      	ldr	r3, [pc, #196]	; (3b50 <wifiInit+0x14c>)
    3a8a:	0022      	movs	r2, r4
    3a8c:	4931      	ldr	r1, [pc, #196]	; (3b54 <wifiInit+0x150>)
    3a8e:	4832      	ldr	r0, [pc, #200]	; (3b58 <wifiInit+0x154>)
    3a90:	4e32      	ldr	r6, [pc, #200]	; (3b5c <wifiInit+0x158>)
    3a92:	47b0      	blx	r6
	cloud_create_topic(gPublish_Channel, DEVICE_TYPE, gAwsMqttClientId, PUBLISH_TOPIC);
    3a94:	4b32      	ldr	r3, [pc, #200]	; (3b60 <wifiInit+0x15c>)
    3a96:	0022      	movs	r2, r4
    3a98:	492e      	ldr	r1, [pc, #184]	; (3b54 <wifiInit+0x150>)
    3a9a:	4832      	ldr	r0, [pc, #200]	; (3b64 <wifiInit+0x160>)
    3a9c:	47b0      	blx	r6
	DBG_LOG("gSubscribe_Channel: %s\r\n", gSubscribe_Channel);
    3a9e:	481c      	ldr	r0, [pc, #112]	; (3b10 <wifiInit+0x10c>)
    3aa0:	47a8      	blx	r5
    3aa2:	492d      	ldr	r1, [pc, #180]	; (3b58 <wifiInit+0x154>)
    3aa4:	4830      	ldr	r0, [pc, #192]	; (3b68 <wifiInit+0x164>)
    3aa6:	47b8      	blx	r7
	DBG_LOG("gPublish_Channel: %s\r\n", gPublish_Channel);
    3aa8:	4819      	ldr	r0, [pc, #100]	; (3b10 <wifiInit+0x10c>)
    3aaa:	47a8      	blx	r5
    3aac:	492d      	ldr	r1, [pc, #180]	; (3b64 <wifiInit+0x160>)
    3aae:	482f      	ldr	r0, [pc, #188]	; (3b6c <wifiInit+0x168>)
    3ab0:	47b8      	blx	r7
	
	if (gDefaultSSID[0]==0xFF || gDefaultSSID[0]==0x0 )	// Read nothing from flash, assign default value
    3ab2:	4b2f      	ldr	r3, [pc, #188]	; (3b70 <wifiInit+0x16c>)
    3ab4:	781b      	ldrb	r3, [r3, #0]
    3ab6:	3b01      	subs	r3, #1
    3ab8:	b2db      	uxtb	r3, r3
    3aba:	2bfd      	cmp	r3, #253	; 0xfd
    3abc:	d920      	bls.n	3b00 <wifiInit+0xfc>
	{
		printf("use default SSID\r\n");
    3abe:	482d      	ldr	r0, [pc, #180]	; (3b74 <wifiInit+0x170>)
    3ac0:	4f14      	ldr	r7, [pc, #80]	; (3b14 <wifiInit+0x110>)
    3ac2:	47b8      	blx	r7
		memcpy(gDefaultSSID, MAIN_WLAN_SSID, strlen(MAIN_WLAN_SSID));
    3ac4:	4c2a      	ldr	r4, [pc, #168]	; (3b70 <wifiInit+0x16c>)
    3ac6:	4b2c      	ldr	r3, [pc, #176]	; (3b78 <wifiInit+0x174>)
    3ac8:	0022      	movs	r2, r4
    3aca:	cb03      	ldmia	r3!, {r0, r1}
    3acc:	c203      	stmia	r2!, {r0, r1}
    3ace:	781b      	ldrb	r3, [r3, #0]
    3ad0:	7013      	strb	r3, [r2, #0]
		memcpy(gDefaultKey, MAIN_WLAN_PSK, strlen(MAIN_WLAN_PSK));
    3ad2:	4d2a      	ldr	r5, [pc, #168]	; (3b7c <wifiInit+0x178>)
    3ad4:	4b2a      	ldr	r3, [pc, #168]	; (3b80 <wifiInit+0x17c>)
    3ad6:	002a      	movs	r2, r5
    3ad8:	cb03      	ldmia	r3!, {r0, r1}
    3ada:	c203      	stmia	r2!, {r0, r1}
		gAuthType = MAIN_WLAN_AUTH;
    3adc:	4e29      	ldr	r6, [pc, #164]	; (3b84 <wifiInit+0x180>)
    3ade:	2302      	movs	r3, #2
    3ae0:	7033      	strb	r3, [r6, #0]
		gDefaultSSID[strlen(MAIN_WLAN_SSID)]=0;
    3ae2:	2300      	movs	r3, #0
    3ae4:	7263      	strb	r3, [r4, #9]
		gDefaultKey[strlen(MAIN_WLAN_PSK)]=0;
    3ae6:	722b      	strb	r3, [r5, #8]
		DBG_LOG("gDefaultSSID=%s, pw=%s, auth=%d, ssidlen=%d, pslen=%d\n", gDefaultSSID,gDefaultKey,gAuthType, strlen(MAIN_WLAN_SSID), strlen(MAIN_WLAN_PSK));
    3ae8:	4809      	ldr	r0, [pc, #36]	; (3b10 <wifiInit+0x10c>)
    3aea:	47b8      	blx	r7
    3aec:	7833      	ldrb	r3, [r6, #0]
    3aee:	2208      	movs	r2, #8
    3af0:	9201      	str	r2, [sp, #4]
    3af2:	3201      	adds	r2, #1
    3af4:	9200      	str	r2, [sp, #0]
    3af6:	002a      	movs	r2, r5
    3af8:	0021      	movs	r1, r4
    3afa:	4823      	ldr	r0, [pc, #140]	; (3b88 <wifiInit+0x184>)
    3afc:	4c08      	ldr	r4, [pc, #32]	; (3b20 <wifiInit+0x11c>)
    3afe:	47a0      	blx	r4
	}
	
	register_env_sensor_udpate_callback_handler(EnvSensorCallbackHandler);
    3b00:	4822      	ldr	r0, [pc, #136]	; (3b8c <wifiInit+0x188>)
    3b02:	4b23      	ldr	r3, [pc, #140]	; (3b90 <wifiInit+0x18c>)
    3b04:	4798      	blx	r3
	register_rotation_vector_udpate_callback_handler(motionSensorCallbackHandler);
    3b06:	4823      	ldr	r0, [pc, #140]	; (3b94 <wifiInit+0x190>)
    3b08:	4b23      	ldr	r3, [pc, #140]	; (3b98 <wifiInit+0x194>)
    3b0a:	4798      	blx	r3
	
	//regButtonPress5sTimeoutCallback(buttonSW0Handle);

}
    3b0c:	b00b      	add	sp, #44	; 0x2c
    3b0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3b10:	000140b0 	.word	0x000140b0
    3b14:	00011aad 	.word	0x00011aad
    3b18:	00013a70 	.word	0x00013a70
    3b1c:	00013e18 	.word	0x00013e18
    3b20:	0001198d 	.word	0x0001198d
    3b24:	00011845 	.word	0x00011845
    3b28:	00003269 	.word	0x00003269
    3b2c:	00004fa5 	.word	0x00004fa5
    3b30:	00013f38 	.word	0x00013f38
    3b34:	20002228 	.word	0x20002228
    3b38:	000053d9 	.word	0x000053d9
    3b3c:	00013f60 	.word	0x00013f60
    3b40:	20001a44 	.word	0x20001a44
    3b44:	00013828 	.word	0x00013828
    3b48:	00011c59 	.word	0x00011c59
    3b4c:	00013f90 	.word	0x00013f90
    3b50:	00013fb0 	.word	0x00013fb0
    3b54:	00013ae4 	.word	0x00013ae4
    3b58:	20001b08 	.word	0x20001b08
    3b5c:	00001f0d 	.word	0x00001f0d
    3b60:	00013fbc 	.word	0x00013fbc
    3b64:	20001a54 	.word	0x20001a54
    3b68:	00013fc8 	.word	0x00013fc8
    3b6c:	00013fe4 	.word	0x00013fe4
    3b70:	200008a4 	.word	0x200008a4
    3b74:	00013ffc 	.word	0x00013ffc
    3b78:	00014010 	.word	0x00014010
    3b7c:	200001f8 	.word	0x200001f8
    3b80:	0001401c 	.word	0x0001401c
    3b84:	200002e8 	.word	0x200002e8
    3b88:	00014028 	.word	0x00014028
    3b8c:	00003085 	.word	0x00003085
    3b90:	000021a5 	.word	0x000021a5
    3b94:	00002ffd 	.word	0x00002ffd
    3b98:	00002d69 	.word	0x00002d69

00003b9c <wifiTaskExecute>:



int wifiTaskExecute()
{	
    3b9c:	b570      	push	{r4, r5, r6, lr}
    3b9e:	b0a4      	sub	sp, #144	; 0x90
	Cloud_RC ret = CLOUD_RC_NONE_ERROR;
	
	m2m_wifi_handle_events(NULL);
    3ba0:	2000      	movs	r0, #0
    3ba2:	4b81      	ldr	r3, [pc, #516]	; (3da8 <wifiTaskExecute+0x20c>)
    3ba4:	4798      	blx	r3
	switch (wifi_states)
    3ba6:	4b81      	ldr	r3, [pc, #516]	; (3dac <wifiTaskExecute+0x210>)
    3ba8:	781a      	ldrb	r2, [r3, #0]
    3baa:	2a06      	cmp	r2, #6
    3bac:	d900      	bls.n	3bb0 <wifiTaskExecute+0x14>
    3bae:	e0f9      	b.n	3da4 <wifiTaskExecute+0x208>
    3bb0:	0093      	lsls	r3, r2, #2
    3bb2:	4a7f      	ldr	r2, [pc, #508]	; (3db0 <wifiTaskExecute+0x214>)
    3bb4:	58d3      	ldr	r3, [r2, r3]
    3bb6:	469f      	mov	pc, r3
	{
			
		case WIFI_TASK_SWITCH_TO_AP:
			
			led_ctrl_set_color(LED_COLOR_RED, LED_MODE_BLINK_NORMAL);
    3bb8:	2103      	movs	r1, #3
    3bba:	2002      	movs	r0, #2
    3bbc:	4b7d      	ldr	r3, [pc, #500]	; (3db4 <wifiTaskExecute+0x218>)
    3bbe:	4798      	blx	r3
	int8_t ret;
	static uint8_t mac_addr[M2M_MAC_ADDRES_LEN];
	
	tstrM2MAPConfig strM2MAPConfig;
	/* Initialize AP mode parameters structure with SSID, channel and security type. */
	memset(&strM2MAPConfig, 0x00, sizeof(tstrM2MAPConfig));
    3bc0:	ac02      	add	r4, sp, #8
    3bc2:	2288      	movs	r2, #136	; 0x88
    3bc4:	2100      	movs	r1, #0
    3bc6:	0020      	movs	r0, r4
    3bc8:	4b7b      	ldr	r3, [pc, #492]	; (3db8 <wifiTaskExecute+0x21c>)
    3bca:	4798      	blx	r3
	strcpy((char *)&strM2MAPConfig.au8SSID, AP_WLAN_SSID);
    3bcc:	4b7b      	ldr	r3, [pc, #492]	; (3dbc <wifiTaskExecute+0x220>)
    3bce:	0022      	movs	r2, r4
    3bd0:	cb23      	ldmia	r3!, {r0, r1, r5}
    3bd2:	c223      	stmia	r2!, {r0, r1, r5}
    3bd4:	cb03      	ldmia	r3!, {r0, r1}
    3bd6:	c203      	stmia	r2!, {r0, r1}
    3bd8:	781b      	ldrb	r3, [r3, #0]
    3bda:	7013      	strb	r3, [r2, #0]
	
	m2m_wifi_get_mac_address(mac_addr);
    3bdc:	4878      	ldr	r0, [pc, #480]	; (3dc0 <wifiTaskExecute+0x224>)
    3bde:	4b79      	ldr	r3, [pc, #484]	; (3dc4 <wifiTaskExecute+0x228>)
    3be0:	4798      	blx	r3
static void set_dev_param_to_mac(uint8 *param, uint8 *addr, uint8_t offset)
{
	/* Name must be in the format AtmelSmartPlug000000 */
	uint16 len;

	len = m2m_strlen(param);
    3be2:	0020      	movs	r0, r4
    3be4:	4b78      	ldr	r3, [pc, #480]	; (3dc8 <wifiTaskExecute+0x22c>)
    3be6:	4798      	blx	r3
	if (len >= offset) {
    3be8:	280d      	cmp	r0, #13
    3bea:	d94b      	bls.n	3c84 <wifiTaskExecute+0xe8>
		param[len - 1] = HEX2ASCII((addr[5] >> 0) & 0x0f);
    3bec:	ab24      	add	r3, sp, #144	; 0x90
    3bee:	1819      	adds	r1, r3, r0
    3bf0:	3989      	subs	r1, #137	; 0x89
    3bf2:	4b73      	ldr	r3, [pc, #460]	; (3dc0 <wifiTaskExecute+0x224>)
    3bf4:	795b      	ldrb	r3, [r3, #5]
    3bf6:	220f      	movs	r2, #15
    3bf8:	401a      	ands	r2, r3
    3bfa:	0014      	movs	r4, r2
    3bfc:	3430      	adds	r4, #48	; 0x30
    3bfe:	2a09      	cmp	r2, #9
    3c00:	dd01      	ble.n	3c06 <wifiTaskExecute+0x6a>
    3c02:	3237      	adds	r2, #55	; 0x37
    3c04:	0014      	movs	r4, r2
    3c06:	700c      	strb	r4, [r1, #0]
		param[len - 2] = HEX2ASCII((addr[5] >> 4) & 0x0f);
    3c08:	aa24      	add	r2, sp, #144	; 0x90
    3c0a:	1812      	adds	r2, r2, r0
    3c0c:	3a8a      	subs	r2, #138	; 0x8a
    3c0e:	091b      	lsrs	r3, r3, #4
    3c10:	0019      	movs	r1, r3
    3c12:	3130      	adds	r1, #48	; 0x30
    3c14:	2b09      	cmp	r3, #9
    3c16:	dd01      	ble.n	3c1c <wifiTaskExecute+0x80>
    3c18:	3337      	adds	r3, #55	; 0x37
    3c1a:	0019      	movs	r1, r3
    3c1c:	7011      	strb	r1, [r2, #0]
		param[len - 3] = HEX2ASCII((addr[4] >> 0) & 0x0f);
    3c1e:	ab24      	add	r3, sp, #144	; 0x90
    3c20:	1819      	adds	r1, r3, r0
    3c22:	398b      	subs	r1, #139	; 0x8b
    3c24:	4b66      	ldr	r3, [pc, #408]	; (3dc0 <wifiTaskExecute+0x224>)
    3c26:	791b      	ldrb	r3, [r3, #4]
    3c28:	220f      	movs	r2, #15
    3c2a:	401a      	ands	r2, r3
    3c2c:	0014      	movs	r4, r2
    3c2e:	3430      	adds	r4, #48	; 0x30
    3c30:	2a09      	cmp	r2, #9
    3c32:	dd01      	ble.n	3c38 <wifiTaskExecute+0x9c>
    3c34:	3237      	adds	r2, #55	; 0x37
    3c36:	0014      	movs	r4, r2
    3c38:	700c      	strb	r4, [r1, #0]
		param[len - 4] = HEX2ASCII((addr[4] >> 4) & 0x0f);
    3c3a:	aa24      	add	r2, sp, #144	; 0x90
    3c3c:	1812      	adds	r2, r2, r0
    3c3e:	3a8c      	subs	r2, #140	; 0x8c
    3c40:	091b      	lsrs	r3, r3, #4
    3c42:	0019      	movs	r1, r3
    3c44:	3130      	adds	r1, #48	; 0x30
    3c46:	2b09      	cmp	r3, #9
    3c48:	dd01      	ble.n	3c4e <wifiTaskExecute+0xb2>
    3c4a:	3337      	adds	r3, #55	; 0x37
    3c4c:	0019      	movs	r1, r3
    3c4e:	7011      	strb	r1, [r2, #0]
		param[len - 5] = HEX2ASCII((addr[3] >> 0) & 0x0f);
    3c50:	ab24      	add	r3, sp, #144	; 0x90
    3c52:	1819      	adds	r1, r3, r0
    3c54:	398d      	subs	r1, #141	; 0x8d
    3c56:	4b5a      	ldr	r3, [pc, #360]	; (3dc0 <wifiTaskExecute+0x224>)
    3c58:	78db      	ldrb	r3, [r3, #3]
    3c5a:	220f      	movs	r2, #15
    3c5c:	401a      	ands	r2, r3
    3c5e:	0014      	movs	r4, r2
    3c60:	3430      	adds	r4, #48	; 0x30
    3c62:	2a09      	cmp	r2, #9
    3c64:	dd01      	ble.n	3c6a <wifiTaskExecute+0xce>
    3c66:	3237      	adds	r2, #55	; 0x37
    3c68:	0014      	movs	r4, r2
    3c6a:	700c      	strb	r4, [r1, #0]
		param[len - 6] = HEX2ASCII((addr[3] >> 4) & 0x0f);
    3c6c:	aa24      	add	r2, sp, #144	; 0x90
    3c6e:	4694      	mov	ip, r2
    3c70:	4460      	add	r0, ip
    3c72:	388e      	subs	r0, #142	; 0x8e
    3c74:	091b      	lsrs	r3, r3, #4
    3c76:	001a      	movs	r2, r3
    3c78:	3230      	adds	r2, #48	; 0x30
    3c7a:	2b09      	cmp	r3, #9
    3c7c:	dd01      	ble.n	3c82 <wifiTaskExecute+0xe6>
    3c7e:	3337      	adds	r3, #55	; 0x37
    3c80:	001a      	movs	r2, r3
    3c82:	7002      	strb	r2, [r0, #0]
	
	m2m_wifi_get_mac_address(mac_addr);
	/* Generate SSID according mac addr */
	set_dev_param_to_mac(strM2MAPConfig.au8SSID, mac_addr, MAIN_WLAN_SSID_OFFSET);

	strM2MAPConfig.u8ListenChannel = MAIN_WLAN_CHANNEL;
    3c84:	ac02      	add	r4, sp, #8
    3c86:	2206      	movs	r2, #6
    3c88:	2321      	movs	r3, #33	; 0x21
    3c8a:	54e2      	strb	r2, [r4, r3]
	strM2MAPConfig.u8SecType = AP_WLAN_AUTH;
    3c8c:	3b20      	subs	r3, #32
    3c8e:	3239      	adds	r2, #57	; 0x39
    3c90:	54a3      	strb	r3, [r4, r2]
	
	strM2MAPConfig.au8DHCPServerIP[0] = 192;
    3c92:	21c0      	movs	r1, #192	; 0xc0
    3c94:	3202      	adds	r2, #2
    3c96:	54a1      	strb	r1, [r4, r2]
	strM2MAPConfig.au8DHCPServerIP[1] = 168;
    3c98:	3918      	subs	r1, #24
    3c9a:	3201      	adds	r2, #1
    3c9c:	54a1      	strb	r1, [r4, r2]
	strM2MAPConfig.au8DHCPServerIP[2] = 1; 
    3c9e:	3201      	adds	r2, #1
    3ca0:	54a3      	strb	r3, [r4, r2]
	strM2MAPConfig.au8DHCPServerIP[3] = 1;
    3ca2:	3201      	adds	r2, #1
    3ca4:	54a3      	strb	r3, [r4, r2]
	set_dev_param_to_mac(strM2MAPConfig.au8WepKey, mac_addr, MAIN_WLAN_WEP_KEY_OFFSET);

#endif

	/* Bring up AP mode with parameters structure. */
	DBG_LOG("[%s] bring up AP!\r\n", __func__);
    3ca6:	4849      	ldr	r0, [pc, #292]	; (3dcc <wifiTaskExecute+0x230>)
    3ca8:	4b49      	ldr	r3, [pc, #292]	; (3dd0 <wifiTaskExecute+0x234>)
    3caa:	4798      	blx	r3
    3cac:	4949      	ldr	r1, [pc, #292]	; (3dd4 <wifiTaskExecute+0x238>)
    3cae:	484a      	ldr	r0, [pc, #296]	; (3dd8 <wifiTaskExecute+0x23c>)
    3cb0:	4b4a      	ldr	r3, [pc, #296]	; (3ddc <wifiTaskExecute+0x240>)
    3cb2:	4798      	blx	r3
	ret = m2m_wifi_enable_ap(&strM2MAPConfig);
    3cb4:	0020      	movs	r0, r4
    3cb6:	4b4a      	ldr	r3, [pc, #296]	; (3de0 <wifiTaskExecute+0x244>)
    3cb8:	4798      	blx	r3
	if (M2M_SUCCESS != ret) {
    3cba:	2800      	cmp	r0, #0
    3cbc:	d003      	beq.n	3cc6 <wifiTaskExecute+0x12a>
		printf("main: m2m_wifi_enable_ap call error!\r\n");
    3cbe:	4849      	ldr	r0, [pc, #292]	; (3de4 <wifiTaskExecute+0x248>)
    3cc0:	4b43      	ldr	r3, [pc, #268]	; (3dd0 <wifiTaskExecute+0x234>)
    3cc2:	4798      	blx	r3
    3cc4:	e7fe      	b.n	3cc4 <wifiTaskExecute+0x128>
		while (1) {
		}
	}
	
	/* Initialize Socket module */
	socketInit();
    3cc6:	4b48      	ldr	r3, [pc, #288]	; (3de8 <wifiTaskExecute+0x24c>)
    3cc8:	4798      	blx	r3
	registerSocketCallback(m2m_wifi_socket_handler, NULL);
    3cca:	2100      	movs	r1, #0
    3ccc:	4847      	ldr	r0, [pc, #284]	; (3dec <wifiTaskExecute+0x250>)
    3cce:	4b48      	ldr	r3, [pc, #288]	; (3df0 <wifiTaskExecute+0x254>)
    3cd0:	4798      	blx	r3
	
	gAPEnabled = 1;
    3cd2:	2301      	movs	r3, #1
    3cd4:	4a47      	ldr	r2, [pc, #284]	; (3df4 <wifiTaskExecute+0x258>)
    3cd6:	7013      	strb	r3, [r2, #0]
			
		case WIFI_TASK_SWITCH_TO_AP:
			
			led_ctrl_set_color(LED_COLOR_RED, LED_MODE_BLINK_NORMAL);
			wifiSwitchtoAP();
			gu8WiFiMode = APP_AP;
    3cd8:	4a47      	ldr	r2, [pc, #284]	; (3df8 <wifiTaskExecute+0x25c>)
    3cda:	7013      	strb	r3, [r2, #0]
			wifi_states = WIFI_TASK_SWITCHING_TO_AP;
    3cdc:	2207      	movs	r2, #7
    3cde:	4b33      	ldr	r3, [pc, #204]	; (3dac <wifiTaskExecute+0x210>)
    3ce0:	701a      	strb	r2, [r3, #0]
			break;
    3ce2:	e05f      	b.n	3da4 <wifiTaskExecute+0x208>
			
		case WIFI_TASK_SWITCHING_TO_STA:
			//if (detSw0Sock>=0)
			//	unRegButtonPressDetectCallback(detSw0Sock);
			/* Connect to router. */
			DBG_LOG("connecting AP, ssid = %s , pwd= %s\n", (char *)gDefaultSSID,(char *)gDefaultKey);
    3ce4:	4839      	ldr	r0, [pc, #228]	; (3dcc <wifiTaskExecute+0x230>)
    3ce6:	4b3a      	ldr	r3, [pc, #232]	; (3dd0 <wifiTaskExecute+0x234>)
    3ce8:	4798      	blx	r3
    3cea:	4d44      	ldr	r5, [pc, #272]	; (3dfc <wifiTaskExecute+0x260>)
    3cec:	4c44      	ldr	r4, [pc, #272]	; (3e00 <wifiTaskExecute+0x264>)
    3cee:	002a      	movs	r2, r5
    3cf0:	0021      	movs	r1, r4
    3cf2:	4844      	ldr	r0, [pc, #272]	; (3e04 <wifiTaskExecute+0x268>)
    3cf4:	4b39      	ldr	r3, [pc, #228]	; (3ddc <wifiTaskExecute+0x240>)
    3cf6:	4798      	blx	r3
			gu8WiFiMode = APP_STA;
    3cf8:	2600      	movs	r6, #0
    3cfa:	4b3f      	ldr	r3, [pc, #252]	; (3df8 <wifiTaskExecute+0x25c>)
    3cfc:	701e      	strb	r6, [r3, #0]
			m2m_wifi_connect((char *)gDefaultSSID, strlen(gDefaultSSID), gAuthType, (char *)gDefaultKey, M2M_WIFI_CH_ALL);
    3cfe:	0020      	movs	r0, r4
    3d00:	4b41      	ldr	r3, [pc, #260]	; (3e08 <wifiTaskExecute+0x26c>)
    3d02:	4798      	blx	r3
    3d04:	4b41      	ldr	r3, [pc, #260]	; (3e0c <wifiTaskExecute+0x270>)
    3d06:	781a      	ldrb	r2, [r3, #0]
    3d08:	b2c1      	uxtb	r1, r0
    3d0a:	23ff      	movs	r3, #255	; 0xff
    3d0c:	9300      	str	r3, [sp, #0]
    3d0e:	002b      	movs	r3, r5
    3d10:	0020      	movs	r0, r4
    3d12:	4c3f      	ldr	r4, [pc, #252]	; (3e10 <wifiTaskExecute+0x274>)
    3d14:	47a0      	blx	r4
			wifi_states = WIFI_TASK_IDLE;
    3d16:	4b25      	ldr	r3, [pc, #148]	; (3dac <wifiTaskExecute+0x210>)
    3d18:	701e      	strb	r6, [r3, #0]
			break;
    3d1a:	e043      	b.n	3da4 <wifiTaskExecute+0x208>
			
		case WIFI_TASK_CONNECT_CLOUD:
		
			ret = cloud_connect();
    3d1c:	4b3d      	ldr	r3, [pc, #244]	; (3e14 <wifiTaskExecute+0x278>)
    3d1e:	4798      	blx	r3

			if (ret == CLOUD_RC_SUCCESS)
    3d20:	2800      	cmp	r0, #0
    3d22:	d106      	bne.n	3d32 <wifiTaskExecute+0x196>
			{
				led_ctrl_set_mode(LED_MODE_TURN_ON);
    3d24:	3002      	adds	r0, #2
    3d26:	4b3c      	ldr	r3, [pc, #240]	; (3e18 <wifiTaskExecute+0x27c>)
    3d28:	4798      	blx	r3
				wifi_states = WIFI_TASK_MQTT_SUBSCRIBE;
    3d2a:	2203      	movs	r2, #3
    3d2c:	4b1f      	ldr	r3, [pc, #124]	; (3dac <wifiTaskExecute+0x210>)
    3d2e:	701a      	strb	r2, [r3, #0]
    3d30:	e038      	b.n	3da4 <wifiTaskExecute+0x208>
			}
			else
				printf("Cloud connect fail...\r\n");
    3d32:	483a      	ldr	r0, [pc, #232]	; (3e1c <wifiTaskExecute+0x280>)
    3d34:	4b26      	ldr	r3, [pc, #152]	; (3dd0 <wifiTaskExecute+0x234>)
    3d36:	4798      	blx	r3
    3d38:	e034      	b.n	3da4 <wifiTaskExecute+0x208>
			
			break;
		
		case WIFI_TASK_MQTT_SUBSCRIBE:
			ret = cloud_mqtt_subscribe(gSubscribe_Channel, MQTTSubscribeCBCallbackHandler);
    3d3a:	4939      	ldr	r1, [pc, #228]	; (3e20 <wifiTaskExecute+0x284>)
    3d3c:	4839      	ldr	r0, [pc, #228]	; (3e24 <wifiTaskExecute+0x288>)
    3d3e:	4b3a      	ldr	r3, [pc, #232]	; (3e28 <wifiTaskExecute+0x28c>)
    3d40:	4798      	blx	r3
		
			if (ret == CLOUD_RC_SUCCESS)
    3d42:	2800      	cmp	r0, #0
    3d44:	d11f      	bne.n	3d86 <wifiTaskExecute+0x1ea>
			{
				//strcpy(gUuid, "20aaa2de-297e-413f-9ace-a1bebfccf08b");
				cloud_create_search_topic(gSearch_Channel, gUuid, SUBSCRIBE_SEARCH_TOPIC);
    3d46:	4e39      	ldr	r6, [pc, #228]	; (3e2c <wifiTaskExecute+0x290>)
    3d48:	4c39      	ldr	r4, [pc, #228]	; (3e30 <wifiTaskExecute+0x294>)
    3d4a:	4a3a      	ldr	r2, [pc, #232]	; (3e34 <wifiTaskExecute+0x298>)
    3d4c:	0031      	movs	r1, r6
    3d4e:	0020      	movs	r0, r4
    3d50:	4d39      	ldr	r5, [pc, #228]	; (3e38 <wifiTaskExecute+0x29c>)
    3d52:	47a8      	blx	r5
				cloud_create_search_topic(gSearchResp_Channel, gUuid, PUBLISH_SEARCH_RESP_TOPIC);
    3d54:	4a39      	ldr	r2, [pc, #228]	; (3e3c <wifiTaskExecute+0x2a0>)
    3d56:	0031      	movs	r1, r6
    3d58:	4839      	ldr	r0, [pc, #228]	; (3e40 <wifiTaskExecute+0x2a4>)
    3d5a:	47a8      	blx	r5
				
				DBG_LOG("subscribe search channel: %s\n", gSearch_Channel);
    3d5c:	481b      	ldr	r0, [pc, #108]	; (3dcc <wifiTaskExecute+0x230>)
    3d5e:	4b1c      	ldr	r3, [pc, #112]	; (3dd0 <wifiTaskExecute+0x234>)
    3d60:	4798      	blx	r3
    3d62:	0021      	movs	r1, r4
    3d64:	4837      	ldr	r0, [pc, #220]	; (3e44 <wifiTaskExecute+0x2a8>)
    3d66:	4b1d      	ldr	r3, [pc, #116]	; (3ddc <wifiTaskExecute+0x240>)
    3d68:	4798      	blx	r3
				ret = cloud_mqtt_subscribe(gSearch_Channel, MQTTSubscribeCBCallbackHandler);
    3d6a:	492d      	ldr	r1, [pc, #180]	; (3e20 <wifiTaskExecute+0x284>)
    3d6c:	0020      	movs	r0, r4
    3d6e:	4b2e      	ldr	r3, [pc, #184]	; (3e28 <wifiTaskExecute+0x28c>)
    3d70:	4798      	blx	r3
				if (ret == CLOUD_RC_SUCCESS)
    3d72:	2800      	cmp	r0, #0
    3d74:	d103      	bne.n	3d7e <wifiTaskExecute+0x1e2>
					wifi_states = WIFI_TASK_MQTT_RUNNING;
    3d76:	2204      	movs	r2, #4
    3d78:	4b0c      	ldr	r3, [pc, #48]	; (3dac <wifiTaskExecute+0x210>)
    3d7a:	701a      	strb	r2, [r3, #0]
    3d7c:	e012      	b.n	3da4 <wifiTaskExecute+0x208>
				else
					printf("Publish MQTT channel fail...\r\n");
    3d7e:	4832      	ldr	r0, [pc, #200]	; (3e48 <wifiTaskExecute+0x2ac>)
    3d80:	4b13      	ldr	r3, [pc, #76]	; (3dd0 <wifiTaskExecute+0x234>)
    3d82:	4798      	blx	r3
    3d84:	e00e      	b.n	3da4 <wifiTaskExecute+0x208>
			}
			else
				printf("Publish MQTT channel fail...\r\n");
    3d86:	4830      	ldr	r0, [pc, #192]	; (3e48 <wifiTaskExecute+0x2ac>)
    3d88:	4b11      	ldr	r3, [pc, #68]	; (3dd0 <wifiTaskExecute+0x234>)
    3d8a:	4798      	blx	r3
    3d8c:	e00a      	b.n	3da4 <wifiTaskExecute+0x208>
			break;
			
		case WIFI_TASK_MQTT_RUNNING:
			
			//Max time the yield function will wait for read messages
			ret = cloud_mqtt_yield(100);
    3d8e:	2064      	movs	r0, #100	; 0x64
    3d90:	4b2e      	ldr	r3, [pc, #184]	; (3e4c <wifiTaskExecute+0x2b0>)
    3d92:	4798      	blx	r3
			if(CLOUD_RC_NETWORK_ATTEMPTING_RECONNECT == ret){
    3d94:	3019      	adds	r0, #25
    3d96:	d105      	bne.n	3da4 <wifiTaskExecute+0x208>
				printf("-->sleep reconnect\r\n");
    3d98:	482d      	ldr	r0, [pc, #180]	; (3e50 <wifiTaskExecute+0x2b4>)
    3d9a:	4b0d      	ldr	r3, [pc, #52]	; (3dd0 <wifiTaskExecute+0x234>)
    3d9c:	4798      	blx	r3
				delay_ms(1);
    3d9e:	2001      	movs	r0, #1
    3da0:	4b2c      	ldr	r3, [pc, #176]	; (3e54 <wifiTaskExecute+0x2b8>)
    3da2:	4798      	blx	r3
		default:
				break;
		
	}
	
}
    3da4:	b024      	add	sp, #144	; 0x90
    3da6:	bd70      	pop	{r4, r5, r6, pc}
    3da8:	000050d5 	.word	0x000050d5
    3dac:	2000010d 	.word	0x2000010d
    3db0:	00013a54 	.word	0x00013a54
    3db4:	00002b19 	.word	0x00002b19
    3db8:	00011845 	.word	0x00011845
    3dbc:	00014060 	.word	0x00014060
    3dc0:	2000023c 	.word	0x2000023c
    3dc4:	000053d9 	.word	0x000053d9
    3dc8:	0000427d 	.word	0x0000427d
    3dcc:	000140b0 	.word	0x000140b0
    3dd0:	00011aad 	.word	0x00011aad
    3dd4:	00013a94 	.word	0x00013a94
    3dd8:	00014078 	.word	0x00014078
    3ddc:	0001198d 	.word	0x0001198d
    3de0:	00005385 	.word	0x00005385
    3de4:	0001408c 	.word	0x0001408c
    3de8:	00006ca5 	.word	0x00006ca5
    3dec:	000037a5 	.word	0x000037a5
    3df0:	00006ce9 	.word	0x00006ce9
    3df4:	200002e7 	.word	0x200002e7
    3df8:	20000864 	.word	0x20000864
    3dfc:	200001f8 	.word	0x200001f8
    3e00:	200008a4 	.word	0x200008a4
    3e04:	000140b4 	.word	0x000140b4
    3e08:	00011d75 	.word	0x00011d75
    3e0c:	200002e8 	.word	0x200002e8
    3e10:	00005365 	.word	0x00005365
    3e14:	00001d31 	.word	0x00001d31
    3e18:	00002c49 	.word	0x00002c49
    3e1c:	000140d8 	.word	0x000140d8
    3e20:	00003451 	.word	0x00003451
    3e24:	20001b08 	.word	0x20001b08
    3e28:	00001eb5 	.word	0x00001eb5
    3e2c:	20000868 	.word	0x20000868
    3e30:	20001acc 	.word	0x20001acc
    3e34:	00013844 	.word	0x00013844
    3e38:	00001f2d 	.word	0x00001f2d
    3e3c:	00013850 	.word	0x00013850
    3e40:	20001a90 	.word	0x20001a90
    3e44:	000140f0 	.word	0x000140f0
    3e48:	00014110 	.word	0x00014110
    3e4c:	00001e45 	.word	0x00001e45
    3e50:	00014130 	.word	0x00014130
    3e54:	0000c4f5 	.word	0x0000c4f5

00003e58 <chip_isr>:
#include "conf_winc.h"

static tpfNmBspIsr gpfIsr;

static void chip_isr(void)
{
    3e58:	b510      	push	{r4, lr}
	if (gpfIsr) {
    3e5a:	4b03      	ldr	r3, [pc, #12]	; (3e68 <chip_isr+0x10>)
    3e5c:	681b      	ldr	r3, [r3, #0]
    3e5e:	2b00      	cmp	r3, #0
    3e60:	d000      	beq.n	3e64 <chip_isr+0xc>
		gpfIsr();
    3e62:	4798      	blx	r3
	}
}
    3e64:	bd10      	pop	{r4, pc}
    3e66:	46c0      	nop			; (mov r8, r8)
    3e68:	200008c8 	.word	0x200008c8

00003e6c <nm_bsp_sleep>:
 *	@brief	Sleep in units of mSec
 *	@param[IN]	u32TimeMsec
 *				Time in milliseconds
 */
void nm_bsp_sleep(uint32 u32TimeMsec)
{
    3e6c:	b570      	push	{r4, r5, r6, lr}
	while (u32TimeMsec--) {
    3e6e:	2800      	cmp	r0, #0
    3e70:	d006      	beq.n	3e80 <nm_bsp_sleep+0x14>
    3e72:	0004      	movs	r4, r0
		delay_ms(1);
    3e74:	4d03      	ldr	r5, [pc, #12]	; (3e84 <nm_bsp_sleep+0x18>)
    3e76:	2001      	movs	r0, #1
    3e78:	47a8      	blx	r5
    3e7a:	3c01      	subs	r4, #1
 *	@param[IN]	u32TimeMsec
 *				Time in milliseconds
 */
void nm_bsp_sleep(uint32 u32TimeMsec)
{
	while (u32TimeMsec--) {
    3e7c:	2c00      	cmp	r4, #0
    3e7e:	d1fa      	bne.n	3e76 <nm_bsp_sleep+0xa>
		delay_ms(1);
	}
}
    3e80:	bd70      	pop	{r4, r5, r6, pc}
    3e82:	46c0      	nop			; (mov r8, r8)
    3e84:	0000c4f5 	.word	0x0000c4f5

00003e88 <nm_bsp_reset>:
 *	@fn		nm_bsp_reset
 *	@brief	Reset NMC1500 SoC by setting CHIP_EN and RESET_N signals low,
 *           CHIP_EN high then RESET_N high
 */
void nm_bsp_reset(void)
{
    3e88:	b5f0      	push	{r4, r5, r6, r7, lr}
    3e8a:	4647      	mov	r7, r8
    3e8c:	b480      	push	{r7}
    3e8e:	4d0b      	ldr	r5, [pc, #44]	; (3ebc <nm_bsp_reset+0x34>)
    3e90:	002f      	movs	r7, r5
    3e92:	3780      	adds	r7, #128	; 0x80
    3e94:	2380      	movs	r3, #128	; 0x80
    3e96:	009b      	lsls	r3, r3, #2
    3e98:	4698      	mov	r8, r3
    3e9a:	617b      	str	r3, [r7, #20]
    3e9c:	2608      	movs	r6, #8
    3e9e:	616e      	str	r6, [r5, #20]
	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, false);
	port_pin_set_output_level(CONF_WINC_PIN_RESET, false);
	nm_bsp_sleep(100);
    3ea0:	2064      	movs	r0, #100	; 0x64
    3ea2:	4c07      	ldr	r4, [pc, #28]	; (3ec0 <nm_bsp_reset+0x38>)
    3ea4:	47a0      	blx	r4
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    3ea6:	4643      	mov	r3, r8
    3ea8:	61bb      	str	r3, [r7, #24]
	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, true);
	nm_bsp_sleep(100);
    3eaa:	2064      	movs	r0, #100	; 0x64
    3eac:	47a0      	blx	r4
    3eae:	61ae      	str	r6, [r5, #24]
	port_pin_set_output_level(CONF_WINC_PIN_RESET, true);
	nm_bsp_sleep(100);
    3eb0:	2064      	movs	r0, #100	; 0x64
    3eb2:	47a0      	blx	r4
}
    3eb4:	bc04      	pop	{r2}
    3eb6:	4690      	mov	r8, r2
    3eb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3eba:	46c0      	nop			; (mov r8, r8)
    3ebc:	40002800 	.word	0x40002800
    3ec0:	00003e6d 	.word	0x00003e6d

00003ec4 <nm_bsp_init>:
 *	@fn		nm_bsp_init
 *	@brief	Initialize BSP
 *	@return	0 in case of success and -1 in case of failure
 */
sint8 nm_bsp_init(void)
{
    3ec4:	b570      	push	{r4, r5, r6, lr}
    3ec6:	b082      	sub	sp, #8
	gpfIsr = NULL;
    3ec8:	2300      	movs	r3, #0
    3eca:	4a17      	ldr	r2, [pc, #92]	; (3f28 <nm_bsp_init+0x64>)
    3ecc:	6013      	str	r3, [r2, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    3ece:	ac01      	add	r4, sp, #4
    3ed0:	2501      	movs	r5, #1
    3ed2:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
    3ed4:	70a3      	strb	r3, [r4, #2]
	struct port_config pin_conf;

	port_get_config_defaults(&pin_conf);

	/* Configure control pins as output. */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    3ed6:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(CONF_WINC_PIN_RESET, &pin_conf);
    3ed8:	0021      	movs	r1, r4
    3eda:	2003      	movs	r0, #3
    3edc:	4e13      	ldr	r6, [pc, #76]	; (3f2c <nm_bsp_init+0x68>)
    3ede:	47b0      	blx	r6
	port_pin_set_config(CONF_WINC_PIN_CHIP_ENABLE, &pin_conf);
    3ee0:	0021      	movs	r1, r4
    3ee2:	2029      	movs	r0, #41	; 0x29
    3ee4:	47b0      	blx	r6
	port_pin_set_config(CONF_WINC_PIN_WAKE, &pin_conf);
    3ee6:	0021      	movs	r1, r4
    3ee8:	2028      	movs	r0, #40	; 0x28
    3eea:	47b0      	blx	r6

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    3eec:	4b10      	ldr	r3, [pc, #64]	; (3f30 <nm_bsp_init+0x6c>)
    3eee:	001a      	movs	r2, r3
    3ef0:	3280      	adds	r2, #128	; 0x80
    3ef2:	2180      	movs	r1, #128	; 0x80
    3ef4:	0089      	lsls	r1, r1, #2
    3ef6:	6151      	str	r1, [r2, #20]
    3ef8:	2208      	movs	r2, #8
    3efa:	615a      	str	r2, [r3, #20]

	/* Initialize chip IOs. */
	init_chip_pins();

    /* Make sure a 1ms Systick is configured. */
    if (!(SysTick->CTRL & SysTick_CTRL_ENABLE_Msk && SysTick->CTRL & SysTick_CTRL_TICKINT_Msk)) {
    3efc:	4b0d      	ldr	r3, [pc, #52]	; (3f34 <nm_bsp_init+0x70>)
    3efe:	681b      	ldr	r3, [r3, #0]
    3f00:	421d      	tst	r5, r3
    3f02:	d003      	beq.n	3f0c <nm_bsp_init+0x48>
    3f04:	4b0b      	ldr	r3, [pc, #44]	; (3f34 <nm_bsp_init+0x70>)
    3f06:	681b      	ldr	r3, [r3, #0]
    3f08:	079b      	lsls	r3, r3, #30
    3f0a:	d401      	bmi.n	3f10 <nm_bsp_init+0x4c>
	    delay_init();
    3f0c:	4b0a      	ldr	r3, [pc, #40]	; (3f38 <nm_bsp_init+0x74>)
    3f0e:	4798      	blx	r3
    }

	/* Perform chip reset. */
	nm_bsp_reset();
    3f10:	4b0a      	ldr	r3, [pc, #40]	; (3f3c <nm_bsp_init+0x78>)
    3f12:	4798      	blx	r3
 *
 * Enables global interrupts in the device to fire any enabled interrupt handlers.
 */
static inline void system_interrupt_enable_global(void)
{
	cpu_irq_enable();
    3f14:	2201      	movs	r2, #1
    3f16:	4b0a      	ldr	r3, [pc, #40]	; (3f40 <nm_bsp_init+0x7c>)
    3f18:	701a      	strb	r2, [r3, #0]
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    3f1a:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    3f1e:	b662      	cpsie	i

	system_interrupt_enable_global();

	return M2M_SUCCESS;
}
    3f20:	2000      	movs	r0, #0
    3f22:	b002      	add	sp, #8
    3f24:	bd70      	pop	{r4, r5, r6, pc}
    3f26:	46c0      	nop			; (mov r8, r8)
    3f28:	200008c8 	.word	0x200008c8
    3f2c:	0000c7c5 	.word	0x0000c7c5
    3f30:	40002800 	.word	0x40002800
    3f34:	e000e010 	.word	0xe000e010
    3f38:	0000c4b5 	.word	0x0000c4b5
    3f3c:	00003e89 	.word	0x00003e89
    3f40:	20000138 	.word	0x20000138

00003f44 <nm_bsp_register_isr>:
 *	@brief	Register interrupt service routine
 *	@param[IN]	pfIsr
 *				Pointer to ISR handler
 */
void nm_bsp_register_isr(tpfNmBspIsr pfIsr)
{
    3f44:	b510      	push	{r4, lr}
    3f46:	b084      	sub	sp, #16
	struct extint_chan_conf config_extint_chan;

	gpfIsr = pfIsr;
    3f48:	4b0e      	ldr	r3, [pc, #56]	; (3f84 <nm_bsp_register_isr+0x40>)
    3f4a:	6018      	str	r0, [r3, #0]

	extint_chan_get_config_defaults(&config_extint_chan);
    3f4c:	ac01      	add	r4, sp, #4
    3f4e:	0020      	movs	r0, r4
    3f50:	4b0d      	ldr	r3, [pc, #52]	; (3f88 <nm_bsp_register_isr+0x44>)
    3f52:	4798      	blx	r3
	config_extint_chan.gpio_pin = CONF_WINC_SPI_INT_PIN;
    3f54:	2310      	movs	r3, #16
    3f56:	9301      	str	r3, [sp, #4]
	config_extint_chan.gpio_pin_mux = CONF_WINC_SPI_INT_MUX;
    3f58:	2300      	movs	r3, #0
    3f5a:	6063      	str	r3, [r4, #4]
	config_extint_chan.gpio_pin_pull = EXTINT_PULL_UP;
    3f5c:	3301      	adds	r3, #1
    3f5e:	7223      	strb	r3, [r4, #8]
	config_extint_chan.detection_criteria = EXTINT_DETECT_FALLING;
    3f60:	3301      	adds	r3, #1
    3f62:	72e3      	strb	r3, [r4, #11]
	//config_extint_chan.detection_criteria = EXTINT_DETECT_LOW;

	extint_chan_set_config(CONF_WINC_SPI_INT_EIC, &config_extint_chan);
    3f64:	0021      	movs	r1, r4
    3f66:	2000      	movs	r0, #0
    3f68:	4b08      	ldr	r3, [pc, #32]	; (3f8c <nm_bsp_register_isr+0x48>)
    3f6a:	4798      	blx	r3
	extint_register_callback(chip_isr, CONF_WINC_SPI_INT_EIC,
    3f6c:	2200      	movs	r2, #0
    3f6e:	2100      	movs	r1, #0
    3f70:	4807      	ldr	r0, [pc, #28]	; (3f90 <nm_bsp_register_isr+0x4c>)
    3f72:	4b08      	ldr	r3, [pc, #32]	; (3f94 <nm_bsp_register_isr+0x50>)
    3f74:	4798      	blx	r3
			EXTINT_CALLBACK_TYPE_DETECT);
	extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
    3f76:	2100      	movs	r1, #0
    3f78:	2000      	movs	r0, #0
    3f7a:	4b07      	ldr	r3, [pc, #28]	; (3f98 <nm_bsp_register_isr+0x54>)
    3f7c:	4798      	blx	r3
			EXTINT_CALLBACK_TYPE_DETECT);
}
    3f7e:	b004      	add	sp, #16
    3f80:	bd10      	pop	{r4, pc}
    3f82:	46c0      	nop			; (mov r8, r8)
    3f84:	200008c8 	.word	0x200008c8
    3f88:	0000c729 	.word	0x0000c729
    3f8c:	0000c73d 	.word	0x0000c73d
    3f90:	00003e59 	.word	0x00003e59
    3f94:	0000c591 	.word	0x0000c591
    3f98:	0000c5bd 	.word	0x0000c5bd

00003f9c <nm_bsp_interrupt_ctrl>:
 *	@brief	Enable/Disable interrupts
 *	@param[IN]	u8Enable
 *				'0' disable interrupts. '1' enable interrupts
 */
void nm_bsp_interrupt_ctrl(uint8 u8Enable)
{
    3f9c:	b510      	push	{r4, lr}
	if (u8Enable) {
    3f9e:	2800      	cmp	r0, #0
    3fa0:	d004      	beq.n	3fac <nm_bsp_interrupt_ctrl+0x10>
		extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
    3fa2:	2100      	movs	r1, #0
    3fa4:	2000      	movs	r0, #0
    3fa6:	4b04      	ldr	r3, [pc, #16]	; (3fb8 <nm_bsp_interrupt_ctrl+0x1c>)
    3fa8:	4798      	blx	r3
    3faa:	e003      	b.n	3fb4 <nm_bsp_interrupt_ctrl+0x18>
				EXTINT_CALLBACK_TYPE_DETECT);
	} else {
		extint_chan_disable_callback(CONF_WINC_SPI_INT_EIC,
    3fac:	2100      	movs	r1, #0
    3fae:	2000      	movs	r0, #0
    3fb0:	4b02      	ldr	r3, [pc, #8]	; (3fbc <nm_bsp_interrupt_ctrl+0x20>)
    3fb2:	4798      	blx	r3
				EXTINT_CALLBACK_TYPE_DETECT);
	}
}
    3fb4:	bd10      	pop	{r4, pc}
    3fb6:	46c0      	nop			; (mov r8, r8)
    3fb8:	0000c5bd 	.word	0x0000c5bd
    3fbc:	0000c5dd 	.word	0x0000c5dd

00003fc0 <nm_bus_init>:
*	@fn		nm_bus_init
*	@brief	Initialize the bus wrapper
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*/
sint8 nm_bus_init(void *pvinit)
{
    3fc0:	b530      	push	{r4, r5, lr}
    3fc2:	b091      	sub	sp, #68	; 0x44
		const struct spi_slave_inst_config *const config)
{
	Assert(slave);
	Assert(config);

	slave->ss_pin          = config->ss_pin;
    3fc4:	4c31      	ldr	r4, [pc, #196]	; (408c <nm_bus_init+0xcc>)
    3fc6:	2306      	movs	r3, #6
    3fc8:	7023      	strb	r3, [r4, #0]
	slave->address_enabled = config->address_enabled;
    3fca:	2300      	movs	r3, #0
    3fcc:	7063      	strb	r3, [r4, #1]
	slave->address         = config->address;
    3fce:	70a3      	strb	r3, [r4, #2]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    3fd0:	a901      	add	r1, sp, #4
    3fd2:	2201      	movs	r2, #1
    3fd4:	704a      	strb	r2, [r1, #1]
	config->powersave  = false;
    3fd6:	708b      	strb	r3, [r1, #2]
	/* Get default config for pin */
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Edit config to set the pin as output */
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
    3fd8:	700a      	strb	r2, [r1, #0]

	/* Set config on Slave Select pin */
	port_pin_set_config(slave->ss_pin, &pin_conf);
    3fda:	2006      	movs	r0, #6
    3fdc:	4b2c      	ldr	r3, [pc, #176]	; (4090 <nm_bus_init+0xd0>)
    3fde:	4798      	blx	r3
	port_pin_set_output_level(slave->ss_pin, true);
    3fe0:	7823      	ldrb	r3, [r4, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    3fe2:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    3fe4:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    3fe6:	2900      	cmp	r1, #0
    3fe8:	d104      	bne.n	3ff4 <nm_bus_init+0x34>
		return &(ports[port_index]->Group[group_index]);
    3fea:	095a      	lsrs	r2, r3, #5
    3fec:	01d2      	lsls	r2, r2, #7
    3fee:	4929      	ldr	r1, [pc, #164]	; (4094 <nm_bus_init+0xd4>)
    3ff0:	468c      	mov	ip, r1
    3ff2:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    3ff4:	211f      	movs	r1, #31
    3ff6:	400b      	ands	r3, r1
    3ff8:	391e      	subs	r1, #30
    3ffa:	0008      	movs	r0, r1
    3ffc:	4098      	lsls	r0, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    3ffe:	6190      	str	r0, [r2, #24]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
    4000:	ac02      	add	r4, sp, #8
    4002:	7021      	strb	r1, [r4, #0]
	config->data_order       = SPI_DATA_ORDER_MSB;
    4004:	2300      	movs	r3, #0
    4006:	9303      	str	r3, [sp, #12]
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
    4008:	9304      	str	r3, [sp, #16]
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
    400a:	22c0      	movs	r2, #192	; 0xc0
    400c:	0392      	lsls	r2, r2, #14
    400e:	9205      	str	r2, [sp, #20]
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
    4010:	7423      	strb	r3, [r4, #16]
	config->run_in_standby   = false;
    4012:	7463      	strb	r3, [r4, #17]
	config->receiver_enable  = true;
    4014:	74a1      	strb	r1, [r4, #18]
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	config->select_slave_low_detect_enable= true;
    4016:	74e1      	strb	r1, [r4, #19]
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
    4018:	7523      	strb	r3, [r4, #20]
#  endif
	config->generator_source = GCLK_GENERATOR_0;
    401a:	2224      	movs	r2, #36	; 0x24
    401c:	54a3      	strb	r3, [r4, r2]

	/* Clear mode specific config */
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
    401e:	3a18      	subs	r2, #24
    4020:	2100      	movs	r1, #0
    4022:	a808      	add	r0, sp, #32
    4024:	4b1c      	ldr	r3, [pc, #112]	; (4098 <nm_bus_init+0xd8>)
    4026:	4798      	blx	r3
	spi_attach_slave(&slave_inst, &slave_config);

	/* Configure the SPI master. */
	spi_get_config_defaults(&config);
	config.mux_setting = CONF_WINC_SPI_SERCOM_MUX;
	config.pinmux_pad0 = CONF_WINC_SPI_PINMUX_PAD0;
    4028:	4b1c      	ldr	r3, [pc, #112]	; (409c <nm_bus_init+0xdc>)
    402a:	62a3      	str	r3, [r4, #40]	; 0x28
	config.pinmux_pad1 = CONF_WINC_SPI_PINMUX_PAD1;
    402c:	4b1c      	ldr	r3, [pc, #112]	; (40a0 <nm_bus_init+0xe0>)
    402e:	62e3      	str	r3, [r4, #44]	; 0x2c
	config.pinmux_pad2 = CONF_WINC_SPI_PINMUX_PAD2;
    4030:	2301      	movs	r3, #1
    4032:	425b      	negs	r3, r3
    4034:	6323      	str	r3, [r4, #48]	; 0x30
	config.pinmux_pad3 = CONF_WINC_SPI_PINMUX_PAD3;
    4036:	4b1b      	ldr	r3, [pc, #108]	; (40a4 <nm_bus_init+0xe4>)
    4038:	6363      	str	r3, [r4, #52]	; 0x34
	config.master_slave_select_enable = false;

	config.mode_specific.master.baudrate = CONF_WINC_SPI_CLOCK;
    403a:	4b1b      	ldr	r3, [pc, #108]	; (40a8 <nm_bus_init+0xe8>)
    403c:	61a3      	str	r3, [r4, #24]
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
    403e:	0022      	movs	r2, r4
    4040:	2184      	movs	r1, #132	; 0x84
    4042:	05c9      	lsls	r1, r1, #23
    4044:	4819      	ldr	r0, [pc, #100]	; (40ac <nm_bus_init+0xec>)
    4046:	4b1a      	ldr	r3, [pc, #104]	; (40b0 <nm_bus_init+0xf0>)
    4048:	4798      	blx	r3
    404a:	2800      	cmp	r0, #0
    404c:	d119      	bne.n	4082 <nm_bus_init+0xc2>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    404e:	4d17      	ldr	r5, [pc, #92]	; (40ac <nm_bus_init+0xec>)
    4050:	682c      	ldr	r4, [r5, #0]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    4052:	0020      	movs	r0, r4
    4054:	4b17      	ldr	r3, [pc, #92]	; (40b4 <nm_bus_init+0xf4>)
    4056:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    4058:	231f      	movs	r3, #31
    405a:	4018      	ands	r0, r3
    405c:	3b1e      	subs	r3, #30
    405e:	4083      	lsls	r3, r0
    4060:	4a15      	ldr	r2, [pc, #84]	; (40b8 <nm_bus_init+0xf8>)
    4062:	6013      	str	r3, [r2, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4064:	682a      	ldr	r2, [r5, #0]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
    4066:	69d3      	ldr	r3, [r2, #28]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
    4068:	2b00      	cmp	r3, #0
    406a:	d1fc      	bne.n	4066 <nm_bus_init+0xa6>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
    406c:	6822      	ldr	r2, [r4, #0]
    406e:	3302      	adds	r3, #2
    4070:	4313      	orrs	r3, r2
    4072:	6023      	str	r3, [r4, #0]
	}

	/* Enable the SPI master. */
	spi_enable(&master);

	nm_bsp_reset();
    4074:	4b11      	ldr	r3, [pc, #68]	; (40bc <nm_bus_init+0xfc>)
    4076:	4798      	blx	r3
	nm_bsp_sleep(1);
    4078:	2001      	movs	r0, #1
    407a:	4b11      	ldr	r3, [pc, #68]	; (40c0 <nm_bus_init+0x100>)
    407c:	4798      	blx	r3
#endif
	return result;
    407e:	2000      	movs	r0, #0
    4080:	e001      	b.n	4086 <nm_bus_init+0xc6>
	config.pinmux_pad3 = CONF_WINC_SPI_PINMUX_PAD3;
	config.master_slave_select_enable = false;

	config.mode_specific.master.baudrate = CONF_WINC_SPI_CLOCK;
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
		return M2M_ERR_BUS_FAIL;
    4082:	2006      	movs	r0, #6
    4084:	4240      	negs	r0, r0

	nm_bsp_reset();
	nm_bsp_sleep(1);
#endif
	return result;
}
    4086:	b011      	add	sp, #68	; 0x44
    4088:	bd30      	pop	{r4, r5, pc}
    408a:	46c0      	nop			; (mov r8, r8)
    408c:	20002230 	.word	0x20002230
    4090:	0000c7c5 	.word	0x0000c7c5
    4094:	40002800 	.word	0x40002800
    4098:	00011845 	.word	0x00011845
    409c:	00040003 	.word	0x00040003
    40a0:	00050003 	.word	0x00050003
    40a4:	00070003 	.word	0x00070003
    40a8:	00b71b00 	.word	0x00b71b00
    40ac:	20002234 	.word	0x20002234
    40b0:	000072fd 	.word	0x000072fd
    40b4:	0000cc25 	.word	0x0000cc25
    40b8:	e000e100 	.word	0xe000e100
    40bc:	00003e89 	.word	0x00003e89
    40c0:	00003e6d 	.word	0x00003e6d

000040c4 <nm_bus_ioctl>:
*					Arbitrary parameter depenging on IOCTL
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*	@note	For SPI only, it's important to be able to send/receive at the same time
*/
sint8 nm_bus_ioctl(uint8 u8Cmd, void* pvParameter)
{
    40c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    40c6:	465f      	mov	r7, fp
    40c8:	4656      	mov	r6, sl
    40ca:	464d      	mov	r5, r9
    40cc:	4644      	mov	r4, r8
    40ce:	b4f0      	push	{r4, r5, r6, r7}
    40d0:	b085      	sub	sp, #20
	sint8 s8Ret = 0;
	switch(u8Cmd)
    40d2:	2803      	cmp	r0, #3
    40d4:	d164      	bne.n	41a0 <nm_bus_ioctl+0xdc>
		}
		break;
#elif defined CONF_WINC_USE_SPI
		case NM_BUS_IOCTL_RW: {
			tstrNmSpiRw *pstrParam = (tstrNmSpiRw *)pvParameter;
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
    40d6:	680f      	ldr	r7, [r1, #0]
    40d8:	684e      	ldr	r6, [r1, #4]
    40da:	890d      	ldrh	r5, [r1, #8]
struct spi_module master;
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
    40dc:	2200      	movs	r2, #0
    40de:	ab02      	add	r3, sp, #8
    40e0:	71da      	strb	r2, [r3, #7]
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
	uint16_t txd_data = 0;
	uint16_t rxd_data = 0;

	
	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) || (u16Sz == 0)) {
    40e2:	2e00      	cmp	r6, #0
    40e4:	d102      	bne.n	40ec <nm_bus_ioctl+0x28>
    40e6:	2f00      	cmp	r7, #0
    40e8:	d17a      	bne.n	41e0 <nm_bus_ioctl+0x11c>
    40ea:	e050      	b.n	418e <nm_bus_ioctl+0xca>
    40ec:	2d00      	cmp	r5, #0
    40ee:	d051      	beq.n	4194 <nm_bus_ioctl+0xd0>
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
    40f0:	2300      	movs	r3, #0
    40f2:	9301      	str	r3, [sp, #4]
	
	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) || (u16Sz == 0)) {
		return M2M_ERR_INVALID_ARG;
	}

	if (pu8Mosi == NULL) {
    40f4:	2f00      	cmp	r7, #0
    40f6:	d103      	bne.n	4100 <nm_bus_ioctl+0x3c>
		pu8Mosi = &u8Dummy;
		u8SkipMosi = 1;
    40f8:	3301      	adds	r3, #1
    40fa:	9301      	str	r3, [sp, #4]
	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) || (u16Sz == 0)) {
		return M2M_ERR_INVALID_ARG;
	}

	if (pu8Mosi == NULL) {
		pu8Mosi = &u8Dummy;
    40fc:	ab02      	add	r3, sp, #8
    40fe:	1ddf      	adds	r7, r3, #7
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
    4100:	2400      	movs	r4, #0

	if (pu8Mosi == NULL) {
		pu8Mosi = &u8Dummy;
		u8SkipMosi = 1;
	}
	if(pu8Miso == NULL) {
    4102:	2e00      	cmp	r6, #0
    4104:	d15b      	bne.n	41be <nm_bus_ioctl+0xfa>
		pu8Miso = &u8Dummy;
		u8SkipMiso = 1;
    4106:	3401      	adds	r4, #1
	if (pu8Mosi == NULL) {
		pu8Mosi = &u8Dummy;
		u8SkipMosi = 1;
	}
	if(pu8Miso == NULL) {
		pu8Miso = &u8Dummy;
    4108:	ab02      	add	r3, sp, #8
    410a:	1dde      	adds	r6, r3, #7
    410c:	e057      	b.n	41be <nm_bus_ioctl+0xfa>


	spi_select_slave(&master, &slave_inst, true);

	while (u16Sz) {
		txd_data = *pu8Mosi;
    410e:	783c      	ldrb	r4, [r7, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4110:	4653      	mov	r3, sl
    4112:	681b      	ldr	r3, [r3, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    4114:	7e19      	ldrb	r1, [r3, #24]
		while (!spi_is_ready_to_write(&master))
    4116:	4201      	tst	r1, r0
    4118:	d0fc      	beq.n	4114 <nm_bus_ioctl+0x50>
    411a:	7e19      	ldrb	r1, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    411c:	4201      	tst	r1, r0
    411e:	d0fc      	beq.n	411a <nm_bus_ioctl+0x56>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    4120:	629c      	str	r4, [r3, #40]	; 0x28
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    4122:	7e19      	ldrb	r1, [r3, #24]
			;
		while(spi_write(&master, txd_data) != STATUS_OK)
			;

		/* Read SPI master data register. */
		while (!spi_is_ready_to_read(&master))
    4124:	4211      	tst	r1, r2
    4126:	d0fc      	beq.n	4122 <nm_bus_ioctl+0x5e>
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    4128:	4649      	mov	r1, r9
    412a:	798c      	ldrb	r4, [r1, #6]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    412c:	7e19      	ldrb	r1, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    412e:	4211      	tst	r1, r2
    4130:	d0fc      	beq.n	412c <nm_bus_ioctl+0x68>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    4132:	8b59      	ldrh	r1, [r3, #26]
		/* No data has been received, return */
		return STATUS_ERR_IO;
	}

	/* Return value */
	enum status_code retval = STATUS_OK;
    4134:	2500      	movs	r5, #0

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    4136:	4211      	tst	r1, r2
    4138:	d005      	beq.n	4146 <nm_bus_ioctl+0x82>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    413a:	8b59      	ldrh	r1, [r3, #26]
    413c:	4645      	mov	r5, r8
    413e:	4329      	orrs	r1, r5
    4140:	b289      	uxth	r1, r1
    4142:	8359      	strh	r1, [r3, #26]
	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
		retval = STATUS_ERR_OVERFLOW;
    4144:	251e      	movs	r5, #30
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    4146:	2c01      	cmp	r4, #1
    4148:	d103      	bne.n	4152 <nm_bus_ioctl+0x8e>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    414a:	6a99      	ldr	r1, [r3, #40]	; 0x28
    414c:	05c9      	lsls	r1, r1, #23
    414e:	0dc9      	lsrs	r1, r1, #23
    4150:	e001      	b.n	4156 <nm_bus_ioctl+0x92>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    4152:	6a99      	ldr	r1, [r3, #40]	; 0x28
    4154:	b2c9      	uxtb	r1, r1
			;
		while (spi_read(&master, &rxd_data) != STATUS_OK)
    4156:	2d00      	cmp	r5, #0
    4158:	d1e8      	bne.n	412c <nm_bus_ioctl+0x68>
			;
		*pu8Miso = rxd_data;
    415a:	7031      	strb	r1, [r6, #0]

		u16Sz--;
    415c:	9d00      	ldr	r5, [sp, #0]
    415e:	3d01      	subs	r5, #1
    4160:	b2ab      	uxth	r3, r5
    4162:	001c      	movs	r4, r3
    4164:	9300      	str	r3, [sp, #0]
		if (!u8SkipMiso)
			pu8Miso++;
    4166:	445e      	add	r6, fp
		if (!u8SkipMosi)
			pu8Mosi++;
    4168:	9b01      	ldr	r3, [sp, #4]
    416a:	4259      	negs	r1, r3
    416c:	414b      	adcs	r3, r1
    416e:	18ff      	adds	r7, r7, r3
	}


	spi_select_slave(&master, &slave_inst, true);

	while (u16Sz) {
    4170:	2c00      	cmp	r4, #0
    4172:	d1cc      	bne.n	410e <nm_bus_ioctl+0x4a>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4174:	4b20      	ldr	r3, [pc, #128]	; (41f8 <nm_bus_ioctl+0x134>)
    4176:	6819      	ldr	r1, [r3, #0]
			pu8Miso++;
		if (!u8SkipMosi)
			pu8Mosi++;
	}

	while (!spi_is_write_complete(&master))
    4178:	2202      	movs	r2, #2

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    417a:	7e0b      	ldrb	r3, [r1, #24]
    417c:	4213      	tst	r3, r2
    417e:	d0fc      	beq.n	417a <nm_bus_ioctl+0xb6>
		;

	spi_select_slave(&master, &slave_inst, false);
    4180:	2200      	movs	r2, #0
    4182:	491e      	ldr	r1, [pc, #120]	; (41fc <nm_bus_ioctl+0x138>)
    4184:	481c      	ldr	r0, [pc, #112]	; (41f8 <nm_bus_ioctl+0x134>)
    4186:	4b1e      	ldr	r3, [pc, #120]	; (4200 <nm_bus_ioctl+0x13c>)
    4188:	4798      	blx	r3

	return M2M_SUCCESS;
    418a:	2000      	movs	r0, #0
    418c:	e02d      	b.n	41ea <nm_bus_ioctl+0x126>
	uint16_t txd_data = 0;
	uint16_t rxd_data = 0;

	
	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) || (u16Sz == 0)) {
		return M2M_ERR_INVALID_ARG;
    418e:	200f      	movs	r0, #15
    4190:	4240      	negs	r0, r0
    4192:	e02a      	b.n	41ea <nm_bus_ioctl+0x126>
    4194:	200f      	movs	r0, #15
    4196:	4240      	negs	r0, r0
    4198:	e027      	b.n	41ea <nm_bus_ioctl+0x126>
    419a:	200f      	movs	r0, #15
    419c:	4240      	negs	r0, r0
#elif defined CONF_WINC_USE_SPI
		case NM_BUS_IOCTL_RW: {
			tstrNmSpiRw *pstrParam = (tstrNmSpiRw *)pvParameter;
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
		}
		break;
    419e:	e024      	b.n	41ea <nm_bus_ioctl+0x126>
#endif
		default:
			s8Ret = -1;
			M2M_ERR("invalide ioclt cmd\n");
    41a0:	2210      	movs	r2, #16
    41a2:	32ff      	adds	r2, #255	; 0xff
    41a4:	4917      	ldr	r1, [pc, #92]	; (4204 <nm_bus_ioctl+0x140>)
    41a6:	4818      	ldr	r0, [pc, #96]	; (4208 <nm_bus_ioctl+0x144>)
    41a8:	4b18      	ldr	r3, [pc, #96]	; (420c <nm_bus_ioctl+0x148>)
    41aa:	4798      	blx	r3
    41ac:	4818      	ldr	r0, [pc, #96]	; (4210 <nm_bus_ioctl+0x14c>)
    41ae:	4b19      	ldr	r3, [pc, #100]	; (4214 <nm_bus_ioctl+0x150>)
    41b0:	4798      	blx	r3
    41b2:	200d      	movs	r0, #13
    41b4:	4b18      	ldr	r3, [pc, #96]	; (4218 <nm_bus_ioctl+0x154>)
    41b6:	4798      	blx	r3
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
		}
		break;
#endif
		default:
			s8Ret = -1;
    41b8:	2001      	movs	r0, #1
    41ba:	4240      	negs	r0, r0
			M2M_ERR("invalide ioclt cmd\n");
			break;
	}

	return s8Ret;
    41bc:	e015      	b.n	41ea <nm_bus_ioctl+0x126>
		pu8Miso = &u8Dummy;
		u8SkipMiso = 1;
	}


	spi_select_slave(&master, &slave_inst, true);
    41be:	2201      	movs	r2, #1
    41c0:	490e      	ldr	r1, [pc, #56]	; (41fc <nm_bus_ioctl+0x138>)
    41c2:	480d      	ldr	r0, [pc, #52]	; (41f8 <nm_bus_ioctl+0x134>)
    41c4:	4b0e      	ldr	r3, [pc, #56]	; (4200 <nm_bus_ioctl+0x13c>)
    41c6:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    41c8:	4b0b      	ldr	r3, [pc, #44]	; (41f8 <nm_bus_ioctl+0x134>)
    41ca:	469a      	mov	sl, r3

	while (u16Sz) {
		txd_data = *pu8Mosi;
		while (!spi_is_ready_to_write(&master))
    41cc:	2001      	movs	r0, #1
			;
		while(spi_write(&master, txd_data) != STATUS_OK)
			;

		/* Read SPI master data register. */
		while (!spi_is_ready_to_read(&master))
    41ce:	2204      	movs	r2, #4
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    41d0:	4699      	mov	r9, r3

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    41d2:	2304      	movs	r3, #4
    41d4:	4698      	mov	r8, r3
			;
		*pu8Miso = rxd_data;

		u16Sz--;
		if (!u8SkipMiso)
			pu8Miso++;
    41d6:	4263      	negs	r3, r4
    41d8:	4163      	adcs	r3, r4
    41da:	469b      	mov	fp, r3
    41dc:	9500      	str	r5, [sp, #0]
    41de:	e796      	b.n	410e <nm_bus_ioctl+0x4a>
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
	uint16_t txd_data = 0;
	uint16_t rxd_data = 0;

	
	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) || (u16Sz == 0)) {
    41e0:	2d00      	cmp	r5, #0
    41e2:	d0da      	beq.n	419a <nm_bus_ioctl+0xd6>
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
    41e4:	2300      	movs	r3, #0
    41e6:	9301      	str	r3, [sp, #4]
    41e8:	e78a      	b.n	4100 <nm_bus_ioctl+0x3c>
			M2M_ERR("invalide ioclt cmd\n");
			break;
	}

	return s8Ret;
}
    41ea:	b005      	add	sp, #20
    41ec:	bc3c      	pop	{r2, r3, r4, r5}
    41ee:	4690      	mov	r8, r2
    41f0:	4699      	mov	r9, r3
    41f2:	46a2      	mov	sl, r4
    41f4:	46ab      	mov	fp, r5
    41f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    41f8:	20002234 	.word	0x20002234
    41fc:	20002230 	.word	0x20002230
    4200:	0000751d 	.word	0x0000751d
    4204:	0001416c 	.word	0x0001416c
    4208:	00014144 	.word	0x00014144
    420c:	0001198d 	.word	0x0001198d
    4210:	00014158 	.word	0x00014158
    4214:	00011aad 	.word	0x00011aad
    4218:	000119c1 	.word	0x000119c1

0000421c <nm_bus_deinit>:
/*
*	@fn		nm_bus_deinit
*	@brief	De-initialize the bus wrapper
*/
sint8 nm_bus_deinit(void)
{
    421c:	b570      	push	{r4, r5, r6, lr}
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    421e:	4d0b      	ldr	r5, [pc, #44]	; (424c <nm_bus_deinit+0x30>)
    4220:	682c      	ldr	r4, [r5, #0]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
    4222:	0020      	movs	r0, r4
    4224:	4b0a      	ldr	r3, [pc, #40]	; (4250 <nm_bus_deinit+0x34>)
    4226:	4798      	blx	r3
 * \param[in] vector  Interrupt vector to disable
 */
static inline void system_interrupt_disable(
		const enum system_interrupt_vector vector)
{
	NVIC->ICER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    4228:	231f      	movs	r3, #31
    422a:	4018      	ands	r0, r3
    422c:	3b1e      	subs	r3, #30
    422e:	4083      	lsls	r3, r0
    4230:	2280      	movs	r2, #128	; 0x80
    4232:	4908      	ldr	r1, [pc, #32]	; (4254 <nm_bus_deinit+0x38>)
    4234:	508b      	str	r3, [r1, r2]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4236:	682a      	ldr	r2, [r5, #0]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
    4238:	69d3      	ldr	r3, [r2, #28]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
    423a:	2b00      	cmp	r3, #0
    423c:	d1fc      	bne.n	4238 <nm_bus_deinit+0x1c>
		/* Wait until the synchronization is complete */
	}

	/* Disable SPI */
	spi_module->CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
    423e:	6823      	ldr	r3, [r4, #0]
    4240:	2202      	movs	r2, #2
    4242:	4393      	bics	r3, r2
    4244:	6023      	str	r3, [r4, #0]
#endif /* CONF_WINC_USE_I2C */
#ifdef CONF_WINC_USE_SPI
	spi_disable(&master);
#endif /* CONF_WINC_USE_SPI */
	return result;
}
    4246:	2000      	movs	r0, #0
    4248:	bd70      	pop	{r4, r5, r6, pc}
    424a:	46c0      	nop			; (mov r8, r8)
    424c:	20002234 	.word	0x20002234
    4250:	0000cc25 	.word	0x0000cc25
    4254:	e000e100 	.word	0xe000e100

00004258 <m2m_memcpy>:
 */
#include "common/include/nm_common.h"

void m2m_memcpy(uint8* pDst,uint8* pSrc,uint32 sz)
{
	if(sz == 0) return;
    4258:	2a00      	cmp	r2, #0
    425a:	d006      	beq.n	426a <m2m_memcpy+0x12>
    425c:	1882      	adds	r2, r0, r2
	do
	{
		*pDst = *pSrc;
    425e:	780b      	ldrb	r3, [r1, #0]
    4260:	7003      	strb	r3, [r0, #0]
		pDst++;
    4262:	3001      	adds	r0, #1
		pSrc++;
    4264:	3101      	adds	r1, #1
	}while(--sz);
    4266:	4290      	cmp	r0, r2
    4268:	d1f9      	bne.n	425e <m2m_memcpy+0x6>
}
    426a:	4770      	bx	lr

0000426c <m2m_memset>:
	return cs;
}

void m2m_memset(uint8* pBuf,uint8 val,uint32 sz)
{
	if(sz == 0) return;
    426c:	2a00      	cmp	r2, #0
    426e:	d004      	beq.n	427a <m2m_memset+0xe>
    4270:	1882      	adds	r2, r0, r2
	do
	{
		*pBuf = val;
    4272:	7001      	strb	r1, [r0, #0]
		pBuf++;
    4274:	3001      	adds	r0, #1
	}while(--sz);
    4276:	4290      	cmp	r0, r2
    4278:	d1fb      	bne.n	4272 <m2m_memset+0x6>
}
    427a:	4770      	bx	lr

0000427c <m2m_strlen>:

uint16 m2m_strlen(uint8 * pcStr)
{
    427c:	0003      	movs	r3, r0
	uint16	u16StrLen = 0;
	while(*pcStr)
    427e:	7802      	ldrb	r2, [r0, #0]
    4280:	2a00      	cmp	r2, #0
    4282:	d007      	beq.n	4294 <m2m_strlen+0x18>
    4284:	2000      	movs	r0, #0
	{
		u16StrLen ++;
    4286:	3001      	adds	r0, #1
    4288:	b280      	uxth	r0, r0
		pcStr++;
    428a:	3301      	adds	r3, #1
}

uint16 m2m_strlen(uint8 * pcStr)
{
	uint16	u16StrLen = 0;
	while(*pcStr)
    428c:	781a      	ldrb	r2, [r3, #0]
    428e:	2a00      	cmp	r2, #0
    4290:	d1f9      	bne.n	4286 <m2m_strlen+0xa>
    4292:	e000      	b.n	4296 <m2m_strlen+0x1a>
	}while(--sz);
}

uint16 m2m_strlen(uint8 * pcStr)
{
	uint16	u16StrLen = 0;
    4294:	2000      	movs	r0, #0
	{
		u16StrLen ++;
		pcStr++;
	}
	return u16StrLen;
}
    4296:	4770      	bx	lr

00004298 <isr>:

volatile tstrHifContext gstrHifCxt;

static void isr(void)
{
	gstrHifCxt.u8Interrupt++;
    4298:	4a02      	ldr	r2, [pc, #8]	; (42a4 <isr+0xc>)
    429a:	78d3      	ldrb	r3, [r2, #3]
    429c:	3301      	adds	r3, #1
    429e:	b2db      	uxtb	r3, r3
    42a0:	70d3      	strb	r3, [r2, #3]
#ifdef NM_LEVEL_INTERRUPT
	nm_bsp_interrupt_ctrl(0);
#endif
}
    42a2:	4770      	bx	lr
    42a4:	20002270 	.word	0x20002270

000042a8 <m2m_hif_cb>:
*/
static void m2m_hif_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
{


}
    42a8:	4770      	bx	lr
    42aa:	46c0      	nop			; (mov r8, r8)

000042ac <hif_set_rx_done>:
#ifdef NM_LEVEL_INTERRUPT
	nm_bsp_interrupt_ctrl(0);
#endif
}
static sint8 hif_set_rx_done(void)
{
    42ac:	b500      	push	{lr}
    42ae:	b083      	sub	sp, #12
	uint32 reg;
	sint8 ret = M2M_SUCCESS;

	gstrHifCxt.u8HifRXDone = 0;
    42b0:	2200      	movs	r2, #0
    42b2:	4b0a      	ldr	r3, [pc, #40]	; (42dc <hif_set_rx_done+0x30>)
    42b4:	709a      	strb	r2, [r3, #2]
#ifdef NM_EDGE_INTERRUPT
	nm_bsp_interrupt_ctrl(1);
    42b6:	2001      	movs	r0, #1
    42b8:	4b09      	ldr	r3, [pc, #36]	; (42e0 <hif_set_rx_done+0x34>)
    42ba:	4798      	blx	r3
#endif
	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
    42bc:	a901      	add	r1, sp, #4
    42be:	4809      	ldr	r0, [pc, #36]	; (42e4 <hif_set_rx_done+0x38>)
    42c0:	4b09      	ldr	r3, [pc, #36]	; (42e8 <hif_set_rx_done+0x3c>)
    42c2:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
    42c4:	2800      	cmp	r0, #0
    42c6:	d106      	bne.n	42d6 <hif_set_rx_done+0x2a>
	/* Set RX Done */
	reg |= NBIT1;
    42c8:	2102      	movs	r1, #2
    42ca:	9b01      	ldr	r3, [sp, #4]
    42cc:	4319      	orrs	r1, r3
    42ce:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
    42d0:	4804      	ldr	r0, [pc, #16]	; (42e4 <hif_set_rx_done+0x38>)
    42d2:	4b06      	ldr	r3, [pc, #24]	; (42ec <hif_set_rx_done+0x40>)
    42d4:	4798      	blx	r3
	nm_bsp_interrupt_ctrl(1);
#endif
ERR1:
	return ret;

}
    42d6:	b003      	add	sp, #12
    42d8:	bd00      	pop	{pc}
    42da:	46c0      	nop			; (mov r8, r8)
    42dc:	20002270 	.word	0x20002270
    42e0:	00003f9d 	.word	0x00003f9d
    42e4:	00001070 	.word	0x00001070
    42e8:	00005965 	.word	0x00005965
    42ec:	00005971 	.word	0x00005971

000042f0 <hif_chip_wake>:
*	@brief	To Wakeup the chip.
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_wake(void)
{
    42f0:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
	if(gstrHifCxt.u8HifRXDone)
    42f2:	4b0c      	ldr	r3, [pc, #48]	; (4324 <hif_chip_wake+0x34>)
    42f4:	789b      	ldrb	r3, [r3, #2]
	{
		/*chip already wake for the rx not done no need to send wake request*/
		return ret;
    42f6:	2000      	movs	r0, #0
*/

sint8 hif_chip_wake(void)
{
	sint8 ret = M2M_SUCCESS;
	if(gstrHifCxt.u8HifRXDone)
    42f8:	2b00      	cmp	r3, #0
    42fa:	d111      	bne.n	4320 <hif_chip_wake+0x30>
	{
		/*chip already wake for the rx not done no need to send wake request*/
		return ret;
	}
	if(gstrHifCxt.u8ChipSleep == 0)
    42fc:	4b09      	ldr	r3, [pc, #36]	; (4324 <hif_chip_wake+0x34>)
    42fe:	785b      	ldrb	r3, [r3, #1]
    4300:	2b00      	cmp	r3, #0
    4302:	d107      	bne.n	4314 <hif_chip_wake+0x24>
	{
		if(gstrHifCxt.u8ChipMode != M2M_NO_PS)
    4304:	4b07      	ldr	r3, [pc, #28]	; (4324 <hif_chip_wake+0x34>)
    4306:	781b      	ldrb	r3, [r3, #0]
    4308:	2b00      	cmp	r3, #0
    430a:	d003      	beq.n	4314 <hif_chip_wake+0x24>
		{
			ret = chip_wake();
    430c:	4b06      	ldr	r3, [pc, #24]	; (4328 <hif_chip_wake+0x38>)
    430e:	4798      	blx	r3
			if(ret != M2M_SUCCESS)goto ERR1;
    4310:	2800      	cmp	r0, #0
    4312:	d105      	bne.n	4320 <hif_chip_wake+0x30>
		}
		else
		{
		}
	}
	gstrHifCxt.u8ChipSleep++;
    4314:	4a03      	ldr	r2, [pc, #12]	; (4324 <hif_chip_wake+0x34>)
    4316:	7853      	ldrb	r3, [r2, #1]
    4318:	3301      	adds	r3, #1
    431a:	b2db      	uxtb	r3, r3
    431c:	7053      	strb	r3, [r2, #1]
    431e:	2000      	movs	r0, #0
ERR1:
	return ret;
}
    4320:	bd10      	pop	{r4, pc}
    4322:	46c0      	nop			; (mov r8, r8)
    4324:	20002270 	.word	0x20002270
    4328:	000055e1 	.word	0x000055e1

0000432c <hif_chip_sleep_sc>:
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep_sc(void)
{
	if(gstrHifCxt.u8ChipSleep >= 1)
    432c:	4b05      	ldr	r3, [pc, #20]	; (4344 <hif_chip_sleep_sc+0x18>)
    432e:	785b      	ldrb	r3, [r3, #1]
    4330:	2b00      	cmp	r3, #0
    4332:	d004      	beq.n	433e <hif_chip_sleep_sc+0x12>
	{
		gstrHifCxt.u8ChipSleep--;
    4334:	4a03      	ldr	r2, [pc, #12]	; (4344 <hif_chip_sleep_sc+0x18>)
    4336:	7853      	ldrb	r3, [r2, #1]
    4338:	3b01      	subs	r3, #1
    433a:	b2db      	uxtb	r3, r3
    433c:	7053      	strb	r3, [r2, #1]
	}
	return M2M_SUCCESS;
}
    433e:	2000      	movs	r0, #0
    4340:	4770      	bx	lr
    4342:	46c0      	nop			; (mov r8, r8)
    4344:	20002270 	.word	0x20002270

00004348 <hif_chip_sleep>:
*	@brief	To make the chip sleep.
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep(void)
{
    4348:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;

	if(gstrHifCxt.u8ChipSleep >= 1)
    434a:	4b0a      	ldr	r3, [pc, #40]	; (4374 <hif_chip_sleep+0x2c>)
    434c:	785b      	ldrb	r3, [r3, #1]
    434e:	2b00      	cmp	r3, #0
    4350:	d004      	beq.n	435c <hif_chip_sleep+0x14>
	{
		gstrHifCxt.u8ChipSleep--;
    4352:	4a08      	ldr	r2, [pc, #32]	; (4374 <hif_chip_sleep+0x2c>)
    4354:	7853      	ldrb	r3, [r2, #1]
    4356:	3b01      	subs	r3, #1
    4358:	b2db      	uxtb	r3, r3
    435a:	7053      	strb	r3, [r2, #1]
	}
	
	if(gstrHifCxt.u8ChipSleep == 0)
    435c:	4b05      	ldr	r3, [pc, #20]	; (4374 <hif_chip_sleep+0x2c>)
    435e:	785b      	ldrb	r3, [r3, #1]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep(void)
{
	sint8 ret = M2M_SUCCESS;
    4360:	2000      	movs	r0, #0
	if(gstrHifCxt.u8ChipSleep >= 1)
	{
		gstrHifCxt.u8ChipSleep--;
	}
	
	if(gstrHifCxt.u8ChipSleep == 0)
    4362:	2b00      	cmp	r3, #0
    4364:	d105      	bne.n	4372 <hif_chip_sleep+0x2a>
	{
		if(gstrHifCxt.u8ChipMode != M2M_NO_PS)
    4366:	4b03      	ldr	r3, [pc, #12]	; (4374 <hif_chip_sleep+0x2c>)
    4368:	781b      	ldrb	r3, [r3, #0]
    436a:	2b00      	cmp	r3, #0
    436c:	d001      	beq.n	4372 <hif_chip_sleep+0x2a>
		{
			ret = chip_sleep();
    436e:	4b02      	ldr	r3, [pc, #8]	; (4378 <hif_chip_sleep+0x30>)
    4370:	4798      	blx	r3
		{
		}
	}
ERR1:
	return ret;
}
    4372:	bd10      	pop	{r4, pc}
    4374:	20002270 	.word	0x20002270
    4378:	0000557d 	.word	0x0000557d

0000437c <hif_send>:
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSize,
			   uint8 *pu8DataBuf,uint16 u16DataSize, uint16 u16DataOffset)
{
    437c:	b5f0      	push	{r4, r5, r6, r7, lr}
    437e:	465f      	mov	r7, fp
    4380:	4656      	mov	r6, sl
    4382:	b4c0      	push	{r6, r7}
    4384:	b08b      	sub	sp, #44	; 0x2c
    4386:	4683      	mov	fp, r0
    4388:	000c      	movs	r4, r1
    438a:	9203      	str	r2, [sp, #12]
    438c:	9302      	str	r3, [sp, #8]
    438e:	ab12      	add	r3, sp, #72	; 0x48
    4390:	cb80      	ldmia	r3!, {r7}
    4392:	881e      	ldrh	r6, [r3, #0]
    4394:	ab14      	add	r3, sp, #80	; 0x50
    4396:	881d      	ldrh	r5, [r3, #0]
	sint8		ret = M2M_ERR_SEND;
	volatile tstrHifHdr	strHif;

	strHif.u8Opcode		= u8Opcode&(~NBIT7);
    4398:	227f      	movs	r2, #127	; 0x7f
    439a:	400a      	ands	r2, r1
    439c:	ab09      	add	r3, sp, #36	; 0x24
    439e:	705a      	strb	r2, [r3, #1]
	strHif.u8Gid		= u8Gid;
    43a0:	7018      	strb	r0, [r3, #0]
	strHif.u16Length	= M2M_HIF_HDR_OFFSET;
    43a2:	2208      	movs	r2, #8
    43a4:	805a      	strh	r2, [r3, #2]
	if(pu8DataBuf != NULL)
    43a6:	2f00      	cmp	r7, #0
    43a8:	d005      	beq.n	43b6 <hif_send+0x3a>
	{
		strHif.u16Length += u16DataOffset + u16DataSize;
    43aa:	885a      	ldrh	r2, [r3, #2]
    43ac:	1992      	adds	r2, r2, r6
    43ae:	18aa      	adds	r2, r5, r2
    43b0:	b292      	uxth	r2, r2
    43b2:	805a      	strh	r2, [r3, #2]
    43b4:	e006      	b.n	43c4 <hif_send+0x48>
	}
	else
	{
		strHif.u16Length += u16CtrlBufSize;
    43b6:	ab09      	add	r3, sp, #36	; 0x24
    43b8:	885a      	ldrh	r2, [r3, #2]
    43ba:	9902      	ldr	r1, [sp, #8]
    43bc:	468c      	mov	ip, r1
    43be:	4462      	add	r2, ip
    43c0:	b292      	uxth	r2, r2
    43c2:	805a      	strh	r2, [r3, #2]
	}
	ret = hif_chip_wake();
    43c4:	4b66      	ldr	r3, [pc, #408]	; (4560 <hif_send+0x1e4>)
    43c6:	4798      	blx	r3
    43c8:	9001      	str	r0, [sp, #4]
	if(ret == M2M_SUCCESS)
    43ca:	2800      	cmp	r0, #0
    43cc:	d000      	beq.n	43d0 <hif_send+0x54>
    43ce:	e0ad      	b.n	452c <hif_send+0x1b0>
	{
		volatile uint32 reg, dma_addr = 0;
    43d0:	9007      	str	r0, [sp, #28]
		volatile uint16 cnt = 0;
    43d2:	aa04      	add	r2, sp, #16
    43d4:	80d0      	strh	r0, [r2, #6]
//#define OPTIMIZE_BUS 
/*please define in firmware also*/
#ifndef OPTIMIZE_BUS
		reg = 0UL;
    43d6:	9006      	str	r0, [sp, #24]
		reg |= (uint32)u8Gid;
    43d8:	9b06      	ldr	r3, [sp, #24]
    43da:	465a      	mov	r2, fp
    43dc:	431a      	orrs	r2, r3
    43de:	9206      	str	r2, [sp, #24]
		reg |= ((uint32)u8Opcode<<8);
    43e0:	9a06      	ldr	r2, [sp, #24]
    43e2:	0223      	lsls	r3, r4, #8
    43e4:	4313      	orrs	r3, r2
    43e6:	9306      	str	r3, [sp, #24]
		reg |= ((uint32)strHif.u16Length<<16);
    43e8:	ab09      	add	r3, sp, #36	; 0x24
    43ea:	885b      	ldrh	r3, [r3, #2]
    43ec:	9a06      	ldr	r2, [sp, #24]
    43ee:	041b      	lsls	r3, r3, #16
    43f0:	4313      	orrs	r3, r2
    43f2:	9306      	str	r3, [sp, #24]
		ret = nm_write_reg(NMI_STATE_REG,reg);
    43f4:	9906      	ldr	r1, [sp, #24]
    43f6:	485b      	ldr	r0, [pc, #364]	; (4564 <hif_send+0x1e8>)
    43f8:	4b5b      	ldr	r3, [pc, #364]	; (4568 <hif_send+0x1ec>)
    43fa:	4798      	blx	r3
    43fc:	1e04      	subs	r4, r0, #0
		if(M2M_SUCCESS != ret) goto ERR1;
    43fe:	d000      	beq.n	4402 <hif_send+0x86>
    4400:	e0a5      	b.n	454e <hif_send+0x1d2>

		reg = 0UL;
    4402:	2300      	movs	r3, #0
    4404:	9306      	str	r3, [sp, #24]
		reg |= NBIT1;
    4406:	9a06      	ldr	r2, [sp, #24]
    4408:	3302      	adds	r3, #2
    440a:	4313      	orrs	r3, r2
    440c:	9306      	str	r3, [sp, #24]
		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
    440e:	9906      	ldr	r1, [sp, #24]
    4410:	4856      	ldr	r0, [pc, #344]	; (456c <hif_send+0x1f0>)
    4412:	4b55      	ldr	r3, [pc, #340]	; (4568 <hif_send+0x1ec>)
    4414:	4798      	blx	r3
    4416:	1e04      	subs	r4, r0, #0
		if(M2M_SUCCESS != ret) goto ERR1;
    4418:	d000      	beq.n	441c <hif_send+0xa0>
    441a:	e098      	b.n	454e <hif_send+0x1d2>
		reg |= (u8Gid == M2M_REQ_GROUP_IP) ? (NBIT3):(0); /*IP = 1 or non IP*/
		reg |= ((uint32)strHif.u16Length << 4); /*length of pkt max = 4096*/
		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
		if(M2M_SUCCESS != ret) goto ERR1;
#endif
		dma_addr = 0;
    441c:	2200      	movs	r2, #0
    441e:	9207      	str	r2, [sp, #28]
		
		for(cnt = 0; cnt < 1000; cnt ++)
    4420:	ab04      	add	r3, sp, #16
    4422:	80da      	strh	r2, [r3, #6]
    4424:	3306      	adds	r3, #6
    4426:	881b      	ldrh	r3, [r3, #0]
    4428:	b29b      	uxth	r3, r3
    442a:	4a51      	ldr	r2, [pc, #324]	; (4570 <hif_send+0x1f4>)
    442c:	4293      	cmp	r3, r2
    442e:	d838      	bhi.n	44a2 <hif_send+0x126>
		{
			ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_2,(uint32 *)&reg);
    4430:	4c50      	ldr	r4, [pc, #320]	; (4574 <hif_send+0x1f8>)
			 */
			if(cnt >= 500) {
				if(cnt < 501) {
					M2M_INFO("Slowing down...\n");
				}
				nm_bsp_sleep(1);
    4432:	4b51      	ldr	r3, [pc, #324]	; (4578 <hif_send+0x1fc>)
    4434:	469a      	mov	sl, r3
#endif
		dma_addr = 0;
		
		for(cnt = 0; cnt < 1000; cnt ++)
		{
			ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_2,(uint32 *)&reg);
    4436:	a906      	add	r1, sp, #24
    4438:	484c      	ldr	r0, [pc, #304]	; (456c <hif_send+0x1f0>)
    443a:	47a0      	blx	r4
			if(ret != M2M_SUCCESS) break;
    443c:	2800      	cmp	r0, #0
    443e:	d130      	bne.n	44a2 <hif_send+0x126>
			/*
			 * If it takes too long to get a response, the slow down to 
			 * avoid back-to-back register read operations.
			 */
			if(cnt >= 500) {
    4440:	ab04      	add	r3, sp, #16
    4442:	3306      	adds	r3, #6
    4444:	881b      	ldrh	r3, [r3, #0]
    4446:	b29b      	uxth	r3, r3
    4448:	22f4      	movs	r2, #244	; 0xf4
    444a:	32ff      	adds	r2, #255	; 0xff
    444c:	4293      	cmp	r3, r2
    444e:	d911      	bls.n	4474 <hif_send+0xf8>
				if(cnt < 501) {
    4450:	ab04      	add	r3, sp, #16
    4452:	3306      	adds	r3, #6
    4454:	881b      	ldrh	r3, [r3, #0]
    4456:	b29b      	uxth	r3, r3
    4458:	3201      	adds	r2, #1
    445a:	4293      	cmp	r3, r2
    445c:	d808      	bhi.n	4470 <hif_send+0xf4>
					M2M_INFO("Slowing down...\n");
    445e:	4847      	ldr	r0, [pc, #284]	; (457c <hif_send+0x200>)
    4460:	4b47      	ldr	r3, [pc, #284]	; (4580 <hif_send+0x204>)
    4462:	4798      	blx	r3
    4464:	4847      	ldr	r0, [pc, #284]	; (4584 <hif_send+0x208>)
    4466:	4b48      	ldr	r3, [pc, #288]	; (4588 <hif_send+0x20c>)
    4468:	4798      	blx	r3
    446a:	200d      	movs	r0, #13
    446c:	4b47      	ldr	r3, [pc, #284]	; (458c <hif_send+0x210>)
    446e:	4798      	blx	r3
				}
				nm_bsp_sleep(1);
    4470:	2001      	movs	r0, #1
    4472:	47d0      	blx	sl
			}
			if (!(reg & NBIT1))
    4474:	9b06      	ldr	r3, [sp, #24]
    4476:	079b      	lsls	r3, r3, #30
    4478:	d408      	bmi.n	448c <hif_send+0x110>
			{
				ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_4,(uint32 *)&dma_addr);
    447a:	a907      	add	r1, sp, #28
    447c:	4844      	ldr	r0, [pc, #272]	; (4590 <hif_send+0x214>)
    447e:	4b3d      	ldr	r3, [pc, #244]	; (4574 <hif_send+0x1f8>)
    4480:	4798      	blx	r3
    4482:	1e04      	subs	r4, r0, #0
				if(ret != M2M_SUCCESS) {
    4484:	d00d      	beq.n	44a2 <hif_send+0x126>
					/*in case of read error clear the DMA address and return error*/
					dma_addr = 0;
    4486:	2300      	movs	r3, #0
    4488:	9307      	str	r3, [sp, #28]
					goto ERR1;
    448a:	e060      	b.n	454e <hif_send+0x1d2>
		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
		if(M2M_SUCCESS != ret) goto ERR1;
#endif
		dma_addr = 0;
		
		for(cnt = 0; cnt < 1000; cnt ++)
    448c:	ab04      	add	r3, sp, #16
    448e:	88da      	ldrh	r2, [r3, #6]
    4490:	3201      	adds	r2, #1
    4492:	b292      	uxth	r2, r2
    4494:	80da      	strh	r2, [r3, #6]
    4496:	3306      	adds	r3, #6
    4498:	881b      	ldrh	r3, [r3, #0]
    449a:	b29b      	uxth	r3, r3
    449c:	4a34      	ldr	r2, [pc, #208]	; (4570 <hif_send+0x1f4>)
    449e:	4293      	cmp	r3, r2
    44a0:	d9c9      	bls.n	4436 <hif_send+0xba>
				/*in case of success break */
				break;
			}
		}

		if (dma_addr != 0)
    44a2:	9b07      	ldr	r3, [sp, #28]
    44a4:	2b00      	cmp	r3, #0
    44a6:	d03c      	beq.n	4522 <hif_send+0x1a6>
		{
			volatile uint32	u32CurrAddr;
			u32CurrAddr = dma_addr;
    44a8:	9b07      	ldr	r3, [sp, #28]
    44aa:	9308      	str	r3, [sp, #32]
			strHif.u16Length=NM_BSP_B_L_16(strHif.u16Length);
    44ac:	a909      	add	r1, sp, #36	; 0x24
    44ae:	884b      	ldrh	r3, [r1, #2]
    44b0:	b29b      	uxth	r3, r3
    44b2:	804b      	strh	r3, [r1, #2]
			ret = nm_write_block(u32CurrAddr, (uint8*)&strHif, M2M_HIF_HDR_OFFSET);
    44b4:	9808      	ldr	r0, [sp, #32]
    44b6:	2208      	movs	r2, #8
    44b8:	4b36      	ldr	r3, [pc, #216]	; (4594 <hif_send+0x218>)
    44ba:	4798      	blx	r3
    44bc:	1e04      	subs	r4, r0, #0
			if(M2M_SUCCESS != ret) goto ERR1;
    44be:	d146      	bne.n	454e <hif_send+0x1d2>
			u32CurrAddr += M2M_HIF_HDR_OFFSET;
    44c0:	9b08      	ldr	r3, [sp, #32]
    44c2:	3308      	adds	r3, #8
    44c4:	9308      	str	r3, [sp, #32]
			if(pu8CtrlBuf != NULL)
    44c6:	9b03      	ldr	r3, [sp, #12]
    44c8:	2b00      	cmp	r3, #0
    44ca:	d00b      	beq.n	44e4 <hif_send+0x168>
			{
				ret = nm_write_block(u32CurrAddr, pu8CtrlBuf, u16CtrlBufSize);
    44cc:	9808      	ldr	r0, [sp, #32]
    44ce:	9a02      	ldr	r2, [sp, #8]
    44d0:	0019      	movs	r1, r3
    44d2:	4b30      	ldr	r3, [pc, #192]	; (4594 <hif_send+0x218>)
    44d4:	4798      	blx	r3
    44d6:	1e04      	subs	r4, r0, #0
				if(M2M_SUCCESS != ret) goto ERR1;
    44d8:	d139      	bne.n	454e <hif_send+0x1d2>
				u32CurrAddr += u16CtrlBufSize;
    44da:	9b08      	ldr	r3, [sp, #32]
    44dc:	9a02      	ldr	r2, [sp, #8]
    44de:	4694      	mov	ip, r2
    44e0:	4463      	add	r3, ip
    44e2:	9308      	str	r3, [sp, #32]
			}
			if(pu8DataBuf != NULL)
    44e4:	2f00      	cmp	r7, #0
    44e6:	d00e      	beq.n	4506 <hif_send+0x18a>
			{
				u32CurrAddr += (u16DataOffset - u16CtrlBufSize);
    44e8:	9b08      	ldr	r3, [sp, #32]
    44ea:	9a02      	ldr	r2, [sp, #8]
    44ec:	1aad      	subs	r5, r5, r2
    44ee:	18ed      	adds	r5, r5, r3
    44f0:	9508      	str	r5, [sp, #32]
				ret = nm_write_block(u32CurrAddr, pu8DataBuf, u16DataSize);
    44f2:	9808      	ldr	r0, [sp, #32]
    44f4:	0032      	movs	r2, r6
    44f6:	0039      	movs	r1, r7
    44f8:	4b26      	ldr	r3, [pc, #152]	; (4594 <hif_send+0x218>)
    44fa:	4798      	blx	r3
    44fc:	1e04      	subs	r4, r0, #0
				if(M2M_SUCCESS != ret) goto ERR1;
    44fe:	d126      	bne.n	454e <hif_send+0x1d2>
				u32CurrAddr += u16DataSize;
    4500:	9b08      	ldr	r3, [sp, #32]
    4502:	18f3      	adds	r3, r6, r3
    4504:	9308      	str	r3, [sp, #32]
			}

			reg = dma_addr << 2;
    4506:	9b07      	ldr	r3, [sp, #28]
    4508:	009b      	lsls	r3, r3, #2
    450a:	9306      	str	r3, [sp, #24]
			reg |= NBIT1;
    450c:	9a06      	ldr	r2, [sp, #24]
    450e:	2302      	movs	r3, #2
    4510:	4313      	orrs	r3, r2
    4512:	9306      	str	r3, [sp, #24]
			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_3, reg);
    4514:	9906      	ldr	r1, [sp, #24]
    4516:	4820      	ldr	r0, [pc, #128]	; (4598 <hif_send+0x21c>)
    4518:	4b13      	ldr	r3, [pc, #76]	; (4568 <hif_send+0x1ec>)
    451a:	4798      	blx	r3
    451c:	1e04      	subs	r4, r0, #0
			if(M2M_SUCCESS != ret) goto ERR1;
    451e:	d116      	bne.n	454e <hif_send+0x1d2>
    4520:	e012      	b.n	4548 <hif_send+0x1cc>
		}
		else
		{
			ret = hif_chip_sleep();
    4522:	4b1e      	ldr	r3, [pc, #120]	; (459c <hif_send+0x220>)
    4524:	4798      	blx	r3
			M2M_DBG("Failed to alloc rx size %d\r",ret);
			ret = M2M_ERR_MEM_ALLOC;
    4526:	2003      	movs	r0, #3
    4528:	4240      	negs	r0, r0
			goto ERR2;
    452a:	e013      	b.n	4554 <hif_send+0x1d8>
		}

	}
	else
	{
		M2M_ERR("(HIF)Fail to wakup the chip\n");
    452c:	22cb      	movs	r2, #203	; 0xcb
    452e:	0052      	lsls	r2, r2, #1
    4530:	491b      	ldr	r1, [pc, #108]	; (45a0 <hif_send+0x224>)
    4532:	481c      	ldr	r0, [pc, #112]	; (45a4 <hif_send+0x228>)
    4534:	4b12      	ldr	r3, [pc, #72]	; (4580 <hif_send+0x204>)
    4536:	4798      	blx	r3
    4538:	481b      	ldr	r0, [pc, #108]	; (45a8 <hif_send+0x22c>)
    453a:	4b13      	ldr	r3, [pc, #76]	; (4588 <hif_send+0x20c>)
    453c:	4798      	blx	r3
    453e:	200d      	movs	r0, #13
    4540:	4b12      	ldr	r3, [pc, #72]	; (458c <hif_send+0x210>)
    4542:	4798      	blx	r3
	}
	else
	{
		strHif.u16Length += u16CtrlBufSize;
	}
	ret = hif_chip_wake();
    4544:	9801      	ldr	r0, [sp, #4]

	}
	else
	{
		M2M_ERR("(HIF)Fail to wakup the chip\n");
		goto ERR2;
    4546:	e005      	b.n	4554 <hif_send+0x1d8>
	}
	/*actual sleep ret = M2M_SUCCESS*/
 	ret = hif_chip_sleep();
    4548:	4b14      	ldr	r3, [pc, #80]	; (459c <hif_send+0x220>)
    454a:	4798      	blx	r3
	return ret;
    454c:	e002      	b.n	4554 <hif_send+0x1d8>
ERR1:
	/*reset the count but no actual sleep as it already bus error*/
	hif_chip_sleep_sc();
    454e:	4b17      	ldr	r3, [pc, #92]	; (45ac <hif_send+0x230>)
    4550:	4798      	blx	r3
    4552:	0020      	movs	r0, r4
ERR2:
	/*logical error*/
	return ret;
}
    4554:	b00b      	add	sp, #44	; 0x2c
    4556:	bc0c      	pop	{r2, r3}
    4558:	4692      	mov	sl, r2
    455a:	469b      	mov	fp, r3
    455c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    455e:	46c0      	nop			; (mov r8, r8)
    4560:	000042f1 	.word	0x000042f1
    4564:	0000108c 	.word	0x0000108c
    4568:	00005971 	.word	0x00005971
    456c:	00001078 	.word	0x00001078
    4570:	000003e7 	.word	0x000003e7
    4574:	00005965 	.word	0x00005965
    4578:	00003e6d 	.word	0x00003e6d
    457c:	00013ca0 	.word	0x00013ca0
    4580:	0001198d 	.word	0x0001198d
    4584:	000141c8 	.word	0x000141c8
    4588:	00011aad 	.word	0x00011aad
    458c:	000119c1 	.word	0x000119c1
    4590:	00150400 	.word	0x00150400
    4594:	000059e5 	.word	0x000059e5
    4598:	0000106c 	.word	0x0000106c
    459c:	00004349 	.word	0x00004349
    45a0:	0001449c 	.word	0x0001449c
    45a4:	00014144 	.word	0x00014144
    45a8:	000141d8 	.word	0x000141d8
    45ac:	0000432d 	.word	0x0000432d

000045b0 <hif_handle_isr>:
*	@brief	Handle interrupt received from NMC1500 firmware.
*   @return     The function SHALL return 0 for success and a negative value otherwise.
*/

sint8 hif_handle_isr(void)
{
    45b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    45b2:	464f      	mov	r7, r9
    45b4:	4646      	mov	r6, r8
    45b6:	b4c0      	push	{r6, r7}
    45b8:	b087      	sub	sp, #28
	sint8 ret = M2M_SUCCESS;	
	while (gstrHifCxt.u8Interrupt) {
    45ba:	4bcd      	ldr	r3, [pc, #820]	; (48f0 <hif_handle_isr+0x340>)
    45bc:	4698      	mov	r8, r3
		/*must be at that place because of the race of interrupt increment and that decrement*/
		/*when the interrupt enabled*/
		gstrHifCxt.u8Interrupt--;
    45be:	4699      	mov	r9, r3
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg;
	volatile tstrHifHdr strHif;

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0, &reg);
    45c0:	4ecc      	ldr	r6, [pc, #816]	; (48f4 <hif_handle_isr+0x344>)
*/

sint8 hif_handle_isr(void)
{
	sint8 ret = M2M_SUCCESS;	
	while (gstrHifCxt.u8Interrupt) {
    45c2:	e1d9      	b.n	4978 <hif_handle_isr+0x3c8>
		/*must be at that place because of the race of interrupt increment and that decrement*/
		/*when the interrupt enabled*/
		gstrHifCxt.u8Interrupt--;
    45c4:	464b      	mov	r3, r9
    45c6:	78db      	ldrb	r3, [r3, #3]
    45c8:	3b01      	subs	r3, #1
    45ca:	b2db      	uxtb	r3, r3
    45cc:	464a      	mov	r2, r9
    45ce:	70d3      	strb	r3, [r2, #3]
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg;
	volatile tstrHifHdr strHif;

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0, &reg);
    45d0:	a903      	add	r1, sp, #12
    45d2:	48c9      	ldr	r0, [pc, #804]	; (48f8 <hif_handle_isr+0x348>)
    45d4:	47b0      	blx	r6
    45d6:	1e04      	subs	r4, r0, #0
	if(M2M_SUCCESS == ret)
    45d8:	d000      	beq.n	45dc <hif_handle_isr+0x2c>
    45da:	e16f      	b.n	48bc <hif_handle_isr+0x30c>
	{
		if(reg & 0x1)	/* New interrupt has been received */
    45dc:	9b03      	ldr	r3, [sp, #12]
    45de:	07db      	lsls	r3, r3, #31
    45e0:	d400      	bmi.n	45e4 <hif_handle_isr+0x34>
    45e2:	e15c      	b.n	489e <hif_handle_isr+0x2ee>
		{
			uint16 size;

			nm_bsp_interrupt_ctrl(0);
    45e4:	2000      	movs	r0, #0
    45e6:	4bc5      	ldr	r3, [pc, #788]	; (48fc <hif_handle_isr+0x34c>)
    45e8:	4798      	blx	r3
			/*Clearing RX interrupt*/
			reg &= ~NBIT0;
    45ea:	2301      	movs	r3, #1
    45ec:	9903      	ldr	r1, [sp, #12]
    45ee:	4399      	bics	r1, r3
    45f0:	9103      	str	r1, [sp, #12]
			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
    45f2:	48c1      	ldr	r0, [pc, #772]	; (48f8 <hif_handle_isr+0x348>)
    45f4:	4bc2      	ldr	r3, [pc, #776]	; (4900 <hif_handle_isr+0x350>)
    45f6:	4798      	blx	r3
    45f8:	1e04      	subs	r4, r0, #0
			if(ret != M2M_SUCCESS)goto ERR1;
    45fa:	d000      	beq.n	45fe <hif_handle_isr+0x4e>
    45fc:	e16c      	b.n	48d8 <hif_handle_isr+0x328>
			gstrHifCxt.u8HifRXDone = 1;
    45fe:	2201      	movs	r2, #1
    4600:	4bbb      	ldr	r3, [pc, #748]	; (48f0 <hif_handle_isr+0x340>)
    4602:	709a      	strb	r2, [r3, #2]
			size = (uint16)((reg >> 2) & 0xfff);
    4604:	9b03      	ldr	r3, [sp, #12]
    4606:	0499      	lsls	r1, r3, #18
    4608:	0d0f      	lsrs	r7, r1, #20
			if (size > 0) {
    460a:	d100      	bne.n	460e <hif_handle_isr+0x5e>
    460c:	e138      	b.n	4880 <hif_handle_isr+0x2d0>
				uint32 address = 0;
    460e:	2300      	movs	r3, #0
    4610:	9305      	str	r3, [sp, #20]
				/**
				start bus transfer
				**/
				ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_1, &address);
    4612:	a905      	add	r1, sp, #20
    4614:	48bb      	ldr	r0, [pc, #748]	; (4904 <hif_handle_isr+0x354>)
    4616:	4bb7      	ldr	r3, [pc, #732]	; (48f4 <hif_handle_isr+0x344>)
    4618:	4798      	blx	r3
    461a:	1e04      	subs	r4, r0, #0
				if(M2M_SUCCESS != ret)
    461c:	d00f      	beq.n	463e <hif_handle_isr+0x8e>
				{
					M2M_ERR("(hif) WIFI_HOST_RCV_CTRL_1 bus fail\n");
    461e:	22c8      	movs	r2, #200	; 0xc8
    4620:	32ff      	adds	r2, #255	; 0xff
    4622:	49b9      	ldr	r1, [pc, #740]	; (4908 <hif_handle_isr+0x358>)
    4624:	48b9      	ldr	r0, [pc, #740]	; (490c <hif_handle_isr+0x35c>)
    4626:	4bba      	ldr	r3, [pc, #744]	; (4910 <hif_handle_isr+0x360>)
    4628:	4798      	blx	r3
    462a:	48ba      	ldr	r0, [pc, #744]	; (4914 <hif_handle_isr+0x364>)
    462c:	4bba      	ldr	r3, [pc, #744]	; (4918 <hif_handle_isr+0x368>)
    462e:	4798      	blx	r3
    4630:	200d      	movs	r0, #13
    4632:	4bba      	ldr	r3, [pc, #744]	; (491c <hif_handle_isr+0x36c>)
    4634:	4798      	blx	r3
					nm_bsp_interrupt_ctrl(1);
    4636:	2001      	movs	r0, #1
    4638:	4bb0      	ldr	r3, [pc, #704]	; (48fc <hif_handle_isr+0x34c>)
    463a:	4798      	blx	r3
    463c:	e14a      	b.n	48d4 <hif_handle_isr+0x324>
					goto ERR1;
				}
				gstrHifCxt.u32RxAddr = address;
    463e:	4bac      	ldr	r3, [pc, #688]	; (48f0 <hif_handle_isr+0x340>)
    4640:	9a05      	ldr	r2, [sp, #20]
    4642:	605a      	str	r2, [r3, #4]
				gstrHifCxt.u32RxSize = size;
    4644:	609f      	str	r7, [r3, #8]
				ret = nm_read_block(address, (uint8*)&strHif, sizeof(tstrHifHdr));
    4646:	ad04      	add	r5, sp, #16
    4648:	2204      	movs	r2, #4
    464a:	0029      	movs	r1, r5
    464c:	9805      	ldr	r0, [sp, #20]
    464e:	4bb4      	ldr	r3, [pc, #720]	; (4920 <hif_handle_isr+0x370>)
    4650:	4798      	blx	r3
    4652:	0004      	movs	r4, r0
				strHif.u16Length = NM_BSP_B_L_16(strHif.u16Length);
    4654:	886b      	ldrh	r3, [r5, #2]
    4656:	b29b      	uxth	r3, r3
    4658:	806b      	strh	r3, [r5, #2]
				if(M2M_SUCCESS != ret)
    465a:	2800      	cmp	r0, #0
    465c:	d00f      	beq.n	467e <hif_handle_isr+0xce>
				{
					M2M_ERR("(hif) address bus fail\n");
    465e:	22d2      	movs	r2, #210	; 0xd2
    4660:	32ff      	adds	r2, #255	; 0xff
    4662:	49a9      	ldr	r1, [pc, #676]	; (4908 <hif_handle_isr+0x358>)
    4664:	48a9      	ldr	r0, [pc, #676]	; (490c <hif_handle_isr+0x35c>)
    4666:	4baa      	ldr	r3, [pc, #680]	; (4910 <hif_handle_isr+0x360>)
    4668:	4798      	blx	r3
    466a:	48ae      	ldr	r0, [pc, #696]	; (4924 <hif_handle_isr+0x374>)
    466c:	4baa      	ldr	r3, [pc, #680]	; (4918 <hif_handle_isr+0x368>)
    466e:	4798      	blx	r3
    4670:	200d      	movs	r0, #13
    4672:	4baa      	ldr	r3, [pc, #680]	; (491c <hif_handle_isr+0x36c>)
    4674:	4798      	blx	r3
					nm_bsp_interrupt_ctrl(1);
    4676:	2001      	movs	r0, #1
    4678:	4ba0      	ldr	r3, [pc, #640]	; (48fc <hif_handle_isr+0x34c>)
    467a:	4798      	blx	r3
    467c:	e12a      	b.n	48d4 <hif_handle_isr+0x324>
					goto ERR1;
				}
				if(strHif.u16Length != size)
    467e:	ab04      	add	r3, sp, #16
    4680:	885b      	ldrh	r3, [r3, #2]
    4682:	b29b      	uxth	r3, r3
    4684:	429f      	cmp	r7, r3
    4686:	d01d      	beq.n	46c4 <hif_handle_isr+0x114>
				{
					if((size - strHif.u16Length) > 4)
    4688:	ab04      	add	r3, sp, #16
    468a:	885b      	ldrh	r3, [r3, #2]
    468c:	1afb      	subs	r3, r7, r3
    468e:	2b04      	cmp	r3, #4
    4690:	dd18      	ble.n	46c4 <hif_handle_isr+0x114>
					{
						M2M_ERR("(hif) Corrupted packet Size = %u <L = %u, G = %u, OP = %02X>\n",
    4692:	22ed      	movs	r2, #237	; 0xed
    4694:	0052      	lsls	r2, r2, #1
    4696:	499c      	ldr	r1, [pc, #624]	; (4908 <hif_handle_isr+0x358>)
    4698:	489c      	ldr	r0, [pc, #624]	; (490c <hif_handle_isr+0x35c>)
    469a:	4c9d      	ldr	r4, [pc, #628]	; (4910 <hif_handle_isr+0x360>)
    469c:	47a0      	blx	r4
    469e:	a904      	add	r1, sp, #16
    46a0:	884a      	ldrh	r2, [r1, #2]
    46a2:	b292      	uxth	r2, r2
    46a4:	780b      	ldrb	r3, [r1, #0]
    46a6:	b2db      	uxtb	r3, r3
    46a8:	7849      	ldrb	r1, [r1, #1]
    46aa:	9100      	str	r1, [sp, #0]
    46ac:	0039      	movs	r1, r7
    46ae:	489e      	ldr	r0, [pc, #632]	; (4928 <hif_handle_isr+0x378>)
    46b0:	47a0      	blx	r4
    46b2:	200d      	movs	r0, #13
    46b4:	4b99      	ldr	r3, [pc, #612]	; (491c <hif_handle_isr+0x36c>)
    46b6:	4798      	blx	r3
							size, strHif.u16Length, strHif.u8Gid, strHif.u8Opcode);
						nm_bsp_interrupt_ctrl(1);
    46b8:	2001      	movs	r0, #1
    46ba:	4b90      	ldr	r3, [pc, #576]	; (48fc <hif_handle_isr+0x34c>)
    46bc:	4798      	blx	r3
						ret = M2M_ERR_BUS_FAIL;
    46be:	2406      	movs	r4, #6
    46c0:	4264      	negs	r4, r4
    46c2:	e107      	b.n	48d4 <hif_handle_isr+0x324>
						goto ERR1;
					}
				}

				if(M2M_REQ_GROUP_WIFI == strHif.u8Gid)
    46c4:	ab04      	add	r3, sp, #16
    46c6:	781b      	ldrb	r3, [r3, #0]
    46c8:	2b01      	cmp	r3, #1
    46ca:	d11c      	bne.n	4706 <hif_handle_isr+0x156>
				{
					if(gstrHifCxt.pfWifiCb)
    46cc:	4b88      	ldr	r3, [pc, #544]	; (48f0 <hif_handle_isr+0x340>)
    46ce:	68db      	ldr	r3, [r3, #12]
    46d0:	2b00      	cmp	r3, #0
    46d2:	d00b      	beq.n	46ec <hif_handle_isr+0x13c>
						gstrHifCxt.pfWifiCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    46d4:	4b86      	ldr	r3, [pc, #536]	; (48f0 <hif_handle_isr+0x340>)
    46d6:	68db      	ldr	r3, [r3, #12]
    46d8:	aa04      	add	r2, sp, #16
    46da:	7850      	ldrb	r0, [r2, #1]
    46dc:	b2c0      	uxtb	r0, r0
    46de:	8851      	ldrh	r1, [r2, #2]
    46e0:	9a05      	ldr	r2, [sp, #20]
    46e2:	3208      	adds	r2, #8
    46e4:	3908      	subs	r1, #8
    46e6:	b289      	uxth	r1, r1
    46e8:	4798      	blx	r3
    46ea:	e0b0      	b.n	484e <hif_handle_isr+0x29e>
					else
						M2M_ERR("WIFI callback is not registered\n");
    46ec:	22f3      	movs	r2, #243	; 0xf3
    46ee:	0052      	lsls	r2, r2, #1
    46f0:	4985      	ldr	r1, [pc, #532]	; (4908 <hif_handle_isr+0x358>)
    46f2:	4886      	ldr	r0, [pc, #536]	; (490c <hif_handle_isr+0x35c>)
    46f4:	4b86      	ldr	r3, [pc, #536]	; (4910 <hif_handle_isr+0x360>)
    46f6:	4798      	blx	r3
    46f8:	488c      	ldr	r0, [pc, #560]	; (492c <hif_handle_isr+0x37c>)
    46fa:	4b87      	ldr	r3, [pc, #540]	; (4918 <hif_handle_isr+0x368>)
    46fc:	4798      	blx	r3
    46fe:	200d      	movs	r0, #13
    4700:	4b86      	ldr	r3, [pc, #536]	; (491c <hif_handle_isr+0x36c>)
    4702:	4798      	blx	r3
    4704:	e0a3      	b.n	484e <hif_handle_isr+0x29e>

				}
				else if(M2M_REQ_GROUP_IP == strHif.u8Gid)
    4706:	ab04      	add	r3, sp, #16
    4708:	781b      	ldrb	r3, [r3, #0]
    470a:	2b02      	cmp	r3, #2
    470c:	d11c      	bne.n	4748 <hif_handle_isr+0x198>
				{
					if(gstrHifCxt.pfIpCb)
    470e:	4b78      	ldr	r3, [pc, #480]	; (48f0 <hif_handle_isr+0x340>)
    4710:	691b      	ldr	r3, [r3, #16]
    4712:	2b00      	cmp	r3, #0
    4714:	d00b      	beq.n	472e <hif_handle_isr+0x17e>
						gstrHifCxt.pfIpCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    4716:	4b76      	ldr	r3, [pc, #472]	; (48f0 <hif_handle_isr+0x340>)
    4718:	691b      	ldr	r3, [r3, #16]
    471a:	aa04      	add	r2, sp, #16
    471c:	7850      	ldrb	r0, [r2, #1]
    471e:	b2c0      	uxtb	r0, r0
    4720:	8851      	ldrh	r1, [r2, #2]
    4722:	9a05      	ldr	r2, [sp, #20]
    4724:	3208      	adds	r2, #8
    4726:	3908      	subs	r1, #8
    4728:	b289      	uxth	r1, r1
    472a:	4798      	blx	r3
    472c:	e08f      	b.n	484e <hif_handle_isr+0x29e>
					else
						M2M_ERR("Scoket callback is not registered\n");
    472e:	22f7      	movs	r2, #247	; 0xf7
    4730:	0052      	lsls	r2, r2, #1
    4732:	4975      	ldr	r1, [pc, #468]	; (4908 <hif_handle_isr+0x358>)
    4734:	4875      	ldr	r0, [pc, #468]	; (490c <hif_handle_isr+0x35c>)
    4736:	4b76      	ldr	r3, [pc, #472]	; (4910 <hif_handle_isr+0x360>)
    4738:	4798      	blx	r3
    473a:	487d      	ldr	r0, [pc, #500]	; (4930 <hif_handle_isr+0x380>)
    473c:	4b76      	ldr	r3, [pc, #472]	; (4918 <hif_handle_isr+0x368>)
    473e:	4798      	blx	r3
    4740:	200d      	movs	r0, #13
    4742:	4b76      	ldr	r3, [pc, #472]	; (491c <hif_handle_isr+0x36c>)
    4744:	4798      	blx	r3
    4746:	e082      	b.n	484e <hif_handle_isr+0x29e>

				}
				else if(M2M_REQ_GROUP_OTA == strHif.u8Gid)
    4748:	ab04      	add	r3, sp, #16
    474a:	781b      	ldrb	r3, [r3, #0]
    474c:	2b04      	cmp	r3, #4
    474e:	d11c      	bne.n	478a <hif_handle_isr+0x1da>
				{
					if(gstrHifCxt.pfOtaCb)
    4750:	4b67      	ldr	r3, [pc, #412]	; (48f0 <hif_handle_isr+0x340>)
    4752:	695b      	ldr	r3, [r3, #20]
    4754:	2b00      	cmp	r3, #0
    4756:	d00b      	beq.n	4770 <hif_handle_isr+0x1c0>
						gstrHifCxt.pfOtaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    4758:	4b65      	ldr	r3, [pc, #404]	; (48f0 <hif_handle_isr+0x340>)
    475a:	695b      	ldr	r3, [r3, #20]
    475c:	aa04      	add	r2, sp, #16
    475e:	7850      	ldrb	r0, [r2, #1]
    4760:	b2c0      	uxtb	r0, r0
    4762:	8851      	ldrh	r1, [r2, #2]
    4764:	9a05      	ldr	r2, [sp, #20]
    4766:	3208      	adds	r2, #8
    4768:	3908      	subs	r1, #8
    476a:	b289      	uxth	r1, r1
    476c:	4798      	blx	r3
    476e:	e06e      	b.n	484e <hif_handle_isr+0x29e>
					else
						M2M_ERR("Ota callback is not registered\n");
    4770:	22fb      	movs	r2, #251	; 0xfb
    4772:	0052      	lsls	r2, r2, #1
    4774:	4964      	ldr	r1, [pc, #400]	; (4908 <hif_handle_isr+0x358>)
    4776:	4865      	ldr	r0, [pc, #404]	; (490c <hif_handle_isr+0x35c>)
    4778:	4b65      	ldr	r3, [pc, #404]	; (4910 <hif_handle_isr+0x360>)
    477a:	4798      	blx	r3
    477c:	486d      	ldr	r0, [pc, #436]	; (4934 <hif_handle_isr+0x384>)
    477e:	4b66      	ldr	r3, [pc, #408]	; (4918 <hif_handle_isr+0x368>)
    4780:	4798      	blx	r3
    4782:	200d      	movs	r0, #13
    4784:	4b65      	ldr	r3, [pc, #404]	; (491c <hif_handle_isr+0x36c>)
    4786:	4798      	blx	r3
    4788:	e061      	b.n	484e <hif_handle_isr+0x29e>

				}
				else if(M2M_REQ_GROUP_CRYPTO == strHif.u8Gid)
    478a:	ab04      	add	r3, sp, #16
    478c:	781b      	ldrb	r3, [r3, #0]
    478e:	2b06      	cmp	r3, #6
    4790:	d11b      	bne.n	47ca <hif_handle_isr+0x21a>
				{
					if(gstrHifCxt.pfCryptoCb)
    4792:	4b57      	ldr	r3, [pc, #348]	; (48f0 <hif_handle_isr+0x340>)
    4794:	6a1b      	ldr	r3, [r3, #32]
    4796:	2b00      	cmp	r3, #0
    4798:	d00b      	beq.n	47b2 <hif_handle_isr+0x202>
						gstrHifCxt.pfCryptoCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    479a:	4b55      	ldr	r3, [pc, #340]	; (48f0 <hif_handle_isr+0x340>)
    479c:	6a1b      	ldr	r3, [r3, #32]
    479e:	aa04      	add	r2, sp, #16
    47a0:	7850      	ldrb	r0, [r2, #1]
    47a2:	b2c0      	uxtb	r0, r0
    47a4:	8851      	ldrh	r1, [r2, #2]
    47a6:	9a05      	ldr	r2, [sp, #20]
    47a8:	3208      	adds	r2, #8
    47aa:	3908      	subs	r1, #8
    47ac:	b289      	uxth	r1, r1
    47ae:	4798      	blx	r3
    47b0:	e04d      	b.n	484e <hif_handle_isr+0x29e>

					else
						M2M_ERR("Crypto callback is not registered\n");
    47b2:	4a61      	ldr	r2, [pc, #388]	; (4938 <hif_handle_isr+0x388>)
    47b4:	4954      	ldr	r1, [pc, #336]	; (4908 <hif_handle_isr+0x358>)
    47b6:	4855      	ldr	r0, [pc, #340]	; (490c <hif_handle_isr+0x35c>)
    47b8:	4b55      	ldr	r3, [pc, #340]	; (4910 <hif_handle_isr+0x360>)
    47ba:	4798      	blx	r3
    47bc:	485f      	ldr	r0, [pc, #380]	; (493c <hif_handle_isr+0x38c>)
    47be:	4b56      	ldr	r3, [pc, #344]	; (4918 <hif_handle_isr+0x368>)
    47c0:	4798      	blx	r3
    47c2:	200d      	movs	r0, #13
    47c4:	4b55      	ldr	r3, [pc, #340]	; (491c <hif_handle_isr+0x36c>)
    47c6:	4798      	blx	r3
    47c8:	e041      	b.n	484e <hif_handle_isr+0x29e>
				}
				else if(M2M_REQ_GROUP_SIGMA == strHif.u8Gid)
    47ca:	ab04      	add	r3, sp, #16
    47cc:	781b      	ldrb	r3, [r3, #0]
    47ce:	2b07      	cmp	r3, #7
    47d0:	d11b      	bne.n	480a <hif_handle_isr+0x25a>
				{
					if(gstrHifCxt.pfSigmaCb)
    47d2:	4b47      	ldr	r3, [pc, #284]	; (48f0 <hif_handle_isr+0x340>)
    47d4:	699b      	ldr	r3, [r3, #24]
    47d6:	2b00      	cmp	r3, #0
    47d8:	d00b      	beq.n	47f2 <hif_handle_isr+0x242>
						gstrHifCxt.pfSigmaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    47da:	4b45      	ldr	r3, [pc, #276]	; (48f0 <hif_handle_isr+0x340>)
    47dc:	699b      	ldr	r3, [r3, #24]
    47de:	aa04      	add	r2, sp, #16
    47e0:	7850      	ldrb	r0, [r2, #1]
    47e2:	b2c0      	uxtb	r0, r0
    47e4:	8851      	ldrh	r1, [r2, #2]
    47e6:	9a05      	ldr	r2, [sp, #20]
    47e8:	3208      	adds	r2, #8
    47ea:	3908      	subs	r1, #8
    47ec:	b289      	uxth	r1, r1
    47ee:	4798      	blx	r3
    47f0:	e02d      	b.n	484e <hif_handle_isr+0x29e>
					else
						M2M_ERR("Sigma callback is not registered\n");
    47f2:	4a53      	ldr	r2, [pc, #332]	; (4940 <hif_handle_isr+0x390>)
    47f4:	4944      	ldr	r1, [pc, #272]	; (4908 <hif_handle_isr+0x358>)
    47f6:	4845      	ldr	r0, [pc, #276]	; (490c <hif_handle_isr+0x35c>)
    47f8:	4b45      	ldr	r3, [pc, #276]	; (4910 <hif_handle_isr+0x360>)
    47fa:	4798      	blx	r3
    47fc:	4851      	ldr	r0, [pc, #324]	; (4944 <hif_handle_isr+0x394>)
    47fe:	4b46      	ldr	r3, [pc, #280]	; (4918 <hif_handle_isr+0x368>)
    4800:	4798      	blx	r3
    4802:	200d      	movs	r0, #13
    4804:	4b45      	ldr	r3, [pc, #276]	; (491c <hif_handle_isr+0x36c>)
    4806:	4798      	blx	r3
    4808:	e021      	b.n	484e <hif_handle_isr+0x29e>
				}
				else if(M2M_REQ_GROUP_SSL == strHif.u8Gid)
    480a:	ab04      	add	r3, sp, #16
    480c:	781b      	ldrb	r3, [r3, #0]
    480e:	2b05      	cmp	r3, #5
    4810:	d10f      	bne.n	4832 <hif_handle_isr+0x282>
				{
				    if(gstrHifCxt.pfSslCb)
    4812:	4b37      	ldr	r3, [pc, #220]	; (48f0 <hif_handle_isr+0x340>)
    4814:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    4816:	2b00      	cmp	r3, #0
    4818:	d019      	beq.n	484e <hif_handle_isr+0x29e>
						gstrHifCxt.pfSslCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    481a:	4b35      	ldr	r3, [pc, #212]	; (48f0 <hif_handle_isr+0x340>)
    481c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    481e:	aa04      	add	r2, sp, #16
    4820:	7850      	ldrb	r0, [r2, #1]
    4822:	b2c0      	uxtb	r0, r0
    4824:	8851      	ldrh	r1, [r2, #2]
    4826:	9a05      	ldr	r2, [sp, #20]
    4828:	3208      	adds	r2, #8
    482a:	3908      	subs	r1, #8
    482c:	b289      	uxth	r1, r1
    482e:	4798      	blx	r3
    4830:	e00d      	b.n	484e <hif_handle_isr+0x29e>
				}
				else
				{
					M2M_ERR("(hif) invalid group ID\n");
    4832:	4a45      	ldr	r2, [pc, #276]	; (4948 <hif_handle_isr+0x398>)
    4834:	4934      	ldr	r1, [pc, #208]	; (4908 <hif_handle_isr+0x358>)
    4836:	4835      	ldr	r0, [pc, #212]	; (490c <hif_handle_isr+0x35c>)
    4838:	4b35      	ldr	r3, [pc, #212]	; (4910 <hif_handle_isr+0x360>)
    483a:	4798      	blx	r3
    483c:	4843      	ldr	r0, [pc, #268]	; (494c <hif_handle_isr+0x39c>)
    483e:	4b36      	ldr	r3, [pc, #216]	; (4918 <hif_handle_isr+0x368>)
    4840:	4798      	blx	r3
    4842:	200d      	movs	r0, #13
    4844:	4b35      	ldr	r3, [pc, #212]	; (491c <hif_handle_isr+0x36c>)
    4846:	4798      	blx	r3
					ret = M2M_ERR_BUS_FAIL;
    4848:	2406      	movs	r4, #6
    484a:	4264      	negs	r4, r4
    484c:	e042      	b.n	48d4 <hif_handle_isr+0x324>
					goto ERR1;
				}
				if(gstrHifCxt.u8HifRXDone)
    484e:	4b28      	ldr	r3, [pc, #160]	; (48f0 <hif_handle_isr+0x340>)
    4850:	789b      	ldrb	r3, [r3, #2]
    4852:	2b00      	cmp	r3, #0
    4854:	d03e      	beq.n	48d4 <hif_handle_isr+0x324>
				{
					M2M_ERR("(hif) host app didn't set RX Done <%u><%X>\n", strHif.u8Gid, strHif.u8Opcode);
    4856:	4a3e      	ldr	r2, [pc, #248]	; (4950 <hif_handle_isr+0x3a0>)
    4858:	492b      	ldr	r1, [pc, #172]	; (4908 <hif_handle_isr+0x358>)
    485a:	482c      	ldr	r0, [pc, #176]	; (490c <hif_handle_isr+0x35c>)
    485c:	4d2c      	ldr	r5, [pc, #176]	; (4910 <hif_handle_isr+0x360>)
    485e:	47a8      	blx	r5
    4860:	ab04      	add	r3, sp, #16
    4862:	7819      	ldrb	r1, [r3, #0]
    4864:	b2c9      	uxtb	r1, r1
    4866:	785a      	ldrb	r2, [r3, #1]
    4868:	b2d2      	uxtb	r2, r2
    486a:	483a      	ldr	r0, [pc, #232]	; (4954 <hif_handle_isr+0x3a4>)
    486c:	47a8      	blx	r5
    486e:	200d      	movs	r0, #13
    4870:	4b2a      	ldr	r3, [pc, #168]	; (491c <hif_handle_isr+0x36c>)
    4872:	4798      	blx	r3
					ret = hif_set_rx_done();
    4874:	4b38      	ldr	r3, [pc, #224]	; (4958 <hif_handle_isr+0x3a8>)
    4876:	4798      	blx	r3
					if(ret != M2M_SUCCESS) goto ERR1;
    4878:	2800      	cmp	r0, #0
    487a:	d02b      	beq.n	48d4 <hif_handle_isr+0x324>
					goto ERR1;
				}
				if(gstrHifCxt.u8HifRXDone)
				{
					M2M_ERR("(hif) host app didn't set RX Done <%u><%X>\n", strHif.u8Gid, strHif.u8Opcode);
					ret = hif_set_rx_done();
    487c:	0004      	movs	r4, r0
    487e:	e029      	b.n	48d4 <hif_handle_isr+0x324>
					if(ret != M2M_SUCCESS) goto ERR1;
				}
			}
			else
			{
				M2M_ERR("(hif) Wrong Size\n");
    4880:	2287      	movs	r2, #135	; 0x87
    4882:	0092      	lsls	r2, r2, #2
    4884:	4920      	ldr	r1, [pc, #128]	; (4908 <hif_handle_isr+0x358>)
    4886:	4821      	ldr	r0, [pc, #132]	; (490c <hif_handle_isr+0x35c>)
    4888:	4b21      	ldr	r3, [pc, #132]	; (4910 <hif_handle_isr+0x360>)
    488a:	4798      	blx	r3
    488c:	4833      	ldr	r0, [pc, #204]	; (495c <hif_handle_isr+0x3ac>)
    488e:	4b22      	ldr	r3, [pc, #136]	; (4918 <hif_handle_isr+0x368>)
    4890:	4798      	blx	r3
    4892:	200d      	movs	r0, #13
    4894:	4b21      	ldr	r3, [pc, #132]	; (491c <hif_handle_isr+0x36c>)
    4896:	4798      	blx	r3
				ret = M2M_ERR_RCV;
    4898:	2402      	movs	r4, #2
    489a:	4264      	negs	r4, r4
    489c:	e01c      	b.n	48d8 <hif_handle_isr+0x328>
			}
		}
		else
		{
#ifndef WIN32
			M2M_ERR("(hif) False interrupt %lx",reg);
    489e:	2289      	movs	r2, #137	; 0x89
    48a0:	0092      	lsls	r2, r2, #2
    48a2:	4919      	ldr	r1, [pc, #100]	; (4908 <hif_handle_isr+0x358>)
    48a4:	4819      	ldr	r0, [pc, #100]	; (490c <hif_handle_isr+0x35c>)
    48a6:	4c1a      	ldr	r4, [pc, #104]	; (4910 <hif_handle_isr+0x360>)
    48a8:	47a0      	blx	r4
    48aa:	9903      	ldr	r1, [sp, #12]
    48ac:	482c      	ldr	r0, [pc, #176]	; (4960 <hif_handle_isr+0x3b0>)
    48ae:	47a0      	blx	r4
    48b0:	200d      	movs	r0, #13
    48b2:	4b1a      	ldr	r3, [pc, #104]	; (491c <hif_handle_isr+0x36c>)
    48b4:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    48b6:	240c      	movs	r4, #12
    48b8:	4264      	negs	r4, r4
    48ba:	e00d      	b.n	48d8 <hif_handle_isr+0x328>
#endif
		}
	}
	else
	{
		M2M_ERR("(hif) Fail to Read interrupt reg\n");
    48bc:	4a29      	ldr	r2, [pc, #164]	; (4964 <hif_handle_isr+0x3b4>)
    48be:	4912      	ldr	r1, [pc, #72]	; (4908 <hif_handle_isr+0x358>)
    48c0:	4812      	ldr	r0, [pc, #72]	; (490c <hif_handle_isr+0x35c>)
    48c2:	4b13      	ldr	r3, [pc, #76]	; (4910 <hif_handle_isr+0x360>)
    48c4:	4798      	blx	r3
    48c6:	4828      	ldr	r0, [pc, #160]	; (4968 <hif_handle_isr+0x3b8>)
    48c8:	4b13      	ldr	r3, [pc, #76]	; (4918 <hif_handle_isr+0x368>)
    48ca:	4798      	blx	r3
    48cc:	200d      	movs	r0, #13
    48ce:	4b13      	ldr	r3, [pc, #76]	; (491c <hif_handle_isr+0x36c>)
    48d0:	4798      	blx	r3
    48d2:	e001      	b.n	48d8 <hif_handle_isr+0x328>
		/*when the interrupt enabled*/
		gstrHifCxt.u8Interrupt--;
		while(1)
		{
			ret = hif_isr();
			if(ret == M2M_SUCCESS) {
    48d4:	2c00      	cmp	r4, #0
    48d6:	d04f      	beq.n	4978 <hif_handle_isr+0x3c8>
				/*we will try forever untill we get that interrupt*/
				/*Fail return errors here due to bus errors (reading expected values)*/
				break;
			} else {
				M2M_ERR("(HIF) Fail to handle interrupt %d try Again..\n",ret);
    48d8:	4a24      	ldr	r2, [pc, #144]	; (496c <hif_handle_isr+0x3bc>)
    48da:	4925      	ldr	r1, [pc, #148]	; (4970 <hif_handle_isr+0x3c0>)
    48dc:	480b      	ldr	r0, [pc, #44]	; (490c <hif_handle_isr+0x35c>)
    48de:	4d0c      	ldr	r5, [pc, #48]	; (4910 <hif_handle_isr+0x360>)
    48e0:	47a8      	blx	r5
    48e2:	0021      	movs	r1, r4
    48e4:	4823      	ldr	r0, [pc, #140]	; (4974 <hif_handle_isr+0x3c4>)
    48e6:	47a8      	blx	r5
    48e8:	200d      	movs	r0, #13
    48ea:	4b0c      	ldr	r3, [pc, #48]	; (491c <hif_handle_isr+0x36c>)
    48ec:	4798      	blx	r3
			}
		}
    48ee:	e66f      	b.n	45d0 <hif_handle_isr+0x20>
    48f0:	20002270 	.word	0x20002270
    48f4:	00005965 	.word	0x00005965
    48f8:	00001070 	.word	0x00001070
    48fc:	00003f9d 	.word	0x00003f9d
    4900:	00005971 	.word	0x00005971
    4904:	00001084 	.word	0x00001084
    4908:	000144a8 	.word	0x000144a8
    490c:	00014144 	.word	0x00014144
    4910:	0001198d 	.word	0x0001198d
    4914:	000141f4 	.word	0x000141f4
    4918:	00011aad 	.word	0x00011aad
    491c:	000119c1 	.word	0x000119c1
    4920:	0000597d 	.word	0x0000597d
    4924:	00014218 	.word	0x00014218
    4928:	00014230 	.word	0x00014230
    492c:	00014270 	.word	0x00014270
    4930:	00014290 	.word	0x00014290
    4934:	000142b4 	.word	0x000142b4
    4938:	000001ff 	.word	0x000001ff
    493c:	000142d4 	.word	0x000142d4
    4940:	00000206 	.word	0x00000206
    4944:	000142f8 	.word	0x000142f8
    4948:	0000020f 	.word	0x0000020f
    494c:	0001431c 	.word	0x0001431c
    4950:	00000215 	.word	0x00000215
    4954:	00014334 	.word	0x00014334
    4958:	000042ad 	.word	0x000042ad
    495c:	00014360 	.word	0x00014360
    4960:	00014374 	.word	0x00014374
    4964:	0000022d 	.word	0x0000022d
    4968:	00014390 	.word	0x00014390
    496c:	0000024a 	.word	0x0000024a
    4970:	0001419c 	.word	0x0001419c
    4974:	000143b4 	.word	0x000143b4
*/

sint8 hif_handle_isr(void)
{
	sint8 ret = M2M_SUCCESS;	
	while (gstrHifCxt.u8Interrupt) {
    4978:	4643      	mov	r3, r8
    497a:	78db      	ldrb	r3, [r3, #3]
    497c:	2b00      	cmp	r3, #0
    497e:	d000      	beq.n	4982 <hif_handle_isr+0x3d2>
    4980:	e620      	b.n	45c4 <hif_handle_isr+0x14>
			}
		}
	}

	return ret;
}
    4982:	2000      	movs	r0, #0
    4984:	b007      	add	sp, #28
    4986:	bc0c      	pop	{r2, r3}
    4988:	4690      	mov	r8, r2
    498a:	4699      	mov	r9, r3
    498c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    498e:	46c0      	nop			; (mov r8, r8)

00004990 <hif_receive>:
*	@param [in]	isDone
*				If you don't need any more packets send True otherwise send false
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/
sint8 hif_receive(uint32 u32Addr, uint8 *pu8Buf, uint16 u16Sz, uint8 isDone)
{
    4990:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4992:	0014      	movs	r4, r2
    4994:	001d      	movs	r5, r3
	sint8 ret = M2M_SUCCESS;
	if((u32Addr == 0)||(pu8Buf == NULL) || (u16Sz == 0))
    4996:	2800      	cmp	r0, #0
    4998:	d003      	beq.n	49a2 <hif_receive+0x12>
    499a:	2900      	cmp	r1, #0
    499c:	d001      	beq.n	49a2 <hif_receive+0x12>
    499e:	2a00      	cmp	r2, #0
    49a0:	d112      	bne.n	49c8 <hif_receive+0x38>
	{
		if(isDone)
    49a2:	2d00      	cmp	r5, #0
    49a4:	d002      	beq.n	49ac <hif_receive+0x1c>
		{			
			/* set RX done */
			ret = hif_set_rx_done();
    49a6:	4b27      	ldr	r3, [pc, #156]	; (4a44 <hif_receive+0xb4>)
    49a8:	4798      	blx	r3
    49aa:	e049      	b.n	4a40 <hif_receive+0xb0>
		}
		else
		{
			ret = M2M_ERR_FAIL;
			M2M_ERR(" hif_receive: Invalid argument\n");
    49ac:	4a26      	ldr	r2, [pc, #152]	; (4a48 <hif_receive+0xb8>)
    49ae:	4927      	ldr	r1, [pc, #156]	; (4a4c <hif_receive+0xbc>)
    49b0:	4827      	ldr	r0, [pc, #156]	; (4a50 <hif_receive+0xc0>)
    49b2:	4b28      	ldr	r3, [pc, #160]	; (4a54 <hif_receive+0xc4>)
    49b4:	4798      	blx	r3
    49b6:	4828      	ldr	r0, [pc, #160]	; (4a58 <hif_receive+0xc8>)
    49b8:	4b28      	ldr	r3, [pc, #160]	; (4a5c <hif_receive+0xcc>)
    49ba:	4798      	blx	r3
    49bc:	200d      	movs	r0, #13
    49be:	4b28      	ldr	r3, [pc, #160]	; (4a60 <hif_receive+0xd0>)
    49c0:	4798      	blx	r3
			/* set RX done */
			ret = hif_set_rx_done();
		}
		else
		{
			ret = M2M_ERR_FAIL;
    49c2:	200c      	movs	r0, #12
    49c4:	4240      	negs	r0, r0
    49c6:	e03b      	b.n	4a40 <hif_receive+0xb0>
			M2M_ERR(" hif_receive: Invalid argument\n");
		}
		goto ERR1;
	}

	if(u16Sz > gstrHifCxt.u32RxSize)
    49c8:	4b26      	ldr	r3, [pc, #152]	; (4a64 <hif_receive+0xd4>)
    49ca:	689b      	ldr	r3, [r3, #8]
    49cc:	429a      	cmp	r2, r3
    49ce:	d90f      	bls.n	49f0 <hif_receive+0x60>
	{
		ret = M2M_ERR_FAIL;
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%u><%lu>\n",u16Sz, gstrHifCxt.u32RxSize);
    49d0:	4a25      	ldr	r2, [pc, #148]	; (4a68 <hif_receive+0xd8>)
    49d2:	491e      	ldr	r1, [pc, #120]	; (4a4c <hif_receive+0xbc>)
    49d4:	481e      	ldr	r0, [pc, #120]	; (4a50 <hif_receive+0xc0>)
    49d6:	4d1f      	ldr	r5, [pc, #124]	; (4a54 <hif_receive+0xc4>)
    49d8:	47a8      	blx	r5
    49da:	4b22      	ldr	r3, [pc, #136]	; (4a64 <hif_receive+0xd4>)
    49dc:	689a      	ldr	r2, [r3, #8]
    49de:	0021      	movs	r1, r4
    49e0:	4822      	ldr	r0, [pc, #136]	; (4a6c <hif_receive+0xdc>)
    49e2:	47a8      	blx	r5
    49e4:	200d      	movs	r0, #13
    49e6:	4b1e      	ldr	r3, [pc, #120]	; (4a60 <hif_receive+0xd0>)
    49e8:	4798      	blx	r3
		goto ERR1;
	}

	if(u16Sz > gstrHifCxt.u32RxSize)
	{
		ret = M2M_ERR_FAIL;
    49ea:	200c      	movs	r0, #12
    49ec:	4240      	negs	r0, r0
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%u><%lu>\n",u16Sz, gstrHifCxt.u32RxSize);
		goto ERR1;
    49ee:	e027      	b.n	4a40 <hif_receive+0xb0>
	}
	if((u32Addr < gstrHifCxt.u32RxAddr)||((u32Addr + u16Sz)>(gstrHifCxt.u32RxAddr + gstrHifCxt.u32RxSize)))
    49f0:	4b1c      	ldr	r3, [pc, #112]	; (4a64 <hif_receive+0xd4>)
    49f2:	685b      	ldr	r3, [r3, #4]
    49f4:	4298      	cmp	r0, r3
    49f6:	d306      	bcc.n	4a06 <hif_receive+0x76>
    49f8:	1886      	adds	r6, r0, r2
    49fa:	4a1a      	ldr	r2, [pc, #104]	; (4a64 <hif_receive+0xd4>)
    49fc:	6857      	ldr	r7, [r2, #4]
    49fe:	6893      	ldr	r3, [r2, #8]
    4a00:	18fb      	adds	r3, r7, r3
    4a02:	429e      	cmp	r6, r3
    4a04:	d90d      	bls.n	4a22 <hif_receive+0x92>
	{
		ret = M2M_ERR_FAIL;
		M2M_ERR("APP Requested Address beyond the recived buffer address and length\n");
    4a06:	4a1a      	ldr	r2, [pc, #104]	; (4a70 <hif_receive+0xe0>)
    4a08:	4910      	ldr	r1, [pc, #64]	; (4a4c <hif_receive+0xbc>)
    4a0a:	4811      	ldr	r0, [pc, #68]	; (4a50 <hif_receive+0xc0>)
    4a0c:	4b11      	ldr	r3, [pc, #68]	; (4a54 <hif_receive+0xc4>)
    4a0e:	4798      	blx	r3
    4a10:	4818      	ldr	r0, [pc, #96]	; (4a74 <hif_receive+0xe4>)
    4a12:	4b12      	ldr	r3, [pc, #72]	; (4a5c <hif_receive+0xcc>)
    4a14:	4798      	blx	r3
    4a16:	200d      	movs	r0, #13
    4a18:	4b11      	ldr	r3, [pc, #68]	; (4a60 <hif_receive+0xd0>)
    4a1a:	4798      	blx	r3
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%u><%lu>\n",u16Sz, gstrHifCxt.u32RxSize);
		goto ERR1;
	}
	if((u32Addr < gstrHifCxt.u32RxAddr)||((u32Addr + u16Sz)>(gstrHifCxt.u32RxAddr + gstrHifCxt.u32RxSize)))
	{
		ret = M2M_ERR_FAIL;
    4a1c:	200c      	movs	r0, #12
    4a1e:	4240      	negs	r0, r0
		M2M_ERR("APP Requested Address beyond the recived buffer address and length\n");
		goto ERR1;
    4a20:	e00e      	b.n	4a40 <hif_receive+0xb0>
	}
	
	/* Receive the payload */
	ret = nm_read_block(u32Addr, pu8Buf, u16Sz);
    4a22:	0022      	movs	r2, r4
    4a24:	4b14      	ldr	r3, [pc, #80]	; (4a78 <hif_receive+0xe8>)
    4a26:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
    4a28:	2800      	cmp	r0, #0
    4a2a:	d109      	bne.n	4a40 <hif_receive+0xb0>

	/* check if this is the last packet */
	if((((gstrHifCxt.u32RxAddr + gstrHifCxt.u32RxSize) - (u32Addr + u16Sz)) <= 0) || isDone)
    4a2c:	4a0d      	ldr	r2, [pc, #52]	; (4a64 <hif_receive+0xd4>)
    4a2e:	6851      	ldr	r1, [r2, #4]
    4a30:	6893      	ldr	r3, [r2, #8]
    4a32:	18cb      	adds	r3, r1, r3
    4a34:	429e      	cmp	r6, r3
    4a36:	d001      	beq.n	4a3c <hif_receive+0xac>
    4a38:	2d00      	cmp	r5, #0
    4a3a:	d001      	beq.n	4a40 <hif_receive+0xb0>
	{
		/* set RX done */
		ret = hif_set_rx_done();
    4a3c:	4b01      	ldr	r3, [pc, #4]	; (4a44 <hif_receive+0xb4>)
    4a3e:	4798      	blx	r3
	}

ERR1:
	return ret;
}
    4a40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4a42:	46c0      	nop			; (mov r8, r8)
    4a44:	000042ad 	.word	0x000042ad
    4a48:	0000026b 	.word	0x0000026b
    4a4c:	000141ac 	.word	0x000141ac
    4a50:	00014144 	.word	0x00014144
    4a54:	0001198d 	.word	0x0001198d
    4a58:	000143e4 	.word	0x000143e4
    4a5c:	00011aad 	.word	0x00011aad
    4a60:	000119c1 	.word	0x000119c1
    4a64:	20002270 	.word	0x20002270
    4a68:	00000273 	.word	0x00000273
    4a6c:	00014404 	.word	0x00014404
    4a70:	00000279 	.word	0x00000279
    4a74:	0001444c 	.word	0x0001444c
    4a78:	0000597d 	.word	0x0000597d

00004a7c <hif_register_cb>:
*				function to be set
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
    4a7c:	b570      	push	{r4, r5, r6, lr}
    4a7e:	1e04      	subs	r4, r0, #0
	sint8 ret = M2M_SUCCESS;
	switch(u8Grp)
    4a80:	2c07      	cmp	r4, #7
    4a82:	d81f      	bhi.n	4ac4 <hif_register_cb+0x48>
    4a84:	0083      	lsls	r3, r0, #2
    4a86:	4a16      	ldr	r2, [pc, #88]	; (4ae0 <hif_register_cb+0x64>)
    4a88:	58d3      	ldr	r3, [r2, r3]
    4a8a:	469f      	mov	pc, r3
	{
		case M2M_REQ_GROUP_IP:
			gstrHifCxt.pfIpCb = fn;
    4a8c:	4b15      	ldr	r3, [pc, #84]	; (4ae4 <hif_register_cb+0x68>)
    4a8e:	6119      	str	r1, [r3, #16]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    4a90:	2000      	movs	r0, #0
	switch(u8Grp)
	{
		case M2M_REQ_GROUP_IP:
			gstrHifCxt.pfIpCb = fn;
			break;
    4a92:	e024      	b.n	4ade <hif_register_cb+0x62>
		case M2M_REQ_GROUP_WIFI:
			gstrHifCxt.pfWifiCb = fn;
    4a94:	4b13      	ldr	r3, [pc, #76]	; (4ae4 <hif_register_cb+0x68>)
    4a96:	60d9      	str	r1, [r3, #12]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    4a98:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_IP:
			gstrHifCxt.pfIpCb = fn;
			break;
		case M2M_REQ_GROUP_WIFI:
			gstrHifCxt.pfWifiCb = fn;
			break;
    4a9a:	e020      	b.n	4ade <hif_register_cb+0x62>
		case M2M_REQ_GROUP_OTA:
			gstrHifCxt.pfOtaCb = fn;
    4a9c:	4b11      	ldr	r3, [pc, #68]	; (4ae4 <hif_register_cb+0x68>)
    4a9e:	6159      	str	r1, [r3, #20]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    4aa0:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_WIFI:
			gstrHifCxt.pfWifiCb = fn;
			break;
		case M2M_REQ_GROUP_OTA:
			gstrHifCxt.pfOtaCb = fn;
			break;
    4aa2:	e01c      	b.n	4ade <hif_register_cb+0x62>
		case M2M_REQ_GROUP_HIF:
			gstrHifCxt.pfHifCb = fn;
    4aa4:	4b0f      	ldr	r3, [pc, #60]	; (4ae4 <hif_register_cb+0x68>)
    4aa6:	61d9      	str	r1, [r3, #28]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    4aa8:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_OTA:
			gstrHifCxt.pfOtaCb = fn;
			break;
		case M2M_REQ_GROUP_HIF:
			gstrHifCxt.pfHifCb = fn;
			break;
    4aaa:	e018      	b.n	4ade <hif_register_cb+0x62>
		case M2M_REQ_GROUP_CRYPTO:
			gstrHifCxt.pfCryptoCb = fn;
    4aac:	4b0d      	ldr	r3, [pc, #52]	; (4ae4 <hif_register_cb+0x68>)
    4aae:	6219      	str	r1, [r3, #32]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    4ab0:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_HIF:
			gstrHifCxt.pfHifCb = fn;
			break;
		case M2M_REQ_GROUP_CRYPTO:
			gstrHifCxt.pfCryptoCb = fn;
			break;
    4ab2:	e014      	b.n	4ade <hif_register_cb+0x62>
		case M2M_REQ_GROUP_SIGMA:
			gstrHifCxt.pfSigmaCb = fn;
    4ab4:	4b0b      	ldr	r3, [pc, #44]	; (4ae4 <hif_register_cb+0x68>)
    4ab6:	6199      	str	r1, [r3, #24]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    4ab8:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_CRYPTO:
			gstrHifCxt.pfCryptoCb = fn;
			break;
		case M2M_REQ_GROUP_SIGMA:
			gstrHifCxt.pfSigmaCb = fn;
			break;
    4aba:	e010      	b.n	4ade <hif_register_cb+0x62>
		case M2M_REQ_GROUP_SSL:
			gstrHifCxt.pfSslCb = fn;
    4abc:	4b09      	ldr	r3, [pc, #36]	; (4ae4 <hif_register_cb+0x68>)
    4abe:	6259      	str	r1, [r3, #36]	; 0x24
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    4ac0:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_SIGMA:
			gstrHifCxt.pfSigmaCb = fn;
			break;
		case M2M_REQ_GROUP_SSL:
			gstrHifCxt.pfSslCb = fn;
			break;
    4ac2:	e00c      	b.n	4ade <hif_register_cb+0x62>
		default:
			M2M_ERR("GRp ? %d\n",u8Grp);
    4ac4:	4a08      	ldr	r2, [pc, #32]	; (4ae8 <hif_register_cb+0x6c>)
    4ac6:	4909      	ldr	r1, [pc, #36]	; (4aec <hif_register_cb+0x70>)
    4ac8:	4809      	ldr	r0, [pc, #36]	; (4af0 <hif_register_cb+0x74>)
    4aca:	4d0a      	ldr	r5, [pc, #40]	; (4af4 <hif_register_cb+0x78>)
    4acc:	47a8      	blx	r5
    4ace:	0021      	movs	r1, r4
    4ad0:	4809      	ldr	r0, [pc, #36]	; (4af8 <hif_register_cb+0x7c>)
    4ad2:	47a8      	blx	r5
    4ad4:	200d      	movs	r0, #13
    4ad6:	4b09      	ldr	r3, [pc, #36]	; (4afc <hif_register_cb+0x80>)
    4ad8:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    4ada:	200c      	movs	r0, #12
    4adc:	4240      	negs	r0, r0
			break;
	}
	return ret;
}
    4ade:	bd70      	pop	{r4, r5, r6, pc}
    4ae0:	0001417c 	.word	0x0001417c
    4ae4:	20002270 	.word	0x20002270
    4ae8:	000002b1 	.word	0x000002b1
    4aec:	000141b8 	.word	0x000141b8
    4af0:	00014144 	.word	0x00014144
    4af4:	0001198d 	.word	0x0001198d
    4af8:	00014490 	.word	0x00014490
    4afc:	000119c1 	.word	0x000119c1

00004b00 <hif_init>:
*				Pointer to the arguments.
*   @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_init(void * arg)
{
    4b00:	b510      	push	{r4, lr}
	m2m_memset((uint8*)&gstrHifCxt,0,sizeof(tstrHifContext));
    4b02:	2228      	movs	r2, #40	; 0x28
    4b04:	2100      	movs	r1, #0
    4b06:	4806      	ldr	r0, [pc, #24]	; (4b20 <hif_init+0x20>)
    4b08:	4b06      	ldr	r3, [pc, #24]	; (4b24 <hif_init+0x24>)
    4b0a:	4798      	blx	r3
	nm_bsp_register_isr(isr);
    4b0c:	4806      	ldr	r0, [pc, #24]	; (4b28 <hif_init+0x28>)
    4b0e:	4b07      	ldr	r3, [pc, #28]	; (4b2c <hif_init+0x2c>)
    4b10:	4798      	blx	r3
	hif_register_cb(M2M_REQ_GROUP_HIF,m2m_hif_cb);
    4b12:	4907      	ldr	r1, [pc, #28]	; (4b30 <hif_init+0x30>)
    4b14:	2003      	movs	r0, #3
    4b16:	4b07      	ldr	r3, [pc, #28]	; (4b34 <hif_init+0x34>)
    4b18:	4798      	blx	r3
	return M2M_SUCCESS;
}
    4b1a:	2000      	movs	r0, #0
    4b1c:	bd10      	pop	{r4, pc}
    4b1e:	46c0      	nop			; (mov r8, r8)
    4b20:	20002270 	.word	0x20002270
    4b24:	0000426d 	.word	0x0000426d
    4b28:	00004299 	.word	0x00004299
    4b2c:	00003f45 	.word	0x00003f45
    4b30:	000042a9 	.word	0x000042a9
    4b34:	00004a7d 	.word	0x00004a7d

00004b38 <m2m_wifi_cb>:
*	@author
*	@date
*	@version	1.0
*/
static void m2m_wifi_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
{
    4b38:	b530      	push	{r4, r5, lr}
    4b3a:	b09f      	sub	sp, #124	; 0x7c
    4b3c:	0004      	movs	r4, r0
    4b3e:	0015      	movs	r5, r2
	uint8 rx_buf[8];
	if (u8OpCode == M2M_WIFI_RESP_CON_STATE_CHANGED)
    4b40:	282c      	cmp	r0, #44	; 0x2c
    4b42:	d111      	bne.n	4b68 <m2m_wifi_cb+0x30>
	{
		tstrM2mWifiStateChanged strState;
		if (hif_receive(u32Addr, (uint8*) &strState,sizeof(tstrM2mWifiStateChanged), 0) == M2M_SUCCESS)
    4b44:	2300      	movs	r3, #0
    4b46:	2204      	movs	r2, #4
    4b48:	a903      	add	r1, sp, #12
    4b4a:	0028      	movs	r0, r5
    4b4c:	4c94      	ldr	r4, [pc, #592]	; (4da0 <m2m_wifi_cb+0x268>)
    4b4e:	47a0      	blx	r4
    4b50:	2800      	cmp	r0, #0
    4b52:	d000      	beq.n	4b56 <m2m_wifi_cb+0x1e>
    4b54:	e122      	b.n	4d9c <m2m_wifi_cb+0x264>
		{
			if (gpfAppWifiCb)
    4b56:	4b93      	ldr	r3, [pc, #588]	; (4da4 <m2m_wifi_cb+0x26c>)
    4b58:	681b      	ldr	r3, [r3, #0]
    4b5a:	2b00      	cmp	r3, #0
    4b5c:	d100      	bne.n	4b60 <m2m_wifi_cb+0x28>
    4b5e:	e11d      	b.n	4d9c <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_CON_STATE_CHANGED, &strState);
    4b60:	a903      	add	r1, sp, #12
    4b62:	302c      	adds	r0, #44	; 0x2c
    4b64:	4798      	blx	r3
    4b66:	e119      	b.n	4d9c <m2m_wifi_cb+0x264>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_GET_SYS_TIME)
    4b68:	281b      	cmp	r0, #27
    4b6a:	d111      	bne.n	4b90 <m2m_wifi_cb+0x58>
	{
		tstrSystemTime strSysTime;
		if (hif_receive(u32Addr, (uint8*) &strSysTime,sizeof(tstrSystemTime), 0) == M2M_SUCCESS)
    4b6c:	2300      	movs	r3, #0
    4b6e:	2208      	movs	r2, #8
    4b70:	a903      	add	r1, sp, #12
    4b72:	0028      	movs	r0, r5
    4b74:	4c8a      	ldr	r4, [pc, #552]	; (4da0 <m2m_wifi_cb+0x268>)
    4b76:	47a0      	blx	r4
    4b78:	2800      	cmp	r0, #0
    4b7a:	d000      	beq.n	4b7e <m2m_wifi_cb+0x46>
    4b7c:	e10e      	b.n	4d9c <m2m_wifi_cb+0x264>
		{
			if (gpfAppWifiCb)
    4b7e:	4b89      	ldr	r3, [pc, #548]	; (4da4 <m2m_wifi_cb+0x26c>)
    4b80:	681b      	ldr	r3, [r3, #0]
    4b82:	2b00      	cmp	r3, #0
    4b84:	d100      	bne.n	4b88 <m2m_wifi_cb+0x50>
    4b86:	e109      	b.n	4d9c <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_GET_SYS_TIME, &strSysTime);
    4b88:	a903      	add	r1, sp, #12
    4b8a:	301b      	adds	r0, #27
    4b8c:	4798      	blx	r3
    4b8e:	e105      	b.n	4d9c <m2m_wifi_cb+0x264>
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_CONN_INFO)
    4b90:	2806      	cmp	r0, #6
    4b92:	d111      	bne.n	4bb8 <m2m_wifi_cb+0x80>
	{
		tstrM2MConnInfo		strConnInfo;
		if(hif_receive(u32Addr, (uint8*)&strConnInfo, sizeof(tstrM2MConnInfo), 1) == M2M_SUCCESS)
    4b94:	2301      	movs	r3, #1
    4b96:	2230      	movs	r2, #48	; 0x30
    4b98:	a903      	add	r1, sp, #12
    4b9a:	0028      	movs	r0, r5
    4b9c:	4c80      	ldr	r4, [pc, #512]	; (4da0 <m2m_wifi_cb+0x268>)
    4b9e:	47a0      	blx	r4
    4ba0:	2800      	cmp	r0, #0
    4ba2:	d000      	beq.n	4ba6 <m2m_wifi_cb+0x6e>
    4ba4:	e0fa      	b.n	4d9c <m2m_wifi_cb+0x264>
		{
			if(gpfAppWifiCb)
    4ba6:	4b7f      	ldr	r3, [pc, #508]	; (4da4 <m2m_wifi_cb+0x26c>)
    4ba8:	681b      	ldr	r3, [r3, #0]
    4baa:	2b00      	cmp	r3, #0
    4bac:	d100      	bne.n	4bb0 <m2m_wifi_cb+0x78>
    4bae:	e0f5      	b.n	4d9c <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_CONN_INFO, &strConnInfo);
    4bb0:	a903      	add	r1, sp, #12
    4bb2:	3006      	adds	r0, #6
    4bb4:	4798      	blx	r3
    4bb6:	e0f1      	b.n	4d9c <m2m_wifi_cb+0x264>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_MEMORY_RECOVER)
    4bb8:	280e      	cmp	r0, #14
    4bba:	d100      	bne.n	4bbe <m2m_wifi_cb+0x86>
    4bbc:	e0ee      	b.n	4d9c <m2m_wifi_cb+0x264>
			if (app_wifi_recover_cb)
				app_wifi_recover_cb(strState.u8CurrState);
		}
#endif
	}
	else if (u8OpCode == M2M_WIFI_REQ_DHCP_CONF)
    4bbe:	2832      	cmp	r0, #50	; 0x32
    4bc0:	d111      	bne.n	4be6 <m2m_wifi_cb+0xae>
	{
		tstrM2MIPConfig strIpConfig;
		if (hif_receive(u32Addr, (uint8 *)&strIpConfig, sizeof(tstrM2MIPConfig), 0) == M2M_SUCCESS)
    4bc2:	2300      	movs	r3, #0
    4bc4:	2214      	movs	r2, #20
    4bc6:	a903      	add	r1, sp, #12
    4bc8:	0028      	movs	r0, r5
    4bca:	4c75      	ldr	r4, [pc, #468]	; (4da0 <m2m_wifi_cb+0x268>)
    4bcc:	47a0      	blx	r4
    4bce:	2800      	cmp	r0, #0
    4bd0:	d000      	beq.n	4bd4 <m2m_wifi_cb+0x9c>
    4bd2:	e0e3      	b.n	4d9c <m2m_wifi_cb+0x264>
		{
			if (gpfAppWifiCb)
    4bd4:	4b73      	ldr	r3, [pc, #460]	; (4da4 <m2m_wifi_cb+0x26c>)
    4bd6:	681b      	ldr	r3, [r3, #0]
    4bd8:	2b00      	cmp	r3, #0
    4bda:	d100      	bne.n	4bde <m2m_wifi_cb+0xa6>
    4bdc:	e0de      	b.n	4d9c <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_REQ_DHCP_CONF, (uint8 *)&strIpConfig);
    4bde:	a903      	add	r1, sp, #12
    4be0:	3032      	adds	r0, #50	; 0x32
    4be2:	4798      	blx	r3
    4be4:	e0da      	b.n	4d9c <m2m_wifi_cb+0x264>
		}
	}
	else if (u8OpCode == M2M_WIFI_REQ_WPS)
    4be6:	282f      	cmp	r0, #47	; 0x2f
    4be8:	d116      	bne.n	4c18 <m2m_wifi_cb+0xe0>
	{
		tstrM2MWPSInfo strWps;
		m2m_memset((uint8*)&strWps,0,sizeof(tstrM2MWPSInfo));
    4bea:	2264      	movs	r2, #100	; 0x64
    4bec:	2100      	movs	r1, #0
    4bee:	a803      	add	r0, sp, #12
    4bf0:	4b6d      	ldr	r3, [pc, #436]	; (4da8 <m2m_wifi_cb+0x270>)
    4bf2:	4798      	blx	r3
		if(hif_receive(u32Addr, (uint8*)&strWps, sizeof(tstrM2MWPSInfo), 0) == M2M_SUCCESS)
    4bf4:	2300      	movs	r3, #0
    4bf6:	2264      	movs	r2, #100	; 0x64
    4bf8:	a903      	add	r1, sp, #12
    4bfa:	0028      	movs	r0, r5
    4bfc:	4c68      	ldr	r4, [pc, #416]	; (4da0 <m2m_wifi_cb+0x268>)
    4bfe:	47a0      	blx	r4
    4c00:	2800      	cmp	r0, #0
    4c02:	d000      	beq.n	4c06 <m2m_wifi_cb+0xce>
    4c04:	e0ca      	b.n	4d9c <m2m_wifi_cb+0x264>
		{
			if (gpfAppWifiCb)
    4c06:	4b67      	ldr	r3, [pc, #412]	; (4da4 <m2m_wifi_cb+0x26c>)
    4c08:	681b      	ldr	r3, [r3, #0]
    4c0a:	2b00      	cmp	r3, #0
    4c0c:	d100      	bne.n	4c10 <m2m_wifi_cb+0xd8>
    4c0e:	e0c5      	b.n	4d9c <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_REQ_WPS, &strWps);
    4c10:	a903      	add	r1, sp, #12
    4c12:	302f      	adds	r0, #47	; 0x2f
    4c14:	4798      	blx	r3
    4c16:	e0c1      	b.n	4d9c <m2m_wifi_cb+0x264>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_IP_CONFLICT)
    4c18:	2834      	cmp	r0, #52	; 0x34
    4c1a:	d122      	bne.n	4c62 <m2m_wifi_cb+0x12a>
	{
		uint32  u32ConflictedIP;
		if(hif_receive(u32Addr, (uint8 *)&u32ConflictedIP, sizeof(u32ConflictedIP), 0) == M2M_SUCCESS)
    4c1c:	2300      	movs	r3, #0
    4c1e:	2204      	movs	r2, #4
    4c20:	a903      	add	r1, sp, #12
    4c22:	0028      	movs	r0, r5
    4c24:	4c5e      	ldr	r4, [pc, #376]	; (4da0 <m2m_wifi_cb+0x268>)
    4c26:	47a0      	blx	r4
    4c28:	2800      	cmp	r0, #0
    4c2a:	d000      	beq.n	4c2e <m2m_wifi_cb+0xf6>
    4c2c:	e0b6      	b.n	4d9c <m2m_wifi_cb+0x264>
		{
			M2M_INFO("Conflicted IP \" %u.%u.%u.%u \" \n", 
    4c2e:	485f      	ldr	r0, [pc, #380]	; (4dac <m2m_wifi_cb+0x274>)
    4c30:	4c5f      	ldr	r4, [pc, #380]	; (4db0 <m2m_wifi_cb+0x278>)
    4c32:	47a0      	blx	r4
    4c34:	9803      	ldr	r0, [sp, #12]
    4c36:	0c03      	lsrs	r3, r0, #16
    4c38:	21ff      	movs	r1, #255	; 0xff
    4c3a:	400b      	ands	r3, r1
    4c3c:	0a02      	lsrs	r2, r0, #8
    4c3e:	400a      	ands	r2, r1
    4c40:	4001      	ands	r1, r0
    4c42:	0e00      	lsrs	r0, r0, #24
    4c44:	9000      	str	r0, [sp, #0]
    4c46:	485b      	ldr	r0, [pc, #364]	; (4db4 <m2m_wifi_cb+0x27c>)
    4c48:	47a0      	blx	r4
    4c4a:	200d      	movs	r0, #13
    4c4c:	4b5a      	ldr	r3, [pc, #360]	; (4db8 <m2m_wifi_cb+0x280>)
    4c4e:	4798      	blx	r3
				BYTE_0(u32ConflictedIP),BYTE_1(u32ConflictedIP),BYTE_2(u32ConflictedIP),BYTE_3(u32ConflictedIP));
			if (gpfAppWifiCb)
    4c50:	4b54      	ldr	r3, [pc, #336]	; (4da4 <m2m_wifi_cb+0x26c>)
    4c52:	681b      	ldr	r3, [r3, #0]
    4c54:	2b00      	cmp	r3, #0
    4c56:	d100      	bne.n	4c5a <m2m_wifi_cb+0x122>
    4c58:	e0a0      	b.n	4d9c <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_IP_CONFLICT, NULL);
    4c5a:	2100      	movs	r1, #0
    4c5c:	2034      	movs	r0, #52	; 0x34
    4c5e:	4798      	blx	r3
    4c60:	e09c      	b.n	4d9c <m2m_wifi_cb+0x264>

		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_SCAN_DONE)
    4c62:	2811      	cmp	r0, #17
    4c64:	d118      	bne.n	4c98 <m2m_wifi_cb+0x160>
	{
		tstrM2mScanDone strState;
		gu8scanInProgress = 0;
    4c66:	2200      	movs	r2, #0
    4c68:	4b54      	ldr	r3, [pc, #336]	; (4dbc <m2m_wifi_cb+0x284>)
    4c6a:	701a      	strb	r2, [r3, #0]
		if(hif_receive(u32Addr, (uint8*)&strState, sizeof(tstrM2mScanDone), 0) == M2M_SUCCESS)
    4c6c:	2300      	movs	r3, #0
    4c6e:	3204      	adds	r2, #4
    4c70:	a903      	add	r1, sp, #12
    4c72:	0028      	movs	r0, r5
    4c74:	4c4a      	ldr	r4, [pc, #296]	; (4da0 <m2m_wifi_cb+0x268>)
    4c76:	47a0      	blx	r4
    4c78:	2800      	cmp	r0, #0
    4c7a:	d000      	beq.n	4c7e <m2m_wifi_cb+0x146>
    4c7c:	e08e      	b.n	4d9c <m2m_wifi_cb+0x264>
		{
			gu8ChNum = strState.u8NumofCh;
    4c7e:	ab03      	add	r3, sp, #12
    4c80:	781a      	ldrb	r2, [r3, #0]
    4c82:	4b4f      	ldr	r3, [pc, #316]	; (4dc0 <m2m_wifi_cb+0x288>)
    4c84:	701a      	strb	r2, [r3, #0]
			if (gpfAppWifiCb)
    4c86:	4b47      	ldr	r3, [pc, #284]	; (4da4 <m2m_wifi_cb+0x26c>)
    4c88:	681b      	ldr	r3, [r3, #0]
    4c8a:	2b00      	cmp	r3, #0
    4c8c:	d100      	bne.n	4c90 <m2m_wifi_cb+0x158>
    4c8e:	e085      	b.n	4d9c <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_DONE, &strState);
    4c90:	a903      	add	r1, sp, #12
    4c92:	3011      	adds	r0, #17
    4c94:	4798      	blx	r3
    4c96:	e081      	b.n	4d9c <m2m_wifi_cb+0x264>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_SCAN_RESULT)
    4c98:	2813      	cmp	r0, #19
    4c9a:	d10f      	bne.n	4cbc <m2m_wifi_cb+0x184>
	{
		tstrM2mWifiscanResult strScanResult;
		if(hif_receive(u32Addr, (uint8*)&strScanResult, sizeof(tstrM2mWifiscanResult), 0) == M2M_SUCCESS)
    4c9c:	2300      	movs	r3, #0
    4c9e:	222c      	movs	r2, #44	; 0x2c
    4ca0:	a903      	add	r1, sp, #12
    4ca2:	0028      	movs	r0, r5
    4ca4:	4c3e      	ldr	r4, [pc, #248]	; (4da0 <m2m_wifi_cb+0x268>)
    4ca6:	47a0      	blx	r4
    4ca8:	2800      	cmp	r0, #0
    4caa:	d177      	bne.n	4d9c <m2m_wifi_cb+0x264>
		{
			if (gpfAppWifiCb)
    4cac:	4b3d      	ldr	r3, [pc, #244]	; (4da4 <m2m_wifi_cb+0x26c>)
    4cae:	681b      	ldr	r3, [r3, #0]
    4cb0:	2b00      	cmp	r3, #0
    4cb2:	d073      	beq.n	4d9c <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_RESULT, &strScanResult);
    4cb4:	a903      	add	r1, sp, #12
    4cb6:	3013      	adds	r0, #19
    4cb8:	4798      	blx	r3
    4cba:	e06f      	b.n	4d9c <m2m_wifi_cb+0x264>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_CURRENT_RSSI)
    4cbc:	2804      	cmp	r0, #4
    4cbe:	d10f      	bne.n	4ce0 <m2m_wifi_cb+0x1a8>
	{
		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
    4cc0:	2300      	movs	r3, #0
    4cc2:	2204      	movs	r2, #4
    4cc4:	a91c      	add	r1, sp, #112	; 0x70
    4cc6:	0028      	movs	r0, r5
    4cc8:	4c35      	ldr	r4, [pc, #212]	; (4da0 <m2m_wifi_cb+0x268>)
    4cca:	47a0      	blx	r4
    4ccc:	2800      	cmp	r0, #0
    4cce:	d165      	bne.n	4d9c <m2m_wifi_cb+0x264>
		{
			if (gpfAppWifiCb)
    4cd0:	4b34      	ldr	r3, [pc, #208]	; (4da4 <m2m_wifi_cb+0x26c>)
    4cd2:	681b      	ldr	r3, [r3, #0]
    4cd4:	2b00      	cmp	r3, #0
    4cd6:	d061      	beq.n	4d9c <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_CURRENT_RSSI, rx_buf);
    4cd8:	a91c      	add	r1, sp, #112	; 0x70
    4cda:	3004      	adds	r0, #4
    4cdc:	4798      	blx	r3
    4cde:	e05d      	b.n	4d9c <m2m_wifi_cb+0x264>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_CLIENT_INFO)
    4ce0:	2865      	cmp	r0, #101	; 0x65
    4ce2:	d10f      	bne.n	4d04 <m2m_wifi_cb+0x1cc>
	{
		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
    4ce4:	2300      	movs	r3, #0
    4ce6:	2204      	movs	r2, #4
    4ce8:	a91c      	add	r1, sp, #112	; 0x70
    4cea:	0028      	movs	r0, r5
    4cec:	4c2c      	ldr	r4, [pc, #176]	; (4da0 <m2m_wifi_cb+0x268>)
    4cee:	47a0      	blx	r4
    4cf0:	2800      	cmp	r0, #0
    4cf2:	d153      	bne.n	4d9c <m2m_wifi_cb+0x264>
		{
			if (gpfAppWifiCb)
    4cf4:	4b2b      	ldr	r3, [pc, #172]	; (4da4 <m2m_wifi_cb+0x26c>)
    4cf6:	681b      	ldr	r3, [r3, #0]
    4cf8:	2b00      	cmp	r3, #0
    4cfa:	d04f      	beq.n	4d9c <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_CLIENT_INFO, rx_buf);
    4cfc:	a91c      	add	r1, sp, #112	; 0x70
    4cfe:	3065      	adds	r0, #101	; 0x65
    4d00:	4798      	blx	r3
    4d02:	e04b      	b.n	4d9c <m2m_wifi_cb+0x264>
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_PROVISION_INFO)
    4d04:	2809      	cmp	r0, #9
    4d06:	d10f      	bne.n	4d28 <m2m_wifi_cb+0x1f0>
	{
		tstrM2MProvisionInfo	strProvInfo;
		if(hif_receive(u32Addr, (uint8*)&strProvInfo, sizeof(tstrM2MProvisionInfo), 1) == M2M_SUCCESS)
    4d08:	2301      	movs	r3, #1
    4d0a:	2264      	movs	r2, #100	; 0x64
    4d0c:	a903      	add	r1, sp, #12
    4d0e:	0028      	movs	r0, r5
    4d10:	4c23      	ldr	r4, [pc, #140]	; (4da0 <m2m_wifi_cb+0x268>)
    4d12:	47a0      	blx	r4
    4d14:	2800      	cmp	r0, #0
    4d16:	d141      	bne.n	4d9c <m2m_wifi_cb+0x264>
		{
			if(gpfAppWifiCb)
    4d18:	4b22      	ldr	r3, [pc, #136]	; (4da4 <m2m_wifi_cb+0x26c>)
    4d1a:	681b      	ldr	r3, [r3, #0]
    4d1c:	2b00      	cmp	r3, #0
    4d1e:	d03d      	beq.n	4d9c <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_PROVISION_INFO, &strProvInfo);
    4d20:	a903      	add	r1, sp, #12
    4d22:	3009      	adds	r0, #9
    4d24:	4798      	blx	r3
    4d26:	e039      	b.n	4d9c <m2m_wifi_cb+0x264>
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_DEFAULT_CONNECT)
    4d28:	282a      	cmp	r0, #42	; 0x2a
    4d2a:	d10f      	bne.n	4d4c <m2m_wifi_cb+0x214>
	{
		tstrM2MDefaultConnResp	strResp;
		if(hif_receive(u32Addr, (uint8*)&strResp, sizeof(tstrM2MDefaultConnResp), 1) == M2M_SUCCESS)
    4d2c:	2301      	movs	r3, #1
    4d2e:	2204      	movs	r2, #4
    4d30:	a903      	add	r1, sp, #12
    4d32:	0028      	movs	r0, r5
    4d34:	4c1a      	ldr	r4, [pc, #104]	; (4da0 <m2m_wifi_cb+0x268>)
    4d36:	47a0      	blx	r4
    4d38:	2800      	cmp	r0, #0
    4d3a:	d12f      	bne.n	4d9c <m2m_wifi_cb+0x264>
		{
			if(gpfAppWifiCb)
    4d3c:	4b19      	ldr	r3, [pc, #100]	; (4da4 <m2m_wifi_cb+0x26c>)
    4d3e:	681b      	ldr	r3, [r3, #0]
    4d40:	2b00      	cmp	r3, #0
    4d42:	d02b      	beq.n	4d9c <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_DEFAULT_CONNECT, &strResp);
    4d44:	a903      	add	r1, sp, #12
    4d46:	302a      	adds	r0, #42	; 0x2a
    4d48:	4798      	blx	r3
    4d4a:	e027      	b.n	4d9c <m2m_wifi_cb+0x264>
		}
	}
	
	else if(u8OpCode == M2M_WIFI_RESP_GET_PRNG)
    4d4c:	2820      	cmp	r0, #32
    4d4e:	d119      	bne.n	4d84 <m2m_wifi_cb+0x24c>
	{
		tstrPrng strPrng;
		if(hif_receive(u32Addr, (uint8*)&strPrng,sizeof(tstrPrng), 0) == M2M_SUCCESS)
    4d50:	2300      	movs	r3, #0
    4d52:	2208      	movs	r2, #8
    4d54:	a903      	add	r1, sp, #12
    4d56:	0028      	movs	r0, r5
    4d58:	4c11      	ldr	r4, [pc, #68]	; (4da0 <m2m_wifi_cb+0x268>)
    4d5a:	47a0      	blx	r4
    4d5c:	2800      	cmp	r0, #0
    4d5e:	d11d      	bne.n	4d9c <m2m_wifi_cb+0x264>
		{
			if(hif_receive(u32Addr + sizeof(tstrPrng),strPrng.pu8RngBuff,strPrng.u16PrngSize, 1) == M2M_SUCCESS)
    4d60:	ab03      	add	r3, sp, #12
    4d62:	889a      	ldrh	r2, [r3, #4]
    4d64:	0028      	movs	r0, r5
    4d66:	3008      	adds	r0, #8
    4d68:	2301      	movs	r3, #1
    4d6a:	9903      	ldr	r1, [sp, #12]
    4d6c:	4c0c      	ldr	r4, [pc, #48]	; (4da0 <m2m_wifi_cb+0x268>)
    4d6e:	47a0      	blx	r4
    4d70:	2800      	cmp	r0, #0
    4d72:	d113      	bne.n	4d9c <m2m_wifi_cb+0x264>
			{
				if(gpfAppWifiCb)
    4d74:	4b0b      	ldr	r3, [pc, #44]	; (4da4 <m2m_wifi_cb+0x26c>)
    4d76:	681b      	ldr	r3, [r3, #0]
    4d78:	2b00      	cmp	r3, #0
    4d7a:	d00f      	beq.n	4d9c <m2m_wifi_cb+0x264>
					gpfAppWifiCb(M2M_WIFI_RESP_GET_PRNG,&strPrng);
    4d7c:	a903      	add	r1, sp, #12
    4d7e:	3020      	adds	r0, #32
    4d80:	4798      	blx	r3
    4d82:	e00b      	b.n	4d9c <m2m_wifi_cb+0x264>
		}
	}
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
    4d84:	2292      	movs	r2, #146	; 0x92
    4d86:	0052      	lsls	r2, r2, #1
    4d88:	490e      	ldr	r1, [pc, #56]	; (4dc4 <m2m_wifi_cb+0x28c>)
    4d8a:	480f      	ldr	r0, [pc, #60]	; (4dc8 <m2m_wifi_cb+0x290>)
    4d8c:	4d08      	ldr	r5, [pc, #32]	; (4db0 <m2m_wifi_cb+0x278>)
    4d8e:	47a8      	blx	r5
    4d90:	0021      	movs	r1, r4
    4d92:	480e      	ldr	r0, [pc, #56]	; (4dcc <m2m_wifi_cb+0x294>)
    4d94:	47a8      	blx	r5
    4d96:	200d      	movs	r0, #13
    4d98:	4b07      	ldr	r3, [pc, #28]	; (4db8 <m2m_wifi_cb+0x280>)
    4d9a:	4798      	blx	r3
	}
}
    4d9c:	b01f      	add	sp, #124	; 0x7c
    4d9e:	bd30      	pop	{r4, r5, pc}
    4da0:	00004991 	.word	0x00004991
    4da4:	200008cc 	.word	0x200008cc
    4da8:	0000426d 	.word	0x0000426d
    4dac:	00013ca0 	.word	0x00013ca0
    4db0:	0001198d 	.word	0x0001198d
    4db4:	000144d0 	.word	0x000144d0
    4db8:	000119c1 	.word	0x000119c1
    4dbc:	200008d0 	.word	0x200008d0
    4dc0:	200008d1 	.word	0x200008d1
    4dc4:	000144c4 	.word	0x000144c4
    4dc8:	00014144 	.word	0x00014144
    4dcc:	000144f0 	.word	0x000144f0

00004dd0 <m2m_validate_ap_parameters>:
_EXIT0:
	return ret;
}

static sint8 m2m_validate_ap_parameters(CONST tstrM2MAPConfig* pstrM2MAPConfig)
{
    4dd0:	b510      	push	{r4, lr}
    4dd2:	1e04      	subs	r4, r0, #0
	sint8 s8Ret = M2M_SUCCESS;
	/* Check for incoming pointer */
	if(pstrM2MAPConfig == NULL)
    4dd4:	d10e      	bne.n	4df4 <m2m_validate_ap_parameters+0x24>
	{
		M2M_ERR("INVALID POINTER\n");
    4dd6:	223e      	movs	r2, #62	; 0x3e
    4dd8:	32ff      	adds	r2, #255	; 0xff
    4dda:	4963      	ldr	r1, [pc, #396]	; (4f68 <m2m_validate_ap_parameters+0x198>)
    4ddc:	4863      	ldr	r0, [pc, #396]	; (4f6c <m2m_validate_ap_parameters+0x19c>)
    4dde:	4b64      	ldr	r3, [pc, #400]	; (4f70 <m2m_validate_ap_parameters+0x1a0>)
    4de0:	4798      	blx	r3
    4de2:	4864      	ldr	r0, [pc, #400]	; (4f74 <m2m_validate_ap_parameters+0x1a4>)
    4de4:	4b64      	ldr	r3, [pc, #400]	; (4f78 <m2m_validate_ap_parameters+0x1a8>)
    4de6:	4798      	blx	r3
    4de8:	200d      	movs	r0, #13
    4dea:	4b64      	ldr	r3, [pc, #400]	; (4f7c <m2m_validate_ap_parameters+0x1ac>)
    4dec:	4798      	blx	r3
		s8Ret = M2M_ERR_FAIL;
    4dee:	200c      	movs	r0, #12
    4df0:	4240      	negs	r0, r0
		goto ERR1;
    4df2:	e0b8      	b.n	4f66 <m2m_validate_ap_parameters+0x196>
	}
	/* Check for SSID */
	if((m2m_strlen((uint8 *)pstrM2MAPConfig->au8SSID) <= 0) || (m2m_strlen((uint8 *)pstrM2MAPConfig->au8SSID) >= M2M_MAX_SSID_LEN))
    4df4:	4b62      	ldr	r3, [pc, #392]	; (4f80 <m2m_validate_ap_parameters+0x1b0>)
    4df6:	4798      	blx	r3
    4df8:	2800      	cmp	r0, #0
    4dfa:	d004      	beq.n	4e06 <m2m_validate_ap_parameters+0x36>
    4dfc:	0020      	movs	r0, r4
    4dfe:	4b60      	ldr	r3, [pc, #384]	; (4f80 <m2m_validate_ap_parameters+0x1b0>)
    4e00:	4798      	blx	r3
    4e02:	2820      	cmp	r0, #32
    4e04:	d90e      	bls.n	4e24 <m2m_validate_ap_parameters+0x54>
	{
		M2M_ERR("INVALID SSID\n");
    4e06:	22a2      	movs	r2, #162	; 0xa2
    4e08:	0052      	lsls	r2, r2, #1
    4e0a:	4957      	ldr	r1, [pc, #348]	; (4f68 <m2m_validate_ap_parameters+0x198>)
    4e0c:	4857      	ldr	r0, [pc, #348]	; (4f6c <m2m_validate_ap_parameters+0x19c>)
    4e0e:	4b58      	ldr	r3, [pc, #352]	; (4f70 <m2m_validate_ap_parameters+0x1a0>)
    4e10:	4798      	blx	r3
    4e12:	485c      	ldr	r0, [pc, #368]	; (4f84 <m2m_validate_ap_parameters+0x1b4>)
    4e14:	4b58      	ldr	r3, [pc, #352]	; (4f78 <m2m_validate_ap_parameters+0x1a8>)
    4e16:	4798      	blx	r3
    4e18:	200d      	movs	r0, #13
    4e1a:	4b58      	ldr	r3, [pc, #352]	; (4f7c <m2m_validate_ap_parameters+0x1ac>)
    4e1c:	4798      	blx	r3
		s8Ret = M2M_ERR_FAIL;
    4e1e:	200c      	movs	r0, #12
    4e20:	4240      	negs	r0, r0
		goto ERR1;
    4e22:	e0a0      	b.n	4f66 <m2m_validate_ap_parameters+0x196>
	}
	/* Check for Channel */
	if(pstrM2MAPConfig->u8ListenChannel > M2M_WIFI_CH_14 || pstrM2MAPConfig->u8ListenChannel < M2M_WIFI_CH_1)
    4e24:	2321      	movs	r3, #33	; 0x21
    4e26:	5ce3      	ldrb	r3, [r4, r3]
    4e28:	3b01      	subs	r3, #1
    4e2a:	2b0d      	cmp	r3, #13
    4e2c:	d90e      	bls.n	4e4c <m2m_validate_ap_parameters+0x7c>
	{
		M2M_ERR("INVALID CH\n");
    4e2e:	224c      	movs	r2, #76	; 0x4c
    4e30:	32ff      	adds	r2, #255	; 0xff
    4e32:	494d      	ldr	r1, [pc, #308]	; (4f68 <m2m_validate_ap_parameters+0x198>)
    4e34:	484d      	ldr	r0, [pc, #308]	; (4f6c <m2m_validate_ap_parameters+0x19c>)
    4e36:	4b4e      	ldr	r3, [pc, #312]	; (4f70 <m2m_validate_ap_parameters+0x1a0>)
    4e38:	4798      	blx	r3
    4e3a:	4853      	ldr	r0, [pc, #332]	; (4f88 <m2m_validate_ap_parameters+0x1b8>)
    4e3c:	4b4e      	ldr	r3, [pc, #312]	; (4f78 <m2m_validate_ap_parameters+0x1a8>)
    4e3e:	4798      	blx	r3
    4e40:	200d      	movs	r0, #13
    4e42:	4b4e      	ldr	r3, [pc, #312]	; (4f7c <m2m_validate_ap_parameters+0x1ac>)
    4e44:	4798      	blx	r3
		s8Ret = M2M_ERR_FAIL;
    4e46:	200c      	movs	r0, #12
    4e48:	4240      	negs	r0, r0
		goto ERR1;
    4e4a:	e08c      	b.n	4f66 <m2m_validate_ap_parameters+0x196>
	}
	/* Check for DHCP Server IP address */
	if(!(pstrM2MAPConfig->au8DHCPServerIP[0] || pstrM2MAPConfig->au8DHCPServerIP[1]))
    4e4c:	2341      	movs	r3, #65	; 0x41
    4e4e:	5ce3      	ldrb	r3, [r4, r3]
    4e50:	2b00      	cmp	r3, #0
    4e52:	d116      	bne.n	4e82 <m2m_validate_ap_parameters+0xb2>
    4e54:	3342      	adds	r3, #66	; 0x42
    4e56:	5ce3      	ldrb	r3, [r4, r3]
    4e58:	2b00      	cmp	r3, #0
    4e5a:	d112      	bne.n	4e82 <m2m_validate_ap_parameters+0xb2>
	{
		if(!(pstrM2MAPConfig->au8DHCPServerIP[2]))
    4e5c:	3343      	adds	r3, #67	; 0x43
    4e5e:	5ce3      	ldrb	r3, [r4, r3]
    4e60:	2b00      	cmp	r3, #0
    4e62:	d10e      	bne.n	4e82 <m2m_validate_ap_parameters+0xb2>
		{
			M2M_ERR("INVALID DHCP SERVER IP\n");
    4e64:	22aa      	movs	r2, #170	; 0xaa
    4e66:	0052      	lsls	r2, r2, #1
    4e68:	493f      	ldr	r1, [pc, #252]	; (4f68 <m2m_validate_ap_parameters+0x198>)
    4e6a:	4840      	ldr	r0, [pc, #256]	; (4f6c <m2m_validate_ap_parameters+0x19c>)
    4e6c:	4b40      	ldr	r3, [pc, #256]	; (4f70 <m2m_validate_ap_parameters+0x1a0>)
    4e6e:	4798      	blx	r3
    4e70:	4846      	ldr	r0, [pc, #280]	; (4f8c <m2m_validate_ap_parameters+0x1bc>)
    4e72:	4b41      	ldr	r3, [pc, #260]	; (4f78 <m2m_validate_ap_parameters+0x1a8>)
    4e74:	4798      	blx	r3
    4e76:	200d      	movs	r0, #13
    4e78:	4b40      	ldr	r3, [pc, #256]	; (4f7c <m2m_validate_ap_parameters+0x1ac>)
    4e7a:	4798      	blx	r3
			s8Ret = M2M_ERR_FAIL;
    4e7c:	200c      	movs	r0, #12
    4e7e:	4240      	negs	r0, r0
			goto ERR1;
    4e80:	e071      	b.n	4f66 <m2m_validate_ap_parameters+0x196>
		}
	}
	/* Check for Security */
	if(pstrM2MAPConfig->u8SecType == M2M_WIFI_SEC_OPEN)
    4e82:	233f      	movs	r3, #63	; 0x3f
    4e84:	5ce3      	ldrb	r3, [r4, r3]
    4e86:	2b01      	cmp	r3, #1
    4e88:	d06c      	beq.n	4f64 <m2m_validate_ap_parameters+0x194>
	{
		goto ERR1;
	}
	else if(pstrM2MAPConfig->u8SecType == M2M_WIFI_SEC_WEP)
    4e8a:	2b03      	cmp	r3, #3
    4e8c:	d144      	bne.n	4f18 <m2m_validate_ap_parameters+0x148>
	{
		/* Check for WEP Key index */
		if((pstrM2MAPConfig->u8KeyIndx <= 0) || (pstrM2MAPConfig->u8KeyIndx > WEP_KEY_MAX_INDEX))
    4e8e:	331f      	adds	r3, #31
    4e90:	5ce3      	ldrb	r3, [r4, r3]
    4e92:	3b01      	subs	r3, #1
    4e94:	2b03      	cmp	r3, #3
    4e96:	d90e      	bls.n	4eb6 <m2m_validate_ap_parameters+0xe6>
		{
			M2M_ERR("INVALID KEY INDEX\n");
    4e98:	2264      	movs	r2, #100	; 0x64
    4e9a:	32ff      	adds	r2, #255	; 0xff
    4e9c:	4932      	ldr	r1, [pc, #200]	; (4f68 <m2m_validate_ap_parameters+0x198>)
    4e9e:	4833      	ldr	r0, [pc, #204]	; (4f6c <m2m_validate_ap_parameters+0x19c>)
    4ea0:	4b33      	ldr	r3, [pc, #204]	; (4f70 <m2m_validate_ap_parameters+0x1a0>)
    4ea2:	4798      	blx	r3
    4ea4:	483a      	ldr	r0, [pc, #232]	; (4f90 <m2m_validate_ap_parameters+0x1c0>)
    4ea6:	4b34      	ldr	r3, [pc, #208]	; (4f78 <m2m_validate_ap_parameters+0x1a8>)
    4ea8:	4798      	blx	r3
    4eaa:	200d      	movs	r0, #13
    4eac:	4b33      	ldr	r3, [pc, #204]	; (4f7c <m2m_validate_ap_parameters+0x1ac>)
    4eae:	4798      	blx	r3
			s8Ret = M2M_ERR_FAIL;
    4eb0:	200c      	movs	r0, #12
    4eb2:	4240      	negs	r0, r0
			goto ERR1;
    4eb4:	e057      	b.n	4f66 <m2m_validate_ap_parameters+0x196>
		}
		/* Check for WEP Key size */
		if(	(pstrM2MAPConfig->u8KeySz != WEP_40_KEY_STRING_SIZE) &&
    4eb6:	2323      	movs	r3, #35	; 0x23
    4eb8:	5ce3      	ldrb	r3, [r4, r3]
    4eba:	2210      	movs	r2, #16
    4ebc:	4393      	bics	r3, r2
    4ebe:	2b0a      	cmp	r3, #10
    4ec0:	d00e      	beq.n	4ee0 <m2m_validate_ap_parameters+0x110>
			(pstrM2MAPConfig->u8KeySz != WEP_104_KEY_STRING_SIZE)
		)
		{
			M2M_ERR("INVALID KEY STRING SIZE\n");
    4ec2:	325d      	adds	r2, #93	; 0x5d
    4ec4:	32ff      	adds	r2, #255	; 0xff
    4ec6:	4928      	ldr	r1, [pc, #160]	; (4f68 <m2m_validate_ap_parameters+0x198>)
    4ec8:	4828      	ldr	r0, [pc, #160]	; (4f6c <m2m_validate_ap_parameters+0x19c>)
    4eca:	4b29      	ldr	r3, [pc, #164]	; (4f70 <m2m_validate_ap_parameters+0x1a0>)
    4ecc:	4798      	blx	r3
    4ece:	4831      	ldr	r0, [pc, #196]	; (4f94 <m2m_validate_ap_parameters+0x1c4>)
    4ed0:	4b29      	ldr	r3, [pc, #164]	; (4f78 <m2m_validate_ap_parameters+0x1a8>)
    4ed2:	4798      	blx	r3
    4ed4:	200d      	movs	r0, #13
    4ed6:	4b29      	ldr	r3, [pc, #164]	; (4f7c <m2m_validate_ap_parameters+0x1ac>)
    4ed8:	4798      	blx	r3
			s8Ret = M2M_ERR_FAIL;
    4eda:	200c      	movs	r0, #12
    4edc:	4240      	negs	r0, r0
			goto ERR1;
    4ede:	e042      	b.n	4f66 <m2m_validate_ap_parameters+0x196>
		}

		if((m2m_strlen((uint8 *)pstrM2MAPConfig->au8WepKey) <= 0) || (m2m_strlen((uint8 *)pstrM2MAPConfig->au8WepKey) > WEP_104_KEY_STRING_SIZE))
    4ee0:	3424      	adds	r4, #36	; 0x24
    4ee2:	0020      	movs	r0, r4
    4ee4:	4b26      	ldr	r3, [pc, #152]	; (4f80 <m2m_validate_ap_parameters+0x1b0>)
    4ee6:	4798      	blx	r3
    4ee8:	2800      	cmp	r0, #0
    4eea:	d006      	beq.n	4efa <m2m_validate_ap_parameters+0x12a>
    4eec:	0020      	movs	r0, r4
    4eee:	4b24      	ldr	r3, [pc, #144]	; (4f80 <m2m_validate_ap_parameters+0x1b0>)
    4ef0:	4798      	blx	r3
    4ef2:	0003      	movs	r3, r0
	return ret;
}

static sint8 m2m_validate_ap_parameters(CONST tstrM2MAPConfig* pstrM2MAPConfig)
{
	sint8 s8Ret = M2M_SUCCESS;
    4ef4:	2000      	movs	r0, #0
			M2M_ERR("INVALID KEY STRING SIZE\n");
			s8Ret = M2M_ERR_FAIL;
			goto ERR1;
		}

		if((m2m_strlen((uint8 *)pstrM2MAPConfig->au8WepKey) <= 0) || (m2m_strlen((uint8 *)pstrM2MAPConfig->au8WepKey) > WEP_104_KEY_STRING_SIZE))
    4ef6:	2b1a      	cmp	r3, #26
    4ef8:	d935      	bls.n	4f66 <m2m_validate_ap_parameters+0x196>
		{
			M2M_ERR("INVALID KEY SIZE\n");
    4efa:	2274      	movs	r2, #116	; 0x74
    4efc:	32ff      	adds	r2, #255	; 0xff
    4efe:	491a      	ldr	r1, [pc, #104]	; (4f68 <m2m_validate_ap_parameters+0x198>)
    4f00:	481a      	ldr	r0, [pc, #104]	; (4f6c <m2m_validate_ap_parameters+0x19c>)
    4f02:	4b1b      	ldr	r3, [pc, #108]	; (4f70 <m2m_validate_ap_parameters+0x1a0>)
    4f04:	4798      	blx	r3
    4f06:	4824      	ldr	r0, [pc, #144]	; (4f98 <m2m_validate_ap_parameters+0x1c8>)
    4f08:	4b1b      	ldr	r3, [pc, #108]	; (4f78 <m2m_validate_ap_parameters+0x1a8>)
    4f0a:	4798      	blx	r3
    4f0c:	200d      	movs	r0, #13
    4f0e:	4b1b      	ldr	r3, [pc, #108]	; (4f7c <m2m_validate_ap_parameters+0x1ac>)
    4f10:	4798      	blx	r3
			s8Ret = M2M_ERR_FAIL;
    4f12:	200c      	movs	r0, #12
    4f14:	4240      	negs	r0, r0
			goto ERR1;
    4f16:	e026      	b.n	4f66 <m2m_validate_ap_parameters+0x196>
		}
	}
	else if(pstrM2MAPConfig->u8SecType == M2M_WIFI_SEC_WPA_PSK)
    4f18:	2b02      	cmp	r3, #2
    4f1a:	d114      	bne.n	4f46 <m2m_validate_ap_parameters+0x176>
	{
		/* Check for WPA Key size */
		if(	((pstrM2MAPConfig->u8KeySz + 1) < M2M_MIN_PSK_LEN) || ((pstrM2MAPConfig->u8KeySz + 1) > M2M_MAX_PSK_LEN))
    4f1c:	3321      	adds	r3, #33	; 0x21
    4f1e:	5ce3      	ldrb	r3, [r4, r3]
    4f20:	3b08      	subs	r3, #8
	return ret;
}

static sint8 m2m_validate_ap_parameters(CONST tstrM2MAPConfig* pstrM2MAPConfig)
{
	sint8 s8Ret = M2M_SUCCESS;
    4f22:	2000      	movs	r0, #0
		}
	}
	else if(pstrM2MAPConfig->u8SecType == M2M_WIFI_SEC_WPA_PSK)
	{
		/* Check for WPA Key size */
		if(	((pstrM2MAPConfig->u8KeySz + 1) < M2M_MIN_PSK_LEN) || ((pstrM2MAPConfig->u8KeySz + 1) > M2M_MAX_PSK_LEN))
    4f24:	2b38      	cmp	r3, #56	; 0x38
    4f26:	d91e      	bls.n	4f66 <m2m_validate_ap_parameters+0x196>
		{
			M2M_ERR("INVALID WPA KEY SIZE\n");
    4f28:	227e      	movs	r2, #126	; 0x7e
    4f2a:	32ff      	adds	r2, #255	; 0xff
    4f2c:	490e      	ldr	r1, [pc, #56]	; (4f68 <m2m_validate_ap_parameters+0x198>)
    4f2e:	480f      	ldr	r0, [pc, #60]	; (4f6c <m2m_validate_ap_parameters+0x19c>)
    4f30:	4b0f      	ldr	r3, [pc, #60]	; (4f70 <m2m_validate_ap_parameters+0x1a0>)
    4f32:	4798      	blx	r3
    4f34:	4819      	ldr	r0, [pc, #100]	; (4f9c <m2m_validate_ap_parameters+0x1cc>)
    4f36:	4b10      	ldr	r3, [pc, #64]	; (4f78 <m2m_validate_ap_parameters+0x1a8>)
    4f38:	4798      	blx	r3
    4f3a:	200d      	movs	r0, #13
    4f3c:	4b0f      	ldr	r3, [pc, #60]	; (4f7c <m2m_validate_ap_parameters+0x1ac>)
    4f3e:	4798      	blx	r3
			s8Ret = M2M_ERR_FAIL;
    4f40:	200c      	movs	r0, #12
    4f42:	4240      	negs	r0, r0
			goto ERR1;
    4f44:	e00f      	b.n	4f66 <m2m_validate_ap_parameters+0x196>
		}
	}
	else
	{
		M2M_ERR("INVALID AUTHENTICATION MODE\n");
    4f46:	22c2      	movs	r2, #194	; 0xc2
    4f48:	0052      	lsls	r2, r2, #1
    4f4a:	4907      	ldr	r1, [pc, #28]	; (4f68 <m2m_validate_ap_parameters+0x198>)
    4f4c:	4807      	ldr	r0, [pc, #28]	; (4f6c <m2m_validate_ap_parameters+0x19c>)
    4f4e:	4b08      	ldr	r3, [pc, #32]	; (4f70 <m2m_validate_ap_parameters+0x1a0>)
    4f50:	4798      	blx	r3
    4f52:	4813      	ldr	r0, [pc, #76]	; (4fa0 <m2m_validate_ap_parameters+0x1d0>)
    4f54:	4b08      	ldr	r3, [pc, #32]	; (4f78 <m2m_validate_ap_parameters+0x1a8>)
    4f56:	4798      	blx	r3
    4f58:	200d      	movs	r0, #13
    4f5a:	4b08      	ldr	r3, [pc, #32]	; (4f7c <m2m_validate_ap_parameters+0x1ac>)
    4f5c:	4798      	blx	r3
		s8Ret = M2M_ERR_FAIL;
    4f5e:	200c      	movs	r0, #12
    4f60:	4240      	negs	r0, r0
		goto ERR1;
    4f62:	e000      	b.n	4f66 <m2m_validate_ap_parameters+0x196>
	return ret;
}

static sint8 m2m_validate_ap_parameters(CONST tstrM2MAPConfig* pstrM2MAPConfig)
{
	sint8 s8Ret = M2M_SUCCESS;
    4f64:	2000      	movs	r0, #0
		goto ERR1;
	}
	
ERR1:
	return s8Ret;
}
    4f66:	bd10      	pop	{r4, pc}
    4f68:	00014864 	.word	0x00014864
    4f6c:	00014144 	.word	0x00014144
    4f70:	0001198d 	.word	0x0001198d
    4f74:	00014504 	.word	0x00014504
    4f78:	00011aad 	.word	0x00011aad
    4f7c:	000119c1 	.word	0x000119c1
    4f80:	0000427d 	.word	0x0000427d
    4f84:	00014514 	.word	0x00014514
    4f88:	00014524 	.word	0x00014524
    4f8c:	00014530 	.word	0x00014530
    4f90:	00014548 	.word	0x00014548
    4f94:	0001455c 	.word	0x0001455c
    4f98:	00014574 	.word	0x00014574
    4f9c:	00014588 	.word	0x00014588
    4fa0:	000145a0 	.word	0x000145a0

00004fa4 <m2m_wifi_init>:
	s8Ret = hif_send(M2M_REQ_GROUP_SSL, M2M_SSL_IND_CRL|M2M_REQ_DATA_PKT, NULL, 0, (uint8*)pCRL, sizeof(tstrTlsCrlInfo), 0);
	return s8Ret;
}

sint8 m2m_wifi_init(tstrWifiInitParam * param)
{
    4fa4:	b5f0      	push	{r4, r5, r6, r7, lr}
    4fa6:	b08f      	sub	sp, #60	; 0x3c
	tstrM2mRev strtmp;
	sint8 ret = M2M_SUCCESS;
	uint8 u8WifiMode = M2M_WIFI_MODE_NORMAL;
    4fa8:	2201      	movs	r2, #1
    4faa:	230f      	movs	r3, #15
    4fac:	446b      	add	r3, sp
    4fae:	701a      	strb	r2, [r3, #0]
	
	if(param == NULL) {
    4fb0:	2800      	cmp	r0, #0
    4fb2:	d05e      	beq.n	5072 <m2m_wifi_init+0xce>
		ret = M2M_ERR_FAIL;
		goto _EXIT0;
	}
	
	gpfAppWifiCb = param->pfAppWifiCb;
    4fb4:	6802      	ldr	r2, [r0, #0]
    4fb6:	4b31      	ldr	r3, [pc, #196]	; (507c <m2m_wifi_init+0xd8>)
    4fb8:	601a      	str	r2, [r3, #0]
#endif /* ETH_MODE */

#ifdef CONF_MGMT
	gpfAppMonCb  = param->pfAppMonCb;
#endif
	gu8scanInProgress = 0;
    4fba:	2200      	movs	r2, #0
    4fbc:	4b30      	ldr	r3, [pc, #192]	; (5080 <m2m_wifi_init+0xdc>)
    4fbe:	701a      	strb	r2, [r3, #0]
	/* Apply device specific initialization. */
	ret = nm_drv_init(&u8WifiMode);
    4fc0:	200f      	movs	r0, #15
    4fc2:	4468      	add	r0, sp
    4fc4:	4b2f      	ldr	r3, [pc, #188]	; (5084 <m2m_wifi_init+0xe0>)
    4fc6:	4798      	blx	r3
    4fc8:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS) 	goto _EXIT0;
    4fca:	d154      	bne.n	5076 <m2m_wifi_init+0xd2>
	/* Initialize host interface module */
	ret = hif_init(NULL);
    4fcc:	2000      	movs	r0, #0
    4fce:	4b2e      	ldr	r3, [pc, #184]	; (5088 <m2m_wifi_init+0xe4>)
    4fd0:	4798      	blx	r3
    4fd2:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS) 	goto _EXIT1;
    4fd4:	d149      	bne.n	506a <m2m_wifi_init+0xc6>

	hif_register_cb(M2M_REQ_GROUP_WIFI,m2m_wifi_cb);
    4fd6:	492d      	ldr	r1, [pc, #180]	; (508c <m2m_wifi_init+0xe8>)
    4fd8:	2001      	movs	r0, #1
    4fda:	4b2d      	ldr	r3, [pc, #180]	; (5090 <m2m_wifi_init+0xec>)
    4fdc:	4798      	blx	r3

	ret = nm_get_firmware_full_info(&strtmp);
    4fde:	ae04      	add	r6, sp, #16
    4fe0:	0030      	movs	r0, r6
    4fe2:	4b2c      	ldr	r3, [pc, #176]	; (5094 <m2m_wifi_init+0xf0>)
    4fe4:	4798      	blx	r3
    4fe6:	0004      	movs	r4, r0

	M2M_INFO("Firmware ver   : %u.%u.%u Svnrev %u\n", strtmp.u8FirmwareMajor, strtmp.u8FirmwareMinor, strtmp.u8FirmwarePatch,strtmp.u16FirmwareSvnNum);
    4fe8:	482b      	ldr	r0, [pc, #172]	; (5098 <m2m_wifi_init+0xf4>)
    4fea:	4d2c      	ldr	r5, [pc, #176]	; (509c <m2m_wifi_init+0xf8>)
    4fec:	47a8      	blx	r5
    4fee:	79b3      	ldrb	r3, [r6, #6]
    4ff0:	7972      	ldrb	r2, [r6, #5]
    4ff2:	7931      	ldrb	r1, [r6, #4]
    4ff4:	8c30      	ldrh	r0, [r6, #32]
    4ff6:	9000      	str	r0, [sp, #0]
    4ff8:	4829      	ldr	r0, [pc, #164]	; (50a0 <m2m_wifi_init+0xfc>)
    4ffa:	47a8      	blx	r5
    4ffc:	200d      	movs	r0, #13
    4ffe:	4f29      	ldr	r7, [pc, #164]	; (50a4 <m2m_wifi_init+0x100>)
    5000:	47b8      	blx	r7
	M2M_INFO("Firmware Build %s Time %s\n",strtmp.BuildDate,strtmp.BuildTime);
    5002:	4825      	ldr	r0, [pc, #148]	; (5098 <m2m_wifi_init+0xf4>)
    5004:	47a8      	blx	r5
    5006:	2226      	movs	r2, #38	; 0x26
    5008:	446a      	add	r2, sp
    500a:	211a      	movs	r1, #26
    500c:	4469      	add	r1, sp
    500e:	4826      	ldr	r0, [pc, #152]	; (50a8 <m2m_wifi_init+0x104>)
    5010:	47a8      	blx	r5
    5012:	200d      	movs	r0, #13
    5014:	47b8      	blx	r7
	M2M_INFO("Firmware Min driver ver : %u.%u.%u\n", strtmp.u8DriverMajor, strtmp.u8DriverMinor, strtmp.u8DriverPatch);
    5016:	4820      	ldr	r0, [pc, #128]	; (5098 <m2m_wifi_init+0xf4>)
    5018:	47a8      	blx	r5
    501a:	7a73      	ldrb	r3, [r6, #9]
    501c:	7a32      	ldrb	r2, [r6, #8]
    501e:	79f1      	ldrb	r1, [r6, #7]
    5020:	4822      	ldr	r0, [pc, #136]	; (50ac <m2m_wifi_init+0x108>)
    5022:	47a8      	blx	r5
    5024:	200d      	movs	r0, #13
    5026:	47b8      	blx	r7
	M2M_INFO("Driver ver: %u.%u.%u\n", M2M_RELEASE_VERSION_MAJOR_NO, M2M_RELEASE_VERSION_MINOR_NO, M2M_RELEASE_VERSION_PATCH_NO);
    5028:	481b      	ldr	r0, [pc, #108]	; (5098 <m2m_wifi_init+0xf4>)
    502a:	47a8      	blx	r5
    502c:	2302      	movs	r3, #2
    502e:	2205      	movs	r2, #5
    5030:	2113      	movs	r1, #19
    5032:	481f      	ldr	r0, [pc, #124]	; (50b0 <m2m_wifi_init+0x10c>)
    5034:	47a8      	blx	r5
    5036:	200d      	movs	r0, #13
    5038:	47b8      	blx	r7
	M2M_INFO("Driver built at %s\t%s\n",__DATE__,__TIME__);
    503a:	4817      	ldr	r0, [pc, #92]	; (5098 <m2m_wifi_init+0xf4>)
    503c:	47a8      	blx	r5
    503e:	4a1d      	ldr	r2, [pc, #116]	; (50b4 <m2m_wifi_init+0x110>)
    5040:	491d      	ldr	r1, [pc, #116]	; (50b8 <m2m_wifi_init+0x114>)
    5042:	481e      	ldr	r0, [pc, #120]	; (50bc <m2m_wifi_init+0x118>)
    5044:	47a8      	blx	r5
    5046:	200d      	movs	r0, #13
    5048:	47b8      	blx	r7
	if(M2M_ERR_FW_VER_MISMATCH == ret)
    504a:	0023      	movs	r3, r4
    504c:	330d      	adds	r3, #13
    504e:	d112      	bne.n	5076 <m2m_wifi_init+0xd2>
	{
		M2M_ERR("Mismatch Firmawre Version\n");
    5050:	22e8      	movs	r2, #232	; 0xe8
    5052:	32ff      	adds	r2, #255	; 0xff
    5054:	491a      	ldr	r1, [pc, #104]	; (50c0 <m2m_wifi_init+0x11c>)
    5056:	481b      	ldr	r0, [pc, #108]	; (50c4 <m2m_wifi_init+0x120>)
    5058:	4b10      	ldr	r3, [pc, #64]	; (509c <m2m_wifi_init+0xf8>)
    505a:	4798      	blx	r3
    505c:	481a      	ldr	r0, [pc, #104]	; (50c8 <m2m_wifi_init+0x124>)
    505e:	4b1b      	ldr	r3, [pc, #108]	; (50cc <m2m_wifi_init+0x128>)
    5060:	4798      	blx	r3
    5062:	200d      	movs	r0, #13
    5064:	4b0f      	ldr	r3, [pc, #60]	; (50a4 <m2m_wifi_init+0x100>)
    5066:	4798      	blx	r3
    5068:	e005      	b.n	5076 <m2m_wifi_init+0xd2>
	}

	goto _EXIT0;

_EXIT1:
	nm_drv_deinit(NULL);
    506a:	2000      	movs	r0, #0
    506c:	4b18      	ldr	r3, [pc, #96]	; (50d0 <m2m_wifi_init+0x12c>)
    506e:	4798      	blx	r3
    5070:	e001      	b.n	5076 <m2m_wifi_init+0xd2>
	tstrM2mRev strtmp;
	sint8 ret = M2M_SUCCESS;
	uint8 u8WifiMode = M2M_WIFI_MODE_NORMAL;
	
	if(param == NULL) {
		ret = M2M_ERR_FAIL;
    5072:	240c      	movs	r4, #12
    5074:	4264      	negs	r4, r4

_EXIT1:
	nm_drv_deinit(NULL);
_EXIT0:
	return ret;
}
    5076:	0020      	movs	r0, r4
    5078:	b00f      	add	sp, #60	; 0x3c
    507a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    507c:	200008cc 	.word	0x200008cc
    5080:	200008d0 	.word	0x200008d0
    5084:	00005b31 	.word	0x00005b31
    5088:	00004b01 	.word	0x00004b01
    508c:	00004b39 	.word	0x00004b39
    5090:	00004a7d 	.word	0x00004a7d
    5094:	00005a4d 	.word	0x00005a4d
    5098:	00013ca0 	.word	0x00013ca0
    509c:	0001198d 	.word	0x0001198d
    50a0:	000145bc 	.word	0x000145bc
    50a4:	000119c1 	.word	0x000119c1
    50a8:	000145e4 	.word	0x000145e4
    50ac:	00014600 	.word	0x00014600
    50b0:	00014624 	.word	0x00014624
    50b4:	0001463c 	.word	0x0001463c
    50b8:	00014648 	.word	0x00014648
    50bc:	00014654 	.word	0x00014654
    50c0:	00014880 	.word	0x00014880
    50c4:	00014144 	.word	0x00014144
    50c8:	0001466c 	.word	0x0001466c
    50cc:	00011aad 	.word	0x00011aad
    50d0:	00005c05 	.word	0x00005c05

000050d4 <m2m_wifi_handle_events>:
	return M2M_SUCCESS;
}


sint8 m2m_wifi_handle_events(void * arg)
{
    50d4:	b510      	push	{r4, lr}
	return hif_handle_isr();
    50d6:	4b01      	ldr	r3, [pc, #4]	; (50dc <m2m_wifi_handle_events+0x8>)
    50d8:	4798      	blx	r3
}
    50da:	bd10      	pop	{r4, pc}
    50dc:	000045b1 	.word	0x000045b1

000050e0 <m2m_wifi_connect_sc>:
sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch)
{
	return m2m_wifi_connect_sc(pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);
}
sint8 m2m_wifi_connect_sc(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch, uint8 u8NoSaveCred)
{
    50e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    50e2:	464f      	mov	r7, r9
    50e4:	4646      	mov	r6, r8
    50e6:	b4c0      	push	{r6, r7}
    50e8:	b0a3      	sub	sp, #140	; 0x8c
    50ea:	9005      	str	r0, [sp, #20]
    50ec:	000c      	movs	r4, r1
    50ee:	0015      	movs	r5, r2
    50f0:	001f      	movs	r7, r3
    50f2:	ab2a      	add	r3, sp, #168	; 0xa8
    50f4:	881b      	ldrh	r3, [r3, #0]
    50f6:	4699      	mov	r9, r3
    50f8:	ab2b      	add	r3, sp, #172	; 0xac
    50fa:	781b      	ldrb	r3, [r3, #0]
    50fc:	4698      	mov	r8, r3
	sint8				ret = M2M_SUCCESS;
	tstrM2mWifiConnect	strConnect;
	tstrM2MWifiSecInfo	*pstrAuthInfo;

	if(u8SecType != M2M_WIFI_SEC_OPEN)
    50fe:	2a01      	cmp	r2, #1
    5100:	d040      	beq.n	5184 <m2m_wifi_connect_sc+0xa4>
	{
		if(pvAuthInfo == NULL)
    5102:	2f00      	cmp	r7, #0
    5104:	d10d      	bne.n	5122 <m2m_wifi_connect_sc+0x42>
		{
			M2M_ERR("Key is not valid\n");
    5106:	4a80      	ldr	r2, [pc, #512]	; (5308 <m2m_wifi_connect_sc+0x228>)
    5108:	4980      	ldr	r1, [pc, #512]	; (530c <m2m_wifi_connect_sc+0x22c>)
    510a:	4881      	ldr	r0, [pc, #516]	; (5310 <m2m_wifi_connect_sc+0x230>)
    510c:	4b81      	ldr	r3, [pc, #516]	; (5314 <m2m_wifi_connect_sc+0x234>)
    510e:	4798      	blx	r3
    5110:	4881      	ldr	r0, [pc, #516]	; (5318 <m2m_wifi_connect_sc+0x238>)
    5112:	4b82      	ldr	r3, [pc, #520]	; (531c <m2m_wifi_connect_sc+0x23c>)
    5114:	4798      	blx	r3
    5116:	200d      	movs	r0, #13
    5118:	4b81      	ldr	r3, [pc, #516]	; (5320 <m2m_wifi_connect_sc+0x240>)
    511a:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    511c:	200c      	movs	r0, #12
    511e:	4240      	negs	r0, r0
			goto ERR1;
    5120:	e0ec      	b.n	52fc <m2m_wifi_connect_sc+0x21c>
		}
		if((u8SecType == M2M_WIFI_SEC_WPA_PSK) && (m2m_strlen(pvAuthInfo) == (M2M_MAX_PSK_LEN-1)))
    5122:	2a02      	cmp	r2, #2
    5124:	d12e      	bne.n	5184 <m2m_wifi_connect_sc+0xa4>
    5126:	0038      	movs	r0, r7
    5128:	4b7e      	ldr	r3, [pc, #504]	; (5324 <m2m_wifi_connect_sc+0x244>)
    512a:	4798      	blx	r3
    512c:	2840      	cmp	r0, #64	; 0x40
    512e:	d129      	bne.n	5184 <m2m_wifi_connect_sc+0xa4>
		{
			uint8 i = 0;
			uint8* pu8Psk = (uint8*)pvAuthInfo;
			while(i < (M2M_MAX_PSK_LEN-1))
			{
				if(pu8Psk[i]<'0' || (pu8Psk[i]>'9' && pu8Psk[i] < 'A')|| (pu8Psk[i]>'F' && pu8Psk[i] < 'a') || pu8Psk[i] > 'f')
    5130:	783b      	ldrb	r3, [r7, #0]
    5132:	001a      	movs	r2, r3
    5134:	3a30      	subs	r2, #48	; 0x30
    5136:	2a36      	cmp	r2, #54	; 0x36
    5138:	d813      	bhi.n	5162 <m2m_wifi_connect_sc+0x82>
    513a:	3a0a      	subs	r2, #10
    513c:	2a06      	cmp	r2, #6
    513e:	d910      	bls.n	5162 <m2m_wifi_connect_sc+0x82>
    5140:	3b47      	subs	r3, #71	; 0x47
    5142:	2b19      	cmp	r3, #25
    5144:	d90d      	bls.n	5162 <m2m_wifi_connect_sc+0x82>
    5146:	1c7a      	adds	r2, r7, #1
    5148:	0038      	movs	r0, r7
    514a:	3040      	adds	r0, #64	; 0x40
    514c:	7813      	ldrb	r3, [r2, #0]
    514e:	0019      	movs	r1, r3
    5150:	3930      	subs	r1, #48	; 0x30
    5152:	2936      	cmp	r1, #54	; 0x36
    5154:	d805      	bhi.n	5162 <m2m_wifi_connect_sc+0x82>
    5156:	390a      	subs	r1, #10
    5158:	2906      	cmp	r1, #6
    515a:	d902      	bls.n	5162 <m2m_wifi_connect_sc+0x82>
    515c:	3b47      	subs	r3, #71	; 0x47
    515e:	2b19      	cmp	r3, #25
    5160:	d80d      	bhi.n	517e <m2m_wifi_connect_sc+0x9e>
				{
					M2M_ERR("Invalid Key\n");
    5162:	4a71      	ldr	r2, [pc, #452]	; (5328 <m2m_wifi_connect_sc+0x248>)
    5164:	4969      	ldr	r1, [pc, #420]	; (530c <m2m_wifi_connect_sc+0x22c>)
    5166:	486a      	ldr	r0, [pc, #424]	; (5310 <m2m_wifi_connect_sc+0x230>)
    5168:	4b6a      	ldr	r3, [pc, #424]	; (5314 <m2m_wifi_connect_sc+0x234>)
    516a:	4798      	blx	r3
    516c:	486f      	ldr	r0, [pc, #444]	; (532c <m2m_wifi_connect_sc+0x24c>)
    516e:	4b6b      	ldr	r3, [pc, #428]	; (531c <m2m_wifi_connect_sc+0x23c>)
    5170:	4798      	blx	r3
    5172:	200d      	movs	r0, #13
    5174:	4b6a      	ldr	r3, [pc, #424]	; (5320 <m2m_wifi_connect_sc+0x240>)
    5176:	4798      	blx	r3
					ret = M2M_ERR_FAIL;
    5178:	200c      	movs	r0, #12
    517a:	4240      	negs	r0, r0
					goto ERR1;
    517c:	e0be      	b.n	52fc <m2m_wifi_connect_sc+0x21c>
    517e:	3201      	adds	r2, #1
		}
		if((u8SecType == M2M_WIFI_SEC_WPA_PSK) && (m2m_strlen(pvAuthInfo) == (M2M_MAX_PSK_LEN-1)))
		{
			uint8 i = 0;
			uint8* pu8Psk = (uint8*)pvAuthInfo;
			while(i < (M2M_MAX_PSK_LEN-1))
    5180:	4282      	cmp	r2, r0
    5182:	d1e3      	bne.n	514c <m2m_wifi_connect_sc+0x6c>
				}
				i++;
			}
		}
	}
	if((u8SsidLen<=0)||(u8SsidLen>=M2M_MAX_SSID_LEN))
    5184:	1e63      	subs	r3, r4, #1
    5186:	2b1f      	cmp	r3, #31
    5188:	d90d      	bls.n	51a6 <m2m_wifi_connect_sc+0xc6>
	{
		M2M_ERR("SSID LEN INVALID\n");
    518a:	4a69      	ldr	r2, [pc, #420]	; (5330 <m2m_wifi_connect_sc+0x250>)
    518c:	495f      	ldr	r1, [pc, #380]	; (530c <m2m_wifi_connect_sc+0x22c>)
    518e:	4860      	ldr	r0, [pc, #384]	; (5310 <m2m_wifi_connect_sc+0x230>)
    5190:	4b60      	ldr	r3, [pc, #384]	; (5314 <m2m_wifi_connect_sc+0x234>)
    5192:	4798      	blx	r3
    5194:	4867      	ldr	r0, [pc, #412]	; (5334 <m2m_wifi_connect_sc+0x254>)
    5196:	4b61      	ldr	r3, [pc, #388]	; (531c <m2m_wifi_connect_sc+0x23c>)
    5198:	4798      	blx	r3
    519a:	200d      	movs	r0, #13
    519c:	4b60      	ldr	r3, [pc, #384]	; (5320 <m2m_wifi_connect_sc+0x240>)
    519e:	4798      	blx	r3
		ret = M2M_ERR_FAIL;
    51a0:	200c      	movs	r0, #12
    51a2:	4240      	negs	r0, r0
		goto ERR1;
    51a4:	e0aa      	b.n	52fc <m2m_wifi_connect_sc+0x21c>
	}

	if(u16Ch < M2M_WIFI_CH_1|| u16Ch > M2M_WIFI_CH_14)
    51a6:	464b      	mov	r3, r9
    51a8:	3b01      	subs	r3, #1
    51aa:	b29b      	uxth	r3, r3
    51ac:	2b0d      	cmp	r3, #13
    51ae:	d911      	bls.n	51d4 <m2m_wifi_connect_sc+0xf4>
	{
		if(u16Ch!=M2M_WIFI_CH_ALL)
    51b0:	464b      	mov	r3, r9
    51b2:	2bff      	cmp	r3, #255	; 0xff
    51b4:	d00e      	beq.n	51d4 <m2m_wifi_connect_sc+0xf4>
		{
			M2M_ERR("CH INVALID\n");
    51b6:	228d      	movs	r2, #141	; 0x8d
    51b8:	0092      	lsls	r2, r2, #2
    51ba:	4954      	ldr	r1, [pc, #336]	; (530c <m2m_wifi_connect_sc+0x22c>)
    51bc:	4854      	ldr	r0, [pc, #336]	; (5310 <m2m_wifi_connect_sc+0x230>)
    51be:	4b55      	ldr	r3, [pc, #340]	; (5314 <m2m_wifi_connect_sc+0x234>)
    51c0:	4798      	blx	r3
    51c2:	485d      	ldr	r0, [pc, #372]	; (5338 <m2m_wifi_connect_sc+0x258>)
    51c4:	4b55      	ldr	r3, [pc, #340]	; (531c <m2m_wifi_connect_sc+0x23c>)
    51c6:	4798      	blx	r3
    51c8:	200d      	movs	r0, #13
    51ca:	4b55      	ldr	r3, [pc, #340]	; (5320 <m2m_wifi_connect_sc+0x240>)
    51cc:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    51ce:	200c      	movs	r0, #12
    51d0:	4240      	negs	r0, r0
			goto ERR1;
    51d2:	e093      	b.n	52fc <m2m_wifi_connect_sc+0x21c>
		}
	}


	m2m_memcpy(strConnect.au8SSID, (uint8*)pcSsid, u8SsidLen);
    51d4:	ae07      	add	r6, sp, #28
    51d6:	0022      	movs	r2, r4
    51d8:	9905      	ldr	r1, [sp, #20]
    51da:	205a      	movs	r0, #90	; 0x5a
    51dc:	ab02      	add	r3, sp, #8
    51de:	469c      	mov	ip, r3
    51e0:	4460      	add	r0, ip
    51e2:	4b56      	ldr	r3, [pc, #344]	; (533c <m2m_wifi_connect_sc+0x25c>)
    51e4:	4798      	blx	r3
	strConnect.au8SSID[u8SsidLen]	= 0;
    51e6:	1934      	adds	r4, r6, r4
    51e8:	3446      	adds	r4, #70	; 0x46
    51ea:	2300      	movs	r3, #0
    51ec:	7023      	strb	r3, [r4, #0]
	strConnect.u16Ch				= NM_BSP_B_L_16(u16Ch);
    51ee:	3344      	adds	r3, #68	; 0x44
    51f0:	464a      	mov	r2, r9
    51f2:	52f2      	strh	r2, [r6, r3]
	/* Credentials will be Not be saved if u8NoSaveCred is set */ 
	strConnect.u8NoSaveCred 			= u8NoSaveCred ? 1:0;
    51f4:	4643      	mov	r3, r8
    51f6:	1e5a      	subs	r2, r3, #1
    51f8:	4193      	sbcs	r3, r2
    51fa:	2267      	movs	r2, #103	; 0x67
    51fc:	54b3      	strb	r3, [r6, r2]
	pstrAuthInfo = &strConnect.strSec;
	pstrAuthInfo->u8SecType		= u8SecType;
    51fe:	2341      	movs	r3, #65	; 0x41
    5200:	54f5      	strb	r5, [r6, r3]

	if(u8SecType == M2M_WIFI_SEC_WEP)
    5202:	2d03      	cmp	r5, #3
    5204:	d13b      	bne.n	527e <m2m_wifi_connect_sc+0x19e>
	{
		tstrM2mWifiWepParams	* pstrWepParams = (tstrM2mWifiWepParams*)pvAuthInfo;
		tstrM2mWifiWepParams	*pstrWep = &pstrAuthInfo->uniAuth.strWepInfo;
		pstrWep->u8KeyIndx =pstrWepParams->u8KeyIndx-1;
    5206:	783b      	ldrb	r3, [r7, #0]
    5208:	3b01      	subs	r3, #1
    520a:	b2db      	uxtb	r3, r3
    520c:	aa07      	add	r2, sp, #28
    520e:	7013      	strb	r3, [r2, #0]

		if(pstrWep->u8KeyIndx >= WEP_KEY_MAX_INDEX)
    5210:	2b03      	cmp	r3, #3
    5212:	d90e      	bls.n	5232 <m2m_wifi_connect_sc+0x152>
		{
			M2M_ERR("Invalid Wep key index %d\n", pstrWep->u8KeyIndx);
    5214:	4a4a      	ldr	r2, [pc, #296]	; (5340 <m2m_wifi_connect_sc+0x260>)
    5216:	493d      	ldr	r1, [pc, #244]	; (530c <m2m_wifi_connect_sc+0x22c>)
    5218:	483d      	ldr	r0, [pc, #244]	; (5310 <m2m_wifi_connect_sc+0x230>)
    521a:	4c3e      	ldr	r4, [pc, #248]	; (5314 <m2m_wifi_connect_sc+0x234>)
    521c:	47a0      	blx	r4
    521e:	ab07      	add	r3, sp, #28
    5220:	7819      	ldrb	r1, [r3, #0]
    5222:	4848      	ldr	r0, [pc, #288]	; (5344 <m2m_wifi_connect_sc+0x264>)
    5224:	47a0      	blx	r4
    5226:	200d      	movs	r0, #13
    5228:	4b3d      	ldr	r3, [pc, #244]	; (5320 <m2m_wifi_connect_sc+0x240>)
    522a:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    522c:	200c      	movs	r0, #12
    522e:	4240      	negs	r0, r0
			goto ERR1;
    5230:	e064      	b.n	52fc <m2m_wifi_connect_sc+0x21c>
		}
		pstrWep->u8KeySz = pstrWepParams->u8KeySz-1;
    5232:	787a      	ldrb	r2, [r7, #1]
    5234:	1e51      	subs	r1, r2, #1
    5236:	ab07      	add	r3, sp, #28
    5238:	7059      	strb	r1, [r3, #1]
		if ((pstrWep->u8KeySz != WEP_40_KEY_STRING_SIZE)&& (pstrWep->u8KeySz != WEP_104_KEY_STRING_SIZE))
    523a:	2310      	movs	r3, #16
    523c:	0011      	movs	r1, r2
    523e:	4399      	bics	r1, r3
    5240:	290b      	cmp	r1, #11
    5242:	d00e      	beq.n	5262 <m2m_wifi_connect_sc+0x182>
		{
			M2M_ERR("Invalid Wep key length %d\n", pstrWep->u8KeySz);
    5244:	4a40      	ldr	r2, [pc, #256]	; (5348 <m2m_wifi_connect_sc+0x268>)
    5246:	4931      	ldr	r1, [pc, #196]	; (530c <m2m_wifi_connect_sc+0x22c>)
    5248:	4831      	ldr	r0, [pc, #196]	; (5310 <m2m_wifi_connect_sc+0x230>)
    524a:	4c32      	ldr	r4, [pc, #200]	; (5314 <m2m_wifi_connect_sc+0x234>)
    524c:	47a0      	blx	r4
    524e:	ab07      	add	r3, sp, #28
    5250:	7859      	ldrb	r1, [r3, #1]
    5252:	483e      	ldr	r0, [pc, #248]	; (534c <m2m_wifi_connect_sc+0x26c>)
    5254:	47a0      	blx	r4
    5256:	200d      	movs	r0, #13
    5258:	4b31      	ldr	r3, [pc, #196]	; (5320 <m2m_wifi_connect_sc+0x240>)
    525a:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    525c:	200c      	movs	r0, #12
    525e:	4240      	negs	r0, r0
			goto ERR1;
    5260:	e04c      	b.n	52fc <m2m_wifi_connect_sc+0x21c>
		}
		m2m_memcpy((uint8*)pstrWep->au8WepKey,(uint8*)pstrWepParams->au8WepKey, pstrWepParams->u8KeySz);
    5262:	1cb9      	adds	r1, r7, #2
    5264:	2016      	movs	r0, #22
    5266:	ab02      	add	r3, sp, #8
    5268:	469c      	mov	ip, r3
    526a:	4460      	add	r0, ip
    526c:	4b33      	ldr	r3, [pc, #204]	; (533c <m2m_wifi_connect_sc+0x25c>)
    526e:	4798      	blx	r3
		pstrWep->au8WepKey[pstrWepParams->u8KeySz] = 0;
    5270:	787b      	ldrb	r3, [r7, #1]
    5272:	aa07      	add	r2, sp, #28
    5274:	4694      	mov	ip, r2
    5276:	4463      	add	r3, ip
    5278:	2200      	movs	r2, #0
    527a:	709a      	strb	r2, [r3, #2]
    527c:	e034      	b.n	52e8 <m2m_wifi_connect_sc+0x208>

	}


	else if(u8SecType == M2M_WIFI_SEC_WPA_PSK)
    527e:	2d02      	cmp	r5, #2
    5280:	d11a      	bne.n	52b8 <m2m_wifi_connect_sc+0x1d8>
	{
		uint16	u16KeyLen = m2m_strlen((uint8*)pvAuthInfo);
    5282:	0038      	movs	r0, r7
    5284:	4b27      	ldr	r3, [pc, #156]	; (5324 <m2m_wifi_connect_sc+0x244>)
    5286:	4798      	blx	r3
		if((u16KeyLen <= 0)||(u16KeyLen >= M2M_MAX_PSK_LEN))
    5288:	1e43      	subs	r3, r0, #1
    528a:	b29b      	uxth	r3, r3
    528c:	2b3f      	cmp	r3, #63	; 0x3f
    528e:	d90d      	bls.n	52ac <m2m_wifi_connect_sc+0x1cc>
		{
			M2M_ERR("Incorrect PSK key length\n");
    5290:	4a2f      	ldr	r2, [pc, #188]	; (5350 <m2m_wifi_connect_sc+0x270>)
    5292:	491e      	ldr	r1, [pc, #120]	; (530c <m2m_wifi_connect_sc+0x22c>)
    5294:	481e      	ldr	r0, [pc, #120]	; (5310 <m2m_wifi_connect_sc+0x230>)
    5296:	4b1f      	ldr	r3, [pc, #124]	; (5314 <m2m_wifi_connect_sc+0x234>)
    5298:	4798      	blx	r3
    529a:	482e      	ldr	r0, [pc, #184]	; (5354 <m2m_wifi_connect_sc+0x274>)
    529c:	4b1f      	ldr	r3, [pc, #124]	; (531c <m2m_wifi_connect_sc+0x23c>)
    529e:	4798      	blx	r3
    52a0:	200d      	movs	r0, #13
    52a2:	4b1f      	ldr	r3, [pc, #124]	; (5320 <m2m_wifi_connect_sc+0x240>)
    52a4:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    52a6:	200c      	movs	r0, #12
    52a8:	4240      	negs	r0, r0
			goto ERR1;
    52aa:	e027      	b.n	52fc <m2m_wifi_connect_sc+0x21c>
		}
		m2m_memcpy(pstrAuthInfo->uniAuth.au8PSK, (uint8*)pvAuthInfo, u16KeyLen + 1);
    52ac:	1c42      	adds	r2, r0, #1
    52ae:	0039      	movs	r1, r7
    52b0:	a807      	add	r0, sp, #28
    52b2:	4b22      	ldr	r3, [pc, #136]	; (533c <m2m_wifi_connect_sc+0x25c>)
    52b4:	4798      	blx	r3
    52b6:	e017      	b.n	52e8 <m2m_wifi_connect_sc+0x208>
	}
	else if(u8SecType == M2M_WIFI_SEC_802_1X)
    52b8:	2d04      	cmp	r5, #4
    52ba:	d105      	bne.n	52c8 <m2m_wifi_connect_sc+0x1e8>
	{
		m2m_memcpy((uint8*)&pstrAuthInfo->uniAuth.strCred1x, (uint8*)pvAuthInfo, sizeof(tstr1xAuthCredentials));
    52bc:	223e      	movs	r2, #62	; 0x3e
    52be:	0039      	movs	r1, r7
    52c0:	a807      	add	r0, sp, #28
    52c2:	4b1e      	ldr	r3, [pc, #120]	; (533c <m2m_wifi_connect_sc+0x25c>)
    52c4:	4798      	blx	r3
    52c6:	e00f      	b.n	52e8 <m2m_wifi_connect_sc+0x208>
	}
	else if(u8SecType == M2M_WIFI_SEC_OPEN)
    52c8:	2d01      	cmp	r5, #1
    52ca:	d00d      	beq.n	52e8 <m2m_wifi_connect_sc+0x208>
	{

	}
	else
	{
		M2M_ERR("undefined sec type\n");
    52cc:	4a22      	ldr	r2, [pc, #136]	; (5358 <m2m_wifi_connect_sc+0x278>)
    52ce:	490f      	ldr	r1, [pc, #60]	; (530c <m2m_wifi_connect_sc+0x22c>)
    52d0:	480f      	ldr	r0, [pc, #60]	; (5310 <m2m_wifi_connect_sc+0x230>)
    52d2:	4b10      	ldr	r3, [pc, #64]	; (5314 <m2m_wifi_connect_sc+0x234>)
    52d4:	4798      	blx	r3
    52d6:	4821      	ldr	r0, [pc, #132]	; (535c <m2m_wifi_connect_sc+0x27c>)
    52d8:	4b10      	ldr	r3, [pc, #64]	; (531c <m2m_wifi_connect_sc+0x23c>)
    52da:	4798      	blx	r3
    52dc:	200d      	movs	r0, #13
    52de:	4b10      	ldr	r3, [pc, #64]	; (5320 <m2m_wifi_connect_sc+0x240>)
    52e0:	4798      	blx	r3
		ret = M2M_ERR_FAIL;
    52e2:	200c      	movs	r0, #12
    52e4:	4240      	negs	r0, r0
		goto ERR1;
    52e6:	e009      	b.n	52fc <m2m_wifi_connect_sc+0x21c>
	}

	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_CONNECT, (uint8*)&strConnect, sizeof(tstrM2mWifiConnect),NULL, 0,0);
    52e8:	2300      	movs	r3, #0
    52ea:	9302      	str	r3, [sp, #8]
    52ec:	9301      	str	r3, [sp, #4]
    52ee:	9300      	str	r3, [sp, #0]
    52f0:	336c      	adds	r3, #108	; 0x6c
    52f2:	aa07      	add	r2, sp, #28
    52f4:	2128      	movs	r1, #40	; 0x28
    52f6:	2001      	movs	r0, #1
    52f8:	4c19      	ldr	r4, [pc, #100]	; (5360 <m2m_wifi_connect_sc+0x280>)
    52fa:	47a0      	blx	r4

ERR1:
	return ret;
}
    52fc:	b023      	add	sp, #140	; 0x8c
    52fe:	bc0c      	pop	{r2, r3}
    5300:	4690      	mov	r8, r2
    5302:	4699      	mov	r9, r3
    5304:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5306:	46c0      	nop			; (mov r8, r8)
    5308:	00000215 	.word	0x00000215
    530c:	000144b0 	.word	0x000144b0
    5310:	00014144 	.word	0x00014144
    5314:	0001198d 	.word	0x0001198d
    5318:	00014688 	.word	0x00014688
    531c:	00011aad 	.word	0x00011aad
    5320:	000119c1 	.word	0x000119c1
    5324:	0000427d 	.word	0x0000427d
    5328:	00000221 	.word	0x00000221
    532c:	0001469c 	.word	0x0001469c
    5330:	0000022b 	.word	0x0000022b
    5334:	000146a8 	.word	0x000146a8
    5338:	000146bc 	.word	0x000146bc
    533c:	00004259 	.word	0x00004259
    5340:	0000024b 	.word	0x0000024b
    5344:	000146c8 	.word	0x000146c8
    5348:	00000252 	.word	0x00000252
    534c:	000146e4 	.word	0x000146e4
    5350:	00000261 	.word	0x00000261
    5354:	00014700 	.word	0x00014700
    5358:	00000271 	.word	0x00000271
    535c:	0001471c 	.word	0x0001471c
    5360:	0000437d 	.word	0x0000437d

00005364 <m2m_wifi_connect>:
{
	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DEFAULT_CONNECT, NULL, 0,NULL, 0,0);
}

sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch)
{
    5364:	b530      	push	{r4, r5, lr}
    5366:	b083      	sub	sp, #12
    5368:	ac06      	add	r4, sp, #24
    536a:	8824      	ldrh	r4, [r4, #0]
	return m2m_wifi_connect_sc(pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);
    536c:	2500      	movs	r5, #0
    536e:	9501      	str	r5, [sp, #4]
    5370:	9400      	str	r4, [sp, #0]
    5372:	4c02      	ldr	r4, [pc, #8]	; (537c <m2m_wifi_connect+0x18>)
    5374:	47a0      	blx	r4
}
    5376:	b003      	add	sp, #12
    5378:	bd30      	pop	{r4, r5, pc}
    537a:	46c0      	nop			; (mov r8, r8)
    537c:	000050e1 	.word	0x000050e1

00005380 <m2m_wifi_request_dhcp_client>:

sint8 m2m_wifi_request_dhcp_client(void)
{
	/*legacy API should be removed */
	return 0;
}
    5380:	2000      	movs	r0, #0
    5382:	4770      	bx	lr

00005384 <m2m_wifi_enable_ap>:
	sint8 ret = M2M_SUCCESS;
	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DISABLE_P2P, NULL, 0, NULL, 0, 0);
	return ret;
}
sint8 m2m_wifi_enable_ap(CONST tstrM2MAPConfig* pstrM2MAPConfig)
{
    5384:	b510      	push	{r4, lr}
    5386:	b084      	sub	sp, #16
    5388:	0004      	movs	r4, r0
	sint8 ret = M2M_ERR_FAIL;
	if(M2M_SUCCESS == m2m_validate_ap_parameters(pstrM2MAPConfig))
    538a:	4b09      	ldr	r3, [pc, #36]	; (53b0 <m2m_wifi_enable_ap+0x2c>)
    538c:	4798      	blx	r3
    538e:	2800      	cmp	r0, #0
    5390:	d10a      	bne.n	53a8 <m2m_wifi_enable_ap+0x24>
	{
		ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_ENABLE_AP, (uint8 *)pstrM2MAPConfig, sizeof(tstrM2MAPConfig), NULL, 0, 0);	
    5392:	2300      	movs	r3, #0
    5394:	9302      	str	r3, [sp, #8]
    5396:	9301      	str	r3, [sp, #4]
    5398:	9300      	str	r3, [sp, #0]
    539a:	3388      	adds	r3, #136	; 0x88
    539c:	0022      	movs	r2, r4
    539e:	2146      	movs	r1, #70	; 0x46
    53a0:	3001      	adds	r0, #1
    53a2:	4c04      	ldr	r4, [pc, #16]	; (53b4 <m2m_wifi_enable_ap+0x30>)
    53a4:	47a0      	blx	r4
    53a6:	e001      	b.n	53ac <m2m_wifi_enable_ap+0x28>
	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DISABLE_P2P, NULL, 0, NULL, 0, 0);
	return ret;
}
sint8 m2m_wifi_enable_ap(CONST tstrM2MAPConfig* pstrM2MAPConfig)
{
	sint8 ret = M2M_ERR_FAIL;
    53a8:	200c      	movs	r0, #12
    53aa:	4240      	negs	r0, r0
	if(M2M_SUCCESS == m2m_validate_ap_parameters(pstrM2MAPConfig))
	{
		ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_ENABLE_AP, (uint8 *)pstrM2MAPConfig, sizeof(tstrM2MAPConfig), NULL, 0, 0);	
	}
	return ret;
}
    53ac:	b004      	add	sp, #16
    53ae:	bd10      	pop	{r4, pc}
    53b0:	00004dd1 	.word	0x00004dd1
    53b4:	0000437d 	.word	0x0000437d

000053b8 <m2m_wifi_disable_ap>:
		ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_GAINS, (uint8 *)pstrM2mGain, sizeof(tstrM2mWifiGainsParams), NULL, 0, 0);	
	}
	return ret;
}
sint8 m2m_wifi_disable_ap(void)
{
    53b8:	b510      	push	{r4, lr}
    53ba:	b084      	sub	sp, #16
	sint8 ret = M2M_SUCCESS;
	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DISABLE_AP, NULL, 0, NULL, 0, 0);
    53bc:	2300      	movs	r3, #0
    53be:	9302      	str	r3, [sp, #8]
    53c0:	9301      	str	r3, [sp, #4]
    53c2:	9300      	str	r3, [sp, #0]
    53c4:	2200      	movs	r2, #0
    53c6:	2147      	movs	r1, #71	; 0x47
    53c8:	2001      	movs	r0, #1
    53ca:	4c02      	ldr	r4, [pc, #8]	; (53d4 <m2m_wifi_disable_ap+0x1c>)
    53cc:	47a0      	blx	r4
	return ret;
}
    53ce:	b004      	add	sp, #16
    53d0:	bd10      	pop	{r4, pc}
    53d2:	46c0      	nop			; (mov r8, r8)
    53d4:	0000437d 	.word	0x0000437d

000053d8 <m2m_wifi_get_mac_address>:
@return      The function shall return M2M_SUCCESS for success and a negative value otherwise.
@sa          m2m_wifi_get_otp_mac_address             
@pre         m2m_wifi_init required to call any WIFI/socket function
*/
sint8 m2m_wifi_get_mac_address(uint8 *pu8MacAddr)
{
    53d8:	b510      	push	{r4, lr}
    53da:	0004      	movs	r4, r0
	sint8 ret = M2M_SUCCESS;
	ret = hif_chip_wake();
    53dc:	4b05      	ldr	r3, [pc, #20]	; (53f4 <m2m_wifi_get_mac_address+0x1c>)
    53de:	4798      	blx	r3
	if(ret == M2M_SUCCESS)
    53e0:	2800      	cmp	r0, #0
    53e2:	d106      	bne.n	53f2 <m2m_wifi_get_mac_address+0x1a>
	{
		ret = nmi_get_mac_address(pu8MacAddr);
    53e4:	0020      	movs	r0, r4
    53e6:	4b04      	ldr	r3, [pc, #16]	; (53f8 <m2m_wifi_get_mac_address+0x20>)
    53e8:	4798      	blx	r3
		if(ret == M2M_SUCCESS)
    53ea:	2800      	cmp	r0, #0
    53ec:	d101      	bne.n	53f2 <m2m_wifi_get_mac_address+0x1a>
		{
			ret = hif_chip_sleep();
    53ee:	4b03      	ldr	r3, [pc, #12]	; (53fc <m2m_wifi_get_mac_address+0x24>)
    53f0:	4798      	blx	r3
		}
	}

	return ret;
}
    53f2:	bd10      	pop	{r4, pc}
    53f4:	000042f1 	.word	0x000042f1
    53f8:	000058c9 	.word	0x000058c9
    53fc:	00004349 	.word	0x00004349

00005400 <m2m_wifi_get_sytem_time>:
 * @note         get the system time from the sntp client
 *		         using the API \ref m2m_wifi_get_sytem_time.
 * @return        The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
sint8 m2m_wifi_get_sytem_time(void)
{
    5400:	b510      	push	{r4, lr}
    5402:	b084      	sub	sp, #16
	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_GET_SYS_TIME, NULL,0, NULL, 0, 0);
    5404:	2300      	movs	r3, #0
    5406:	9302      	str	r3, [sp, #8]
    5408:	9301      	str	r3, [sp, #4]
    540a:	9300      	str	r3, [sp, #0]
    540c:	2200      	movs	r2, #0
    540e:	211a      	movs	r1, #26
    5410:	2001      	movs	r0, #1
    5412:	4c02      	ldr	r4, [pc, #8]	; (541c <m2m_wifi_get_sytem_time+0x1c>)
    5414:	47a0      	blx	r4
}
    5416:	b004      	add	sp, #16
    5418:	bd10      	pop	{r4, pc}
    541a:	46c0      	nop			; (mov r8, r8)
    541c:	0000437d 	.word	0x0000437d

00005420 <chip_apply_conf>:

#define TIMEOUT						(0xfffffffful)
#define WAKUP_TRAILS_TIMEOUT		(4)

sint8 chip_apply_conf(uint32 u32Conf)
{
    5420:	b5f0      	push	{r4, r5, r6, r7, lr}
    5422:	b083      	sub	sp, #12
#endif
#ifdef __DISABLE_FIRMWARE_LOGS__
	val32 |= rHAVE_LOGS_DISABLED_BIT;
#endif

	val32 |= rHAVE_RESERVED1_BIT;
    5424:	2580      	movs	r5, #128	; 0x80
    5426:	006d      	lsls	r5, r5, #1
    5428:	4305      	orrs	r5, r0
	do  {
		nm_write_reg(rNMI_GP_REG_1, val32);
    542a:	24a5      	movs	r4, #165	; 0xa5
    542c:	0164      	lsls	r4, r4, #5
    542e:	4f08      	ldr	r7, [pc, #32]	; (5450 <chip_apply_conf+0x30>)
		if(val32 != 0) {		
			uint32 reg = 0;
			ret = nm_read_reg_with_ret(rNMI_GP_REG_1, &reg);
    5430:	4e08      	ldr	r6, [pc, #32]	; (5454 <chip_apply_conf+0x34>)
	val32 |= rHAVE_LOGS_DISABLED_BIT;
#endif

	val32 |= rHAVE_RESERVED1_BIT;
	do  {
		nm_write_reg(rNMI_GP_REG_1, val32);
    5432:	0029      	movs	r1, r5
    5434:	0020      	movs	r0, r4
    5436:	47b8      	blx	r7
		if(val32 != 0) {		
			uint32 reg = 0;
    5438:	2300      	movs	r3, #0
    543a:	9301      	str	r3, [sp, #4]
			ret = nm_read_reg_with_ret(rNMI_GP_REG_1, &reg);
    543c:	a901      	add	r1, sp, #4
    543e:	0020      	movs	r0, r4
    5440:	47b0      	blx	r6
			if(ret == M2M_SUCCESS) {
    5442:	2800      	cmp	r0, #0
    5444:	d1f5      	bne.n	5432 <chip_apply_conf+0x12>
				if(reg == val32)
    5446:	9b01      	ldr	r3, [sp, #4]
    5448:	429d      	cmp	r5, r3
    544a:	d1f2      	bne.n	5432 <chip_apply_conf+0x12>
			break;
		}
	} while(1);

	return M2M_SUCCESS;
}
    544c:	b003      	add	sp, #12
    544e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5450:	00005971 	.word	0x00005971
    5454:	00005965 	.word	0x00005965

00005458 <enable_interrupts>:
		nm_write_reg(WAKE_CLK_REG, reg);
	}
}

sint8 enable_interrupts(void)
{
    5458:	b500      	push	{lr}
    545a:	b083      	sub	sp, #12
	uint32 reg = 0;
    545c:	2300      	movs	r3, #0
    545e:	9301      	str	r3, [sp, #4]
	sint8 ret = M2M_SUCCESS;
	/**
	interrupt pin mux select
	**/
	ret = nm_read_reg_with_ret(NMI_PIN_MUX_0, &reg);
    5460:	a901      	add	r1, sp, #4
    5462:	4810      	ldr	r0, [pc, #64]	; (54a4 <enable_interrupts+0x4c>)
    5464:	4b10      	ldr	r3, [pc, #64]	; (54a8 <enable_interrupts+0x50>)
    5466:	4798      	blx	r3
	if (M2M_SUCCESS != ret) goto ERR1;
    5468:	2800      	cmp	r0, #0
    546a:	d119      	bne.n	54a0 <enable_interrupts+0x48>
	
	reg |= ((uint32) 1 << 8);
    546c:	2180      	movs	r1, #128	; 0x80
    546e:	0049      	lsls	r1, r1, #1
    5470:	9b01      	ldr	r3, [sp, #4]
    5472:	4319      	orrs	r1, r3
    5474:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_PIN_MUX_0, reg);
    5476:	480b      	ldr	r0, [pc, #44]	; (54a4 <enable_interrupts+0x4c>)
    5478:	4b0c      	ldr	r3, [pc, #48]	; (54ac <enable_interrupts+0x54>)
    547a:	4798      	blx	r3
	if (M2M_SUCCESS != ret) goto ERR1;
    547c:	2800      	cmp	r0, #0
    547e:	d10f      	bne.n	54a0 <enable_interrupts+0x48>
	
	/**
	interrupt enable
	**/
	ret = nm_read_reg_with_ret(NMI_INTR_ENABLE, &reg);
    5480:	a901      	add	r1, sp, #4
    5482:	20d0      	movs	r0, #208	; 0xd0
    5484:	0140      	lsls	r0, r0, #5
    5486:	4b08      	ldr	r3, [pc, #32]	; (54a8 <enable_interrupts+0x50>)
    5488:	4798      	blx	r3
	if (M2M_SUCCESS != ret) goto ERR1;
    548a:	2800      	cmp	r0, #0
    548c:	d108      	bne.n	54a0 <enable_interrupts+0x48>
	
	reg |= ((uint32) 1 << 16);
    548e:	2180      	movs	r1, #128	; 0x80
    5490:	0249      	lsls	r1, r1, #9
    5492:	9b01      	ldr	r3, [sp, #4]
    5494:	4319      	orrs	r1, r3
    5496:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_INTR_ENABLE, reg);
    5498:	20d0      	movs	r0, #208	; 0xd0
    549a:	0140      	lsls	r0, r0, #5
    549c:	4b03      	ldr	r3, [pc, #12]	; (54ac <enable_interrupts+0x54>)
    549e:	4798      	blx	r3
	if (M2M_SUCCESS != ret) goto ERR1;
ERR1:	
	return ret;
}
    54a0:	b003      	add	sp, #12
    54a2:	bd00      	pop	{pc}
    54a4:	00001408 	.word	0x00001408
    54a8:	00005965 	.word	0x00005965
    54ac:	00005971 	.word	0x00005971

000054b0 <nmi_get_chipid>:
	nm_bsp_sleep(1);
	return ret;
}

uint32 nmi_get_chipid(void)
{
    54b0:	b510      	push	{r4, lr}
    54b2:	b082      	sub	sp, #8
	static uint32 chipid = 0;

	if (chipid == 0) {
    54b4:	4b27      	ldr	r3, [pc, #156]	; (5554 <nmi_get_chipid+0xa4>)
    54b6:	681c      	ldr	r4, [r3, #0]
    54b8:	2c00      	cmp	r4, #0
    54ba:	d146      	bne.n	554a <nmi_get_chipid+0x9a>
		uint32 rfrevid;
		
		if((nm_read_reg_with_ret(0x1000, &chipid)) != M2M_SUCCESS) {
    54bc:	0019      	movs	r1, r3
    54be:	2080      	movs	r0, #128	; 0x80
    54c0:	0140      	lsls	r0, r0, #5
    54c2:	4b25      	ldr	r3, [pc, #148]	; (5558 <nmi_get_chipid+0xa8>)
    54c4:	4798      	blx	r3
    54c6:	2800      	cmp	r0, #0
    54c8:	d003      	beq.n	54d2 <nmi_get_chipid+0x22>
			chipid = 0;
    54ca:	2200      	movs	r2, #0
    54cc:	4b21      	ldr	r3, [pc, #132]	; (5554 <nmi_get_chipid+0xa4>)
    54ce:	601a      	str	r2, [r3, #0]
			return 0;
    54d0:	e03d      	b.n	554e <nmi_get_chipid+0x9e>
		}
		//if((ret = nm_read_reg_with_ret(0x11fc, &revid)) != M2M_SUCCESS) {
		//	return 0;
		//}
		if((nm_read_reg_with_ret(0x13f4, &rfrevid)) != M2M_SUCCESS) {
    54d2:	a901      	add	r1, sp, #4
    54d4:	4821      	ldr	r0, [pc, #132]	; (555c <nmi_get_chipid+0xac>)
    54d6:	4b20      	ldr	r3, [pc, #128]	; (5558 <nmi_get_chipid+0xa8>)
    54d8:	4798      	blx	r3
    54da:	2800      	cmp	r0, #0
    54dc:	d003      	beq.n	54e6 <nmi_get_chipid+0x36>
			chipid = 0;
    54de:	2200      	movs	r2, #0
    54e0:	4b1c      	ldr	r3, [pc, #112]	; (5554 <nmi_get_chipid+0xa4>)
    54e2:	601a      	str	r2, [r3, #0]
			return 0;
    54e4:	e033      	b.n	554e <nmi_get_chipid+0x9e>
		}

		if (chipid == 0x1002a0)  {
    54e6:	4b1b      	ldr	r3, [pc, #108]	; (5554 <nmi_get_chipid+0xa4>)
    54e8:	681b      	ldr	r3, [r3, #0]
    54ea:	4a1d      	ldr	r2, [pc, #116]	; (5560 <nmi_get_chipid+0xb0>)
    54ec:	4293      	cmp	r3, r2
    54ee:	d106      	bne.n	54fe <nmi_get_chipid+0x4e>
			if (rfrevid == 0x1) { /* 1002A0 */
    54f0:	9b01      	ldr	r3, [sp, #4]
    54f2:	2b01      	cmp	r3, #1
    54f4:	d021      	beq.n	553a <nmi_get_chipid+0x8a>
			} else /* if (rfrevid == 0x2) */ { /* 1002A1 */
				chipid = 0x1002a1;
    54f6:	4a1b      	ldr	r2, [pc, #108]	; (5564 <nmi_get_chipid+0xb4>)
    54f8:	4b16      	ldr	r3, [pc, #88]	; (5554 <nmi_get_chipid+0xa4>)
    54fa:	601a      	str	r2, [r3, #0]
    54fc:	e01d      	b.n	553a <nmi_get_chipid+0x8a>
			}
		} else if(chipid == 0x1002b0) {
    54fe:	4a1a      	ldr	r2, [pc, #104]	; (5568 <nmi_get_chipid+0xb8>)
    5500:	4293      	cmp	r3, r2
    5502:	d10c      	bne.n	551e <nmi_get_chipid+0x6e>
			if(rfrevid == 3) { /* 1002B0 */
    5504:	9b01      	ldr	r3, [sp, #4]
    5506:	2b03      	cmp	r3, #3
    5508:	d017      	beq.n	553a <nmi_get_chipid+0x8a>
			} else if(rfrevid == 4) { /* 1002B1 */
    550a:	2b04      	cmp	r3, #4
    550c:	d103      	bne.n	5516 <nmi_get_chipid+0x66>
				chipid = 0x1002b1;
    550e:	4a17      	ldr	r2, [pc, #92]	; (556c <nmi_get_chipid+0xbc>)
    5510:	4b10      	ldr	r3, [pc, #64]	; (5554 <nmi_get_chipid+0xa4>)
    5512:	601a      	str	r2, [r3, #0]
    5514:	e011      	b.n	553a <nmi_get_chipid+0x8a>
			} else /* if(rfrevid == 5) */ { /* 1002B2 */
				chipid = 0x1002b2;
    5516:	4a16      	ldr	r2, [pc, #88]	; (5570 <nmi_get_chipid+0xc0>)
    5518:	4b0e      	ldr	r3, [pc, #56]	; (5554 <nmi_get_chipid+0xa4>)
    551a:	601a      	str	r2, [r3, #0]
    551c:	e00d      	b.n	553a <nmi_get_chipid+0x8a>
			}
		}else if(chipid == 0x1000F0) { 
    551e:	4a15      	ldr	r2, [pc, #84]	; (5574 <nmi_get_chipid+0xc4>)
    5520:	4293      	cmp	r3, r2
    5522:	d10a      	bne.n	553a <nmi_get_chipid+0x8a>
			if((nm_read_reg_with_ret(0x3B0000, &chipid)) != M2M_SUCCESS) {
    5524:	490b      	ldr	r1, [pc, #44]	; (5554 <nmi_get_chipid+0xa4>)
    5526:	20ec      	movs	r0, #236	; 0xec
    5528:	0380      	lsls	r0, r0, #14
    552a:	4b0b      	ldr	r3, [pc, #44]	; (5558 <nmi_get_chipid+0xa8>)
    552c:	4798      	blx	r3
    552e:	2800      	cmp	r0, #0
    5530:	d003      	beq.n	553a <nmi_get_chipid+0x8a>
			chipid = 0;
    5532:	2200      	movs	r2, #0
    5534:	4b07      	ldr	r3, [pc, #28]	; (5554 <nmi_get_chipid+0xa4>)
    5536:	601a      	str	r2, [r3, #0]
			return 0;
    5538:	e009      	b.n	554e <nmi_get_chipid+0x9e>
			}
		}
#else
		/*M2M is by default have SPI flash*/
		chipid &= ~(0x0f0000);
		chipid |= 0x050000;
    553a:	4a06      	ldr	r2, [pc, #24]	; (5554 <nmi_get_chipid+0xa4>)
    553c:	4b0e      	ldr	r3, [pc, #56]	; (5578 <nmi_get_chipid+0xc8>)
    553e:	6811      	ldr	r1, [r2, #0]
    5540:	400b      	ands	r3, r1
    5542:	21a0      	movs	r1, #160	; 0xa0
    5544:	02c9      	lsls	r1, r1, #11
    5546:	430b      	orrs	r3, r1
    5548:	6013      	str	r3, [r2, #0]
#endif /* PROBE_FLASH */
	}
	return chipid;
    554a:	4b02      	ldr	r3, [pc, #8]	; (5554 <nmi_get_chipid+0xa4>)
    554c:	681c      	ldr	r4, [r3, #0]
}
    554e:	0020      	movs	r0, r4
    5550:	b002      	add	sp, #8
    5552:	bd10      	pop	{r4, pc}
    5554:	200008d4 	.word	0x200008d4
    5558:	00005965 	.word	0x00005965
    555c:	000013f4 	.word	0x000013f4
    5560:	001002a0 	.word	0x001002a0
    5564:	001002a1 	.word	0x001002a1
    5568:	001002b0 	.word	0x001002b0
    556c:	001002b1 	.word	0x001002b1
    5570:	001002b2 	.word	0x001002b2
    5574:	001000f0 	.word	0x001000f0
    5578:	fff0ffff 	.word	0xfff0ffff

0000557c <chip_sleep>:

	/* Do PLL update */
	nmi_update_pll();
}
sint8 chip_sleep(void)
{
    557c:	b530      	push	{r4, r5, lr}
    557e:	b083      	sub	sp, #12
	uint32 reg;
	sint8 ret = M2M_SUCCESS;
	
	while(1)
	{
		ret = nm_read_reg_with_ret(CORT_HOST_COMM,&reg);
    5580:	4c15      	ldr	r4, [pc, #84]	; (55d8 <chip_sleep+0x5c>)
		if(ret != M2M_SUCCESS) goto ERR1;
		if((reg & NBIT0) == 0) break;
    5582:	2501      	movs	r5, #1
	uint32 reg;
	sint8 ret = M2M_SUCCESS;
	
	while(1)
	{
		ret = nm_read_reg_with_ret(CORT_HOST_COMM,&reg);
    5584:	a901      	add	r1, sp, #4
    5586:	2010      	movs	r0, #16
    5588:	47a0      	blx	r4
		if(ret != M2M_SUCCESS) goto ERR1;
    558a:	2800      	cmp	r0, #0
    558c:	d122      	bne.n	55d4 <chip_sleep+0x58>
		if((reg & NBIT0) == 0) break;
    558e:	9b01      	ldr	r3, [sp, #4]
    5590:	422b      	tst	r3, r5
    5592:	d1f7      	bne.n	5584 <chip_sleep+0x8>
	}
	
	/* Clear bit 1 */
	ret = nm_read_reg_with_ret(WAKE_CLK_REG, &reg);
    5594:	a901      	add	r1, sp, #4
    5596:	3001      	adds	r0, #1
    5598:	4b0f      	ldr	r3, [pc, #60]	; (55d8 <chip_sleep+0x5c>)
    559a:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
    559c:	2800      	cmp	r0, #0
    559e:	d119      	bne.n	55d4 <chip_sleep+0x58>
	if(reg & NBIT1)
    55a0:	9901      	ldr	r1, [sp, #4]
    55a2:	078b      	lsls	r3, r1, #30
    55a4:	d507      	bpl.n	55b6 <chip_sleep+0x3a>
	{
		reg &=~NBIT1;
    55a6:	2302      	movs	r3, #2
    55a8:	4399      	bics	r1, r3
    55aa:	9101      	str	r1, [sp, #4]
		ret = nm_write_reg(WAKE_CLK_REG, reg);
    55ac:	3001      	adds	r0, #1
    55ae:	4b0b      	ldr	r3, [pc, #44]	; (55dc <chip_sleep+0x60>)
    55b0:	4798      	blx	r3
		if(ret != M2M_SUCCESS)goto ERR1;
    55b2:	2800      	cmp	r0, #0
    55b4:	d10e      	bne.n	55d4 <chip_sleep+0x58>
	}
	
	ret = nm_read_reg_with_ret(HOST_CORT_COMM, &reg);
    55b6:	a901      	add	r1, sp, #4
    55b8:	200b      	movs	r0, #11
    55ba:	4b07      	ldr	r3, [pc, #28]	; (55d8 <chip_sleep+0x5c>)
    55bc:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
    55be:	2800      	cmp	r0, #0
    55c0:	d108      	bne.n	55d4 <chip_sleep+0x58>
	if(reg & NBIT0)
    55c2:	9901      	ldr	r1, [sp, #4]
    55c4:	07cb      	lsls	r3, r1, #31
    55c6:	d505      	bpl.n	55d4 <chip_sleep+0x58>
	{
		reg &= ~NBIT0;
    55c8:	2301      	movs	r3, #1
    55ca:	4399      	bics	r1, r3
    55cc:	9101      	str	r1, [sp, #4]
		ret = nm_write_reg(HOST_CORT_COMM, reg);
    55ce:	300b      	adds	r0, #11
    55d0:	4b02      	ldr	r3, [pc, #8]	; (55dc <chip_sleep+0x60>)
    55d2:	4798      	blx	r3
		if(ret != M2M_SUCCESS)goto ERR1;
	}

ERR1:
	return ret;
}
    55d4:	b003      	add	sp, #12
    55d6:	bd30      	pop	{r4, r5, pc}
    55d8:	00005965 	.word	0x00005965
    55dc:	00005971 	.word	0x00005971

000055e0 <chip_wake>:
sint8 chip_wake(void)
{
    55e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    55e2:	b083      	sub	sp, #12
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, clk_status_reg = 0,trials = 0;
    55e4:	2300      	movs	r3, #0
    55e6:	9301      	str	r3, [sp, #4]
    55e8:	9300      	str	r3, [sp, #0]

	ret = nm_read_reg_with_ret(HOST_CORT_COMM, &reg);
    55ea:	a901      	add	r1, sp, #4
    55ec:	200b      	movs	r0, #11
    55ee:	4b28      	ldr	r3, [pc, #160]	; (5690 <chip_wake+0xb0>)
    55f0:	4798      	blx	r3
    55f2:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
    55f4:	d148      	bne.n	5688 <chip_wake+0xa8>
	
	if(!(reg & NBIT0))
    55f6:	9901      	ldr	r1, [sp, #4]
    55f8:	07cb      	lsls	r3, r1, #31
    55fa:	d406      	bmi.n	560a <chip_wake+0x2a>
	{
		/*USE bit 0 to indicate host wakeup*/
		ret = nm_write_reg(HOST_CORT_COMM, reg|NBIT0);
    55fc:	2301      	movs	r3, #1
    55fe:	4319      	orrs	r1, r3
    5600:	200b      	movs	r0, #11
    5602:	4b24      	ldr	r3, [pc, #144]	; (5694 <chip_wake+0xb4>)
    5604:	4798      	blx	r3
    5606:	1e04      	subs	r4, r0, #0
		if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
    5608:	d13e      	bne.n	5688 <chip_wake+0xa8>
	}
		
	ret = nm_read_reg_with_ret(WAKE_CLK_REG, &reg);
    560a:	a901      	add	r1, sp, #4
    560c:	2001      	movs	r0, #1
    560e:	4b20      	ldr	r3, [pc, #128]	; (5690 <chip_wake+0xb0>)
    5610:	4798      	blx	r3
    5612:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
    5614:	d138      	bne.n	5688 <chip_wake+0xa8>
	/* Set bit 1 */
	if(!(reg & NBIT1))
    5616:	9901      	ldr	r1, [sp, #4]
    5618:	078b      	lsls	r3, r1, #30
    561a:	d406      	bmi.n	562a <chip_wake+0x4a>
	{
		ret = nm_write_reg(WAKE_CLK_REG, reg | NBIT1);
    561c:	2302      	movs	r3, #2
    561e:	4319      	orrs	r1, r3
    5620:	2001      	movs	r0, #1
    5622:	4b1c      	ldr	r3, [pc, #112]	; (5694 <chip_wake+0xb4>)
    5624:	4798      	blx	r3
    5626:	1e04      	subs	r4, r0, #0
		if(ret != M2M_SUCCESS) goto _WAKE_EXIT;	
    5628:	d12e      	bne.n	5688 <chip_wake+0xa8>

ERR1:
	return ret;
}
sint8 chip_wake(void)
{
    562a:	2505      	movs	r5, #5
		if(ret != M2M_SUCCESS) goto _WAKE_EXIT;	
	}

	do
	{
		ret = nm_read_reg_with_ret(CLOCKS_EN_REG, &clk_status_reg);
    562c:	4f18      	ldr	r7, [pc, #96]	; (5690 <chip_wake+0xb0>)
			goto _WAKE_EXIT;
		}
		if(clk_status_reg & NBIT2) {
			break;
		}
		nm_bsp_sleep(2);
    562e:	4e1a      	ldr	r6, [pc, #104]	; (5698 <chip_wake+0xb8>)
		if(ret != M2M_SUCCESS) goto _WAKE_EXIT;	
	}

	do
	{
		ret = nm_read_reg_with_ret(CLOCKS_EN_REG, &clk_status_reg);
    5630:	4669      	mov	r1, sp
    5632:	200f      	movs	r0, #15
    5634:	47b8      	blx	r7
    5636:	1e04      	subs	r4, r0, #0
		if(ret != M2M_SUCCESS) {
    5638:	d00d      	beq.n	5656 <chip_wake+0x76>
			M2M_ERR("Bus error (5).%d %lx\n",ret,clk_status_reg);
    563a:	22aa      	movs	r2, #170	; 0xaa
    563c:	0052      	lsls	r2, r2, #1
    563e:	4917      	ldr	r1, [pc, #92]	; (569c <chip_wake+0xbc>)
    5640:	4817      	ldr	r0, [pc, #92]	; (56a0 <chip_wake+0xc0>)
    5642:	4d18      	ldr	r5, [pc, #96]	; (56a4 <chip_wake+0xc4>)
    5644:	47a8      	blx	r5
    5646:	9a00      	ldr	r2, [sp, #0]
    5648:	0021      	movs	r1, r4
    564a:	4817      	ldr	r0, [pc, #92]	; (56a8 <chip_wake+0xc8>)
    564c:	47a8      	blx	r5
    564e:	200d      	movs	r0, #13
    5650:	4b16      	ldr	r3, [pc, #88]	; (56ac <chip_wake+0xcc>)
    5652:	4798      	blx	r3
			goto _WAKE_EXIT;
    5654:	e018      	b.n	5688 <chip_wake+0xa8>
		}
		if(clk_status_reg & NBIT2) {
    5656:	9b00      	ldr	r3, [sp, #0]
    5658:	075b      	lsls	r3, r3, #29
    565a:	d413      	bmi.n	5684 <chip_wake+0xa4>
			break;
		}
		nm_bsp_sleep(2);
    565c:	2002      	movs	r0, #2
    565e:	47b0      	blx	r6
    5660:	3d01      	subs	r5, #1
		trials++;
		if(trials > WAKUP_TRAILS_TIMEOUT)
    5662:	2d00      	cmp	r5, #0
    5664:	d1e4      	bne.n	5630 <chip_wake+0x50>
		{
			M2M_ERR("Failed to wakup the chip\n");
    5666:	22af      	movs	r2, #175	; 0xaf
    5668:	0052      	lsls	r2, r2, #1
    566a:	490c      	ldr	r1, [pc, #48]	; (569c <chip_wake+0xbc>)
    566c:	480c      	ldr	r0, [pc, #48]	; (56a0 <chip_wake+0xc0>)
    566e:	4b0d      	ldr	r3, [pc, #52]	; (56a4 <chip_wake+0xc4>)
    5670:	4798      	blx	r3
    5672:	480f      	ldr	r0, [pc, #60]	; (56b0 <chip_wake+0xd0>)
    5674:	4b0f      	ldr	r3, [pc, #60]	; (56b4 <chip_wake+0xd4>)
    5676:	4798      	blx	r3
    5678:	200d      	movs	r0, #13
    567a:	4b0c      	ldr	r3, [pc, #48]	; (56ac <chip_wake+0xcc>)
    567c:	4798      	blx	r3
			ret = M2M_ERR_TIME_OUT;
    567e:	2404      	movs	r4, #4
    5680:	4264      	negs	r4, r4
			goto _WAKE_EXIT;
    5682:	e001      	b.n	5688 <chip_wake+0xa8>
		}
	}while(1);
	
	/*workaround sometimes spi fail to read clock regs after reading/writing clockless registers*/
	nm_bus_reset();
    5684:	4b0c      	ldr	r3, [pc, #48]	; (56b8 <chip_wake+0xd8>)
    5686:	4798      	blx	r3
	
_WAKE_EXIT:
	return ret;
}
    5688:	0020      	movs	r0, r4
    568a:	b003      	add	sp, #12
    568c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    568e:	46c0      	nop			; (mov r8, r8)
    5690:	00005965 	.word	0x00005965
    5694:	00005971 	.word	0x00005971
    5698:	00003e6d 	.word	0x00003e6d
    569c:	00014900 	.word	0x00014900
    56a0:	00014144 	.word	0x00014144
    56a4:	0001198d 	.word	0x0001198d
    56a8:	00014890 	.word	0x00014890
    56ac:	000119c1 	.word	0x000119c1
    56b0:	000148a8 	.word	0x000148a8
    56b4:	00011aad 	.word	0x00011aad
    56b8:	0000594d 	.word	0x0000594d

000056bc <wait_for_bootrom>:
	nm_bsp_sleep(50);
	return ret;
}

sint8 wait_for_bootrom(uint8 arg)
{
    56bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    56be:	0007      	movs	r7, r0
				M2M_RELEASE_VERSION_PATCH_NO);


	reg = 0;
	while(1) {
		reg = nm_read_reg(0x1014);	/* wait for efuse loading done */
    56c0:	4d2d      	ldr	r5, [pc, #180]	; (5778 <wait_for_bootrom+0xbc>)
    56c2:	4c2e      	ldr	r4, [pc, #184]	; (577c <wait_for_bootrom+0xc0>)
		if (reg & 0x80000000) {
			break;
		}
		nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
    56c4:	4e2e      	ldr	r6, [pc, #184]	; (5780 <wait_for_bootrom+0xc4>)
				M2M_RELEASE_VERSION_PATCH_NO);


	reg = 0;
	while(1) {
		reg = nm_read_reg(0x1014);	/* wait for efuse loading done */
    56c6:	0028      	movs	r0, r5
    56c8:	47a0      	blx	r4
		if (reg & 0x80000000) {
    56ca:	2800      	cmp	r0, #0
    56cc:	db02      	blt.n	56d4 <wait_for_bootrom+0x18>
			break;
		}
		nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
    56ce:	2001      	movs	r0, #1
    56d0:	47b0      	blx	r6
	}
    56d2:	e7f8      	b.n	56c6 <wait_for_bootrom+0xa>
	reg = nm_read_reg(M2M_WAIT_FOR_HOST_REG);
    56d4:	482b      	ldr	r0, [pc, #172]	; (5784 <wait_for_bootrom+0xc8>)
    56d6:	4b29      	ldr	r3, [pc, #164]	; (577c <wait_for_bootrom+0xc0>)
    56d8:	4798      	blx	r3
	reg &= 0x1;

	/* check if waiting for the host will be skipped or not */
	if(reg == 0)
    56da:	07c3      	lsls	r3, r0, #31
    56dc:	d409      	bmi.n	56f2 <wait_for_bootrom+0x36>
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
		{
			nm_bsp_sleep(1);
    56de:	4e28      	ldr	r6, [pc, #160]	; (5780 <wait_for_bootrom+0xc4>)
			reg = nm_read_reg(BOOTROM_REG);
    56e0:	4c29      	ldr	r4, [pc, #164]	; (5788 <wait_for_bootrom+0xcc>)
    56e2:	4d26      	ldr	r5, [pc, #152]	; (577c <wait_for_bootrom+0xc0>)
	if(reg == 0)
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
		{
			nm_bsp_sleep(1);
    56e4:	2001      	movs	r0, #1
    56e6:	47b0      	blx	r6
			reg = nm_read_reg(BOOTROM_REG);
    56e8:	0020      	movs	r0, r4
    56ea:	47a8      	blx	r5

	/* check if waiting for the host will be skipped or not */
	if(reg == 0)
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
    56ec:	4b27      	ldr	r3, [pc, #156]	; (578c <wait_for_bootrom+0xd0>)
    56ee:	4298      	cmp	r0, r3
    56f0:	d1f8      	bne.n	56e4 <wait_for_bootrom+0x28>
				goto ERR2;
			}
		}
	}
	
	if(M2M_WIFI_MODE_ATE_HIGH == arg) {
    56f2:	2f02      	cmp	r7, #2
    56f4:	d109      	bne.n	570a <wait_for_bootrom+0x4e>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
    56f6:	4926      	ldr	r1, [pc, #152]	; (5790 <wait_for_bootrom+0xd4>)
    56f8:	4826      	ldr	r0, [pc, #152]	; (5794 <wait_for_bootrom+0xd8>)
    56fa:	4c27      	ldr	r4, [pc, #156]	; (5798 <wait_for_bootrom+0xdc>)
    56fc:	47a0      	blx	r4
		nm_write_reg(NMI_STATE_REG, NBIT20);
    56fe:	2180      	movs	r1, #128	; 0x80
    5700:	0349      	lsls	r1, r1, #13
    5702:	4826      	ldr	r0, [pc, #152]	; (579c <wait_for_bootrom+0xe0>)
    5704:	47a0      	blx	r4

sint8 wait_for_bootrom(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32GpReg1 = 0;
    5706:	2400      	movs	r4, #0
    5708:	e017      	b.n	573a <wait_for_bootrom+0x7e>
	}
	
	if(M2M_WIFI_MODE_ATE_HIGH == arg) {
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
		nm_write_reg(NMI_STATE_REG, NBIT20);
	}else if(M2M_WIFI_MODE_ATE_LOW == arg) {
    570a:	2f03      	cmp	r7, #3
    570c:	d108      	bne.n	5720 <wait_for_bootrom+0x64>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
    570e:	4920      	ldr	r1, [pc, #128]	; (5790 <wait_for_bootrom+0xd4>)
    5710:	4820      	ldr	r0, [pc, #128]	; (5794 <wait_for_bootrom+0xd8>)
    5712:	4c21      	ldr	r4, [pc, #132]	; (5798 <wait_for_bootrom+0xdc>)
    5714:	47a0      	blx	r4
		nm_write_reg(NMI_STATE_REG, 0);
    5716:	2100      	movs	r1, #0
    5718:	4820      	ldr	r0, [pc, #128]	; (579c <wait_for_bootrom+0xe0>)
    571a:	47a0      	blx	r4

sint8 wait_for_bootrom(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32GpReg1 = 0;
    571c:	2400      	movs	r4, #0
    571e:	e00c      	b.n	573a <wait_for_bootrom+0x7e>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
		nm_write_reg(NMI_STATE_REG, NBIT20);
	}else if(M2M_WIFI_MODE_ATE_LOW == arg) {
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
		nm_write_reg(NMI_STATE_REG, 0);
	}else if(M2M_WIFI_MODE_ETHERNET == arg){
    5720:	2f04      	cmp	r7, #4
    5722:	d105      	bne.n	5730 <wait_for_bootrom+0x74>
		u32GpReg1 = rHAVE_ETHERNET_MODE_BIT;
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
    5724:	491e      	ldr	r1, [pc, #120]	; (57a0 <wait_for_bootrom+0xe4>)
    5726:	481d      	ldr	r0, [pc, #116]	; (579c <wait_for_bootrom+0xe0>)
    5728:	4b1b      	ldr	r3, [pc, #108]	; (5798 <wait_for_bootrom+0xdc>)
    572a:	4798      	blx	r3
		nm_write_reg(NMI_STATE_REG, NBIT20);
	}else if(M2M_WIFI_MODE_ATE_LOW == arg) {
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
		nm_write_reg(NMI_STATE_REG, 0);
	}else if(M2M_WIFI_MODE_ETHERNET == arg){
		u32GpReg1 = rHAVE_ETHERNET_MODE_BIT;
    572c:	2480      	movs	r4, #128	; 0x80
    572e:	e004      	b.n	573a <wait_for_bootrom+0x7e>
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
	} else {
		/*bypass this step*/
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
    5730:	491b      	ldr	r1, [pc, #108]	; (57a0 <wait_for_bootrom+0xe4>)
    5732:	481a      	ldr	r0, [pc, #104]	; (579c <wait_for_bootrom+0xe0>)
    5734:	4b18      	ldr	r3, [pc, #96]	; (5798 <wait_for_bootrom+0xdc>)
    5736:	4798      	blx	r3

sint8 wait_for_bootrom(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32GpReg1 = 0;
    5738:	2400      	movs	r4, #0
	} else {
		/*bypass this step*/
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
	}

	if(REV(nmi_get_chipid()) >= REV_3A0){
    573a:	4b1a      	ldr	r3, [pc, #104]	; (57a4 <wait_for_bootrom+0xe8>)
    573c:	4798      	blx	r3
    573e:	0500      	lsls	r0, r0, #20
    5740:	0d00      	lsrs	r0, r0, #20
    5742:	4b19      	ldr	r3, [pc, #100]	; (57a8 <wait_for_bootrom+0xec>)
    5744:	4298      	cmp	r0, r3
    5746:	d904      	bls.n	5752 <wait_for_bootrom+0x96>
		chip_apply_conf(u32GpReg1 | rHAVE_USE_PMU_BIT);
    5748:	2002      	movs	r0, #2
    574a:	4320      	orrs	r0, r4
    574c:	4b17      	ldr	r3, [pc, #92]	; (57ac <wait_for_bootrom+0xf0>)
    574e:	4798      	blx	r3
    5750:	e002      	b.n	5758 <wait_for_bootrom+0x9c>
	} else {
		chip_apply_conf(u32GpReg1);
    5752:	0020      	movs	r0, r4
    5754:	4b15      	ldr	r3, [pc, #84]	; (57ac <wait_for_bootrom+0xf0>)
    5756:	4798      	blx	r3
	}
	M2M_INFO("DriverVerInfo: 0x%08lx\n",u32DriverVerInfo);
    5758:	4815      	ldr	r0, [pc, #84]	; (57b0 <wait_for_bootrom+0xf4>)
    575a:	4c16      	ldr	r4, [pc, #88]	; (57b4 <wait_for_bootrom+0xf8>)
    575c:	47a0      	blx	r4
    575e:	4910      	ldr	r1, [pc, #64]	; (57a0 <wait_for_bootrom+0xe4>)
    5760:	4815      	ldr	r0, [pc, #84]	; (57b8 <wait_for_bootrom+0xfc>)
    5762:	47a0      	blx	r4
    5764:	200d      	movs	r0, #13
    5766:	4b15      	ldr	r3, [pc, #84]	; (57bc <wait_for_bootrom+0x100>)
    5768:	4798      	blx	r3

	nm_write_reg(BOOTROM_REG,M2M_START_FIRMWARE);
    576a:	4915      	ldr	r1, [pc, #84]	; (57c0 <wait_for_bootrom+0x104>)
    576c:	4806      	ldr	r0, [pc, #24]	; (5788 <wait_for_bootrom+0xcc>)
    576e:	4b0a      	ldr	r3, [pc, #40]	; (5798 <wait_for_bootrom+0xdc>)
    5770:	4798      	blx	r3
	rom_test();
#endif /* __ROM_TEST__ */

ERR2:
	return ret;
}
    5772:	2000      	movs	r0, #0
    5774:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5776:	46c0      	nop			; (mov r8, r8)
    5778:	00001014 	.word	0x00001014
    577c:	00005959 	.word	0x00005959
    5780:	00003e6d 	.word	0x00003e6d
    5784:	000207bc 	.word	0x000207bc
    5788:	000c000c 	.word	0x000c000c
    578c:	10add09e 	.word	0x10add09e
    5790:	3c1cd57d 	.word	0x3c1cd57d
    5794:	000207ac 	.word	0x000207ac
    5798:	00005971 	.word	0x00005971
    579c:	0000108c 	.word	0x0000108c
    57a0:	13521352 	.word	0x13521352
    57a4:	000054b1 	.word	0x000054b1
    57a8:	0000039f 	.word	0x0000039f
    57ac:	00005421 	.word	0x00005421
    57b0:	00013ca0 	.word	0x00013ca0
    57b4:	0001198d 	.word	0x0001198d
    57b8:	000148c4 	.word	0x000148c4
    57bc:	000119c1 	.word	0x000119c1
    57c0:	ef522f61 	.word	0xef522f61

000057c4 <wait_for_firmware_start>:

sint8 wait_for_firmware_start(uint8 arg)
{
    57c4:	b570      	push	{r4, r5, r6, lr}
    57c6:	b082      	sub	sp, #8
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32Timeout = TIMEOUT;
	volatile uint32 regAddress = NMI_STATE_REG;
    57c8:	4b15      	ldr	r3, [pc, #84]	; (5820 <wait_for_firmware_start+0x5c>)
    57ca:	9301      	str	r3, [sp, #4]
	volatile uint32 checkValue = M2M_FINISH_INIT_STATE;
    57cc:	4b15      	ldr	r3, [pc, #84]	; (5824 <wait_for_firmware_start+0x60>)
    57ce:	9300      	str	r3, [sp, #0]
	
	if((M2M_WIFI_MODE_ATE_HIGH == arg)||(M2M_WIFI_MODE_ATE_LOW == arg)) {
    57d0:	3802      	subs	r0, #2
    57d2:	2801      	cmp	r0, #1
    57d4:	d80c      	bhi.n	57f0 <wait_for_firmware_start+0x2c>
		regAddress = NMI_REV_REG;
    57d6:	4b14      	ldr	r3, [pc, #80]	; (5828 <wait_for_firmware_start+0x64>)
    57d8:	9301      	str	r3, [sp, #4]
		checkValue = M2M_ATE_FW_IS_UP_VALUE;
    57da:	4b14      	ldr	r3, [pc, #80]	; (582c <wait_for_firmware_start+0x68>)
    57dc:	9300      	str	r3, [sp, #0]
    57de:	e007      	b.n	57f0 <wait_for_firmware_start+0x2c>
	}
	
	
	while (checkValue != reg)
	{
		nm_bsp_sleep(2); /* TODO: Why bus error if this delay is not here. */
    57e0:	2002      	movs	r0, #2
    57e2:	47b0      	blx	r6
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
    57e4:	9801      	ldr	r0, [sp, #4]
    57e6:	47a8      	blx	r5
    57e8:	3c01      	subs	r4, #1
		if(++cnt >= u32Timeout)
    57ea:	2c00      	cmp	r4, #0
    57ec:	d105      	bne.n	57fa <wait_for_firmware_start+0x36>
    57ee:	e012      	b.n	5816 <wait_for_firmware_start+0x52>
ERR2:
	return ret;
}

sint8 wait_for_firmware_start(uint8 arg)
{
    57f0:	2401      	movs	r4, #1
    57f2:	4264      	negs	r4, r4
    57f4:	2000      	movs	r0, #0
	}
	
	
	while (checkValue != reg)
	{
		nm_bsp_sleep(2); /* TODO: Why bus error if this delay is not here. */
    57f6:	4e0e      	ldr	r6, [pc, #56]	; (5830 <wait_for_firmware_start+0x6c>)
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
    57f8:	4d0e      	ldr	r5, [pc, #56]	; (5834 <wait_for_firmware_start+0x70>)
	} else {
		/*bypass this step*/
	}
	
	
	while (checkValue != reg)
    57fa:	9b00      	ldr	r3, [sp, #0]
    57fc:	4298      	cmp	r0, r3
    57fe:	d1ef      	bne.n	57e0 <wait_for_firmware_start+0x1c>
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
			goto ERR;
		}
	}
	if(M2M_FINISH_INIT_STATE == checkValue)
    5800:	9a00      	ldr	r2, [sp, #0]
	return ret;
}

sint8 wait_for_firmware_start(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
    5802:	2000      	movs	r0, #0
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
			goto ERR;
		}
	}
	if(M2M_FINISH_INIT_STATE == checkValue)
    5804:	4b07      	ldr	r3, [pc, #28]	; (5824 <wait_for_firmware_start+0x60>)
    5806:	429a      	cmp	r2, r3
    5808:	d107      	bne.n	581a <wait_for_firmware_start+0x56>
	{
		nm_write_reg(NMI_STATE_REG, 0);
    580a:	2100      	movs	r1, #0
    580c:	4804      	ldr	r0, [pc, #16]	; (5820 <wait_for_firmware_start+0x5c>)
    580e:	4b0a      	ldr	r3, [pc, #40]	; (5838 <wait_for_firmware_start+0x74>)
    5810:	4798      	blx	r3
	return ret;
}

sint8 wait_for_firmware_start(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
    5812:	2000      	movs	r0, #0
    5814:	e001      	b.n	581a <wait_for_firmware_start+0x56>
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
		if(++cnt >= u32Timeout)
		{
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
    5816:	2005      	movs	r0, #5
    5818:	4240      	negs	r0, r0
	{
		nm_write_reg(NMI_STATE_REG, 0);
	}
ERR:
	return ret;
}
    581a:	b002      	add	sp, #8
    581c:	bd70      	pop	{r4, r5, r6, pc}
    581e:	46c0      	nop			; (mov r8, r8)
    5820:	0000108c 	.word	0x0000108c
    5824:	02532636 	.word	0x02532636
    5828:	000207ac 	.word	0x000207ac
    582c:	d75dc1c3 	.word	0xd75dc1c3
    5830:	00003e6d 	.word	0x00003e6d
    5834:	00005959 	.word	0x00005959
    5838:	00005971 	.word	0x00005971

0000583c <chip_deinit>:

sint8 chip_deinit(void)
{
    583c:	b510      	push	{r4, lr}
    583e:	b082      	sub	sp, #8
	uint32 reg = 0;
    5840:	2300      	movs	r3, #0
    5842:	9301      	str	r3, [sp, #4]
	sint8 ret;

	/**
	stop the firmware, need a re-download
	**/
	ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
    5844:	a901      	add	r1, sp, #4
    5846:	20a0      	movs	r0, #160	; 0xa0
    5848:	0140      	lsls	r0, r0, #5
    584a:	4b14      	ldr	r3, [pc, #80]	; (589c <chip_deinit+0x60>)
    584c:	4798      	blx	r3
    584e:	1e04      	subs	r4, r0, #0
	if (ret != M2M_SUCCESS) {
    5850:	d00b      	beq.n	586a <chip_deinit+0x2e>
		M2M_ERR("failed to de-initialize\n");
    5852:	4a13      	ldr	r2, [pc, #76]	; (58a0 <chip_deinit+0x64>)
    5854:	4913      	ldr	r1, [pc, #76]	; (58a4 <chip_deinit+0x68>)
    5856:	4814      	ldr	r0, [pc, #80]	; (58a8 <chip_deinit+0x6c>)
    5858:	4b14      	ldr	r3, [pc, #80]	; (58ac <chip_deinit+0x70>)
    585a:	4798      	blx	r3
    585c:	4814      	ldr	r0, [pc, #80]	; (58b0 <chip_deinit+0x74>)
    585e:	4b15      	ldr	r3, [pc, #84]	; (58b4 <chip_deinit+0x78>)
    5860:	4798      	blx	r3
    5862:	200d      	movs	r0, #13
    5864:	4b14      	ldr	r3, [pc, #80]	; (58b8 <chip_deinit+0x7c>)
    5866:	4798      	blx	r3
		goto ERR1;
    5868:	e014      	b.n	5894 <chip_deinit+0x58>
	}
	reg &= ~(1 << 10);
    586a:	4914      	ldr	r1, [pc, #80]	; (58bc <chip_deinit+0x80>)
    586c:	9b01      	ldr	r3, [sp, #4]
    586e:	4019      	ands	r1, r3
    5870:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_GLB_RESET_0, reg);
    5872:	20a0      	movs	r0, #160	; 0xa0
    5874:	0140      	lsls	r0, r0, #5
    5876:	4b12      	ldr	r3, [pc, #72]	; (58c0 <chip_deinit+0x84>)
    5878:	4798      	blx	r3
    587a:	1e04      	subs	r4, r0, #0
	if (ret != M2M_SUCCESS) {
    587c:	d00a      	beq.n	5894 <chip_deinit+0x58>
		M2M_ERR("failed to de-initialize\n");
    587e:	4a11      	ldr	r2, [pc, #68]	; (58c4 <chip_deinit+0x88>)
    5880:	4908      	ldr	r1, [pc, #32]	; (58a4 <chip_deinit+0x68>)
    5882:	4809      	ldr	r0, [pc, #36]	; (58a8 <chip_deinit+0x6c>)
    5884:	4b09      	ldr	r3, [pc, #36]	; (58ac <chip_deinit+0x70>)
    5886:	4798      	blx	r3
    5888:	4809      	ldr	r0, [pc, #36]	; (58b0 <chip_deinit+0x74>)
    588a:	4b0a      	ldr	r3, [pc, #40]	; (58b4 <chip_deinit+0x78>)
    588c:	4798      	blx	r3
    588e:	200d      	movs	r0, #13
    5890:	4b09      	ldr	r3, [pc, #36]	; (58b8 <chip_deinit+0x7c>)
    5892:	4798      	blx	r3
		goto ERR1;
	}

ERR1:
	return ret;
}
    5894:	0020      	movs	r0, r4
    5896:	b002      	add	sp, #8
    5898:	bd10      	pop	{r4, pc}
    589a:	46c0      	nop			; (mov r8, r8)
    589c:	00005965 	.word	0x00005965
    58a0:	00000205 	.word	0x00000205
    58a4:	000148f4 	.word	0x000148f4
    58a8:	00014144 	.word	0x00014144
    58ac:	0001198d 	.word	0x0001198d
    58b0:	000148dc 	.word	0x000148dc
    58b4:	00011aad 	.word	0x00011aad
    58b8:	000119c1 	.word	0x000119c1
    58bc:	fffffbff 	.word	0xfffffbff
    58c0:	00005971 	.word	0x00005971
    58c4:	0000020b 	.word	0x0000020b

000058c8 <nmi_get_mac_address>:
	if(pu8IsValid) *pu8IsValid = 0;
	return ret;
}

sint8 nmi_get_mac_address(uint8 *pu8MacAddr)
{
    58c8:	b530      	push	{r4, r5, lr}
    58ca:	b087      	sub	sp, #28
    58cc:	0005      	movs	r5, r0
	sint8 ret;
	uint32	u32RegValue;
	uint8	mac[6];
	tstrGpRegs strgp = {0};
    58ce:	2208      	movs	r2, #8
    58d0:	2100      	movs	r1, #0
    58d2:	a801      	add	r0, sp, #4
    58d4:	4b12      	ldr	r3, [pc, #72]	; (5920 <nmi_get_mac_address+0x58>)
    58d6:	4798      	blx	r3

	ret = nm_read_reg_with_ret(rNMI_GP_REG_2, &u32RegValue);
    58d8:	a905      	add	r1, sp, #20
    58da:	4812      	ldr	r0, [pc, #72]	; (5924 <nmi_get_mac_address+0x5c>)
    58dc:	4b12      	ldr	r3, [pc, #72]	; (5928 <nmi_get_mac_address+0x60>)
    58de:	4798      	blx	r3
	if(ret != M2M_SUCCESS) goto _EXIT_ERR;
    58e0:	2800      	cmp	r0, #0
    58e2:	d11b      	bne.n	591c <nmi_get_mac_address+0x54>

	ret = nm_read_block(u32RegValue|0x30000,(uint8*)&strgp,sizeof(tstrGpRegs));
    58e4:	20c0      	movs	r0, #192	; 0xc0
    58e6:	0280      	lsls	r0, r0, #10
    58e8:	9b05      	ldr	r3, [sp, #20]
    58ea:	4318      	orrs	r0, r3
    58ec:	2208      	movs	r2, #8
    58ee:	a901      	add	r1, sp, #4
    58f0:	4b0e      	ldr	r3, [pc, #56]	; (592c <nmi_get_mac_address+0x64>)
    58f2:	4798      	blx	r3
	if(ret != M2M_SUCCESS) goto _EXIT_ERR;
    58f4:	2800      	cmp	r0, #0
    58f6:	d111      	bne.n	591c <nmi_get_mac_address+0x54>
	u32RegValue = strgp.u32Mac_efuse_mib;

	u32RegValue &=0x0000ffff;
    58f8:	9b01      	ldr	r3, [sp, #4]
    58fa:	0418      	lsls	r0, r3, #16
    58fc:	0c00      	lsrs	r0, r0, #16
    58fe:	9005      	str	r0, [sp, #20]
	ret = nm_read_block(u32RegValue|0x30000, mac, 6);
    5900:	23c0      	movs	r3, #192	; 0xc0
    5902:	029b      	lsls	r3, r3, #10
    5904:	4318      	orrs	r0, r3
    5906:	2206      	movs	r2, #6
    5908:	a903      	add	r1, sp, #12
    590a:	4b08      	ldr	r3, [pc, #32]	; (592c <nmi_get_mac_address+0x64>)
    590c:	4798      	blx	r3
    590e:	0004      	movs	r4, r0
	m2m_memcpy(pu8MacAddr, mac, 6);
    5910:	2206      	movs	r2, #6
    5912:	a903      	add	r1, sp, #12
    5914:	0028      	movs	r0, r5
    5916:	4b06      	ldr	r3, [pc, #24]	; (5930 <nmi_get_mac_address+0x68>)
    5918:	4798      	blx	r3

	return ret;
    591a:	0020      	movs	r0, r4

_EXIT_ERR:
	return ret;
}
    591c:	b007      	add	sp, #28
    591e:	bd30      	pop	{r4, r5, pc}
    5920:	00011845 	.word	0x00011845
    5924:	000c0008 	.word	0x000c0008
    5928:	00005965 	.word	0x00005965
    592c:	0000597d 	.word	0x0000597d
    5930:	00004259 	.word	0x00004259

00005934 <nm_bus_iface_init>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_bus_iface_init(void *pvInitVal)
{
    5934:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
	ret = nm_bus_init(pvInitVal);
    5936:	4b01      	ldr	r3, [pc, #4]	; (593c <nm_bus_iface_init+0x8>)
    5938:	4798      	blx	r3
	return ret;
}
    593a:	bd10      	pop	{r4, pc}
    593c:	00003fc1 	.word	0x00003fc1

00005940 <nm_bus_iface_deinit>:
*	@author	Samer Sarhan
*	@date	07 April 2014
*	@version	1.0
*/
sint8 nm_bus_iface_deinit(void)
{
    5940:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
	ret = nm_bus_deinit();
    5942:	4b01      	ldr	r3, [pc, #4]	; (5948 <nm_bus_iface_deinit+0x8>)
    5944:	4798      	blx	r3

	return ret;
}
    5946:	bd10      	pop	{r4, pc}
    5948:	0000421d 	.word	0x0000421d

0000594c <nm_bus_reset>:
*	@brief	reset bus interface
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*	@version	1.0
*/
sint8 nm_bus_reset(void)
{
    594c:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
#ifdef CONF_WINC_USE_UART
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_reset();
    594e:	4b01      	ldr	r3, [pc, #4]	; (5954 <nm_bus_reset+0x8>)
    5950:	4798      	blx	r3
#else
#error "Plesae define bus usage"
#endif

	return ret;
}
    5952:	bd10      	pop	{r4, pc}
    5954:	000062f1 	.word	0x000062f1

00005958 <nm_read_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
uint32 nm_read_reg(uint32 u32Addr)
{
    5958:	b510      	push	{r4, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_reg(u32Addr);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_reg(u32Addr);
    595a:	4b01      	ldr	r3, [pc, #4]	; (5960 <nm_read_reg+0x8>)
    595c:	4798      	blx	r3
	return nm_i2c_read_reg(u32Addr);
#else
#error "Plesae define bus usage"
#endif

}
    595e:	bd10      	pop	{r4, pc}
    5960:	00006329 	.word	0x00006329

00005964 <nm_read_reg_with_ret>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
{
    5964:	b510      	push	{r4, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_reg_with_ret(u32Addr,pu32RetVal);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_reg_with_ret(u32Addr,pu32RetVal);
    5966:	4b01      	ldr	r3, [pc, #4]	; (596c <nm_read_reg_with_ret+0x8>)
    5968:	4798      	blx	r3
#elif defined (CONF_WINC_USE_I2C)
	return nm_i2c_read_reg_with_ret(u32Addr,pu32RetVal);
#else
#error "Plesae define bus usage"
#endif
}
    596a:	bd10      	pop	{r4, pc}
    596c:	0000633d 	.word	0x0000633d

00005970 <nm_write_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_write_reg(uint32 u32Addr, uint32 u32Val)
{
    5970:	b510      	push	{r4, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_reg(u32Addr,u32Val);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_reg(u32Addr,u32Val);
    5972:	4b01      	ldr	r3, [pc, #4]	; (5978 <nm_write_reg+0x8>)
    5974:	4798      	blx	r3
#elif defined (CONF_WINC_USE_I2C)
	return nm_i2c_write_reg(u32Addr,u32Val);
#else
#error "Plesae define bus usage"
#endif
}
    5976:	bd10      	pop	{r4, pc}
    5978:	00006355 	.word	0x00006355

0000597c <nm_read_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/ 
sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
    597c:	b5f0      	push	{r4, r5, r6, r7, lr}
    597e:	4657      	mov	r7, sl
    5980:	464e      	mov	r6, r9
    5982:	4645      	mov	r5, r8
    5984:	b4e0      	push	{r5, r6, r7}
    5986:	b082      	sub	sp, #8
    5988:	4680      	mov	r8, r0
    598a:	4689      	mov	r9, r1
    598c:	0015      	movs	r5, r2
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
    598e:	4b13      	ldr	r3, [pc, #76]	; (59dc <nm_read_block+0x60>)
    5990:	881f      	ldrh	r7, [r3, #0]
    5992:	3f08      	subs	r7, #8
    5994:	b2bb      	uxth	r3, r7
    5996:	9301      	str	r3, [sp, #4]
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    5998:	001e      	movs	r6, r3
    599a:	0004      	movs	r4, r0
    599c:	429a      	cmp	r2, r3
    599e:	d806      	bhi.n	59ae <nm_read_block+0x32>
*	@version	1.0
*/ 
sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
	uint32 off = 0;
    59a0:	2100      	movs	r1, #0
static sint8 p_nm_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_block(u32Addr,puBuf,u16Sz);
    59a2:	b2aa      	uxth	r2, r5
    59a4:	4449      	add	r1, r9
    59a6:	0020      	movs	r0, r4
    59a8:	4b0d      	ldr	r3, [pc, #52]	; (59e0 <nm_read_block+0x64>)
    59aa:	4798      	blx	r3
	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
		{
			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], (uint16)u32Sz);	
			break;
    59ac:	e010      	b.n	59d0 <nm_read_block+0x54>
static sint8 p_nm_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_block(u32Addr,puBuf,u16Sz);
    59ae:	4b0c      	ldr	r3, [pc, #48]	; (59e0 <nm_read_block+0x64>)
    59b0:	469a      	mov	sl, r3
    59b2:	1a37      	subs	r7, r6, r0
    59b4:	4643      	mov	r3, r8
    59b6:	1ae1      	subs	r1, r4, r3
    59b8:	4449      	add	r1, r9
    59ba:	9a01      	ldr	r2, [sp, #4]
    59bc:	0020      	movs	r0, r4
    59be:	47d0      	blx	sl
			break;
		}
		else
		{
			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], u16MaxTrxSz);
			if(M2M_SUCCESS != s8Ret) break;
    59c0:	2800      	cmp	r0, #0
    59c2:	d105      	bne.n	59d0 <nm_read_block+0x54>
			u32Sz -= u16MaxTrxSz;
    59c4:	1bad      	subs	r5, r5, r6
    59c6:	1939      	adds	r1, r7, r4
			off += u16MaxTrxSz;
			u32Addr += u16MaxTrxSz;
    59c8:	19a4      	adds	r4, r4, r6
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    59ca:	42b5      	cmp	r5, r6
    59cc:	d8f2      	bhi.n	59b4 <nm_read_block+0x38>
    59ce:	e7e8      	b.n	59a2 <nm_read_block+0x26>
			u32Addr += u16MaxTrxSz;
		}
	}

	return s8Ret;
}
    59d0:	b002      	add	sp, #8
    59d2:	bc1c      	pop	{r2, r3, r4}
    59d4:	4690      	mov	r8, r2
    59d6:	4699      	mov	r9, r3
    59d8:	46a2      	mov	sl, r4
    59da:	bdf0      	pop	{r4, r5, r6, r7, pc}
    59dc:	20000110 	.word	0x20000110
    59e0:	00006499 	.word	0x00006499

000059e4 <nm_write_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/ 
sint8 nm_write_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
    59e4:	b5f0      	push	{r4, r5, r6, r7, lr}
    59e6:	4657      	mov	r7, sl
    59e8:	464e      	mov	r6, r9
    59ea:	4645      	mov	r5, r8
    59ec:	b4e0      	push	{r5, r6, r7}
    59ee:	b082      	sub	sp, #8
    59f0:	4680      	mov	r8, r0
    59f2:	4689      	mov	r9, r1
    59f4:	0015      	movs	r5, r2
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
    59f6:	4b13      	ldr	r3, [pc, #76]	; (5a44 <nm_write_block+0x60>)
    59f8:	881f      	ldrh	r7, [r3, #0]
    59fa:	3f08      	subs	r7, #8
    59fc:	b2bb      	uxth	r3, r7
    59fe:	9301      	str	r3, [sp, #4]
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    5a00:	001e      	movs	r6, r3
    5a02:	0004      	movs	r4, r0
    5a04:	429a      	cmp	r2, r3
    5a06:	d806      	bhi.n	5a16 <nm_write_block+0x32>
*	@version	1.0
*/ 
sint8 nm_write_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
	uint32 off = 0;
    5a08:	2100      	movs	r1, #0
static sint8 p_nm_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_block(u32Addr,puBuf,u16Sz);
    5a0a:	b2aa      	uxth	r2, r5
    5a0c:	4449      	add	r1, r9
    5a0e:	0020      	movs	r0, r4
    5a10:	4b0d      	ldr	r3, [pc, #52]	; (5a48 <nm_write_block+0x64>)
    5a12:	4798      	blx	r3
	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
		{
			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], (uint16)u32Sz);	
			break;
    5a14:	e010      	b.n	5a38 <nm_write_block+0x54>
static sint8 p_nm_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_block(u32Addr,puBuf,u16Sz);
    5a16:	4b0c      	ldr	r3, [pc, #48]	; (5a48 <nm_write_block+0x64>)
    5a18:	469a      	mov	sl, r3
    5a1a:	1a37      	subs	r7, r6, r0
    5a1c:	4643      	mov	r3, r8
    5a1e:	1ae1      	subs	r1, r4, r3
    5a20:	4449      	add	r1, r9
    5a22:	9a01      	ldr	r2, [sp, #4]
    5a24:	0020      	movs	r0, r4
    5a26:	47d0      	blx	sl
			break;
		}
		else
		{
			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], u16MaxTrxSz);
			if(M2M_SUCCESS != s8Ret) break;
    5a28:	2800      	cmp	r0, #0
    5a2a:	d105      	bne.n	5a38 <nm_write_block+0x54>
			u32Sz -= u16MaxTrxSz;
    5a2c:	1bad      	subs	r5, r5, r6
    5a2e:	1939      	adds	r1, r7, r4
			off += u16MaxTrxSz;
			u32Addr += u16MaxTrxSz;
    5a30:	19a4      	adds	r4, r4, r6
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    5a32:	42b5      	cmp	r5, r6
    5a34:	d8f2      	bhi.n	5a1c <nm_write_block+0x38>
    5a36:	e7e8      	b.n	5a0a <nm_write_block+0x26>
			u32Addr += u16MaxTrxSz;
		}
	}

	return s8Ret;
}
    5a38:	b002      	add	sp, #8
    5a3a:	bc1c      	pop	{r2, r3, r4}
    5a3c:	4690      	mov	r8, r2
    5a3e:	4699      	mov	r9, r3
    5a40:	46a2      	mov	sl, r4
    5a42:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5a44:	20000110 	.word	0x20000110
    5a48:	000065f5 	.word	0x000065f5

00005a4c <nm_get_firmware_full_info>:
*	@param [out]	M2mRev
*			    pointer holds address of structure "tstrM2mRev" that contains the firmware version parameters
*	@version	1.0
*/
sint8 nm_get_firmware_full_info(tstrM2mRev* pstrRev)
{
    5a4c:	b570      	push	{r4, r5, r6, lr}
    5a4e:	b084      	sub	sp, #16
    5a50:	0004      	movs	r4, r0
	uint16  curr_drv_ver, min_req_drv_ver,curr_firm_ver;
	uint32	reg = 0;
    5a52:	2300      	movs	r3, #0
    5a54:	9303      	str	r3, [sp, #12]
	sint8	ret = M2M_SUCCESS;
	tstrGpRegs strgp = {0};
    5a56:	2208      	movs	r2, #8
    5a58:	2100      	movs	r1, #0
    5a5a:	a801      	add	r0, sp, #4
    5a5c:	4b2d      	ldr	r3, [pc, #180]	; (5b14 <nm_get_firmware_full_info+0xc8>)
    5a5e:	4798      	blx	r3
	if (pstrRev != NULL)
    5a60:	2c00      	cmp	r4, #0
    5a62:	d045      	beq.n	5af0 <nm_get_firmware_full_info+0xa4>
	{
		m2m_memset((uint8*)pstrRev,0,sizeof(tstrM2mRev));
    5a64:	2228      	movs	r2, #40	; 0x28
    5a66:	2100      	movs	r1, #0
    5a68:	0020      	movs	r0, r4
    5a6a:	4b2b      	ldr	r3, [pc, #172]	; (5b18 <nm_get_firmware_full_info+0xcc>)
    5a6c:	4798      	blx	r3
		ret = nm_read_reg_with_ret(rNMI_GP_REG_2, &reg);
    5a6e:	a903      	add	r1, sp, #12
    5a70:	482a      	ldr	r0, [pc, #168]	; (5b1c <nm_get_firmware_full_info+0xd0>)
    5a72:	4b2b      	ldr	r3, [pc, #172]	; (5b20 <nm_get_firmware_full_info+0xd4>)
    5a74:	4798      	blx	r3
		if(ret == M2M_SUCCESS)
    5a76:	2800      	cmp	r0, #0
    5a78:	d14a      	bne.n	5b10 <nm_get_firmware_full_info+0xc4>
		{
			if(reg != 0)
    5a7a:	9803      	ldr	r0, [sp, #12]
    5a7c:	2800      	cmp	r0, #0
    5a7e:	d039      	beq.n	5af4 <nm_get_firmware_full_info+0xa8>
			{
				ret = nm_read_block(reg|0x30000,(uint8*)&strgp,sizeof(tstrGpRegs));
    5a80:	23c0      	movs	r3, #192	; 0xc0
    5a82:	029b      	lsls	r3, r3, #10
    5a84:	4318      	orrs	r0, r3
    5a86:	2208      	movs	r2, #8
    5a88:	a901      	add	r1, sp, #4
    5a8a:	4b26      	ldr	r3, [pc, #152]	; (5b24 <nm_get_firmware_full_info+0xd8>)
    5a8c:	4798      	blx	r3
				if(ret == M2M_SUCCESS)
    5a8e:	2800      	cmp	r0, #0
    5a90:	d13e      	bne.n	5b10 <nm_get_firmware_full_info+0xc4>
				{
					reg = strgp.u32Firmware_Ota_rev;
					reg &= 0x0000ffff;
    5a92:	9b02      	ldr	r3, [sp, #8]
    5a94:	0418      	lsls	r0, r3, #16
    5a96:	0c00      	lsrs	r0, r0, #16
    5a98:	9003      	str	r0, [sp, #12]
					if(reg != 0)
    5a9a:	d02e      	beq.n	5afa <nm_get_firmware_full_info+0xae>
					{
						ret = nm_read_block(reg|0x30000,(uint8*)pstrRev,sizeof(tstrM2mRev));
    5a9c:	23c0      	movs	r3, #192	; 0xc0
    5a9e:	029b      	lsls	r3, r3, #10
    5aa0:	4318      	orrs	r0, r3
    5aa2:	2228      	movs	r2, #40	; 0x28
    5aa4:	0021      	movs	r1, r4
    5aa6:	4b1f      	ldr	r3, [pc, #124]	; (5b24 <nm_get_firmware_full_info+0xd8>)
    5aa8:	4798      	blx	r3
						if(ret == M2M_SUCCESS)
    5aaa:	2800      	cmp	r0, #0
    5aac:	d130      	bne.n	5b10 <nm_get_firmware_full_info+0xc4>
						{
							curr_firm_ver   = M2M_MAKE_VERSION(pstrRev->u8FirmwareMajor, pstrRev->u8FirmwareMinor,pstrRev->u8FirmwarePatch);
    5aae:	7923      	ldrb	r3, [r4, #4]
    5ab0:	0219      	lsls	r1, r3, #8
    5ab2:	79a3      	ldrb	r3, [r4, #6]
    5ab4:	250f      	movs	r5, #15
    5ab6:	402b      	ands	r3, r5
    5ab8:	430b      	orrs	r3, r1
    5aba:	7966      	ldrb	r6, [r4, #5]
    5abc:	0136      	lsls	r6, r6, #4
    5abe:	22ff      	movs	r2, #255	; 0xff
    5ac0:	4016      	ands	r6, r2
    5ac2:	4333      	orrs	r3, r6
							curr_drv_ver    = M2M_MAKE_VERSION(M2M_RELEASE_VERSION_MAJOR_NO, M2M_RELEASE_VERSION_MINOR_NO, M2M_RELEASE_VERSION_PATCH_NO);
							min_req_drv_ver = M2M_MAKE_VERSION(pstrRev->u8DriverMajor, pstrRev->u8DriverMinor,pstrRev->u8DriverPatch);
    5ac4:	79e6      	ldrb	r6, [r4, #7]
    5ac6:	0236      	lsls	r6, r6, #8
    5ac8:	7a61      	ldrb	r1, [r4, #9]
    5aca:	400d      	ands	r5, r1
    5acc:	4335      	orrs	r5, r6
    5ace:	7a21      	ldrb	r1, [r4, #8]
    5ad0:	0109      	lsls	r1, r1, #4
    5ad2:	4011      	ands	r1, r2
    5ad4:	002a      	movs	r2, r5
    5ad6:	430a      	orrs	r2, r1
							if((curr_firm_ver == 0)||(min_req_drv_ver == 0)||(min_req_drv_ver == 0)){
    5ad8:	2b00      	cmp	r3, #0
    5ada:	d011      	beq.n	5b00 <nm_get_firmware_full_info+0xb4>
    5adc:	2a00      	cmp	r2, #0
    5ade:	d012      	beq.n	5b06 <nm_get_firmware_full_info+0xba>
								ret = M2M_ERR_FAIL;
								goto EXIT;
							}
							if(curr_drv_ver <  min_req_drv_ver) {
    5ae0:	4911      	ldr	r1, [pc, #68]	; (5b28 <nm_get_firmware_full_info+0xdc>)
    5ae2:	428a      	cmp	r2, r1
    5ae4:	d812      	bhi.n	5b0c <nm_get_firmware_full_info+0xc0>
								/*The current driver version should be larger or equal 
								than the min driver that the current firmware support  */
								ret = M2M_ERR_FW_VER_MISMATCH;
								goto EXIT;
							}
							if(curr_drv_ver >  curr_firm_ver) {
    5ae6:	4a11      	ldr	r2, [pc, #68]	; (5b2c <nm_get_firmware_full_info+0xe0>)
    5ae8:	4293      	cmp	r3, r2
    5aea:	d811      	bhi.n	5b10 <nm_get_firmware_full_info+0xc4>
								/*The current driver should be equal or less than the firmware version*/
								ret = M2M_ERR_FW_VER_MISMATCH;
    5aec:	380d      	subs	r0, #13
    5aee:	e00f      	b.n	5b10 <nm_get_firmware_full_info+0xc4>
*/
sint8 nm_get_firmware_full_info(tstrM2mRev* pstrRev)
{
	uint16  curr_drv_ver, min_req_drv_ver,curr_firm_ver;
	uint32	reg = 0;
	sint8	ret = M2M_SUCCESS;
    5af0:	2000      	movs	r0, #0
    5af2:	e00d      	b.n	5b10 <nm_get_firmware_full_info+0xc4>
					}else {
						ret = M2M_ERR_FAIL;
					}
				}
			}else{
				ret = M2M_ERR_FAIL;
    5af4:	200c      	movs	r0, #12
    5af6:	4240      	negs	r0, r0
    5af8:	e00a      	b.n	5b10 <nm_get_firmware_full_info+0xc4>
								ret = M2M_ERR_FW_VER_MISMATCH;
								goto EXIT;
							}
						}
					}else {
						ret = M2M_ERR_FAIL;
    5afa:	200c      	movs	r0, #12
    5afc:	4240      	negs	r0, r0
    5afe:	e007      	b.n	5b10 <nm_get_firmware_full_info+0xc4>
						{
							curr_firm_ver   = M2M_MAKE_VERSION(pstrRev->u8FirmwareMajor, pstrRev->u8FirmwareMinor,pstrRev->u8FirmwarePatch);
							curr_drv_ver    = M2M_MAKE_VERSION(M2M_RELEASE_VERSION_MAJOR_NO, M2M_RELEASE_VERSION_MINOR_NO, M2M_RELEASE_VERSION_PATCH_NO);
							min_req_drv_ver = M2M_MAKE_VERSION(pstrRev->u8DriverMajor, pstrRev->u8DriverMinor,pstrRev->u8DriverPatch);
							if((curr_firm_ver == 0)||(min_req_drv_ver == 0)||(min_req_drv_ver == 0)){
								ret = M2M_ERR_FAIL;
    5b00:	200c      	movs	r0, #12
    5b02:	4240      	negs	r0, r0
    5b04:	e004      	b.n	5b10 <nm_get_firmware_full_info+0xc4>
    5b06:	200c      	movs	r0, #12
    5b08:	4240      	negs	r0, r0
    5b0a:	e001      	b.n	5b10 <nm_get_firmware_full_info+0xc4>
								goto EXIT;
							}
							if(curr_drv_ver <  min_req_drv_ver) {
								/*The current driver version should be larger or equal 
								than the min driver that the current firmware support  */
								ret = M2M_ERR_FW_VER_MISMATCH;
    5b0c:	200d      	movs	r0, #13
    5b0e:	4240      	negs	r0, r0
			}
		}
	}
EXIT:
	return ret;
}
    5b10:	b004      	add	sp, #16
    5b12:	bd70      	pop	{r4, r5, r6, pc}
    5b14:	00011845 	.word	0x00011845
    5b18:	0000426d 	.word	0x0000426d
    5b1c:	000c0008 	.word	0x000c0008
    5b20:	00005965 	.word	0x00005965
    5b24:	0000597d 	.word	0x0000597d
    5b28:	00001352 	.word	0x00001352
    5b2c:	00001351 	.word	0x00001351

00005b30 <nm_drv_init>:
*	@author	M. Abdelmawla
*	@date	15 July 2012
*	@version	1.0
*/
sint8 nm_drv_init(void * arg)
{
    5b30:	b570      	push	{r4, r5, r6, lr}
	sint8 ret = M2M_SUCCESS;
	uint8 u8Mode;
	
	if(NULL != arg) {
    5b32:	2800      	cmp	r0, #0
    5b34:	d005      	beq.n	5b42 <nm_drv_init+0x12>
		u8Mode = *((uint8 *)arg);
    5b36:	7805      	ldrb	r5, [r0, #0]
		if((u8Mode < M2M_WIFI_MODE_NORMAL)||(u8Mode >= M2M_WIFI_MODE_MAX)) {
    5b38:	1e6b      	subs	r3, r5, #1
    5b3a:	2b03      	cmp	r3, #3
    5b3c:	d902      	bls.n	5b44 <nm_drv_init+0x14>
			u8Mode = M2M_WIFI_MODE_NORMAL;
    5b3e:	2501      	movs	r5, #1
    5b40:	e000      	b.n	5b44 <nm_drv_init+0x14>
		}
	} else {
		u8Mode = M2M_WIFI_MODE_NORMAL;
    5b42:	2501      	movs	r5, #1
	}
	
	ret = nm_bus_iface_init(NULL);
    5b44:	2000      	movs	r0, #0
    5b46:	4b1f      	ldr	r3, [pc, #124]	; (5bc4 <nm_drv_init+0x94>)
    5b48:	4798      	blx	r3
    5b4a:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    5b4c:	d00c      	beq.n	5b68 <nm_drv_init+0x38>
		M2M_ERR("[nmi start]: fail init bus\n");
    5b4e:	2228      	movs	r2, #40	; 0x28
    5b50:	32ff      	adds	r2, #255	; 0xff
    5b52:	491d      	ldr	r1, [pc, #116]	; (5bc8 <nm_drv_init+0x98>)
    5b54:	481d      	ldr	r0, [pc, #116]	; (5bcc <nm_drv_init+0x9c>)
    5b56:	4b1e      	ldr	r3, [pc, #120]	; (5bd0 <nm_drv_init+0xa0>)
    5b58:	4798      	blx	r3
    5b5a:	481e      	ldr	r0, [pc, #120]	; (5bd4 <nm_drv_init+0xa4>)
    5b5c:	4b1e      	ldr	r3, [pc, #120]	; (5bd8 <nm_drv_init+0xa8>)
    5b5e:	4798      	blx	r3
    5b60:	200d      	movs	r0, #13
    5b62:	4b1e      	ldr	r3, [pc, #120]	; (5bdc <nm_drv_init+0xac>)
    5b64:	4798      	blx	r3
		goto ERR1;
    5b66:	e02b      	b.n	5bc0 <nm_drv_init+0x90>
	ret = chip_reset();
	if (M2M_SUCCESS != ret) {
		goto ERR2;
	}
#endif
	M2M_INFO("Chip ID %lx\n", nmi_get_chipid());
    5b68:	481d      	ldr	r0, [pc, #116]	; (5be0 <nm_drv_init+0xb0>)
    5b6a:	4c19      	ldr	r4, [pc, #100]	; (5bd0 <nm_drv_init+0xa0>)
    5b6c:	47a0      	blx	r4
    5b6e:	4b1d      	ldr	r3, [pc, #116]	; (5be4 <nm_drv_init+0xb4>)
    5b70:	4798      	blx	r3
    5b72:	0001      	movs	r1, r0
    5b74:	481c      	ldr	r0, [pc, #112]	; (5be8 <nm_drv_init+0xb8>)
    5b76:	47a0      	blx	r4
    5b78:	200d      	movs	r0, #13
    5b7a:	4b18      	ldr	r3, [pc, #96]	; (5bdc <nm_drv_init+0xac>)
    5b7c:	4798      	blx	r3
#ifdef CONF_WINC_USE_SPI
	/* Must do this after global reset to set SPI data packet size. */
	nm_spi_init();
    5b7e:	4b1b      	ldr	r3, [pc, #108]	; (5bec <nm_drv_init+0xbc>)
    5b80:	4798      	blx	r3
#endif
	ret = wait_for_bootrom(u8Mode);
    5b82:	0028      	movs	r0, r5
    5b84:	4b1a      	ldr	r3, [pc, #104]	; (5bf0 <nm_drv_init+0xc0>)
    5b86:	4798      	blx	r3
    5b88:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    5b8a:	d117      	bne.n	5bbc <nm_drv_init+0x8c>
		goto ERR2;
	}
		
	ret = wait_for_firmware_start(u8Mode);
    5b8c:	0028      	movs	r0, r5
    5b8e:	4b19      	ldr	r3, [pc, #100]	; (5bf4 <nm_drv_init+0xc4>)
    5b90:	4798      	blx	r3
    5b92:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    5b94:	d112      	bne.n	5bbc <nm_drv_init+0x8c>
		goto ERR2;
	}
	
	if((M2M_WIFI_MODE_ATE_HIGH == u8Mode)||(M2M_WIFI_MODE_ATE_LOW == u8Mode)) {
    5b96:	1ea8      	subs	r0, r5, #2
    5b98:	2801      	cmp	r0, #1
    5b9a:	d911      	bls.n	5bc0 <nm_drv_init+0x90>
		goto ERR1;
	} else {
		/*continue running*/
	}
	
	ret = enable_interrupts();
    5b9c:	4b16      	ldr	r3, [pc, #88]	; (5bf8 <nm_drv_init+0xc8>)
    5b9e:	4798      	blx	r3
    5ba0:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    5ba2:	d00d      	beq.n	5bc0 <nm_drv_init+0x90>
		M2M_ERR("failed to enable interrupts..\n");
    5ba4:	2256      	movs	r2, #86	; 0x56
    5ba6:	32ff      	adds	r2, #255	; 0xff
    5ba8:	4907      	ldr	r1, [pc, #28]	; (5bc8 <nm_drv_init+0x98>)
    5baa:	4808      	ldr	r0, [pc, #32]	; (5bcc <nm_drv_init+0x9c>)
    5bac:	4b08      	ldr	r3, [pc, #32]	; (5bd0 <nm_drv_init+0xa0>)
    5bae:	4798      	blx	r3
    5bb0:	4812      	ldr	r0, [pc, #72]	; (5bfc <nm_drv_init+0xcc>)
    5bb2:	4b09      	ldr	r3, [pc, #36]	; (5bd8 <nm_drv_init+0xa8>)
    5bb4:	4798      	blx	r3
    5bb6:	200d      	movs	r0, #13
    5bb8:	4b08      	ldr	r3, [pc, #32]	; (5bdc <nm_drv_init+0xac>)
    5bba:	4798      	blx	r3
		goto ERR2;
	}
	return ret;
ERR2:
	nm_bus_iface_deinit();
    5bbc:	4b10      	ldr	r3, [pc, #64]	; (5c00 <nm_drv_init+0xd0>)
    5bbe:	4798      	blx	r3
ERR1:
	return ret;
}
    5bc0:	0020      	movs	r0, r4
    5bc2:	bd70      	pop	{r4, r5, r6, pc}
    5bc4:	00005935 	.word	0x00005935
    5bc8:	000149b8 	.word	0x000149b8
    5bcc:	00014144 	.word	0x00014144
    5bd0:	0001198d 	.word	0x0001198d
    5bd4:	0001490c 	.word	0x0001490c
    5bd8:	00011aad 	.word	0x00011aad
    5bdc:	000119c1 	.word	0x000119c1
    5be0:	00013ca0 	.word	0x00013ca0
    5be4:	000054b1 	.word	0x000054b1
    5be8:	00014928 	.word	0x00014928
    5bec:	0000636d 	.word	0x0000636d
    5bf0:	000056bd 	.word	0x000056bd
    5bf4:	000057c5 	.word	0x000057c5
    5bf8:	00005459 	.word	0x00005459
    5bfc:	00014938 	.word	0x00014938
    5c00:	00005941 	.word	0x00005941

00005c04 <nm_drv_deinit>:
*	@author	M. Abdelmawla
*	@date	17 July 2012
*	@version	1.0
*/
sint8 nm_drv_deinit(void * arg)
{
    5c04:	b510      	push	{r4, lr}
	sint8 ret;

	ret = chip_deinit();
    5c06:	4b1c      	ldr	r3, [pc, #112]	; (5c78 <nm_drv_deinit+0x74>)
    5c08:	4798      	blx	r3
    5c0a:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    5c0c:	d00c      	beq.n	5c28 <nm_drv_deinit+0x24>
		M2M_ERR("[nmi stop]: chip_deinit fail\n");
    5c0e:	22b6      	movs	r2, #182	; 0xb6
    5c10:	0052      	lsls	r2, r2, #1
    5c12:	491a      	ldr	r1, [pc, #104]	; (5c7c <nm_drv_deinit+0x78>)
    5c14:	481a      	ldr	r0, [pc, #104]	; (5c80 <nm_drv_deinit+0x7c>)
    5c16:	4b1b      	ldr	r3, [pc, #108]	; (5c84 <nm_drv_deinit+0x80>)
    5c18:	4798      	blx	r3
    5c1a:	481b      	ldr	r0, [pc, #108]	; (5c88 <nm_drv_deinit+0x84>)
    5c1c:	4b1b      	ldr	r3, [pc, #108]	; (5c8c <nm_drv_deinit+0x88>)
    5c1e:	4798      	blx	r3
    5c20:	200d      	movs	r0, #13
    5c22:	4b1b      	ldr	r3, [pc, #108]	; (5c90 <nm_drv_deinit+0x8c>)
    5c24:	4798      	blx	r3
		goto ERR1;
    5c26:	e024      	b.n	5c72 <nm_drv_deinit+0x6e>
	}
	
	/* Disable SPI flash to save power when the chip is off */
	ret = spi_flash_enable(0);
    5c28:	2000      	movs	r0, #0
    5c2a:	4b1a      	ldr	r3, [pc, #104]	; (5c94 <nm_drv_deinit+0x90>)
    5c2c:	4798      	blx	r3
    5c2e:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    5c30:	d00c      	beq.n	5c4c <nm_drv_deinit+0x48>
		M2M_ERR("[nmi stop]: SPI flash disable fail\n");
    5c32:	2274      	movs	r2, #116	; 0x74
    5c34:	32ff      	adds	r2, #255	; 0xff
    5c36:	4911      	ldr	r1, [pc, #68]	; (5c7c <nm_drv_deinit+0x78>)
    5c38:	4811      	ldr	r0, [pc, #68]	; (5c80 <nm_drv_deinit+0x7c>)
    5c3a:	4b12      	ldr	r3, [pc, #72]	; (5c84 <nm_drv_deinit+0x80>)
    5c3c:	4798      	blx	r3
    5c3e:	4816      	ldr	r0, [pc, #88]	; (5c98 <nm_drv_deinit+0x94>)
    5c40:	4b12      	ldr	r3, [pc, #72]	; (5c8c <nm_drv_deinit+0x88>)
    5c42:	4798      	blx	r3
    5c44:	200d      	movs	r0, #13
    5c46:	4b12      	ldr	r3, [pc, #72]	; (5c90 <nm_drv_deinit+0x8c>)
    5c48:	4798      	blx	r3
		goto ERR1;
    5c4a:	e012      	b.n	5c72 <nm_drv_deinit+0x6e>
	}

	ret = nm_bus_iface_deinit();
    5c4c:	4b13      	ldr	r3, [pc, #76]	; (5c9c <nm_drv_deinit+0x98>)
    5c4e:	4798      	blx	r3
    5c50:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    5c52:	d00c      	beq.n	5c6e <nm_drv_deinit+0x6a>
		M2M_ERR("[nmi stop]: fail init bus\n");
    5c54:	227a      	movs	r2, #122	; 0x7a
    5c56:	32ff      	adds	r2, #255	; 0xff
    5c58:	4908      	ldr	r1, [pc, #32]	; (5c7c <nm_drv_deinit+0x78>)
    5c5a:	4809      	ldr	r0, [pc, #36]	; (5c80 <nm_drv_deinit+0x7c>)
    5c5c:	4b09      	ldr	r3, [pc, #36]	; (5c84 <nm_drv_deinit+0x80>)
    5c5e:	4798      	blx	r3
    5c60:	480f      	ldr	r0, [pc, #60]	; (5ca0 <nm_drv_deinit+0x9c>)
    5c62:	4b0a      	ldr	r3, [pc, #40]	; (5c8c <nm_drv_deinit+0x88>)
    5c64:	4798      	blx	r3
    5c66:	200d      	movs	r0, #13
    5c68:	4b09      	ldr	r3, [pc, #36]	; (5c90 <nm_drv_deinit+0x8c>)
    5c6a:	4798      	blx	r3
		goto ERR1;
    5c6c:	e001      	b.n	5c72 <nm_drv_deinit+0x6e>
	}
#ifdef CONF_WINC_USE_SPI
	/* Must do this after global reset to set SPI data packet size. */
	nm_spi_deinit();
    5c6e:	4b0d      	ldr	r3, [pc, #52]	; (5ca4 <nm_drv_deinit+0xa0>)
    5c70:	4798      	blx	r3
#endif

ERR1:
	return ret;
}
    5c72:	0020      	movs	r0, r4
    5c74:	bd10      	pop	{r4, pc}
    5c76:	46c0      	nop			; (mov r8, r8)
    5c78:	0000583d 	.word	0x0000583d
    5c7c:	000149c4 	.word	0x000149c4
    5c80:	00014144 	.word	0x00014144
    5c84:	0001198d 	.word	0x0001198d
    5c88:	00014958 	.word	0x00014958
    5c8c:	00011aad 	.word	0x00011aad
    5c90:	000119c1 	.word	0x000119c1
    5c94:	00007219 	.word	0x00007219
    5c98:	00014978 	.word	0x00014978
    5c9c:	00005941 	.word	0x00005941
    5ca0:	0001499c 	.word	0x0001499c
    5ca4:	00006319 	.word	0x00006319

00005ca8 <nmi_spi_write>:
	spi.u16Sz = sz;
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
}

static sint8 nmi_spi_write(uint8* b, uint16 sz)
{
    5ca8:	b500      	push	{lr}
    5caa:	b085      	sub	sp, #20
	tstrNmSpiRw spi;
	spi.pu8InBuf = b;
    5cac:	ab01      	add	r3, sp, #4
    5cae:	9001      	str	r0, [sp, #4]
	spi.pu8OutBuf = NULL;
    5cb0:	2200      	movs	r2, #0
    5cb2:	9202      	str	r2, [sp, #8]
	spi.u16Sz = sz;
    5cb4:	8119      	strh	r1, [r3, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
    5cb6:	0019      	movs	r1, r3
    5cb8:	2003      	movs	r0, #3
    5cba:	4b02      	ldr	r3, [pc, #8]	; (5cc4 <nmi_spi_write+0x1c>)
    5cbc:	4798      	blx	r3
}
    5cbe:	b005      	add	sp, #20
    5cc0:	bd00      	pop	{pc}
    5cc2:	46c0      	nop			; (mov r8, r8)
    5cc4:	000040c5 	.word	0x000040c5

00005cc8 <spi_cmd>:
#define DATA_PKT_SZ_4K			(4 * 1024)
#define DATA_PKT_SZ_8K			(8 * 1024)
#define DATA_PKT_SZ				DATA_PKT_SZ_8K

static sint8 spi_cmd(uint8 cmd, uint32 adr, uint32 u32data, uint32 sz,uint8 clockless)
{
    5cc8:	b570      	push	{r4, r5, r6, lr}
    5cca:	b084      	sub	sp, #16
    5ccc:	ac08      	add	r4, sp, #32
    5cce:	7825      	ldrb	r5, [r4, #0]
	uint8 bc[9];
	uint8 len = 5;
	sint8 result = N_OK;

	bc[0] = cmd;
    5cd0:	ac01      	add	r4, sp, #4
    5cd2:	7020      	strb	r0, [r4, #0]
	switch (cmd) {
    5cd4:	303f      	adds	r0, #63	; 0x3f
    5cd6:	b2c4      	uxtb	r4, r0
    5cd8:	2c0e      	cmp	r4, #14
    5cda:	d900      	bls.n	5cde <spi_cmd+0x16>
    5cdc:	e092      	b.n	5e04 <spi_cmd+0x13c>
    5cde:	00a0      	lsls	r0, r4, #2
    5ce0:	4c50      	ldr	r4, [pc, #320]	; (5e24 <spi_cmd+0x15c>)
    5ce2:	5820      	ldr	r0, [r4, r0]
    5ce4:	4687      	mov	pc, r0
	case CMD_SINGLE_READ:				/* single word (4 bytes) read */
		bc[1] = (uint8)(adr >> 16);
    5ce6:	ab01      	add	r3, sp, #4
    5ce8:	0c0a      	lsrs	r2, r1, #16
    5cea:	705a      	strb	r2, [r3, #1]
		bc[2] = (uint8)(adr >> 8);
    5cec:	0a0a      	lsrs	r2, r1, #8
    5cee:	709a      	strb	r2, [r3, #2]
		bc[3] = (uint8)adr;
    5cf0:	70d9      	strb	r1, [r3, #3]
		len = 5;
    5cf2:	2105      	movs	r1, #5
		break;
    5cf4:	e08e      	b.n	5e14 <spi_cmd+0x14c>
	case CMD_INTERNAL_READ:			/* internal register read */
		bc[1] = (uint8)(adr >> 8);
    5cf6:	0a0b      	lsrs	r3, r1, #8
    5cf8:	b2db      	uxtb	r3, r3
		if(clockless)  bc[1] |= (1 << 7);
    5cfa:	2d00      	cmp	r5, #0
    5cfc:	d102      	bne.n	5d04 <spi_cmd+0x3c>
		bc[2] = (uint8)(adr >> 8);
		bc[3] = (uint8)adr;
		len = 5;
		break;
	case CMD_INTERNAL_READ:			/* internal register read */
		bc[1] = (uint8)(adr >> 8);
    5cfe:	aa01      	add	r2, sp, #4
    5d00:	7053      	strb	r3, [r2, #1]
    5d02:	e004      	b.n	5d0e <spi_cmd+0x46>
		if(clockless)  bc[1] |= (1 << 7);
    5d04:	2280      	movs	r2, #128	; 0x80
    5d06:	4252      	negs	r2, r2
    5d08:	4313      	orrs	r3, r2
    5d0a:	aa01      	add	r2, sp, #4
    5d0c:	7053      	strb	r3, [r2, #1]
		bc[2] = (uint8)adr;
    5d0e:	ab01      	add	r3, sp, #4
    5d10:	7099      	strb	r1, [r3, #2]
		bc[3] = 0x00;
    5d12:	2200      	movs	r2, #0
    5d14:	70da      	strb	r2, [r3, #3]
		len = 5;
    5d16:	2105      	movs	r1, #5
		break;
    5d18:	e07c      	b.n	5e14 <spi_cmd+0x14c>
	case CMD_TERMINATE:					/* termination */
		bc[1] = 0x00;
    5d1a:	ab01      	add	r3, sp, #4
    5d1c:	2200      	movs	r2, #0
    5d1e:	705a      	strb	r2, [r3, #1]
		bc[2] = 0x00;
    5d20:	709a      	strb	r2, [r3, #2]
		bc[3] = 0x00;
    5d22:	70da      	strb	r2, [r3, #3]
		len = 5;
    5d24:	2105      	movs	r1, #5
		break;
    5d26:	e075      	b.n	5e14 <spi_cmd+0x14c>
	case CMD_REPEAT:						/* repeat */
		bc[1] = 0x00;
    5d28:	ab01      	add	r3, sp, #4
    5d2a:	2200      	movs	r2, #0
    5d2c:	705a      	strb	r2, [r3, #1]
		bc[2] = 0x00;
    5d2e:	709a      	strb	r2, [r3, #2]
		bc[3] = 0x00;
    5d30:	70da      	strb	r2, [r3, #3]
		len = 5;
    5d32:	2105      	movs	r1, #5
		break;
    5d34:	e06e      	b.n	5e14 <spi_cmd+0x14c>
	case CMD_RESET:							/* reset */
		bc[1] = 0xff;
    5d36:	ab01      	add	r3, sp, #4
    5d38:	22ff      	movs	r2, #255	; 0xff
    5d3a:	705a      	strb	r2, [r3, #1]
		bc[2] = 0xff;
    5d3c:	709a      	strb	r2, [r3, #2]
		bc[3] = 0xff;
    5d3e:	70da      	strb	r2, [r3, #3]
		len = 5;
    5d40:	2105      	movs	r1, #5
		break;
    5d42:	e067      	b.n	5e14 <spi_cmd+0x14c>
	case CMD_DMA_WRITE:					/* dma write */
	case CMD_DMA_READ:					/* dma read */
		bc[1] = (uint8)(adr >> 16);
    5d44:	aa01      	add	r2, sp, #4
    5d46:	0c08      	lsrs	r0, r1, #16
    5d48:	7050      	strb	r0, [r2, #1]
		bc[2] = (uint8)(adr >> 8);
    5d4a:	0a08      	lsrs	r0, r1, #8
    5d4c:	7090      	strb	r0, [r2, #2]
		bc[3] = (uint8)adr;
    5d4e:	70d1      	strb	r1, [r2, #3]
		bc[4] = (uint8)(sz >> 8);
    5d50:	0a19      	lsrs	r1, r3, #8
    5d52:	7111      	strb	r1, [r2, #4]
		bc[5] = (uint8)(sz);
    5d54:	7153      	strb	r3, [r2, #5]
		len = 7;
    5d56:	2107      	movs	r1, #7
		break;
    5d58:	e05c      	b.n	5e14 <spi_cmd+0x14c>
	case CMD_DMA_EXT_WRITE:		/* dma extended write */
	case CMD_DMA_EXT_READ:			/* dma extended read */
		bc[1] = (uint8)(adr >> 16);
    5d5a:	aa01      	add	r2, sp, #4
    5d5c:	0c08      	lsrs	r0, r1, #16
    5d5e:	7050      	strb	r0, [r2, #1]
		bc[2] = (uint8)(adr >> 8);
    5d60:	0a08      	lsrs	r0, r1, #8
    5d62:	7090      	strb	r0, [r2, #2]
		bc[3] = (uint8)adr;
    5d64:	70d1      	strb	r1, [r2, #3]
		bc[4] = (uint8)(sz >> 16);
    5d66:	0c19      	lsrs	r1, r3, #16
    5d68:	7111      	strb	r1, [r2, #4]
		bc[5] = (uint8)(sz >> 8);
    5d6a:	0a19      	lsrs	r1, r3, #8
    5d6c:	7151      	strb	r1, [r2, #5]
		bc[6] = (uint8)(sz);
    5d6e:	7193      	strb	r3, [r2, #6]
		len = 8;
    5d70:	2108      	movs	r1, #8
		break;
    5d72:	e04f      	b.n	5e14 <spi_cmd+0x14c>
	case CMD_INTERNAL_WRITE:		/* internal register write */
		bc[1] = (uint8)(adr >> 8);
    5d74:	0a0b      	lsrs	r3, r1, #8
    5d76:	b2db      	uxtb	r3, r3
		if(clockless)  bc[1] |= (1 << 7);
    5d78:	2d00      	cmp	r5, #0
    5d7a:	d102      	bne.n	5d82 <spi_cmd+0xba>
		bc[5] = (uint8)(sz >> 8);
		bc[6] = (uint8)(sz);
		len = 8;
		break;
	case CMD_INTERNAL_WRITE:		/* internal register write */
		bc[1] = (uint8)(adr >> 8);
    5d7c:	a801      	add	r0, sp, #4
    5d7e:	7043      	strb	r3, [r0, #1]
    5d80:	e004      	b.n	5d8c <spi_cmd+0xc4>
		if(clockless)  bc[1] |= (1 << 7);
    5d82:	2080      	movs	r0, #128	; 0x80
    5d84:	4240      	negs	r0, r0
    5d86:	4303      	orrs	r3, r0
    5d88:	a801      	add	r0, sp, #4
    5d8a:	7043      	strb	r3, [r0, #1]
		bc[2] = (uint8)(adr);
    5d8c:	ab01      	add	r3, sp, #4
    5d8e:	7099      	strb	r1, [r3, #2]
		bc[3] = (uint8)(u32data >> 24);
    5d90:	0e11      	lsrs	r1, r2, #24
    5d92:	70d9      	strb	r1, [r3, #3]
		bc[4] = (uint8)(u32data >> 16);
    5d94:	0c11      	lsrs	r1, r2, #16
    5d96:	7119      	strb	r1, [r3, #4]
		bc[5] = (uint8)(u32data >> 8);
    5d98:	0a11      	lsrs	r1, r2, #8
    5d9a:	7159      	strb	r1, [r3, #5]
		bc[6] = (uint8)(u32data);
    5d9c:	719a      	strb	r2, [r3, #6]
		len = 8;
    5d9e:	2108      	movs	r1, #8
		break;
    5da0:	e038      	b.n	5e14 <spi_cmd+0x14c>
	case CMD_SINGLE_WRITE:			/* single word write */
		bc[1] = (uint8)(adr >> 16);
    5da2:	ab01      	add	r3, sp, #4
    5da4:	0c08      	lsrs	r0, r1, #16
    5da6:	7058      	strb	r0, [r3, #1]
		bc[2] = (uint8)(adr >> 8);
    5da8:	0a08      	lsrs	r0, r1, #8
    5daa:	7098      	strb	r0, [r3, #2]
		bc[3] = (uint8)(adr);
    5dac:	70d9      	strb	r1, [r3, #3]
		bc[4] = (uint8)(u32data >> 24);
    5dae:	0e11      	lsrs	r1, r2, #24
    5db0:	7119      	strb	r1, [r3, #4]
		bc[5] = (uint8)(u32data >> 16);
    5db2:	0c11      	lsrs	r1, r2, #16
    5db4:	7159      	strb	r1, [r3, #5]
		bc[6] = (uint8)(u32data >> 8);
    5db6:	0a11      	lsrs	r1, r2, #8
    5db8:	7199      	strb	r1, [r3, #6]
		bc[7] = (uint8)(u32data);
    5dba:	71da      	strb	r2, [r3, #7]
		len = 9;
    5dbc:	2109      	movs	r1, #9
		break;
    5dbe:	e029      	b.n	5e14 <spi_cmd+0x14c>
};


static uint8 crc7_byte(uint8 crc, uint8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
    5dc0:	005b      	lsls	r3, r3, #1
    5dc2:	7810      	ldrb	r0, [r2, #0]
    5dc4:	4043      	eors	r3, r0
    5dc6:	5ce3      	ldrb	r3, [r4, r3]
    5dc8:	3201      	adds	r2, #1
}

static uint8 crc7(uint8 crc, const uint8 *buffer, uint32 len)
{
	while (len--)
    5dca:	4295      	cmp	r5, r2
    5dcc:	d1f8      	bne.n	5dc0 <spi_cmd+0xf8>
		break;
	}

	if (result) {
		if (!gu8Crc_off)
			bc[len-1] = (crc7(0x7f, (const uint8 *)&bc[0], len-1)) << 1;
    5dce:	005b      	lsls	r3, r3, #1
    5dd0:	aa01      	add	r2, sp, #4
    5dd2:	5593      	strb	r3, [r2, r6]
    5dd4:	e001      	b.n	5dda <spi_cmd+0x112>
		else
			len-=1;
    5dd6:	3901      	subs	r1, #1
    5dd8:	b2c9      	uxtb	r1, r1

		if (M2M_SUCCESS != nmi_spi_write(bc, len)) {
    5dda:	b289      	uxth	r1, r1
    5ddc:	a801      	add	r0, sp, #4
    5dde:	4b12      	ldr	r3, [pc, #72]	; (5e28 <spi_cmd+0x160>)
    5de0:	4798      	blx	r3
    5de2:	2301      	movs	r3, #1
    5de4:	2800      	cmp	r0, #0
    5de6:	d01a      	beq.n	5e1e <spi_cmd+0x156>
			M2M_ERR("[nmi spi]: Failed cmd write, bus error...\n");
    5de8:	2228      	movs	r2, #40	; 0x28
    5dea:	32ff      	adds	r2, #255	; 0xff
    5dec:	490f      	ldr	r1, [pc, #60]	; (5e2c <spi_cmd+0x164>)
    5dee:	4810      	ldr	r0, [pc, #64]	; (5e30 <spi_cmd+0x168>)
    5df0:	4b10      	ldr	r3, [pc, #64]	; (5e34 <spi_cmd+0x16c>)
    5df2:	4798      	blx	r3
    5df4:	4810      	ldr	r0, [pc, #64]	; (5e38 <spi_cmd+0x170>)
    5df6:	4b11      	ldr	r3, [pc, #68]	; (5e3c <spi_cmd+0x174>)
    5df8:	4798      	blx	r3
    5dfa:	200d      	movs	r0, #13
    5dfc:	4b10      	ldr	r3, [pc, #64]	; (5e40 <spi_cmd+0x178>)
    5dfe:	4798      	blx	r3
			result = N_FAIL;
    5e00:	2300      	movs	r3, #0
    5e02:	e00c      	b.n	5e1e <spi_cmd+0x156>
	uint8 bc[9];
	uint8 len = 5;
	sint8 result = N_OK;

	bc[0] = cmd;
	switch (cmd) {
    5e04:	2300      	movs	r3, #0
    5e06:	e00a      	b.n	5e1e <spi_cmd+0x156>
		break;
	}

	if (result) {
		if (!gu8Crc_off)
			bc[len-1] = (crc7(0x7f, (const uint8 *)&bc[0], len-1)) << 1;
    5e08:	1e4e      	subs	r6, r1, #1
    5e0a:	aa01      	add	r2, sp, #4
    5e0c:	1995      	adds	r5, r2, r6
    5e0e:	237f      	movs	r3, #127	; 0x7f
};


static uint8 crc7_byte(uint8 crc, uint8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
    5e10:	4c0c      	ldr	r4, [pc, #48]	; (5e44 <spi_cmd+0x17c>)
    5e12:	e7d5      	b.n	5dc0 <spi_cmd+0xf8>
		result = N_FAIL;
		break;
	}

	if (result) {
		if (!gu8Crc_off)
    5e14:	4b0c      	ldr	r3, [pc, #48]	; (5e48 <spi_cmd+0x180>)
    5e16:	781b      	ldrb	r3, [r3, #0]
    5e18:	2b00      	cmp	r3, #0
    5e1a:	d1dc      	bne.n	5dd6 <spi_cmd+0x10e>
    5e1c:	e7f4      	b.n	5e08 <spi_cmd+0x140>
			result = N_FAIL;
		}
	}

	return result;
}
    5e1e:	0018      	movs	r0, r3
    5e20:	b004      	add	sp, #16
    5e22:	bd70      	pop	{r4, r5, r6, pc}
    5e24:	000149d4 	.word	0x000149d4
    5e28:	00005ca9 	.word	0x00005ca9
    5e2c:	00014a40 	.word	0x00014a40
    5e30:	00014144 	.word	0x00014144
    5e34:	0001198d 	.word	0x0001198d
    5e38:	00014a68 	.word	0x00014a68
    5e3c:	00011aad 	.word	0x00011aad
    5e40:	000119c1 	.word	0x000119c1
    5e44:	00014fd8 	.word	0x00014fd8
    5e48:	200008d8 	.word	0x200008d8

00005e4c <nmi_spi_read>:
#define DATA_PKT_SZ				DATA_PKT_SZ_8K

static uint8 	gu8Crc_off	=   0;

static sint8 nmi_spi_read(uint8* b, uint16 sz)
{
    5e4c:	b500      	push	{lr}
    5e4e:	b085      	sub	sp, #20
	tstrNmSpiRw spi;
	spi.pu8InBuf = NULL;
    5e50:	ab01      	add	r3, sp, #4
    5e52:	2200      	movs	r2, #0
    5e54:	9201      	str	r2, [sp, #4]
	spi.pu8OutBuf = b;
    5e56:	9002      	str	r0, [sp, #8]
	spi.u16Sz = sz;
    5e58:	8119      	strh	r1, [r3, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
    5e5a:	0019      	movs	r1, r3
    5e5c:	2003      	movs	r0, #3
    5e5e:	4b02      	ldr	r3, [pc, #8]	; (5e68 <nmi_spi_read+0x1c>)
    5e60:	4798      	blx	r3
}
    5e62:	b005      	add	sp, #20
    5e64:	bd00      	pop	{pc}
    5e66:	46c0      	nop			; (mov r8, r8)
    5e68:	000040c5 	.word	0x000040c5

00005e6c <spi_cmd_rsp>:

	return result;
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
    5e6c:	b5f0      	push	{r4, r5, r6, r7, lr}
    5e6e:	b083      	sub	sp, #12
    5e70:	1e06      	subs	r6, r0, #0
	sint8 s8RetryCnt;

	/**
		Command/Control response
	**/
	if ((cmd == CMD_RESET) ||
    5e72:	2ecf      	cmp	r6, #207	; 0xcf
    5e74:	d004      	beq.n	5e80 <spi_cmd_rsp+0x14>
    5e76:	0003      	movs	r3, r0
    5e78:	333b      	adds	r3, #59	; 0x3b
    5e7a:	b2db      	uxtb	r3, r3
    5e7c:	2b01      	cmp	r3, #1
    5e7e:	d807      	bhi.n	5e90 <spi_cmd_rsp+0x24>
		 (cmd == CMD_TERMINATE) ||
		 (cmd == CMD_REPEAT)) {
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    5e80:	2101      	movs	r1, #1
    5e82:	466b      	mov	r3, sp
    5e84:	1dd8      	adds	r0, r3, #7
    5e86:	4b24      	ldr	r3, [pc, #144]	; (5f18 <spi_cmd_rsp+0xac>)
    5e88:	4798      	blx	r3
			result = N_FAIL;
    5e8a:	2300      	movs	r3, #0
		Command/Control response
	**/
	if ((cmd == CMD_RESET) ||
		 (cmd == CMD_TERMINATE) ||
		 (cmd == CMD_REPEAT)) {
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    5e8c:	2800      	cmp	r0, #0
    5e8e:	d140      	bne.n	5f12 <spi_cmd_rsp+0xa6>

	return result;
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
    5e90:	240b      	movs	r4, #11

	/* wait for response */
	s8RetryCnt = SPI_RESP_RETRY_COUNT;
	do
	{
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    5e92:	466b      	mov	r3, sp
    5e94:	1ddd      	adds	r5, r3, #7
    5e96:	4f20      	ldr	r7, [pc, #128]	; (5f18 <spi_cmd_rsp+0xac>)
    5e98:	2101      	movs	r1, #1
    5e9a:	0028      	movs	r0, r5
    5e9c:	47b8      	blx	r7
    5e9e:	2800      	cmp	r0, #0
    5ea0:	d00d      	beq.n	5ebe <spi_cmd_rsp+0x52>
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
    5ea2:	22b1      	movs	r2, #177	; 0xb1
    5ea4:	0052      	lsls	r2, r2, #1
    5ea6:	491d      	ldr	r1, [pc, #116]	; (5f1c <spi_cmd_rsp+0xb0>)
    5ea8:	481d      	ldr	r0, [pc, #116]	; (5f20 <spi_cmd_rsp+0xb4>)
    5eaa:	4b1e      	ldr	r3, [pc, #120]	; (5f24 <spi_cmd_rsp+0xb8>)
    5eac:	4798      	blx	r3
    5eae:	481e      	ldr	r0, [pc, #120]	; (5f28 <spi_cmd_rsp+0xbc>)
    5eb0:	4b1e      	ldr	r3, [pc, #120]	; (5f2c <spi_cmd_rsp+0xc0>)
    5eb2:	4798      	blx	r3
    5eb4:	200d      	movs	r0, #13
    5eb6:	4b1e      	ldr	r3, [pc, #120]	; (5f30 <spi_cmd_rsp+0xc4>)
    5eb8:	4798      	blx	r3
			result = N_FAIL;
    5eba:	2300      	movs	r3, #0
			goto _fail_;
    5ebc:	e029      	b.n	5f12 <spi_cmd_rsp+0xa6>
		}
	} while((rsp != cmd) && (s8RetryCnt-- >0));
    5ebe:	782b      	ldrb	r3, [r5, #0]
    5ec0:	42b3      	cmp	r3, r6
    5ec2:	d005      	beq.n	5ed0 <spi_cmd_rsp+0x64>
    5ec4:	3c01      	subs	r4, #1
    5ec6:	b2e4      	uxtb	r4, r4
    5ec8:	2c00      	cmp	r4, #0
    5eca:	d1e5      	bne.n	5e98 <spi_cmd_rsp+0x2c>
    5ecc:	340b      	adds	r4, #11
    5ece:	e000      	b.n	5ed2 <spi_cmd_rsp+0x66>
    5ed0:	240b      	movs	r4, #11
	**/
	/* wait for response */
	s8RetryCnt = SPI_RESP_RETRY_COUNT;
	do
	{
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    5ed2:	466b      	mov	r3, sp
    5ed4:	1ddd      	adds	r5, r3, #7
    5ed6:	4e10      	ldr	r6, [pc, #64]	; (5f18 <spi_cmd_rsp+0xac>)
    5ed8:	2101      	movs	r1, #1
    5eda:	0028      	movs	r0, r5
    5edc:	47b0      	blx	r6
    5ede:	2800      	cmp	r0, #0
    5ee0:	d00d      	beq.n	5efe <spi_cmd_rsp+0x92>
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
    5ee2:	22b8      	movs	r2, #184	; 0xb8
    5ee4:	0052      	lsls	r2, r2, #1
    5ee6:	490d      	ldr	r1, [pc, #52]	; (5f1c <spi_cmd_rsp+0xb0>)
    5ee8:	480d      	ldr	r0, [pc, #52]	; (5f20 <spi_cmd_rsp+0xb4>)
    5eea:	4b0e      	ldr	r3, [pc, #56]	; (5f24 <spi_cmd_rsp+0xb8>)
    5eec:	4798      	blx	r3
    5eee:	480e      	ldr	r0, [pc, #56]	; (5f28 <spi_cmd_rsp+0xbc>)
    5ef0:	4b0e      	ldr	r3, [pc, #56]	; (5f2c <spi_cmd_rsp+0xc0>)
    5ef2:	4798      	blx	r3
    5ef4:	200d      	movs	r0, #13
    5ef6:	4b0e      	ldr	r3, [pc, #56]	; (5f30 <spi_cmd_rsp+0xc4>)
    5ef8:	4798      	blx	r3
			result = N_FAIL;
    5efa:	2300      	movs	r3, #0
			goto _fail_;
    5efc:	e009      	b.n	5f12 <spi_cmd_rsp+0xa6>
		}
	} while((rsp != 0x00) && (s8RetryCnt-- >0));
    5efe:	782b      	ldrb	r3, [r5, #0]
    5f00:	2b00      	cmp	r3, #0
    5f02:	d005      	beq.n	5f10 <spi_cmd_rsp+0xa4>
    5f04:	3c01      	subs	r4, #1
    5f06:	b2e4      	uxtb	r4, r4
    5f08:	2c00      	cmp	r4, #0
    5f0a:	d1e5      	bne.n	5ed8 <spi_cmd_rsp+0x6c>
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
	uint8 rsp;
	sint8 result = N_OK;
    5f0c:	2301      	movs	r3, #1
    5f0e:	e000      	b.n	5f12 <spi_cmd_rsp+0xa6>
    5f10:	2301      	movs	r3, #1
	} while((rsp != 0x00) && (s8RetryCnt-- >0));

_fail_:

	return result;
}
    5f12:	0018      	movs	r0, r3
    5f14:	b003      	add	sp, #12
    5f16:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5f18:	00005e4d 	.word	0x00005e4d
    5f1c:	00014fac 	.word	0x00014fac
    5f20:	00014144 	.word	0x00014144
    5f24:	0001198d 	.word	0x0001198d
    5f28:	00014a94 	.word	0x00014a94
    5f2c:	00011aad 	.word	0x00011aad
    5f30:	000119c1 	.word	0x000119c1

00005f34 <spi_data_read>:
_error_:
	return result;
}
#endif
static sint8 spi_data_read(uint8 *b, uint16 sz,uint8 clockless)
{
    5f34:	b5f0      	push	{r4, r5, r6, r7, lr}
    5f36:	465f      	mov	r7, fp
    5f38:	4656      	mov	r6, sl
    5f3a:	464d      	mov	r5, r9
    5f3c:	4644      	mov	r4, r8
    5f3e:	b4f0      	push	{r4, r5, r6, r7}
    5f40:	b083      	sub	sp, #12
    5f42:	4682      	mov	sl, r0
    5f44:	4689      	mov	r9, r1
    5f46:	4693      	mov	fp, r2
	uint8 rsp;

	/**
		Data
	**/
	ix = 0;
    5f48:	2300      	movs	r3, #0
    5f4a:	4698      	mov	r8, r3
		/**
			Data Respnose header
		**/
		retry = SPI_RESP_RETRY_COUNT;
		do {
			if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    5f4c:	4f3c      	ldr	r7, [pc, #240]	; (6040 <spi_data_read+0x10c>)
	/**
		Data
	**/
	ix = 0;
	do {
		if (sz <= DATA_PKT_SZ)
    5f4e:	2380      	movs	r3, #128	; 0x80
    5f50:	019b      	lsls	r3, r3, #6
    5f52:	4599      	cmp	r9, r3
    5f54:	d802      	bhi.n	5f5c <spi_data_read+0x28>
			nbytes = sz;
    5f56:	464b      	mov	r3, r9
    5f58:	b21e      	sxth	r6, r3
    5f5a:	e001      	b.n	5f60 <spi_data_read+0x2c>
		else
			nbytes = DATA_PKT_SZ;
    5f5c:	2680      	movs	r6, #128	; 0x80
    5f5e:	01b6      	lsls	r6, r6, #6

		/**
			Data Respnose header
		**/
		retry = SPI_RESP_RETRY_COUNT;
    5f60:	240a      	movs	r4, #10
		do {
			if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    5f62:	466b      	mov	r3, sp
    5f64:	1cdd      	adds	r5, r3, #3
    5f66:	2101      	movs	r1, #1
    5f68:	0028      	movs	r0, r5
    5f6a:	47b8      	blx	r7
    5f6c:	2800      	cmp	r0, #0
    5f6e:	d00c      	beq.n	5f8a <spi_data_read+0x56>
				M2M_ERR("[nmi spi]: Failed data response read, bus error...\n");
    5f70:	4a34      	ldr	r2, [pc, #208]	; (6044 <spi_data_read+0x110>)
    5f72:	4935      	ldr	r1, [pc, #212]	; (6048 <spi_data_read+0x114>)
    5f74:	4835      	ldr	r0, [pc, #212]	; (604c <spi_data_read+0x118>)
    5f76:	4b36      	ldr	r3, [pc, #216]	; (6050 <spi_data_read+0x11c>)
    5f78:	4798      	blx	r3
    5f7a:	4836      	ldr	r0, [pc, #216]	; (6054 <spi_data_read+0x120>)
    5f7c:	4b36      	ldr	r3, [pc, #216]	; (6058 <spi_data_read+0x124>)
    5f7e:	4798      	blx	r3
    5f80:	200d      	movs	r0, #13
    5f82:	4b36      	ldr	r3, [pc, #216]	; (605c <spi_data_read+0x128>)
    5f84:	4798      	blx	r3
    5f86:	2000      	movs	r0, #0
    5f88:	e053      	b.n	6032 <spi_data_read+0xfe>
				result = N_FAIL;
				break;
			}
			if (((rsp >> 4) & 0xf) == 0xf)
    5f8a:	782b      	ldrb	r3, [r5, #0]
    5f8c:	091b      	lsrs	r3, r3, #4
    5f8e:	2b0f      	cmp	r3, #15
    5f90:	d004      	beq.n	5f9c <spi_data_read+0x68>
    5f92:	3c01      	subs	r4, #1
    5f94:	b224      	sxth	r4, r4
				break;
		} while (retry--);
    5f96:	1c63      	adds	r3, r4, #1
    5f98:	d1e5      	bne.n	5f66 <spi_data_read+0x32>
    5f9a:	e001      	b.n	5fa0 <spi_data_read+0x6c>

		if (result == N_FAIL)
			break;

		if (retry <= 0) {
    5f9c:	2c00      	cmp	r4, #0
    5f9e:	dc0d      	bgt.n	5fbc <spi_data_read+0x88>
			M2M_ERR("[nmi spi]: Failed data response read...(%02x)\n", rsp);
    5fa0:	4a2f      	ldr	r2, [pc, #188]	; (6060 <spi_data_read+0x12c>)
    5fa2:	4929      	ldr	r1, [pc, #164]	; (6048 <spi_data_read+0x114>)
    5fa4:	4829      	ldr	r0, [pc, #164]	; (604c <spi_data_read+0x118>)
    5fa6:	4c2a      	ldr	r4, [pc, #168]	; (6050 <spi_data_read+0x11c>)
    5fa8:	47a0      	blx	r4
    5faa:	466b      	mov	r3, sp
    5fac:	78d9      	ldrb	r1, [r3, #3]
    5fae:	482d      	ldr	r0, [pc, #180]	; (6064 <spi_data_read+0x130>)
    5fb0:	47a0      	blx	r4
    5fb2:	200d      	movs	r0, #13
    5fb4:	4b29      	ldr	r3, [pc, #164]	; (605c <spi_data_read+0x128>)
    5fb6:	4798      	blx	r3
			result = N_FAIL;
    5fb8:	2000      	movs	r0, #0
			break;
    5fba:	e03a      	b.n	6032 <spi_data_read+0xfe>
		}

		/**
			Read bytes
		**/
		if (M2M_SUCCESS != nmi_spi_read(&b[ix], nbytes)) {
    5fbc:	b2b6      	uxth	r6, r6
    5fbe:	4650      	mov	r0, sl
    5fc0:	4440      	add	r0, r8
    5fc2:	0031      	movs	r1, r6
    5fc4:	4b1e      	ldr	r3, [pc, #120]	; (6040 <spi_data_read+0x10c>)
    5fc6:	4798      	blx	r3
    5fc8:	2800      	cmp	r0, #0
    5fca:	d00d      	beq.n	5fe8 <spi_data_read+0xb4>
			M2M_ERR("[nmi spi]: Failed data block read, bus error...\n");
    5fcc:	22c5      	movs	r2, #197	; 0xc5
    5fce:	0092      	lsls	r2, r2, #2
    5fd0:	491d      	ldr	r1, [pc, #116]	; (6048 <spi_data_read+0x114>)
    5fd2:	481e      	ldr	r0, [pc, #120]	; (604c <spi_data_read+0x118>)
    5fd4:	4b1e      	ldr	r3, [pc, #120]	; (6050 <spi_data_read+0x11c>)
    5fd6:	4798      	blx	r3
    5fd8:	4823      	ldr	r0, [pc, #140]	; (6068 <spi_data_read+0x134>)
    5fda:	4b1f      	ldr	r3, [pc, #124]	; (6058 <spi_data_read+0x124>)
    5fdc:	4798      	blx	r3
    5fde:	200d      	movs	r0, #13
    5fe0:	4b1e      	ldr	r3, [pc, #120]	; (605c <spi_data_read+0x128>)
    5fe2:	4798      	blx	r3
			result = N_FAIL;
    5fe4:	2000      	movs	r0, #0
			break;
    5fe6:	e024      	b.n	6032 <spi_data_read+0xfe>
		}
		if(!clockless)
    5fe8:	465b      	mov	r3, fp
    5fea:	2b00      	cmp	r3, #0
    5fec:	d116      	bne.n	601c <spi_data_read+0xe8>
		{
			/**
			Read Crc
			**/
			if (!gu8Crc_off) {
    5fee:	4b1f      	ldr	r3, [pc, #124]	; (606c <spi_data_read+0x138>)
    5ff0:	781b      	ldrb	r3, [r3, #0]
    5ff2:	2b00      	cmp	r3, #0
    5ff4:	d112      	bne.n	601c <spi_data_read+0xe8>
				if (M2M_SUCCESS != nmi_spi_read(crc, 2)) {
    5ff6:	2102      	movs	r1, #2
    5ff8:	a801      	add	r0, sp, #4
    5ffa:	4b11      	ldr	r3, [pc, #68]	; (6040 <spi_data_read+0x10c>)
    5ffc:	4798      	blx	r3
    5ffe:	2800      	cmp	r0, #0
    6000:	d00c      	beq.n	601c <spi_data_read+0xe8>
					M2M_ERR("[nmi spi]: Failed data block crc read, bus error...\n");
    6002:	4a1b      	ldr	r2, [pc, #108]	; (6070 <spi_data_read+0x13c>)
    6004:	4910      	ldr	r1, [pc, #64]	; (6048 <spi_data_read+0x114>)
    6006:	4811      	ldr	r0, [pc, #68]	; (604c <spi_data_read+0x118>)
    6008:	4b11      	ldr	r3, [pc, #68]	; (6050 <spi_data_read+0x11c>)
    600a:	4798      	blx	r3
    600c:	4819      	ldr	r0, [pc, #100]	; (6074 <spi_data_read+0x140>)
    600e:	4b12      	ldr	r3, [pc, #72]	; (6058 <spi_data_read+0x124>)
    6010:	4798      	blx	r3
    6012:	200d      	movs	r0, #13
    6014:	4b11      	ldr	r3, [pc, #68]	; (605c <spi_data_read+0x128>)
    6016:	4798      	blx	r3
					result = N_FAIL;
    6018:	2000      	movs	r0, #0
					break;
    601a:	e00a      	b.n	6032 <spi_data_read+0xfe>
				}
			}
		}
		ix += nbytes;
    601c:	4643      	mov	r3, r8
    601e:	18f3      	adds	r3, r6, r3
    6020:	b21b      	sxth	r3, r3
    6022:	4698      	mov	r8, r3
		sz -= nbytes;
    6024:	464b      	mov	r3, r9
    6026:	1b9e      	subs	r6, r3, r6
    6028:	b2b3      	uxth	r3, r6
    602a:	4699      	mov	r9, r3

	} while (sz);
    602c:	2b00      	cmp	r3, #0
    602e:	d18e      	bne.n	5f4e <spi_data_read+0x1a>
    6030:	2001      	movs	r0, #1

	return result;
}
    6032:	b003      	add	sp, #12
    6034:	bc3c      	pop	{r2, r3, r4, r5}
    6036:	4690      	mov	r8, r2
    6038:	4699      	mov	r9, r3
    603a:	46a2      	mov	sl, r4
    603c:	46ab      	mov	fp, r5
    603e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6040:	00005e4d 	.word	0x00005e4d
    6044:	000002ff 	.word	0x000002ff
    6048:	00014fc8 	.word	0x00014fc8
    604c:	00014144 	.word	0x00014144
    6050:	0001198d 	.word	0x0001198d
    6054:	00014ac8 	.word	0x00014ac8
    6058:	00011aad 	.word	0x00011aad
    605c:	000119c1 	.word	0x000119c1
    6060:	0000030b 	.word	0x0000030b
    6064:	00014afc 	.word	0x00014afc
    6068:	00014b2c 	.word	0x00014b2c
    606c:	200008d8 	.word	0x200008d8
    6070:	0000031f 	.word	0x0000031f
    6074:	00014b5c 	.word	0x00014b5c

00006078 <spi_write_reg>:
	Spi interfaces

********************************************/

static sint8 spi_write_reg(uint32 addr, uint32 u32data)
{
    6078:	b5f0      	push	{r4, r5, r6, r7, lr}
    607a:	4657      	mov	r7, sl
    607c:	464e      	mov	r6, r9
    607e:	4645      	mov	r5, r8
    6080:	b4e0      	push	{r5, r6, r7}
    6082:	b086      	sub	sp, #24
    6084:	9003      	str	r0, [sp, #12]
    6086:	9104      	str	r1, [sp, #16]
    6088:	2830      	cmp	r0, #48	; 0x30
    608a:	d802      	bhi.n	6092 <spi_write_reg+0x1a>
    608c:	4b30      	ldr	r3, [pc, #192]	; (6150 <spi_write_reg+0xd8>)
    608e:	781f      	ldrb	r7, [r3, #0]
    6090:	e001      	b.n	6096 <spi_write_reg+0x1e>
    6092:	4b30      	ldr	r3, [pc, #192]	; (6154 <spi_write_reg+0xdc>)
    6094:	781f      	ldrb	r7, [r3, #0]
    6096:	b2fb      	uxtb	r3, r7
    6098:	9305      	str	r3, [sp, #20]
    609a:	2300      	movs	r3, #0
    609c:	2230      	movs	r2, #48	; 0x30
    609e:	9903      	ldr	r1, [sp, #12]
    60a0:	428a      	cmp	r2, r1
    60a2:	415b      	adcs	r3, r3
    60a4:	b2db      	uxtb	r3, r3
    60a6:	469a      	mov	sl, r3
    60a8:	250a      	movs	r5, #10
		cmd = CMD_SINGLE_WRITE;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, u32data, 4, clockless);
    60aa:	4b2b      	ldr	r3, [pc, #172]	; (6158 <spi_write_reg+0xe0>)
    60ac:	4698      	mov	r8, r3
		goto _FAIL_;
	}

	result = spi_cmd_rsp(cmd);
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed cmd response, write reg (%08x)...\n", (unsigned int)addr);
    60ae:	46d1      	mov	r9, sl
		cmd = CMD_SINGLE_WRITE;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, u32data, 4, clockless);
    60b0:	464b      	mov	r3, r9
    60b2:	9300      	str	r3, [sp, #0]
    60b4:	2304      	movs	r3, #4
    60b6:	9a04      	ldr	r2, [sp, #16]
    60b8:	9f03      	ldr	r7, [sp, #12]
    60ba:	0039      	movs	r1, r7
    60bc:	9805      	ldr	r0, [sp, #20]
    60be:	47c0      	blx	r8
    60c0:	1e04      	subs	r4, r0, #0
	if (result != N_OK) {
    60c2:	2c01      	cmp	r4, #1
    60c4:	d00b      	beq.n	60de <spi_write_reg+0x66>
		M2M_ERR("[nmi spi]: Failed cmd, write reg (%08x)...\n", (unsigned int)addr);
    60c6:	4a25      	ldr	r2, [pc, #148]	; (615c <spi_write_reg+0xe4>)
    60c8:	4925      	ldr	r1, [pc, #148]	; (6160 <spi_write_reg+0xe8>)
    60ca:	4826      	ldr	r0, [pc, #152]	; (6164 <spi_write_reg+0xec>)
    60cc:	4e26      	ldr	r6, [pc, #152]	; (6168 <spi_write_reg+0xf0>)
    60ce:	47b0      	blx	r6
    60d0:	0039      	movs	r1, r7
    60d2:	4826      	ldr	r0, [pc, #152]	; (616c <spi_write_reg+0xf4>)
    60d4:	47b0      	blx	r6
    60d6:	200d      	movs	r0, #13
    60d8:	4b25      	ldr	r3, [pc, #148]	; (6170 <spi_write_reg+0xf8>)
    60da:	4798      	blx	r3
		goto _FAIL_;
    60dc:	e011      	b.n	6102 <spi_write_reg+0x8a>
	}

	result = spi_cmd_rsp(cmd);
    60de:	9805      	ldr	r0, [sp, #20]
    60e0:	4b24      	ldr	r3, [pc, #144]	; (6174 <spi_write_reg+0xfc>)
    60e2:	4798      	blx	r3
    60e4:	1e04      	subs	r4, r0, #0
	if (result != N_OK) {
    60e6:	2c01      	cmp	r4, #1
    60e8:	d02a      	beq.n	6140 <spi_write_reg+0xc8>
		M2M_ERR("[nmi spi]: Failed cmd response, write reg (%08x)...\n", (unsigned int)addr);
    60ea:	22e7      	movs	r2, #231	; 0xe7
    60ec:	0092      	lsls	r2, r2, #2
    60ee:	491c      	ldr	r1, [pc, #112]	; (6160 <spi_write_reg+0xe8>)
    60f0:	481c      	ldr	r0, [pc, #112]	; (6164 <spi_write_reg+0xec>)
    60f2:	4e1d      	ldr	r6, [pc, #116]	; (6168 <spi_write_reg+0xf0>)
    60f4:	47b0      	blx	r6
    60f6:	9903      	ldr	r1, [sp, #12]
    60f8:	481f      	ldr	r0, [pc, #124]	; (6178 <spi_write_reg+0x100>)
    60fa:	47b0      	blx	r6
    60fc:	200d      	movs	r0, #13
    60fe:	4b1c      	ldr	r3, [pc, #112]	; (6170 <spi_write_reg+0xf8>)
    6100:	4798      	blx	r3

#endif
_FAIL_:
	if(result != N_OK)
	{
		nm_bsp_sleep(1);
    6102:	2001      	movs	r0, #1
    6104:	4e1d      	ldr	r6, [pc, #116]	; (617c <spi_write_reg+0x104>)
    6106:	47b0      	blx	r6
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    6108:	2300      	movs	r3, #0
    610a:	9300      	str	r3, [sp, #0]
    610c:	2200      	movs	r2, #0
    610e:	2100      	movs	r1, #0
    6110:	20cf      	movs	r0, #207	; 0xcf
    6112:	4f11      	ldr	r7, [pc, #68]	; (6158 <spi_write_reg+0xe0>)
    6114:	47b8      	blx	r7
		spi_cmd_rsp(CMD_RESET);
    6116:	20cf      	movs	r0, #207	; 0xcf
    6118:	4b16      	ldr	r3, [pc, #88]	; (6174 <spi_write_reg+0xfc>)
    611a:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx %lx\n",retry,addr,u32data);
    611c:	4a18      	ldr	r2, [pc, #96]	; (6180 <spi_write_reg+0x108>)
    611e:	4910      	ldr	r1, [pc, #64]	; (6160 <spi_write_reg+0xe8>)
    6120:	4810      	ldr	r0, [pc, #64]	; (6164 <spi_write_reg+0xec>)
    6122:	4f11      	ldr	r7, [pc, #68]	; (6168 <spi_write_reg+0xf0>)
    6124:	47b8      	blx	r7
    6126:	9b04      	ldr	r3, [sp, #16]
    6128:	9a03      	ldr	r2, [sp, #12]
    612a:	0029      	movs	r1, r5
    612c:	4815      	ldr	r0, [pc, #84]	; (6184 <spi_write_reg+0x10c>)
    612e:	47b8      	blx	r7
    6130:	200d      	movs	r0, #13
    6132:	4b0f      	ldr	r3, [pc, #60]	; (6170 <spi_write_reg+0xf8>)
    6134:	4798      	blx	r3
		nm_bsp_sleep(1);
    6136:	2001      	movs	r0, #1
    6138:	47b0      	blx	r6
    613a:	3d01      	subs	r5, #1
		retry--;
		if(retry) goto _RETRY_;
    613c:	2d00      	cmp	r5, #0
    613e:	d1b7      	bne.n	60b0 <spi_write_reg+0x38>
	}

	return result;
}
    6140:	0020      	movs	r0, r4
    6142:	b006      	add	sp, #24
    6144:	bc1c      	pop	{r2, r3, r4}
    6146:	4690      	mov	r8, r2
    6148:	4699      	mov	r9, r3
    614a:	46a2      	mov	sl, r4
    614c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    614e:	46c0      	nop			; (mov r8, r8)
    6150:	00014a10 	.word	0x00014a10
    6154:	00014a11 	.word	0x00014a11
    6158:	00005cc9 	.word	0x00005cc9
    615c:	00000396 	.word	0x00000396
    6160:	00014a30 	.word	0x00014a30
    6164:	00014144 	.word	0x00014144
    6168:	0001198d 	.word	0x0001198d
    616c:	00014b90 	.word	0x00014b90
    6170:	000119c1 	.word	0x000119c1
    6174:	00005e6d 	.word	0x00005e6d
    6178:	00014bbc 	.word	0x00014bbc
    617c:	00003e6d 	.word	0x00003e6d
    6180:	000003af 	.word	0x000003af
    6184:	00014bf4 	.word	0x00014bf4

00006188 <spi_read_reg>:

	return result;
}

static sint8 spi_read_reg(uint32 addr, uint32 *u32data)
{
    6188:	b5f0      	push	{r4, r5, r6, r7, lr}
    618a:	465f      	mov	r7, fp
    618c:	4656      	mov	r6, sl
    618e:	464d      	mov	r5, r9
    6190:	4644      	mov	r4, r8
    6192:	b4f0      	push	{r4, r5, r6, r7}
    6194:	b087      	sub	sp, #28
    6196:	9002      	str	r0, [sp, #8]
    6198:	468b      	mov	fp, r1
    619a:	28ff      	cmp	r0, #255	; 0xff
    619c:	d802      	bhi.n	61a4 <spi_read_reg+0x1c>
    619e:	4b41      	ldr	r3, [pc, #260]	; (62a4 <spi_read_reg+0x11c>)
    61a0:	781f      	ldrb	r7, [r3, #0]
    61a2:	e001      	b.n	61a8 <spi_read_reg+0x20>
    61a4:	4b40      	ldr	r3, [pc, #256]	; (62a8 <spi_read_reg+0x120>)
    61a6:	781f      	ldrb	r7, [r3, #0]
    61a8:	b2fb      	uxtb	r3, r7
    61aa:	9303      	str	r3, [sp, #12]
    61ac:	2300      	movs	r3, #0
    61ae:	22ff      	movs	r2, #255	; 0xff
    61b0:	9902      	ldr	r1, [sp, #8]
    61b2:	428a      	cmp	r2, r1
    61b4:	415b      	adcs	r3, r3
    61b6:	b2db      	uxtb	r3, r3
    61b8:	469a      	mov	sl, r3
    61ba:	250a      	movs	r5, #10
		cmd = CMD_SINGLE_READ;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, 4, clockless);
    61bc:	4b3b      	ldr	r3, [pc, #236]	; (62ac <spi_read_reg+0x124>)
    61be:	4698      	mov	r8, r3
		M2M_ERR("[nmi spi]: Failed cmd response, read reg (%08x)...\n", (unsigned int)addr);
		goto _FAIL_;
	}

	/* to avoid endianess issues */
	result = spi_data_read(&tmp[0], 4, clockless);
    61c0:	46d1      	mov	r9, sl
		cmd = CMD_SINGLE_READ;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, 4, clockless);
    61c2:	464b      	mov	r3, r9
    61c4:	9300      	str	r3, [sp, #0]
    61c6:	2304      	movs	r3, #4
    61c8:	2200      	movs	r2, #0
    61ca:	9f02      	ldr	r7, [sp, #8]
    61cc:	0039      	movs	r1, r7
    61ce:	9803      	ldr	r0, [sp, #12]
    61d0:	47c0      	blx	r8
    61d2:	1e04      	subs	r4, r0, #0
	if (result != N_OK) {
    61d4:	2c01      	cmp	r4, #1
    61d6:	d00b      	beq.n	61f0 <spi_read_reg+0x68>
		M2M_ERR("[nmi spi]: Failed cmd, read reg (%08x)...\n", (unsigned int)addr);
    61d8:	4a35      	ldr	r2, [pc, #212]	; (62b0 <spi_read_reg+0x128>)
    61da:	4936      	ldr	r1, [pc, #216]	; (62b4 <spi_read_reg+0x12c>)
    61dc:	4836      	ldr	r0, [pc, #216]	; (62b8 <spi_read_reg+0x130>)
    61de:	4e37      	ldr	r6, [pc, #220]	; (62bc <spi_read_reg+0x134>)
    61e0:	47b0      	blx	r6
    61e2:	0039      	movs	r1, r7
    61e4:	4836      	ldr	r0, [pc, #216]	; (62c0 <spi_read_reg+0x138>)
    61e6:	47b0      	blx	r6
    61e8:	200d      	movs	r0, #13
    61ea:	4b36      	ldr	r3, [pc, #216]	; (62c4 <spi_read_reg+0x13c>)
    61ec:	4798      	blx	r3
		goto _FAIL_;
    61ee:	e033      	b.n	6258 <spi_read_reg+0xd0>
	}

	result = spi_cmd_rsp(cmd);
    61f0:	9803      	ldr	r0, [sp, #12]
    61f2:	4b35      	ldr	r3, [pc, #212]	; (62c8 <spi_read_reg+0x140>)
    61f4:	4798      	blx	r3
    61f6:	1e04      	subs	r4, r0, #0
	if (result != N_OK) {
    61f8:	2c01      	cmp	r4, #1
    61fa:	d00b      	beq.n	6214 <spi_read_reg+0x8c>
		M2M_ERR("[nmi spi]: Failed cmd response, read reg (%08x)...\n", (unsigned int)addr);
    61fc:	4a33      	ldr	r2, [pc, #204]	; (62cc <spi_read_reg+0x144>)
    61fe:	492d      	ldr	r1, [pc, #180]	; (62b4 <spi_read_reg+0x12c>)
    6200:	482d      	ldr	r0, [pc, #180]	; (62b8 <spi_read_reg+0x130>)
    6202:	4e2e      	ldr	r6, [pc, #184]	; (62bc <spi_read_reg+0x134>)
    6204:	47b0      	blx	r6
    6206:	9902      	ldr	r1, [sp, #8]
    6208:	4831      	ldr	r0, [pc, #196]	; (62d0 <spi_read_reg+0x148>)
    620a:	47b0      	blx	r6
    620c:	200d      	movs	r0, #13
    620e:	4b2d      	ldr	r3, [pc, #180]	; (62c4 <spi_read_reg+0x13c>)
    6210:	4798      	blx	r3
		goto _FAIL_;
    6212:	e021      	b.n	6258 <spi_read_reg+0xd0>
	}

	/* to avoid endianess issues */
	result = spi_data_read(&tmp[0], 4, clockless);
    6214:	464a      	mov	r2, r9
    6216:	2104      	movs	r1, #4
    6218:	a805      	add	r0, sp, #20
    621a:	4b2e      	ldr	r3, [pc, #184]	; (62d4 <spi_read_reg+0x14c>)
    621c:	4798      	blx	r3
    621e:	1e04      	subs	r4, r0, #0
	if (result != N_OK) {
    6220:	2c01      	cmp	r4, #1
    6222:	d00b      	beq.n	623c <spi_read_reg+0xb4>
		M2M_ERR("[nmi spi]: Failed data read...\n");
    6224:	4a2c      	ldr	r2, [pc, #176]	; (62d8 <spi_read_reg+0x150>)
    6226:	4923      	ldr	r1, [pc, #140]	; (62b4 <spi_read_reg+0x12c>)
    6228:	4823      	ldr	r0, [pc, #140]	; (62b8 <spi_read_reg+0x130>)
    622a:	4b24      	ldr	r3, [pc, #144]	; (62bc <spi_read_reg+0x134>)
    622c:	4798      	blx	r3
    622e:	482b      	ldr	r0, [pc, #172]	; (62dc <spi_read_reg+0x154>)
    6230:	4b2b      	ldr	r3, [pc, #172]	; (62e0 <spi_read_reg+0x158>)
    6232:	4798      	blx	r3
    6234:	200d      	movs	r0, #13
    6236:	4b23      	ldr	r3, [pc, #140]	; (62c4 <spi_read_reg+0x13c>)
    6238:	4798      	blx	r3
		goto _FAIL_;
    623a:	e00d      	b.n	6258 <spi_read_reg+0xd0>
	}

#endif

	*u32data = tmp[0] |
		((uint32)tmp[1] << 8) |
    623c:	aa05      	add	r2, sp, #20
		goto _FAIL_;
	}

#endif

	*u32data = tmp[0] |
    623e:	7853      	ldrb	r3, [r2, #1]
    6240:	0219      	lsls	r1, r3, #8
    6242:	7893      	ldrb	r3, [r2, #2]
    6244:	041b      	lsls	r3, r3, #16
    6246:	430b      	orrs	r3, r1
    6248:	7811      	ldrb	r1, [r2, #0]
    624a:	430b      	orrs	r3, r1
    624c:	78d2      	ldrb	r2, [r2, #3]
    624e:	0612      	lsls	r2, r2, #24
    6250:	4313      	orrs	r3, r2
    6252:	465a      	mov	r2, fp
    6254:	6013      	str	r3, [r2, #0]
    6256:	e01d      	b.n	6294 <spi_read_reg+0x10c>
		
_FAIL_:
	if(result != N_OK)
	{
		
		nm_bsp_sleep(1);
    6258:	2001      	movs	r0, #1
    625a:	4e22      	ldr	r6, [pc, #136]	; (62e4 <spi_read_reg+0x15c>)
    625c:	47b0      	blx	r6
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    625e:	2300      	movs	r3, #0
    6260:	9300      	str	r3, [sp, #0]
    6262:	2200      	movs	r2, #0
    6264:	2100      	movs	r1, #0
    6266:	20cf      	movs	r0, #207	; 0xcf
    6268:	4f10      	ldr	r7, [pc, #64]	; (62ac <spi_read_reg+0x124>)
    626a:	47b8      	blx	r7
		spi_cmd_rsp(CMD_RESET);
    626c:	20cf      	movs	r0, #207	; 0xcf
    626e:	4b16      	ldr	r3, [pc, #88]	; (62c8 <spi_read_reg+0x140>)
    6270:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx\n",retry,addr);
    6272:	4a1d      	ldr	r2, [pc, #116]	; (62e8 <spi_read_reg+0x160>)
    6274:	490f      	ldr	r1, [pc, #60]	; (62b4 <spi_read_reg+0x12c>)
    6276:	4810      	ldr	r0, [pc, #64]	; (62b8 <spi_read_reg+0x130>)
    6278:	4f10      	ldr	r7, [pc, #64]	; (62bc <spi_read_reg+0x134>)
    627a:	47b8      	blx	r7
    627c:	9a02      	ldr	r2, [sp, #8]
    627e:	0029      	movs	r1, r5
    6280:	481a      	ldr	r0, [pc, #104]	; (62ec <spi_read_reg+0x164>)
    6282:	47b8      	blx	r7
    6284:	200d      	movs	r0, #13
    6286:	4b0f      	ldr	r3, [pc, #60]	; (62c4 <spi_read_reg+0x13c>)
    6288:	4798      	blx	r3
		nm_bsp_sleep(1);
    628a:	2001      	movs	r0, #1
    628c:	47b0      	blx	r6
    628e:	3d01      	subs	r5, #1
		retry--;
		if(retry) goto _RETRY_;
    6290:	2d00      	cmp	r5, #0
    6292:	d196      	bne.n	61c2 <spi_read_reg+0x3a>
	}
		
	return result;
}
    6294:	0020      	movs	r0, r4
    6296:	b007      	add	sp, #28
    6298:	bc3c      	pop	{r2, r3, r4, r5}
    629a:	4690      	mov	r8, r2
    629c:	4699      	mov	r9, r3
    629e:	46a2      	mov	sl, r4
    62a0:	46ab      	mov	fp, r5
    62a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    62a4:	00014a12 	.word	0x00014a12
    62a8:	00014a13 	.word	0x00014a13
    62ac:	00005cc9 	.word	0x00005cc9
    62b0:	00000417 	.word	0x00000417
    62b4:	00014fb8 	.word	0x00014fb8
    62b8:	00014144 	.word	0x00014144
    62bc:	0001198d 	.word	0x0001198d
    62c0:	00014c10 	.word	0x00014c10
    62c4:	000119c1 	.word	0x000119c1
    62c8:	00005e6d 	.word	0x00005e6d
    62cc:	0000041d 	.word	0x0000041d
    62d0:	00014c3c 	.word	0x00014c3c
    62d4:	00005f35 	.word	0x00005f35
    62d8:	00000424 	.word	0x00000424
    62dc:	00014c70 	.word	0x00014c70
    62e0:	00011aad 	.word	0x00011aad
    62e4:	00003e6d 	.word	0x00003e6d
    62e8:	0000043c 	.word	0x0000043c
    62ec:	00014c90 	.word	0x00014c90

000062f0 <nm_spi_reset>:
	}
	nm_spi_write_reg(SPI_BASE+0x24, val32);
}

sint8 nm_spi_reset(void)
{
    62f0:	b510      	push	{r4, lr}
    62f2:	b082      	sub	sp, #8
	spi_cmd(CMD_RESET, 0, 0, 0, 0);
    62f4:	2300      	movs	r3, #0
    62f6:	9300      	str	r3, [sp, #0]
    62f8:	2200      	movs	r2, #0
    62fa:	2100      	movs	r1, #0
    62fc:	20cf      	movs	r0, #207	; 0xcf
    62fe:	4c04      	ldr	r4, [pc, #16]	; (6310 <nm_spi_reset+0x20>)
    6300:	47a0      	blx	r4
	spi_cmd_rsp(CMD_RESET);
    6302:	20cf      	movs	r0, #207	; 0xcf
    6304:	4b03      	ldr	r3, [pc, #12]	; (6314 <nm_spi_reset+0x24>)
    6306:	4798      	blx	r3
	return M2M_SUCCESS;
}
    6308:	2000      	movs	r0, #0
    630a:	b002      	add	sp, #8
    630c:	bd10      	pop	{r4, pc}
    630e:	46c0      	nop			; (mov r8, r8)
    6310:	00005cc9 	.word	0x00005cc9
    6314:	00005e6d 	.word	0x00005e6d

00006318 <nm_spi_deinit>:
*	@date	27 Feb 2015
*	@version	1.0
*/ 
sint8 nm_spi_deinit(void)
{
	gu8Crc_off = 0;
    6318:	2200      	movs	r2, #0
    631a:	4b02      	ldr	r3, [pc, #8]	; (6324 <nm_spi_deinit+0xc>)
    631c:	701a      	strb	r2, [r3, #0]
	return M2M_SUCCESS;
}
    631e:	2000      	movs	r0, #0
    6320:	4770      	bx	lr
    6322:	46c0      	nop			; (mov r8, r8)
    6324:	200008d8 	.word	0x200008d8

00006328 <nm_spi_read_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
uint32 nm_spi_read_reg(uint32 u32Addr)
{
    6328:	b500      	push	{lr}
    632a:	b083      	sub	sp, #12
	uint32 u32Val;

	spi_read_reg(u32Addr, &u32Val);
    632c:	a901      	add	r1, sp, #4
    632e:	4b02      	ldr	r3, [pc, #8]	; (6338 <nm_spi_read_reg+0x10>)
    6330:	4798      	blx	r3

	return u32Val;
}
    6332:	9801      	ldr	r0, [sp, #4]
    6334:	b003      	add	sp, #12
    6336:	bd00      	pop	{pc}
    6338:	00006189 	.word	0x00006189

0000633c <nm_spi_read_reg_with_ret>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
{
    633c:	b510      	push	{r4, lr}
	sint8 s8Ret;

	s8Ret = spi_read_reg(u32Addr,pu32RetVal);
    633e:	4b04      	ldr	r3, [pc, #16]	; (6350 <nm_spi_read_reg_with_ret+0x14>)
    6340:	4798      	blx	r3

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    6342:	2300      	movs	r3, #0
    6344:	2801      	cmp	r0, #1
    6346:	d000      	beq.n	634a <nm_spi_read_reg_with_ret+0xe>
	else s8Ret = M2M_ERR_BUS_FAIL;
    6348:	3b06      	subs	r3, #6

	return s8Ret;
}
    634a:	0018      	movs	r0, r3
    634c:	bd10      	pop	{r4, pc}
    634e:	46c0      	nop			; (mov r8, r8)
    6350:	00006189 	.word	0x00006189

00006354 <nm_spi_write_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_write_reg(uint32 u32Addr, uint32 u32Val)
{
    6354:	b510      	push	{r4, lr}
	sint8 s8Ret;

	s8Ret = spi_write_reg(u32Addr, u32Val);
    6356:	4b04      	ldr	r3, [pc, #16]	; (6368 <nm_spi_write_reg+0x14>)
    6358:	4798      	blx	r3

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    635a:	2300      	movs	r3, #0
    635c:	2801      	cmp	r0, #1
    635e:	d000      	beq.n	6362 <nm_spi_write_reg+0xe>
	else s8Ret = M2M_ERR_BUS_FAIL;
    6360:	3b06      	subs	r3, #6

	return s8Ret;
}
    6362:	0018      	movs	r0, r3
    6364:	bd10      	pop	{r4, pc}
    6366:	46c0      	nop			; (mov r8, r8)
    6368:	00006079 	.word	0x00006079

0000636c <nm_spi_init>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_init(void)
{
    636c:	b510      	push	{r4, lr}
    636e:	b082      	sub	sp, #8
	uint32 chipid;
	uint32 reg = 0;
    6370:	2300      	movs	r3, #0
    6372:	9300      	str	r3, [sp, #0]
	

	/**
		configure protocol
	**/
	gu8Crc_off = 0;
    6374:	4a35      	ldr	r2, [pc, #212]	; (644c <nm_spi_init+0xe0>)
    6376:	7013      	strb	r3, [r2, #0]

	// TODO: We can remove the CRC trials if there is a definite way to reset
	// the SPI to it's initial value.
	if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)) {
    6378:	4669      	mov	r1, sp
    637a:	4835      	ldr	r0, [pc, #212]	; (6450 <nm_spi_init+0xe4>)
    637c:	4b35      	ldr	r3, [pc, #212]	; (6454 <nm_spi_init+0xe8>)
    637e:	4798      	blx	r3
    6380:	2800      	cmp	r0, #0
    6382:	d11f      	bne.n	63c4 <nm_spi_init+0x58>
		/* Read failed. Try with CRC off. This might happen when module
		is removed but chip isn't reset*/
		gu8Crc_off = 1;
    6384:	2201      	movs	r2, #1
    6386:	4b31      	ldr	r3, [pc, #196]	; (644c <nm_spi_init+0xe0>)
    6388:	701a      	strb	r2, [r3, #0]
		M2M_ERR("[nmi spi]: Failed internal read protocol with CRC on, retyring with CRC off...\n");
    638a:	4a33      	ldr	r2, [pc, #204]	; (6458 <nm_spi_init+0xec>)
    638c:	4933      	ldr	r1, [pc, #204]	; (645c <nm_spi_init+0xf0>)
    638e:	4834      	ldr	r0, [pc, #208]	; (6460 <nm_spi_init+0xf4>)
    6390:	4b34      	ldr	r3, [pc, #208]	; (6464 <nm_spi_init+0xf8>)
    6392:	4798      	blx	r3
    6394:	4834      	ldr	r0, [pc, #208]	; (6468 <nm_spi_init+0xfc>)
    6396:	4b35      	ldr	r3, [pc, #212]	; (646c <nm_spi_init+0x100>)
    6398:	4798      	blx	r3
    639a:	200d      	movs	r0, #13
    639c:	4b34      	ldr	r3, [pc, #208]	; (6470 <nm_spi_init+0x104>)
    639e:	4798      	blx	r3
		if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)){
    63a0:	4669      	mov	r1, sp
    63a2:	482b      	ldr	r0, [pc, #172]	; (6450 <nm_spi_init+0xe4>)
    63a4:	4b2b      	ldr	r3, [pc, #172]	; (6454 <nm_spi_init+0xe8>)
    63a6:	4798      	blx	r3
    63a8:	1e04      	subs	r4, r0, #0
    63aa:	d10b      	bne.n	63c4 <nm_spi_init+0x58>
			// Reaad failed with both CRC on and off, something went bad
			M2M_ERR( "[nmi spi]: Failed internal read protocol...\n");
    63ac:	4a31      	ldr	r2, [pc, #196]	; (6474 <nm_spi_init+0x108>)
    63ae:	492b      	ldr	r1, [pc, #172]	; (645c <nm_spi_init+0xf0>)
    63b0:	482b      	ldr	r0, [pc, #172]	; (6460 <nm_spi_init+0xf4>)
    63b2:	4b2c      	ldr	r3, [pc, #176]	; (6464 <nm_spi_init+0xf8>)
    63b4:	4798      	blx	r3
    63b6:	4830      	ldr	r0, [pc, #192]	; (6478 <nm_spi_init+0x10c>)
    63b8:	4b2c      	ldr	r3, [pc, #176]	; (646c <nm_spi_init+0x100>)
    63ba:	4798      	blx	r3
    63bc:	200d      	movs	r0, #13
    63be:	4b2c      	ldr	r3, [pc, #176]	; (6470 <nm_spi_init+0x104>)
    63c0:	4798      	blx	r3
			return 0;
    63c2:	e03f      	b.n	6444 <nm_spi_init+0xd8>
		}
	}
	if(gu8Crc_off == 0)
    63c4:	4b21      	ldr	r3, [pc, #132]	; (644c <nm_spi_init+0xe0>)
    63c6:	781b      	ldrb	r3, [r3, #0]
    63c8:	2b00      	cmp	r3, #0
    63ca:	d119      	bne.n	6400 <nm_spi_init+0x94>
	{
		reg &= ~0xc;	/* disable crc checking */
		reg &= ~0x70;
		reg |= (0x5 << 4);
    63cc:	337c      	adds	r3, #124	; 0x7c
    63ce:	9900      	ldr	r1, [sp, #0]
    63d0:	4399      	bics	r1, r3
    63d2:	3b2c      	subs	r3, #44	; 0x2c
    63d4:	4319      	orrs	r1, r3
    63d6:	9100      	str	r1, [sp, #0]
		if (!spi_write_reg(NMI_SPI_PROTOCOL_CONFIG, reg)) {
    63d8:	481d      	ldr	r0, [pc, #116]	; (6450 <nm_spi_init+0xe4>)
    63da:	4b28      	ldr	r3, [pc, #160]	; (647c <nm_spi_init+0x110>)
    63dc:	4798      	blx	r3
    63de:	1e04      	subs	r4, r0, #0
    63e0:	d10b      	bne.n	63fa <nm_spi_init+0x8e>
			M2M_ERR( "[nmi spi]: Failed internal write protocol reg...\n");
    63e2:	4a27      	ldr	r2, [pc, #156]	; (6480 <nm_spi_init+0x114>)
    63e4:	491d      	ldr	r1, [pc, #116]	; (645c <nm_spi_init+0xf0>)
    63e6:	481e      	ldr	r0, [pc, #120]	; (6460 <nm_spi_init+0xf4>)
    63e8:	4b1e      	ldr	r3, [pc, #120]	; (6464 <nm_spi_init+0xf8>)
    63ea:	4798      	blx	r3
    63ec:	4825      	ldr	r0, [pc, #148]	; (6484 <nm_spi_init+0x118>)
    63ee:	4b1f      	ldr	r3, [pc, #124]	; (646c <nm_spi_init+0x100>)
    63f0:	4798      	blx	r3
    63f2:	200d      	movs	r0, #13
    63f4:	4b1e      	ldr	r3, [pc, #120]	; (6470 <nm_spi_init+0x104>)
    63f6:	4798      	blx	r3
			return 0;
    63f8:	e024      	b.n	6444 <nm_spi_init+0xd8>
		}
		gu8Crc_off = 1;
    63fa:	2201      	movs	r2, #1
    63fc:	4b13      	ldr	r3, [pc, #76]	; (644c <nm_spi_init+0xe0>)
    63fe:	701a      	strb	r2, [r3, #0]
	}

	/**
		make sure can read back chip id correctly
	**/
	if (!spi_read_reg(0x1000, &chipid)) {
    6400:	a901      	add	r1, sp, #4
    6402:	2080      	movs	r0, #128	; 0x80
    6404:	0140      	lsls	r0, r0, #5
    6406:	4b13      	ldr	r3, [pc, #76]	; (6454 <nm_spi_init+0xe8>)
    6408:	4798      	blx	r3
    640a:	2800      	cmp	r0, #0
    640c:	d10d      	bne.n	642a <nm_spi_init+0xbe>
		M2M_ERR("[nmi spi]: Fail cmd read chip id...\n");
    640e:	4a1e      	ldr	r2, [pc, #120]	; (6488 <nm_spi_init+0x11c>)
    6410:	4912      	ldr	r1, [pc, #72]	; (645c <nm_spi_init+0xf0>)
    6412:	4813      	ldr	r0, [pc, #76]	; (6460 <nm_spi_init+0xf4>)
    6414:	4b13      	ldr	r3, [pc, #76]	; (6464 <nm_spi_init+0xf8>)
    6416:	4798      	blx	r3
    6418:	481c      	ldr	r0, [pc, #112]	; (648c <nm_spi_init+0x120>)
    641a:	4b14      	ldr	r3, [pc, #80]	; (646c <nm_spi_init+0x100>)
    641c:	4798      	blx	r3
    641e:	200d      	movs	r0, #13
    6420:	4b13      	ldr	r3, [pc, #76]	; (6470 <nm_spi_init+0x104>)
    6422:	4798      	blx	r3
		return M2M_ERR_BUS_FAIL;
    6424:	2406      	movs	r4, #6
    6426:	4264      	negs	r4, r4
    6428:	e00c      	b.n	6444 <nm_spi_init+0xd8>
static void spi_init_pkt_sz(void)
{
	uint32 val32;

	/* Make sure SPI max. packet size fits the defined DATA_PKT_SZ.  */
	val32 = nm_spi_read_reg(SPI_BASE+0x24);
    642a:	4c09      	ldr	r4, [pc, #36]	; (6450 <nm_spi_init+0xe4>)
    642c:	0020      	movs	r0, r4
    642e:	4b18      	ldr	r3, [pc, #96]	; (6490 <nm_spi_init+0x124>)
    6430:	4798      	blx	r3
	val32 &= ~(0x7 << 4);
    6432:	2370      	movs	r3, #112	; 0x70
    6434:	0001      	movs	r1, r0
    6436:	4399      	bics	r1, r3
	case 2048: val32 |= (3 << 4); break;
	case 4096: val32 |= (4 << 4); break;
	case 8192: val32 |= (5 << 4); break;

	}
	nm_spi_write_reg(SPI_BASE+0x24, val32);
    6438:	3b20      	subs	r3, #32
    643a:	4319      	orrs	r1, r3
    643c:	0020      	movs	r0, r4
    643e:	4b15      	ldr	r3, [pc, #84]	; (6494 <nm_spi_init+0x128>)
    6440:	4798      	blx	r3

	M2M_DBG("[nmi spi]: chipid (%08x)\n", (unsigned int)chipid);
	spi_init_pkt_sz();


	return M2M_SUCCESS;
    6442:	2400      	movs	r4, #0
}
    6444:	0020      	movs	r0, r4
    6446:	b002      	add	sp, #8
    6448:	bd10      	pop	{r4, pc}
    644a:	46c0      	nop			; (mov r8, r8)
    644c:	200008d8 	.word	0x200008d8
    6450:	0000e824 	.word	0x0000e824
    6454:	00006189 	.word	0x00006189
    6458:	000004c7 	.word	0x000004c7
    645c:	000150d8 	.word	0x000150d8
    6460:	00014144 	.word	0x00014144
    6464:	0001198d 	.word	0x0001198d
    6468:	00014ca8 	.word	0x00014ca8
    646c:	00011aad 	.word	0x00011aad
    6470:	000119c1 	.word	0x000119c1
    6474:	000004ca 	.word	0x000004ca
    6478:	00014cf8 	.word	0x00014cf8
    647c:	00006079 	.word	0x00006079
    6480:	000004d4 	.word	0x000004d4
    6484:	00014d24 	.word	0x00014d24
    6488:	000004de 	.word	0x000004de
    648c:	00014d58 	.word	0x00014d58
    6490:	00006329 	.word	0x00006329
    6494:	00006355 	.word	0x00006355

00006498 <nm_spi_read_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
    6498:	b5f0      	push	{r4, r5, r6, r7, lr}
    649a:	465f      	mov	r7, fp
    649c:	4656      	mov	r6, sl
    649e:	464d      	mov	r5, r9
    64a0:	4644      	mov	r4, r8
    64a2:	b4f0      	push	{r4, r5, r6, r7}
    64a4:	b087      	sub	sp, #28
    64a6:	9002      	str	r0, [sp, #8]
    64a8:	9103      	str	r1, [sp, #12]
    64aa:	0016      	movs	r6, r2
    64ac:	250a      	movs	r5, #10
	uint8 cmd = CMD_DMA_EXT_READ;
	sint8 result;
	uint8 retry = SPI_RETRY_COUNT;
#if defined USE_OLD_SPI_SW
	uint8 tmp[2];
	uint8 single_byte_workaround = 0;
    64ae:	2300      	movs	r3, #0
    64b0:	469b      	mov	fp, r3
	{
		//Workaround hardware problem with single byte transfers over SPI bus
		size = 2;
		single_byte_workaround = 1;
	}
	result = spi_cmd(cmd, addr, 0, size,0);
    64b2:	2400      	movs	r4, #0
    64b4:	4b3e      	ldr	r3, [pc, #248]	; (65b0 <nm_spi_read_block+0x118>)
    64b6:	4698      	mov	r8, r3
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed cmd, read block (%08x)...\n", (unsigned int)addr);
		goto _FAIL_;
	}

	result = spi_cmd_rsp(cmd);
    64b8:	46a9      	mov	r9, r5

	/**
		Command
	**/
#if defined USE_OLD_SPI_SW
	if (size == 1)
    64ba:	2e01      	cmp	r6, #1
    64bc:	d102      	bne.n	64c4 <nm_spi_read_block+0x2c>
	{
		//Workaround hardware problem with single byte transfers over SPI bus
		size = 2;
		single_byte_workaround = 1;
    64be:	2301      	movs	r3, #1
    64c0:	469b      	mov	fp, r3
	**/
#if defined USE_OLD_SPI_SW
	if (size == 1)
	{
		//Workaround hardware problem with single byte transfers over SPI bus
		size = 2;
    64c2:	3601      	adds	r6, #1
		single_byte_workaround = 1;
	}
	result = spi_cmd(cmd, addr, 0, size,0);
    64c4:	9400      	str	r4, [sp, #0]
    64c6:	0033      	movs	r3, r6
    64c8:	0022      	movs	r2, r4
    64ca:	9d02      	ldr	r5, [sp, #8]
    64cc:	0029      	movs	r1, r5
    64ce:	20c8      	movs	r0, #200	; 0xc8
    64d0:	47c0      	blx	r8
	if (result != N_OK) {
    64d2:	2801      	cmp	r0, #1
    64d4:	d00b      	beq.n	64ee <nm_spi_read_block+0x56>
		M2M_ERR("[nmi spi]: Failed cmd, read block (%08x)...\n", (unsigned int)addr);
    64d6:	4a37      	ldr	r2, [pc, #220]	; (65b4 <nm_spi_read_block+0x11c>)
    64d8:	4937      	ldr	r1, [pc, #220]	; (65b8 <nm_spi_read_block+0x120>)
    64da:	4838      	ldr	r0, [pc, #224]	; (65bc <nm_spi_read_block+0x124>)
    64dc:	4f38      	ldr	r7, [pc, #224]	; (65c0 <nm_spi_read_block+0x128>)
    64de:	47b8      	blx	r7
    64e0:	0029      	movs	r1, r5
    64e2:	4838      	ldr	r0, [pc, #224]	; (65c4 <nm_spi_read_block+0x12c>)
    64e4:	47b8      	blx	r7
    64e6:	200d      	movs	r0, #13
    64e8:	4b37      	ldr	r3, [pc, #220]	; (65c8 <nm_spi_read_block+0x130>)
    64ea:	4798      	blx	r3
    64ec:	e032      	b.n	6554 <nm_spi_read_block+0xbc>
		goto _FAIL_;
	}

	result = spi_cmd_rsp(cmd);
    64ee:	20c8      	movs	r0, #200	; 0xc8
    64f0:	4b36      	ldr	r3, [pc, #216]	; (65cc <nm_spi_read_block+0x134>)
    64f2:	4798      	blx	r3
	if (result != N_OK) {
    64f4:	2801      	cmp	r0, #1
    64f6:	d00b      	beq.n	6510 <nm_spi_read_block+0x78>
		M2M_ERR("[nmi spi]: Failed cmd response, read block (%08x)...\n", (unsigned int)addr);
    64f8:	4a35      	ldr	r2, [pc, #212]	; (65d0 <nm_spi_read_block+0x138>)
    64fa:	492f      	ldr	r1, [pc, #188]	; (65b8 <nm_spi_read_block+0x120>)
    64fc:	482f      	ldr	r0, [pc, #188]	; (65bc <nm_spi_read_block+0x124>)
    64fe:	4f30      	ldr	r7, [pc, #192]	; (65c0 <nm_spi_read_block+0x128>)
    6500:	47b8      	blx	r7
    6502:	9902      	ldr	r1, [sp, #8]
    6504:	4833      	ldr	r0, [pc, #204]	; (65d4 <nm_spi_read_block+0x13c>)
    6506:	47b8      	blx	r7
    6508:	200d      	movs	r0, #13
    650a:	4b2f      	ldr	r3, [pc, #188]	; (65c8 <nm_spi_read_block+0x130>)
    650c:	4798      	blx	r3
    650e:	e021      	b.n	6554 <nm_spi_read_block+0xbc>
	}

	/**
		Data
	**/
	if (single_byte_workaround)
    6510:	465b      	mov	r3, fp
    6512:	2b00      	cmp	r3, #0
    6514:	d009      	beq.n	652a <nm_spi_read_block+0x92>
	{
		result = spi_data_read(tmp, size,0);
    6516:	af05      	add	r7, sp, #20
    6518:	0022      	movs	r2, r4
    651a:	0031      	movs	r1, r6
    651c:	0038      	movs	r0, r7
    651e:	4b2e      	ldr	r3, [pc, #184]	; (65d8 <nm_spi_read_block+0x140>)
    6520:	4798      	blx	r3
		buf[0] = tmp[0];
    6522:	783b      	ldrb	r3, [r7, #0]
    6524:	9a03      	ldr	r2, [sp, #12]
    6526:	7013      	strb	r3, [r2, #0]
    6528:	e004      	b.n	6534 <nm_spi_read_block+0x9c>
	}
	else
		result = spi_data_read(buf, size,0);
    652a:	0022      	movs	r2, r4
    652c:	0031      	movs	r1, r6
    652e:	9803      	ldr	r0, [sp, #12]
    6530:	4b29      	ldr	r3, [pc, #164]	; (65d8 <nm_spi_read_block+0x140>)
    6532:	4798      	blx	r3

	if (result != N_OK) {
    6534:	2801      	cmp	r0, #1
    6536:	d00b      	beq.n	6550 <nm_spi_read_block+0xb8>
		M2M_ERR("[nmi spi]: Failed block data read...\n");
    6538:	4a28      	ldr	r2, [pc, #160]	; (65dc <nm_spi_read_block+0x144>)
    653a:	491f      	ldr	r1, [pc, #124]	; (65b8 <nm_spi_read_block+0x120>)
    653c:	481f      	ldr	r0, [pc, #124]	; (65bc <nm_spi_read_block+0x124>)
    653e:	4b20      	ldr	r3, [pc, #128]	; (65c0 <nm_spi_read_block+0x128>)
    6540:	4798      	blx	r3
    6542:	4827      	ldr	r0, [pc, #156]	; (65e0 <nm_spi_read_block+0x148>)
    6544:	4b27      	ldr	r3, [pc, #156]	; (65e4 <nm_spi_read_block+0x14c>)
    6546:	4798      	blx	r3
    6548:	200d      	movs	r0, #13
    654a:	4b1f      	ldr	r3, [pc, #124]	; (65c8 <nm_spi_read_block+0x130>)
    654c:	4798      	blx	r3
    654e:	e001      	b.n	6554 <nm_spi_read_block+0xbc>
{
	sint8 s8Ret;

	s8Ret = nm_spi_read(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    6550:	2000      	movs	r0, #0
    6552:	e025      	b.n	65a0 <nm_spi_read_block+0x108>
#endif

_FAIL_:
	if(result != N_OK)
	{
		nm_bsp_sleep(1);
    6554:	2001      	movs	r0, #1
    6556:	4f24      	ldr	r7, [pc, #144]	; (65e8 <nm_spi_read_block+0x150>)
    6558:	47b8      	blx	r7
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    655a:	9400      	str	r4, [sp, #0]
    655c:	0023      	movs	r3, r4
    655e:	0022      	movs	r2, r4
    6560:	0021      	movs	r1, r4
    6562:	20cf      	movs	r0, #207	; 0xcf
    6564:	4d12      	ldr	r5, [pc, #72]	; (65b0 <nm_spi_read_block+0x118>)
    6566:	47a8      	blx	r5
		spi_cmd_rsp(CMD_RESET);
    6568:	20cf      	movs	r0, #207	; 0xcf
    656a:	4b18      	ldr	r3, [pc, #96]	; (65cc <nm_spi_read_block+0x134>)
    656c:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx %d\n",retry,addr,size);
    656e:	4a1f      	ldr	r2, [pc, #124]	; (65ec <nm_spi_read_block+0x154>)
    6570:	4911      	ldr	r1, [pc, #68]	; (65b8 <nm_spi_read_block+0x120>)
    6572:	4812      	ldr	r0, [pc, #72]	; (65bc <nm_spi_read_block+0x124>)
    6574:	4b12      	ldr	r3, [pc, #72]	; (65c0 <nm_spi_read_block+0x128>)
    6576:	469a      	mov	sl, r3
    6578:	4798      	blx	r3
    657a:	0033      	movs	r3, r6
    657c:	9a02      	ldr	r2, [sp, #8]
    657e:	4649      	mov	r1, r9
    6580:	481b      	ldr	r0, [pc, #108]	; (65f0 <nm_spi_read_block+0x158>)
    6582:	47d0      	blx	sl
    6584:	200d      	movs	r0, #13
    6586:	4b10      	ldr	r3, [pc, #64]	; (65c8 <nm_spi_read_block+0x130>)
    6588:	4798      	blx	r3
		nm_bsp_sleep(1);
    658a:	2001      	movs	r0, #1
    658c:	47b8      	blx	r7
    658e:	2301      	movs	r3, #1
    6590:	425b      	negs	r3, r3
    6592:	469c      	mov	ip, r3
    6594:	44e1      	add	r9, ip
		retry--;
		if(retry) goto _RETRY_;
    6596:	464b      	mov	r3, r9
    6598:	2b00      	cmp	r3, #0
    659a:	d18e      	bne.n	64ba <nm_spi_read_block+0x22>
	sint8 s8Ret;

	s8Ret = nm_spi_read(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
	else s8Ret = M2M_ERR_BUS_FAIL;
    659c:	2006      	movs	r0, #6
    659e:	4240      	negs	r0, r0

	return s8Ret;
}
    65a0:	b007      	add	sp, #28
    65a2:	bc3c      	pop	{r2, r3, r4, r5}
    65a4:	4690      	mov	r8, r2
    65a6:	4699      	mov	r9, r3
    65a8:	46a2      	mov	sl, r4
    65aa:	46ab      	mov	fp, r5
    65ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    65ae:	46c0      	nop			; (mov r8, r8)
    65b0:	00005cc9 	.word	0x00005cc9
    65b4:	0000045d 	.word	0x0000045d
    65b8:	00014a14 	.word	0x00014a14
    65bc:	00014144 	.word	0x00014144
    65c0:	0001198d 	.word	0x0001198d
    65c4:	00014d7c 	.word	0x00014d7c
    65c8:	000119c1 	.word	0x000119c1
    65cc:	00005e6d 	.word	0x00005e6d
    65d0:	00000463 	.word	0x00000463
    65d4:	00014dac 	.word	0x00014dac
    65d8:	00005f35 	.word	0x00005f35
    65dc:	00000473 	.word	0x00000473
    65e0:	00014de4 	.word	0x00014de4
    65e4:	00011aad 	.word	0x00011aad
    65e8:	00003e6d 	.word	0x00003e6d
    65ec:	00000484 	.word	0x00000484
    65f0:	00014e0c 	.word	0x00014e0c

000065f4 <nm_spi_write_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
    65f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    65f6:	465f      	mov	r7, fp
    65f8:	4656      	mov	r6, sl
    65fa:	464d      	mov	r5, r9
    65fc:	4644      	mov	r4, r8
    65fe:	b4f0      	push	{r4, r5, r6, r7}
    6600:	b089      	sub	sp, #36	; 0x24
    6602:	9004      	str	r0, [sp, #16]
    6604:	4688      	mov	r8, r1
    6606:	9203      	str	r2, [sp, #12]
    6608:	270a      	movs	r7, #10
#if defined USE_OLD_SPI_SW
	//Workaround hardware problem with single byte transfers over SPI bus
	if (size == 1)
		size = 2;

	result = spi_cmd(cmd, addr, 0, size,0);
    660a:	2600      	movs	r6, #0
    660c:	4b89      	ldr	r3, [pc, #548]	; (6834 <nm_spi_write_block+0x240>)
    660e:	469a      	mov	sl, r3
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed cmd, write block (%08x)...\n", (unsigned int)addr);
		goto _FAIL_;
	}

	result = spi_cmd_rsp(cmd);
    6610:	46b9      	mov	r9, r7
	/**
		Command
	**/
#if defined USE_OLD_SPI_SW
	//Workaround hardware problem with single byte transfers over SPI bus
	if (size == 1)
    6612:	9b03      	ldr	r3, [sp, #12]
    6614:	2b01      	cmp	r3, #1
    6616:	d101      	bne.n	661c <nm_spi_write_block+0x28>
		size = 2;
    6618:	3301      	adds	r3, #1
    661a:	9303      	str	r3, [sp, #12]

	result = spi_cmd(cmd, addr, 0, size,0);
    661c:	9600      	str	r6, [sp, #0]
    661e:	9b03      	ldr	r3, [sp, #12]
    6620:	0032      	movs	r2, r6
    6622:	9d04      	ldr	r5, [sp, #16]
    6624:	0029      	movs	r1, r5
    6626:	20c7      	movs	r0, #199	; 0xc7
    6628:	47d0      	blx	sl
	if (result != N_OK) {
    662a:	2801      	cmp	r0, #1
    662c:	d00b      	beq.n	6646 <nm_spi_write_block+0x52>
		M2M_ERR("[nmi spi]: Failed cmd, write block (%08x)...\n", (unsigned int)addr);
    662e:	4a82      	ldr	r2, [pc, #520]	; (6838 <nm_spi_write_block+0x244>)
    6630:	4982      	ldr	r1, [pc, #520]	; (683c <nm_spi_write_block+0x248>)
    6632:	4883      	ldr	r0, [pc, #524]	; (6840 <nm_spi_write_block+0x24c>)
    6634:	4c83      	ldr	r4, [pc, #524]	; (6844 <nm_spi_write_block+0x250>)
    6636:	47a0      	blx	r4
    6638:	0029      	movs	r1, r5
    663a:	4883      	ldr	r0, [pc, #524]	; (6848 <nm_spi_write_block+0x254>)
    663c:	47a0      	blx	r4
    663e:	200d      	movs	r0, #13
    6640:	4b82      	ldr	r3, [pc, #520]	; (684c <nm_spi_write_block+0x258>)
    6642:	4798      	blx	r3
    6644:	e0c9      	b.n	67da <nm_spi_write_block+0x1e6>
		goto _FAIL_;
	}

	result = spi_cmd_rsp(cmd);
    6646:	20c7      	movs	r0, #199	; 0xc7
    6648:	4b81      	ldr	r3, [pc, #516]	; (6850 <nm_spi_write_block+0x25c>)
    664a:	4798      	blx	r3
	if (result != N_OK) {
    664c:	2801      	cmp	r0, #1
    664e:	d00c      	beq.n	666a <nm_spi_write_block+0x76>
		M2M_ERR("[nmi spi ]: Failed cmd response, write block (%08x)...\n", (unsigned int)addr);
    6650:	22f4      	movs	r2, #244	; 0xf4
    6652:	0092      	lsls	r2, r2, #2
    6654:	4979      	ldr	r1, [pc, #484]	; (683c <nm_spi_write_block+0x248>)
    6656:	487a      	ldr	r0, [pc, #488]	; (6840 <nm_spi_write_block+0x24c>)
    6658:	4c7a      	ldr	r4, [pc, #488]	; (6844 <nm_spi_write_block+0x250>)
    665a:	47a0      	blx	r4
    665c:	9904      	ldr	r1, [sp, #16]
    665e:	487d      	ldr	r0, [pc, #500]	; (6854 <nm_spi_write_block+0x260>)
    6660:	47a0      	blx	r4
    6662:	200d      	movs	r0, #13
    6664:	4b79      	ldr	r3, [pc, #484]	; (684c <nm_spi_write_block+0x258>)
    6666:	4798      	blx	r3
    6668:	e0b7      	b.n	67da <nm_spi_write_block+0x1e6>
static sint8 spi_data_write(uint8 *b, uint16 sz)
{
	sint16 ix;
	uint16 nbytes;
	sint8 result = 1;
	uint8 cmd, order, crc[2] = {0};
    666a:	ab07      	add	r3, sp, #28
    666c:	801e      	strh	r6, [r3, #0]
    666e:	9c03      	ldr	r4, [sp, #12]
	//uint8 rsp;

	/**
		Data
	**/
	ix = 0;
    6670:	0037      	movs	r7, r6
    6672:	2380      	movs	r3, #128	; 0x80
    6674:	019b      	lsls	r3, r3, #6
    6676:	469b      	mov	fp, r3
    6678:	466a      	mov	r2, sp
    667a:	82d3      	strh	r3, [r2, #22]
    667c:	1c25      	adds	r5, r4, #0
    667e:	455c      	cmp	r4, fp
    6680:	d901      	bls.n	6686 <nm_spi_write_block+0x92>
    6682:	466b      	mov	r3, sp
    6684:	8add      	ldrh	r5, [r3, #22]
    6686:	b2ad      	uxth	r5, r5

		/**
			Write command
		**/
		cmd = 0xf0;
		if (ix == 0)  {
    6688:	2f00      	cmp	r7, #0
    668a:	d104      	bne.n	6696 <nm_spi_write_block+0xa2>
			if (sz <= DATA_PKT_SZ)
				order = 0x3;
    668c:	2303      	movs	r3, #3
		/**
			Write command
		**/
		cmd = 0xf0;
		if (ix == 0)  {
			if (sz <= DATA_PKT_SZ)
    668e:	455c      	cmp	r4, fp
    6690:	d906      	bls.n	66a0 <nm_spi_write_block+0xac>
				order = 0x3;
			else
				order = 0x1;
    6692:	3b02      	subs	r3, #2
    6694:	e004      	b.n	66a0 <nm_spi_write_block+0xac>
		} else {
			if (sz <= DATA_PKT_SZ)
				order = 0x3;
			else
				order = 0x2;
    6696:	0033      	movs	r3, r6
    6698:	465a      	mov	r2, fp
    669a:	42a2      	cmp	r2, r4
    669c:	4173      	adcs	r3, r6
    669e:	3302      	adds	r3, #2
		}
		cmd |= order;
    66a0:	200b      	movs	r0, #11
    66a2:	aa04      	add	r2, sp, #16
    66a4:	4694      	mov	ip, r2
    66a6:	4460      	add	r0, ip
    66a8:	2210      	movs	r2, #16
    66aa:	4252      	negs	r2, r2
    66ac:	4313      	orrs	r3, r2
    66ae:	7003      	strb	r3, [r0, #0]
		if (M2M_SUCCESS != nmi_spi_write(&cmd, 1)) {
    66b0:	2101      	movs	r1, #1
    66b2:	4b69      	ldr	r3, [pc, #420]	; (6858 <nm_spi_write_block+0x264>)
    66b4:	4798      	blx	r3
    66b6:	2800      	cmp	r0, #0
    66b8:	d00c      	beq.n	66d4 <nm_spi_write_block+0xe0>
			M2M_ERR("[nmi spi]: Failed data block cmd write, bus error...\n");
    66ba:	22d4      	movs	r2, #212	; 0xd4
    66bc:	0092      	lsls	r2, r2, #2
    66be:	4967      	ldr	r1, [pc, #412]	; (685c <nm_spi_write_block+0x268>)
    66c0:	485f      	ldr	r0, [pc, #380]	; (6840 <nm_spi_write_block+0x24c>)
    66c2:	4b60      	ldr	r3, [pc, #384]	; (6844 <nm_spi_write_block+0x250>)
    66c4:	4798      	blx	r3
    66c6:	4866      	ldr	r0, [pc, #408]	; (6860 <nm_spi_write_block+0x26c>)
    66c8:	4b66      	ldr	r3, [pc, #408]	; (6864 <nm_spi_write_block+0x270>)
    66ca:	4798      	blx	r3
    66cc:	200d      	movs	r0, #13
    66ce:	4b5f      	ldr	r3, [pc, #380]	; (684c <nm_spi_write_block+0x258>)
    66d0:	4798      	blx	r3
    66d2:	e059      	b.n	6788 <nm_spi_write_block+0x194>
		}

		/**
			Write data
		**/
		if (M2M_SUCCESS != nmi_spi_write(&b[ix], nbytes)) {
    66d4:	4643      	mov	r3, r8
    66d6:	19d8      	adds	r0, r3, r7
    66d8:	0029      	movs	r1, r5
    66da:	4b5f      	ldr	r3, [pc, #380]	; (6858 <nm_spi_write_block+0x264>)
    66dc:	4798      	blx	r3
    66de:	2800      	cmp	r0, #0
    66e0:	d00b      	beq.n	66fa <nm_spi_write_block+0x106>
			M2M_ERR("[nmi spi]: Failed data block write, bus error...\n");
    66e2:	4a61      	ldr	r2, [pc, #388]	; (6868 <nm_spi_write_block+0x274>)
    66e4:	495d      	ldr	r1, [pc, #372]	; (685c <nm_spi_write_block+0x268>)
    66e6:	4856      	ldr	r0, [pc, #344]	; (6840 <nm_spi_write_block+0x24c>)
    66e8:	4b56      	ldr	r3, [pc, #344]	; (6844 <nm_spi_write_block+0x250>)
    66ea:	4798      	blx	r3
    66ec:	485f      	ldr	r0, [pc, #380]	; (686c <nm_spi_write_block+0x278>)
    66ee:	4b5d      	ldr	r3, [pc, #372]	; (6864 <nm_spi_write_block+0x270>)
    66f0:	4798      	blx	r3
    66f2:	200d      	movs	r0, #13
    66f4:	4b55      	ldr	r3, [pc, #340]	; (684c <nm_spi_write_block+0x258>)
    66f6:	4798      	blx	r3
    66f8:	e046      	b.n	6788 <nm_spi_write_block+0x194>
		}

		/**
			Write Crc
		**/
		if (!gu8Crc_off) {
    66fa:	4b5d      	ldr	r3, [pc, #372]	; (6870 <nm_spi_write_block+0x27c>)
    66fc:	781b      	ldrb	r3, [r3, #0]
    66fe:	2b00      	cmp	r3, #0
    6700:	d111      	bne.n	6726 <nm_spi_write_block+0x132>
			if (M2M_SUCCESS != nmi_spi_write(crc, 2)) {
    6702:	2102      	movs	r1, #2
    6704:	a807      	add	r0, sp, #28
    6706:	4b54      	ldr	r3, [pc, #336]	; (6858 <nm_spi_write_block+0x264>)
    6708:	4798      	blx	r3
    670a:	2800      	cmp	r0, #0
    670c:	d00b      	beq.n	6726 <nm_spi_write_block+0x132>
				M2M_ERR("[nmi spi]: Failed data block crc write, bus error...\n");
    670e:	4a59      	ldr	r2, [pc, #356]	; (6874 <nm_spi_write_block+0x280>)
    6710:	4952      	ldr	r1, [pc, #328]	; (685c <nm_spi_write_block+0x268>)
    6712:	484b      	ldr	r0, [pc, #300]	; (6840 <nm_spi_write_block+0x24c>)
    6714:	4b4b      	ldr	r3, [pc, #300]	; (6844 <nm_spi_write_block+0x250>)
    6716:	4798      	blx	r3
    6718:	4857      	ldr	r0, [pc, #348]	; (6878 <nm_spi_write_block+0x284>)
    671a:	4b52      	ldr	r3, [pc, #328]	; (6864 <nm_spi_write_block+0x270>)
    671c:	4798      	blx	r3
    671e:	200d      	movs	r0, #13
    6720:	4b4a      	ldr	r3, [pc, #296]	; (684c <nm_spi_write_block+0x258>)
    6722:	4798      	blx	r3
    6724:	e030      	b.n	6788 <nm_spi_write_block+0x194>
				result = N_FAIL;
				break;
			}
		}

		ix += nbytes;
    6726:	19ef      	adds	r7, r5, r7
    6728:	b23f      	sxth	r7, r7
		sz -= nbytes;
    672a:	1b64      	subs	r4, r4, r5
    672c:	b2a4      	uxth	r4, r4
	} while (sz);
    672e:	2c00      	cmp	r4, #0
    6730:	d1a4      	bne.n	667c <nm_spi_write_block+0x88>
    6732:	e036      	b.n	67a2 <nm_spi_write_block+0x1ae>
		len = 2;
	else
		len = 3;

	if (M2M_SUCCESS != nmi_spi_read(&rsp[0], len)) {
		M2M_ERR("[nmi spi]: Failed bus error...\n");
    6734:	223c      	movs	r2, #60	; 0x3c
    6736:	32ff      	adds	r2, #255	; 0xff
    6738:	4950      	ldr	r1, [pc, #320]	; (687c <nm_spi_write_block+0x288>)
    673a:	4841      	ldr	r0, [pc, #260]	; (6840 <nm_spi_write_block+0x24c>)
    673c:	4b41      	ldr	r3, [pc, #260]	; (6844 <nm_spi_write_block+0x250>)
    673e:	4798      	blx	r3
    6740:	484f      	ldr	r0, [pc, #316]	; (6880 <nm_spi_write_block+0x28c>)
    6742:	4b48      	ldr	r3, [pc, #288]	; (6864 <nm_spi_write_block+0x270>)
    6744:	4798      	blx	r3
    6746:	200d      	movs	r0, #13
    6748:	4b40      	ldr	r3, [pc, #256]	; (684c <nm_spi_write_block+0x258>)
    674a:	4798      	blx	r3
    674c:	e036      	b.n	67bc <nm_spi_write_block+0x1c8>
		result = N_FAIL;
		goto _fail_;
	}
		
	if((rsp[len-1] != 0)||(rsp[len-2] != 0xC3))
    674e:	ab08      	add	r3, sp, #32
    6750:	191b      	adds	r3, r3, r4
    6752:	3b05      	subs	r3, #5
    6754:	781b      	ldrb	r3, [r3, #0]
    6756:	2b00      	cmp	r3, #0
    6758:	d106      	bne.n	6768 <nm_spi_write_block+0x174>
    675a:	ab08      	add	r3, sp, #32
    675c:	469c      	mov	ip, r3
    675e:	4464      	add	r4, ip
    6760:	3c06      	subs	r4, #6
    6762:	7823      	ldrb	r3, [r4, #0]
    6764:	2bc3      	cmp	r3, #195	; 0xc3
    6766:	d036      	beq.n	67d6 <nm_spi_write_block+0x1e2>
	{
		M2M_ERR("[nmi spi]: Failed data response read, %x %x %x\n",rsp[0],rsp[1],rsp[2]);
    6768:	22a1      	movs	r2, #161	; 0xa1
    676a:	0052      	lsls	r2, r2, #1
    676c:	4943      	ldr	r1, [pc, #268]	; (687c <nm_spi_write_block+0x288>)
    676e:	4834      	ldr	r0, [pc, #208]	; (6840 <nm_spi_write_block+0x24c>)
    6770:	4c34      	ldr	r4, [pc, #208]	; (6844 <nm_spi_write_block+0x250>)
    6772:	47a0      	blx	r4
    6774:	a907      	add	r1, sp, #28
    6776:	788b      	ldrb	r3, [r1, #2]
    6778:	784a      	ldrb	r2, [r1, #1]
    677a:	7809      	ldrb	r1, [r1, #0]
    677c:	4841      	ldr	r0, [pc, #260]	; (6884 <nm_spi_write_block+0x290>)
    677e:	47a0      	blx	r4
    6780:	200d      	movs	r0, #13
    6782:	4b32      	ldr	r3, [pc, #200]	; (684c <nm_spi_write_block+0x258>)
    6784:	4798      	blx	r3
    6786:	e019      	b.n	67bc <nm_spi_write_block+0x1c8>
	/**
		Data
	**/
	result = spi_data_write(buf, size);
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed block data write...\n");
    6788:	22f8      	movs	r2, #248	; 0xf8
    678a:	0092      	lsls	r2, r2, #2
    678c:	492b      	ldr	r1, [pc, #172]	; (683c <nm_spi_write_block+0x248>)
    678e:	482c      	ldr	r0, [pc, #176]	; (6840 <nm_spi_write_block+0x24c>)
    6790:	4b2c      	ldr	r3, [pc, #176]	; (6844 <nm_spi_write_block+0x250>)
    6792:	4798      	blx	r3
    6794:	483c      	ldr	r0, [pc, #240]	; (6888 <nm_spi_write_block+0x294>)
    6796:	4b33      	ldr	r3, [pc, #204]	; (6864 <nm_spi_write_block+0x270>)
    6798:	4798      	blx	r3
    679a:	200d      	movs	r0, #13
    679c:	4b2b      	ldr	r3, [pc, #172]	; (684c <nm_spi_write_block+0x258>)
    679e:	4798      	blx	r3
    67a0:	e01b      	b.n	67da <nm_spi_write_block+0x1e6>
{
	uint8 len;
	uint8 rsp[3];
	sint8 result = N_OK;

    if (!gu8Crc_off)
    67a2:	4b33      	ldr	r3, [pc, #204]	; (6870 <nm_spi_write_block+0x27c>)
    67a4:	781c      	ldrb	r4, [r3, #0]
		len = 2;
	else
		len = 3;
    67a6:	4263      	negs	r3, r4
    67a8:	4163      	adcs	r3, r4
    67aa:	2403      	movs	r4, #3
    67ac:	1ae4      	subs	r4, r4, r3

	if (M2M_SUCCESS != nmi_spi_read(&rsp[0], len)) {
    67ae:	b2a1      	uxth	r1, r4
    67b0:	a807      	add	r0, sp, #28
    67b2:	4b36      	ldr	r3, [pc, #216]	; (688c <nm_spi_write_block+0x298>)
    67b4:	4798      	blx	r3
    67b6:	2800      	cmp	r0, #0
    67b8:	d0c9      	beq.n	674e <nm_spi_write_block+0x15a>
    67ba:	e7bb      	b.n	6734 <nm_spi_write_block+0x140>
	/**
		Data RESP
	**/
	result = spi_data_rsp(cmd);
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed block data write...\n");
    67bc:	22fa      	movs	r2, #250	; 0xfa
    67be:	0092      	lsls	r2, r2, #2
    67c0:	491e      	ldr	r1, [pc, #120]	; (683c <nm_spi_write_block+0x248>)
    67c2:	481f      	ldr	r0, [pc, #124]	; (6840 <nm_spi_write_block+0x24c>)
    67c4:	4b1f      	ldr	r3, [pc, #124]	; (6844 <nm_spi_write_block+0x250>)
    67c6:	4798      	blx	r3
    67c8:	482f      	ldr	r0, [pc, #188]	; (6888 <nm_spi_write_block+0x294>)
    67ca:	4b26      	ldr	r3, [pc, #152]	; (6864 <nm_spi_write_block+0x270>)
    67cc:	4798      	blx	r3
    67ce:	200d      	movs	r0, #13
    67d0:	4b1e      	ldr	r3, [pc, #120]	; (684c <nm_spi_write_block+0x258>)
    67d2:	4798      	blx	r3
    67d4:	e001      	b.n	67da <nm_spi_write_block+0x1e6>
{
	sint8 s8Ret;

	s8Ret = nm_spi_write(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    67d6:	2000      	movs	r0, #0
    67d8:	e025      	b.n	6826 <nm_spi_write_block+0x232>
	}
	
_FAIL_:
	if(result != N_OK)
	{
		nm_bsp_sleep(1);
    67da:	2001      	movs	r0, #1
    67dc:	4c2c      	ldr	r4, [pc, #176]	; (6890 <nm_spi_write_block+0x29c>)
    67de:	47a0      	blx	r4
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    67e0:	9600      	str	r6, [sp, #0]
    67e2:	0033      	movs	r3, r6
    67e4:	0032      	movs	r2, r6
    67e6:	0031      	movs	r1, r6
    67e8:	20cf      	movs	r0, #207	; 0xcf
    67ea:	4d12      	ldr	r5, [pc, #72]	; (6834 <nm_spi_write_block+0x240>)
    67ec:	47a8      	blx	r5
		spi_cmd_rsp(CMD_RESET);
    67ee:	20cf      	movs	r0, #207	; 0xcf
    67f0:	4b17      	ldr	r3, [pc, #92]	; (6850 <nm_spi_write_block+0x25c>)
    67f2:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx %d\n",retry,addr,size);
    67f4:	4a27      	ldr	r2, [pc, #156]	; (6894 <nm_spi_write_block+0x2a0>)
    67f6:	4911      	ldr	r1, [pc, #68]	; (683c <nm_spi_write_block+0x248>)
    67f8:	4811      	ldr	r0, [pc, #68]	; (6840 <nm_spi_write_block+0x24c>)
    67fa:	4d12      	ldr	r5, [pc, #72]	; (6844 <nm_spi_write_block+0x250>)
    67fc:	47a8      	blx	r5
    67fe:	9b03      	ldr	r3, [sp, #12]
    6800:	9a04      	ldr	r2, [sp, #16]
    6802:	4649      	mov	r1, r9
    6804:	4824      	ldr	r0, [pc, #144]	; (6898 <nm_spi_write_block+0x2a4>)
    6806:	47a8      	blx	r5
    6808:	200d      	movs	r0, #13
    680a:	4b10      	ldr	r3, [pc, #64]	; (684c <nm_spi_write_block+0x258>)
    680c:	4798      	blx	r3
		nm_bsp_sleep(1);
    680e:	2001      	movs	r0, #1
    6810:	47a0      	blx	r4
    6812:	2301      	movs	r3, #1
    6814:	425b      	negs	r3, r3
    6816:	469c      	mov	ip, r3
    6818:	44e1      	add	r9, ip
		retry--;
		if(retry) goto _RETRY_;
    681a:	464b      	mov	r3, r9
    681c:	2b00      	cmp	r3, #0
    681e:	d000      	beq.n	6822 <nm_spi_write_block+0x22e>
    6820:	e6f7      	b.n	6612 <nm_spi_write_block+0x1e>
	sint8 s8Ret;

	s8Ret = nm_spi_write(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
	else s8Ret = M2M_ERR_BUS_FAIL;
    6822:	2006      	movs	r0, #6
    6824:	4240      	negs	r0, r0

	return s8Ret;
}
    6826:	b009      	add	sp, #36	; 0x24
    6828:	bc3c      	pop	{r2, r3, r4, r5}
    682a:	4690      	mov	r8, r2
    682c:	4699      	mov	r9, r3
    682e:	46a2      	mov	sl, r4
    6830:	46ab      	mov	fp, r5
    6832:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6834:	00005cc9 	.word	0x00005cc9
    6838:	000003ca 	.word	0x000003ca
    683c:	00014a58 	.word	0x00014a58
    6840:	00014144 	.word	0x00014144
    6844:	0001198d 	.word	0x0001198d
    6848:	00014e28 	.word	0x00014e28
    684c:	000119c1 	.word	0x000119c1
    6850:	00005e6d 	.word	0x00005e6d
    6854:	00014e58 	.word	0x00014e58
    6858:	00005ca9 	.word	0x00005ca9
    685c:	00014a20 	.word	0x00014a20
    6860:	00014e90 	.word	0x00014e90
    6864:	00011aad 	.word	0x00011aad
    6868:	00000359 	.word	0x00000359
    686c:	00014ec8 	.word	0x00014ec8
    6870:	200008d8 	.word	0x200008d8
    6874:	00000363 	.word	0x00000363
    6878:	00014efc 	.word	0x00014efc
    687c:	00014a48 	.word	0x00014a48
    6880:	00014f34 	.word	0x00014f34
    6884:	00014f54 	.word	0x00014f54
    6888:	00014f84 	.word	0x00014f84
    688c:	00005e4d 	.word	0x00005e4d
    6890:	00003e6d 	.word	0x00003e6d
    6894:	000003f2 	.word	0x000003f2
    6898:	00014e0c 	.word	0x00014e0c

0000689c <Socket_ReadSocketData>:
Date
		17 July 2012
*********************************************************************/
NMI_API void Socket_ReadSocketData(SOCKET sock, tstrSocketRecvMsg *pstrRecv,uint8 u8SocketMsg,
								  uint32 u32StartAddress,uint16 u16ReadCount)
{
    689c:	b5f0      	push	{r4, r5, r6, r7, lr}
    689e:	465f      	mov	r7, fp
    68a0:	4656      	mov	r6, sl
    68a2:	464d      	mov	r5, r9
    68a4:	4644      	mov	r4, r8
    68a6:	b4f0      	push	{r4, r5, r6, r7}
    68a8:	b085      	sub	sp, #20
    68aa:	9001      	str	r0, [sp, #4]
    68ac:	000e      	movs	r6, r1
    68ae:	9202      	str	r2, [sp, #8]
    68b0:	001d      	movs	r5, r3
    68b2:	ab0e      	add	r3, sp, #56	; 0x38
    68b4:	881c      	ldrh	r4, [r3, #0]
	if((u16ReadCount > 0) && (gastrSockets[sock].pu8UserBuffer != NULL) && (gastrSockets[sock].u16UserBufferSize > 0) && (gastrSockets[sock].bIsUsed == 1))
    68b6:	2c00      	cmp	r4, #0
    68b8:	d062      	beq.n	6980 <Socket_ReadSocketData+0xe4>
    68ba:	0103      	lsls	r3, r0, #4
    68bc:	4934      	ldr	r1, [pc, #208]	; (6990 <Socket_ReadSocketData+0xf4>)
    68be:	585b      	ldr	r3, [r3, r1]
    68c0:	2b00      	cmp	r3, #0
    68c2:	d05d      	beq.n	6980 <Socket_ReadSocketData+0xe4>
    68c4:	0103      	lsls	r3, r0, #4
    68c6:	18cb      	adds	r3, r1, r3
    68c8:	889b      	ldrh	r3, [r3, #4]
    68ca:	b29b      	uxth	r3, r3
    68cc:	2b00      	cmp	r3, #0
    68ce:	d057      	beq.n	6980 <Socket_ReadSocketData+0xe4>
    68d0:	0103      	lsls	r3, r0, #4
    68d2:	18cb      	adds	r3, r1, r3
    68d4:	7a9b      	ldrb	r3, [r3, #10]
    68d6:	2b01      	cmp	r3, #1
    68d8:	d152      	bne.n	6980 <Socket_ReadSocketData+0xe4>
		uint32	u32Address = u32StartAddress;
		uint16	u16Read;
		sint16	s16Diff;
		uint8	u8SetRxDone;

		pstrRecv->u16RemainingSize = u16ReadCount;
    68da:	80f4      	strh	r4, [r6, #6]
		do
		{
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
    68dc:	0107      	lsls	r7, r0, #4
    68de:	468b      	mov	fp, r1
    68e0:	44bb      	add	fp, r7
					gpfAppSocketCb(sock,u8SocketMsg, pstrRecv);

				u16ReadCount -= u16Read;
				u32Address += u16Read;

				if((!gastrSockets[sock].bIsUsed) && (u16ReadCount))
    68e2:	465b      	mov	r3, fp
    68e4:	220a      	movs	r2, #10
    68e6:	4690      	mov	r8, r2
    68e8:	44d8      	add	r8, fp
    68ea:	46ba      	mov	sl, r7
    68ec:	9500      	str	r5, [sp, #0]
    68ee:	9303      	str	r3, [sp, #12]
		pstrRecv->u16RemainingSize = u16ReadCount;
		do
		{
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
    68f0:	465b      	mov	r3, fp
    68f2:	889b      	ldrh	r3, [r3, #4]
			if(s16Diff > 0)
    68f4:	1ae3      	subs	r3, r4, r3
    68f6:	b21b      	sxth	r3, r3
    68f8:	2b00      	cmp	r3, #0
    68fa:	dd04      	ble.n	6906 <Socket_ReadSocketData+0x6a>
			{
				u8SetRxDone = 0;
				u16Read		= gastrSockets[sock].u16UserBufferSize;
    68fc:	9b03      	ldr	r3, [sp, #12]
    68fe:	889d      	ldrh	r5, [r3, #4]
    6900:	b2ad      	uxth	r5, r5
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
			if(s16Diff > 0)
			{
				u8SetRxDone = 0;
    6902:	2300      	movs	r3, #0
    6904:	e001      	b.n	690a <Socket_ReadSocketData+0x6e>
    6906:	0025      	movs	r5, r4
		uint8	u8SetRxDone;

		pstrRecv->u16RemainingSize = u16ReadCount;
		do
		{
			u8SetRxDone = 1;
    6908:	2301      	movs	r3, #1
			{
				u8SetRxDone = 0;
				u16Read		= gastrSockets[sock].u16UserBufferSize;
			}
			
			if(hif_receive(u32Address, gastrSockets[sock].pu8UserBuffer, u16Read, u8SetRxDone) == M2M_SUCCESS)
    690a:	4a21      	ldr	r2, [pc, #132]	; (6990 <Socket_ReadSocketData+0xf4>)
    690c:	4651      	mov	r1, sl
    690e:	5889      	ldr	r1, [r1, r2]
    6910:	002a      	movs	r2, r5
    6912:	9800      	ldr	r0, [sp, #0]
    6914:	4f1f      	ldr	r7, [pc, #124]	; (6994 <Socket_ReadSocketData+0xf8>)
    6916:	47b8      	blx	r7
    6918:	2800      	cmp	r0, #0
    691a:	d125      	bne.n	6968 <Socket_ReadSocketData+0xcc>
			{
				pstrRecv->pu8Buffer			= gastrSockets[sock].pu8UserBuffer;
    691c:	4b1c      	ldr	r3, [pc, #112]	; (6990 <Socket_ReadSocketData+0xf4>)
    691e:	4652      	mov	r2, sl
    6920:	58d3      	ldr	r3, [r2, r3]
    6922:	6033      	str	r3, [r6, #0]
				pstrRecv->s16BufferSize		= u16Read;
    6924:	80b5      	strh	r5, [r6, #4]
				pstrRecv->u16RemainingSize	-= u16Read;
    6926:	88f3      	ldrh	r3, [r6, #6]
    6928:	1b5b      	subs	r3, r3, r5
    692a:	80f3      	strh	r3, [r6, #6]

				if (gpfAppSocketCb)
    692c:	4b1a      	ldr	r3, [pc, #104]	; (6998 <Socket_ReadSocketData+0xfc>)
    692e:	681b      	ldr	r3, [r3, #0]
    6930:	2b00      	cmp	r3, #0
    6932:	d005      	beq.n	6940 <Socket_ReadSocketData+0xa4>
					gpfAppSocketCb(sock,u8SocketMsg, pstrRecv);
    6934:	4b18      	ldr	r3, [pc, #96]	; (6998 <Socket_ReadSocketData+0xfc>)
    6936:	681b      	ldr	r3, [r3, #0]
    6938:	0032      	movs	r2, r6
    693a:	9902      	ldr	r1, [sp, #8]
    693c:	9801      	ldr	r0, [sp, #4]
    693e:	4798      	blx	r3

				u16ReadCount -= u16Read;
    6940:	1b64      	subs	r4, r4, r5
    6942:	b2a4      	uxth	r4, r4
				u32Address += u16Read;
    6944:	9b00      	ldr	r3, [sp, #0]
    6946:	469c      	mov	ip, r3
    6948:	44ac      	add	ip, r5
    694a:	4663      	mov	r3, ip
    694c:	9300      	str	r3, [sp, #0]

				if((!gastrSockets[sock].bIsUsed) && (u16ReadCount))
    694e:	4643      	mov	r3, r8
    6950:	781b      	ldrb	r3, [r3, #0]
    6952:	2b00      	cmp	r3, #0
    6954:	d112      	bne.n	697c <Socket_ReadSocketData+0xe0>
    6956:	2c00      	cmp	r4, #0
    6958:	d012      	beq.n	6980 <Socket_ReadSocketData+0xe4>
				{
					M2M_DBG("Application Closed Socket While Rx Is not Complete\n");
					if(hif_receive(0, NULL, 0, 1) == M2M_SUCCESS)
    695a:	3301      	adds	r3, #1
    695c:	2200      	movs	r2, #0
    695e:	2100      	movs	r1, #0
    6960:	2000      	movs	r0, #0
    6962:	4c0c      	ldr	r4, [pc, #48]	; (6994 <Socket_ReadSocketData+0xf8>)
    6964:	47a0      	blx	r4
    6966:	e00b      	b.n	6980 <Socket_ReadSocketData+0xe4>
					break;
				}
			}
			else
			{
				M2M_INFO("(ERRR)Current <%d>\n", u16ReadCount);
    6968:	480c      	ldr	r0, [pc, #48]	; (699c <Socket_ReadSocketData+0x100>)
    696a:	4d0d      	ldr	r5, [pc, #52]	; (69a0 <Socket_ReadSocketData+0x104>)
    696c:	47a8      	blx	r5
    696e:	0021      	movs	r1, r4
    6970:	480c      	ldr	r0, [pc, #48]	; (69a4 <Socket_ReadSocketData+0x108>)
    6972:	47a8      	blx	r5
    6974:	200d      	movs	r0, #13
    6976:	4b0c      	ldr	r3, [pc, #48]	; (69a8 <Socket_ReadSocketData+0x10c>)
    6978:	4798      	blx	r3
				break;
    697a:	e001      	b.n	6980 <Socket_ReadSocketData+0xe4>
			}
		}while(u16ReadCount != 0);
    697c:	2c00      	cmp	r4, #0
    697e:	d1b7      	bne.n	68f0 <Socket_ReadSocketData+0x54>
	}
}
    6980:	b005      	add	sp, #20
    6982:	bc3c      	pop	{r2, r3, r4, r5}
    6984:	4690      	mov	r8, r2
    6986:	4699      	mov	r9, r3
    6988:	46a2      	mov	sl, r4
    698a:	46ab      	mov	fp, r5
    698c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    698e:	46c0      	nop			; (mov r8, r8)
    6990:	2000229c 	.word	0x2000229c
    6994:	00004991 	.word	0x00004991
    6998:	2000234c 	.word	0x2000234c
    699c:	00013ca0 	.word	0x00013ca0
    69a0:	0001198d 	.word	0x0001198d
    69a4:	000150e4 	.word	0x000150e4
    69a8:	000119c1 	.word	0x000119c1

000069ac <m2m_ip_cb>:

Date
		17 July 2012
*********************************************************************/
static void m2m_ip_cb(uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
{	
    69ac:	b5f0      	push	{r4, r5, r6, r7, lr}
    69ae:	464f      	mov	r7, r9
    69b0:	4646      	mov	r6, r8
    69b2:	b4c0      	push	{r6, r7}
    69b4:	b09b      	sub	sp, #108	; 0x6c
    69b6:	000d      	movs	r5, r1
    69b8:	0014      	movs	r4, r2
	if((u8OpCode == SOCKET_CMD_BIND) || (u8OpCode == SOCKET_CMD_SSL_BIND))
    69ba:	2841      	cmp	r0, #65	; 0x41
    69bc:	d001      	beq.n	69c2 <m2m_ip_cb+0x16>
    69be:	2854      	cmp	r0, #84	; 0x54
    69c0:	d11a      	bne.n	69f8 <m2m_ip_cb+0x4c>
	{
		tstrBindReply		strBindReply;
		tstrSocketBindMsg	strBind;

		if(hif_receive(u32Address, (uint8*)&strBindReply, sizeof(tstrBindReply), 0) == M2M_SUCCESS)
    69c2:	2300      	movs	r3, #0
    69c4:	2204      	movs	r2, #4
    69c6:	a909      	add	r1, sp, #36	; 0x24
    69c8:	0020      	movs	r0, r4
    69ca:	4caf      	ldr	r4, [pc, #700]	; (6c88 <m2m_ip_cb+0x2dc>)
    69cc:	47a0      	blx	r4
    69ce:	2800      	cmp	r0, #0
    69d0:	d000      	beq.n	69d4 <m2m_ip_cb+0x28>
    69d2:	e153      	b.n	6c7c <m2m_ip_cb+0x2d0>
		{
			strBind.status = strBindReply.s8Status;
    69d4:	ab09      	add	r3, sp, #36	; 0x24
    69d6:	785a      	ldrb	r2, [r3, #1]
    69d8:	ab05      	add	r3, sp, #20
    69da:	701a      	strb	r2, [r3, #0]
			if(gpfAppSocketCb)
    69dc:	4bab      	ldr	r3, [pc, #684]	; (6c8c <m2m_ip_cb+0x2e0>)
    69de:	681b      	ldr	r3, [r3, #0]
    69e0:	2b00      	cmp	r3, #0
    69e2:	d100      	bne.n	69e6 <m2m_ip_cb+0x3a>
    69e4:	e14a      	b.n	6c7c <m2m_ip_cb+0x2d0>
				gpfAppSocketCb(strBindReply.sock,SOCKET_MSG_BIND,&strBind);
    69e6:	4ba9      	ldr	r3, [pc, #676]	; (6c8c <m2m_ip_cb+0x2e0>)
    69e8:	681b      	ldr	r3, [r3, #0]
    69ea:	aa09      	add	r2, sp, #36	; 0x24
    69ec:	2000      	movs	r0, #0
    69ee:	5610      	ldrsb	r0, [r2, r0]
    69f0:	aa05      	add	r2, sp, #20
    69f2:	2101      	movs	r1, #1
    69f4:	4798      	blx	r3
		17 July 2012
*********************************************************************/
static void m2m_ip_cb(uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
{	
	if((u8OpCode == SOCKET_CMD_BIND) || (u8OpCode == SOCKET_CMD_SSL_BIND))
	{
    69f6:	e141      	b.n	6c7c <m2m_ip_cb+0x2d0>
			strBind.status = strBindReply.s8Status;
			if(gpfAppSocketCb)
				gpfAppSocketCb(strBindReply.sock,SOCKET_MSG_BIND,&strBind);
		}
	}
	else if(u8OpCode == SOCKET_CMD_LISTEN)
    69f8:	2842      	cmp	r0, #66	; 0x42
    69fa:	d11a      	bne.n	6a32 <m2m_ip_cb+0x86>
	{
		tstrListenReply			strListenReply;
		tstrSocketListenMsg		strListen;
		if(hif_receive(u32Address, (uint8*)&strListenReply, sizeof(tstrListenReply), 0) == M2M_SUCCESS)
    69fc:	2300      	movs	r3, #0
    69fe:	2204      	movs	r2, #4
    6a00:	a909      	add	r1, sp, #36	; 0x24
    6a02:	0020      	movs	r0, r4
    6a04:	4ca0      	ldr	r4, [pc, #640]	; (6c88 <m2m_ip_cb+0x2dc>)
    6a06:	47a0      	blx	r4
    6a08:	2800      	cmp	r0, #0
    6a0a:	d000      	beq.n	6a0e <m2m_ip_cb+0x62>
    6a0c:	e136      	b.n	6c7c <m2m_ip_cb+0x2d0>
		{
			strListen.status = strListenReply.s8Status;
    6a0e:	ab09      	add	r3, sp, #36	; 0x24
    6a10:	785a      	ldrb	r2, [r3, #1]
    6a12:	ab05      	add	r3, sp, #20
    6a14:	701a      	strb	r2, [r3, #0]
			if(gpfAppSocketCb)
    6a16:	4b9d      	ldr	r3, [pc, #628]	; (6c8c <m2m_ip_cb+0x2e0>)
    6a18:	681b      	ldr	r3, [r3, #0]
    6a1a:	2b00      	cmp	r3, #0
    6a1c:	d100      	bne.n	6a20 <m2m_ip_cb+0x74>
    6a1e:	e12d      	b.n	6c7c <m2m_ip_cb+0x2d0>
				gpfAppSocketCb(strListenReply.sock,SOCKET_MSG_LISTEN, &strListen);
    6a20:	4b9a      	ldr	r3, [pc, #616]	; (6c8c <m2m_ip_cb+0x2e0>)
    6a22:	681b      	ldr	r3, [r3, #0]
    6a24:	aa09      	add	r2, sp, #36	; 0x24
    6a26:	2000      	movs	r0, #0
    6a28:	5610      	ldrsb	r0, [r2, r0]
    6a2a:	aa05      	add	r2, sp, #20
    6a2c:	2102      	movs	r1, #2
    6a2e:	4798      	blx	r3
    6a30:	e124      	b.n	6c7c <m2m_ip_cb+0x2d0>
		}
	}
	else if(u8OpCode == SOCKET_CMD_ACCEPT)
    6a32:	2843      	cmp	r0, #67	; 0x43
    6a34:	d149      	bne.n	6aca <m2m_ip_cb+0x11e>
	{
		tstrAcceptReply			strAcceptReply;
		tstrSocketAcceptMsg		strAccept;
		if(hif_receive(u32Address, (uint8*)&strAcceptReply, sizeof(tstrAcceptReply), 0) == M2M_SUCCESS)
    6a36:	2300      	movs	r3, #0
    6a38:	220c      	movs	r2, #12
    6a3a:	a905      	add	r1, sp, #20
    6a3c:	0020      	movs	r0, r4
    6a3e:	4c92      	ldr	r4, [pc, #584]	; (6c88 <m2m_ip_cb+0x2dc>)
    6a40:	47a0      	blx	r4
    6a42:	2800      	cmp	r0, #0
    6a44:	d000      	beq.n	6a48 <m2m_ip_cb+0x9c>
    6a46:	e119      	b.n	6c7c <m2m_ip_cb+0x2d0>
		{
			if(strAcceptReply.sConnectedSock >= 0)
    6a48:	ab05      	add	r3, sp, #20
    6a4a:	2209      	movs	r2, #9
    6a4c:	569a      	ldrsb	r2, [r3, r2]
    6a4e:	2a00      	cmp	r2, #0
    6a50:	db24      	blt.n	6a9c <m2m_ip_cb+0xf0>
			{
				gastrSockets[strAcceptReply.sConnectedSock].u8SSLFlags 		= gastrSockets[strAcceptReply.sListenSock].u8SSLFlags;
    6a52:	0018      	movs	r0, r3
    6a54:	2108      	movs	r1, #8
    6a56:	5659      	ldrsb	r1, [r3, r1]
    6a58:	4c8d      	ldr	r4, [pc, #564]	; (6c90 <m2m_ip_cb+0x2e4>)
    6a5a:	0109      	lsls	r1, r1, #4
    6a5c:	1861      	adds	r1, r4, r1
    6a5e:	7ac9      	ldrb	r1, [r1, #11]
    6a60:	b2c9      	uxtb	r1, r1
    6a62:	0113      	lsls	r3, r2, #4
    6a64:	18e3      	adds	r3, r4, r3
    6a66:	72d9      	strb	r1, [r3, #11]
				gastrSockets[strAcceptReply.sConnectedSock].bIsUsed 		= 1;
    6a68:	2101      	movs	r1, #1
    6a6a:	7299      	strb	r1, [r3, #10]
				gastrSockets[strAcceptReply.sConnectedSock].u16DataOffset 	= strAcceptReply.u16AppDataOffset - M2M_HIF_HDR_OFFSET;
    6a6c:	8941      	ldrh	r1, [r0, #10]
    6a6e:	3908      	subs	r1, #8
    6a70:	b289      	uxth	r1, r1
    6a72:	8119      	strh	r1, [r3, #8]

				/* The session ID is used to distinguish different socket connections
					by comparing the assigned session ID to the one reported by the firmware*/
				++gu16SessionID;
    6a74:	4987      	ldr	r1, [pc, #540]	; (6c94 <m2m_ip_cb+0x2e8>)
    6a76:	880b      	ldrh	r3, [r1, #0]
    6a78:	3301      	adds	r3, #1
    6a7a:	b29b      	uxth	r3, r3
    6a7c:	800b      	strh	r3, [r1, #0]
				if(gu16SessionID == 0)
    6a7e:	880b      	ldrh	r3, [r1, #0]
    6a80:	b29b      	uxth	r3, r3
    6a82:	2b00      	cmp	r3, #0
    6a84:	d103      	bne.n	6a8e <m2m_ip_cb+0xe2>
					++gu16SessionID;
    6a86:	880b      	ldrh	r3, [r1, #0]
    6a88:	3301      	adds	r3, #1
    6a8a:	b29b      	uxth	r3, r3
    6a8c:	800b      	strh	r3, [r1, #0]

				gastrSockets[strAcceptReply.sConnectedSock].u16SessionID = gu16SessionID;
    6a8e:	4b81      	ldr	r3, [pc, #516]	; (6c94 <m2m_ip_cb+0x2e8>)
    6a90:	8819      	ldrh	r1, [r3, #0]
    6a92:	b289      	uxth	r1, r1
    6a94:	0113      	lsls	r3, r2, #4
    6a96:	487e      	ldr	r0, [pc, #504]	; (6c90 <m2m_ip_cb+0x2e4>)
    6a98:	18c3      	adds	r3, r0, r3
    6a9a:	80d9      	strh	r1, [r3, #6]
				M2M_DBG("Socket %d session ID = %d\r\n",strAcceptReply.sConnectedSock , gu16SessionID );		
			}
			strAccept.sock = strAcceptReply.sConnectedSock;
    6a9c:	ab09      	add	r3, sp, #36	; 0x24
    6a9e:	701a      	strb	r2, [r3, #0]
			strAccept.strAddr.sin_family		= AF_INET;
    6aa0:	2202      	movs	r2, #2
    6aa2:	809a      	strh	r2, [r3, #4]
			strAccept.strAddr.sin_port = strAcceptReply.strAddr.u16Port;
    6aa4:	aa05      	add	r2, sp, #20
    6aa6:	8851      	ldrh	r1, [r2, #2]
    6aa8:	80d9      	strh	r1, [r3, #6]
			strAccept.strAddr.sin_addr.s_addr = strAcceptReply.strAddr.u32IPAddr;
    6aaa:	9a06      	ldr	r2, [sp, #24]
    6aac:	920b      	str	r2, [sp, #44]	; 0x2c
			if(gpfAppSocketCb)
    6aae:	4b77      	ldr	r3, [pc, #476]	; (6c8c <m2m_ip_cb+0x2e0>)
    6ab0:	681b      	ldr	r3, [r3, #0]
    6ab2:	2b00      	cmp	r3, #0
    6ab4:	d100      	bne.n	6ab8 <m2m_ip_cb+0x10c>
    6ab6:	e0e1      	b.n	6c7c <m2m_ip_cb+0x2d0>
				gpfAppSocketCb(strAcceptReply.sListenSock, SOCKET_MSG_ACCEPT, &strAccept);
    6ab8:	4b74      	ldr	r3, [pc, #464]	; (6c8c <m2m_ip_cb+0x2e0>)
    6aba:	681b      	ldr	r3, [r3, #0]
    6abc:	aa05      	add	r2, sp, #20
    6abe:	2008      	movs	r0, #8
    6ac0:	5610      	ldrsb	r0, [r2, r0]
    6ac2:	aa09      	add	r2, sp, #36	; 0x24
    6ac4:	2104      	movs	r1, #4
    6ac6:	4798      	blx	r3
    6ac8:	e0d8      	b.n	6c7c <m2m_ip_cb+0x2d0>
		}
	}
	else if((u8OpCode == SOCKET_CMD_CONNECT) || (u8OpCode == SOCKET_CMD_SSL_CONNECT))
    6aca:	2844      	cmp	r0, #68	; 0x44
    6acc:	d001      	beq.n	6ad2 <m2m_ip_cb+0x126>
    6ace:	284b      	cmp	r0, #75	; 0x4b
    6ad0:	d125      	bne.n	6b1e <m2m_ip_cb+0x172>
	{
		tstrConnectReply		strConnectReply;
		tstrSocketConnectMsg	strConnMsg;
		if(hif_receive(u32Address, (uint8*)&strConnectReply, sizeof(tstrConnectReply), 0) == M2M_SUCCESS)
    6ad2:	2300      	movs	r3, #0
    6ad4:	2204      	movs	r2, #4
    6ad6:	a909      	add	r1, sp, #36	; 0x24
    6ad8:	0020      	movs	r0, r4
    6ada:	4c6b      	ldr	r4, [pc, #428]	; (6c88 <m2m_ip_cb+0x2dc>)
    6adc:	47a0      	blx	r4
    6ade:	2800      	cmp	r0, #0
    6ae0:	d000      	beq.n	6ae4 <m2m_ip_cb+0x138>
    6ae2:	e0cb      	b.n	6c7c <m2m_ip_cb+0x2d0>
		{
			strConnMsg.sock		= strConnectReply.sock;
    6ae4:	ab09      	add	r3, sp, #36	; 0x24
    6ae6:	2000      	movs	r0, #0
    6ae8:	5618      	ldrsb	r0, [r3, r0]
    6aea:	aa05      	add	r2, sp, #20
    6aec:	7010      	strb	r0, [r2, #0]
			strConnMsg.s8Error	= strConnectReply.s8Error;
    6aee:	785b      	ldrb	r3, [r3, #1]
    6af0:	b25b      	sxtb	r3, r3
    6af2:	7053      	strb	r3, [r2, #1]
			if(strConnectReply.s8Error == SOCK_ERR_NO_ERROR)
    6af4:	2b00      	cmp	r3, #0
    6af6:	d107      	bne.n	6b08 <m2m_ip_cb+0x15c>
			{
				gastrSockets[strConnectReply.sock].u16DataOffset = strConnectReply.u16AppDataOffset - M2M_HIF_HDR_OFFSET;
    6af8:	ab09      	add	r3, sp, #36	; 0x24
    6afa:	885a      	ldrh	r2, [r3, #2]
    6afc:	3a08      	subs	r2, #8
    6afe:	b292      	uxth	r2, r2
    6b00:	0103      	lsls	r3, r0, #4
    6b02:	4963      	ldr	r1, [pc, #396]	; (6c90 <m2m_ip_cb+0x2e4>)
    6b04:	18cb      	adds	r3, r1, r3
    6b06:	811a      	strh	r2, [r3, #8]
			}
			if(gpfAppSocketCb)
    6b08:	4b60      	ldr	r3, [pc, #384]	; (6c8c <m2m_ip_cb+0x2e0>)
    6b0a:	681b      	ldr	r3, [r3, #0]
    6b0c:	2b00      	cmp	r3, #0
    6b0e:	d100      	bne.n	6b12 <m2m_ip_cb+0x166>
    6b10:	e0b4      	b.n	6c7c <m2m_ip_cb+0x2d0>
				gpfAppSocketCb(strConnectReply.sock,SOCKET_MSG_CONNECT, &strConnMsg);
    6b12:	4b5e      	ldr	r3, [pc, #376]	; (6c8c <m2m_ip_cb+0x2e0>)
    6b14:	681b      	ldr	r3, [r3, #0]
    6b16:	aa05      	add	r2, sp, #20
    6b18:	2105      	movs	r1, #5
    6b1a:	4798      	blx	r3
			if(gpfAppSocketCb)
				gpfAppSocketCb(strAcceptReply.sListenSock, SOCKET_MSG_ACCEPT, &strAccept);
		}
	}
	else if((u8OpCode == SOCKET_CMD_CONNECT) || (u8OpCode == SOCKET_CMD_SSL_CONNECT))
	{
    6b1c:	e0ae      	b.n	6c7c <m2m_ip_cb+0x2d0>
			}
			if(gpfAppSocketCb)
				gpfAppSocketCb(strConnectReply.sock,SOCKET_MSG_CONNECT, &strConnMsg);
		}
	}
	else if(u8OpCode == SOCKET_CMD_DNS_RESOLVE)
    6b1e:	284a      	cmp	r0, #74	; 0x4a
    6b20:	d115      	bne.n	6b4e <m2m_ip_cb+0x1a2>
	{
		tstrDnsReply	strDnsReply;
		if(hif_receive(u32Address, (uint8*)&strDnsReply, sizeof(tstrDnsReply), 0) == M2M_SUCCESS)
    6b22:	2300      	movs	r3, #0
    6b24:	2244      	movs	r2, #68	; 0x44
    6b26:	a909      	add	r1, sp, #36	; 0x24
    6b28:	0020      	movs	r0, r4
    6b2a:	4c57      	ldr	r4, [pc, #348]	; (6c88 <m2m_ip_cb+0x2dc>)
    6b2c:	47a0      	blx	r4
    6b2e:	2800      	cmp	r0, #0
    6b30:	d000      	beq.n	6b34 <m2m_ip_cb+0x188>
    6b32:	e0a3      	b.n	6c7c <m2m_ip_cb+0x2d0>
		{
			if(gpfAppResolveCb)
    6b34:	4b58      	ldr	r3, [pc, #352]	; (6c98 <m2m_ip_cb+0x2ec>)
    6b36:	681b      	ldr	r3, [r3, #0]
    6b38:	2b00      	cmp	r3, #0
    6b3a:	d100      	bne.n	6b3e <m2m_ip_cb+0x192>
    6b3c:	e09e      	b.n	6c7c <m2m_ip_cb+0x2d0>
				gpfAppResolveCb((uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
    6b3e:	4b56      	ldr	r3, [pc, #344]	; (6c98 <m2m_ip_cb+0x2ec>)
    6b40:	681b      	ldr	r3, [r3, #0]
    6b42:	9a19      	ldr	r2, [sp, #100]	; 0x64
    6b44:	9203      	str	r2, [sp, #12]
    6b46:	0011      	movs	r1, r2
    6b48:	a809      	add	r0, sp, #36	; 0x24
    6b4a:	4798      	blx	r3
    6b4c:	e096      	b.n	6c7c <m2m_ip_cb+0x2d0>
		}
	}
	else if((u8OpCode == SOCKET_CMD_RECV) || (u8OpCode == SOCKET_CMD_RECVFROM) || (u8OpCode == SOCKET_CMD_SSL_RECV))
    6b4e:	2846      	cmp	r0, #70	; 0x46
    6b50:	d005      	beq.n	6b5e <m2m_ip_cb+0x1b2>
    6b52:	2848      	cmp	r0, #72	; 0x48
    6b54:	d005      	beq.n	6b62 <m2m_ip_cb+0x1b6>
		SOCKET				sock;
		sint16				s16RecvStatus;
		tstrRecvReply		strRecvReply;
		uint16				u16ReadSize;
		tstrSocketRecvMsg	strRecvMsg;
		uint8				u8CallbackMsgID = SOCKET_MSG_RECV;
    6b56:	2606      	movs	r6, #6
		{
			if(gpfAppResolveCb)
				gpfAppResolveCb((uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
		}
	}
	else if((u8OpCode == SOCKET_CMD_RECV) || (u8OpCode == SOCKET_CMD_RECVFROM) || (u8OpCode == SOCKET_CMD_SSL_RECV))
    6b58:	284d      	cmp	r0, #77	; 0x4d
    6b5a:	d003      	beq.n	6b64 <m2m_ip_cb+0x1b8>
    6b5c:	e04c      	b.n	6bf8 <m2m_ip_cb+0x24c>
		SOCKET				sock;
		sint16				s16RecvStatus;
		tstrRecvReply		strRecvReply;
		uint16				u16ReadSize;
		tstrSocketRecvMsg	strRecvMsg;
		uint8				u8CallbackMsgID = SOCKET_MSG_RECV;
    6b5e:	2606      	movs	r6, #6
    6b60:	e000      	b.n	6b64 <m2m_ip_cb+0x1b8>
		uint16				u16DataOffset;

		if(u8OpCode == SOCKET_CMD_RECVFROM)
			u8CallbackMsgID = SOCKET_MSG_RECVFROM;
    6b62:	2609      	movs	r6, #9

		/* Read RECV REPLY data structure.
		*/
		u16ReadSize = sizeof(tstrRecvReply);
		if(hif_receive(u32Address, (uint8*)&strRecvReply, u16ReadSize, 0) == M2M_SUCCESS)
    6b64:	2300      	movs	r3, #0
    6b66:	2210      	movs	r2, #16
    6b68:	a905      	add	r1, sp, #20
    6b6a:	0020      	movs	r0, r4
    6b6c:	4f46      	ldr	r7, [pc, #280]	; (6c88 <m2m_ip_cb+0x2dc>)
    6b6e:	47b8      	blx	r7
    6b70:	2800      	cmp	r0, #0
    6b72:	d000      	beq.n	6b76 <m2m_ip_cb+0x1ca>
    6b74:	e082      	b.n	6c7c <m2m_ip_cb+0x2d0>
		{
			uint16 u16SessionID = 0;

			sock			= strRecvReply.sock;
    6b76:	aa05      	add	r2, sp, #20
    6b78:	200c      	movs	r0, #12
    6b7a:	5610      	ldrsb	r0, [r2, r0]
			u16SessionID = strRecvReply.u16SessionID;
    6b7c:	89d3      	ldrh	r3, [r2, #14]
    6b7e:	469c      	mov	ip, r3
			M2M_DBG("recv callback session ID = %d\r\n",u16SessionID);
			
			/* Reset the Socket RX Pending Flag.
			*/
			gastrSockets[sock].bIsRecvPending = 0;
    6b80:	0103      	lsls	r3, r0, #4
    6b82:	4943      	ldr	r1, [pc, #268]	; (6c90 <m2m_ip_cb+0x2e4>)
    6b84:	18c9      	adds	r1, r1, r3
    6b86:	2300      	movs	r3, #0
    6b88:	730b      	strb	r3, [r1, #12]

			s16RecvStatus	= NM_BSP_B_L_16(strRecvReply.s16RecvStatus);
    6b8a:	2708      	movs	r7, #8
    6b8c:	5fd3      	ldrsh	r3, [r2, r7]
    6b8e:	4698      	mov	r8, r3
			u16DataOffset	= NM_BSP_B_L_16(strRecvReply.u16DataOffset);
    6b90:	8953      	ldrh	r3, [r2, #10]
    6b92:	4699      	mov	r9, r3
			strRecvMsg.strRemoteAddr.sin_port 			= strRecvReply.strRemoteAddr.u16Port;
    6b94:	af09      	add	r7, sp, #36	; 0x24
    6b96:	8853      	ldrh	r3, [r2, #2]
    6b98:	817b      	strh	r3, [r7, #10]
			strRecvMsg.strRemoteAddr.sin_addr.s_addr 	= strRecvReply.strRemoteAddr.u32IPAddr;
    6b9a:	9b06      	ldr	r3, [sp, #24]
    6b9c:	930c      	str	r3, [sp, #48]	; 0x30

			if(u16SessionID == gastrSockets[sock].u16SessionID)
    6b9e:	88ca      	ldrh	r2, [r1, #6]
    6ba0:	b292      	uxth	r2, r2
    6ba2:	4594      	cmp	ip, r2
    6ba4:	d11f      	bne.n	6be6 <m2m_ip_cb+0x23a>
			{
				if((s16RecvStatus > 0) && (s16RecvStatus < u16BufferSize))
    6ba6:	4643      	mov	r3, r8
    6ba8:	2b00      	cmp	r3, #0
    6baa:	dd0d      	ble.n	6bc8 <m2m_ip_cb+0x21c>
    6bac:	45a8      	cmp	r8, r5
    6bae:	da0b      	bge.n	6bc8 <m2m_ip_cb+0x21c>
					/* Read the Application data and deliver it to the application callback in
					the given application buffer. If the buffer is smaller than the received data,
					the data is passed to the application in chunks according to its buffer size.
					*/
					u16ReadSize = (uint16)s16RecvStatus;
					Socket_ReadSocketData(sock, &strRecvMsg, u8CallbackMsgID, u32Address, u16ReadSize);
    6bb0:	0023      	movs	r3, r4
    6bb2:	444b      	add	r3, r9
    6bb4:	4642      	mov	r2, r8
    6bb6:	4669      	mov	r1, sp
    6bb8:	818a      	strh	r2, [r1, #12]
    6bba:	898a      	ldrh	r2, [r1, #12]
    6bbc:	9200      	str	r2, [sp, #0]
    6bbe:	0032      	movs	r2, r6
    6bc0:	0039      	movs	r1, r7
    6bc2:	4c36      	ldr	r4, [pc, #216]	; (6c9c <m2m_ip_cb+0x2f0>)
    6bc4:	47a0      	blx	r4
    6bc6:	e059      	b.n	6c7c <m2m_ip_cb+0x2d0>
				}
				else
				{
					strRecvMsg.s16BufferSize	= s16RecvStatus;
    6bc8:	ab09      	add	r3, sp, #36	; 0x24
    6bca:	4642      	mov	r2, r8
    6bcc:	809a      	strh	r2, [r3, #4]
					strRecvMsg.pu8Buffer		= NULL;
    6bce:	2300      	movs	r3, #0
    6bd0:	9309      	str	r3, [sp, #36]	; 0x24
					if(gpfAppSocketCb)
    6bd2:	4b2e      	ldr	r3, [pc, #184]	; (6c8c <m2m_ip_cb+0x2e0>)
    6bd4:	681b      	ldr	r3, [r3, #0]
    6bd6:	2b00      	cmp	r3, #0
    6bd8:	d050      	beq.n	6c7c <m2m_ip_cb+0x2d0>
						gpfAppSocketCb(sock,u8CallbackMsgID, &strRecvMsg);
    6bda:	4b2c      	ldr	r3, [pc, #176]	; (6c8c <m2m_ip_cb+0x2e0>)
    6bdc:	681b      	ldr	r3, [r3, #0]
    6bde:	aa09      	add	r2, sp, #36	; 0x24
    6be0:	0031      	movs	r1, r6
    6be2:	4798      	blx	r3
    6be4:	e04a      	b.n	6c7c <m2m_ip_cb+0x2d0>
				}
			}
			else
			{
				M2M_DBG("Discard recv callback %d %d \r\n",u16SessionID , gastrSockets[sock].u16SessionID);
				if(u16ReadSize < u16BufferSize)
    6be6:	2d10      	cmp	r5, #16
    6be8:	d948      	bls.n	6c7c <m2m_ip_cb+0x2d0>
				{
					if(hif_receive(0, NULL, 0, 1) == M2M_SUCCESS)
    6bea:	2301      	movs	r3, #1
    6bec:	2200      	movs	r2, #0
    6bee:	2100      	movs	r1, #0
    6bf0:	2000      	movs	r0, #0
    6bf2:	4c25      	ldr	r4, [pc, #148]	; (6c88 <m2m_ip_cb+0x2dc>)
    6bf4:	47a0      	blx	r4
			if(gpfAppResolveCb)
				gpfAppResolveCb((uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
		}
	}
	else if((u8OpCode == SOCKET_CMD_RECV) || (u8OpCode == SOCKET_CMD_RECVFROM) || (u8OpCode == SOCKET_CMD_SSL_RECV))
	{
    6bf6:	e041      	b.n	6c7c <m2m_ip_cb+0x2d0>
						M2M_DBG("hif_receive Fail\n");
				}
			}
		}
	}
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
    6bf8:	2845      	cmp	r0, #69	; 0x45
    6bfa:	d005      	beq.n	6c08 <m2m_ip_cb+0x25c>
    6bfc:	2847      	cmp	r0, #71	; 0x47
    6bfe:	d005      	beq.n	6c0c <m2m_ip_cb+0x260>
	{
		SOCKET			sock;
		sint16			s16Rcvd;
		tstrSendReply	strReply;
		uint8			u8CallbackMsgID = SOCKET_MSG_SEND;
    6c00:	2507      	movs	r5, #7
						M2M_DBG("hif_receive Fail\n");
				}
			}
		}
	}
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
    6c02:	284c      	cmp	r0, #76	; 0x4c
    6c04:	d003      	beq.n	6c0e <m2m_ip_cb+0x262>
    6c06:	e022      	b.n	6c4e <m2m_ip_cb+0x2a2>
	{
		SOCKET			sock;
		sint16			s16Rcvd;
		tstrSendReply	strReply;
		uint8			u8CallbackMsgID = SOCKET_MSG_SEND;
    6c08:	2507      	movs	r5, #7
    6c0a:	e000      	b.n	6c0e <m2m_ip_cb+0x262>

		if(u8OpCode == SOCKET_CMD_SENDTO)
			u8CallbackMsgID = SOCKET_MSG_SENDTO;
    6c0c:	2508      	movs	r5, #8

		if(hif_receive(u32Address, (uint8*)&strReply, sizeof(tstrSendReply), 0) == M2M_SUCCESS)
    6c0e:	2300      	movs	r3, #0
    6c10:	2208      	movs	r2, #8
    6c12:	a909      	add	r1, sp, #36	; 0x24
    6c14:	0020      	movs	r0, r4
    6c16:	4c1c      	ldr	r4, [pc, #112]	; (6c88 <m2m_ip_cb+0x2dc>)
    6c18:	47a0      	blx	r4
    6c1a:	2800      	cmp	r0, #0
    6c1c:	d12e      	bne.n	6c7c <m2m_ip_cb+0x2d0>
		{
			uint16 u16SessionID = 0;
			
			sock = strReply.sock;
    6c1e:	ab09      	add	r3, sp, #36	; 0x24
    6c20:	2000      	movs	r0, #0
    6c22:	5618      	ldrsb	r0, [r3, r0]
			u16SessionID = strReply.u16SessionID;
    6c24:	889a      	ldrh	r2, [r3, #4]
			M2M_DBG("send callback session ID = %d\r\n",u16SessionID);
			
			s16Rcvd = NM_BSP_B_L_16(strReply.s16SentBytes);
    6c26:	8859      	ldrh	r1, [r3, #2]
    6c28:	ab05      	add	r3, sp, #20
    6c2a:	8019      	strh	r1, [r3, #0]

			if(u16SessionID == gastrSockets[sock].u16SessionID)
    6c2c:	0103      	lsls	r3, r0, #4
    6c2e:	4918      	ldr	r1, [pc, #96]	; (6c90 <m2m_ip_cb+0x2e4>)
    6c30:	18cb      	adds	r3, r1, r3
    6c32:	88db      	ldrh	r3, [r3, #6]
    6c34:	b29b      	uxth	r3, r3
    6c36:	429a      	cmp	r2, r3
    6c38:	d120      	bne.n	6c7c <m2m_ip_cb+0x2d0>
			{
				if(gpfAppSocketCb)
    6c3a:	4b14      	ldr	r3, [pc, #80]	; (6c8c <m2m_ip_cb+0x2e0>)
    6c3c:	681b      	ldr	r3, [r3, #0]
    6c3e:	2b00      	cmp	r3, #0
    6c40:	d01c      	beq.n	6c7c <m2m_ip_cb+0x2d0>
					gpfAppSocketCb(sock,u8CallbackMsgID, &s16Rcvd);
    6c42:	4b12      	ldr	r3, [pc, #72]	; (6c8c <m2m_ip_cb+0x2e0>)
    6c44:	681b      	ldr	r3, [r3, #0]
    6c46:	aa05      	add	r2, sp, #20
    6c48:	0029      	movs	r1, r5
    6c4a:	4798      	blx	r3
				}
			}
		}
	}
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
	{
    6c4c:	e016      	b.n	6c7c <m2m_ip_cb+0x2d0>
			{
				M2M_DBG("Discard send callback %d %d \r\n",u16SessionID , gastrSockets[sock].u16SessionID);
			}
		}
	}
	else if(u8OpCode == SOCKET_CMD_PING)
    6c4e:	2852      	cmp	r0, #82	; 0x52
    6c50:	d114      	bne.n	6c7c <m2m_ip_cb+0x2d0>
	{
		tstrPingReply	strPingReply;
		if(hif_receive(u32Address, (uint8*)&strPingReply, sizeof(tstrPingReply), 1) == M2M_SUCCESS)
    6c52:	2301      	movs	r3, #1
    6c54:	2214      	movs	r2, #20
    6c56:	a909      	add	r1, sp, #36	; 0x24
    6c58:	0020      	movs	r0, r4
    6c5a:	4c0b      	ldr	r4, [pc, #44]	; (6c88 <m2m_ip_cb+0x2dc>)
    6c5c:	47a0      	blx	r4
    6c5e:	2800      	cmp	r0, #0
    6c60:	d10c      	bne.n	6c7c <m2m_ip_cb+0x2d0>
		{
			gfpPingCb = (void (*)(uint32 , uint32 , uint8))strPingReply.u32CmdPrivate;
    6c62:	4b0f      	ldr	r3, [pc, #60]	; (6ca0 <m2m_ip_cb+0x2f4>)
    6c64:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    6c66:	601a      	str	r2, [r3, #0]
			if(gfpPingCb != NULL)
    6c68:	681b      	ldr	r3, [r3, #0]
    6c6a:	2b00      	cmp	r3, #0
    6c6c:	d006      	beq.n	6c7c <m2m_ip_cb+0x2d0>
			{
				gfpPingCb(strPingReply.u32IPAddr, strPingReply.u32RTT, strPingReply.u8ErrorCode);
    6c6e:	4b0c      	ldr	r3, [pc, #48]	; (6ca0 <m2m_ip_cb+0x2f4>)
    6c70:	681c      	ldr	r4, [r3, #0]
    6c72:	ab09      	add	r3, sp, #36	; 0x24
    6c74:	7c1a      	ldrb	r2, [r3, #16]
    6c76:	990b      	ldr	r1, [sp, #44]	; 0x2c
    6c78:	9809      	ldr	r0, [sp, #36]	; 0x24
    6c7a:	47a0      	blx	r4
			}
		}
	}
}
    6c7c:	b01b      	add	sp, #108	; 0x6c
    6c7e:	bc0c      	pop	{r2, r3}
    6c80:	4690      	mov	r8, r2
    6c82:	4699      	mov	r9, r3
    6c84:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6c86:	46c0      	nop			; (mov r8, r8)
    6c88:	00004991 	.word	0x00004991
    6c8c:	2000234c 	.word	0x2000234c
    6c90:	2000229c 	.word	0x2000229c
    6c94:	200008dc 	.word	0x200008dc
    6c98:	20002354 	.word	0x20002354
    6c9c:	0000689d 	.word	0x0000689d
    6ca0:	20002350 	.word	0x20002350

00006ca4 <socketInit>:

Date
		4 June 2012
*********************************************************************/
void socketInit(void)
{
    6ca4:	b510      	push	{r4, lr}
	if(gbSocketInit == 0)
    6ca6:	4b0a      	ldr	r3, [pc, #40]	; (6cd0 <socketInit+0x2c>)
    6ca8:	781b      	ldrb	r3, [r3, #0]
    6caa:	2b00      	cmp	r3, #0
    6cac:	d10e      	bne.n	6ccc <socketInit+0x28>
	{
		m2m_memset((uint8*)gastrSockets, 0, MAX_SOCKET * sizeof(tstrSocket));
    6cae:	22b0      	movs	r2, #176	; 0xb0
    6cb0:	2100      	movs	r1, #0
    6cb2:	4808      	ldr	r0, [pc, #32]	; (6cd4 <socketInit+0x30>)
    6cb4:	4b08      	ldr	r3, [pc, #32]	; (6cd8 <socketInit+0x34>)
    6cb6:	4798      	blx	r3
		hif_register_cb(M2M_REQ_GROUP_IP,m2m_ip_cb);
    6cb8:	4908      	ldr	r1, [pc, #32]	; (6cdc <socketInit+0x38>)
    6cba:	2002      	movs	r0, #2
    6cbc:	4b08      	ldr	r3, [pc, #32]	; (6ce0 <socketInit+0x3c>)
    6cbe:	4798      	blx	r3
		gbSocketInit	= 1;
    6cc0:	2201      	movs	r2, #1
    6cc2:	4b03      	ldr	r3, [pc, #12]	; (6cd0 <socketInit+0x2c>)
    6cc4:	701a      	strb	r2, [r3, #0]
		gu16SessionID	= 0;
    6cc6:	2200      	movs	r2, #0
    6cc8:	4b06      	ldr	r3, [pc, #24]	; (6ce4 <socketInit+0x40>)
    6cca:	801a      	strh	r2, [r3, #0]
	}
}
    6ccc:	bd10      	pop	{r4, pc}
    6cce:	46c0      	nop			; (mov r8, r8)
    6cd0:	200008db 	.word	0x200008db
    6cd4:	2000229c 	.word	0x2000229c
    6cd8:	0000426d 	.word	0x0000426d
    6cdc:	000069ad 	.word	0x000069ad
    6ce0:	00004a7d 	.word	0x00004a7d
    6ce4:	200008dc 	.word	0x200008dc

00006ce8 <registerSocketCallback>:
Date
		4 June 2012
*********************************************************************/
void registerSocketCallback(tpfAppSocketCb pfAppSocketCb, tpfAppResolveCb pfAppResolveCb)
{
	gpfAppSocketCb = pfAppSocketCb;
    6ce8:	4b02      	ldr	r3, [pc, #8]	; (6cf4 <registerSocketCallback+0xc>)
    6cea:	6018      	str	r0, [r3, #0]
	gpfAppResolveCb = pfAppResolveCb;
    6cec:	4b02      	ldr	r3, [pc, #8]	; (6cf8 <registerSocketCallback+0x10>)
    6cee:	6019      	str	r1, [r3, #0]
}
    6cf0:	4770      	bx	lr
    6cf2:	46c0      	nop			; (mov r8, r8)
    6cf4:	2000234c 	.word	0x2000234c
    6cf8:	20002354 	.word	0x20002354

00006cfc <socket>:

Date
		4 June 2012
*********************************************************************/
SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
{
    6cfc:	b5f0      	push	{r4, r5, r6, r7, lr}
    6cfe:	4657      	mov	r7, sl
    6d00:	464e      	mov	r6, r9
    6d02:	b4c0      	push	{r6, r7}
    6d04:	b089      	sub	sp, #36	; 0x24
    6d06:	9205      	str	r2, [sp, #20]
	volatile tstrSocket		*pstrSock;
	static volatile uint8	u8NextTcpSock	= 0;
	static volatile uint8	u8NextUdpSock	= 0;

	/* The only supported family is the AF_INET for UDP and TCP transport layer protocols. */
	if(u16Domain == AF_INET)
    6d08:	2802      	cmp	r0, #2
    6d0a:	d000      	beq.n	6d0e <socket+0x12>
    6d0c:	e094      	b.n	6e38 <socket+0x13c>
	{
		if(u8Type == SOCK_STREAM)
    6d0e:	2901      	cmp	r1, #1
    6d10:	d133      	bne.n	6d7a <socket+0x7e>
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
			{
				u8SockID	= u8NextTcpSock;
    6d12:	4c4f      	ldr	r4, [pc, #316]	; (6e50 <socket+0x154>)
    6d14:	7825      	ldrb	r5, [r4, #0]
    6d16:	b2ef      	uxtb	r7, r5
				pstrSock	= &gastrSockets[u8NextTcpSock];
    6d18:	7823      	ldrb	r3, [r4, #0]
    6d1a:	b2de      	uxtb	r6, r3
				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
    6d1c:	7820      	ldrb	r0, [r4, #0]
    6d1e:	3001      	adds	r0, #1
    6d20:	3106      	adds	r1, #6
    6d22:	4b4c      	ldr	r3, [pc, #304]	; (6e54 <socket+0x158>)
    6d24:	4798      	blx	r3
    6d26:	b2c9      	uxtb	r1, r1
    6d28:	7021      	strb	r1, [r4, #0]
				if(!pstrSock->bIsUsed)
    6d2a:	0133      	lsls	r3, r6, #4
    6d2c:	4a4a      	ldr	r2, [pc, #296]	; (6e58 <socket+0x15c>)
    6d2e:	18d3      	adds	r3, r2, r3
    6d30:	7a9b      	ldrb	r3, [r3, #10]
    6d32:	2506      	movs	r5, #6
    6d34:	2b00      	cmp	r3, #0
    6d36:	d102      	bne.n	6d3e <socket+0x42>
		if(u8Type == SOCK_STREAM)
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
			{
				u8SockID	= u8NextTcpSock;
				pstrSock	= &gastrSockets[u8NextTcpSock];
    6d38:	0134      	lsls	r4, r6, #4
    6d3a:	18a4      	adds	r4, r4, r2
    6d3c:	e016      	b.n	6d6c <socket+0x70>
	{
		if(u8Type == SOCK_STREAM)
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
			{
				u8SockID	= u8NextTcpSock;
    6d3e:	4c44      	ldr	r4, [pc, #272]	; (6e50 <socket+0x154>)
				pstrSock	= &gastrSockets[u8NextTcpSock];
				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
    6d40:	4b44      	ldr	r3, [pc, #272]	; (6e54 <socket+0x158>)
    6d42:	469a      	mov	sl, r3
				if(!pstrSock->bIsUsed)
    6d44:	4b44      	ldr	r3, [pc, #272]	; (6e58 <socket+0x15c>)
    6d46:	4699      	mov	r9, r3
	{
		if(u8Type == SOCK_STREAM)
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
			{
				u8SockID	= u8NextTcpSock;
    6d48:	7827      	ldrb	r7, [r4, #0]
    6d4a:	b2ff      	uxtb	r7, r7
				pstrSock	= &gastrSockets[u8NextTcpSock];
    6d4c:	7823      	ldrb	r3, [r4, #0]
    6d4e:	b2de      	uxtb	r6, r3
				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
    6d50:	7820      	ldrb	r0, [r4, #0]
    6d52:	3001      	adds	r0, #1
    6d54:	2107      	movs	r1, #7
    6d56:	47d0      	blx	sl
    6d58:	b2c9      	uxtb	r1, r1
    6d5a:	7021      	strb	r1, [r4, #0]
				if(!pstrSock->bIsUsed)
    6d5c:	0133      	lsls	r3, r6, #4
    6d5e:	444b      	add	r3, r9
    6d60:	7a9b      	ldrb	r3, [r3, #10]
    6d62:	2b00      	cmp	r3, #0
    6d64:	d104      	bne.n	6d70 <socket+0x74>
		if(u8Type == SOCK_STREAM)
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
			{
				u8SockID	= u8NextTcpSock;
				pstrSock	= &gastrSockets[u8NextTcpSock];
    6d66:	0134      	lsls	r4, r6, #4
    6d68:	4b3b      	ldr	r3, [pc, #236]	; (6e58 <socket+0x15c>)
    6d6a:	18e4      	adds	r4, r4, r3
				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
				if(!pstrSock->bIsUsed)
				{
					sock = (SOCKET)u8SockID;
    6d6c:	b27d      	sxtb	r5, r7
					break;
    6d6e:	e02d      	b.n	6dcc <socket+0xd0>
    6d70:	3d01      	subs	r5, #1
    6d72:	b2ed      	uxtb	r5, r5
	/* The only supported family is the AF_INET for UDP and TCP transport layer protocols. */
	if(u16Domain == AF_INET)
	{
		if(u8Type == SOCK_STREAM)
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
    6d74:	2d00      	cmp	r5, #0
    6d76:	d1e7      	bne.n	6d48 <socket+0x4c>
    6d78:	e061      	b.n	6e3e <socket+0x142>
					sock = (SOCKET)u8SockID;
					break;
				}
			}
		}
		else if(u8Type == SOCK_DGRAM)
    6d7a:	2902      	cmp	r1, #2
    6d7c:	d15f      	bne.n	6e3e <socket+0x142>
		{
			volatile tstrSocket	*pastrUDPSockets = &gastrSockets[TCP_SOCK_MAX];
			for(u8Count = 0; u8Count < UDP_SOCK_MAX; u8Count ++)
			{
				u8SockID		= u8NextUdpSock;
    6d7e:	4a37      	ldr	r2, [pc, #220]	; (6e5c <socket+0x160>)
    6d80:	7815      	ldrb	r5, [r2, #0]
    6d82:	b2ed      	uxtb	r5, r5
				pstrSock		= &pastrUDPSockets[u8NextUdpSock];
    6d84:	7814      	ldrb	r4, [r2, #0]
    6d86:	0124      	lsls	r4, r4, #4
    6d88:	4b35      	ldr	r3, [pc, #212]	; (6e60 <socket+0x164>)
    6d8a:	18e4      	adds	r4, r4, r3
				u8NextUdpSock	= (u8NextUdpSock + 1) % UDP_SOCK_MAX;
    6d8c:	7813      	ldrb	r3, [r2, #0]
    6d8e:	3301      	adds	r3, #1
    6d90:	3101      	adds	r1, #1
    6d92:	400b      	ands	r3, r1
    6d94:	7013      	strb	r3, [r2, #0]
				if(!pstrSock->bIsUsed)
    6d96:	7aa3      	ldrb	r3, [r4, #10]
    6d98:	2b00      	cmp	r3, #0
    6d9a:	d00f      	beq.n	6dbc <socket+0xc0>
    6d9c:	2203      	movs	r2, #3
		else if(u8Type == SOCK_DGRAM)
		{
			volatile tstrSocket	*pastrUDPSockets = &gastrSockets[TCP_SOCK_MAX];
			for(u8Count = 0; u8Count < UDP_SOCK_MAX; u8Count ++)
			{
				u8SockID		= u8NextUdpSock;
    6d9e:	492f      	ldr	r1, [pc, #188]	; (6e5c <socket+0x160>)
				pstrSock		= &pastrUDPSockets[u8NextUdpSock];
    6da0:	4f2f      	ldr	r7, [pc, #188]	; (6e60 <socket+0x164>)
				u8NextUdpSock	= (u8NextUdpSock + 1) % UDP_SOCK_MAX;
    6da2:	2003      	movs	r0, #3
		else if(u8Type == SOCK_DGRAM)
		{
			volatile tstrSocket	*pastrUDPSockets = &gastrSockets[TCP_SOCK_MAX];
			for(u8Count = 0; u8Count < UDP_SOCK_MAX; u8Count ++)
			{
				u8SockID		= u8NextUdpSock;
    6da4:	780d      	ldrb	r5, [r1, #0]
    6da6:	b2ed      	uxtb	r5, r5
				pstrSock		= &pastrUDPSockets[u8NextUdpSock];
    6da8:	780c      	ldrb	r4, [r1, #0]
    6daa:	0124      	lsls	r4, r4, #4
    6dac:	19e4      	adds	r4, r4, r7
				u8NextUdpSock	= (u8NextUdpSock + 1) % UDP_SOCK_MAX;
    6dae:	780b      	ldrb	r3, [r1, #0]
    6db0:	3301      	adds	r3, #1
    6db2:	4003      	ands	r3, r0
    6db4:	700b      	strb	r3, [r1, #0]
				if(!pstrSock->bIsUsed)
    6db6:	7aa3      	ldrb	r3, [r4, #10]
    6db8:	2b00      	cmp	r3, #0
    6dba:	d102      	bne.n	6dc2 <socket+0xc6>
				{
					sock = (SOCKET)(u8SockID + TCP_SOCK_MAX);
    6dbc:	3507      	adds	r5, #7
    6dbe:	b26d      	sxtb	r5, r5
					break;
    6dc0:	e004      	b.n	6dcc <socket+0xd0>
    6dc2:	3a01      	subs	r2, #1
    6dc4:	b2d2      	uxtb	r2, r2
			}
		}
		else if(u8Type == SOCK_DGRAM)
		{
			volatile tstrSocket	*pastrUDPSockets = &gastrSockets[TCP_SOCK_MAX];
			for(u8Count = 0; u8Count < UDP_SOCK_MAX; u8Count ++)
    6dc6:	2a00      	cmp	r2, #0
    6dc8:	d1ec      	bne.n	6da4 <socket+0xa8>
    6dca:	e038      	b.n	6e3e <socket+0x142>
					break;
				}
			}
		}

		if(sock >= 0)
    6dcc:	2d00      	cmp	r5, #0
    6dce:	db38      	blt.n	6e42 <socket+0x146>
		{
			m2m_memset((uint8*)pstrSock, 0, sizeof(tstrSocket));
    6dd0:	2210      	movs	r2, #16
    6dd2:	2100      	movs	r1, #0
    6dd4:	0020      	movs	r0, r4
    6dd6:	4b23      	ldr	r3, [pc, #140]	; (6e64 <socket+0x168>)
    6dd8:	4798      	blx	r3
			pstrSock->bIsUsed = 1;
    6dda:	2301      	movs	r3, #1
    6ddc:	72a3      	strb	r3, [r4, #10]

			/* The session ID is used to distinguish different socket connections
				by comparing the assigned session ID to the one reported by the firmware*/
			++gu16SessionID;
    6dde:	4a22      	ldr	r2, [pc, #136]	; (6e68 <socket+0x16c>)
    6de0:	8813      	ldrh	r3, [r2, #0]
    6de2:	3301      	adds	r3, #1
    6de4:	b29b      	uxth	r3, r3
    6de6:	8013      	strh	r3, [r2, #0]
			if(gu16SessionID == 0)
    6de8:	8813      	ldrh	r3, [r2, #0]
    6dea:	b29b      	uxth	r3, r3
    6dec:	2b00      	cmp	r3, #0
    6dee:	d103      	bne.n	6df8 <socket+0xfc>
				++gu16SessionID;
    6df0:	8813      	ldrh	r3, [r2, #0]
    6df2:	3301      	adds	r3, #1
    6df4:	b29b      	uxth	r3, r3
    6df6:	8013      	strh	r3, [r2, #0]
				
			pstrSock->u16SessionID = gu16SessionID;
    6df8:	4e1b      	ldr	r6, [pc, #108]	; (6e68 <socket+0x16c>)
    6dfa:	8833      	ldrh	r3, [r6, #0]
    6dfc:	b29b      	uxth	r3, r3
    6dfe:	80e3      	strh	r3, [r4, #6]
            M2M_INFO("Socket %d session ID = %d\r\n",sock, gu16SessionID );
    6e00:	481a      	ldr	r0, [pc, #104]	; (6e6c <socket+0x170>)
    6e02:	4f1b      	ldr	r7, [pc, #108]	; (6e70 <socket+0x174>)
    6e04:	47b8      	blx	r7
    6e06:	8832      	ldrh	r2, [r6, #0]
    6e08:	b292      	uxth	r2, r2
    6e0a:	0029      	movs	r1, r5
    6e0c:	4819      	ldr	r0, [pc, #100]	; (6e74 <socket+0x178>)
    6e0e:	47b8      	blx	r7
    6e10:	200d      	movs	r0, #13
    6e12:	4b19      	ldr	r3, [pc, #100]	; (6e78 <socket+0x17c>)
    6e14:	4798      	blx	r3

			if(u8Flags & SOCKET_FLAGS_SSL)
    6e16:	9b05      	ldr	r3, [sp, #20]
    6e18:	07db      	lsls	r3, r3, #31
    6e1a:	d512      	bpl.n	6e42 <socket+0x146>
			{
				tstrSSLSocketCreateCmd	strSSLCreate;
				strSSLCreate.sslSock = sock;
    6e1c:	aa07      	add	r2, sp, #28
    6e1e:	7015      	strb	r5, [r2, #0]
				pstrSock->u8SSLFlags = SSL_FLAGS_ACTIVE | SSL_FLAGS_NO_TX_COPY;
    6e20:	2321      	movs	r3, #33	; 0x21
    6e22:	72e3      	strb	r3, [r4, #11]
				SOCKET_REQUEST(SOCKET_CMD_SSL_CREATE, (uint8*)&strSSLCreate, sizeof(tstrSSLSocketCreateCmd), 0, 0, 0);
    6e24:	2300      	movs	r3, #0
    6e26:	9302      	str	r3, [sp, #8]
    6e28:	9301      	str	r3, [sp, #4]
    6e2a:	9300      	str	r3, [sp, #0]
    6e2c:	3304      	adds	r3, #4
    6e2e:	2150      	movs	r1, #80	; 0x50
    6e30:	2002      	movs	r0, #2
    6e32:	4c12      	ldr	r4, [pc, #72]	; (6e7c <socket+0x180>)
    6e34:	47a0      	blx	r4
    6e36:	e004      	b.n	6e42 <socket+0x146>
Date
		4 June 2012
*********************************************************************/
SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
{
	SOCKET					sock = -1;
    6e38:	2501      	movs	r5, #1
    6e3a:	426d      	negs	r5, r5
    6e3c:	e001      	b.n	6e42 <socket+0x146>
    6e3e:	2501      	movs	r5, #1
    6e40:	426d      	negs	r5, r5
				SOCKET_REQUEST(SOCKET_CMD_SSL_CREATE, (uint8*)&strSSLCreate, sizeof(tstrSSLSocketCreateCmd), 0, 0, 0);
			}
		}
	}
	return sock;
}
    6e42:	0028      	movs	r0, r5
    6e44:	b009      	add	sp, #36	; 0x24
    6e46:	bc0c      	pop	{r2, r3}
    6e48:	4691      	mov	r9, r2
    6e4a:	469a      	mov	sl, r3
    6e4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6e4e:	46c0      	nop			; (mov r8, r8)
    6e50:	200008d9 	.word	0x200008d9
    6e54:	0000fb0d 	.word	0x0000fb0d
    6e58:	2000229c 	.word	0x2000229c
    6e5c:	200008da 	.word	0x200008da
    6e60:	2000230c 	.word	0x2000230c
    6e64:	0000426d 	.word	0x0000426d
    6e68:	200008dc 	.word	0x200008dc
    6e6c:	00013ca0 	.word	0x00013ca0
    6e70:	0001198d 	.word	0x0001198d
    6e74:	000150f8 	.word	0x000150f8
    6e78:	000119c1 	.word	0x000119c1
    6e7c:	0000437d 	.word	0x0000437d

00006e80 <bind>:

Date
		5 June 2012
*********************************************************************/
sint8 bind(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
    6e80:	b570      	push	{r4, r5, r6, lr}
    6e82:	b088      	sub	sp, #32
    6e84:	0004      	movs	r4, r0
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if((pstrAddr != NULL) && (sock >= 0) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
    6e86:	2900      	cmp	r1, #0
    6e88:	d02a      	beq.n	6ee0 <bind+0x60>
    6e8a:	2800      	cmp	r0, #0
    6e8c:	db2b      	blt.n	6ee6 <bind+0x66>
    6e8e:	0103      	lsls	r3, r0, #4
    6e90:	481a      	ldr	r0, [pc, #104]	; (6efc <bind+0x7c>)
    6e92:	18c3      	adds	r3, r0, r3
    6e94:	7a9b      	ldrb	r3, [r3, #10]
    6e96:	2b01      	cmp	r3, #1
    6e98:	d128      	bne.n	6eec <bind+0x6c>
    6e9a:	2a00      	cmp	r2, #0
    6e9c:	d029      	beq.n	6ef2 <bind+0x72>
	{
		tstrBindCmd			strBind;
		uint8				u8CMD = SOCKET_CMD_BIND;
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    6e9e:	0123      	lsls	r3, r4, #4
    6ea0:	18c3      	adds	r3, r0, r3
    6ea2:	7adb      	ldrb	r3, [r3, #11]
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if((pstrAddr != NULL) && (sock >= 0) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
	{
		tstrBindCmd			strBind;
		uint8				u8CMD = SOCKET_CMD_BIND;
    6ea4:	2641      	movs	r6, #65	; 0x41
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    6ea6:	07db      	lsls	r3, r3, #31
    6ea8:	d500      	bpl.n	6eac <bind+0x2c>
		{
			u8CMD = SOCKET_CMD_SSL_BIND;
    6eaa:	3613      	adds	r6, #19
		}

		/* Build the bind request. */
		strBind.sock = sock;
    6eac:	ad05      	add	r5, sp, #20
    6eae:	722c      	strb	r4, [r5, #8]
		m2m_memcpy((uint8 *)&strBind.strAddr, (uint8 *)pstrAddr, sizeof(tstrSockAddr));
    6eb0:	2208      	movs	r2, #8
    6eb2:	0028      	movs	r0, r5
    6eb4:	4b12      	ldr	r3, [pc, #72]	; (6f00 <bind+0x80>)
    6eb6:	4798      	blx	r3
		strBind.u16SessionID		= gastrSockets[sock].u16SessionID;
    6eb8:	0124      	lsls	r4, r4, #4
    6eba:	4b10      	ldr	r3, [pc, #64]	; (6efc <bind+0x7c>)
    6ebc:	191c      	adds	r4, r3, r4
    6ebe:	88e3      	ldrh	r3, [r4, #6]
    6ec0:	816b      	strh	r3, [r5, #10]
		
		/* Send the request. */
		s8Ret = SOCKET_REQUEST(u8CMD, (uint8*)&strBind,sizeof(tstrBindCmd) , NULL , 0, 0);
    6ec2:	2300      	movs	r3, #0
    6ec4:	9302      	str	r3, [sp, #8]
    6ec6:	9301      	str	r3, [sp, #4]
    6ec8:	9300      	str	r3, [sp, #0]
    6eca:	330c      	adds	r3, #12
    6ecc:	002a      	movs	r2, r5
    6ece:	0031      	movs	r1, r6
    6ed0:	2002      	movs	r0, #2
    6ed2:	4c0c      	ldr	r4, [pc, #48]	; (6f04 <bind+0x84>)
    6ed4:	47a0      	blx	r4
		if(s8Ret != SOCK_ERR_NO_ERROR)
    6ed6:	2800      	cmp	r0, #0
    6ed8:	d00d      	beq.n	6ef6 <bind+0x76>
		{
			s8Ret = SOCK_ERR_INVALID;
    6eda:	2009      	movs	r0, #9
    6edc:	4240      	negs	r0, r0
    6ede:	e00a      	b.n	6ef6 <bind+0x76>
Date
		5 June 2012
*********************************************************************/
sint8 bind(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    6ee0:	2006      	movs	r0, #6
    6ee2:	4240      	negs	r0, r0
    6ee4:	e007      	b.n	6ef6 <bind+0x76>
    6ee6:	2006      	movs	r0, #6
    6ee8:	4240      	negs	r0, r0
    6eea:	e004      	b.n	6ef6 <bind+0x76>
    6eec:	2006      	movs	r0, #6
    6eee:	4240      	negs	r0, r0
    6ef0:	e001      	b.n	6ef6 <bind+0x76>
    6ef2:	2006      	movs	r0, #6
    6ef4:	4240      	negs	r0, r0
		{
			s8Ret = SOCK_ERR_INVALID;
		}
	}
	return s8Ret;
}
    6ef6:	b008      	add	sp, #32
    6ef8:	bd70      	pop	{r4, r5, r6, pc}
    6efa:	46c0      	nop			; (mov r8, r8)
    6efc:	2000229c 	.word	0x2000229c
    6f00:	00004259 	.word	0x00004259
    6f04:	0000437d 	.word	0x0000437d

00006f08 <listen>:

Date
		5 June 2012
*********************************************************************/
sint8 listen(SOCKET sock, uint8 backlog)
{
    6f08:	b510      	push	{r4, lr}
    6f0a:	b086      	sub	sp, #24
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	
	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))
    6f0c:	2800      	cmp	r0, #0
    6f0e:	db1b      	blt.n	6f48 <listen+0x40>
    6f10:	0103      	lsls	r3, r0, #4
    6f12:	4a11      	ldr	r2, [pc, #68]	; (6f58 <listen+0x50>)
    6f14:	18d3      	adds	r3, r2, r3
    6f16:	7a9b      	ldrb	r3, [r3, #10]
    6f18:	2b01      	cmp	r3, #1
    6f1a:	d118      	bne.n	6f4e <listen+0x46>
	{
		tstrListenCmd		strListen;

		strListen.sock = sock;
    6f1c:	aa05      	add	r2, sp, #20
    6f1e:	7010      	strb	r0, [r2, #0]
		strListen.u8BackLog = backlog;
    6f20:	7051      	strb	r1, [r2, #1]
		strListen.u16SessionID		= gastrSockets[sock].u16SessionID;
    6f22:	0100      	lsls	r0, r0, #4
    6f24:	4b0c      	ldr	r3, [pc, #48]	; (6f58 <listen+0x50>)
    6f26:	1818      	adds	r0, r3, r0
    6f28:	88c3      	ldrh	r3, [r0, #6]
    6f2a:	8053      	strh	r3, [r2, #2]

		s8Ret = SOCKET_REQUEST(SOCKET_CMD_LISTEN, (uint8*)&strListen, sizeof(tstrListenCmd), NULL, 0, 0);
    6f2c:	2300      	movs	r3, #0
    6f2e:	9302      	str	r3, [sp, #8]
    6f30:	9301      	str	r3, [sp, #4]
    6f32:	9300      	str	r3, [sp, #0]
    6f34:	3304      	adds	r3, #4
    6f36:	2142      	movs	r1, #66	; 0x42
    6f38:	2002      	movs	r0, #2
    6f3a:	4c08      	ldr	r4, [pc, #32]	; (6f5c <listen+0x54>)
    6f3c:	47a0      	blx	r4
		if(s8Ret != SOCK_ERR_NO_ERROR)
    6f3e:	2800      	cmp	r0, #0
    6f40:	d007      	beq.n	6f52 <listen+0x4a>
		{
			s8Ret = SOCK_ERR_INVALID;
    6f42:	2009      	movs	r0, #9
    6f44:	4240      	negs	r0, r0
    6f46:	e004      	b.n	6f52 <listen+0x4a>
Date
		5 June 2012
*********************************************************************/
sint8 listen(SOCKET sock, uint8 backlog)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    6f48:	2006      	movs	r0, #6
    6f4a:	4240      	negs	r0, r0
    6f4c:	e001      	b.n	6f52 <listen+0x4a>
    6f4e:	2006      	movs	r0, #6
    6f50:	4240      	negs	r0, r0
		{
			s8Ret = SOCK_ERR_INVALID;
		}
	}
	return s8Ret;
}
    6f52:	b006      	add	sp, #24
    6f54:	bd10      	pop	{r4, pc}
    6f56:	46c0      	nop			; (mov r8, r8)
    6f58:	2000229c 	.word	0x2000229c
    6f5c:	0000437d 	.word	0x0000437d

00006f60 <accept>:
*********************************************************************/
sint8 accept(SOCKET sock, struct sockaddr *addr, uint8 *addrlen)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	
	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1) )
    6f60:	2800      	cmp	r0, #0
    6f62:	db07      	blt.n	6f74 <accept+0x14>
    6f64:	0100      	lsls	r0, r0, #4
    6f66:	4b06      	ldr	r3, [pc, #24]	; (6f80 <accept+0x20>)
    6f68:	1818      	adds	r0, r3, r0
    6f6a:	7a83      	ldrb	r3, [r0, #10]
    6f6c:	2b01      	cmp	r3, #1
    6f6e:	d104      	bne.n	6f7a <accept+0x1a>
	{
		s8Ret = SOCK_ERR_NO_ERROR;
    6f70:	2000      	movs	r0, #0
    6f72:	e004      	b.n	6f7e <accept+0x1e>
Date
		5 June 2012
*********************************************************************/
sint8 accept(SOCKET sock, struct sockaddr *addr, uint8 *addrlen)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    6f74:	2006      	movs	r0, #6
    6f76:	4240      	negs	r0, r0
    6f78:	e001      	b.n	6f7e <accept+0x1e>
    6f7a:	2006      	movs	r0, #6
    6f7c:	4240      	negs	r0, r0
	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1) )
	{
		s8Ret = SOCK_ERR_NO_ERROR;
	}
	return s8Ret;
}
    6f7e:	4770      	bx	lr
    6f80:	2000229c 	.word	0x2000229c

00006f84 <connect>:

Date
		5 June 2012
*********************************************************************/
sint8 connect(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
    6f84:	b570      	push	{r4, r5, r6, lr}
    6f86:	b088      	sub	sp, #32
    6f88:	1e04      	subs	r4, r0, #0
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if((sock >= 0) && (pstrAddr != NULL) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
    6f8a:	db2f      	blt.n	6fec <connect+0x68>
    6f8c:	2900      	cmp	r1, #0
    6f8e:	d030      	beq.n	6ff2 <connect+0x6e>
    6f90:	0103      	lsls	r3, r0, #4
    6f92:	481d      	ldr	r0, [pc, #116]	; (7008 <connect+0x84>)
    6f94:	18c3      	adds	r3, r0, r3
    6f96:	7a9b      	ldrb	r3, [r3, #10]
    6f98:	2b01      	cmp	r3, #1
    6f9a:	d12d      	bne.n	6ff8 <connect+0x74>
    6f9c:	2a00      	cmp	r2, #0
    6f9e:	d02e      	beq.n	6ffe <connect+0x7a>
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
    6fa0:	0123      	lsls	r3, r4, #4
    6fa2:	18c3      	adds	r3, r0, r3
    6fa4:	7adb      	ldrb	r3, [r3, #11]
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if((sock >= 0) && (pstrAddr != NULL) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
    6fa6:	2644      	movs	r6, #68	; 0x44
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
    6fa8:	07db      	lsls	r3, r3, #31
    6faa:	d505      	bpl.n	6fb8 <connect+0x34>
		{
			u8Cmd = SOCKET_CMD_SSL_CONNECT;
			strConnect.u8SslFlags = gastrSockets[sock].u8SSLFlags;
    6fac:	0123      	lsls	r3, r4, #4
    6fae:	18c3      	adds	r3, r0, r3
    6fb0:	7ada      	ldrb	r2, [r3, #11]
    6fb2:	ab05      	add	r3, sp, #20
    6fb4:	725a      	strb	r2, [r3, #9]
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
		{
			u8Cmd = SOCKET_CMD_SSL_CONNECT;
    6fb6:	3607      	adds	r6, #7
			strConnect.u8SslFlags = gastrSockets[sock].u8SSLFlags;
		}
		strConnect.sock = sock;
    6fb8:	ad05      	add	r5, sp, #20
    6fba:	722c      	strb	r4, [r5, #8]
		m2m_memcpy((uint8 *)&strConnect.strAddr, (uint8 *)pstrAddr, sizeof(tstrSockAddr));
    6fbc:	2208      	movs	r2, #8
    6fbe:	0028      	movs	r0, r5
    6fc0:	4b12      	ldr	r3, [pc, #72]	; (700c <connect+0x88>)
    6fc2:	4798      	blx	r3

		strConnect.u16SessionID		= gastrSockets[sock].u16SessionID;
    6fc4:	0124      	lsls	r4, r4, #4
    6fc6:	4b10      	ldr	r3, [pc, #64]	; (7008 <connect+0x84>)
    6fc8:	191c      	adds	r4, r3, r4
    6fca:	88e3      	ldrh	r3, [r4, #6]
    6fcc:	816b      	strh	r3, [r5, #10]
		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strConnect,sizeof(tstrConnectCmd), NULL, 0, 0);
    6fce:	2300      	movs	r3, #0
    6fd0:	9302      	str	r3, [sp, #8]
    6fd2:	9301      	str	r3, [sp, #4]
    6fd4:	9300      	str	r3, [sp, #0]
    6fd6:	330c      	adds	r3, #12
    6fd8:	002a      	movs	r2, r5
    6fda:	0031      	movs	r1, r6
    6fdc:	2002      	movs	r0, #2
    6fde:	4c0c      	ldr	r4, [pc, #48]	; (7010 <connect+0x8c>)
    6fe0:	47a0      	blx	r4
		if(s8Ret != SOCK_ERR_NO_ERROR)
    6fe2:	2800      	cmp	r0, #0
    6fe4:	d00d      	beq.n	7002 <connect+0x7e>
		{
			s8Ret = SOCK_ERR_INVALID;
    6fe6:	2009      	movs	r0, #9
    6fe8:	4240      	negs	r0, r0
    6fea:	e00a      	b.n	7002 <connect+0x7e>
Date
		5 June 2012
*********************************************************************/
sint8 connect(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    6fec:	2006      	movs	r0, #6
    6fee:	4240      	negs	r0, r0
    6ff0:	e007      	b.n	7002 <connect+0x7e>
    6ff2:	2006      	movs	r0, #6
    6ff4:	4240      	negs	r0, r0
    6ff6:	e004      	b.n	7002 <connect+0x7e>
    6ff8:	2006      	movs	r0, #6
    6ffa:	4240      	negs	r0, r0
    6ffc:	e001      	b.n	7002 <connect+0x7e>
    6ffe:	2006      	movs	r0, #6
    7000:	4240      	negs	r0, r0
		{
			s8Ret = SOCK_ERR_INVALID;
		}
	}
	return s8Ret;
}
    7002:	b008      	add	sp, #32
    7004:	bd70      	pop	{r4, r5, r6, pc}
    7006:	46c0      	nop			; (mov r8, r8)
    7008:	2000229c 	.word	0x2000229c
    700c:	00004259 	.word	0x00004259
    7010:	0000437d 	.word	0x0000437d

00007014 <send>:

Date
		5 June 2012
*********************************************************************/
sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags)
{
    7014:	b530      	push	{r4, r5, lr}
    7016:	b089      	sub	sp, #36	; 0x24
    7018:	000c      	movs	r4, r1
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvSendBuffer != NULL) && (u16SendLength <= SOCKET_BUFFER_MAX_LENGTH) && (gastrSockets[sock].bIsUsed == 1))
    701a:	2800      	cmp	r0, #0
    701c:	db33      	blt.n	7086 <send+0x72>
    701e:	2900      	cmp	r1, #0
    7020:	d034      	beq.n	708c <send+0x78>
    7022:	23af      	movs	r3, #175	; 0xaf
    7024:	00db      	lsls	r3, r3, #3
    7026:	429a      	cmp	r2, r3
    7028:	d833      	bhi.n	7092 <send+0x7e>
    702a:	0103      	lsls	r3, r0, #4
    702c:	491d      	ldr	r1, [pc, #116]	; (70a4 <send+0x90>)
    702e:	18cb      	adds	r3, r1, r3
    7030:	7a9b      	ldrb	r3, [r3, #10]
    7032:	2b01      	cmp	r3, #1
    7034:	d130      	bne.n	7098 <send+0x84>
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
		u16DataOffset	= TCP_TX_PACKET_OFFSET;

		strSend.sock			= sock;
    7036:	a904      	add	r1, sp, #16
    7038:	7008      	strb	r0, [r1, #0]
		strSend.u16DataSize		= NM_BSP_B_L_16(u16SendLength);
    703a:	804a      	strh	r2, [r1, #2]
		strSend.u16SessionID	= gastrSockets[sock].u16SessionID;
    703c:	0103      	lsls	r3, r0, #4
    703e:	4d19      	ldr	r5, [pc, #100]	; (70a4 <send+0x90>)
    7040:	18eb      	adds	r3, r5, r3
    7042:	88db      	ldrh	r3, [r3, #6]
    7044:	818b      	strh	r3, [r1, #12]
		uint16			u16DataOffset;
		tstrSendCmd		strSend;
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
		u16DataOffset	= TCP_TX_PACKET_OFFSET;
    7046:	2550      	movs	r5, #80	; 0x50

		strSend.sock			= sock;
		strSend.u16DataSize		= NM_BSP_B_L_16(u16SendLength);
		strSend.u16SessionID	= gastrSockets[sock].u16SessionID;

		if(sock >= TCP_SOCK_MAX)
    7048:	2806      	cmp	r0, #6
    704a:	dd00      	ble.n	704e <send+0x3a>
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
    704c:	3d0c      	subs	r5, #12
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    704e:	0103      	lsls	r3, r0, #4
    7050:	4914      	ldr	r1, [pc, #80]	; (70a4 <send+0x90>)
    7052:	18cb      	adds	r3, r1, r3
    7054:	7adb      	ldrb	r3, [r3, #11]
	{
		uint16			u16DataOffset;
		tstrSendCmd		strSend;
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
    7056:	2145      	movs	r1, #69	; 0x45

		if(sock >= TCP_SOCK_MAX)
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    7058:	07db      	lsls	r3, r3, #31
    705a:	d505      	bpl.n	7068 <send+0x54>
		{
			u8Cmd			= SOCKET_CMD_SSL_SEND;
			u16DataOffset	= gastrSockets[sock].u16DataOffset;
    705c:	0100      	lsls	r0, r0, #4
    705e:	4b11      	ldr	r3, [pc, #68]	; (70a4 <send+0x90>)
    7060:	1818      	adds	r0, r3, r0
    7062:	8905      	ldrh	r5, [r0, #8]
    7064:	b2ad      	uxth	r5, r5
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
		{
			u8Cmd			= SOCKET_CMD_SSL_SEND;
    7066:	3107      	adds	r1, #7
			u16DataOffset	= gastrSockets[sock].u16DataOffset;
		}

		s16Ret =  SOCKET_REQUEST(u8Cmd|M2M_REQ_DATA_PKT, (uint8*)&strSend, sizeof(tstrSendCmd), pvSendBuffer, u16SendLength, u16DataOffset);
    7068:	2380      	movs	r3, #128	; 0x80
    706a:	4319      	orrs	r1, r3
    706c:	9502      	str	r5, [sp, #8]
    706e:	9201      	str	r2, [sp, #4]
    7070:	9400      	str	r4, [sp, #0]
    7072:	3b70      	subs	r3, #112	; 0x70
    7074:	aa04      	add	r2, sp, #16
    7076:	2002      	movs	r0, #2
    7078:	4c0b      	ldr	r4, [pc, #44]	; (70a8 <send+0x94>)
    707a:	47a0      	blx	r4
    707c:	2300      	movs	r3, #0
		if(s16Ret != SOCK_ERR_NO_ERROR)
    707e:	2800      	cmp	r0, #0
    7080:	d00c      	beq.n	709c <send+0x88>
		{
			s16Ret = SOCK_ERR_BUFFER_FULL;
    7082:	3b0e      	subs	r3, #14
    7084:	e00a      	b.n	709c <send+0x88>
Date
		5 June 2012
*********************************************************************/
sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags)
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
    7086:	2306      	movs	r3, #6
    7088:	425b      	negs	r3, r3
    708a:	e007      	b.n	709c <send+0x88>
    708c:	2306      	movs	r3, #6
    708e:	425b      	negs	r3, r3
    7090:	e004      	b.n	709c <send+0x88>
    7092:	2306      	movs	r3, #6
    7094:	425b      	negs	r3, r3
    7096:	e001      	b.n	709c <send+0x88>
    7098:	2306      	movs	r3, #6
    709a:	425b      	negs	r3, r3
		{
			s16Ret = SOCK_ERR_BUFFER_FULL;
		}
	}
	return s16Ret;
}
    709c:	0018      	movs	r0, r3
    709e:	b009      	add	sp, #36	; 0x24
    70a0:	bd30      	pop	{r4, r5, pc}
    70a2:	46c0      	nop			; (mov r8, r8)
    70a4:	2000229c 	.word	0x2000229c
    70a8:	0000437d 	.word	0x0000437d

000070ac <recv>:

Date
		5 June 2012
*********************************************************************/
sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
{
    70ac:	b530      	push	{r4, r5, lr}
    70ae:	b087      	sub	sp, #28
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (gastrSockets[sock].bIsUsed == 1))
    70b0:	2800      	cmp	r0, #0
    70b2:	db33      	blt.n	711c <recv+0x70>
    70b4:	2900      	cmp	r1, #0
    70b6:	d034      	beq.n	7122 <recv+0x76>
    70b8:	2a00      	cmp	r2, #0
    70ba:	d035      	beq.n	7128 <recv+0x7c>
    70bc:	0104      	lsls	r4, r0, #4
    70be:	4d1e      	ldr	r5, [pc, #120]	; (7138 <recv+0x8c>)
    70c0:	192c      	adds	r4, r5, r4
    70c2:	7aa4      	ldrb	r4, [r4, #10]
    70c4:	2c01      	cmp	r4, #1
    70c6:	d132      	bne.n	712e <recv+0x82>
	{
		s16Ret = SOCK_ERR_NO_ERROR;
		gastrSockets[sock].pu8UserBuffer 		= (uint8*)pvRecvBuf;
    70c8:	0104      	lsls	r4, r0, #4
    70ca:	5161      	str	r1, [r4, r5]
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;
    70cc:	1929      	adds	r1, r5, r4
    70ce:	808a      	strh	r2, [r1, #4]

		if(!gastrSockets[sock].bIsRecvPending)
    70d0:	7b09      	ldrb	r1, [r1, #12]
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (gastrSockets[sock].bIsUsed == 1))
	{
		s16Ret = SOCK_ERR_NO_ERROR;
    70d2:	2200      	movs	r2, #0
		gastrSockets[sock].pu8UserBuffer 		= (uint8*)pvRecvBuf;
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;

		if(!gastrSockets[sock].bIsRecvPending)
    70d4:	2900      	cmp	r1, #0
    70d6:	d12c      	bne.n	7132 <recv+0x86>
		{
			tstrRecvCmd	strRecv;
			uint8		u8Cmd = SOCKET_CMD_RECV;

			gastrSockets[sock].bIsRecvPending = 1;
    70d8:	192a      	adds	r2, r5, r4
    70da:	2101      	movs	r1, #1
    70dc:	7311      	strb	r1, [r2, #12]
			if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    70de:	7ad2      	ldrb	r2, [r2, #11]
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;

		if(!gastrSockets[sock].bIsRecvPending)
		{
			tstrRecvCmd	strRecv;
			uint8		u8Cmd = SOCKET_CMD_RECV;
    70e0:	3145      	adds	r1, #69	; 0x45

			gastrSockets[sock].bIsRecvPending = 1;
			if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    70e2:	07d2      	lsls	r2, r2, #31
    70e4:	d500      	bpl.n	70e8 <recv+0x3c>
			{
				u8Cmd = SOCKET_CMD_SSL_RECV;
    70e6:	3107      	adds	r1, #7
			}

			/* Check the timeout value. */
			if(u32Timeoutmsec == 0)
    70e8:	2b00      	cmp	r3, #0
    70ea:	d102      	bne.n	70f2 <recv+0x46>
				strRecv.u32Timeoutmsec = 0xFFFFFFFF;
    70ec:	3b01      	subs	r3, #1
    70ee:	9304      	str	r3, [sp, #16]
    70f0:	e000      	b.n	70f4 <recv+0x48>
			else
				strRecv.u32Timeoutmsec = NM_BSP_B_L_32(u32Timeoutmsec);
    70f2:	9304      	str	r3, [sp, #16]
			strRecv.sock = sock;
    70f4:	aa04      	add	r2, sp, #16
    70f6:	7110      	strb	r0, [r2, #4]
			strRecv.u16SessionID		= gastrSockets[sock].u16SessionID;
    70f8:	0100      	lsls	r0, r0, #4
    70fa:	4b0f      	ldr	r3, [pc, #60]	; (7138 <recv+0x8c>)
    70fc:	1818      	adds	r0, r3, r0
    70fe:	88c3      	ldrh	r3, [r0, #6]
    7100:	80d3      	strh	r3, [r2, #6]
		
			s16Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strRecv, sizeof(tstrRecvCmd), NULL , 0, 0);
    7102:	2300      	movs	r3, #0
    7104:	9302      	str	r3, [sp, #8]
    7106:	9301      	str	r3, [sp, #4]
    7108:	9300      	str	r3, [sp, #0]
    710a:	3308      	adds	r3, #8
    710c:	2002      	movs	r0, #2
    710e:	4c0b      	ldr	r4, [pc, #44]	; (713c <recv+0x90>)
    7110:	47a0      	blx	r4
    7112:	2200      	movs	r2, #0
			if(s16Ret != SOCK_ERR_NO_ERROR)
    7114:	2800      	cmp	r0, #0
    7116:	d00c      	beq.n	7132 <recv+0x86>
			{
				s16Ret = SOCK_ERR_BUFFER_FULL;
    7118:	3a0e      	subs	r2, #14
    711a:	e00a      	b.n	7132 <recv+0x86>
Date
		5 June 2012
*********************************************************************/
sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
    711c:	2206      	movs	r2, #6
    711e:	4252      	negs	r2, r2
    7120:	e007      	b.n	7132 <recv+0x86>
    7122:	2206      	movs	r2, #6
    7124:	4252      	negs	r2, r2
    7126:	e004      	b.n	7132 <recv+0x86>
    7128:	2206      	movs	r2, #6
    712a:	4252      	negs	r2, r2
    712c:	e001      	b.n	7132 <recv+0x86>
    712e:	2206      	movs	r2, #6
    7130:	4252      	negs	r2, r2
				s16Ret = SOCK_ERR_BUFFER_FULL;
			}
		}
	}
	return s16Ret;
}
    7132:	0010      	movs	r0, r2
    7134:	b007      	add	sp, #28
    7136:	bd30      	pop	{r4, r5, pc}
    7138:	2000229c 	.word	0x2000229c
    713c:	0000437d 	.word	0x0000437d

00007140 <close>:

Date
		4 June 2012
*********************************************************************/
sint8 close(SOCKET sock)
{
    7140:	b530      	push	{r4, r5, lr}
    7142:	b087      	sub	sp, #28
    7144:	0004      	movs	r4, r0
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    M2M_INFO("Sock to delete <%d>\n", sock);
    7146:	481e      	ldr	r0, [pc, #120]	; (71c0 <close+0x80>)
    7148:	4d1e      	ldr	r5, [pc, #120]	; (71c4 <close+0x84>)
    714a:	47a8      	blx	r5
    714c:	0021      	movs	r1, r4
    714e:	481e      	ldr	r0, [pc, #120]	; (71c8 <close+0x88>)
    7150:	47a8      	blx	r5
    7152:	200d      	movs	r0, #13
    7154:	4b1d      	ldr	r3, [pc, #116]	; (71cc <close+0x8c>)
    7156:	4798      	blx	r3
	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))
    7158:	2c00      	cmp	r4, #0
    715a:	db29      	blt.n	71b0 <close+0x70>
    715c:	0123      	lsls	r3, r4, #4
    715e:	4a1c      	ldr	r2, [pc, #112]	; (71d0 <close+0x90>)
    7160:	18d3      	adds	r3, r2, r3
    7162:	7a9b      	ldrb	r3, [r3, #10]
    7164:	2b01      	cmp	r3, #1
    7166:	d126      	bne.n	71b6 <close+0x76>
	{
		uint8	u8Cmd = SOCKET_CMD_CLOSE;
		tstrCloseCmd strclose;
		strclose.sock = sock; 
    7168:	a905      	add	r1, sp, #20
    716a:	700c      	strb	r4, [r1, #0]
		strclose.u16SessionID		= gastrSockets[sock].u16SessionID;
    716c:	0122      	lsls	r2, r4, #4
    716e:	4b18      	ldr	r3, [pc, #96]	; (71d0 <close+0x90>)
    7170:	189b      	adds	r3, r3, r2
    7172:	88da      	ldrh	r2, [r3, #6]
    7174:	804a      	strh	r2, [r1, #2]
		
		gastrSockets[sock].bIsUsed = 0;
    7176:	2200      	movs	r2, #0
    7178:	729a      	strb	r2, [r3, #10]
		gastrSockets[sock].u16SessionID =0;
    717a:	80da      	strh	r2, [r3, #6]
		
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    717c:	7adb      	ldrb	r3, [r3, #11]
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    M2M_INFO("Sock to delete <%d>\n", sock);
	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))
	{
		uint8	u8Cmd = SOCKET_CMD_CLOSE;
    717e:	2149      	movs	r1, #73	; 0x49
		strclose.u16SessionID		= gastrSockets[sock].u16SessionID;
		
		gastrSockets[sock].bIsUsed = 0;
		gastrSockets[sock].u16SessionID =0;
		
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    7180:	07db      	lsls	r3, r3, #31
    7182:	d500      	bpl.n	7186 <close+0x46>
		{
			u8Cmd = SOCKET_CMD_SSL_CLOSE;
    7184:	3105      	adds	r1, #5
		}
		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strclose, sizeof(tstrCloseCmd), NULL,0, 0);
    7186:	2300      	movs	r3, #0
    7188:	9302      	str	r3, [sp, #8]
    718a:	9301      	str	r3, [sp, #4]
    718c:	9300      	str	r3, [sp, #0]
    718e:	3304      	adds	r3, #4
    7190:	aa05      	add	r2, sp, #20
    7192:	2002      	movs	r0, #2
    7194:	4d0f      	ldr	r5, [pc, #60]	; (71d4 <close+0x94>)
    7196:	47a8      	blx	r5
    7198:	1e05      	subs	r5, r0, #0
		if(s8Ret != SOCK_ERR_NO_ERROR)
    719a:	d001      	beq.n	71a0 <close+0x60>
		{
			s8Ret = SOCK_ERR_INVALID;
    719c:	2509      	movs	r5, #9
    719e:	426d      	negs	r5, r5
		}
		m2m_memset((uint8*)&gastrSockets[sock], 0, sizeof(tstrSocket));
    71a0:	0124      	lsls	r4, r4, #4
    71a2:	480b      	ldr	r0, [pc, #44]	; (71d0 <close+0x90>)
    71a4:	1820      	adds	r0, r4, r0
    71a6:	2210      	movs	r2, #16
    71a8:	2100      	movs	r1, #0
    71aa:	4b0b      	ldr	r3, [pc, #44]	; (71d8 <close+0x98>)
    71ac:	4798      	blx	r3
    71ae:	e004      	b.n	71ba <close+0x7a>
Date
		4 June 2012
*********************************************************************/
sint8 close(SOCKET sock)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    71b0:	2506      	movs	r5, #6
    71b2:	426d      	negs	r5, r5
    71b4:	e001      	b.n	71ba <close+0x7a>
    71b6:	2506      	movs	r5, #6
    71b8:	426d      	negs	r5, r5
			s8Ret = SOCK_ERR_INVALID;
		}
		m2m_memset((uint8*)&gastrSockets[sock], 0, sizeof(tstrSocket));
	}
	return s8Ret;
}
    71ba:	0028      	movs	r0, r5
    71bc:	b007      	add	sp, #28
    71be:	bd30      	pop	{r4, r5, pc}
    71c0:	00013ca0 	.word	0x00013ca0
    71c4:	0001198d 	.word	0x0001198d
    71c8:	00015114 	.word	0x00015114
    71cc:	000119c1 	.word	0x000119c1
    71d0:	2000229c 	.word	0x2000229c
    71d4:	0000437d 	.word	0x0000437d
    71d8:	0000426d 	.word	0x0000426d

000071dc <gethostbyname>:

Date
		4 June 2012
*********************************************************************/
sint8 gethostbyname(uint8 * pcHostName)
{
    71dc:	b510      	push	{r4, lr}
    71de:	b084      	sub	sp, #16
    71e0:	0004      	movs	r4, r0
	sint8	s8Err = SOCK_ERR_INVALID_ARG;
	uint8	u8HostNameSize = (uint8)m2m_strlen(pcHostName);
    71e2:	4b0b      	ldr	r3, [pc, #44]	; (7210 <gethostbyname+0x34>)
    71e4:	4798      	blx	r3
	if(u8HostNameSize <= HOSTNAME_MAX_SIZE)
    71e6:	b2c3      	uxtb	r3, r0
    71e8:	2b40      	cmp	r3, #64	; 0x40
    71ea:	d80c      	bhi.n	7206 <gethostbyname+0x2a>
	{
		s8Err = SOCKET_REQUEST(SOCKET_CMD_DNS_RESOLVE, (uint8*)pcHostName, u8HostNameSize + 1, NULL,0, 0);
    71ec:	23ff      	movs	r3, #255	; 0xff
    71ee:	4018      	ands	r0, r3
    71f0:	1c43      	adds	r3, r0, #1
    71f2:	2200      	movs	r2, #0
    71f4:	9202      	str	r2, [sp, #8]
    71f6:	9201      	str	r2, [sp, #4]
    71f8:	9200      	str	r2, [sp, #0]
    71fa:	0022      	movs	r2, r4
    71fc:	214a      	movs	r1, #74	; 0x4a
    71fe:	2002      	movs	r0, #2
    7200:	4c04      	ldr	r4, [pc, #16]	; (7214 <gethostbyname+0x38>)
    7202:	47a0      	blx	r4
    7204:	e001      	b.n	720a <gethostbyname+0x2e>
Date
		4 June 2012
*********************************************************************/
sint8 gethostbyname(uint8 * pcHostName)
{
	sint8	s8Err = SOCK_ERR_INVALID_ARG;
    7206:	2006      	movs	r0, #6
    7208:	4240      	negs	r0, r0
	if(u8HostNameSize <= HOSTNAME_MAX_SIZE)
	{
		s8Err = SOCKET_REQUEST(SOCKET_CMD_DNS_RESOLVE, (uint8*)pcHostName, u8HostNameSize + 1, NULL,0, 0);
	}
	return s8Err;
}
    720a:	b004      	add	sp, #16
    720c:	bd10      	pop	{r4, pc}
    720e:	46c0      	nop			; (mov r8, r8)
    7210:	0000427d 	.word	0x0000427d
    7214:	0000437d 	.word	0x0000437d

00007218 <spi_flash_enable>:
 *	@brief	Enable spi flash operations
 *	@author	M. Abdelmawla
 *	@version	1.0
 */
sint8 spi_flash_enable(uint8 enable)
{
    7218:	b570      	push	{r4, r5, r6, lr}
    721a:	b082      	sub	sp, #8
    721c:	0004      	movs	r4, r0
	sint8 s8Ret = M2M_SUCCESS;
	if(REV(nmi_get_chipid()) >= REV_3A0) {		
    721e:	4b29      	ldr	r3, [pc, #164]	; (72c4 <spi_flash_enable+0xac>)
    7220:	4798      	blx	r3
    7222:	0500      	lsls	r0, r0, #20
    7224:	0d00      	lsrs	r0, r0, #20
 *	@author	M. Abdelmawla
 *	@version	1.0
 */
sint8 spi_flash_enable(uint8 enable)
{
	sint8 s8Ret = M2M_SUCCESS;
    7226:	2500      	movs	r5, #0
	if(REV(nmi_get_chipid()) >= REV_3A0) {		
    7228:	4b27      	ldr	r3, [pc, #156]	; (72c8 <spi_flash_enable+0xb0>)
    722a:	4298      	cmp	r0, r3
    722c:	d947      	bls.n	72be <spi_flash_enable+0xa6>
		uint32 u32Val;
		
		/* Enable pinmux to SPI flash. */
		s8Ret = nm_read_reg_with_ret(0x1410, &u32Val);
    722e:	a901      	add	r1, sp, #4
    7230:	4826      	ldr	r0, [pc, #152]	; (72cc <spi_flash_enable+0xb4>)
    7232:	4b27      	ldr	r3, [pc, #156]	; (72d0 <spi_flash_enable+0xb8>)
    7234:	4798      	blx	r3
    7236:	1e05      	subs	r5, r0, #0
		if(s8Ret != M2M_SUCCESS) {
    7238:	d141      	bne.n	72be <spi_flash_enable+0xa6>
			goto ERR1;
		}
		/* GPIO15/16/17/18 */
		u32Val &= ~((0x7777ul) << 12);
		u32Val |= ((0x1111ul) << 12);
    723a:	4926      	ldr	r1, [pc, #152]	; (72d4 <spi_flash_enable+0xbc>)
    723c:	9b01      	ldr	r3, [sp, #4]
    723e:	4019      	ands	r1, r3
    7240:	4b25      	ldr	r3, [pc, #148]	; (72d8 <spi_flash_enable+0xc0>)
    7242:	4319      	orrs	r1, r3
    7244:	9101      	str	r1, [sp, #4]
		nm_write_reg(0x1410, u32Val);
    7246:	4821      	ldr	r0, [pc, #132]	; (72cc <spi_flash_enable+0xb4>)
    7248:	4b24      	ldr	r3, [pc, #144]	; (72dc <spi_flash_enable+0xc4>)
    724a:	4798      	blx	r3
		if(enable) {
    724c:	2c00      	cmp	r4, #0
    724e:	d016      	beq.n	727e <spi_flash_enable+0x66>
	volatile unsigned long tmp;
	unsigned char* cmd = (unsigned char*) &tmp;

	cmd[0] = 0xab;

	nm_write_reg(SPI_FLASH_DATA_CNT, 0);
    7250:	2100      	movs	r1, #0
    7252:	4823      	ldr	r0, [pc, #140]	; (72e0 <spi_flash_enable+0xc8>)
    7254:	4c21      	ldr	r4, [pc, #132]	; (72dc <spi_flash_enable+0xc4>)
    7256:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
    7258:	21ab      	movs	r1, #171	; 0xab
    725a:	4822      	ldr	r0, [pc, #136]	; (72e4 <spi_flash_enable+0xcc>)
    725c:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF_DIR, 0x1);
    725e:	2101      	movs	r1, #1
    7260:	4821      	ldr	r0, [pc, #132]	; (72e8 <spi_flash_enable+0xd0>)
    7262:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
    7264:	2100      	movs	r1, #0
    7266:	4821      	ldr	r0, [pc, #132]	; (72ec <spi_flash_enable+0xd4>)
    7268:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_CMD_CNT,  1 | (1 << 7));
    726a:	2181      	movs	r1, #129	; 0x81
    726c:	4820      	ldr	r0, [pc, #128]	; (72f0 <spi_flash_enable+0xd8>)
    726e:	47a0      	blx	r4
	while(nm_read_reg(SPI_FLASH_TR_DONE) != 1);
    7270:	4e20      	ldr	r6, [pc, #128]	; (72f4 <spi_flash_enable+0xdc>)
    7272:	4c21      	ldr	r4, [pc, #132]	; (72f8 <spi_flash_enable+0xe0>)
    7274:	0030      	movs	r0, r6
    7276:	47a0      	blx	r4
    7278:	2801      	cmp	r0, #1
    727a:	d1fb      	bne.n	7274 <spi_flash_enable+0x5c>
    727c:	e015      	b.n	72aa <spi_flash_enable+0x92>
	volatile unsigned long tmp;
	unsigned char* cmd = (unsigned char*) &tmp;

	cmd[0] = 0xb9;

	nm_write_reg(SPI_FLASH_DATA_CNT, 0);
    727e:	2100      	movs	r1, #0
    7280:	4817      	ldr	r0, [pc, #92]	; (72e0 <spi_flash_enable+0xc8>)
    7282:	4c16      	ldr	r4, [pc, #88]	; (72dc <spi_flash_enable+0xc4>)
    7284:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
    7286:	21b9      	movs	r1, #185	; 0xb9
    7288:	4816      	ldr	r0, [pc, #88]	; (72e4 <spi_flash_enable+0xcc>)
    728a:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF_DIR, 0x1);
    728c:	2101      	movs	r1, #1
    728e:	4816      	ldr	r0, [pc, #88]	; (72e8 <spi_flash_enable+0xd0>)
    7290:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
    7292:	2100      	movs	r1, #0
    7294:	4815      	ldr	r0, [pc, #84]	; (72ec <spi_flash_enable+0xd4>)
    7296:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_CMD_CNT, 1 | (1 << 7));
    7298:	2181      	movs	r1, #129	; 0x81
    729a:	4815      	ldr	r0, [pc, #84]	; (72f0 <spi_flash_enable+0xd8>)
    729c:	47a0      	blx	r4
	while(nm_read_reg(SPI_FLASH_TR_DONE) != 1);
    729e:	4e15      	ldr	r6, [pc, #84]	; (72f4 <spi_flash_enable+0xdc>)
    72a0:	4c15      	ldr	r4, [pc, #84]	; (72f8 <spi_flash_enable+0xe0>)
    72a2:	0030      	movs	r0, r6
    72a4:	47a0      	blx	r4
    72a6:	2801      	cmp	r0, #1
    72a8:	d1fb      	bne.n	72a2 <spi_flash_enable+0x8a>
		} else {
			spi_flash_enter_low_power_mode();
		}
		/* Disable pinmux to SPI flash to minimize leakage. */
		u32Val &= ~((0x7777ul) << 12);
		u32Val |= ((0x0010ul) << 12);
    72aa:	490a      	ldr	r1, [pc, #40]	; (72d4 <spi_flash_enable+0xbc>)
    72ac:	9b01      	ldr	r3, [sp, #4]
    72ae:	4019      	ands	r1, r3
    72b0:	2380      	movs	r3, #128	; 0x80
    72b2:	025b      	lsls	r3, r3, #9
    72b4:	4319      	orrs	r1, r3
    72b6:	9101      	str	r1, [sp, #4]
		nm_write_reg(0x1410, u32Val);
    72b8:	4804      	ldr	r0, [pc, #16]	; (72cc <spi_flash_enable+0xb4>)
    72ba:	4b08      	ldr	r3, [pc, #32]	; (72dc <spi_flash_enable+0xc4>)
    72bc:	4798      	blx	r3
	}
ERR1:
	return s8Ret;
}
    72be:	0028      	movs	r0, r5
    72c0:	b002      	add	sp, #8
    72c2:	bd70      	pop	{r4, r5, r6, pc}
    72c4:	000054b1 	.word	0x000054b1
    72c8:	0000039f 	.word	0x0000039f
    72cc:	00001410 	.word	0x00001410
    72d0:	00005965 	.word	0x00005965
    72d4:	f8888fff 	.word	0xf8888fff
    72d8:	01111000 	.word	0x01111000
    72dc:	00005971 	.word	0x00005971
    72e0:	00010208 	.word	0x00010208
    72e4:	0001020c 	.word	0x0001020c
    72e8:	00010214 	.word	0x00010214
    72ec:	0001021c 	.word	0x0001021c
    72f0:	00010204 	.word	0x00010204
    72f4:	00010218 	.word	0x00010218
    72f8:	00005959 	.word	0x00005959

000072fc <spi_init>:
 */
enum status_code spi_init(
		struct spi_module *const module,
		Sercom *const hw,
		const struct spi_config *const config)
{
    72fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    72fe:	b08b      	sub	sp, #44	; 0x2c
    7300:	0005      	movs	r5, r0
    7302:	000c      	movs	r4, r1
    7304:	0016      	movs	r6, r2
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize device instance */
	module->hw = hw;
    7306:	6029      	str	r1, [r5, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    7308:	680b      	ldr	r3, [r1, #0]
#  if SPI_CALLBACK_MODE == false
		/* Check if config is valid */
		return _spi_check_config(module, config);
#  else
		return STATUS_ERR_DENIED;
    730a:	201c      	movs	r0, #28
	module->hw = hw;

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    730c:	079b      	lsls	r3, r3, #30
    730e:	d500      	bpl.n	7312 <spi_init+0x16>
    7310:	e0e7      	b.n	74e2 <spi_init+0x1e6>
		return STATUS_ERR_DENIED;
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    7312:	680b      	ldr	r3, [r1, #0]
		return STATUS_BUSY;
    7314:	3817      	subs	r0, #23
		return STATUS_ERR_DENIED;
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    7316:	07db      	lsls	r3, r3, #31
    7318:	d500      	bpl.n	731c <spi_init+0x20>
    731a:	e0e2      	b.n	74e2 <spi_init+0x1e6>
		return STATUS_BUSY;
	}

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    731c:	0008      	movs	r0, r1
    731e:	4b72      	ldr	r3, [pc, #456]	; (74e8 <spi_init+0x1ec>)
    7320:	4798      	blx	r3
	uint32_t pm_index, gclk_index;
#if (SAML21)
	if (sercom_index == 5) {
    7322:	2805      	cmp	r0, #5
    7324:	d100      	bne.n	7328 <spi_init+0x2c>
    7326:	e0d5      	b.n	74d4 <spi_init+0x1d8>
#  else
		return STATUS_ERR_INVALID_ARG;
#  endif
	} else {
		pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
		gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    7328:	0003      	movs	r3, r0
    732a:	3312      	adds	r3, #18
		case SYSTEM_CLOCK_APB_APBB:
			MCLK->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			MCLK->APBCMASK.reg |= mask;
    732c:	4f6f      	ldr	r7, [pc, #444]	; (74ec <spi_init+0x1f0>)
    732e:	69f9      	ldr	r1, [r7, #28]
    7330:	2201      	movs	r2, #1
    7332:	4082      	lsls	r2, r0
    7334:	430a      	orrs	r2, r1
    7336:	61fa      	str	r2, [r7, #28]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    7338:	a909      	add	r1, sp, #36	; 0x24
    733a:	2724      	movs	r7, #36	; 0x24
    733c:	5df2      	ldrb	r2, [r6, r7]
    733e:	700a      	strb	r2, [r1, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    7340:	b2db      	uxtb	r3, r3
    7342:	9301      	str	r3, [sp, #4]
    7344:	0018      	movs	r0, r3
    7346:	4b6a      	ldr	r3, [pc, #424]	; (74f0 <spi_init+0x1f4>)
    7348:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    734a:	9801      	ldr	r0, [sp, #4]
    734c:	4b69      	ldr	r3, [pc, #420]	; (74f4 <spi_init+0x1f8>)
    734e:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    7350:	5df0      	ldrb	r0, [r6, r7]
    7352:	2100      	movs	r1, #0
    7354:	4b68      	ldr	r3, [pc, #416]	; (74f8 <spi_init+0x1fc>)
    7356:	4798      	blx	r3

#  if CONF_SPI_MASTER_ENABLE == true
	if (config->mode == SPI_MODE_MASTER) {
    7358:	7833      	ldrb	r3, [r6, #0]
    735a:	2b01      	cmp	r3, #1
    735c:	d103      	bne.n	7366 <spi_init+0x6a>
		/* Set the SERCOM in SPI master mode */
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x3);
    735e:	6822      	ldr	r2, [r4, #0]
    7360:	330b      	adds	r3, #11
    7362:	4313      	orrs	r3, r2
    7364:	6023      	str	r3, [r4, #0]
	}
#  endif

#  if CONF_SPI_SLAVE_ENABLE == true
	if (config->mode == SPI_MODE_SLAVE) {
    7366:	7833      	ldrb	r3, [r6, #0]
    7368:	2b00      	cmp	r3, #0
    736a:	d103      	bne.n	7374 <spi_init+0x78>
		/* Set the SERCOM in SPI slave mode */
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x2);
    736c:	6822      	ldr	r2, [r4, #0]
    736e:	3308      	adds	r3, #8
    7370:	4313      	orrs	r3, r2
    7372:	6023      	str	r3, [r4, #0]
    7374:	002b      	movs	r3, r5
    7376:	330c      	adds	r3, #12
    7378:	0029      	movs	r1, r5
    737a:	3128      	adds	r1, #40	; 0x28
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
		module->callback[i]        = NULL;
    737c:	2200      	movs	r2, #0
    737e:	c304      	stmia	r3!, {r2}
	/* Temporary variables */
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
    7380:	4299      	cmp	r1, r3
    7382:	d1fc      	bne.n	737e <spi_init+0x82>
		module->callback[i]        = NULL;
	}
	module->tx_buffer_ptr              = NULL;
    7384:	2300      	movs	r3, #0
    7386:	62eb      	str	r3, [r5, #44]	; 0x2c
	module->rx_buffer_ptr              = NULL;
    7388:	62ab      	str	r3, [r5, #40]	; 0x28
	module->remaining_tx_buffer_length = 0x0000;
    738a:	2400      	movs	r4, #0
    738c:	86ab      	strh	r3, [r5, #52]	; 0x34
	module->remaining_rx_buffer_length = 0x0000;
    738e:	862b      	strh	r3, [r5, #48]	; 0x30
	module->registered_callback        = 0x00;
    7390:	3336      	adds	r3, #54	; 0x36
    7392:	54ec      	strb	r4, [r5, r3]
	module->enabled_callback           = 0x00;
    7394:	3301      	adds	r3, #1
    7396:	54ec      	strb	r4, [r5, r3]
	module->status                     = STATUS_OK;
    7398:	3301      	adds	r3, #1
    739a:	54ec      	strb	r4, [r5, r3]
	module->dir                        = SPI_DIRECTION_IDLE;
    739c:	3b35      	subs	r3, #53	; 0x35
    739e:	726b      	strb	r3, [r5, #9]
	module->locked                     = false;
    73a0:	712c      	strb	r4, [r5, #4]
	/*
	 * Set interrupt handler and register SPI software module struct in
	 * look-up table
	 */
	instance_index = _sercom_get_sercom_inst_index(module->hw);
    73a2:	6828      	ldr	r0, [r5, #0]
    73a4:	4b50      	ldr	r3, [pc, #320]	; (74e8 <spi_init+0x1ec>)
    73a6:	4798      	blx	r3
    73a8:	0007      	movs	r7, r0
	_sercom_set_handler(instance_index, _spi_interrupt_handler);
    73aa:	4954      	ldr	r1, [pc, #336]	; (74fc <spi_init+0x200>)
    73ac:	4b54      	ldr	r3, [pc, #336]	; (7500 <spi_init+0x204>)
    73ae:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    73b0:	00b8      	lsls	r0, r7, #2
    73b2:	4b54      	ldr	r3, [pc, #336]	; (7504 <spi_init+0x208>)
    73b4:	50c5      	str	r5, [r0, r3]
	/* Sanity check arguments */
	Assert(module);
	Assert(config);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    73b6:	682f      	ldr	r7, [r5, #0]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    73b8:	ab04      	add	r3, sp, #16
    73ba:	2280      	movs	r2, #128	; 0x80
    73bc:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    73be:	705c      	strb	r4, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    73c0:	3a7f      	subs	r2, #127	; 0x7f
    73c2:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    73c4:	70dc      	strb	r4, [r3, #3]
	Sercom *const hw = module->hw;

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	if(config->mode == SPI_MODE_SLAVE) {
    73c6:	7833      	ldrb	r3, [r6, #0]
    73c8:	2b00      	cmp	r3, #0
    73ca:	d102      	bne.n	73d2 <spi_init+0xd6>
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    73cc:	2200      	movs	r2, #0
    73ce:	ab04      	add	r3, sp, #16
    73d0:	709a      	strb	r2, [r3, #2]
	}

	uint32_t pad_pinmuxes[] = {
    73d2:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    73d4:	9305      	str	r3, [sp, #20]
    73d6:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    73d8:	9306      	str	r3, [sp, #24]
    73da:	6b33      	ldr	r3, [r6, #48]	; 0x30
    73dc:	9307      	str	r3, [sp, #28]
    73de:	6b73      	ldr	r3, [r6, #52]	; 0x34
    73e0:	9308      	str	r3, [sp, #32]
    73e2:	2400      	movs	r4, #0
    73e4:	b2e1      	uxtb	r1, r4
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    73e6:	00a3      	lsls	r3, r4, #2
    73e8:	aa05      	add	r2, sp, #20
    73ea:	5898      	ldr	r0, [r3, r2]

		if (current_pinmux == PINMUX_DEFAULT) {
    73ec:	2800      	cmp	r0, #0
    73ee:	d102      	bne.n	73f6 <spi_init+0xfa>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    73f0:	0038      	movs	r0, r7
    73f2:	4b45      	ldr	r3, [pc, #276]	; (7508 <spi_init+0x20c>)
    73f4:	4798      	blx	r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
    73f6:	1c43      	adds	r3, r0, #1
    73f8:	d006      	beq.n	7408 <spi_init+0x10c>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    73fa:	ab02      	add	r3, sp, #8
    73fc:	7218      	strb	r0, [r3, #8]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    73fe:	0c00      	lsrs	r0, r0, #16
    7400:	b2c0      	uxtb	r0, r0
    7402:	a904      	add	r1, sp, #16
    7404:	4b41      	ldr	r3, [pc, #260]	; (750c <spi_init+0x210>)
    7406:	4798      	blx	r3
    7408:	3401      	adds	r4, #1
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    740a:	2c04      	cmp	r4, #4
    740c:	d1ea      	bne.n	73e4 <spi_init+0xe8>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
		}
	}

	module->mode             = config->mode;
    740e:	7833      	ldrb	r3, [r6, #0]
    7410:	716b      	strb	r3, [r5, #5]
	module->character_size   = config->character_size;
    7412:	7c33      	ldrb	r3, [r6, #16]
    7414:	71ab      	strb	r3, [r5, #6]
	module->receiver_enabled = config->receiver_enable;
    7416:	7cb3      	ldrb	r3, [r6, #18]
    7418:	71eb      	strb	r3, [r5, #7]
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	module->master_slave_select_enable = config->master_slave_select_enable;
    741a:	7d33      	ldrb	r3, [r6, #20]
    741c:	722b      	strb	r3, [r5, #8]
#  endif

#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to write to BAUD register */
	uint16_t baud = 0;
    741e:	2200      	movs	r2, #0
    7420:	ab02      	add	r3, sp, #8
    7422:	80da      	strh	r2, [r3, #6]
	/* Value to write to CTRLB register */
	uint32_t ctrlb = 0;

# if CONF_SPI_MASTER_ENABLE == true
	/* Find baud value and write it */
	if (config->mode == SPI_MODE_MASTER) {
    7424:	7833      	ldrb	r3, [r6, #0]
    7426:	2b01      	cmp	r3, #1
    7428:	d114      	bne.n	7454 <spi_init+0x158>
		/* Find frequency of the internal SERCOMi_GCLK_ID_CORE */
		uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    742a:	6828      	ldr	r0, [r5, #0]
    742c:	4b2e      	ldr	r3, [pc, #184]	; (74e8 <spi_init+0x1ec>)
    742e:	4798      	blx	r3
		uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
		uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
    7430:	3012      	adds	r0, #18
    7432:	b2c0      	uxtb	r0, r0
    7434:	4b36      	ldr	r3, [pc, #216]	; (7510 <spi_init+0x214>)
    7436:	4798      	blx	r3
    7438:	0001      	movs	r1, r0

		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
    743a:	ab02      	add	r3, sp, #8
    743c:	1d9a      	adds	r2, r3, #6
    743e:	69b0      	ldr	r0, [r6, #24]
    7440:	4b34      	ldr	r3, [pc, #208]	; (7514 <spi_init+0x218>)
    7442:	4798      	blx	r3
    7444:	0003      	movs	r3, r0
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
    7446:	2017      	movs	r0, #23
		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
    7448:	2b00      	cmp	r3, #0
    744a:	d14a      	bne.n	74e2 <spi_init+0x1e6>
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
		}

		spi_module->BAUD.reg = (uint8_t)baud;
    744c:	ab02      	add	r3, sp, #8
    744e:	3306      	adds	r3, #6
    7450:	781b      	ldrb	r3, [r3, #0]
    7452:	733b      	strb	r3, [r7, #12]
	}
# endif
# if CONF_SPI_SLAVE_ENABLE == true
	if (config->mode == SPI_MODE_SLAVE) {
    7454:	7833      	ldrb	r3, [r6, #0]
    7456:	2b00      	cmp	r3, #0
    7458:	d10f      	bne.n	747a <spi_init+0x17e>
		/* Set frame format */
		ctrla = config->mode_specific.slave.frame_format;
    745a:	69b0      	ldr	r0, [r6, #24]

		/* Set address mode */
		ctrlb = config->mode_specific.slave.address_mode;
    745c:	8bb3      	ldrh	r3, [r6, #28]

		/* Set address and address mask*/
		spi_module->ADDR.reg |=
    745e:	6a79      	ldr	r1, [r7, #36]	; 0x24
    7460:	7ff2      	ldrb	r2, [r6, #31]
    7462:	0412      	lsls	r2, r2, #16
    7464:	7fb4      	ldrb	r4, [r6, #30]
    7466:	4322      	orrs	r2, r4
    7468:	430a      	orrs	r2, r1
    746a:	627a      	str	r2, [r7, #36]	; 0x24
				(config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);

		if (config->mode_specific.slave.preload_enable) {
    746c:	2220      	movs	r2, #32
    746e:	5cb2      	ldrb	r2, [r6, r2]
    7470:	2a00      	cmp	r2, #0
    7472:	d004      	beq.n	747e <spi_init+0x182>
			/* Enable pre-loading of shift register */
			ctrlb |= SERCOM_SPI_CTRLB_PLOADEN;
    7474:	2140      	movs	r1, #64	; 0x40
    7476:	430b      	orrs	r3, r1
    7478:	e001      	b.n	747e <spi_init+0x182>
	uint16_t baud = 0;
#  endif
	/* Value to write to CTRLA register */
	uint32_t ctrla = 0;
	/* Value to write to CTRLB register */
	uint32_t ctrlb = 0;
    747a:	2300      	movs	r3, #0
#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to write to BAUD register */
	uint16_t baud = 0;
#  endif
	/* Value to write to CTRLA register */
	uint32_t ctrla = 0;
    747c:	2000      	movs	r0, #0

	/* Set clock polarity and clock phase */
	ctrla |= config->transfer_mode;

	/* Set MUX setting */
	ctrla |= config->mux_setting;
    747e:	6872      	ldr	r2, [r6, #4]
    7480:	68b1      	ldr	r1, [r6, #8]
    7482:	430a      	orrs	r2, r1
    7484:	68f1      	ldr	r1, [r6, #12]
    7486:	430a      	orrs	r2, r1
    7488:	4302      	orrs	r2, r0

	/* Set SPI character size */
	ctrlb |= config->character_size;
    748a:	7c31      	ldrb	r1, [r6, #16]
    748c:	430b      	orrs	r3, r1

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    748e:	7c71      	ldrb	r1, [r6, #17]
    7490:	2900      	cmp	r1, #0
    7492:	d103      	bne.n	749c <spi_init+0x1a0>
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
    7494:	4920      	ldr	r1, [pc, #128]	; (7518 <spi_init+0x21c>)
    7496:	7889      	ldrb	r1, [r1, #2]
    7498:	0789      	lsls	r1, r1, #30
    749a:	d501      	bpl.n	74a0 <spi_init+0x1a4>
		ctrla |= SERCOM_SPI_CTRLA_RUNSTDBY;
    749c:	2180      	movs	r1, #128	; 0x80
    749e:	430a      	orrs	r2, r1
	}

	if (config->receiver_enable) {
    74a0:	7cb1      	ldrb	r1, [r6, #18]
    74a2:	2900      	cmp	r1, #0
    74a4:	d002      	beq.n	74ac <spi_init+0x1b0>
		/* Enable receiver */
		ctrlb |= SERCOM_SPI_CTRLB_RXEN;
    74a6:	2180      	movs	r1, #128	; 0x80
    74a8:	0289      	lsls	r1, r1, #10
    74aa:	430b      	orrs	r3, r1
	}
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	if (config->select_slave_low_detect_enable) {
    74ac:	7cf1      	ldrb	r1, [r6, #19]
    74ae:	2900      	cmp	r1, #0
    74b0:	d002      	beq.n	74b8 <spi_init+0x1bc>
		/* Enable Slave Select Low Detect */
		ctrlb |= SERCOM_SPI_CTRLB_SSDE;
    74b2:	2180      	movs	r1, #128	; 0x80
    74b4:	0089      	lsls	r1, r1, #2
    74b6:	430b      	orrs	r3, r1
	}
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if (config->master_slave_select_enable) {
    74b8:	7d31      	ldrb	r1, [r6, #20]
    74ba:	2900      	cmp	r1, #0
    74bc:	d002      	beq.n	74c4 <spi_init+0x1c8>
		/* Enable Master Slave Select */
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
    74be:	2180      	movs	r1, #128	; 0x80
    74c0:	0189      	lsls	r1, r1, #6
    74c2:	430b      	orrs	r3, r1
	}
#  endif
	/* Write CTRLA register */
	spi_module->CTRLA.reg |= ctrla;
    74c4:	6839      	ldr	r1, [r7, #0]
    74c6:	430a      	orrs	r2, r1
    74c8:	603a      	str	r2, [r7, #0]

	/* Write CTRLB register */
	spi_module->CTRLB.reg |= ctrlb;
    74ca:	687a      	ldr	r2, [r7, #4]
    74cc:	4313      	orrs	r3, r2
    74ce:	607b      	str	r3, [r7, #4]

	return STATUS_OK;
    74d0:	2000      	movs	r0, #0
    74d2:	e006      	b.n	74e2 <spi_init+0x1e6>
			break;
		case SYSTEM_CLOCK_APB_APBD:
			MCLK->APBDMASK.reg |= mask;
    74d4:	4a05      	ldr	r2, [pc, #20]	; (74ec <spi_init+0x1f0>)
    74d6:	6a11      	ldr	r1, [r2, #32]
    74d8:	2302      	movs	r3, #2
    74da:	430b      	orrs	r3, r1
    74dc:	6213      	str	r3, [r2, #32]
	uint32_t pm_index, gclk_index;
#if (SAML21)
	if (sercom_index == 5) {
#  ifdef ID_SERCOM5
		pm_index     = MCLK_APBDMASK_SERCOM5_Pos;
		gclk_index   =  SERCOM5_GCLK_ID_CORE;
    74de:	2318      	movs	r3, #24
    74e0:	e72a      	b.n	7338 <spi_init+0x3c>
	_sercom_instances[instance_index] = module;
#endif

	/* Write configuration to module and return status code */
	return _spi_set_config(module, config);
}
    74e2:	b00b      	add	sp, #44	; 0x2c
    74e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    74e6:	46c0      	nop			; (mov r8, r8)
    74e8:	0000cba9 	.word	0x0000cba9
    74ec:	40000400 	.word	0x40000400
    74f0:	0000d959 	.word	0x0000d959
    74f4:	0000d8e9 	.word	0x0000d8e9
    74f8:	0000c9d9 	.word	0x0000c9d9
    74fc:	00007611 	.word	0x00007611
    7500:	0000cbe9 	.word	0x0000cbe9
    7504:	20002850 	.word	0x20002850
    7508:	0000ca25 	.word	0x0000ca25
    750c:	0000da55 	.word	0x0000da55
    7510:	0000d97d 	.word	0x0000d97d
    7514:	0000c7e9 	.word	0x0000c7e9
    7518:	41002000 	.word	0x41002000

0000751c <spi_select_slave>:
 */
enum status_code spi_select_slave(
		struct spi_module *const module,
		struct spi_slave_inst *const slave,
		const bool select)
{
    751c:	b510      	push	{r4, lr}
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
    751e:	7944      	ldrb	r4, [r0, #5]
		return STATUS_ERR_UNSUPPORTED_DEV;
    7520:	2315      	movs	r3, #21
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
    7522:	2c01      	cmp	r4, #1
    7524:	d170      	bne.n	7608 <spi_select_slave+0xec>
		return STATUS_ERR_UNSUPPORTED_DEV;
	}
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if(!(module->master_slave_select_enable))
    7526:	7a04      	ldrb	r4, [r0, #8]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    7528:	2300      	movs	r3, #0
	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
		return STATUS_ERR_UNSUPPORTED_DEV;
	}
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if(!(module->master_slave_select_enable))
    752a:	2c00      	cmp	r4, #0
    752c:	d16c      	bne.n	7608 <spi_select_slave+0xec>
#  endif
	{
		if (select) {
    752e:	2a00      	cmp	r2, #0
    7530:	d05a      	beq.n	75e8 <spi_select_slave+0xcc>
			/* Check if address recognition is enabled */
			if (slave->address_enabled) {
    7532:	784b      	ldrb	r3, [r1, #1]
    7534:	2b00      	cmp	r3, #0
    7536:	d046      	beq.n	75c6 <spi_select_slave+0xaa>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    7538:	6803      	ldr	r3, [r0, #0]
    753a:	7e1b      	ldrb	r3, [r3, #24]
				/* Check if the module is ready to write the address */
				if (!spi_is_ready_to_write(module)) {
    753c:	07db      	lsls	r3, r3, #31
    753e:	d410      	bmi.n	7562 <spi_select_slave+0x46>
					/* Not ready, do not select slave and return */
					port_pin_set_output_level(slave->ss_pin, true);
    7540:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    7542:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    7544:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    7546:	2900      	cmp	r1, #0
    7548:	d104      	bne.n	7554 <spi_select_slave+0x38>
		return &(ports[port_index]->Group[group_index]);
    754a:	095a      	lsrs	r2, r3, #5
    754c:	01d2      	lsls	r2, r2, #7
    754e:	492f      	ldr	r1, [pc, #188]	; (760c <spi_select_slave+0xf0>)
    7550:	468c      	mov	ip, r1
    7552:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    7554:	211f      	movs	r1, #31
    7556:	400b      	ands	r3, r1
    7558:	391e      	subs	r1, #30
    755a:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    755c:	6191      	str	r1, [r2, #24]
					return STATUS_BUSY;
    755e:	2305      	movs	r3, #5
    7560:	e052      	b.n	7608 <spi_select_slave+0xec>
				}

				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
    7562:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    7564:	09dc      	lsrs	r4, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    7566:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    7568:	2c00      	cmp	r4, #0
    756a:	d104      	bne.n	7576 <spi_select_slave+0x5a>
		return &(ports[port_index]->Group[group_index]);
    756c:	095a      	lsrs	r2, r3, #5
    756e:	01d2      	lsls	r2, r2, #7
    7570:	4c26      	ldr	r4, [pc, #152]	; (760c <spi_select_slave+0xf0>)
    7572:	46a4      	mov	ip, r4
    7574:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    7576:	241f      	movs	r4, #31
    7578:	4023      	ands	r3, r4
    757a:	3c1e      	subs	r4, #30
    757c:	409c      	lsls	r4, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    757e:	6154      	str	r4, [r2, #20]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    7580:	6803      	ldr	r3, [r0, #0]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    7582:	7e1a      	ldrb	r2, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    7584:	07d2      	lsls	r2, r2, #31
    7586:	d501      	bpl.n	758c <spi_select_slave+0x70>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    7588:	788a      	ldrb	r2, [r1, #2]
    758a:	629a      	str	r2, [r3, #40]	; 0x28

				/* Write address to slave */
				spi_write(module, slave->address);

				if (!(module->receiver_enabled)) {
    758c:	79c2      	ldrb	r2, [r0, #7]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    758e:	2300      	movs	r3, #0
				port_pin_set_output_level(slave->ss_pin, false);

				/* Write address to slave */
				spi_write(module, slave->address);

				if (!(module->receiver_enabled)) {
    7590:	2a00      	cmp	r2, #0
    7592:	d139      	bne.n	7608 <spi_select_slave+0xec>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    7594:	6802      	ldr	r2, [r0, #0]
					/* Flush contents of shift register shifted back from slave */
					while (!spi_is_ready_to_read(module)) {
    7596:	2104      	movs	r1, #4

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    7598:	7e13      	ldrb	r3, [r2, #24]
    759a:	420b      	tst	r3, r1
    759c:	d0fc      	beq.n	7598 <spi_select_slave+0x7c>
    759e:	7e11      	ldrb	r1, [r2, #24]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    75a0:	2300      	movs	r3, #0
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    75a2:	0749      	lsls	r1, r1, #29
    75a4:	d530      	bpl.n	7608 <spi_select_slave+0xec>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    75a6:	8b53      	ldrh	r3, [r2, #26]
    75a8:	075b      	lsls	r3, r3, #29
    75aa:	d503      	bpl.n	75b4 <spi_select_slave+0x98>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    75ac:	8b51      	ldrh	r1, [r2, #26]
    75ae:	2304      	movs	r3, #4
    75b0:	430b      	orrs	r3, r1
    75b2:	8353      	strh	r3, [r2, #26]
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    75b4:	7983      	ldrb	r3, [r0, #6]
    75b6:	2b01      	cmp	r3, #1
    75b8:	d102      	bne.n	75c0 <spi_select_slave+0xa4>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    75ba:	6a93      	ldr	r3, [r2, #40]	; 0x28
    75bc:	2300      	movs	r3, #0
    75be:	e023      	b.n	7608 <spi_select_slave+0xec>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    75c0:	6a93      	ldr	r3, [r2, #40]	; 0x28
    75c2:	2300      	movs	r3, #0
    75c4:	e020      	b.n	7608 <spi_select_slave+0xec>
					uint16_t flush = 0;
					spi_read(module, &flush);
				}
			} else {
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
    75c6:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    75c8:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    75ca:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    75cc:	2900      	cmp	r1, #0
    75ce:	d104      	bne.n	75da <spi_select_slave+0xbe>
		return &(ports[port_index]->Group[group_index]);
    75d0:	095a      	lsrs	r2, r3, #5
    75d2:	01d2      	lsls	r2, r2, #7
    75d4:	490d      	ldr	r1, [pc, #52]	; (760c <spi_select_slave+0xf0>)
    75d6:	468c      	mov	ip, r1
    75d8:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    75da:	211f      	movs	r1, #31
    75dc:	400b      	ands	r3, r1
    75de:	391e      	subs	r1, #30
    75e0:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    75e2:	6151      	str	r1, [r2, #20]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    75e4:	2300      	movs	r3, #0
    75e6:	e00f      	b.n	7608 <spi_select_slave+0xec>
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
			}
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
    75e8:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    75ea:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    75ec:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    75ee:	2900      	cmp	r1, #0
    75f0:	d104      	bne.n	75fc <spi_select_slave+0xe0>
		return &(ports[port_index]->Group[group_index]);
    75f2:	095a      	lsrs	r2, r3, #5
    75f4:	01d2      	lsls	r2, r2, #7
    75f6:	4905      	ldr	r1, [pc, #20]	; (760c <spi_select_slave+0xf0>)
    75f8:	468c      	mov	ip, r1
    75fa:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    75fc:	211f      	movs	r1, #31
    75fe:	400b      	ands	r3, r1
    7600:	391e      	subs	r1, #30
    7602:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    7604:	6191      	str	r1, [r2, #24]
		}
	}
	return STATUS_OK;
    7606:	2300      	movs	r3, #0
}
    7608:	0018      	movs	r0, r3
    760a:	bd10      	pop	{r4, pc}
    760c:	40002800 	.word	0x40002800

00007610 <_spi_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _spi_interrupt_handler(
		uint8_t instance)
{
    7610:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Get device instance from the look-up table */
	struct spi_module *module
    7612:	0080      	lsls	r0, r0, #2
    7614:	4b7b      	ldr	r3, [pc, #492]	; (7804 <_spi_interrupt_handler+0x1f4>)
    7616:	58c4      	ldr	r4, [r0, r3]
		= (struct spi_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    7618:	6826      	ldr	r6, [r4, #0]

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
			module->enabled_callback & module->registered_callback;
    761a:	2337      	movs	r3, #55	; 0x37

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
    761c:	5ce3      	ldrb	r3, [r4, r3]
    761e:	2236      	movs	r2, #54	; 0x36
    7620:	5ca7      	ldrb	r7, [r4, r2]
    7622:	401f      	ands	r7, r3
			module->enabled_callback & module->registered_callback;

	/* Read and mask interrupt flag register */
	uint16_t interrupt_status = spi_hw->INTFLAG.reg;
    7624:	7e33      	ldrb	r3, [r6, #24]
	interrupt_status &= spi_hw->INTENSET.reg;
    7626:	7db5      	ldrb	r5, [r6, #22]
    7628:	401d      	ands	r5, r3

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
    762a:	07eb      	lsls	r3, r5, #31
    762c:	d543      	bpl.n	76b6 <_spi_interrupt_handler+0xa6>
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    762e:	7963      	ldrb	r3, [r4, #5]
    7630:	2b01      	cmp	r3, #1
    7632:	d116      	bne.n	7662 <_spi_interrupt_handler+0x52>
			(module->dir == SPI_DIRECTION_READ)) {
    7634:	7a63      	ldrb	r3, [r4, #9]
	interrupt_status &= spi_hw->INTENSET.reg;

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    7636:	2b00      	cmp	r3, #0
    7638:	d10f      	bne.n	765a <_spi_interrupt_handler+0x4a>
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Write dummy byte */
	spi_hw->DATA.reg = dummy_write;
    763a:	4b73      	ldr	r3, [pc, #460]	; (7808 <_spi_interrupt_handler+0x1f8>)
    763c:	881b      	ldrh	r3, [r3, #0]
    763e:	62b3      	str	r3, [r6, #40]	; 0x28

	/* Decrement remaining dummy buffer length */
	module->remaining_dummy_buffer_length--;
    7640:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    7642:	3b01      	subs	r3, #1
    7644:	b29b      	uxth	r3, r3
    7646:	8663      	strh	r3, [r4, #50]	; 0x32
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
			(module->dir == SPI_DIRECTION_READ)) {
			/* Send dummy byte when reading in master mode */
			_spi_write_dummy(module);
			if (module->remaining_dummy_buffer_length == 0) {
    7648:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    764a:	b29b      	uxth	r3, r3
    764c:	2b00      	cmp	r3, #0
    764e:	d101      	bne.n	7654 <_spi_interrupt_handler+0x44>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
    7650:	3301      	adds	r3, #1
    7652:	7533      	strb	r3, [r6, #20]
		}
#  endif

		if (0
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
    7654:	7963      	ldrb	r3, [r4, #5]
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
			}
		}
#  endif

		if (0
    7656:	2b01      	cmp	r3, #1
    7658:	d103      	bne.n	7662 <_spi_interrupt_handler+0x52>
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
			(module->dir != SPI_DIRECTION_READ))
    765a:	7a63      	ldrb	r3, [r4, #9]
		}
#  endif

		if (0
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
    765c:	2b00      	cmp	r3, #0
    765e:	d105      	bne.n	766c <_spi_interrupt_handler+0x5c>
    7660:	e029      	b.n	76b6 <_spi_interrupt_handler+0xa6>
			(module->dir != SPI_DIRECTION_READ))
#  endif
#  if CONF_SPI_SLAVE_ENABLE == true
		|| ((module->mode == SPI_MODE_SLAVE) &&
    7662:	2b00      	cmp	r3, #0
    7664:	d127      	bne.n	76b6 <_spi_interrupt_handler+0xa6>
			(module->dir != SPI_DIRECTION_READ))
    7666:	7a63      	ldrb	r3, [r4, #9]
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
			(module->dir != SPI_DIRECTION_READ))
#  endif
#  if CONF_SPI_SLAVE_ENABLE == true
		|| ((module->mode == SPI_MODE_SLAVE) &&
    7668:	2b00      	cmp	r3, #0
    766a:	d024      	beq.n	76b6 <_spi_interrupt_handler+0xa6>
 */
static void _spi_write(
		struct spi_module *const module)
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    766c:	6820      	ldr	r0, [r4, #0]

	/* Write value will be at least 8-bits long */
	uint16_t data_to_send = *(module->tx_buffer_ptr);
    766e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    7670:	780b      	ldrb	r3, [r1, #0]
    7672:	b2da      	uxtb	r2, r3
	/* Increment 8-bit pointer */
	(module->tx_buffer_ptr)++;
    7674:	1c4b      	adds	r3, r1, #1
    7676:	62e3      	str	r3, [r4, #44]	; 0x2c

	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    7678:	79a3      	ldrb	r3, [r4, #6]
    767a:	2b01      	cmp	r3, #1
    767c:	d001      	beq.n	7682 <_spi_interrupt_handler+0x72>
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Write value will be at least 8-bits long */
	uint16_t data_to_send = *(module->tx_buffer_ptr);
    767e:	b293      	uxth	r3, r2
    7680:	e004      	b.n	768c <_spi_interrupt_handler+0x7c>
	/* Increment 8-bit pointer */
	(module->tx_buffer_ptr)++;

	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
		data_to_send |= ((*(module->tx_buffer_ptr)) << 8);
    7682:	784b      	ldrb	r3, [r1, #1]
    7684:	021b      	lsls	r3, r3, #8
    7686:	4313      	orrs	r3, r2
		/* Increment 8-bit pointer */
		(module->tx_buffer_ptr)++;
    7688:	3102      	adds	r1, #2
    768a:	62e1      	str	r1, [r4, #44]	; 0x2c
	}

	/* Write the data to send*/
	spi_hw->DATA.reg = data_to_send & SERCOM_SPI_DATA_MASK;
    768c:	05db      	lsls	r3, r3, #23
    768e:	0ddb      	lsrs	r3, r3, #23
    7690:	6283      	str	r3, [r0, #40]	; 0x28

	/* Decrement remaining buffer length */
	(module->remaining_tx_buffer_length)--;
    7692:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
    7694:	3b01      	subs	r3, #1
    7696:	b29b      	uxth	r3, r3
    7698:	86a3      	strh	r3, [r4, #52]	; 0x34
			(module->dir != SPI_DIRECTION_READ))
#  endif
		) {
			/* Write next byte from buffer */
			_spi_write(module);
			if (module->remaining_tx_buffer_length == 0) {
    769a:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
    769c:	b29b      	uxth	r3, r3
    769e:	2b00      	cmp	r3, #0
    76a0:	d109      	bne.n	76b6 <_spi_interrupt_handler+0xa6>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
    76a2:	3301      	adds	r3, #1
    76a4:	7533      	strb	r3, [r6, #20]

				if (module->dir == SPI_DIRECTION_WRITE &&
    76a6:	7a63      	ldrb	r3, [r4, #9]
    76a8:	2b01      	cmp	r3, #1
    76aa:	d104      	bne.n	76b6 <_spi_interrupt_handler+0xa6>
    76ac:	79e3      	ldrb	r3, [r4, #7]
    76ae:	2b00      	cmp	r3, #0
    76b0:	d101      	bne.n	76b6 <_spi_interrupt_handler+0xa6>
						!(module->receiver_enabled)) {
					/* Enable the Data Register transmit complete Interrupt */
					spi_hw->INTENSET.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    76b2:	3302      	adds	r3, #2
    76b4:	75b3      	strb	r3, [r6, #22]
			}
		}
	}

	/* Receive complete interrupt*/
	if (interrupt_status & SPI_INTERRUPT_FLAG_RX_COMPLETE) {
    76b6:	076b      	lsls	r3, r5, #29
    76b8:	d561      	bpl.n	777e <_spi_interrupt_handler+0x16e>
		/* Check for overflow */
		if (spi_hw->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    76ba:	8b73      	ldrh	r3, [r6, #26]
    76bc:	075b      	lsls	r3, r3, #29
    76be:	d514      	bpl.n	76ea <_spi_interrupt_handler+0xda>
			if (module->dir != SPI_DIRECTION_WRITE) {
    76c0:	7a63      	ldrb	r3, [r4, #9]
    76c2:	2b01      	cmp	r3, #1
    76c4:	d00b      	beq.n	76de <_spi_interrupt_handler+0xce>
				/* Store the error code */
				module->status = STATUS_ERR_OVERFLOW;
    76c6:	221e      	movs	r2, #30
    76c8:	2338      	movs	r3, #56	; 0x38
    76ca:	54e2      	strb	r2, [r4, r3]

				/* End transaction */
				module->dir = SPI_DIRECTION_IDLE;
    76cc:	3b35      	subs	r3, #53	; 0x35
    76ce:	7263      	strb	r3, [r4, #9]

				spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE |
    76d0:	3302      	adds	r3, #2
    76d2:	7533      	strb	r3, [r6, #20]
						SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
				/* Run callback if registered and enabled */
				if (callback_mask & (1 << SPI_CALLBACK_ERROR)) {
    76d4:	073b      	lsls	r3, r7, #28
    76d6:	d502      	bpl.n	76de <_spi_interrupt_handler+0xce>
					(module->callback[SPI_CALLBACK_ERROR])(module);
    76d8:	0020      	movs	r0, r4
    76da:	69a3      	ldr	r3, [r4, #24]
    76dc:	4798      	blx	r3
				}
			}
			/* Flush */
			uint16_t flush = spi_hw->DATA.reg;
    76de:	6ab3      	ldr	r3, [r6, #40]	; 0x28
			UNUSED(flush);
			/* Clear overflow flag */
			spi_hw->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    76e0:	8b72      	ldrh	r2, [r6, #26]
    76e2:	2304      	movs	r3, #4
    76e4:	4313      	orrs	r3, r2
    76e6:	8373      	strh	r3, [r6, #26]
    76e8:	e049      	b.n	777e <_spi_interrupt_handler+0x16e>
		} else {
			if (module->dir == SPI_DIRECTION_WRITE) {
    76ea:	7a63      	ldrb	r3, [r4, #9]
    76ec:	2b01      	cmp	r3, #1
    76ee:	d116      	bne.n	771e <_spi_interrupt_handler+0x10e>
 */
static void _spi_read_dummy(
		struct spi_module *const module)
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    76f0:	6823      	ldr	r3, [r4, #0]
	uint16_t flush = 0;

	/* Read dummy byte */
	flush = spi_hw->DATA.reg;
    76f2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	UNUSED(flush);

	/* Decrement remaining dummy buffer length */
	module->remaining_dummy_buffer_length--;
    76f4:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    76f6:	3b01      	subs	r3, #1
    76f8:	b29b      	uxth	r3, r3
    76fa:	8663      	strh	r3, [r4, #50]	; 0x32
			spi_hw->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
		} else {
			if (module->dir == SPI_DIRECTION_WRITE) {
				/* Flush receive buffer when writing */
				_spi_read_dummy(module);
				if (module->remaining_dummy_buffer_length == 0) {
    76fc:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    76fe:	b29b      	uxth	r3, r3
    7700:	2b00      	cmp	r3, #0
    7702:	d13c      	bne.n	777e <_spi_interrupt_handler+0x16e>
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
    7704:	3304      	adds	r3, #4
    7706:	7533      	strb	r3, [r6, #20]
					module->status = STATUS_OK;
    7708:	2200      	movs	r2, #0
    770a:	3334      	adds	r3, #52	; 0x34
    770c:	54e2      	strb	r2, [r4, r3]
					module->dir = SPI_DIRECTION_IDLE;
    770e:	3b35      	subs	r3, #53	; 0x35
    7710:	7263      	strb	r3, [r4, #9]
					/* Run callback if registered and enabled */
					if (callback_mask &
    7712:	07fb      	lsls	r3, r7, #31
    7714:	d533      	bpl.n	777e <_spi_interrupt_handler+0x16e>
							(1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
						(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])(module);
    7716:	0020      	movs	r0, r4
    7718:	68e3      	ldr	r3, [r4, #12]
    771a:	4798      	blx	r3
    771c:	e02f      	b.n	777e <_spi_interrupt_handler+0x16e>
 */
static void _spi_read(
		struct spi_module *const module)
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    771e:	6823      	ldr	r3, [r4, #0]

	uint16_t received_data = (spi_hw->DATA.reg & SERCOM_SPI_DATA_MASK);
    7720:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    7722:	05db      	lsls	r3, r3, #23
    7724:	0ddb      	lsrs	r3, r3, #23

	/* Read value will be at least 8-bits long */
	*(module->rx_buffer_ptr) = received_data;
    7726:	b2da      	uxtb	r2, r3
    7728:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    772a:	700a      	strb	r2, [r1, #0]
	/* Increment 8-bit pointer */
	module->rx_buffer_ptr += 1;
    772c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    772e:	1c51      	adds	r1, r2, #1
    7730:	62a1      	str	r1, [r4, #40]	; 0x28

	if(module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    7732:	79a1      	ldrb	r1, [r4, #6]
    7734:	2901      	cmp	r1, #1
    7736:	d104      	bne.n	7742 <_spi_interrupt_handler+0x132>
		/* 9-bit data, write next received byte to the buffer */
		*(module->rx_buffer_ptr) = (received_data >> 8);
    7738:	0a1b      	lsrs	r3, r3, #8
    773a:	7053      	strb	r3, [r2, #1]
		/* Increment 8-bit pointer */
		module->rx_buffer_ptr += 1;
    773c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    773e:	3301      	adds	r3, #1
    7740:	62a3      	str	r3, [r4, #40]	; 0x28
	}

	/* Decrement length of the remaining buffer */
	module->remaining_rx_buffer_length--;
    7742:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    7744:	3b01      	subs	r3, #1
    7746:	b29b      	uxth	r3, r3
    7748:	8623      	strh	r3, [r4, #48]	; 0x30
			} else {
				/* Read data register */
				_spi_read(module);

				/* Check if the last character have been received */
				if (module->remaining_rx_buffer_length == 0) {
    774a:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    774c:	b29b      	uxth	r3, r3
    774e:	2b00      	cmp	r3, #0
    7750:	d115      	bne.n	777e <_spi_interrupt_handler+0x16e>
					module->status = STATUS_OK;
    7752:	2200      	movs	r2, #0
    7754:	3338      	adds	r3, #56	; 0x38
    7756:	54e2      	strb	r2, [r4, r3]
					/* Disable RX Complete Interrupt and set status */
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
    7758:	3b34      	subs	r3, #52	; 0x34
    775a:	7533      	strb	r3, [r6, #20]
					if(module->dir == SPI_DIRECTION_BOTH) {
    775c:	7a63      	ldrb	r3, [r4, #9]
    775e:	2b02      	cmp	r3, #2
    7760:	d105      	bne.n	776e <_spi_interrupt_handler+0x15e>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSCEIVED)) {
    7762:	077b      	lsls	r3, r7, #29
    7764:	d50b      	bpl.n	777e <_spi_interrupt_handler+0x16e>
							(module->callback[SPI_CALLBACK_BUFFER_TRANSCEIVED])(module);
    7766:	0020      	movs	r0, r4
    7768:	6963      	ldr	r3, [r4, #20]
    776a:	4798      	blx	r3
    776c:	e007      	b.n	777e <_spi_interrupt_handler+0x16e>
						}
					} else if (module->dir == SPI_DIRECTION_READ) {
    776e:	7a63      	ldrb	r3, [r4, #9]
    7770:	2b00      	cmp	r3, #0
    7772:	d104      	bne.n	777e <_spi_interrupt_handler+0x16e>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_RECEIVED)) {
    7774:	07bb      	lsls	r3, r7, #30
    7776:	d502      	bpl.n	777e <_spi_interrupt_handler+0x16e>
							(module->callback[SPI_CALLBACK_BUFFER_RECEIVED])(module);
    7778:	0020      	movs	r0, r4
    777a:	6923      	ldr	r3, [r4, #16]
    777c:	4798      	blx	r3
			}
		}
	}

	/* Transmit complete */
	if (interrupt_status & SPI_INTERRUPT_FLAG_TX_COMPLETE) {
    777e:	07ab      	lsls	r3, r5, #30
    7780:	d528      	bpl.n	77d4 <_spi_interrupt_handler+0x1c4>
#  if CONF_SPI_SLAVE_ENABLE == true
		if (module->mode == SPI_MODE_SLAVE) {
    7782:	7963      	ldrb	r3, [r4, #5]
    7784:	2b00      	cmp	r3, #0
    7786:	d110      	bne.n	77aa <_spi_interrupt_handler+0x19a>
			/* Transaction ended by master */

			/* Disable interrupts */
			spi_hw->INTENCLR.reg =
    7788:	3307      	adds	r3, #7
    778a:	7533      	strb	r3, [r6, #20]
					SPI_INTERRUPT_FLAG_TX_COMPLETE |
					SPI_INTERRUPT_FLAG_RX_COMPLETE |
					SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
			/* Clear interrupt flag */
			spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    778c:	3b05      	subs	r3, #5
    778e:	7633      	strb	r3, [r6, #24]


			/* Reset all status information */
			module->dir = SPI_DIRECTION_IDLE;
    7790:	3301      	adds	r3, #1
    7792:	7263      	strb	r3, [r4, #9]
			module->remaining_tx_buffer_length = 0;
    7794:	2300      	movs	r3, #0
    7796:	86a3      	strh	r3, [r4, #52]	; 0x34
			module->remaining_rx_buffer_length = 0;
    7798:	8623      	strh	r3, [r4, #48]	; 0x30
			module->status = STATUS_OK;
    779a:	3338      	adds	r3, #56	; 0x38
    779c:	2200      	movs	r2, #0
    779e:	54e2      	strb	r2, [r4, r3]

			if (callback_mask &
    77a0:	06fb      	lsls	r3, r7, #27
    77a2:	d502      	bpl.n	77aa <_spi_interrupt_handler+0x19a>
					(1 << SPI_CALLBACK_SLAVE_TRANSMISSION_COMPLETE)) {
			(module->callback[SPI_CALLBACK_SLAVE_TRANSMISSION_COMPLETE])
    77a4:	0020      	movs	r0, r4
    77a6:	69e3      	ldr	r3, [r4, #28]
    77a8:	4798      	blx	r3
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    77aa:	7963      	ldrb	r3, [r4, #5]
    77ac:	2b01      	cmp	r3, #1
    77ae:	d111      	bne.n	77d4 <_spi_interrupt_handler+0x1c4>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
    77b0:	7a63      	ldrb	r3, [r4, #9]
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    77b2:	2b01      	cmp	r3, #1
    77b4:	d11b      	bne.n	77ee <_spi_interrupt_handler+0x1de>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
    77b6:	79e3      	ldrb	r3, [r4, #7]
    77b8:	2b00      	cmp	r3, #0
    77ba:	d118      	bne.n	77ee <_spi_interrupt_handler+0x1de>
		  	/* Clear interrupt flag */
		 	spi_hw->INTENCLR.reg
					= SPI_INTERRUPT_FLAG_TX_COMPLETE;
    77bc:	3302      	adds	r3, #2
    77be:	7533      	strb	r3, [r6, #20]
			/* Buffer sent with receiver disabled */
			module->dir = SPI_DIRECTION_IDLE;
    77c0:	3301      	adds	r3, #1
    77c2:	7263      	strb	r3, [r4, #9]
			module->status = STATUS_OK;
    77c4:	2200      	movs	r2, #0
    77c6:	3335      	adds	r3, #53	; 0x35
    77c8:	54e2      	strb	r2, [r4, r3]
			/* Run callback if registered and enabled */
			if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
    77ca:	07fb      	lsls	r3, r7, #31
    77cc:	d502      	bpl.n	77d4 <_spi_interrupt_handler+0x1c4>
				(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])
    77ce:	0020      	movs	r0, r4
    77d0:	68e3      	ldr	r3, [r4, #12]
    77d2:	4798      	blx	r3
	}

#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
#  if CONF_SPI_SLAVE_ENABLE == true
		/* When a high to low transition is detected on the _SS pin in slave mode */
		if (interrupt_status & SPI_INTERRUPT_FLAG_SLAVE_SELECT_LOW) {
    77d4:	072b      	lsls	r3, r5, #28
    77d6:	d50a      	bpl.n	77ee <_spi_interrupt_handler+0x1de>
			if (module->mode == SPI_MODE_SLAVE) {
    77d8:	7963      	ldrb	r3, [r4, #5]
    77da:	2b00      	cmp	r3, #0
    77dc:	d107      	bne.n	77ee <_spi_interrupt_handler+0x1de>
				/* Disable interrupts */
				spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_SLAVE_SELECT_LOW;
    77de:	3308      	adds	r3, #8
    77e0:	7533      	strb	r3, [r6, #20]
				/* Clear interrupt flag */
				spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_SLAVE_SELECT_LOW;
    77e2:	7633      	strb	r3, [r6, #24]

				if (callback_mask & (1 << SPI_CALLBACK_SLAVE_SELECT_LOW)) {
    77e4:	06bb      	lsls	r3, r7, #26
    77e6:	d502      	bpl.n	77ee <_spi_interrupt_handler+0x1de>
					(module->callback[SPI_CALLBACK_SLAVE_SELECT_LOW])(module);
    77e8:	0020      	movs	r0, r4
    77ea:	6a23      	ldr	r3, [r4, #32]
    77ec:	4798      	blx	r3
#  endif
#  endif

#  ifdef FEATURE_SPI_ERROR_INTERRUPT
	/* When combined error happen */
	if (interrupt_status & SPI_INTERRUPT_FLAG_COMBINED_ERROR) {
    77ee:	09ed      	lsrs	r5, r5, #7
    77f0:	d007      	beq.n	7802 <_spi_interrupt_handler+0x1f2>
		/* Disable interrupts */
		spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
    77f2:	2380      	movs	r3, #128	; 0x80
    77f4:	7533      	strb	r3, [r6, #20]
		/* Clear interrupt flag */
		spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
    77f6:	7633      	strb	r3, [r6, #24]

		if (callback_mask & (1 << SPI_CALLBACK_COMBINED_ERROR)) {
    77f8:	067b      	lsls	r3, r7, #25
    77fa:	d502      	bpl.n	7802 <_spi_interrupt_handler+0x1f2>
			(module->callback[SPI_CALLBACK_COMBINED_ERROR])(module);
    77fc:	6a63      	ldr	r3, [r4, #36]	; 0x24
    77fe:	0020      	movs	r0, r4
    7800:	4798      	blx	r3
		}
	}
#  endif
}
    7802:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7804:	20002850 	.word	0x20002850
    7808:	20002358 	.word	0x20002358

0000780c <pahoMessageCallback>:
		.isRetained = false,
		.qos = QOS_0
};

#define GETLOWER4BYTES 0x0FFFFFFFF
void pahoMessageCallback(MessageData* md) {
    780c:	b510      	push	{r4, lr}
    780e:	b088      	sub	sp, #32
	MQTTMessage* message = md->message;
    7810:	6803      	ldr	r3, [r0, #0]
	MQTTCallbackParams params;

	// early exit if we do not have a valid callback pointer
	if (md->applicationHandler == NULL) {
    7812:	6884      	ldr	r4, [r0, #8]
    7814:	2c00      	cmp	r4, #0
    7816:	d023      	beq.n	7860 <pahoMessageCallback+0x54>
		return;
	}

	if (NULL != md->topicName->lenstring.data) {
    7818:	6842      	ldr	r2, [r0, #4]
    781a:	6891      	ldr	r1, [r2, #8]
    781c:	2900      	cmp	r1, #0
    781e:	d003      	beq.n	7828 <pahoMessageCallback+0x1c>
		params.pTopicName = md->topicName->lenstring.data;
    7820:	9102      	str	r1, [sp, #8]
		params.TopicNameLen = (uint16_t)(md->topicName->lenstring.len);
    7822:	6851      	ldr	r1, [r2, #4]
    7824:	aa02      	add	r2, sp, #8
    7826:	8091      	strh	r1, [r2, #4]
	}
	if (NULL != message) {
    7828:	2b00      	cmp	r3, #0
    782a:	d010      	beq.n	784e <pahoMessageCallback+0x42>
		params.MessageParams.PayloadLen = message->payloadlen & GETLOWER4BYTES;
    782c:	aa02      	add	r2, sp, #8
    782e:	68d9      	ldr	r1, [r3, #12]
    7830:	9107      	str	r1, [sp, #28]
		params.MessageParams.pPayload = (char*) message->payload;
    7832:	6899      	ldr	r1, [r3, #8]
    7834:	9106      	str	r1, [sp, #24]
		params.MessageParams.isDuplicate = message->dup;
    7836:	7899      	ldrb	r1, [r3, #2]
    7838:	1e48      	subs	r0, r1, #1
    783a:	4181      	sbcs	r1, r0
    783c:	7291      	strb	r1, [r2, #10]
		params.MessageParams.qos = (QoSLevel)message->qos;
    783e:	7819      	ldrb	r1, [r3, #0]
    7840:	7211      	strb	r1, [r2, #8]
		params.MessageParams.isRetained = message->retained;
    7842:	7859      	ldrb	r1, [r3, #1]
    7844:	1e48      	subs	r0, r1, #1
    7846:	4181      	sbcs	r1, r0
    7848:	7251      	strb	r1, [r2, #9]
		params.MessageParams.id = message->id;
    784a:	889b      	ldrh	r3, [r3, #4]
    784c:	8193      	strh	r3, [r2, #12]
	}

	((iot_message_handler)(md->applicationHandler))(params);
    784e:	ab06      	add	r3, sp, #24
    7850:	466a      	mov	r2, sp
    7852:	cb03      	ldmia	r3!, {r0, r1}
    7854:	c203      	stmia	r2!, {r0, r1}
    7856:	9802      	ldr	r0, [sp, #8]
    7858:	9903      	ldr	r1, [sp, #12]
    785a:	9a04      	ldr	r2, [sp, #16]
    785c:	9b05      	ldr	r3, [sp, #20]
    785e:	47a0      	blx	r4
}
    7860:	b008      	add	sp, #32
    7862:	bd10      	pop	{r4, pc}

00007864 <pahoDisconnectHandler>:

void pahoDisconnectHandler(void) {
    7864:	b510      	push	{r4, lr}
	if(NULL != clientDisconnectHandler) {
    7866:	4b03      	ldr	r3, [pc, #12]	; (7874 <pahoDisconnectHandler+0x10>)
    7868:	681b      	ldr	r3, [r3, #0]
    786a:	2b00      	cmp	r3, #0
    786c:	d000      	beq.n	7870 <pahoDisconnectHandler+0xc>
		clientDisconnectHandler();
    786e:	4798      	blx	r3
	}
}
    7870:	bd10      	pop	{r4, pc}
    7872:	46c0      	nop			; (mov r8, r8)
    7874:	20000ce0 	.word	0x20000ce0

00007878 <aws_iot_mqtt_connect>:

static bool isPowerCycle = true;

IoT_Error_t aws_iot_mqtt_connect(MQTTConnectParams *pParams) {
    7878:	b530      	push	{r4, r5, lr}
    787a:	b0a3      	sub	sp, #140	; 0x8c
    787c:	1e04      	subs	r4, r0, #0
	IoT_Error_t rc = NONE_ERROR;
	MQTTReturnCode pahoRc = SUCCESS;

	if(NULL == pParams || NULL == pParams->pClientID || NULL == pParams->pHostURL) {
    787e:	d077      	beq.n	7970 <aws_iot_mqtt_connect+0xf8>
    7880:	6983      	ldr	r3, [r0, #24]
    7882:	2b00      	cmp	r3, #0
    7884:	d077      	beq.n	7976 <aws_iot_mqtt_connect+0xfe>
    7886:	6842      	ldr	r2, [r0, #4]
    7888:	2a00      	cmp	r2, #0
    788a:	d077      	beq.n	797c <aws_iot_mqtt_connect+0x104>
		return NULL_VALUE_ERROR;
	}

	TLSConnectParams TLSParams;
	TLSParams.DestinationPort = pParams->port;
    788c:	ab1b      	add	r3, sp, #108	; 0x6c
    788e:	8901      	ldrh	r1, [r0, #8]
    7890:	911f      	str	r1, [sp, #124]	; 0x7c
	TLSParams.pDestinationURL = pParams->pHostURL;
    7892:	921e      	str	r2, [sp, #120]	; 0x78
	TLSParams.pDeviceCertLocation = pParams->pDeviceCertLocation;
    7894:	6902      	ldr	r2, [r0, #16]
    7896:	921c      	str	r2, [sp, #112]	; 0x70
	TLSParams.pDevicePrivateKeyLocation = pParams->pDevicePrivateKeyLocation;
    7898:	6942      	ldr	r2, [r0, #20]
    789a:	921d      	str	r2, [sp, #116]	; 0x74
	TLSParams.pRootCALocation = pParams->pRootCALocation;
    789c:	68c2      	ldr	r2, [r0, #12]
    789e:	921b      	str	r2, [sp, #108]	; 0x6c
	TLSParams.timeout_ms = pParams->tlsHandshakeTimeout_ms;
    78a0:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    78a2:	9220      	str	r2, [sp, #128]	; 0x80
	TLSParams.ServerVerificationFlag = pParams->isSSLHostnameVerify;
    78a4:	2240      	movs	r2, #64	; 0x40
    78a6:	5c82      	ldrb	r2, [r0, r2]
    78a8:	761a      	strb	r2, [r3, #24]

	// This implementation assumes you are not going to switch between cleansession 1 to 0
	// As we don't have a default subscription handler support in the MQTT client every time a device power cycles it has to re-subscribe to let the MQTT client to pass the message up to the application callback.
	// The default message handler will be implemented in the future revisions.
	if(pParams->isCleansession || isPowerCycle){
    78aa:	2328      	movs	r3, #40	; 0x28
    78ac:	5cc3      	ldrb	r3, [r0, r3]
    78ae:	2b00      	cmp	r3, #0
    78b0:	d103      	bne.n	78ba <aws_iot_mqtt_connect+0x42>
    78b2:	4b37      	ldr	r3, [pc, #220]	; (7990 <aws_iot_mqtt_connect+0x118>)
    78b4:	781b      	ldrb	r3, [r3, #0]
    78b6:	2b00      	cmp	r3, #0
    78b8:	d014      	beq.n	78e4 <aws_iot_mqtt_connect+0x6c>
		pahoRc = MQTTClient(&c, (unsigned int)(pParams->mqttCommandTimeout_ms), writebuf,
    78ba:	2380      	movs	r3, #128	; 0x80
    78bc:	00db      	lsls	r3, r3, #3
    78be:	aa1b      	add	r2, sp, #108	; 0x6c
    78c0:	9204      	str	r2, [sp, #16]
    78c2:	4a34      	ldr	r2, [pc, #208]	; (7994 <aws_iot_mqtt_connect+0x11c>)
    78c4:	9203      	str	r2, [sp, #12]
    78c6:	7822      	ldrb	r2, [r4, #0]
    78c8:	9202      	str	r2, [sp, #8]
    78ca:	9301      	str	r3, [sp, #4]
    78cc:	4a32      	ldr	r2, [pc, #200]	; (7998 <aws_iot_mqtt_connect+0x120>)
    78ce:	9200      	str	r2, [sp, #0]
    78d0:	4a32      	ldr	r2, [pc, #200]	; (799c <aws_iot_mqtt_connect+0x124>)
    78d2:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    78d4:	4832      	ldr	r0, [pc, #200]	; (79a0 <aws_iot_mqtt_connect+0x128>)
    78d6:	4d33      	ldr	r5, [pc, #204]	; (79a4 <aws_iot_mqtt_connect+0x12c>)
    78d8:	47a8      	blx	r5
				   AWS_IOT_MQTT_TX_BUF_LEN, readbuf, AWS_IOT_MQTT_RX_BUF_LEN,
				   pParams->enableAutoReconnect, iot_tls_init, &TLSParams);
		if(SUCCESS != pahoRc) {
    78da:	2800      	cmp	r0, #0
    78dc:	d151      	bne.n	7982 <aws_iot_mqtt_connect+0x10a>
			return CONNECTION_ERROR;
		}
		isPowerCycle = false;
    78de:	2200      	movs	r2, #0
    78e0:	4b2b      	ldr	r3, [pc, #172]	; (7990 <aws_iot_mqtt_connect+0x118>)
    78e2:	701a      	strb	r2, [r3, #0]
	}

	MQTTPacket_connectData data = MQTTPacket_connectData_initializer;
    78e4:	ad06      	add	r5, sp, #24
    78e6:	2254      	movs	r2, #84	; 0x54
    78e8:	492f      	ldr	r1, [pc, #188]	; (79a8 <aws_iot_mqtt_connect+0x130>)
    78ea:	0028      	movs	r0, r5
    78ec:	4b2f      	ldr	r3, [pc, #188]	; (79ac <aws_iot_mqtt_connect+0x134>)
    78ee:	4798      	blx	r3

	data.willFlag = pParams->isWillMsgPresent;
    78f0:	2329      	movs	r3, #41	; 0x29
    78f2:	5ce3      	ldrb	r3, [r4, r3]
    78f4:	75eb      	strb	r3, [r5, #23]
	// compatible type for MQTT_Ver_t
	switch (pParams->MQTTVersion) {
    78f6:	2324      	movs	r3, #36	; 0x24
    78f8:	5ce3      	ldrb	r3, [r4, r3]
    78fa:	2b03      	cmp	r3, #3
    78fc:	d002      	beq.n	7904 <aws_iot_mqtt_connect+0x8c>
    78fe:	2b04      	cmp	r3, #4
    7900:	d004      	beq.n	790c <aws_iot_mqtt_connect+0x94>
    7902:	e007      	b.n	7914 <aws_iot_mqtt_connect+0x9c>
	case MQTT_3_1:
		data.MQTTVersion = (unsigned char) (3);
    7904:	2203      	movs	r2, #3
    7906:	ab06      	add	r3, sp, #24
    7908:	715a      	strb	r2, [r3, #5]
		break;
    790a:	e006      	b.n	791a <aws_iot_mqtt_connect+0xa2>
	case MQTT_3_1_1:
		data.MQTTVersion = (unsigned char) (4);
    790c:	2204      	movs	r2, #4
    790e:	ab06      	add	r3, sp, #24
    7910:	715a      	strb	r2, [r3, #5]
		break;
    7912:	e002      	b.n	791a <aws_iot_mqtt_connect+0xa2>
	default:
		data.MQTTVersion = (unsigned char) (4); // default MQTT version = 3.1.1
    7914:	2204      	movs	r2, #4
    7916:	ab06      	add	r3, sp, #24
    7918:	715a      	strb	r2, [r3, #5]
	}

	// register our disconnect handler, save customer's handler
	setDisconnectHandler(&c, pahoDisconnectHandler);
    791a:	4d21      	ldr	r5, [pc, #132]	; (79a0 <aws_iot_mqtt_connect+0x128>)
    791c:	4924      	ldr	r1, [pc, #144]	; (79b0 <aws_iot_mqtt_connect+0x138>)
    791e:	0028      	movs	r0, r5
    7920:	4b24      	ldr	r3, [pc, #144]	; (79b4 <aws_iot_mqtt_connect+0x13c>)
    7922:	4798      	blx	r3
	clientDisconnectHandler = pParams->disconnectHandler;
    7924:	4b24      	ldr	r3, [pc, #144]	; (79b8 <aws_iot_mqtt_connect+0x140>)
    7926:	6c62      	ldr	r2, [r4, #68]	; 0x44
    7928:	601a      	str	r2, [r3, #0]

	data.clientID.cstring = pParams->pClientID;
    792a:	a906      	add	r1, sp, #24
    792c:	69a3      	ldr	r3, [r4, #24]
    792e:	608b      	str	r3, [r1, #8]
	data.username.cstring = pParams->pUserName;
    7930:	69e3      	ldr	r3, [r4, #28]
    7932:	63cb      	str	r3, [r1, #60]	; 0x3c
	data.password.cstring = pParams->pPassword;
    7934:	6a23      	ldr	r3, [r4, #32]
    7936:	648b      	str	r3, [r1, #72]	; 0x48
	data.will.topicName.cstring = (char*)pParams->will.pTopicName;
    7938:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    793a:	620b      	str	r3, [r1, #32]
	data.will.message.cstring = (char*)pParams->will.pMessage;
    793c:	6b23      	ldr	r3, [r4, #48]	; 0x30
    793e:	62cb      	str	r3, [r1, #44]	; 0x2c
	data.will.qos = pParams->will.qos;
    7940:	2335      	movs	r3, #53	; 0x35
    7942:	5ce2      	ldrb	r2, [r4, r3]
    7944:	3304      	adds	r3, #4
    7946:	54ca      	strb	r2, [r1, r3]
	data.will.retained = pParams->will.isRetained;
    7948:	3b05      	subs	r3, #5
    794a:	5ce2      	ldrb	r2, [r4, r3]
    794c:	3304      	adds	r3, #4
    794e:	54ca      	strb	r2, [r1, r3]
	data.keepAliveInterval = pParams->KeepAliveInterval_sec;
    7950:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
    7952:	828b      	strh	r3, [r1, #20]
	data.cleansession = pParams->isCleansession;
    7954:	2328      	movs	r3, #40	; 0x28
    7956:	5ce3      	ldrb	r3, [r4, r3]
    7958:	758b      	strb	r3, [r1, #22]

	pahoRc = MQTTConnect(&c, &data);
    795a:	0028      	movs	r0, r5
    795c:	4b17      	ldr	r3, [pc, #92]	; (79bc <aws_iot_mqtt_connect+0x144>)
    795e:	4798      	blx	r3
    7960:	0003      	movs	r3, r0
	if(MQTT_NETWORK_ALREADY_CONNECTED_ERROR == pahoRc) {
    7962:	1d42      	adds	r2, r0, #5
    7964:	d010      	beq.n	7988 <aws_iot_mqtt_connect+0x110>
}

static bool isPowerCycle = true;

IoT_Error_t aws_iot_mqtt_connect(MQTTConnectParams *pParams) {
	IoT_Error_t rc = NONE_ERROR;
    7966:	2000      	movs	r0, #0
	data.cleansession = pParams->isCleansession;

	pahoRc = MQTTConnect(&c, &data);
	if(MQTT_NETWORK_ALREADY_CONNECTED_ERROR == pahoRc) {
		rc = NETWORK_ALREADY_CONNECTED;
	} else if(SUCCESS != pahoRc) {
    7968:	2b00      	cmp	r3, #0
    796a:	d00f      	beq.n	798c <aws_iot_mqtt_connect+0x114>
		rc = CONNECTION_ERROR;
    796c:	3803      	subs	r0, #3
    796e:	e00d      	b.n	798c <aws_iot_mqtt_connect+0x114>
IoT_Error_t aws_iot_mqtt_connect(MQTTConnectParams *pParams) {
	IoT_Error_t rc = NONE_ERROR;
	MQTTReturnCode pahoRc = SUCCESS;

	if(NULL == pParams || NULL == pParams->pClientID || NULL == pParams->pHostURL) {
		return NULL_VALUE_ERROR;
    7970:	2002      	movs	r0, #2
    7972:	4240      	negs	r0, r0
    7974:	e00a      	b.n	798c <aws_iot_mqtt_connect+0x114>
    7976:	2002      	movs	r0, #2
    7978:	4240      	negs	r0, r0
    797a:	e007      	b.n	798c <aws_iot_mqtt_connect+0x114>
    797c:	2002      	movs	r0, #2
    797e:	4240      	negs	r0, r0
    7980:	e004      	b.n	798c <aws_iot_mqtt_connect+0x114>
	if(pParams->isCleansession || isPowerCycle){
		pahoRc = MQTTClient(&c, (unsigned int)(pParams->mqttCommandTimeout_ms), writebuf,
				   AWS_IOT_MQTT_TX_BUF_LEN, readbuf, AWS_IOT_MQTT_RX_BUF_LEN,
				   pParams->enableAutoReconnect, iot_tls_init, &TLSParams);
		if(SUCCESS != pahoRc) {
			return CONNECTION_ERROR;
    7982:	2003      	movs	r0, #3
    7984:	4240      	negs	r0, r0
    7986:	e001      	b.n	798c <aws_iot_mqtt_connect+0x114>
	data.keepAliveInterval = pParams->KeepAliveInterval_sec;
	data.cleansession = pParams->isCleansession;

	pahoRc = MQTTConnect(&c, &data);
	if(MQTT_NETWORK_ALREADY_CONNECTED_ERROR == pahoRc) {
		rc = NETWORK_ALREADY_CONNECTED;
    7988:	201a      	movs	r0, #26
    798a:	4240      	negs	r0, r0
	} else if(SUCCESS != pahoRc) {
		rc = CONNECTION_ERROR;
	}

	return rc;
}
    798c:	b023      	add	sp, #140	; 0x8c
    798e:	bd30      	pop	{r4, r5, pc}
    7990:	20000112 	.word	0x20000112
    7994:	00007edd 	.word	0x00007edd
    7998:	200008e0 	.word	0x200008e0
    799c:	20000ce4 	.word	0x20000ce4
    79a0:	200010e4 	.word	0x200010e4
    79a4:	00008031 	.word	0x00008031
    79a8:	00015174 	.word	0x00015174
    79ac:	00011833 	.word	0x00011833
    79b0:	00007865 	.word	0x00007865
    79b4:	00008da1 	.word	0x00008da1
    79b8:	20000ce0 	.word	0x20000ce0
    79bc:	00008619 	.word	0x00008619

000079c0 <aws_iot_mqtt_subscribe>:

IoT_Error_t aws_iot_mqtt_subscribe(MQTTSubscribeParams *pParams) {
    79c0:	b510      	push	{r4, lr}
    79c2:	b082      	sub	sp, #8
	IoT_Error_t rc = NONE_ERROR;

	if (0 != MQTTSubscribe(&c, pParams->pTopic, (enum QoS)pParams->qos, pahoMessageCallback, (void (*)(void))(pParams->mHandler))) {
    79c4:	7902      	ldrb	r2, [r0, #4]
    79c6:	6801      	ldr	r1, [r0, #0]
    79c8:	6883      	ldr	r3, [r0, #8]
    79ca:	9300      	str	r3, [sp, #0]
    79cc:	4b05      	ldr	r3, [pc, #20]	; (79e4 <aws_iot_mqtt_subscribe+0x24>)
    79ce:	4806      	ldr	r0, [pc, #24]	; (79e8 <aws_iot_mqtt_subscribe+0x28>)
    79d0:	4c06      	ldr	r4, [pc, #24]	; (79ec <aws_iot_mqtt_subscribe+0x2c>)
    79d2:	47a0      	blx	r4

	return rc;
}

IoT_Error_t aws_iot_mqtt_subscribe(MQTTSubscribeParams *pParams) {
	IoT_Error_t rc = NONE_ERROR;
    79d4:	2300      	movs	r3, #0

	if (0 != MQTTSubscribe(&c, pParams->pTopic, (enum QoS)pParams->qos, pahoMessageCallback, (void (*)(void))(pParams->mHandler))) {
    79d6:	2800      	cmp	r0, #0
    79d8:	d000      	beq.n	79dc <aws_iot_mqtt_subscribe+0x1c>
			rc = SUBSCRIBE_ERROR;
    79da:	3b04      	subs	r3, #4
	}
	return rc;
}
    79dc:	0018      	movs	r0, r3
    79de:	b002      	add	sp, #8
    79e0:	bd10      	pop	{r4, pc}
    79e2:	46c0      	nop			; (mov r8, r8)
    79e4:	0000780d 	.word	0x0000780d
    79e8:	200010e4 	.word	0x200010e4
    79ec:	00008761 	.word	0x00008761

000079f0 <aws_iot_mqtt_publish>:

IoT_Error_t aws_iot_mqtt_publish(MQTTPublishParams *pParams) {
    79f0:	b500      	push	{lr}
    79f2:	b085      	sub	sp, #20
	IoT_Error_t rc = NONE_ERROR;

	MQTTMessage Message;
	Message.dup = pParams->MessageParams.isDuplicate;
    79f4:	7983      	ldrb	r3, [r0, #6]
    79f6:	466a      	mov	r2, sp
    79f8:	7093      	strb	r3, [r2, #2]
	Message.id = pParams->MessageParams.id;
    79fa:	8903      	ldrh	r3, [r0, #8]
    79fc:	8093      	strh	r3, [r2, #4]
	Message.payload = pParams->MessageParams.pPayload;
    79fe:	68c3      	ldr	r3, [r0, #12]
    7a00:	9302      	str	r3, [sp, #8]
	Message.payloadlen = pParams->MessageParams.PayloadLen;
    7a02:	6903      	ldr	r3, [r0, #16]
    7a04:	9303      	str	r3, [sp, #12]
	Message.qos = (enum QoS)pParams->MessageParams.qos;
    7a06:	7903      	ldrb	r3, [r0, #4]
    7a08:	7013      	strb	r3, [r2, #0]
	Message.retained = pParams->MessageParams.isRetained;
    7a0a:	7943      	ldrb	r3, [r0, #5]
    7a0c:	7053      	strb	r3, [r2, #1]

	if(0 != MQTTPublish(&c, pParams->pTopic, &Message)){
    7a0e:	6801      	ldr	r1, [r0, #0]
    7a10:	4804      	ldr	r0, [pc, #16]	; (7a24 <aws_iot_mqtt_publish+0x34>)
    7a12:	4b05      	ldr	r3, [pc, #20]	; (7a28 <aws_iot_mqtt_publish+0x38>)
    7a14:	4798      	blx	r3
	}
	return rc;
}

IoT_Error_t aws_iot_mqtt_publish(MQTTPublishParams *pParams) {
	IoT_Error_t rc = NONE_ERROR;
    7a16:	2300      	movs	r3, #0
	Message.payload = pParams->MessageParams.pPayload;
	Message.payloadlen = pParams->MessageParams.PayloadLen;
	Message.qos = (enum QoS)pParams->MessageParams.qos;
	Message.retained = pParams->MessageParams.isRetained;

	if(0 != MQTTPublish(&c, pParams->pTopic, &Message)){
    7a18:	2800      	cmp	r0, #0
    7a1a:	d000      	beq.n	7a1e <aws_iot_mqtt_publish+0x2e>
		rc = PUBLISH_ERROR;
    7a1c:	3b05      	subs	r3, #5
	}

	return rc;
}
    7a1e:	0018      	movs	r0, r3
    7a20:	b005      	add	sp, #20
    7a22:	bd00      	pop	{pc}
    7a24:	200010e4 	.word	0x200010e4
    7a28:	00008a4d 	.word	0x00008a4d

00007a2c <aws_iot_mqtt_yield>:
	}

	return rc;
}

IoT_Error_t aws_iot_mqtt_yield(int timeout) {
    7a2c:	b510      	push	{r4, lr}
    7a2e:	0001      	movs	r1, r0
	MQTTReturnCode pahoRc = MQTTYield(&c, timeout);
    7a30:	4816      	ldr	r0, [pc, #88]	; (7a8c <aws_iot_mqtt_yield+0x60>)
    7a32:	4b17      	ldr	r3, [pc, #92]	; (7a90 <aws_iot_mqtt_yield+0x64>)
    7a34:	4798      	blx	r3
    7a36:	1e03      	subs	r3, r0, #0
	IoT_Error_t rc = NONE_ERROR;
	if(MQTT_NETWORK_RECONNECTED == pahoRc){
    7a38:	2b01      	cmp	r3, #1
    7a3a:	d012      	beq.n	7a62 <aws_iot_mqtt_yield+0x36>
		rc = RECONNECT_SUCCESSFUL;
	} else if(SUCCESS == pahoRc){
		rc = NONE_ERROR;
    7a3c:	2000      	movs	r0, #0
IoT_Error_t aws_iot_mqtt_yield(int timeout) {
	MQTTReturnCode pahoRc = MQTTYield(&c, timeout);
	IoT_Error_t rc = NONE_ERROR;
	if(MQTT_NETWORK_RECONNECTED == pahoRc){
		rc = RECONNECT_SUCCESSFUL;
	} else if(SUCCESS == pahoRc){
    7a3e:	2b00      	cmp	r3, #0
    7a40:	d022      	beq.n	7a88 <aws_iot_mqtt_yield+0x5c>
		rc = NONE_ERROR;
	} else if(MQTT_NULL_VALUE_ERROR == pahoRc) {
    7a42:	1d9a      	adds	r2, r3, #6
    7a44:	d00f      	beq.n	7a66 <aws_iot_mqtt_yield+0x3a>
		rc = NULL_VALUE_ERROR;
	} else if(MQTT_NETWORK_DISCONNECTED_ERROR == pahoRc) {
    7a46:	1d1a      	adds	r2, r3, #4
    7a48:	d010      	beq.n	7a6c <aws_iot_mqtt_yield+0x40>
		rc = NETWORK_DISCONNECTED;
	} else if(MQTT_RECONNECT_TIMED_OUT == pahoRc) {
    7a4a:	001a      	movs	r2, r3
    7a4c:	3208      	adds	r2, #8
    7a4e:	d010      	beq.n	7a72 <aws_iot_mqtt_yield+0x46>
		rc = NETWORK_RECONNECT_TIMED_OUT;
	} else if(MQTT_ATTEMPTING_RECONNECT == pahoRc) {
    7a50:	2b03      	cmp	r3, #3
    7a52:	d011      	beq.n	7a78 <aws_iot_mqtt_yield+0x4c>
		rc = NETWORK_ATTEMPTING_RECONNECT;
	} else if(MQTT_BUFFER_RX_MESSAGE_INVALID == pahoRc){
    7a54:	001a      	movs	r2, r3
    7a56:	3212      	adds	r2, #18
    7a58:	d011      	beq.n	7a7e <aws_iot_mqtt_yield+0x52>
		rc = RX_MESSAGE_INVALID;
	} else if(MQTTPACKET_BUFFER_TOO_SHORT == pahoRc){
    7a5a:	3309      	adds	r3, #9
    7a5c:	d012      	beq.n	7a84 <aws_iot_mqtt_yield+0x58>
		rc = RX_MESSAGE_BIGGER_THAN_MQTT_RX_BUF;
	} else {
		rc = YIELD_ERROR;
    7a5e:	3807      	subs	r0, #7
    7a60:	e012      	b.n	7a88 <aws_iot_mqtt_yield+0x5c>

IoT_Error_t aws_iot_mqtt_yield(int timeout) {
	MQTTReturnCode pahoRc = MQTTYield(&c, timeout);
	IoT_Error_t rc = NONE_ERROR;
	if(MQTT_NETWORK_RECONNECTED == pahoRc){
		rc = RECONNECT_SUCCESSFUL;
    7a62:	2001      	movs	r0, #1
    7a64:	e010      	b.n	7a88 <aws_iot_mqtt_yield+0x5c>
	} else if(SUCCESS == pahoRc){
		rc = NONE_ERROR;
	} else if(MQTT_NULL_VALUE_ERROR == pahoRc) {
		rc = NULL_VALUE_ERROR;
    7a66:	2002      	movs	r0, #2
    7a68:	4240      	negs	r0, r0
    7a6a:	e00d      	b.n	7a88 <aws_iot_mqtt_yield+0x5c>
	} else if(MQTT_NETWORK_DISCONNECTED_ERROR == pahoRc) {
		rc = NETWORK_DISCONNECTED;
    7a6c:	2017      	movs	r0, #23
    7a6e:	4240      	negs	r0, r0
    7a70:	e00a      	b.n	7a88 <aws_iot_mqtt_yield+0x5c>
	} else if(MQTT_RECONNECT_TIMED_OUT == pahoRc) {
		rc = NETWORK_RECONNECT_TIMED_OUT;
    7a72:	2018      	movs	r0, #24
    7a74:	4240      	negs	r0, r0
    7a76:	e007      	b.n	7a88 <aws_iot_mqtt_yield+0x5c>
	} else if(MQTT_ATTEMPTING_RECONNECT == pahoRc) {
		rc = NETWORK_ATTEMPTING_RECONNECT;
    7a78:	2019      	movs	r0, #25
    7a7a:	4240      	negs	r0, r0
    7a7c:	e004      	b.n	7a88 <aws_iot_mqtt_yield+0x5c>
	} else if(MQTT_BUFFER_RX_MESSAGE_INVALID == pahoRc){
		rc = RX_MESSAGE_INVALID;
    7a7e:	201b      	movs	r0, #27
    7a80:	4240      	negs	r0, r0
    7a82:	e001      	b.n	7a88 <aws_iot_mqtt_yield+0x5c>
	} else if(MQTTPACKET_BUFFER_TOO_SHORT == pahoRc){
		rc = RX_MESSAGE_BIGGER_THAN_MQTT_RX_BUF;
    7a84:	201c      	movs	r0, #28
    7a86:	4240      	negs	r0, r0
	} else {
		rc = YIELD_ERROR;
	}

	return rc;
}
    7a88:	bd10      	pop	{r4, pc}
    7a8a:	46c0      	nop			; (mov r8, r8)
    7a8c:	200010e4 	.word	0x200010e4
    7a90:	00008cc5 	.word	0x00008cc5

00007a94 <aws_iot_mqtt_attempt_reconnect>:

IoT_Error_t aws_iot_mqtt_attempt_reconnect() {
    7a94:	b510      	push	{r4, lr}
	MQTTReturnCode pahoRc = MQTTAttemptReconnect(&c);
    7a96:	480f      	ldr	r0, [pc, #60]	; (7ad4 <aws_iot_mqtt_attempt_reconnect+0x40>)
    7a98:	4b0f      	ldr	r3, [pc, #60]	; (7ad8 <aws_iot_mqtt_attempt_reconnect+0x44>)
    7a9a:	4798      	blx	r3
	IoT_Error_t rc = RECONNECT_SUCCESSFUL;
	if(MQTT_NETWORK_RECONNECTED == pahoRc){
    7a9c:	2801      	cmp	r0, #1
    7a9e:	d00e      	beq.n	7abe <aws_iot_mqtt_attempt_reconnect+0x2a>
		rc = RECONNECT_SUCCESSFUL;
	} else if(MQTT_NULL_VALUE_ERROR == pahoRc) {
    7aa0:	1d83      	adds	r3, r0, #6
    7aa2:	d00e      	beq.n	7ac2 <aws_iot_mqtt_attempt_reconnect+0x2e>
		rc = NULL_VALUE_ERROR;
	} else if(MQTT_NETWORK_DISCONNECTED_ERROR == pahoRc) {
    7aa4:	1d03      	adds	r3, r0, #4
    7aa6:	d00f      	beq.n	7ac8 <aws_iot_mqtt_attempt_reconnect+0x34>
		rc = NETWORK_DISCONNECTED;
	} else if(MQTT_RECONNECT_TIMED_OUT == pahoRc) {
    7aa8:	0003      	movs	r3, r0
    7aaa:	3308      	adds	r3, #8
    7aac:	d00f      	beq.n	7ace <aws_iot_mqtt_attempt_reconnect+0x3a>
		rc = NETWORK_RECONNECT_TIMED_OUT;
	} else if(MQTT_NETWORK_ALREADY_CONNECTED_ERROR == pahoRc) {
		rc = NETWORK_ALREADY_CONNECTED;
	} else {
		rc = GENERIC_ERROR;
    7aae:	3005      	adds	r0, #5
    7ab0:	1e43      	subs	r3, r0, #1
    7ab2:	4198      	sbcs	r0, r3
    7ab4:	4240      	negs	r0, r0
    7ab6:	231a      	movs	r3, #26
    7ab8:	425b      	negs	r3, r3
    7aba:	4318      	orrs	r0, r3
    7abc:	e009      	b.n	7ad2 <aws_iot_mqtt_attempt_reconnect+0x3e>

IoT_Error_t aws_iot_mqtt_attempt_reconnect() {
	MQTTReturnCode pahoRc = MQTTAttemptReconnect(&c);
	IoT_Error_t rc = RECONNECT_SUCCESSFUL;
	if(MQTT_NETWORK_RECONNECTED == pahoRc){
		rc = RECONNECT_SUCCESSFUL;
    7abe:	2001      	movs	r0, #1
    7ac0:	e007      	b.n	7ad2 <aws_iot_mqtt_attempt_reconnect+0x3e>
	} else if(MQTT_NULL_VALUE_ERROR == pahoRc) {
		rc = NULL_VALUE_ERROR;
    7ac2:	2002      	movs	r0, #2
    7ac4:	4240      	negs	r0, r0
    7ac6:	e004      	b.n	7ad2 <aws_iot_mqtt_attempt_reconnect+0x3e>
	} else if(MQTT_NETWORK_DISCONNECTED_ERROR == pahoRc) {
		rc = NETWORK_DISCONNECTED;
    7ac8:	2017      	movs	r0, #23
    7aca:	4240      	negs	r0, r0
    7acc:	e001      	b.n	7ad2 <aws_iot_mqtt_attempt_reconnect+0x3e>
	} else if(MQTT_RECONNECT_TIMED_OUT == pahoRc) {
		rc = NETWORK_RECONNECT_TIMED_OUT;
    7ace:	2018      	movs	r0, #24
    7ad0:	4240      	negs	r0, r0
	} else {
		rc = GENERIC_ERROR;
	}

	return rc;
}
    7ad2:	bd10      	pop	{r4, pc}
    7ad4:	200010e4 	.word	0x200010e4
    7ad8:	0000899d 	.word	0x0000899d

00007adc <aws_iot_mqtt_autoreconnect_set_status>:

IoT_Error_t aws_iot_mqtt_autoreconnect_set_status(bool value) {
    7adc:	b510      	push	{r4, lr}
    7ade:	0001      	movs	r1, r0
	MQTTReturnCode rc = setAutoReconnectEnabled(&c, (uint8_t) value);
    7ae0:	4804      	ldr	r0, [pc, #16]	; (7af4 <aws_iot_mqtt_autoreconnect_set_status+0x18>)
    7ae2:	4b05      	ldr	r3, [pc, #20]	; (7af8 <aws_iot_mqtt_autoreconnect_set_status+0x1c>)
    7ae4:	4798      	blx	r3

	if(MQTT_NULL_VALUE_ERROR == rc) {
    7ae6:	1d83      	adds	r3, r0, #6
    7ae8:	d001      	beq.n	7aee <aws_iot_mqtt_autoreconnect_set_status+0x12>
		return NULL_VALUE_ERROR;
	}

	return NONE_ERROR;
    7aea:	2000      	movs	r0, #0
    7aec:	e001      	b.n	7af2 <aws_iot_mqtt_autoreconnect_set_status+0x16>

IoT_Error_t aws_iot_mqtt_autoreconnect_set_status(bool value) {
	MQTTReturnCode rc = setAutoReconnectEnabled(&c, (uint8_t) value);

	if(MQTT_NULL_VALUE_ERROR == rc) {
		return NULL_VALUE_ERROR;
    7aee:	2002      	movs	r0, #2
    7af0:	4240      	negs	r0, r0
	}

	return NONE_ERROR;
}
    7af2:	bd10      	pop	{r4, pc}
    7af4:	200010e4 	.word	0x200010e4
    7af8:	00008dc1 	.word	0x00008dc1

00007afc <aws_iot_is_autoreconnect_enabled>:

bool aws_iot_is_mqtt_connected(void) {
	return MQTTIsConnected(&c);
}

bool aws_iot_is_autoreconnect_enabled(void) {
    7afc:	b510      	push	{r4, lr}
	return MQTTIsAutoReconnectEnabled(&c);
    7afe:	4803      	ldr	r0, [pc, #12]	; (7b0c <aws_iot_is_autoreconnect_enabled+0x10>)
    7b00:	4b03      	ldr	r3, [pc, #12]	; (7b10 <aws_iot_is_autoreconnect_enabled+0x14>)
    7b02:	4798      	blx	r3
    7b04:	1e43      	subs	r3, r0, #1
    7b06:	4198      	sbcs	r0, r3
    7b08:	b2c0      	uxtb	r0, r0
}
    7b0a:	bd10      	pop	{r4, pc}
    7b0c:	200010e4 	.word	0x200010e4
    7b10:	00008d95 	.word	0x00008d95

00007b14 <expired>:
	return ms_ticks;
}

char expired(Timer *timer)
{
	return ((timer->end_time > 0)
    7b14:	6802      	ldr	r2, [r0, #0]
	&& ((getTimeInMillis() + timer->offset) > timer->end_time));
    7b16:	2300      	movs	r3, #0
    7b18:	2a00      	cmp	r2, #0
    7b1a:	d006      	beq.n	7b2a <expired+0x16>
#include "AWS_SDK/aws_iot_src/protocol/mqtt/aws_iot_embedded_client_wrapper/timer_interface.h"
extern volatile uint32_t ms_ticks;

static uint32_t getTimeInMillis(void)
{
	return ms_ticks;
    7b1c:	4b04      	ldr	r3, [pc, #16]	; (7b30 <expired+0x1c>)
    7b1e:	6819      	ldr	r1, [r3, #0]
}

char expired(Timer *timer)
{
	return ((timer->end_time > 0)
	&& ((getTimeInMillis() + timer->offset) > timer->end_time));
    7b20:	6843      	ldr	r3, [r0, #4]
    7b22:	18cb      	adds	r3, r1, r3
    7b24:	429a      	cmp	r2, r3
    7b26:	419b      	sbcs	r3, r3
    7b28:	425b      	negs	r3, r3
	return ms_ticks;
}

char expired(Timer *timer)
{
	return ((timer->end_time > 0)
    7b2a:	b2d8      	uxtb	r0, r3
	&& ((getTimeInMillis() + timer->offset) > timer->end_time));
}
    7b2c:	4770      	bx	lr
    7b2e:	46c0      	nop			; (mov r8, r8)
    7b30:	2000193c 	.word	0x2000193c

00007b34 <countdown_ms>:
#include "AWS_SDK/aws_iot_src/protocol/mqtt/aws_iot_embedded_client_wrapper/timer_interface.h"
extern volatile uint32_t ms_ticks;

static uint32_t getTimeInMillis(void)
{
	return ms_ticks;
    7b34:	4b06      	ldr	r3, [pc, #24]	; (7b50 <countdown_ms+0x1c>)
    7b36:	681b      	ldr	r3, [r3, #0]

void countdown_ms(Timer *timer, unsigned int timeout)
{
	uint32_t timems = getTimeInMillis();

	timer->end_time = timems + timeout;
    7b38:	18ca      	adds	r2, r1, r3
    7b3a:	6002      	str	r2, [r0, #0]

	if (timer->end_time < timems) {
    7b3c:	429a      	cmp	r2, r3
    7b3e:	d203      	bcs.n	7b48 <countdown_ms+0x14>
		timer->offset = ~0 - timems + 1;
    7b40:	425b      	negs	r3, r3
    7b42:	6043      	str	r3, [r0, #4]
		timer->end_time += timer->offset;
    7b44:	6001      	str	r1, [r0, #0]
    7b46:	e001      	b.n	7b4c <countdown_ms+0x18>
	}
	else {
		timer->offset = 0;
    7b48:	2300      	movs	r3, #0
    7b4a:	6043      	str	r3, [r0, #4]
	}
}
    7b4c:	4770      	bx	lr
    7b4e:	46c0      	nop			; (mov r8, r8)
    7b50:	2000193c 	.word	0x2000193c

00007b54 <countdown>:
#include "AWS_SDK/aws_iot_src/protocol/mqtt/aws_iot_embedded_client_wrapper/timer_interface.h"
extern volatile uint32_t ms_ticks;

static uint32_t getTimeInMillis(void)
{
	return ms_ticks;
    7b54:	4b07      	ldr	r3, [pc, #28]	; (7b74 <countdown+0x20>)
    7b56:	681a      	ldr	r2, [r3, #0]

void countdown(Timer *timer, unsigned int timeout)
{
	uint32_t timems = getTimeInMillis();

	timer->end_time = timems + (timeout * 1000);
    7b58:	23fa      	movs	r3, #250	; 0xfa
    7b5a:	009b      	lsls	r3, r3, #2
    7b5c:	4359      	muls	r1, r3
    7b5e:	188b      	adds	r3, r1, r2
    7b60:	6003      	str	r3, [r0, #0]

	if (timer->end_time < timems) {
    7b62:	4293      	cmp	r3, r2
    7b64:	d203      	bcs.n	7b6e <countdown+0x1a>
		timer->offset = ~0 - timems + 1;
    7b66:	4252      	negs	r2, r2
    7b68:	6042      	str	r2, [r0, #4]
		timer->end_time += timer->offset;
    7b6a:	6001      	str	r1, [r0, #0]
    7b6c:	e001      	b.n	7b72 <countdown+0x1e>
	}
	else {
		timer->offset = 0;
    7b6e:	2300      	movs	r3, #0
    7b70:	6043      	str	r3, [r0, #4]
	}
}
    7b72:	4770      	bx	lr
    7b74:	2000193c 	.word	0x2000193c

00007b78 <left_ms>:
#include "AWS_SDK/aws_iot_src/protocol/mqtt/aws_iot_embedded_client_wrapper/timer_interface.h"
extern volatile uint32_t ms_ticks;

static uint32_t getTimeInMillis(void)
{
	return ms_ticks;
    7b78:	4b05      	ldr	r3, [pc, #20]	; (7b90 <left_ms+0x18>)
    7b7a:	681a      	ldr	r2, [r3, #0]
}

int left_ms(Timer *timer)
{
	int diff = timer->end_time - (getTimeInMillis() + timer->offset);
	return (diff > 0 ? diff : 0);
    7b7c:	6843      	ldr	r3, [r0, #4]
    7b7e:	469c      	mov	ip, r3
    7b80:	4462      	add	r2, ip
    7b82:	6803      	ldr	r3, [r0, #0]
    7b84:	1a98      	subs	r0, r3, r2
    7b86:	43c3      	mvns	r3, r0
    7b88:	17db      	asrs	r3, r3, #31
    7b8a:	4018      	ands	r0, r3
}
    7b8c:	4770      	bx	lr
    7b8e:	46c0      	nop			; (mov r8, r8)
    7b90:	2000193c 	.word	0x2000193c

00007b94 <InitTimer>:

void InitTimer(Timer *timer)
{
	timer->end_time = 0;
    7b94:	2300      	movs	r3, #0
    7b96:	6003      	str	r3, [r0, #0]
	timer->offset = 0;
    7b98:	6043      	str	r3, [r0, #4]
    7b9a:	4770      	bx	lr

00007b9c <iot_tls_is_connected>:
}

int iot_tls_is_connected(Network *pNetwork) {
	/* Use this to add implementation which can check for physical layer disconnect */
	return 1;
}
    7b9c:	2001      	movs	r0, #1
    7b9e:	4770      	bx	lr

00007ba0 <iot_tls_destroy>:
	close(pNetwork->my_socket);
}

int iot_tls_destroy(Network *pNetwork) {
	
	 if (pNetwork == NULL) {
    7ba0:	2800      	cmp	r0, #0
    7ba2:	d006      	beq.n	7bb2 <iot_tls_destroy+0x12>
		 return (NULL_VALUE_ERROR);
	 }

	 pNetwork->my_socket = 0;
    7ba4:	2300      	movs	r3, #0
    7ba6:	6003      	str	r3, [r0, #0]
	 pNetwork->mqttread = NULL;
    7ba8:	6083      	str	r3, [r0, #8]
	 pNetwork->mqttwrite = NULL;
    7baa:	60c3      	str	r3, [r0, #12]
	 pNetwork->disconnect = NULL;
    7bac:	6103      	str	r3, [r0, #16]

	 return (NONE_ERROR);
    7bae:	2000      	movs	r0, #0
    7bb0:	e001      	b.n	7bb6 <iot_tls_destroy+0x16>
}

int iot_tls_destroy(Network *pNetwork) {
	
	 if (pNetwork == NULL) {
		 return (NULL_VALUE_ERROR);
    7bb2:	2002      	movs	r0, #2
    7bb4:	4240      	negs	r0, r0
	 pNetwork->mqttread = NULL;
	 pNetwork->mqttwrite = NULL;
	 pNetwork->disconnect = NULL;

	 return (NONE_ERROR);
}
    7bb6:	4770      	bx	lr

00007bb8 <resolve_cb>:
 * \param[in] hostIp Server IP.
 *
 * \return None.
 */
static void resolve_cb(uint8_t *hostName, uint32_t hostIp)
{
    7bb8:	b530      	push	{r4, r5, lr}
    7bba:	b083      	sub	sp, #12
    7bbc:	0004      	movs	r4, r0
    7bbe:	0008      	movs	r0, r1
	state = DNS_REQUEST;
    7bc0:	2219      	movs	r2, #25
    7bc2:	4b0a      	ldr	r3, [pc, #40]	; (7bec <resolve_cb+0x34>)
    7bc4:	701a      	strb	r2, [r3, #0]
	gu32HostIp = hostIp;
    7bc6:	4b0a      	ldr	r3, [pc, #40]	; (7bf0 <resolve_cb+0x38>)
    7bc8:	6019      	str	r1, [r3, #0]
	gbHostIpByName = true;
	printf("Host IP is %d.%d.%d.%d\r\n", (int)IPV4_BYTE(hostIp, 0), (int)IPV4_BYTE(hostIp, 1),
    7bca:	0c0b      	lsrs	r3, r1, #16
    7bcc:	21ff      	movs	r1, #255	; 0xff
    7bce:	400b      	ands	r3, r1
    7bd0:	0a02      	lsrs	r2, r0, #8
    7bd2:	400a      	ands	r2, r1
    7bd4:	4001      	ands	r1, r0
    7bd6:	0e00      	lsrs	r0, r0, #24
    7bd8:	9000      	str	r0, [sp, #0]
    7bda:	4806      	ldr	r0, [pc, #24]	; (7bf4 <resolve_cb+0x3c>)
    7bdc:	4d06      	ldr	r5, [pc, #24]	; (7bf8 <resolve_cb+0x40>)
    7bde:	47a8      	blx	r5
			(int)IPV4_BYTE(hostIp, 2), (int)IPV4_BYTE(hostIp, 3));
	printf("Host Name is %s\r\n", hostName);
    7be0:	0021      	movs	r1, r4
    7be2:	4806      	ldr	r0, [pc, #24]	; (7bfc <resolve_cb+0x44>)
    7be4:	47a8      	blx	r5
}
    7be6:	b003      	add	sp, #12
    7be8:	bd30      	pop	{r4, r5, pc}
    7bea:	46c0      	nop			; (mov r8, r8)
    7bec:	20000113 	.word	0x20000113
    7bf0:	200017c4 	.word	0x200017c4
    7bf4:	0001526c 	.word	0x0001526c
    7bf8:	0001198d 	.word	0x0001198d
    7bfc:	00015288 	.word	0x00015288

00007c00 <socket_cb>:
 * \param[in] pvMsg A structure contains notification informations.
 *
 * \return None.
 */
static void socket_cb(SOCKET sock, uint8_t u8Msg, void *pvMsg)
{
    7c00:	b510      	push	{r4, lr}
	switch (u8Msg) {
    7c02:	2906      	cmp	r1, #6
    7c04:	d032      	beq.n	7c6c <socket_cb+0x6c>
    7c06:	2907      	cmp	r1, #7
    7c08:	d01c      	beq.n	7c44 <socket_cb+0x44>
    7c0a:	2905      	cmp	r1, #5
    7c0c:	d140      	bne.n	7c90 <socket_cb+0x90>
		case SOCKET_MSG_CONNECT:
		{
			tstrSocketConnectMsg *pstrConnect = (tstrSocketConnectMsg *)pvMsg;
			if (pstrConnect && pstrConnect->s8Error >= SOCK_ERR_NO_ERROR) {
    7c0e:	2a00      	cmp	r2, #0
    7c10:	d00c      	beq.n	7c2c <socket_cb+0x2c>
    7c12:	7853      	ldrb	r3, [r2, #1]
    7c14:	2b7f      	cmp	r3, #127	; 0x7f
    7c16:	d809      	bhi.n	7c2c <socket_cb+0x2c>
				state = u8Msg;
    7c18:	2205      	movs	r2, #5
    7c1a:	4b1e      	ldr	r3, [pc, #120]	; (7c94 <socket_cb+0x94>)
    7c1c:	701a      	strb	r2, [r3, #0]
				err = 0;
    7c1e:	2200      	movs	r2, #0
    7c20:	4b1d      	ldr	r3, [pc, #116]	; (7c98 <socket_cb+0x98>)
    7c22:	701a      	strb	r2, [r3, #0]
				//recv(sock, gau8SocketTestBuffer, sizeof(gau8SocketTestBuffer),0);	
				printf("Successfully connected.\r\n");
    7c24:	481d      	ldr	r0, [pc, #116]	; (7c9c <socket_cb+0x9c>)
    7c26:	4b1e      	ldr	r3, [pc, #120]	; (7ca0 <socket_cb+0xa0>)
    7c28:	4798      	blx	r3
    7c2a:	e031      	b.n	7c90 <socket_cb+0x90>
				} else {
				state = u8Msg;
    7c2c:	2105      	movs	r1, #5
    7c2e:	4b19      	ldr	r3, [pc, #100]	; (7c94 <socket_cb+0x94>)
    7c30:	7019      	strb	r1, [r3, #0]
				err = -1;
    7c32:	31fa      	adds	r1, #250	; 0xfa
    7c34:	4b18      	ldr	r3, [pc, #96]	; (7c98 <socket_cb+0x98>)
    7c36:	7019      	strb	r1, [r3, #0]
				printf("Connect error! code(%d)\r\n", pstrConnect->s8Error);
    7c38:	2101      	movs	r1, #1
    7c3a:	5651      	ldrsb	r1, [r2, r1]
    7c3c:	4819      	ldr	r0, [pc, #100]	; (7ca4 <socket_cb+0xa4>)
    7c3e:	4b1a      	ldr	r3, [pc, #104]	; (7ca8 <socket_cb+0xa8>)
    7c40:	4798      	blx	r3
    7c42:	e025      	b.n	7c90 <socket_cb+0x90>
		}
		break;
		
		case SOCKET_MSG_SEND:
		{
			sint16 s16SentBytes = *((sint16*)pvMsg);
    7c44:	2300      	movs	r3, #0
    7c46:	5ed1      	ldrsh	r1, [r2, r3]
			state = u8Msg;
    7c48:	2207      	movs	r2, #7
    7c4a:	4b12      	ldr	r3, [pc, #72]	; (7c94 <socket_cb+0x94>)
    7c4c:	701a      	strb	r2, [r3, #0]
			if(s16SentBytes < 0)
    7c4e:	2900      	cmp	r1, #0
    7c50:	da06      	bge.n	7c60 <socket_cb+0x60>
			{
				err = -1;
    7c52:	32f8      	adds	r2, #248	; 0xf8
    7c54:	4b10      	ldr	r3, [pc, #64]	; (7c98 <socket_cb+0x98>)
    7c56:	701a      	strb	r2, [r3, #0]
				printf("Socket send error:%d\r\n",s16SentBytes);
    7c58:	4814      	ldr	r0, [pc, #80]	; (7cac <socket_cb+0xac>)
    7c5a:	4b13      	ldr	r3, [pc, #76]	; (7ca8 <socket_cb+0xa8>)
    7c5c:	4798      	blx	r3
    7c5e:	e017      	b.n	7c90 <socket_cb+0x90>
			}
			else
			{
				err = 0;
    7c60:	2200      	movs	r2, #0
    7c62:	4b0d      	ldr	r3, [pc, #52]	; (7c98 <socket_cb+0x98>)
    7c64:	701a      	strb	r2, [r3, #0]
				sent_bytes = s16SentBytes;
    7c66:	4b12      	ldr	r3, [pc, #72]	; (7cb0 <socket_cb+0xb0>)
    7c68:	6019      	str	r1, [r3, #0]
    7c6a:	e011      	b.n	7c90 <socket_cb+0x90>
		break;
		
		case SOCKET_MSG_RECV:
		{
			tstrSocketRecvMsg *pstrRecv = (tstrSocketRecvMsg *)pvMsg;
			state = u8Msg;
    7c6c:	2106      	movs	r1, #6
    7c6e:	4b09      	ldr	r3, [pc, #36]	; (7c94 <socket_cb+0x94>)
    7c70:	7019      	strb	r1, [r3, #0]
			if (pstrRecv && pstrRecv->s16BufferSize > 0) {
    7c72:	2a00      	cmp	r2, #0
    7c74:	d009      	beq.n	7c8a <socket_cb+0x8a>
    7c76:	2304      	movs	r3, #4
    7c78:	5ed3      	ldrsh	r3, [r2, r3]
    7c7a:	2b00      	cmp	r3, #0
    7c7c:	dd05      	ble.n	7c8a <socket_cb+0x8a>
				received_bytes = pstrRecv->s16BufferSize;
    7c7e:	4a0d      	ldr	r2, [pc, #52]	; (7cb4 <socket_cb+0xb4>)
    7c80:	6013      	str	r3, [r2, #0]
				err = 0;
    7c82:	2200      	movs	r2, #0
    7c84:	4b04      	ldr	r3, [pc, #16]	; (7c98 <socket_cb+0x98>)
    7c86:	701a      	strb	r2, [r3, #0]
    7c88:	e002      	b.n	7c90 <socket_cb+0x90>
			}
			else
			{
				err = -1;
    7c8a:	22ff      	movs	r2, #255	; 0xff
    7c8c:	4b02      	ldr	r3, [pc, #8]	; (7c98 <socket_cb+0x98>)
    7c8e:	701a      	strb	r2, [r3, #0]
		}
		
		default:
		break;
	}
}
    7c90:	bd10      	pop	{r4, pc}
    7c92:	46c0      	nop			; (mov r8, r8)
    7c94:	20000113 	.word	0x20000113
    7c98:	20001204 	.word	0x20001204
    7c9c:	0001529c 	.word	0x0001529c
    7ca0:	00011aad 	.word	0x00011aad
    7ca4:	000152b8 	.word	0x000152b8
    7ca8:	0001198d 	.word	0x0001198d
    7cac:	000152d4 	.word	0x000152d4
    7cb0:	200017bc 	.word	0x200017bc
    7cb4:	200017c0 	.word	0x200017c0

00007cb8 <iot_tls_disconnect>:
		 return len;		 
	 }
	 return (SSL_READ_ERROR);
}

void iot_tls_disconnect(Network *pNetwork) {
    7cb8:	b510      	push	{r4, lr}
	if (pNetwork == NULL || pNetwork->my_socket < 0) {
    7cba:	2800      	cmp	r0, #0
    7cbc:	d005      	beq.n	7cca <iot_tls_disconnect+0x12>
    7cbe:	6800      	ldr	r0, [r0, #0]
    7cc0:	2800      	cmp	r0, #0
    7cc2:	db02      	blt.n	7cca <iot_tls_disconnect+0x12>
		return;
	}
	close(pNetwork->my_socket);
    7cc4:	b240      	sxtb	r0, r0
    7cc6:	4b01      	ldr	r3, [pc, #4]	; (7ccc <iot_tls_disconnect+0x14>)
    7cc8:	4798      	blx	r3
}
    7cca:	bd10      	pop	{r4, pc}
    7ccc:	00007141 	.word	0x00007141

00007cd0 <wait_for_event>:
		break;
	}
}

static void wait_for_event(uint8_t msg)
{
    7cd0:	b570      	push	{r4, r5, r6, lr}
    7cd2:	0006      	movs	r6, r0
	state = -1;
    7cd4:	22ff      	movs	r2, #255	; 0xff
    7cd6:	4b05      	ldr	r3, [pc, #20]	; (7cec <wait_for_event+0x1c>)
    7cd8:	701a      	strb	r2, [r3, #0]
	while(1)
	{
		m2m_wifi_handle_events(NULL);
    7cda:	4d05      	ldr	r5, [pc, #20]	; (7cf0 <wait_for_event+0x20>)
		if(state == msg)
    7cdc:	001c      	movs	r4, r3
static void wait_for_event(uint8_t msg)
{
	state = -1;
	while(1)
	{
		m2m_wifi_handle_events(NULL);
    7cde:	2000      	movs	r0, #0
    7ce0:	47a8      	blx	r5
		if(state == msg)
    7ce2:	2300      	movs	r3, #0
    7ce4:	56e3      	ldrsb	r3, [r4, r3]
    7ce6:	42b3      	cmp	r3, r6
    7ce8:	d1f9      	bne.n	7cde <wait_for_event+0xe>
		{
			return;
		}
	}
}
    7cea:	bd70      	pop	{r4, r5, r6, pc}
    7cec:	20000113 	.word	0x20000113
    7cf0:	000050d5 	.word	0x000050d5

00007cf4 <iot_tls_connect>:
int iot_tls_is_connected(Network *pNetwork) {
	/* Use this to add implementation which can check for physical layer disconnect */
	return 1;
}

int iot_tls_connect(Network *pNetwork, TLSConnectParams params) {
    7cf4:	b084      	sub	sp, #16
    7cf6:	b530      	push	{r4, r5, lr}
    7cf8:	b085      	sub	sp, #20
    7cfa:	0005      	movs	r5, r0
    7cfc:	9109      	str	r1, [sp, #36]	; 0x24
    7cfe:	920a      	str	r2, [sp, #40]	; 0x28
    7d00:	930b      	str	r3, [sp, #44]	; 0x2c
    7d02:	9c0d      	ldr	r4, [sp, #52]	; 0x34
	IoT_Error_t ret = TCP_CONNECT_ERROR;
	struct sockaddr_in addr;
	SOCKET tls_socket = -1;
	
	gethostbyname((uint8_t*)params.pDestinationURL);
    7d04:	980c      	ldr	r0, [sp, #48]	; 0x30
    7d06:	4b20      	ldr	r3, [pc, #128]	; (7d88 <iot_tls_connect+0x94>)
    7d08:	4798      	blx	r3
	wait_for_event(DNS_REQUEST);
    7d0a:	2019      	movs	r0, #25
    7d0c:	4b1f      	ldr	r3, [pc, #124]	; (7d8c <iot_tls_connect+0x98>)
    7d0e:	4798      	blx	r3
	if(gu32HostIp != 0)
    7d10:	4b1f      	ldr	r3, [pc, #124]	; (7d90 <iot_tls_connect+0x9c>)
    7d12:	681b      	ldr	r3, [r3, #0]
    7d14:	2b00      	cmp	r3, #0
    7d16:	d029      	beq.n	7d6c <iot_tls_connect+0x78>
	{
		addr.sin_family = AF_INET;
    7d18:	2202      	movs	r2, #2
    7d1a:	4669      	mov	r1, sp
    7d1c:	800a      	strh	r2, [r1, #0]
		addr.sin_addr.s_addr = gu32HostIp;
    7d1e:	9301      	str	r3, [sp, #4]
		addr.sin_port = _htons(params.DestinationPort);	
    7d20:	0223      	lsls	r3, r4, #8
    7d22:	0424      	lsls	r4, r4, #16
    7d24:	0e24      	lsrs	r4, r4, #24
    7d26:	431c      	orrs	r4, r3
    7d28:	804c      	strh	r4, [r1, #2]
		//sslSetActiveCipherSuites(SSL_ENABLE_ALL_SUITES & ~(SSL_ENABLE_RSA_GCM_SUITES|SSL_ENABLE_DHE_GCM_SUITES
		//							|SSL_ENABLE_ECDHE_GCM_SUITES | SSL_ENABLE_ECDHE_SHA256_SUITES | SSL_ENABLE_ECDHE_SHA_SUITES));
		if ((tls_socket = socket(AF_INET, SOCK_STREAM,SOCKET_FLAGS_SSL)) < 0) 
    7d2a:	3a01      	subs	r2, #1
    7d2c:	2101      	movs	r1, #1
    7d2e:	2002      	movs	r0, #2
    7d30:	4b18      	ldr	r3, [pc, #96]	; (7d94 <iot_tls_connect+0xa0>)
    7d32:	4798      	blx	r3
    7d34:	1e04      	subs	r4, r0, #0
    7d36:	db1c      	blt.n	7d72 <iot_tls_connect+0x7e>
		{
			return SSL_CONNECT_ERROR;
		}
		/* Connect server */
		if(connect(tls_socket, (struct sockaddr *)&addr, sizeof(struct sockaddr_in)) < 0)
    7d38:	2210      	movs	r2, #16
    7d3a:	4669      	mov	r1, sp
    7d3c:	4b16      	ldr	r3, [pc, #88]	; (7d98 <iot_tls_connect+0xa4>)
    7d3e:	4798      	blx	r3
    7d40:	2800      	cmp	r0, #0
    7d42:	da08      	bge.n	7d56 <iot_tls_connect+0x62>
		{
			pNetwork->my_socket = -1;
    7d44:	2301      	movs	r3, #1
    7d46:	425b      	negs	r3, r3
    7d48:	602b      	str	r3, [r5, #0]
			close(tls_socket);
    7d4a:	0020      	movs	r0, r4
    7d4c:	4b13      	ldr	r3, [pc, #76]	; (7d9c <iot_tls_connect+0xa8>)
    7d4e:	4798      	blx	r3
			return SSL_CONNECT_ERROR;
    7d50:	2009      	movs	r0, #9
    7d52:	4240      	negs	r0, r0
    7d54:	e012      	b.n	7d7c <iot_tls_connect+0x88>
		}
		wait_for_event(SOCKET_MSG_CONNECT);
    7d56:	2005      	movs	r0, #5
    7d58:	4b0c      	ldr	r3, [pc, #48]	; (7d8c <iot_tls_connect+0x98>)
    7d5a:	4798      	blx	r3
		if(err == 0)
    7d5c:	4b10      	ldr	r3, [pc, #64]	; (7da0 <iot_tls_connect+0xac>)
    7d5e:	781b      	ldrb	r3, [r3, #0]
    7d60:	b25b      	sxtb	r3, r3
    7d62:	2b00      	cmp	r3, #0
    7d64:	d108      	bne.n	7d78 <iot_tls_connect+0x84>
		{
			pNetwork->my_socket = tls_socket;
    7d66:	602c      	str	r4, [r5, #0]
			ret = NONE_ERROR;
    7d68:	2000      	movs	r0, #0
    7d6a:	e007      	b.n	7d7c <iot_tls_connect+0x88>
			return SSL_CONNECT_ERROR;
		}
	}
	else
	{
		ret = SSL_CONNECT_ERROR;
    7d6c:	2009      	movs	r0, #9
    7d6e:	4240      	negs	r0, r0
	}
	return ret;
    7d70:	e004      	b.n	7d7c <iot_tls_connect+0x88>
		addr.sin_port = _htons(params.DestinationPort);	
		//sslSetActiveCipherSuites(SSL_ENABLE_ALL_SUITES & ~(SSL_ENABLE_RSA_GCM_SUITES|SSL_ENABLE_DHE_GCM_SUITES
		//							|SSL_ENABLE_ECDHE_GCM_SUITES | SSL_ENABLE_ECDHE_SHA256_SUITES | SSL_ENABLE_ECDHE_SHA_SUITES));
		if ((tls_socket = socket(AF_INET, SOCK_STREAM,SOCKET_FLAGS_SSL)) < 0) 
		{
			return SSL_CONNECT_ERROR;
    7d72:	2009      	movs	r0, #9
    7d74:	4240      	negs	r0, r0
    7d76:	e001      	b.n	7d7c <iot_tls_connect+0x88>
			pNetwork->my_socket = tls_socket;
			ret = NONE_ERROR;
		}
		else
		{
			return SSL_CONNECT_ERROR;
    7d78:	2009      	movs	r0, #9
    7d7a:	4240      	negs	r0, r0
	else
	{
		ret = SSL_CONNECT_ERROR;
	}
	return ret;
}
    7d7c:	b005      	add	sp, #20
    7d7e:	bc30      	pop	{r4, r5}
    7d80:	bc08      	pop	{r3}
    7d82:	b004      	add	sp, #16
    7d84:	4718      	bx	r3
    7d86:	46c0      	nop			; (mov r8, r8)
    7d88:	000071dd 	.word	0x000071dd
    7d8c:	00007cd1 	.word	0x00007cd1
    7d90:	200017c4 	.word	0x200017c4
    7d94:	00006cfd 	.word	0x00006cfd
    7d98:	00006f85 	.word	0x00006f85
    7d9c:	00007141 	.word	0x00007141
    7da0:	20001204 	.word	0x20001204

00007da4 <iot_tls_write>:

int iot_tls_write(Network *pNetwork, unsigned char *pMsg, int len, int timeout_ms) {
    7da4:	b510      	push	{r4, lr}
	SOCKET tls_sock = -1;
	int ret = 0, i = 0;

	if (pNetwork == NULL || pMsg == NULL || pNetwork->my_socket < 0
    7da6:	2800      	cmp	r0, #0
    7da8:	d018      	beq.n	7ddc <iot_tls_write+0x38>
    7daa:	2900      	cmp	r1, #0
    7dac:	d019      	beq.n	7de2 <iot_tls_write+0x3e>
    7dae:	6800      	ldr	r0, [r0, #0]
    7db0:	2800      	cmp	r0, #0
    7db2:	db19      	blt.n	7de8 <iot_tls_write+0x44>
	|| timeout_ms == 0) {
    7db4:	2b00      	cmp	r3, #0
    7db6:	d01a      	beq.n	7dee <iot_tls_write+0x4a>
		printf("%02x:",pMsg[i]);
	}
	printf("\n");
#endif
   
	ret = send(tls_sock, pMsg, len, 0);
    7db8:	b292      	uxth	r2, r2
    7dba:	b240      	sxtb	r0, r0
    7dbc:	2300      	movs	r3, #0
    7dbe:	4c10      	ldr	r4, [pc, #64]	; (7e00 <iot_tls_write+0x5c>)
    7dc0:	47a0      	blx	r4
	if( ret < 0)
    7dc2:	2800      	cmp	r0, #0
    7dc4:	db16      	blt.n	7df4 <iot_tls_write+0x50>
	{
		return SSL_WRITE_ERROR;
	}
	wait_for_event(SOCKET_MSG_SEND);
    7dc6:	2007      	movs	r0, #7
    7dc8:	4b0e      	ldr	r3, [pc, #56]	; (7e04 <iot_tls_write+0x60>)
    7dca:	4798      	blx	r3
	if (err == 0) {
    7dcc:	4b0e      	ldr	r3, [pc, #56]	; (7e08 <iot_tls_write+0x64>)
    7dce:	781b      	ldrb	r3, [r3, #0]
    7dd0:	b25b      	sxtb	r3, r3
    7dd2:	2b00      	cmp	r3, #0
    7dd4:	d111      	bne.n	7dfa <iot_tls_write+0x56>
		return (sent_bytes);
    7dd6:	4b0d      	ldr	r3, [pc, #52]	; (7e0c <iot_tls_write+0x68>)
    7dd8:	6818      	ldr	r0, [r3, #0]
    7dda:	e010      	b.n	7dfe <iot_tls_write+0x5a>
	SOCKET tls_sock = -1;
	int ret = 0, i = 0;

	if (pNetwork == NULL || pMsg == NULL || pNetwork->my_socket < 0
	|| timeout_ms == 0) {
		return (NULL_VALUE_ERROR);
    7ddc:	2002      	movs	r0, #2
    7dde:	4240      	negs	r0, r0
    7de0:	e00d      	b.n	7dfe <iot_tls_write+0x5a>
    7de2:	2002      	movs	r0, #2
    7de4:	4240      	negs	r0, r0
    7de6:	e00a      	b.n	7dfe <iot_tls_write+0x5a>
    7de8:	2002      	movs	r0, #2
    7dea:	4240      	negs	r0, r0
    7dec:	e007      	b.n	7dfe <iot_tls_write+0x5a>
    7dee:	2002      	movs	r0, #2
    7df0:	4240      	negs	r0, r0
    7df2:	e004      	b.n	7dfe <iot_tls_write+0x5a>
#endif
   
	ret = send(tls_sock, pMsg, len, 0);
	if( ret < 0)
	{
		return SSL_WRITE_ERROR;
    7df4:	200c      	movs	r0, #12
    7df6:	4240      	negs	r0, r0
    7df8:	e001      	b.n	7dfe <iot_tls_write+0x5a>
	}
	wait_for_event(SOCKET_MSG_SEND);
	if (err == 0) {
		return (sent_bytes);
	}
	return (SSL_WRITE_ERROR);
    7dfa:	200c      	movs	r0, #12
    7dfc:	4240      	negs	r0, r0
}
    7dfe:	bd10      	pop	{r4, pc}
    7e00:	00007015 	.word	0x00007015
    7e04:	00007cd1 	.word	0x00007cd1
    7e08:	20001204 	.word	0x20001204
    7e0c:	200017bc 	.word	0x200017bc

00007e10 <iot_tls_read>:
extern volatile uint32_t ms_ticks;
int iot_tls_read(Network *pNetwork, unsigned char *pMsg, int len, int timeout_ms) {
    7e10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7e12:	000d      	movs	r5, r1
    7e14:	0014      	movs	r4, r2
	 int ret = 0,i = 0;
	 SOCKET tls_socket = NULL;
	 if (pNetwork == NULL || pMsg == NULL || pNetwork->my_socket < 0
    7e16:	2800      	cmp	r0, #0
    7e18:	d007      	beq.n	7e2a <iot_tls_read+0x1a>
    7e1a:	2900      	cmp	r1, #0
    7e1c:	d005      	beq.n	7e2a <iot_tls_read+0x1a>
    7e1e:	6800      	ldr	r0, [r0, #0]
    7e20:	2800      	cmp	r0, #0
    7e22:	db02      	blt.n	7e2a <iot_tls_read+0x1a>
		 	 || timeout_ms == 0) {
    7e24:	2b00      	cmp	r3, #0
    7e26:	d002      	beq.n	7e2e <iot_tls_read+0x1e>
    7e28:	e008      	b.n	7e3c <iot_tls_read+0x2c>
		if(timeout_ms == 0 && received_bytes != 0){
    7e2a:	2b00      	cmp	r3, #0
    7e2c:	d13c      	bne.n	7ea8 <iot_tls_read+0x98>
    7e2e:	4b23      	ldr	r3, [pc, #140]	; (7ebc <iot_tls_read+0xac>)
    7e30:	681b      	ldr	r3, [r3, #0]
			
		}
		else{
			return (NULL_VALUE_ERROR);
    7e32:	2002      	movs	r0, #2
    7e34:	4240      	negs	r0, r0
int iot_tls_read(Network *pNetwork, unsigned char *pMsg, int len, int timeout_ms) {
	 int ret = 0,i = 0;
	 SOCKET tls_socket = NULL;
	 if (pNetwork == NULL || pMsg == NULL || pNetwork->my_socket < 0
		 	 || timeout_ms == 0) {
		if(timeout_ms == 0 && received_bytes != 0){
    7e36:	2b00      	cmp	r3, #0
    7e38:	d03e      	beq.n	7eb8 <iot_tls_read+0xa8>
    7e3a:	e026      	b.n	7e8a <iot_tls_read+0x7a>
		}
		else{
			return (NULL_VALUE_ERROR);
		}
	 }
	 tls_socket = (SOCKET)pNetwork->my_socket;
    7e3c:	b240      	sxtb	r0, r0
	 if(received_bytes == 0)
    7e3e:	4a1f      	ldr	r2, [pc, #124]	; (7ebc <iot_tls_read+0xac>)
    7e40:	6812      	ldr	r2, [r2, #0]
    7e42:	2a00      	cmp	r2, #0
    7e44:	d121      	bne.n	7e8a <iot_tls_read+0x7a>
	 {
		buf_ptr = &gau8SocketTestBuffer;
    7e46:	491e      	ldr	r1, [pc, #120]	; (7ec0 <iot_tls_read+0xb0>)
    7e48:	4a1e      	ldr	r2, [pc, #120]	; (7ec4 <iot_tls_read+0xb4>)
    7e4a:	6011      	str	r1, [r2, #0]
		received_bytes = 0;
    7e4c:	2600      	movs	r6, #0
    7e4e:	4a1b      	ldr	r2, [pc, #108]	; (7ebc <iot_tls_read+0xac>)
    7e50:	6016      	str	r6, [r2, #0]
		ret = recv(tls_socket, gau8SocketTestBuffer,sizeof(gau8SocketTestBuffer), timeout_ms);	
    7e52:	4a1d      	ldr	r2, [pc, #116]	; (7ec8 <iot_tls_read+0xb8>)
    7e54:	4e1d      	ldr	r6, [pc, #116]	; (7ecc <iot_tls_read+0xbc>)
    7e56:	47b0      	blx	r6
		if( ret < 0)
    7e58:	2800      	cmp	r0, #0
    7e5a:	db28      	blt.n	7eae <iot_tls_read+0x9e>
		{
			return SSL_READ_ERROR;
		}
		wait_for_event(SOCKET_MSG_RECV);
    7e5c:	2006      	movs	r0, #6
    7e5e:	4b1c      	ldr	r3, [pc, #112]	; (7ed0 <iot_tls_read+0xc0>)
    7e60:	4798      	blx	r3
		 if (err == -1) {
    7e62:	4b1c      	ldr	r3, [pc, #112]	; (7ed4 <iot_tls_read+0xc4>)
    7e64:	781b      	ldrb	r3, [r3, #0]
    7e66:	b25b      	sxtb	r3, r3
    7e68:	3301      	adds	r3, #1
    7e6a:	d023      	beq.n	7eb4 <iot_tls_read+0xa4>
			 return SSL_READ_ERROR;
		 }
		 else{
			 memcpy(pMsg,buf_ptr,len);
    7e6c:	4f15      	ldr	r7, [pc, #84]	; (7ec4 <iot_tls_read+0xb4>)
    7e6e:	683e      	ldr	r6, [r7, #0]
    7e70:	0022      	movs	r2, r4
    7e72:	0031      	movs	r1, r6
    7e74:	0028      	movs	r0, r5
    7e76:	4b18      	ldr	r3, [pc, #96]	; (7ed8 <iot_tls_read+0xc8>)
    7e78:	4798      	blx	r3
			 received_bytes -= len;
    7e7a:	4a10      	ldr	r2, [pc, #64]	; (7ebc <iot_tls_read+0xac>)
    7e7c:	6813      	ldr	r3, [r2, #0]
    7e7e:	1b1b      	subs	r3, r3, r4
    7e80:	6013      	str	r3, [r2, #0]
			 buf_ptr += len;
    7e82:	1936      	adds	r6, r6, r4
    7e84:	603e      	str	r6, [r7, #0]
				  printf("%02x:",pMsg[i]);
			  }
			  printf("\n");
#endif
			 
			 return len;
    7e86:	0020      	movs	r0, r4
    7e88:	e016      	b.n	7eb8 <iot_tls_read+0xa8>
		 }
	 }
	 else{
		 memcpy(pMsg,buf_ptr,len);
    7e8a:	4f0e      	ldr	r7, [pc, #56]	; (7ec4 <iot_tls_read+0xb4>)
    7e8c:	683e      	ldr	r6, [r7, #0]
    7e8e:	0022      	movs	r2, r4
    7e90:	0031      	movs	r1, r6
    7e92:	0028      	movs	r0, r5
    7e94:	4b10      	ldr	r3, [pc, #64]	; (7ed8 <iot_tls_read+0xc8>)
    7e96:	4798      	blx	r3
		 received_bytes -= len;
    7e98:	4a08      	ldr	r2, [pc, #32]	; (7ebc <iot_tls_read+0xac>)
    7e9a:	6813      	ldr	r3, [r2, #0]
    7e9c:	1b1b      	subs	r3, r3, r4
    7e9e:	6013      	str	r3, [r2, #0]
		 buf_ptr += len;
    7ea0:	1936      	adds	r6, r6, r4
    7ea2:	603e      	str	r6, [r7, #0]
			  printf("%02x:",pMsg[i]);
		  }
		  printf("\n");
#endif
		 
		 return len;		 
    7ea4:	0020      	movs	r0, r4
    7ea6:	e007      	b.n	7eb8 <iot_tls_read+0xa8>
		 	 || timeout_ms == 0) {
		if(timeout_ms == 0 && received_bytes != 0){
			
		}
		else{
			return (NULL_VALUE_ERROR);
    7ea8:	2002      	movs	r0, #2
    7eaa:	4240      	negs	r0, r0
    7eac:	e004      	b.n	7eb8 <iot_tls_read+0xa8>
		buf_ptr = &gau8SocketTestBuffer;
		received_bytes = 0;
		ret = recv(tls_socket, gau8SocketTestBuffer,sizeof(gau8SocketTestBuffer), timeout_ms);	
		if( ret < 0)
		{
			return SSL_READ_ERROR;
    7eae:	2014      	movs	r0, #20
    7eb0:	4240      	negs	r0, r0
    7eb2:	e001      	b.n	7eb8 <iot_tls_read+0xa8>
		}
		wait_for_event(SOCKET_MSG_RECV);
		 if (err == -1) {
			 return SSL_READ_ERROR;
    7eb4:	2014      	movs	r0, #20
    7eb6:	4240      	negs	r0, r0
#endif
		 
		 return len;		 
	 }
	 return (SSL_READ_ERROR);
}
    7eb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7eba:	46c0      	nop			; (mov r8, r8)
    7ebc:	200017c0 	.word	0x200017c0
    7ec0:	20001208 	.word	0x20001208
    7ec4:	20000114 	.word	0x20000114
    7ec8:	000005b4 	.word	0x000005b4
    7ecc:	000070ad 	.word	0x000070ad
    7ed0:	00007cd1 	.word	0x00007cd1
    7ed4:	20001204 	.word	0x20001204
    7ed8:	00011833 	.word	0x00011833

00007edc <iot_tls_init>:
			return;
		}
	}
}

int iot_tls_init(Network *pNetwork) {
    7edc:	b510      	push	{r4, lr}
	
	if(pNetwork == NULL) {
    7ede:	2800      	cmp	r0, #0
    7ee0:	d016      	beq.n	7f10 <iot_tls_init+0x34>
		return NULL_VALUE_ERROR;
	}
	
	pNetwork->my_socket = -1;
    7ee2:	2301      	movs	r3, #1
    7ee4:	425b      	negs	r3, r3
    7ee6:	6003      	str	r3, [r0, #0]
	pNetwork->connect = iot_tls_connect;
    7ee8:	4b0b      	ldr	r3, [pc, #44]	; (7f18 <iot_tls_init+0x3c>)
    7eea:	6043      	str	r3, [r0, #4]
	pNetwork->mqttread = iot_tls_read;
    7eec:	4b0b      	ldr	r3, [pc, #44]	; (7f1c <iot_tls_init+0x40>)
    7eee:	6083      	str	r3, [r0, #8]
	pNetwork->mqttwrite = iot_tls_write;
    7ef0:	4b0b      	ldr	r3, [pc, #44]	; (7f20 <iot_tls_init+0x44>)
    7ef2:	60c3      	str	r3, [r0, #12]
	pNetwork->disconnect = iot_tls_disconnect;
    7ef4:	4b0b      	ldr	r3, [pc, #44]	; (7f24 <iot_tls_init+0x48>)
    7ef6:	6103      	str	r3, [r0, #16]
	pNetwork->isConnected = iot_tls_is_connected;
    7ef8:	4b0b      	ldr	r3, [pc, #44]	; (7f28 <iot_tls_init+0x4c>)
    7efa:	6143      	str	r3, [r0, #20]
	pNetwork->destroy = iot_tls_destroy;
    7efc:	4b0b      	ldr	r3, [pc, #44]	; (7f2c <iot_tls_init+0x50>)
    7efe:	6183      	str	r3, [r0, #24]
	
	/* Initialize Socket module */
	socketInit();
    7f00:	4b0b      	ldr	r3, [pc, #44]	; (7f30 <iot_tls_init+0x54>)
    7f02:	4798      	blx	r3
	registerSocketCallback(socket_cb, resolve_cb);
    7f04:	490b      	ldr	r1, [pc, #44]	; (7f34 <iot_tls_init+0x58>)
    7f06:	480c      	ldr	r0, [pc, #48]	; (7f38 <iot_tls_init+0x5c>)
    7f08:	4b0c      	ldr	r3, [pc, #48]	; (7f3c <iot_tls_init+0x60>)
    7f0a:	4798      	blx	r3

	
	return NONE_ERROR;
    7f0c:	2000      	movs	r0, #0
    7f0e:	e001      	b.n	7f14 <iot_tls_init+0x38>
}

int iot_tls_init(Network *pNetwork) {
	
	if(pNetwork == NULL) {
		return NULL_VALUE_ERROR;
    7f10:	2002      	movs	r0, #2
    7f12:	4240      	negs	r0, r0
	socketInit();
	registerSocketCallback(socket_cb, resolve_cb);

	
	return NONE_ERROR;
}
    7f14:	bd10      	pop	{r4, pc}
    7f16:	46c0      	nop			; (mov r8, r8)
    7f18:	00007cf5 	.word	0x00007cf5
    7f1c:	00007e11 	.word	0x00007e11
    7f20:	00007da5 	.word	0x00007da5
    7f24:	00007cb9 	.word	0x00007cb9
    7f28:	00007b9d 	.word	0x00007b9d
    7f2c:	00007ba1 	.word	0x00007ba1
    7f30:	00006ca5 	.word	0x00006ca5
    7f34:	00007bb9 	.word	0x00007bb9
    7f38:	00007c01 	.word	0x00007c01
    7f3c:	00006ce9 	.word	0x00006ce9

00007f40 <getNextPacketId>:
    md->topicName = aTopicName;
    md->message = aMessage;
    md->applicationHandler = applicationHandler;
}

uint16_t getNextPacketId(Client *c) {
    7f40:	0002      	movs	r2, r0
    return c->nextPacketId = (uint16_t)((MAX_PACKET_ID == c->nextPacketId) ? 1 : (c->nextPacketId + 1));
    7f42:	8883      	ldrh	r3, [r0, #4]
    7f44:	4904      	ldr	r1, [pc, #16]	; (7f58 <getNextPacketId+0x18>)
    7f46:	428b      	cmp	r3, r1
    7f48:	d002      	beq.n	7f50 <getNextPacketId+0x10>
    7f4a:	3301      	adds	r3, #1
    7f4c:	b298      	uxth	r0, r3
    7f4e:	e000      	b.n	7f52 <getNextPacketId+0x12>
    7f50:	2001      	movs	r0, #1
    7f52:	8090      	strh	r0, [r2, #4]
}
    7f54:	4770      	bx	lr
    7f56:	46c0      	nop			; (mov r8, r8)
    7f58:	0000ffff 	.word	0x0000ffff

00007f5c <sendPacket>:

MQTTReturnCode sendPacket(Client *c, uint32_t length, Timer *timer) {
    7f5c:	b5f0      	push	{r4, r5, r6, r7, lr}
    7f5e:	465f      	mov	r7, fp
    7f60:	4656      	mov	r6, sl
    7f62:	464d      	mov	r5, r9
    7f64:	4644      	mov	r4, r8
    7f66:	b4f0      	push	{r4, r5, r6, r7}
    7f68:	b083      	sub	sp, #12
    7f6a:	0006      	movs	r6, r0
    7f6c:	000f      	movs	r7, r1
    7f6e:	9201      	str	r2, [sp, #4]
    if(NULL == c || NULL == timer) {
    7f70:	2800      	cmp	r0, #0
    7f72:	d02b      	beq.n	7fcc <sendPacket+0x70>
    7f74:	2a00      	cmp	r2, #0
    7f76:	d02c      	beq.n	7fd2 <sendPacket+0x76>
    }

    int32_t sentLen = 0;
    uint32_t sent = 0;

    if(length >= c->bufSize) {
    7f78:	6983      	ldr	r3, [r0, #24]
    7f7a:	428b      	cmp	r3, r1
    7f7c:	d92c      	bls.n	7fd8 <sendPacket+0x7c>
    	return MQTTPACKET_BUFFER_TOO_SHORT;
    }

    while(sent < length && !expired(timer)) {
    7f7e:	2400      	movs	r4, #0
    7f80:	2900      	cmp	r1, #0
    7f82:	d113      	bne.n	7fac <sendPacket+0x50>
    7f84:	e01c      	b.n	7fc0 <sendPacket+0x64>
        sentLen = c->networkStack.mqttwrite(&(c->networkStack), &c->buf[sent], (int)length, left_ms(timer));
    7f86:	465b      	mov	r3, fp
    7f88:	58f3      	ldr	r3, [r6, r3]
    7f8a:	4698      	mov	r8, r3
    7f8c:	6a33      	ldr	r3, [r6, #32]
    7f8e:	191d      	adds	r5, r3, r4
    7f90:	9801      	ldr	r0, [sp, #4]
    7f92:	47d0      	blx	sl
    7f94:	0003      	movs	r3, r0
    7f96:	0030      	movs	r0, r6
    7f98:	3098      	adds	r0, #152	; 0x98
    7f9a:	003a      	movs	r2, r7
    7f9c:	0029      	movs	r1, r5
    7f9e:	47c0      	blx	r8
        if(sentLen < 0) {
    7fa0:	2800      	cmp	r0, #0
    7fa2:	db0d      	blt.n	7fc0 <sendPacket+0x64>
            /* there was an error writing the data */
            break;
        }
        sent = sent + (uint32_t)sentLen;
    7fa4:	1824      	adds	r4, r4, r0

    if(length >= c->bufSize) {
    	return MQTTPACKET_BUFFER_TOO_SHORT;
    }

    while(sent < length && !expired(timer)) {
    7fa6:	42a7      	cmp	r7, r4
    7fa8:	d806      	bhi.n	7fb8 <sendPacket+0x5c>
    7faa:	e009      	b.n	7fc0 <sendPacket+0x64>
    7fac:	4b0f      	ldr	r3, [pc, #60]	; (7fec <sendPacket+0x90>)
    7fae:	4699      	mov	r9, r3
        sentLen = c->networkStack.mqttwrite(&(c->networkStack), &c->buf[sent], (int)length, left_ms(timer));
    7fb0:	23a4      	movs	r3, #164	; 0xa4
    7fb2:	469b      	mov	fp, r3
    7fb4:	4b0e      	ldr	r3, [pc, #56]	; (7ff0 <sendPacket+0x94>)
    7fb6:	469a      	mov	sl, r3

    if(length >= c->bufSize) {
    	return MQTTPACKET_BUFFER_TOO_SHORT;
    }

    while(sent < length && !expired(timer)) {
    7fb8:	9801      	ldr	r0, [sp, #4]
    7fba:	47c8      	blx	r9
    7fbc:	2800      	cmp	r0, #0
    7fbe:	d0e2      	beq.n	7f86 <sendPacket+0x2a>
            break;
        }
        sent = sent + (uint32_t)sentLen;
    }

    if(sent == length) {
    7fc0:	1b38      	subs	r0, r7, r4
    7fc2:	0004      	movs	r4, r0
    7fc4:	1e60      	subs	r0, r4, #1
    7fc6:	4184      	sbcs	r4, r0
    7fc8:	4260      	negs	r0, r4
    7fca:	e007      	b.n	7fdc <sendPacket+0x80>
    return c->nextPacketId = (uint16_t)((MAX_PACKET_ID == c->nextPacketId) ? 1 : (c->nextPacketId + 1));
}

MQTTReturnCode sendPacket(Client *c, uint32_t length, Timer *timer) {
    if(NULL == c || NULL == timer) {
        return MQTT_NULL_VALUE_ERROR;
    7fcc:	2006      	movs	r0, #6
    7fce:	4240      	negs	r0, r0
    7fd0:	e004      	b.n	7fdc <sendPacket+0x80>
    7fd2:	2006      	movs	r0, #6
    7fd4:	4240      	negs	r0, r0
    7fd6:	e001      	b.n	7fdc <sendPacket+0x80>

    int32_t sentLen = 0;
    uint32_t sent = 0;

    if(length >= c->bufSize) {
    	return MQTTPACKET_BUFFER_TOO_SHORT;
    7fd8:	2009      	movs	r0, #9
    7fda:	4240      	negs	r0, r0
        //countdown(&c->pingTimer, c->keepAliveInterval);
        return SUCCESS;
    }

    return FAILURE;
}
    7fdc:	b003      	add	sp, #12
    7fde:	bc3c      	pop	{r2, r3, r4, r5}
    7fe0:	4690      	mov	r8, r2
    7fe2:	4699      	mov	r9, r3
    7fe4:	46a2      	mov	sl, r4
    7fe6:	46ab      	mov	fp, r5
    7fe8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7fea:	46c0      	nop			; (mov r8, r8)
    7fec:	00007b15 	.word	0x00007b15
    7ff0:	00007b79 	.word	0x00007b79

00007ff4 <copyMQTTConnectData>:

void copyMQTTConnectData(MQTTPacket_connectData *destination, MQTTPacket_connectData *source) {
    if(NULL == destination || NULL == source) {
    7ff4:	2800      	cmp	r0, #0
    7ff6:	d019      	beq.n	802c <copyMQTTConnectData+0x38>
    7ff8:	2900      	cmp	r1, #0
    7ffa:	d017      	beq.n	802c <copyMQTTConnectData+0x38>
        return;
    }
    destination->willFlag = source->willFlag;
    7ffc:	7dcb      	ldrb	r3, [r1, #23]
    7ffe:	75c3      	strb	r3, [r0, #23]
    destination->MQTTVersion = source->MQTTVersion;
    8000:	794b      	ldrb	r3, [r1, #5]
    8002:	7143      	strb	r3, [r0, #5]
    destination->clientID.cstring = source->clientID.cstring;
    8004:	688b      	ldr	r3, [r1, #8]
    8006:	6083      	str	r3, [r0, #8]
    destination->username.cstring = source->username.cstring;
    8008:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
    800a:	63c3      	str	r3, [r0, #60]	; 0x3c
    destination->password.cstring = source->password.cstring;
    800c:	6c8b      	ldr	r3, [r1, #72]	; 0x48
    800e:	6483      	str	r3, [r0, #72]	; 0x48
    destination->will.topicName.cstring = source->will.topicName.cstring;
    8010:	6a0b      	ldr	r3, [r1, #32]
    8012:	6203      	str	r3, [r0, #32]
    destination->will.message.cstring = source->will.message.cstring;
    8014:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    8016:	62c3      	str	r3, [r0, #44]	; 0x2c
    destination->will.qos = source->will.qos;
    8018:	2339      	movs	r3, #57	; 0x39
    801a:	5cca      	ldrb	r2, [r1, r3]
    801c:	54c2      	strb	r2, [r0, r3]
    destination->will.retained = source->will.retained;
    801e:	3b01      	subs	r3, #1
    8020:	5cca      	ldrb	r2, [r1, r3]
    8022:	54c2      	strb	r2, [r0, r3]
    destination->keepAliveInterval = source->keepAliveInterval;
    8024:	8a8b      	ldrh	r3, [r1, #20]
    8026:	8283      	strh	r3, [r0, #20]
    destination->cleansession = source->cleansession;
    8028:	7d8b      	ldrb	r3, [r1, #22]
    802a:	7583      	strb	r3, [r0, #22]
}
    802c:	4770      	bx	lr
    802e:	46c0      	nop			; (mov r8, r8)

00008030 <MQTTClient>:

MQTTReturnCode MQTTClient(Client *c, uint32_t commandTimeoutMs,
                          unsigned char *buf, size_t bufSize, unsigned char *readbuf,
                          size_t readBufSize, uint8_t enableAutoReconnect,
                          networkInitHandler_t networkInitHandler,
                          TLSConnectParams *tlsConnectParams) {
    8030:	b5f0      	push	{r4, r5, r6, r7, lr}
    8032:	464f      	mov	r7, r9
    8034:	4646      	mov	r6, r8
    8036:	b4c0      	push	{r6, r7}
    8038:	b097      	sub	sp, #92	; 0x5c
    803a:	0004      	movs	r4, r0
    803c:	4689      	mov	r9, r1
    803e:	0016      	movs	r6, r2
    8040:	4698      	mov	r8, r3
    8042:	ab20      	add	r3, sp, #128	; 0x80
    8044:	781f      	ldrb	r7, [r3, #0]
    8046:	9d22      	ldr	r5, [sp, #136]	; 0x88
    if(NULL == c || NULL == tlsConnectParams || NULL == buf || NULL == readbuf
    8048:	2800      	cmp	r0, #0
    804a:	d050      	beq.n	80ee <MQTTClient+0xbe>
    804c:	2d00      	cmp	r5, #0
    804e:	d051      	beq.n	80f4 <MQTTClient+0xc4>
    8050:	2a00      	cmp	r2, #0
    8052:	d052      	beq.n	80fa <MQTTClient+0xca>
    8054:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    8056:	2b00      	cmp	r3, #0
    8058:	d052      	beq.n	8100 <MQTTClient+0xd0>
       || NULL == networkInitHandler) {
    805a:	9b21      	ldr	r3, [sp, #132]	; 0x84
    805c:	2b00      	cmp	r3, #0
    805e:	d052      	beq.n	8106 <MQTTClient+0xd6>
        return MQTT_NULL_VALUE_ERROR;
    }

    uint32_t i;
    MQTTPacket_connectData default_options = MQTTPacket_connectData_initializer;
    8060:	2254      	movs	r2, #84	; 0x54
    8062:	492c      	ldr	r1, [pc, #176]	; (8114 <MQTTClient+0xe4>)
    8064:	a801      	add	r0, sp, #4
    8066:	4b2c      	ldr	r3, [pc, #176]	; (8118 <MQTTClient+0xe8>)
    8068:	4798      	blx	r3
    806a:	0023      	movs	r3, r4
    806c:	33c4      	adds	r3, #196	; 0xc4
    806e:	0021      	movs	r1, r4
    8070:	3115      	adds	r1, #21
    8072:	31ff      	adds	r1, #255	; 0xff

    for(i = 0; i < MAX_MESSAGE_HANDLERS; ++i) {
        c->messageHandlers[i].topicFilter = NULL;
    8074:	2200      	movs	r2, #0
    8076:	601a      	str	r2, [r3, #0]
        c->messageHandlers[i].fp = NULL;
    8078:	605a      	str	r2, [r3, #4]
        c->messageHandlers[i].applicationHandler = NULL;
    807a:	609a      	str	r2, [r3, #8]
        c->messageHandlers[i].qos = 0;
    807c:	731a      	strb	r2, [r3, #12]
    807e:	3310      	adds	r3, #16
    }

    uint32_t i;
    MQTTPacket_connectData default_options = MQTTPacket_connectData_initializer;

    for(i = 0; i < MAX_MESSAGE_HANDLERS; ++i) {
    8080:	428b      	cmp	r3, r1
    8082:	d1f8      	bne.n	8076 <MQTTClient+0x46>
        c->messageHandlers[i].fp = NULL;
        c->messageHandlers[i].applicationHandler = NULL;
        c->messageHandlers[i].qos = 0;
    }

    c->commandTimeoutMs = commandTimeoutMs;
    8084:	464b      	mov	r3, r9
    8086:	60a3      	str	r3, [r4, #8]
    c->buf = buf;
    8088:	6226      	str	r6, [r4, #32]
    c->bufSize = bufSize;
    808a:	4643      	mov	r3, r8
    808c:	61a3      	str	r3, [r4, #24]
    c->readbuf = readbuf;
    808e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    8090:	6263      	str	r3, [r4, #36]	; 0x24
    c->readBufSize = readBufSize;
    8092:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    8094:	61e3      	str	r3, [r4, #28]
    c->isConnected = 0;
    8096:	2300      	movs	r3, #0
    8098:	7023      	strb	r3, [r4, #0]
    c->isPingOutstanding = 0;
    809a:	70a3      	strb	r3, [r4, #2]
    c->wasManuallyDisconnected = 0;
    809c:	7063      	strb	r3, [r4, #1]
    c->counterNetworkDisconnected = 0;
    809e:	6163      	str	r3, [r4, #20]
    c->isAutoReconnectEnabled = enableAutoReconnect;
    80a0:	70e7      	strb	r7, [r4, #3]
    c->defaultMessageHandler = NULL;
    80a2:	228a      	movs	r2, #138	; 0x8a
    80a4:	0052      	lsls	r2, r2, #1
    80a6:	50a3      	str	r3, [r4, r2]
    c->disconnectHandler = NULL;
    80a8:	3204      	adds	r2, #4
    80aa:	50a3      	str	r3, [r4, r2]
    copyMQTTConnectData(&(c->options), &default_options);
    80ac:	0020      	movs	r0, r4
    80ae:	3044      	adds	r0, #68	; 0x44
    80b0:	a901      	add	r1, sp, #4
    80b2:	4b1a      	ldr	r3, [pc, #104]	; (811c <MQTTClient+0xec>)
    80b4:	4798      	blx	r3

    c->networkInitHandler = networkInitHandler;
    80b6:	238e      	movs	r3, #142	; 0x8e
    80b8:	005b      	lsls	r3, r3, #1
    80ba:	9a21      	ldr	r2, [sp, #132]	; 0x84
    80bc:	50e2      	str	r2, [r4, r3]

    c->tlsConnectParams.DestinationPort = tlsConnectParams->DestinationPort;
    80be:	692b      	ldr	r3, [r5, #16]
    80c0:	63a3      	str	r3, [r4, #56]	; 0x38
    c->tlsConnectParams.pDestinationURL = tlsConnectParams->pDestinationURL;
    80c2:	68eb      	ldr	r3, [r5, #12]
    80c4:	6363      	str	r3, [r4, #52]	; 0x34
    c->tlsConnectParams.pDeviceCertLocation = tlsConnectParams->pDeviceCertLocation;
    80c6:	686b      	ldr	r3, [r5, #4]
    80c8:	62e3      	str	r3, [r4, #44]	; 0x2c
    c->tlsConnectParams.pDevicePrivateKeyLocation = tlsConnectParams->pDevicePrivateKeyLocation;
    80ca:	68ab      	ldr	r3, [r5, #8]
    80cc:	6323      	str	r3, [r4, #48]	; 0x30
    c->tlsConnectParams.pRootCALocation = tlsConnectParams->pRootCALocation;
    80ce:	682b      	ldr	r3, [r5, #0]
    80d0:	62a3      	str	r3, [r4, #40]	; 0x28
    c->tlsConnectParams.timeout_ms = tlsConnectParams->timeout_ms;
    80d2:	696b      	ldr	r3, [r5, #20]
    80d4:	63e3      	str	r3, [r4, #60]	; 0x3c
    c->tlsConnectParams.ServerVerificationFlag = tlsConnectParams->ServerVerificationFlag;
    80d6:	7e2a      	ldrb	r2, [r5, #24]
    80d8:	2340      	movs	r3, #64	; 0x40
    80da:	54e2      	strb	r2, [r4, r3]

    InitTimer(&(c->pingTimer));
    80dc:	0020      	movs	r0, r4
    80de:	30b4      	adds	r0, #180	; 0xb4
    80e0:	4d0f      	ldr	r5, [pc, #60]	; (8120 <MQTTClient+0xf0>)
    80e2:	47a8      	blx	r5
    InitTimer(&(c->reconnectDelayTimer));
    80e4:	0020      	movs	r0, r4
    80e6:	30bc      	adds	r0, #188	; 0xbc
    80e8:	47a8      	blx	r5

    return SUCCESS;
    80ea:	2000      	movs	r0, #0
    80ec:	e00d      	b.n	810a <MQTTClient+0xda>
                          size_t readBufSize, uint8_t enableAutoReconnect,
                          networkInitHandler_t networkInitHandler,
                          TLSConnectParams *tlsConnectParams) {
    if(NULL == c || NULL == tlsConnectParams || NULL == buf || NULL == readbuf
       || NULL == networkInitHandler) {
        return MQTT_NULL_VALUE_ERROR;
    80ee:	2006      	movs	r0, #6
    80f0:	4240      	negs	r0, r0
    80f2:	e00a      	b.n	810a <MQTTClient+0xda>
    80f4:	2006      	movs	r0, #6
    80f6:	4240      	negs	r0, r0
    80f8:	e007      	b.n	810a <MQTTClient+0xda>
    80fa:	2006      	movs	r0, #6
    80fc:	4240      	negs	r0, r0
    80fe:	e004      	b.n	810a <MQTTClient+0xda>
    8100:	2006      	movs	r0, #6
    8102:	4240      	negs	r0, r0
    8104:	e001      	b.n	810a <MQTTClient+0xda>
    8106:	2006      	movs	r0, #6
    8108:	4240      	negs	r0, r0

    InitTimer(&(c->pingTimer));
    InitTimer(&(c->reconnectDelayTimer));

    return SUCCESS;
}
    810a:	b017      	add	sp, #92	; 0x5c
    810c:	bc0c      	pop	{r2, r3}
    810e:	4690      	mov	r8, r2
    8110:	4699      	mov	r9, r3
    8112:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8114:	00015324 	.word	0x00015324
    8118:	00011833 	.word	0x00011833
    811c:	00007ff5 	.word	0x00007ff5
    8120:	00007b95 	.word	0x00007b95

00008124 <decodePacket>:

MQTTReturnCode decodePacket(Client *c, uint32_t *value, uint32_t timeout) {
    8124:	b5f0      	push	{r4, r5, r6, r7, lr}
    8126:	464f      	mov	r7, r9
    8128:	4646      	mov	r6, r8
    812a:	b4c0      	push	{r6, r7}
    812c:	b085      	sub	sp, #20
    812e:	1e07      	subs	r7, r0, #0
    8130:	4689      	mov	r9, r1
    8132:	9200      	str	r2, [sp, #0]
    if(NULL == c || NULL == value) {
    8134:	d02e      	beq.n	8194 <decodePacket+0x70>
    8136:	2900      	cmp	r1, #0
    8138:	d02f      	beq.n	819a <decodePacket+0x76>
    unsigned char i;
    uint32_t multiplier = 1;
    uint32_t len = 0;
    const uint32_t MAX_NO_OF_REMAINING_LENGTH_BYTES = 4;

    *value = 0;
    813a:	2300      	movs	r3, #0
    813c:	600b      	str	r3, [r1, #0]
    813e:	3304      	adds	r3, #4
    8140:	4698      	mov	r8, r3
    if(NULL == c || NULL == value) {
        return MQTT_NULL_VALUE_ERROR;
    }

    unsigned char i;
    uint32_t multiplier = 1;
    8142:	2401      	movs	r4, #1
        if(++len > MAX_NO_OF_REMAINING_LENGTH_BYTES) {
            /* bad data */
            return MQTTPACKET_READ_ERROR;
        }

        if((c->networkStack.mqttread(&(c->networkStack), &i, 1, (int)timeout)) != 1) {
    8144:	3394      	adds	r3, #148	; 0x94
    8146:	469c      	mov	ip, r3
    8148:	4484      	add	ip, r0
    814a:	4663      	mov	r3, ip
    814c:	9301      	str	r3, [sp, #4]
    814e:	26a0      	movs	r6, #160	; 0xa0
    8150:	e006      	b.n	8160 <decodePacket+0x3c>
    8152:	2301      	movs	r3, #1
    8154:	425b      	negs	r3, r3
    8156:	469c      	mov	ip, r3
    8158:	44e0      	add	r8, ip
    const uint32_t MAX_NO_OF_REMAINING_LENGTH_BYTES = 4;

    *value = 0;

    do {
        if(++len > MAX_NO_OF_REMAINING_LENGTH_BYTES) {
    815a:	4643      	mov	r3, r8
    815c:	2b00      	cmp	r3, #0
    815e:	d01f      	beq.n	81a0 <decodePacket+0x7c>
            /* bad data */
            return MQTTPACKET_READ_ERROR;
        }

        if((c->networkStack.mqttread(&(c->networkStack), &i, 1, (int)timeout)) != 1) {
    8160:	9b00      	ldr	r3, [sp, #0]
    8162:	2201      	movs	r2, #1
    8164:	a902      	add	r1, sp, #8
    8166:	3107      	adds	r1, #7
    8168:	9801      	ldr	r0, [sp, #4]
    816a:	59bd      	ldr	r5, [r7, r6]
    816c:	47a8      	blx	r5
    816e:	2801      	cmp	r0, #1
    8170:	d119      	bne.n	81a6 <decodePacket+0x82>
            /* The value argument is the important value. len is just used temporarily
             * and never used by the calling function for anything else */
            return FAILURE;
        }

        *value += ((i & 127) * multiplier);
    8172:	ab02      	add	r3, sp, #8
    8174:	79da      	ldrb	r2, [r3, #7]
    8176:	237f      	movs	r3, #127	; 0x7f
    8178:	4013      	ands	r3, r2
    817a:	4363      	muls	r3, r4
    817c:	4649      	mov	r1, r9
    817e:	6809      	ldr	r1, [r1, #0]
    8180:	468c      	mov	ip, r1
    8182:	4463      	add	r3, ip
    8184:	4649      	mov	r1, r9
    8186:	600b      	str	r3, [r1, #0]
        multiplier *= 128;
    8188:	01e4      	lsls	r4, r4, #7
    }while((i & 128) != 0);
    818a:	b252      	sxtb	r2, r2
    818c:	2a00      	cmp	r2, #0
    818e:	dbe0      	blt.n	8152 <decodePacket+0x2e>

    /* The value argument is the important value. len is just used temporarily
     * and never used by the calling function for anything else */
    return SUCCESS;
    8190:	2000      	movs	r0, #0
    8192:	e00a      	b.n	81aa <decodePacket+0x86>
    return SUCCESS;
}

MQTTReturnCode decodePacket(Client *c, uint32_t *value, uint32_t timeout) {
    if(NULL == c || NULL == value) {
        return MQTT_NULL_VALUE_ERROR;
    8194:	2006      	movs	r0, #6
    8196:	4240      	negs	r0, r0
    8198:	e007      	b.n	81aa <decodePacket+0x86>
    819a:	2006      	movs	r0, #6
    819c:	4240      	negs	r0, r0
    819e:	e004      	b.n	81aa <decodePacket+0x86>
    *value = 0;

    do {
        if(++len > MAX_NO_OF_REMAINING_LENGTH_BYTES) {
            /* bad data */
            return MQTTPACKET_READ_ERROR;
    81a0:	200a      	movs	r0, #10
    81a2:	4240      	negs	r0, r0
    81a4:	e001      	b.n	81aa <decodePacket+0x86>
        }

        if((c->networkStack.mqttread(&(c->networkStack), &i, 1, (int)timeout)) != 1) {
            /* The value argument is the important value. len is just used temporarily
             * and never used by the calling function for anything else */
            return FAILURE;
    81a6:	2001      	movs	r0, #1
    81a8:	4240      	negs	r0, r0
    }while((i & 128) != 0);

    /* The value argument is the important value. len is just used temporarily
     * and never used by the calling function for anything else */
    return SUCCESS;
}
    81aa:	b005      	add	sp, #20
    81ac:	bc0c      	pop	{r2, r3}
    81ae:	4690      	mov	r8, r2
    81b0:	4699      	mov	r9, r3
    81b2:	bdf0      	pop	{r4, r5, r6, r7, pc}

000081b4 <readPacket>:

MQTTReturnCode readPacket(Client *c, Timer *timer, uint8_t *packet_type) {
    81b4:	b5f0      	push	{r4, r5, r6, r7, lr}
    81b6:	465f      	mov	r7, fp
    81b8:	4656      	mov	r6, sl
    81ba:	464d      	mov	r5, r9
    81bc:	4644      	mov	r4, r8
    81be:	b4f0      	push	{r4, r5, r6, r7}
    81c0:	b085      	sub	sp, #20
    81c2:	0004      	movs	r4, r0
    81c4:	000d      	movs	r5, r1
    81c6:	9201      	str	r2, [sp, #4]
    if(NULL == c || NULL == timer) {
    81c8:	2800      	cmp	r0, #0
    81ca:	d064      	beq.n	8296 <readPacket+0xe2>
    81cc:	2900      	cmp	r1, #0
    81ce:	d065      	beq.n	829c <readPacket+0xe8>
        return MQTT_NULL_VALUE_ERROR;
    }

    MQTTHeader header = {0};
    uint32_t len = 0;
    uint32_t rem_len = 0;
    81d0:	2300      	movs	r3, #0
    81d2:	9303      	str	r3, [sp, #12]
    uint32_t total_bytes_read = 0;
    uint32_t bytes_to_be_read = 0;
	int32_t ret_val = 0;

    /* 1. read the header byte.  This has the packet type in it */
    if(1 != c->networkStack.mqttread(&(c->networkStack), c->readbuf, 1, left_ms(timer))) {
    81d4:	33a0      	adds	r3, #160	; 0xa0
    81d6:	58c7      	ldr	r7, [r0, r3]
    81d8:	0006      	movs	r6, r0
    81da:	3698      	adds	r6, #152	; 0x98
    81dc:	6a43      	ldr	r3, [r0, #36]	; 0x24
    81de:	4699      	mov	r9, r3
    81e0:	0008      	movs	r0, r1
    81e2:	4b36      	ldr	r3, [pc, #216]	; (82bc <readPacket+0x108>)
    81e4:	4798      	blx	r3
    81e6:	0003      	movs	r3, r0
    81e8:	2201      	movs	r2, #1
    81ea:	4649      	mov	r1, r9
    81ec:	0030      	movs	r0, r6
    81ee:	47b8      	blx	r7
        /* If a network disconnect has occurred it would have been caught by keepalive already.
         * If nothing is found at this point means there was nothing to read. Not 100% correct,
         * but the only way to be sure is to pass proper error codes from the network stack
         * which the mbedtls/openssl implementations do not return */
        return MQTT_NOTHING_TO_READ;
    81f0:	2302      	movs	r3, #2
    uint32_t total_bytes_read = 0;
    uint32_t bytes_to_be_read = 0;
	int32_t ret_val = 0;

    /* 1. read the header byte.  This has the packet type in it */
    if(1 != c->networkStack.mqttread(&(c->networkStack), c->readbuf, 1, left_ms(timer))) {
    81f2:	2801      	cmp	r0, #1
    81f4:	d15a      	bne.n	82ac <readPacket+0xf8>
        return MQTT_NOTHING_TO_READ;
    }

    len = 1;
    /* 2. read the remaining length.  This is variable in itself */
    MQTTReturnCode rc = decodePacket(c, &rem_len, (uint32_t)left_ms(timer));
    81f6:	0028      	movs	r0, r5
    81f8:	4b30      	ldr	r3, [pc, #192]	; (82bc <readPacket+0x108>)
    81fa:	4798      	blx	r3
    81fc:	0002      	movs	r2, r0
    81fe:	a903      	add	r1, sp, #12
    8200:	0020      	movs	r0, r4
    8202:	4b2f      	ldr	r3, [pc, #188]	; (82c0 <readPacket+0x10c>)
    8204:	4798      	blx	r3
    if(SUCCESS != rc) {
        return rc;
    8206:	1e03      	subs	r3, r0, #0
    }

    len = 1;
    /* 2. read the remaining length.  This is variable in itself */
    MQTTReturnCode rc = decodePacket(c, &rem_len, (uint32_t)left_ms(timer));
    if(SUCCESS != rc) {
    8208:	d150      	bne.n	82ac <readPacket+0xf8>
        return rc;
    }

    /* if the buffer is too short then the message will be dropped silently */
	if (rem_len >= c->readBufSize) {
    820a:	69e3      	ldr	r3, [r4, #28]
    820c:	4698      	mov	r8, r3
    820e:	9903      	ldr	r1, [sp, #12]
    8210:	428b      	cmp	r3, r1
    8212:	d81f      	bhi.n	8254 <readPacket+0xa0>
    8214:	2700      	movs	r7, #0
		bytes_to_be_read = c->readBufSize;
		do {
			ret_val = c->networkStack.mqttread(&(c->networkStack), c->readbuf, bytes_to_be_read, left_ms(timer));
    8216:	23a0      	movs	r3, #160	; 0xa0
    8218:	469a      	mov	sl, r3
    821a:	4b28      	ldr	r3, [pc, #160]	; (82bc <readPacket+0x108>)
    821c:	469b      	mov	fp, r3
    821e:	4653      	mov	r3, sl
    8220:	58e3      	ldr	r3, [r4, r3]
    8222:	4699      	mov	r9, r3
    8224:	6a63      	ldr	r3, [r4, #36]	; 0x24
    8226:	9301      	str	r3, [sp, #4]
    8228:	0028      	movs	r0, r5
    822a:	47d8      	blx	fp
    822c:	0003      	movs	r3, r0
    822e:	4642      	mov	r2, r8
    8230:	9901      	ldr	r1, [sp, #4]
    8232:	0030      	movs	r0, r6
    8234:	47c8      	blx	r9
			if (ret_val > 0) {
    8236:	2800      	cmp	r0, #0
    8238:	dd33      	ble.n	82a2 <readPacket+0xee>
				total_bytes_read += ret_val;
    823a:	183f      	adds	r7, r7, r0
				if((rem_len - total_bytes_read) >= c->readBufSize){
    823c:	9b03      	ldr	r3, [sp, #12]
    823e:	69e2      	ldr	r2, [r4, #28]
    8240:	1bd9      	subs	r1, r3, r7
    8242:	4688      	mov	r8, r1
    8244:	4291      	cmp	r1, r2
    8246:	d900      	bls.n	824a <readPacket+0x96>
    8248:	4690      	mov	r8, r2
				}
				else{
					bytes_to_be_read = rem_len - total_bytes_read;
				}
			}
		} while (total_bytes_read < rem_len && ret_val > 0);
    824a:	429f      	cmp	r7, r3
    824c:	d3e7      	bcc.n	821e <readPacket+0x6a>
		return MQTTPACKET_BUFFER_TOO_SHORT;
    824e:	2309      	movs	r3, #9
    8250:	425b      	negs	r3, r3
    8252:	e02b      	b.n	82ac <readPacket+0xf8>
	}

    /* put the original remaining length back into the buffer */
    len += MQTTPacket_encode(c->readbuf + 1, rem_len);
    8254:	6a63      	ldr	r3, [r4, #36]	; 0x24
    8256:	1c58      	adds	r0, r3, #1
    8258:	4b1a      	ldr	r3, [pc, #104]	; (82c4 <readPacket+0x110>)
    825a:	4798      	blx	r3

    /* 3. read the rest of the buffer using a callback to supply the rest of the data */
    if(rem_len > 0 && (c->networkStack.mqttread(&(c->networkStack), c->readbuf + len, (int)rem_len, left_ms(timer)) != (int)rem_len)) {
    825c:	9b03      	ldr	r3, [sp, #12]
    825e:	4699      	mov	r9, r3
    8260:	2b00      	cmp	r3, #0
    8262:	d011      	beq.n	8288 <readPacket+0xd4>
    8264:	23a0      	movs	r3, #160	; 0xa0
    8266:	58e3      	ldr	r3, [r4, r3]
    8268:	469a      	mov	sl, r3
    826a:	3001      	adds	r0, #1
    826c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    826e:	4698      	mov	r8, r3
    8270:	4480      	add	r8, r0
    8272:	0028      	movs	r0, r5
    8274:	4b11      	ldr	r3, [pc, #68]	; (82bc <readPacket+0x108>)
    8276:	4798      	blx	r3
    8278:	0003      	movs	r3, r0
    827a:	464a      	mov	r2, r9
    827c:	4641      	mov	r1, r8
    827e:	0030      	movs	r0, r6
    8280:	47d0      	blx	sl
    8282:	9b03      	ldr	r3, [sp, #12]
    8284:	4298      	cmp	r0, r3
    8286:	d10f      	bne.n	82a8 <readPacket+0xf4>
        return FAILURE;
    }

    header.byte = c->readbuf[0];
    8288:	6a63      	ldr	r3, [r4, #36]	; 0x24
    828a:	781b      	ldrb	r3, [r3, #0]
    *packet_type = header.bits.type;
    828c:	091b      	lsrs	r3, r3, #4
    828e:	9a01      	ldr	r2, [sp, #4]
    8290:	7013      	strb	r3, [r2, #0]

    return SUCCESS;
    8292:	2300      	movs	r3, #0
    8294:	e00a      	b.n	82ac <readPacket+0xf8>
    return SUCCESS;
}

MQTTReturnCode readPacket(Client *c, Timer *timer, uint8_t *packet_type) {
    if(NULL == c || NULL == timer) {
        return MQTT_NULL_VALUE_ERROR;
    8296:	2306      	movs	r3, #6
    8298:	425b      	negs	r3, r3
    829a:	e007      	b.n	82ac <readPacket+0xf8>
    829c:	2306      	movs	r3, #6
    829e:	425b      	negs	r3, r3
    82a0:	e004      	b.n	82ac <readPacket+0xf8>
				else{
					bytes_to_be_read = rem_len - total_bytes_read;
				}
			}
		} while (total_bytes_read < rem_len && ret_val > 0);
		return MQTTPACKET_BUFFER_TOO_SHORT;
    82a2:	2309      	movs	r3, #9
    82a4:	425b      	negs	r3, r3
    82a6:	e001      	b.n	82ac <readPacket+0xf8>
    /* put the original remaining length back into the buffer */
    len += MQTTPacket_encode(c->readbuf + 1, rem_len);

    /* 3. read the rest of the buffer using a callback to supply the rest of the data */
    if(rem_len > 0 && (c->networkStack.mqttread(&(c->networkStack), c->readbuf + len, (int)rem_len, left_ms(timer)) != (int)rem_len)) {
        return FAILURE;
    82a8:	2301      	movs	r3, #1
    82aa:	425b      	negs	r3, r3

    header.byte = c->readbuf[0];
    *packet_type = header.bits.type;

    return SUCCESS;
}
    82ac:	0018      	movs	r0, r3
    82ae:	b005      	add	sp, #20
    82b0:	bc3c      	pop	{r2, r3, r4, r5}
    82b2:	4690      	mov	r8, r2
    82b4:	4699      	mov	r9, r3
    82b6:	46a2      	mov	sl, r4
    82b8:	46ab      	mov	fp, r5
    82ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
    82bc:	00007b79 	.word	0x00007b79
    82c0:	00008125 	.word	0x00008125
    82c4:	000092e5 	.word	0x000092e5

000082c8 <isTopicMatched>:

// assume topic filter and name is in correct format
// # can only be at end
// + and # can only be next to separator
char isTopicMatched(char *topicFilter, MQTTString *topicName) {
    82c8:	b530      	push	{r4, r5, lr}
    if(NULL == topicFilter || NULL == topicName) {
    82ca:	2800      	cmp	r0, #0
    82cc:	d03b      	beq.n	8346 <isTopicMatched+0x7e>
    82ce:	2900      	cmp	r1, #0
    82d0:	d03b      	beq.n	834a <isTopicMatched+0x82>
        return MQTT_NULL_VALUE_ERROR;
    }

    char *curf = topicFilter;
    char *curn = topicName->lenstring.data;
    82d2:	688b      	ldr	r3, [r1, #8]
    char *curn_end = curn + topicName->lenstring.len;
    82d4:	684d      	ldr	r5, [r1, #4]
    82d6:	195d      	adds	r5, r3, r5

    while(*curf && (curn < curn_end)) {
    82d8:	7802      	ldrb	r2, [r0, #0]
    82da:	2a00      	cmp	r2, #0
    82dc:	d03c      	beq.n	8358 <isTopicMatched+0x90>
    82de:	42ab      	cmp	r3, r5
    82e0:	d22e      	bcs.n	8340 <isTopicMatched+0x78>
    82e2:	3001      	adds	r0, #1
    82e4:	1e69      	subs	r1, r5, #1
    82e6:	e000      	b.n	82ea <isTopicMatched+0x22>
    82e8:	3001      	adds	r0, #1
        if(*curn == '/' && *curf != '/') {
    82ea:	781c      	ldrb	r4, [r3, #0]
    82ec:	2c2f      	cmp	r4, #47	; 0x2f
    82ee:	d102      	bne.n	82f6 <isTopicMatched+0x2e>
    82f0:	2a2f      	cmp	r2, #47	; 0x2f
    82f2:	d017      	beq.n	8324 <isTopicMatched+0x5c>
    82f4:	e01e      	b.n	8334 <isTopicMatched+0x6c>
            break;
        }
        if(*curf != '+' && *curf != '#' && *curf != *curn) {
    82f6:	2a2b      	cmp	r2, #43	; 0x2b
    82f8:	d004      	beq.n	8304 <isTopicMatched+0x3c>
    82fa:	2a23      	cmp	r2, #35	; 0x23
    82fc:	d00f      	beq.n	831e <isTopicMatched+0x56>
    82fe:	4294      	cmp	r4, r2
    8300:	d010      	beq.n	8324 <isTopicMatched+0x5c>
    8302:	e017      	b.n	8334 <isTopicMatched+0x6c>
            break;
        }
        if(*curf == '+') {
            /* skip until we meet the next separator, or end of string */
            char *nextpos = curn + 1;
            while(nextpos < curn_end && *nextpos != '/')
    8304:	1c5a      	adds	r2, r3, #1
    8306:	4295      	cmp	r5, r2
    8308:	d92a      	bls.n	8360 <isTopicMatched+0x98>
    830a:	785a      	ldrb	r2, [r3, #1]
    830c:	2a2f      	cmp	r2, #47	; 0x2f
    830e:	d01e      	beq.n	834e <isTopicMatched+0x86>
                nextpos = ++curn + 1;
    8310:	3301      	adds	r3, #1
            break;
        }
        if(*curf == '+') {
            /* skip until we meet the next separator, or end of string */
            char *nextpos = curn + 1;
            while(nextpos < curn_end && *nextpos != '/')
    8312:	428b      	cmp	r3, r1
    8314:	d005      	beq.n	8322 <isTopicMatched+0x5a>
    8316:	785a      	ldrb	r2, [r3, #1]
    8318:	2a2f      	cmp	r2, #47	; 0x2f
    831a:	d1f9      	bne.n	8310 <isTopicMatched+0x48>
    831c:	e017      	b.n	834e <isTopicMatched+0x86>
                nextpos = ++curn + 1;
        } else if(*curf == '#') {
            /* skip until end of string */
            curn = curn_end - 1;
    831e:	1e6b      	subs	r3, r5, #1
    8320:	e000      	b.n	8324 <isTopicMatched+0x5c>
        }
        if(*curf == '+') {
            /* skip until we meet the next separator, or end of string */
            char *nextpos = curn + 1;
            while(nextpos < curn_end && *nextpos != '/')
                nextpos = ++curn + 1;
    8322:	000b      	movs	r3, r1
            /* skip until end of string */
            curn = curn_end - 1;
        }

        curf++;
        curn++;
    8324:	3301      	adds	r3, #1

    char *curf = topicFilter;
    char *curn = topicName->lenstring.data;
    char *curn_end = curn + topicName->lenstring.len;

    while(*curf && (curn < curn_end)) {
    8326:	7802      	ldrb	r2, [r0, #0]
    8328:	2a00      	cmp	r2, #0
    832a:	d015      	beq.n	8358 <isTopicMatched+0x90>
    832c:	429d      	cmp	r5, r3
    832e:	d8db      	bhi.n	82e8 <isTopicMatched+0x20>

        curf++;
        curn++;
    };

    return (curn == curn_end) && (*curf == '\0');
    8330:	2000      	movs	r0, #0
    8332:	e006      	b.n	8342 <isTopicMatched+0x7a>
    8334:	2000      	movs	r0, #0
    8336:	429d      	cmp	r5, r3
    8338:	d103      	bne.n	8342 <isTopicMatched+0x7a>
    833a:	4250      	negs	r0, r2
    833c:	4150      	adcs	r0, r2
    833e:	e000      	b.n	8342 <isTopicMatched+0x7a>
    8340:	2000      	movs	r0, #0
    8342:	b2c0      	uxtb	r0, r0
    8344:	e012      	b.n	836c <isTopicMatched+0xa4>
// assume topic filter and name is in correct format
// # can only be at end
// + and # can only be next to separator
char isTopicMatched(char *topicFilter, MQTTString *topicName) {
    if(NULL == topicFilter || NULL == topicName) {
        return MQTT_NULL_VALUE_ERROR;
    8346:	20fa      	movs	r0, #250	; 0xfa
    8348:	e010      	b.n	836c <isTopicMatched+0xa4>
    834a:	20fa      	movs	r0, #250	; 0xfa
    834c:	e00e      	b.n	836c <isTopicMatched+0xa4>
            /* skip until end of string */
            curn = curn_end - 1;
        }

        curf++;
        curn++;
    834e:	3301      	adds	r3, #1

    char *curf = topicFilter;
    char *curn = topicName->lenstring.data;
    char *curn_end = curn + topicName->lenstring.len;

    while(*curf && (curn < curn_end)) {
    8350:	7802      	ldrb	r2, [r0, #0]
    8352:	2a00      	cmp	r2, #0
    8354:	d1c8      	bne.n	82e8 <isTopicMatched+0x20>
    8356:	e7ed      	b.n	8334 <isTopicMatched+0x6c>

        curf++;
        curn++;
    };

    return (curn == curn_end) && (*curf == '\0');
    8358:	1aeb      	subs	r3, r5, r3
    835a:	4258      	negs	r0, r3
    835c:	4158      	adcs	r0, r3
    835e:	e7f0      	b.n	8342 <isTopicMatched+0x7a>
            /* skip until end of string */
            curn = curn_end - 1;
        }

        curf++;
        curn++;
    8360:	3301      	adds	r3, #1

    char *curf = topicFilter;
    char *curn = topicName->lenstring.data;
    char *curn_end = curn + topicName->lenstring.len;

    while(*curf && (curn < curn_end)) {
    8362:	7802      	ldrb	r2, [r0, #0]

        curf++;
        curn++;
    };

    return (curn == curn_end) && (*curf == '\0');
    8364:	2000      	movs	r0, #0

    char *curf = topicFilter;
    char *curn = topicName->lenstring.data;
    char *curn_end = curn + topicName->lenstring.len;

    while(*curf && (curn < curn_end)) {
    8366:	2a00      	cmp	r2, #0
    8368:	d1eb      	bne.n	8342 <isTopicMatched+0x7a>
    836a:	e7f5      	b.n	8358 <isTopicMatched+0x90>
        curf++;
        curn++;
    };

    return (curn == curn_end) && (*curf == '\0');
}
    836c:	bd30      	pop	{r4, r5, pc}
    836e:	46c0      	nop			; (mov r8, r8)

00008370 <deliverMessage>:

MQTTReturnCode deliverMessage(Client *c, MQTTString *topicName, MQTTMessage *message) {
    8370:	b5f0      	push	{r4, r5, r6, r7, lr}
    8372:	464f      	mov	r7, r9
    8374:	4646      	mov	r6, r8
    8376:	b4c0      	push	{r6, r7}
    8378:	b085      	sub	sp, #20
    837a:	4681      	mov	r9, r0
    837c:	000e      	movs	r6, r1
    837e:	4690      	mov	r8, r2
    if(NULL == c || NULL == topicName || NULL == message) {
    8380:	2800      	cmp	r0, #0
    8382:	d037      	beq.n	83f4 <deliverMessage+0x84>
    8384:	2900      	cmp	r1, #0
    8386:	d038      	beq.n	83fa <deliverMessage+0x8a>
    8388:	2a00      	cmp	r2, #0
    838a:	d039      	beq.n	8400 <deliverMessage+0x90>
    838c:	0004      	movs	r4, r0
    838e:	34c4      	adds	r4, #196	; 0xc4
    8390:	2500      	movs	r5, #0
    8392:	0027      	movs	r7, r4
    uint32_t i;
    MessageData md;

    // we have to find the right message handler - indexed by topic
    for(i = 0; i < MAX_MESSAGE_HANDLERS; ++i) {
        if((c->messageHandlers[i].topicFilter != 0)
    8394:	6821      	ldr	r1, [r4, #0]
    8396:	2900      	cmp	r1, #0
    8398:	d019      	beq.n	83ce <deliverMessage+0x5e>
           && (MQTTPacket_equals(topicName, (char*)c->messageHandlers[i].topicFilter) ||
    839a:	0030      	movs	r0, r6
    839c:	4b1d      	ldr	r3, [pc, #116]	; (8414 <deliverMessage+0xa4>)
    839e:	4798      	blx	r3
    83a0:	2800      	cmp	r0, #0
    83a2:	d105      	bne.n	83b0 <deliverMessage+0x40>
                isTopicMatched((char*)c->messageHandlers[i].topicFilter, topicName))) {
    83a4:	0031      	movs	r1, r6
    83a6:	6820      	ldr	r0, [r4, #0]
    83a8:	4b1b      	ldr	r3, [pc, #108]	; (8418 <deliverMessage+0xa8>)
    83aa:	4798      	blx	r3
    MessageData md;

    // we have to find the right message handler - indexed by topic
    for(i = 0; i < MAX_MESSAGE_HANDLERS; ++i) {
        if((c->messageHandlers[i].topicFilter != 0)
           && (MQTTPacket_equals(topicName, (char*)c->messageHandlers[i].topicFilter) ||
    83ac:	2800      	cmp	r0, #0
    83ae:	d00e      	beq.n	83ce <deliverMessage+0x5e>
                isTopicMatched((char*)c->messageHandlers[i].topicFilter, topicName))) {
            if(c->messageHandlers[i].fp != NULL) {
    83b0:	687a      	ldr	r2, [r7, #4]
    83b2:	2a00      	cmp	r2, #0
    83b4:	d00b      	beq.n	83ce <deliverMessage+0x5e>
                NewMessageData(&md, topicName, message, c->messageHandlers[i].applicationHandler);
    83b6:	012b      	lsls	r3, r5, #4
    83b8:	444b      	add	r3, r9
    83ba:	33cc      	adds	r3, #204	; 0xcc
    83bc:	681b      	ldr	r3, [r3, #0]
#include <string.h>

static void MQTTForceDisconnect(Client *c);

void NewMessageData(MessageData *md, MQTTString *aTopicName, MQTTMessage *aMessage, pApplicationHandler_t applicationHandler) {
    md->topicName = aTopicName;
    83be:	9602      	str	r6, [sp, #8]
    md->message = aMessage;
    83c0:	4641      	mov	r1, r8
    83c2:	9101      	str	r1, [sp, #4]
    md->applicationHandler = applicationHandler;
    83c4:	9303      	str	r3, [sp, #12]
        if((c->messageHandlers[i].topicFilter != 0)
           && (MQTTPacket_equals(topicName, (char*)c->messageHandlers[i].topicFilter) ||
                isTopicMatched((char*)c->messageHandlers[i].topicFilter, topicName))) {
            if(c->messageHandlers[i].fp != NULL) {
                NewMessageData(&md, topicName, message, c->messageHandlers[i].applicationHandler);
                c->messageHandlers[i].fp(&md);
    83c6:	a801      	add	r0, sp, #4
    83c8:	4790      	blx	r2
                return SUCCESS;
    83ca:	2000      	movs	r0, #0
    83cc:	e01d      	b.n	840a <deliverMessage+0x9a>

    uint32_t i;
    MessageData md;

    // we have to find the right message handler - indexed by topic
    for(i = 0; i < MAX_MESSAGE_HANDLERS; ++i) {
    83ce:	3501      	adds	r5, #1
    83d0:	3410      	adds	r4, #16
    83d2:	2d05      	cmp	r5, #5
    83d4:	d1dd      	bne.n	8392 <deliverMessage+0x22>
                return SUCCESS;
            }
        }
    }

    if(NULL != c->defaultMessageHandler) {
    83d6:	238a      	movs	r3, #138	; 0x8a
    83d8:	005b      	lsls	r3, r3, #1
    83da:	464a      	mov	r2, r9
    83dc:	58d3      	ldr	r3, [r2, r3]
    83de:	2b00      	cmp	r3, #0
    83e0:	d011      	beq.n	8406 <deliverMessage+0x96>
#include <string.h>

static void MQTTForceDisconnect(Client *c);

void NewMessageData(MessageData *md, MQTTString *aTopicName, MQTTMessage *aMessage, pApplicationHandler_t applicationHandler) {
    md->topicName = aTopicName;
    83e2:	9602      	str	r6, [sp, #8]
    md->message = aMessage;
    83e4:	4642      	mov	r2, r8
    83e6:	9201      	str	r2, [sp, #4]
    md->applicationHandler = applicationHandler;
    83e8:	2200      	movs	r2, #0
    83ea:	9203      	str	r2, [sp, #12]
        }
    }

    if(NULL != c->defaultMessageHandler) {
        NewMessageData(&md, topicName, message, NULL);
        c->defaultMessageHandler(&md);
    83ec:	a801      	add	r0, sp, #4
    83ee:	4798      	blx	r3
        return SUCCESS;
    83f0:	2000      	movs	r0, #0
    83f2:	e00a      	b.n	840a <deliverMessage+0x9a>
    return (curn == curn_end) && (*curf == '\0');
}

MQTTReturnCode deliverMessage(Client *c, MQTTString *topicName, MQTTMessage *message) {
    if(NULL == c || NULL == topicName || NULL == message) {
        return MQTT_NULL_VALUE_ERROR;
    83f4:	2006      	movs	r0, #6
    83f6:	4240      	negs	r0, r0
    83f8:	e007      	b.n	840a <deliverMessage+0x9a>
    83fa:	2006      	movs	r0, #6
    83fc:	4240      	negs	r0, r0
    83fe:	e004      	b.n	840a <deliverMessage+0x9a>
    8400:	2006      	movs	r0, #6
    8402:	4240      	negs	r0, r0
    8404:	e001      	b.n	840a <deliverMessage+0x9a>
        c->defaultMessageHandler(&md);
        return SUCCESS;
    }

    /* Message handler not found for topic */
    return FAILURE;
    8406:	2001      	movs	r0, #1
    8408:	4240      	negs	r0, r0
}
    840a:	b005      	add	sp, #20
    840c:	bc0c      	pop	{r2, r3}
    840e:	4690      	mov	r8, r2
    8410:	4699      	mov	r9, r3
    8412:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8414:	00009535 	.word	0x00009535
    8418:	000082c9 	.word	0x000082c9

0000841c <handlePublish>:
    countdown(&c->pingTimer, c->keepAliveInterval / 2);

    return SUCCESS;
}

MQTTReturnCode handlePublish(Client *c, Timer *timer) {
    841c:	b570      	push	{r4, r5, r6, lr}
    841e:	b08e      	sub	sp, #56	; 0x38
    8420:	0004      	movs	r4, r0
    8422:	000d      	movs	r5, r1
    MQTTString topicName;
    MQTTMessage msg;
    MQTTReturnCode rc;
    uint32_t len = 0;
    8424:	2300      	movs	r3, #0
    8426:	9306      	str	r3, [sp, #24]

    rc = MQTTDeserialize_publish((unsigned char *) &msg.dup, (QoS *) &msg.qos, (unsigned char *) &msg.retained,
    8428:	69c3      	ldr	r3, [r0, #28]
    842a:	9304      	str	r3, [sp, #16]
    842c:	6a43      	ldr	r3, [r0, #36]	; 0x24
    842e:	9303      	str	r3, [sp, #12]
    8430:	ab0a      	add	r3, sp, #40	; 0x28
    8432:	9302      	str	r3, [sp, #8]
    8434:	ab09      	add	r3, sp, #36	; 0x24
    8436:	9301      	str	r3, [sp, #4]
    8438:	ab0b      	add	r3, sp, #44	; 0x2c
    843a:	9300      	str	r3, [sp, #0]
    843c:	ab08      	add	r3, sp, #32
    843e:	221d      	movs	r2, #29
    8440:	446a      	add	r2, sp
    8442:	a907      	add	r1, sp, #28
    8444:	201e      	movs	r0, #30
    8446:	4468      	add	r0, sp
    8448:	4e19      	ldr	r6, [pc, #100]	; (84b0 <handlePublish+0x94>)
    844a:	47b0      	blx	r6
                                 (uint16_t *)&msg.id, &topicName,
                                 (unsigned char **) &msg.payload, (uint32_t *) &msg.payloadlen, c->readbuf,
                                 c->readBufSize);
    if(SUCCESS != rc) {
    844c:	2800      	cmp	r0, #0
    844e:	d12d      	bne.n	84ac <handlePublish+0x90>
        return rc;
    }

    rc = deliverMessage(c, &topicName, &msg);
    8450:	aa07      	add	r2, sp, #28
    8452:	a90b      	add	r1, sp, #44	; 0x2c
    8454:	0020      	movs	r0, r4
    8456:	4b17      	ldr	r3, [pc, #92]	; (84b4 <handlePublish+0x98>)
    8458:	4798      	blx	r3
    if(SUCCESS != rc) {
    845a:	2800      	cmp	r0, #0
    845c:	d126      	bne.n	84ac <handlePublish+0x90>
        return rc;
    }

    if(QOS0 == msg.qos) {
    845e:	ab07      	add	r3, sp, #28
    8460:	781b      	ldrb	r3, [r3, #0]
        /* No further processing required for QOS0 */
        return SUCCESS;
    8462:	2000      	movs	r0, #0
    rc = deliverMessage(c, &topicName, &msg);
    if(SUCCESS != rc) {
        return rc;
    }

    if(QOS0 == msg.qos) {
    8464:	2b00      	cmp	r3, #0
    8466:	d021      	beq.n	84ac <handlePublish+0x90>
        /* No further processing required for QOS0 */
        return SUCCESS;
    }

    if(QOS1 == msg.qos) {
    8468:	2b01      	cmp	r3, #1
    846a:	d10c      	bne.n	8486 <handlePublish+0x6a>
        rc = MQTTSerialize_ack(c->buf, c->bufSize, PUBACK, 0, msg.id, &len);
    846c:	ab06      	add	r3, sp, #24
    846e:	9301      	str	r3, [sp, #4]
    8470:	ab07      	add	r3, sp, #28
    8472:	889b      	ldrh	r3, [r3, #4]
    8474:	9300      	str	r3, [sp, #0]
    8476:	2300      	movs	r3, #0
    8478:	2204      	movs	r2, #4
    847a:	69a1      	ldr	r1, [r4, #24]
    847c:	6a20      	ldr	r0, [r4, #32]
    847e:	4e0e      	ldr	r6, [pc, #56]	; (84b8 <handlePublish+0x9c>)
    8480:	47b0      	blx	r6
    8482:	0003      	movs	r3, r0
    8484:	e00b      	b.n	849e <handlePublish+0x82>
    } else { /* Message is not QOS0 or 1 means only option left is QOS2 */
        rc = MQTTSerialize_ack(c->buf, c->bufSize, PUBREC, 0, msg.id, &len);
    8486:	ab06      	add	r3, sp, #24
    8488:	9301      	str	r3, [sp, #4]
    848a:	ab07      	add	r3, sp, #28
    848c:	889b      	ldrh	r3, [r3, #4]
    848e:	9300      	str	r3, [sp, #0]
    8490:	2300      	movs	r3, #0
    8492:	2205      	movs	r2, #5
    8494:	69a1      	ldr	r1, [r4, #24]
    8496:	6a20      	ldr	r0, [r4, #32]
    8498:	4e07      	ldr	r6, [pc, #28]	; (84b8 <handlePublish+0x9c>)
    849a:	47b0      	blx	r6
    849c:	0003      	movs	r3, r0
    }

    if(SUCCESS != rc) {
        return rc;
    849e:	1e18      	subs	r0, r3, #0
        rc = MQTTSerialize_ack(c->buf, c->bufSize, PUBACK, 0, msg.id, &len);
    } else { /* Message is not QOS0 or 1 means only option left is QOS2 */
        rc = MQTTSerialize_ack(c->buf, c->bufSize, PUBREC, 0, msg.id, &len);
    }

    if(SUCCESS != rc) {
    84a0:	d104      	bne.n	84ac <handlePublish+0x90>
        return rc;
    }

    rc = sendPacket(c, len, timer);
    84a2:	002a      	movs	r2, r5
    84a4:	9906      	ldr	r1, [sp, #24]
    84a6:	0020      	movs	r0, r4
    84a8:	4b04      	ldr	r3, [pc, #16]	; (84bc <handlePublish+0xa0>)
    84aa:	4798      	blx	r3
    if(SUCCESS != rc) {
        return rc;
    }

    return SUCCESS;
}
    84ac:	b00e      	add	sp, #56	; 0x38
    84ae:	bd70      	pop	{r4, r5, r6, pc}
    84b0:	00009149 	.word	0x00009149
    84b4:	00008371 	.word	0x00008371
    84b8:	000097d9 	.word	0x000097d9
    84bc:	00007f5d 	.word	0x00007f5d

000084c0 <handlePubrec>:

MQTTReturnCode handlePubrec(Client *c, Timer *timer) {
    84c0:	b570      	push	{r4, r5, r6, lr}
    84c2:	b084      	sub	sp, #16
    84c4:	0004      	movs	r4, r0
    84c6:	000d      	movs	r5, r1
    uint16_t packet_id;
    unsigned char dup, type;
    MQTTReturnCode rc;
    rc = MQTTDeserialize_ack(&type, &dup, &packet_id, c->readbuf, c->readBufSize);
    84c8:	69c3      	ldr	r3, [r0, #28]
    84ca:	9300      	str	r3, [sp, #0]
    84cc:	6a43      	ldr	r3, [r0, #36]	; 0x24
    84ce:	220e      	movs	r2, #14
    84d0:	446a      	add	r2, sp
    84d2:	210d      	movs	r1, #13
    84d4:	4469      	add	r1, sp
    84d6:	a803      	add	r0, sp, #12
    84d8:	4e0c      	ldr	r6, [pc, #48]	; (850c <handlePubrec+0x4c>)
    84da:	47b0      	blx	r6
    if(SUCCESS != rc) {
    84dc:	2800      	cmp	r0, #0
    84de:	d112      	bne.n	8506 <handlePubrec+0x46>
        return rc;
    }

    uint32_t len;
    rc = MQTTSerialize_ack(c->buf, c->bufSize, PUBREL, 0, packet_id, &len);
    84e0:	ab02      	add	r3, sp, #8
    84e2:	9301      	str	r3, [sp, #4]
    84e4:	230e      	movs	r3, #14
    84e6:	446b      	add	r3, sp
    84e8:	881b      	ldrh	r3, [r3, #0]
    84ea:	9300      	str	r3, [sp, #0]
    84ec:	2300      	movs	r3, #0
    84ee:	2206      	movs	r2, #6
    84f0:	69a1      	ldr	r1, [r4, #24]
    84f2:	6a20      	ldr	r0, [r4, #32]
    84f4:	4e06      	ldr	r6, [pc, #24]	; (8510 <handlePubrec+0x50>)
    84f6:	47b0      	blx	r6
    if(SUCCESS != rc) {
    84f8:	2800      	cmp	r0, #0
    84fa:	d104      	bne.n	8506 <handlePubrec+0x46>
        return rc;
    }

    /* send the PUBREL packet */
    rc = sendPacket(c, len, timer);
    84fc:	002a      	movs	r2, r5
    84fe:	9902      	ldr	r1, [sp, #8]
    8500:	0020      	movs	r0, r4
    8502:	4b04      	ldr	r3, [pc, #16]	; (8514 <handlePubrec+0x54>)
    8504:	4798      	blx	r3
        /* there was a problem */
        return rc;
    }

    return SUCCESS;
}
    8506:	b004      	add	sp, #16
    8508:	bd70      	pop	{r4, r5, r6, pc}
    850a:	46c0      	nop			; (mov r8, r8)
    850c:	00009229 	.word	0x00009229
    8510:	000097d9 	.word	0x000097d9
    8514:	00007f5d 	.word	0x00007f5d

00008518 <cycle>:

MQTTReturnCode cycle(Client *c, Timer *timer, uint8_t *packet_type) {
    8518:	b570      	push	{r4, r5, r6, lr}
    851a:	0004      	movs	r4, r0
    851c:	000d      	movs	r5, r1
    851e:	0016      	movs	r6, r2
    if(NULL == c || NULL == timer) {
    8520:	2800      	cmp	r0, #0
    8522:	d023      	beq.n	856c <cycle+0x54>
    8524:	2900      	cmp	r1, #0
    8526:	d024      	beq.n	8572 <cycle+0x5a>
        return MQTT_NULL_VALUE_ERROR;
    }

    /* read the socket, see what work is due */
    MQTTReturnCode rc = readPacket(c, timer, packet_type);
    8528:	4b16      	ldr	r3, [pc, #88]	; (8584 <cycle+0x6c>)
    852a:	4798      	blx	r3
    if(MQTT_NOTHING_TO_READ == rc) {
    852c:	2802      	cmp	r0, #2
    852e:	d023      	beq.n	8578 <cycle+0x60>
        /* Nothing to read, not a cycle failure */
        return SUCCESS;
    }
    if(SUCCESS != rc) {
    8530:	2800      	cmp	r0, #0
    8532:	d125      	bne.n	8580 <cycle+0x68>
        return rc;
    }

    switch(*packet_type) {
    8534:	7833      	ldrb	r3, [r6, #0]
    8536:	2b0d      	cmp	r3, #13
    8538:	d820      	bhi.n	857c <cycle+0x64>
    853a:	009b      	lsls	r3, r3, #2
    853c:	4a12      	ldr	r2, [pc, #72]	; (8588 <cycle+0x70>)
    853e:	58d3      	ldr	r3, [r2, r3]
    8540:	469f      	mov	pc, r3
    if(NULL == c || NULL == timer) {
        return MQTT_NULL_VALUE_ERROR;
    }

    /* read the socket, see what work is due */
    MQTTReturnCode rc = readPacket(c, timer, packet_type);
    8542:	2000      	movs	r0, #0
    8544:	e01c      	b.n	8580 <cycle+0x68>
        case PUBACK:
        case SUBACK:
        case UNSUBACK:
            break;
        case PUBLISH: {
            rc = handlePublish(c, timer);
    8546:	0029      	movs	r1, r5
    8548:	0020      	movs	r0, r4
    854a:	4b10      	ldr	r3, [pc, #64]	; (858c <cycle+0x74>)
    854c:	4798      	blx	r3
            break;
    854e:	e017      	b.n	8580 <cycle+0x68>
        }
        case PUBREC: {
            rc = handlePubrec(c, timer);
    8550:	0029      	movs	r1, r5
    8552:	0020      	movs	r0, r4
    8554:	4b0e      	ldr	r3, [pc, #56]	; (8590 <cycle+0x78>)
    8556:	4798      	blx	r3
            break;
    8558:	e012      	b.n	8580 <cycle+0x68>
        }
        case PUBCOMP:
            break;
        case PINGRESP: {
            c->isPingOutstanding = 0;
    855a:	2300      	movs	r3, #0
    855c:	70a3      	strb	r3, [r4, #2]
            countdown(&c->pingTimer, c->keepAliveInterval);
    855e:	68e1      	ldr	r1, [r4, #12]
    8560:	0020      	movs	r0, r4
    8562:	30b4      	adds	r0, #180	; 0xb4
    8564:	4b0b      	ldr	r3, [pc, #44]	; (8594 <cycle+0x7c>)
    8566:	4798      	blx	r3
    if(NULL == c || NULL == timer) {
        return MQTT_NULL_VALUE_ERROR;
    }

    /* read the socket, see what work is due */
    MQTTReturnCode rc = readPacket(c, timer, packet_type);
    8568:	2000      	movs	r0, #0
        case PUBCOMP:
            break;
        case PINGRESP: {
            c->isPingOutstanding = 0;
            countdown(&c->pingTimer, c->keepAliveInterval);
            break;
    856a:	e009      	b.n	8580 <cycle+0x68>
    return SUCCESS;
}

MQTTReturnCode cycle(Client *c, Timer *timer, uint8_t *packet_type) {
    if(NULL == c || NULL == timer) {
        return MQTT_NULL_VALUE_ERROR;
    856c:	2006      	movs	r0, #6
    856e:	4240      	negs	r0, r0
    8570:	e006      	b.n	8580 <cycle+0x68>
    8572:	2006      	movs	r0, #6
    8574:	4240      	negs	r0, r0
    8576:	e003      	b.n	8580 <cycle+0x68>

    /* read the socket, see what work is due */
    MQTTReturnCode rc = readPacket(c, timer, packet_type);
    if(MQTT_NOTHING_TO_READ == rc) {
        /* Nothing to read, not a cycle failure */
        return SUCCESS;
    8578:	2000      	movs	r0, #0
    857a:	e001      	b.n	8580 <cycle+0x68>
            break;
        }
        default: {
            /* Either unknown packet type or Failure occurred
             * Should not happen */
        	return MQTT_BUFFER_RX_MESSAGE_INVALID;
    857c:	2012      	movs	r0, #18
    857e:	4240      	negs	r0, r0
            break;
        }
    }

    return rc;
}
    8580:	bd70      	pop	{r4, r5, r6, pc}
    8582:	46c0      	nop			; (mov r8, r8)
    8584:	000081b5 	.word	0x000081b5
    8588:	000152ec 	.word	0x000152ec
    858c:	0000841d 	.word	0x0000841d
    8590:	000084c1 	.word	0x000084c1
    8594:	00007b55 	.word	0x00007b55

00008598 <waitfor>:

    return rc;
}

/* only used in single-threaded mode where one command at a time is in process */
MQTTReturnCode waitfor(Client *c, uint8_t packet_type, Timer *timer) {
    8598:	b5f0      	push	{r4, r5, r6, r7, lr}
    859a:	4647      	mov	r7, r8
    859c:	b480      	push	{r7}
    859e:	b084      	sub	sp, #16
    85a0:	9001      	str	r0, [sp, #4]
    85a2:	000f      	movs	r7, r1
    85a4:	9200      	str	r2, [sp, #0]
    if(NULL == c || NULL == timer) {
    85a6:	2800      	cmp	r0, #0
    85a8:	d023      	beq.n	85f2 <waitfor+0x5a>
    85aa:	2a00      	cmp	r2, #0
    85ac:	d024      	beq.n	85f8 <waitfor+0x60>
        return MQTT_NULL_VALUE_ERROR;
    }

    MQTTReturnCode rc = FAILURE;
    uint8_t read_packet_type = 0;
    85ae:	2200      	movs	r2, #0
    85b0:	ab02      	add	r3, sp, #8
    85b2:	71da      	strb	r2, [r3, #7]
MQTTReturnCode waitfor(Client *c, uint8_t packet_type, Timer *timer) {
    if(NULL == c || NULL == timer) {
        return MQTT_NULL_VALUE_ERROR;
    }

    MQTTReturnCode rc = FAILURE;
    85b4:	2401      	movs	r4, #1
    85b6:	4264      	negs	r4, r4
    uint8_t read_packet_type = 0;
    do {
        if(expired(timer)) {
    85b8:	4b15      	ldr	r3, [pc, #84]	; (8610 <waitfor+0x78>)
    85ba:	4698      	mov	r8, r3
            /* we timed out */
            break;
        }
        rc = cycle(c, timer, &read_packet_type);
    85bc:	ab02      	add	r3, sp, #8
    85be:	1dde      	adds	r6, r3, #7
    85c0:	4d14      	ldr	r5, [pc, #80]	; (8614 <waitfor+0x7c>)
    }

    MQTTReturnCode rc = FAILURE;
    uint8_t read_packet_type = 0;
    do {
        if(expired(timer)) {
    85c2:	9800      	ldr	r0, [sp, #0]
    85c4:	47c0      	blx	r8
    85c6:	2800      	cmp	r0, #0
    85c8:	d10a      	bne.n	85e0 <waitfor+0x48>
            /* we timed out */
            break;
        }
        rc = cycle(c, timer, &read_packet_type);
    85ca:	0032      	movs	r2, r6
    85cc:	9900      	ldr	r1, [sp, #0]
    85ce:	9801      	ldr	r0, [sp, #4]
    85d0:	47a8      	blx	r5
    85d2:	0004      	movs	r4, r0
    }while(MQTT_NETWORK_DISCONNECTED_ERROR != rc  && read_packet_type != packet_type);
    85d4:	1d03      	adds	r3, r0, #4
    85d6:	d012      	beq.n	85fe <waitfor+0x66>
    85d8:	7833      	ldrb	r3, [r6, #0]
    85da:	42bb      	cmp	r3, r7
    85dc:	d1f1      	bne.n	85c2 <waitfor+0x2a>
    85de:	e006      	b.n	85ee <waitfor+0x56>

    if(MQTT_NETWORK_DISCONNECTED_ERROR != rc && read_packet_type != packet_type) {
    85e0:	1d23      	adds	r3, r4, #4
    85e2:	d004      	beq.n	85ee <waitfor+0x56>
    85e4:	ab02      	add	r3, sp, #8
    85e6:	3307      	adds	r3, #7
    85e8:	781b      	ldrb	r3, [r3, #0]
    85ea:	42bb      	cmp	r3, r7
    85ec:	d10a      	bne.n	8604 <waitfor+0x6c>
        return FAILURE;
    }

    /* Something failed or we didn't receive the expected packet, return error code */
    return rc;
    85ee:	0020      	movs	r0, r4
    85f0:	e00a      	b.n	8608 <waitfor+0x70>
}

/* only used in single-threaded mode where one command at a time is in process */
MQTTReturnCode waitfor(Client *c, uint8_t packet_type, Timer *timer) {
    if(NULL == c || NULL == timer) {
        return MQTT_NULL_VALUE_ERROR;
    85f2:	2006      	movs	r0, #6
    85f4:	4240      	negs	r0, r0
    85f6:	e007      	b.n	8608 <waitfor+0x70>
    85f8:	2006      	movs	r0, #6
    85fa:	4240      	negs	r0, r0
    85fc:	e004      	b.n	8608 <waitfor+0x70>
    do {
        if(expired(timer)) {
            /* we timed out */
            break;
        }
        rc = cycle(c, timer, &read_packet_type);
    85fe:	2004      	movs	r0, #4
    8600:	4240      	negs	r0, r0
    8602:	e001      	b.n	8608 <waitfor+0x70>
    }while(MQTT_NETWORK_DISCONNECTED_ERROR != rc  && read_packet_type != packet_type);

    if(MQTT_NETWORK_DISCONNECTED_ERROR != rc && read_packet_type != packet_type) {
        return FAILURE;
    8604:	2001      	movs	r0, #1
    8606:	4240      	negs	r0, r0
    }

    /* Something failed or we didn't receive the expected packet, return error code */
    return rc;
}
    8608:	b004      	add	sp, #16
    860a:	bc04      	pop	{r2}
    860c:	4690      	mov	r8, r2
    860e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8610:	00007b15 	.word	0x00007b15
    8614:	00008519 	.word	0x00008519

00008618 <MQTTConnect>:

MQTTReturnCode MQTTConnect(Client *c, MQTTPacket_connectData *options) {
    8618:	b570      	push	{r4, r5, r6, lr}
    861a:	b088      	sub	sp, #32
    861c:	0004      	movs	r4, r0
    861e:	000d      	movs	r5, r1
    if(NULL == c) {
    8620:	2800      	cmp	r0, #0
    8622:	d069      	beq.n	86f8 <MQTTConnect+0xe0>
        return MQTT_NULL_VALUE_ERROR;
    }

    Timer connect_timer;
    MQTTReturnCode connack_rc = FAILURE;
    8624:	22ff      	movs	r2, #255	; 0xff
    8626:	2317      	movs	r3, #23
    8628:	446b      	add	r3, sp
    862a:	701a      	strb	r2, [r3, #0]
    char sessionPresent = 0;
    862c:	2300      	movs	r3, #0
    862e:	3ae9      	subs	r2, #233	; 0xe9
    8630:	446a      	add	r2, sp
    8632:	7013      	strb	r3, [r2, #0]
    uint32_t len = 0;
    8634:	9304      	str	r3, [sp, #16]
    MQTTReturnCode rc = FAILURE;

    InitTimer(&connect_timer);
    8636:	a806      	add	r0, sp, #24
    8638:	4b38      	ldr	r3, [pc, #224]	; (871c <MQTTConnect+0x104>)
    863a:	4798      	blx	r3
    countdown_ms(&connect_timer, c->commandTimeoutMs);
    863c:	68a1      	ldr	r1, [r4, #8]
    863e:	a806      	add	r0, sp, #24
    8640:	4b37      	ldr	r3, [pc, #220]	; (8720 <MQTTConnect+0x108>)
    8642:	4798      	blx	r3

    if(c->isConnected) {
    8644:	7823      	ldrb	r3, [r4, #0]
    8646:	2b00      	cmp	r3, #0
    8648:	d159      	bne.n	86fe <MQTTConnect+0xe6>
        /* Don't send connect packet again if we are already connected */
        return MQTT_NETWORK_ALREADY_CONNECTED_ERROR;
    }

    if(NULL != options) {
    864a:	2d00      	cmp	r5, #0
    864c:	d004      	beq.n	8658 <MQTTConnect+0x40>
        /* override default options if new options were supplied */
        copyMQTTConnectData(&(c->options), options);
    864e:	0020      	movs	r0, r4
    8650:	3044      	adds	r0, #68	; 0x44
    8652:	0029      	movs	r1, r5
    8654:	4b33      	ldr	r3, [pc, #204]	; (8724 <MQTTConnect+0x10c>)
    8656:	4798      	blx	r3
    }

    c->networkInitHandler(&(c->networkStack));
    8658:	0025      	movs	r5, r4
    865a:	3598      	adds	r5, #152	; 0x98
    865c:	238e      	movs	r3, #142	; 0x8e
    865e:	005b      	lsls	r3, r3, #1
    8660:	58e3      	ldr	r3, [r4, r3]
    8662:	0028      	movs	r0, r5
    8664:	4798      	blx	r3
    rc = c->networkStack.connect(&(c->networkStack), c->tlsConnectParams);
    8666:	0023      	movs	r3, r4
    8668:	3334      	adds	r3, #52	; 0x34
    866a:	466a      	mov	r2, sp
    866c:	cb43      	ldmia	r3!, {r0, r1, r6}
    866e:	c243      	stmia	r2!, {r0, r1, r6}
    8670:	681b      	ldr	r3, [r3, #0]
    8672:	6013      	str	r3, [r2, #0]
    8674:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    8676:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    8678:	6b23      	ldr	r3, [r4, #48]	; 0x30
    867a:	209c      	movs	r0, #156	; 0x9c
    867c:	5826      	ldr	r6, [r4, r0]
    867e:	0028      	movs	r0, r5
    8680:	47b0      	blx	r6
    if(0 != rc) {
    8682:	b240      	sxtb	r0, r0
    8684:	2800      	cmp	r0, #0
    8686:	d13d      	bne.n	8704 <MQTTConnect+0xec>
        /* TLS Connect failed, return error */
        return FAILURE;
    }

    c->keepAliveInterval = c->options.keepAliveInterval;
    8688:	2358      	movs	r3, #88	; 0x58
    868a:	5ae3      	ldrh	r3, [r4, r3]
    868c:	60e3      	str	r3, [r4, #12]
    rc = MQTTSerialize_connect(c->buf, c->bufSize, &(c->options), &len);
    868e:	0022      	movs	r2, r4
    8690:	3244      	adds	r2, #68	; 0x44
    8692:	ab04      	add	r3, sp, #16
    8694:	69a1      	ldr	r1, [r4, #24]
    8696:	6a20      	ldr	r0, [r4, #32]
    8698:	4d23      	ldr	r5, [pc, #140]	; (8728 <MQTTConnect+0x110>)
    869a:	47a8      	blx	r5
    if(SUCCESS != rc || 0 >= len) {
    869c:	2800      	cmp	r0, #0
    869e:	d134      	bne.n	870a <MQTTConnect+0xf2>
    86a0:	9904      	ldr	r1, [sp, #16]
    86a2:	2900      	cmp	r1, #0
    86a4:	d034      	beq.n	8710 <MQTTConnect+0xf8>
        return FAILURE;
    }

    /* send the connect packet */
    rc = sendPacket(c, len, &connect_timer);
    86a6:	aa06      	add	r2, sp, #24
    86a8:	0020      	movs	r0, r4
    86aa:	4b20      	ldr	r3, [pc, #128]	; (872c <MQTTConnect+0x114>)
    86ac:	4798      	blx	r3
    if(SUCCESS != rc) {
        return rc;
    86ae:	1e03      	subs	r3, r0, #0
        return FAILURE;
    }

    /* send the connect packet */
    rc = sendPacket(c, len, &connect_timer);
    if(SUCCESS != rc) {
    86b0:	d130      	bne.n	8714 <MQTTConnect+0xfc>
        return rc;
    }

    /* this will be a blocking call, wait for the CONNACK */
    rc = waitfor(c, CONNACK, &connect_timer);
    86b2:	aa06      	add	r2, sp, #24
    86b4:	2102      	movs	r1, #2
    86b6:	0020      	movs	r0, r4
    86b8:	4b1d      	ldr	r3, [pc, #116]	; (8730 <MQTTConnect+0x118>)
    86ba:	4798      	blx	r3
    if(SUCCESS != rc) {
        return rc;
    86bc:	1e03      	subs	r3, r0, #0
        return rc;
    }

    /* this will be a blocking call, wait for the CONNACK */
    rc = waitfor(c, CONNACK, &connect_timer);
    if(SUCCESS != rc) {
    86be:	d129      	bne.n	8714 <MQTTConnect+0xfc>
        return rc;
    }

    /* Received CONNACK, check the return code */
    rc = MQTTDeserialize_connack((unsigned char *)&sessionPresent, &connack_rc, c->readbuf, c->readBufSize);
    86c0:	69e3      	ldr	r3, [r4, #28]
    86c2:	6a62      	ldr	r2, [r4, #36]	; 0x24
    86c4:	2117      	movs	r1, #23
    86c6:	4469      	add	r1, sp
    86c8:	3016      	adds	r0, #22
    86ca:	4468      	add	r0, sp
    86cc:	4d19      	ldr	r5, [pc, #100]	; (8734 <MQTTConnect+0x11c>)
    86ce:	47a8      	blx	r5
    if(SUCCESS != rc) {
        return rc;
    86d0:	1e03      	subs	r3, r0, #0
        return rc;
    }

    /* Received CONNACK, check the return code */
    rc = MQTTDeserialize_connack((unsigned char *)&sessionPresent, &connack_rc, c->readbuf, c->readBufSize);
    if(SUCCESS != rc) {
    86d2:	d11f      	bne.n	8714 <MQTTConnect+0xfc>
        return rc;
    }

    if(MQTT_CONNACK_CONNECTION_ACCEPTED != connack_rc) {
    86d4:	2317      	movs	r3, #23
    86d6:	446b      	add	r3, sp
    86d8:	781b      	ldrb	r3, [r3, #0]
    86da:	b25b      	sxtb	r3, r3
    86dc:	2b04      	cmp	r3, #4
    86de:	d119      	bne.n	8714 <MQTTConnect+0xfc>
        return connack_rc;
    }

    c->isConnected = 1;
    86e0:	3b03      	subs	r3, #3
    86e2:	7023      	strb	r3, [r4, #0]
    c->wasManuallyDisconnected = 0;
    86e4:	2300      	movs	r3, #0
    86e6:	7063      	strb	r3, [r4, #1]
    c->isPingOutstanding = 0;
    86e8:	70a3      	strb	r3, [r4, #2]
    countdown(&c->pingTimer, c->keepAliveInterval);
    86ea:	68e1      	ldr	r1, [r4, #12]
    86ec:	0020      	movs	r0, r4
    86ee:	30b4      	adds	r0, #180	; 0xb4
    86f0:	4b11      	ldr	r3, [pc, #68]	; (8738 <MQTTConnect+0x120>)
    86f2:	4798      	blx	r3

    return SUCCESS;
    86f4:	2300      	movs	r3, #0
    86f6:	e00d      	b.n	8714 <MQTTConnect+0xfc>
    return rc;
}

MQTTReturnCode MQTTConnect(Client *c, MQTTPacket_connectData *options) {
    if(NULL == c) {
        return MQTT_NULL_VALUE_ERROR;
    86f8:	2306      	movs	r3, #6
    86fa:	425b      	negs	r3, r3
    86fc:	e00a      	b.n	8714 <MQTTConnect+0xfc>
    InitTimer(&connect_timer);
    countdown_ms(&connect_timer, c->commandTimeoutMs);

    if(c->isConnected) {
        /* Don't send connect packet again if we are already connected */
        return MQTT_NETWORK_ALREADY_CONNECTED_ERROR;
    86fe:	2305      	movs	r3, #5
    8700:	425b      	negs	r3, r3
    8702:	e007      	b.n	8714 <MQTTConnect+0xfc>

    c->networkInitHandler(&(c->networkStack));
    rc = c->networkStack.connect(&(c->networkStack), c->tlsConnectParams);
    if(0 != rc) {
        /* TLS Connect failed, return error */
        return FAILURE;
    8704:	2301      	movs	r3, #1
    8706:	425b      	negs	r3, r3
    8708:	e004      	b.n	8714 <MQTTConnect+0xfc>
    }

    c->keepAliveInterval = c->options.keepAliveInterval;
    rc = MQTTSerialize_connect(c->buf, c->bufSize, &(c->options), &len);
    if(SUCCESS != rc || 0 >= len) {
        return FAILURE;
    870a:	2301      	movs	r3, #1
    870c:	425b      	negs	r3, r3
    870e:	e001      	b.n	8714 <MQTTConnect+0xfc>
    8710:	2301      	movs	r3, #1
    8712:	425b      	negs	r3, r3
    c->wasManuallyDisconnected = 0;
    c->isPingOutstanding = 0;
    countdown(&c->pingTimer, c->keepAliveInterval);

    return SUCCESS;
}
    8714:	0018      	movs	r0, r3
    8716:	b008      	add	sp, #32
    8718:	bd70      	pop	{r4, r5, r6, pc}
    871a:	46c0      	nop			; (mov r8, r8)
    871c:	00007b95 	.word	0x00007b95
    8720:	00007b35 	.word	0x00007b35
    8724:	00007ff5 	.word	0x00007ff5
    8728:	00008e55 	.word	0x00008e55
    872c:	00007f5d 	.word	0x00007f5d
    8730:	00008599 	.word	0x00008599
    8734:	00008fe9 	.word	0x00008fe9
    8738:	00007b55 	.word	0x00007b55

0000873c <GetFreeMessageHandlerIndex>:

/* Return MAX_MESSAGE_HANDLERS value if no free index is available */
uint32_t GetFreeMessageHandlerIndex(Client *c) {
    uint32_t itr;
    for(itr = 0; itr < MAX_MESSAGE_HANDLERS; itr++) {
        if(c->messageHandlers[itr].topicFilter == NULL) {
    873c:	23c4      	movs	r3, #196	; 0xc4
    873e:	58c3      	ldr	r3, [r0, r3]
    8740:	2b00      	cmp	r3, #0
    8742:	d00a      	beq.n	875a <GetFreeMessageHandlerIndex+0x1e>
    8744:	0003      	movs	r3, r0
    8746:	33d4      	adds	r3, #212	; 0xd4
}

/* Return MAX_MESSAGE_HANDLERS value if no free index is available */
uint32_t GetFreeMessageHandlerIndex(Client *c) {
    uint32_t itr;
    for(itr = 0; itr < MAX_MESSAGE_HANDLERS; itr++) {
    8748:	2001      	movs	r0, #1
        if(c->messageHandlers[itr].topicFilter == NULL) {
    874a:	681a      	ldr	r2, [r3, #0]
    874c:	2a00      	cmp	r2, #0
    874e:	d005      	beq.n	875c <GetFreeMessageHandlerIndex+0x20>
}

/* Return MAX_MESSAGE_HANDLERS value if no free index is available */
uint32_t GetFreeMessageHandlerIndex(Client *c) {
    uint32_t itr;
    for(itr = 0; itr < MAX_MESSAGE_HANDLERS; itr++) {
    8750:	3001      	adds	r0, #1
    8752:	3310      	adds	r3, #16
    8754:	2805      	cmp	r0, #5
    8756:	d1f8      	bne.n	874a <GetFreeMessageHandlerIndex+0xe>
    8758:	e000      	b.n	875c <GetFreeMessageHandlerIndex+0x20>
    875a:	2000      	movs	r0, #0
            break;
        }
    }

    return itr;
}
    875c:	4770      	bx	lr
    875e:	46c0      	nop			; (mov r8, r8)

00008760 <MQTTSubscribe>:

MQTTReturnCode MQTTSubscribe(Client *c, const char *topicFilter, QoS qos,
                  messageHandler messageHandler, pApplicationHandler_t applicationHandler) {
    8760:	b5f0      	push	{r4, r5, r6, r7, lr}
    8762:	464f      	mov	r7, r9
    8764:	4646      	mov	r6, r8
    8766:	b4c0      	push	{r6, r7}
    8768:	b091      	sub	sp, #68	; 0x44
    876a:	0004      	movs	r4, r0
    876c:	000e      	movs	r6, r1
    876e:	001f      	movs	r7, r3
    8770:	2317      	movs	r3, #23
    8772:	446b      	add	r3, sp
    8774:	701a      	strb	r2, [r3, #0]
    if(NULL == c || NULL == topicFilter
    8776:	2800      	cmp	r0, #0
    8778:	d065      	beq.n	8846 <MQTTSubscribe+0xe6>
    877a:	2900      	cmp	r1, #0
    877c:	d066      	beq.n	884c <MQTTSubscribe+0xec>
       || NULL == messageHandler || NULL == applicationHandler) {
    877e:	2f00      	cmp	r7, #0
    8780:	d067      	beq.n	8852 <MQTTSubscribe+0xf2>
    8782:	9b18      	ldr	r3, [sp, #96]	; 0x60
    8784:	2b00      	cmp	r3, #0
    8786:	d067      	beq.n	8858 <MQTTSubscribe+0xf8>
        return MQTT_NULL_VALUE_ERROR;
    }

    if(!c->isConnected) {
    8788:	7803      	ldrb	r3, [r0, #0]
    878a:	2b00      	cmp	r3, #0
    878c:	d067      	beq.n	885e <MQTTSubscribe+0xfe>
        return MQTT_NETWORK_DISCONNECTED_ERROR;
    }

    MQTTReturnCode rc = FAILURE;
    Timer timer;
    uint32_t len = 0;
    878e:	2300      	movs	r3, #0
    8790:	930d      	str	r3, [sp, #52]	; 0x34
    uint32_t indexOfFreeMessageHandler;
    uint32_t count = 0;
    8792:	930c      	str	r3, [sp, #48]	; 0x30
    QoS grantedQoS[3] = {QOS0, QOS0, QOS0};
    8794:	aa0b      	add	r2, sp, #44	; 0x2c
    8796:	7013      	strb	r3, [r2, #0]
    8798:	7053      	strb	r3, [r2, #1]
    879a:	7093      	strb	r3, [r2, #2]
    uint16_t packetId;

    MQTTString topic = MQTTString_initializer;
    879c:	ad07      	add	r5, sp, #28
    879e:	9308      	str	r3, [sp, #32]
    87a0:	9309      	str	r3, [sp, #36]	; 0x24
    topic.cstring = (char *)topicFilter;
    87a2:	9107      	str	r1, [sp, #28]

    InitTimer(&timer);
    87a4:	a80e      	add	r0, sp, #56	; 0x38
    87a6:	4b33      	ldr	r3, [pc, #204]	; (8874 <MQTTSubscribe+0x114>)
    87a8:	4798      	blx	r3
    countdown_ms(&timer, c->commandTimeoutMs);
    87aa:	68a1      	ldr	r1, [r4, #8]
    87ac:	a80e      	add	r0, sp, #56	; 0x38
    87ae:	4b32      	ldr	r3, [pc, #200]	; (8878 <MQTTSubscribe+0x118>)
    87b0:	4798      	blx	r3

    rc = MQTTSerialize_subscribe(c->buf, c->bufSize, 0, getNextPacketId(c), 1, &topic, &qos, &len);
    87b2:	6a23      	ldr	r3, [r4, #32]
    87b4:	4698      	mov	r8, r3
    87b6:	69a3      	ldr	r3, [r4, #24]
    87b8:	4699      	mov	r9, r3
    87ba:	0020      	movs	r0, r4
    87bc:	4b2f      	ldr	r3, [pc, #188]	; (887c <MQTTSubscribe+0x11c>)
    87be:	4798      	blx	r3
    87c0:	0003      	movs	r3, r0
    87c2:	aa0d      	add	r2, sp, #52	; 0x34
    87c4:	9203      	str	r2, [sp, #12]
    87c6:	2217      	movs	r2, #23
    87c8:	446a      	add	r2, sp
    87ca:	9202      	str	r2, [sp, #8]
    87cc:	9501      	str	r5, [sp, #4]
    87ce:	2201      	movs	r2, #1
    87d0:	9200      	str	r2, [sp, #0]
    87d2:	2200      	movs	r2, #0
    87d4:	4649      	mov	r1, r9
    87d6:	4640      	mov	r0, r8
    87d8:	4d29      	ldr	r5, [pc, #164]	; (8880 <MQTTSubscribe+0x120>)
    87da:	47a8      	blx	r5
    if(SUCCESS != rc) {
        return rc;
    87dc:	1e03      	subs	r3, r0, #0

    InitTimer(&timer);
    countdown_ms(&timer, c->commandTimeoutMs);

    rc = MQTTSerialize_subscribe(c->buf, c->bufSize, 0, getNextPacketId(c), 1, &topic, &qos, &len);
    if(SUCCESS != rc) {
    87de:	d143      	bne.n	8868 <MQTTSubscribe+0x108>
        return rc;
    }

    indexOfFreeMessageHandler = GetFreeMessageHandlerIndex(c);
    87e0:	0020      	movs	r0, r4
    87e2:	4b28      	ldr	r3, [pc, #160]	; (8884 <MQTTSubscribe+0x124>)
    87e4:	4798      	blx	r3
    87e6:	4681      	mov	r9, r0
    if(MAX_MESSAGE_HANDLERS <= indexOfFreeMessageHandler) {
    87e8:	2804      	cmp	r0, #4
    87ea:	d83b      	bhi.n	8864 <MQTTSubscribe+0x104>
        return MQTT_MAX_SUBSCRIPTIONS_REACHED_ERROR;
    }

    /* send the subscribe packet */
    rc = sendPacket(c, len, &timer);
    87ec:	aa0e      	add	r2, sp, #56	; 0x38
    87ee:	990d      	ldr	r1, [sp, #52]	; 0x34
    87f0:	0020      	movs	r0, r4
    87f2:	4b25      	ldr	r3, [pc, #148]	; (8888 <MQTTSubscribe+0x128>)
    87f4:	4798      	blx	r3
    if(SUCCESS != rc) {
        return rc;
    87f6:	1e03      	subs	r3, r0, #0
        return MQTT_MAX_SUBSCRIPTIONS_REACHED_ERROR;
    }

    /* send the subscribe packet */
    rc = sendPacket(c, len, &timer);
    if(SUCCESS != rc) {
    87f8:	d136      	bne.n	8868 <MQTTSubscribe+0x108>
        return rc;
    }

    /* wait for suback */
    rc = waitfor(c, SUBACK, &timer);
    87fa:	aa0e      	add	r2, sp, #56	; 0x38
    87fc:	2109      	movs	r1, #9
    87fe:	0020      	movs	r0, r4
    8800:	4b22      	ldr	r3, [pc, #136]	; (888c <MQTTSubscribe+0x12c>)
    8802:	4798      	blx	r3
    if(SUCCESS != rc) {
        return rc;
    8804:	1e03      	subs	r3, r0, #0
        return rc;
    }

    /* wait for suback */
    rc = waitfor(c, SUBACK, &timer);
    if(SUCCESS != rc) {
    8806:	d12f      	bne.n	8868 <MQTTSubscribe+0x108>
        return rc;
    }

    /* Granted QoS can be 0, 1 or 2 */
    rc = MQTTDeserialize_suback(&packetId, 1, &count, grantedQoS, c->readbuf, c->readBufSize);
    8808:	69e3      	ldr	r3, [r4, #28]
    880a:	9301      	str	r3, [sp, #4]
    880c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    880e:	9300      	str	r3, [sp, #0]
    8810:	ab0b      	add	r3, sp, #44	; 0x2c
    8812:	aa0c      	add	r2, sp, #48	; 0x30
    8814:	2101      	movs	r1, #1
    8816:	302a      	adds	r0, #42	; 0x2a
    8818:	4468      	add	r0, sp
    881a:	4d1d      	ldr	r5, [pc, #116]	; (8890 <MQTTSubscribe+0x130>)
    881c:	47a8      	blx	r5
    if(SUCCESS != rc) {
        return rc;
    881e:	1e03      	subs	r3, r0, #0
        return rc;
    }

    /* Granted QoS can be 0, 1 or 2 */
    rc = MQTTDeserialize_suback(&packetId, 1, &count, grantedQoS, c->readbuf, c->readBufSize);
    if(SUCCESS != rc) {
    8820:	d122      	bne.n	8868 <MQTTSubscribe+0x108>
    8822:	464b      	mov	r3, r9
    8824:	011d      	lsls	r5, r3, #4
    8826:	1964      	adds	r4, r4, r5
        return rc;
    }

    c->messageHandlers[indexOfFreeMessageHandler].topicFilter =
    8828:	23c4      	movs	r3, #196	; 0xc4
    882a:	50e6      	str	r6, [r4, r3]
            topicFilter;
    c->messageHandlers[indexOfFreeMessageHandler].fp = messageHandler;
    882c:	3304      	adds	r3, #4
    882e:	50e7      	str	r7, [r4, r3]
    c->messageHandlers[indexOfFreeMessageHandler].applicationHandler =
    8830:	0023      	movs	r3, r4
    8832:	33cc      	adds	r3, #204	; 0xcc
    8834:	9a18      	ldr	r2, [sp, #96]	; 0x60
    8836:	601a      	str	r2, [r3, #0]
            applicationHandler;
    c->messageHandlers[indexOfFreeMessageHandler].qos = qos;
    8838:	34d0      	adds	r4, #208	; 0xd0
    883a:	2317      	movs	r3, #23
    883c:	446b      	add	r3, sp
    883e:	781b      	ldrb	r3, [r3, #0]
    8840:	7023      	strb	r3, [r4, #0]

    return SUCCESS;
    8842:	0003      	movs	r3, r0
    8844:	e010      	b.n	8868 <MQTTSubscribe+0x108>

MQTTReturnCode MQTTSubscribe(Client *c, const char *topicFilter, QoS qos,
                  messageHandler messageHandler, pApplicationHandler_t applicationHandler) {
    if(NULL == c || NULL == topicFilter
       || NULL == messageHandler || NULL == applicationHandler) {
        return MQTT_NULL_VALUE_ERROR;
    8846:	2306      	movs	r3, #6
    8848:	425b      	negs	r3, r3
    884a:	e00d      	b.n	8868 <MQTTSubscribe+0x108>
    884c:	2306      	movs	r3, #6
    884e:	425b      	negs	r3, r3
    8850:	e00a      	b.n	8868 <MQTTSubscribe+0x108>
    8852:	2306      	movs	r3, #6
    8854:	425b      	negs	r3, r3
    8856:	e007      	b.n	8868 <MQTTSubscribe+0x108>
    8858:	2306      	movs	r3, #6
    885a:	425b      	negs	r3, r3
    885c:	e004      	b.n	8868 <MQTTSubscribe+0x108>
    }

    if(!c->isConnected) {
        return MQTT_NETWORK_DISCONNECTED_ERROR;
    885e:	2304      	movs	r3, #4
    8860:	425b      	negs	r3, r3
    8862:	e001      	b.n	8868 <MQTTSubscribe+0x108>
        return rc;
    }

    indexOfFreeMessageHandler = GetFreeMessageHandlerIndex(c);
    if(MAX_MESSAGE_HANDLERS <= indexOfFreeMessageHandler) {
        return MQTT_MAX_SUBSCRIPTIONS_REACHED_ERROR;
    8864:	2307      	movs	r3, #7
    8866:	425b      	negs	r3, r3
    c->messageHandlers[indexOfFreeMessageHandler].applicationHandler =
            applicationHandler;
    c->messageHandlers[indexOfFreeMessageHandler].qos = qos;

    return SUCCESS;
}
    8868:	0018      	movs	r0, r3
    886a:	b011      	add	sp, #68	; 0x44
    886c:	bc0c      	pop	{r2, r3}
    886e:	4690      	mov	r8, r2
    8870:	4699      	mov	r9, r3
    8872:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8874:	00007b95 	.word	0x00007b95
    8878:	00007b35 	.word	0x00007b35
    887c:	00007f41 	.word	0x00007f41
    8880:	0000989d 	.word	0x0000989d
    8884:	0000873d 	.word	0x0000873d
    8888:	00007f5d 	.word	0x00007f5d
    888c:	00008599 	.word	0x00008599
    8890:	0000997d 	.word	0x0000997d

00008894 <MQTTResubscribe>:

MQTTReturnCode MQTTResubscribe(Client *c) {
    8894:	b5f0      	push	{r4, r5, r6, r7, lr}
    8896:	465f      	mov	r7, fp
    8898:	4656      	mov	r6, sl
    889a:	464d      	mov	r5, r9
    889c:	4644      	mov	r4, r8
    889e:	b4f0      	push	{r4, r5, r6, r7}
    88a0:	b091      	sub	sp, #68	; 0x44
    88a2:	1e04      	subs	r4, r0, #0
    if(NULL == c) {
    88a4:	d05b      	beq.n	895e <MQTTResubscribe+0xca>
        return MQTT_NULL_VALUE_ERROR;
    }

    if(!c->isConnected) {
    88a6:	7803      	ldrb	r3, [r0, #0]
    88a8:	2b00      	cmp	r3, #0
    88aa:	d05b      	beq.n	8964 <MQTTResubscribe+0xd0>
        return MQTT_NETWORK_DISCONNECTED_ERROR;
    }

    MQTTReturnCode rc = FAILURE;
    Timer timer;
    uint32_t len = 0;
    88ac:	2300      	movs	r3, #0
    88ae:	930d      	str	r3, [sp, #52]	; 0x34
    uint32_t count = 0;
    88b0:	930c      	str	r3, [sp, #48]	; 0x30
    QoS grantedQoS[3] = {QOS0, QOS0, QOS0};
    88b2:	aa0b      	add	r2, sp, #44	; 0x2c
    88b4:	7013      	strb	r3, [r2, #0]
    88b6:	7053      	strb	r3, [r2, #1]
    88b8:	7093      	strb	r3, [r2, #2]
    uint16_t packetId;
    uint32_t existingSubCount = GetFreeMessageHandlerIndex(c);
    88ba:	4b30      	ldr	r3, [pc, #192]	; (897c <MQTTResubscribe+0xe8>)
    88bc:	4798      	blx	r3
    88be:	4683      	mov	fp, r0
    uint32_t itr = 0;

    for(itr = 0; itr < existingSubCount; itr++) {
    88c0:	2800      	cmp	r0, #0
    88c2:	d052      	beq.n	896a <MQTTResubscribe+0xd6>
    88c4:	0026      	movs	r6, r4
    88c6:	36d0      	adds	r6, #208	; 0xd0
    88c8:	2300      	movs	r3, #0
    88ca:	9305      	str	r3, [sp, #20]
        MQTTString topic = MQTTString_initializer;
    88cc:	ad07      	add	r5, sp, #28
    88ce:	4698      	mov	r8, r3
    88d0:	4643      	mov	r3, r8
    88d2:	606b      	str	r3, [r5, #4]
    88d4:	60ab      	str	r3, [r5, #8]
        topic.cstring = (char *)c->messageHandlers[itr].topicFilter;
    88d6:	0033      	movs	r3, r6
    88d8:	3b0c      	subs	r3, #12
    88da:	681b      	ldr	r3, [r3, #0]
    88dc:	602b      	str	r3, [r5, #0]

        InitTimer(&timer);
    88de:	a80e      	add	r0, sp, #56	; 0x38
    88e0:	4b27      	ldr	r3, [pc, #156]	; (8980 <MQTTResubscribe+0xec>)
    88e2:	4798      	blx	r3
        countdown_ms(&timer, c->commandTimeoutMs);
    88e4:	68a1      	ldr	r1, [r4, #8]
    88e6:	a80e      	add	r0, sp, #56	; 0x38
    88e8:	4b26      	ldr	r3, [pc, #152]	; (8984 <MQTTResubscribe+0xf0>)
    88ea:	4798      	blx	r3

        rc = MQTTSerialize_subscribe(c->buf, c->bufSize, 0, getNextPacketId(c), 1,
    88ec:	6a23      	ldr	r3, [r4, #32]
    88ee:	4699      	mov	r9, r3
    88f0:	69a3      	ldr	r3, [r4, #24]
    88f2:	469a      	mov	sl, r3
    88f4:	0020      	movs	r0, r4
    88f6:	4b24      	ldr	r3, [pc, #144]	; (8988 <MQTTResubscribe+0xf4>)
    88f8:	4798      	blx	r3
    88fa:	0003      	movs	r3, r0
    88fc:	aa0d      	add	r2, sp, #52	; 0x34
    88fe:	9203      	str	r2, [sp, #12]
    8900:	9602      	str	r6, [sp, #8]
    8902:	9501      	str	r5, [sp, #4]
    8904:	2201      	movs	r2, #1
    8906:	9200      	str	r2, [sp, #0]
    8908:	2200      	movs	r2, #0
    890a:	4651      	mov	r1, sl
    890c:	4648      	mov	r0, r9
    890e:	4f1f      	ldr	r7, [pc, #124]	; (898c <MQTTResubscribe+0xf8>)
    8910:	47b8      	blx	r7
                                     &topic, &(c->messageHandlers[itr].qos), &len);
        if(SUCCESS != rc) {
    8912:	2800      	cmp	r0, #0
    8914:	d12a      	bne.n	896c <MQTTResubscribe+0xd8>
            return rc;
        }

        /* send the subscribe packet */
        rc = sendPacket(c, len, &timer);
    8916:	aa0e      	add	r2, sp, #56	; 0x38
    8918:	990d      	ldr	r1, [sp, #52]	; 0x34
    891a:	0020      	movs	r0, r4
    891c:	4b1c      	ldr	r3, [pc, #112]	; (8990 <MQTTResubscribe+0xfc>)
    891e:	4798      	blx	r3
        if(SUCCESS != rc) {
    8920:	2800      	cmp	r0, #0
    8922:	d123      	bne.n	896c <MQTTResubscribe+0xd8>
            return rc;
        }

        /* wait for suback */
        rc = waitfor(c, SUBACK, &timer);
    8924:	aa0e      	add	r2, sp, #56	; 0x38
    8926:	2109      	movs	r1, #9
    8928:	0020      	movs	r0, r4
    892a:	4b1a      	ldr	r3, [pc, #104]	; (8994 <MQTTResubscribe+0x100>)
    892c:	4798      	blx	r3
        if(SUCCESS != rc) {
    892e:	2800      	cmp	r0, #0
    8930:	d11c      	bne.n	896c <MQTTResubscribe+0xd8>
            return rc;
        }

        /* Granted QoS can be 0, 1 or 2 */
        rc = MQTTDeserialize_suback(&packetId, 1, &count, grantedQoS, c->readbuf, c->readBufSize);
    8932:	69e3      	ldr	r3, [r4, #28]
    8934:	9301      	str	r3, [sp, #4]
    8936:	6a63      	ldr	r3, [r4, #36]	; 0x24
    8938:	9300      	str	r3, [sp, #0]
    893a:	ab0b      	add	r3, sp, #44	; 0x2c
    893c:	aa0c      	add	r2, sp, #48	; 0x30
    893e:	2101      	movs	r1, #1
    8940:	3022      	adds	r0, #34	; 0x22
    8942:	af02      	add	r7, sp, #8
    8944:	46bc      	mov	ip, r7
    8946:	4460      	add	r0, ip
    8948:	4f13      	ldr	r7, [pc, #76]	; (8998 <MQTTResubscribe+0x104>)
    894a:	47b8      	blx	r7
        if(SUCCESS != rc) {
    894c:	2800      	cmp	r0, #0
    894e:	d10d      	bne.n	896c <MQTTResubscribe+0xd8>
    QoS grantedQoS[3] = {QOS0, QOS0, QOS0};
    uint16_t packetId;
    uint32_t existingSubCount = GetFreeMessageHandlerIndex(c);
    uint32_t itr = 0;

    for(itr = 0; itr < existingSubCount; itr++) {
    8950:	9b05      	ldr	r3, [sp, #20]
    8952:	3301      	adds	r3, #1
    8954:	9305      	str	r3, [sp, #20]
    8956:	3610      	adds	r6, #16
    8958:	459b      	cmp	fp, r3
    895a:	d1b9      	bne.n	88d0 <MQTTResubscribe+0x3c>
    895c:	e006      	b.n	896c <MQTTResubscribe+0xd8>
    return SUCCESS;
}

MQTTReturnCode MQTTResubscribe(Client *c) {
    if(NULL == c) {
        return MQTT_NULL_VALUE_ERROR;
    895e:	2006      	movs	r0, #6
    8960:	4240      	negs	r0, r0
    8962:	e003      	b.n	896c <MQTTResubscribe+0xd8>
    }

    if(!c->isConnected) {
        return MQTT_NETWORK_DISCONNECTED_ERROR;
    8964:	2004      	movs	r0, #4
    8966:	4240      	negs	r0, r0
    8968:	e000      	b.n	896c <MQTTResubscribe+0xd8>
        if(SUCCESS != rc) {
            return rc;
        }
    }

    return SUCCESS;
    896a:	2000      	movs	r0, #0
}
    896c:	b011      	add	sp, #68	; 0x44
    896e:	bc3c      	pop	{r2, r3, r4, r5}
    8970:	4690      	mov	r8, r2
    8972:	4699      	mov	r9, r3
    8974:	46a2      	mov	sl, r4
    8976:	46ab      	mov	fp, r5
    8978:	bdf0      	pop	{r4, r5, r6, r7, pc}
    897a:	46c0      	nop			; (mov r8, r8)
    897c:	0000873d 	.word	0x0000873d
    8980:	00007b95 	.word	0x00007b95
    8984:	00007b35 	.word	0x00007b35
    8988:	00007f41 	.word	0x00007f41
    898c:	0000989d 	.word	0x0000989d
    8990:	00007f5d 	.word	0x00007f5d
    8994:	00008599 	.word	0x00008599
    8998:	0000997d 	.word	0x0000997d

0000899c <MQTTAttemptReconnect>:
    /* Reset to 0 since this was not a manual disconnect */
    c->wasManuallyDisconnected = 0;
    return MQTT_NETWORK_DISCONNECTED_ERROR;
}

MQTTReturnCode MQTTAttemptReconnect(Client *c) {
    899c:	b510      	push	{r4, lr}
    899e:	1e04      	subs	r4, r0, #0
    if(NULL == c) {
    89a0:	d012      	beq.n	89c8 <MQTTAttemptReconnect+0x2c>
        return MQTT_NULL_VALUE_ERROR;
    }

    if(1 == c->isConnected) {
    89a2:	7803      	ldrb	r3, [r0, #0]
    89a4:	2b01      	cmp	r3, #1
    89a6:	d012      	beq.n	89ce <MQTTAttemptReconnect+0x32>
    }

    MQTTReturnCode rc = MQTT_ATTEMPTING_RECONNECT;

    /* Ignoring return code. failures expected if network is disconnected */
    rc = MQTTConnect(c, NULL);
    89a8:	2100      	movs	r1, #0
    89aa:	4b0a      	ldr	r3, [pc, #40]	; (89d4 <MQTTAttemptReconnect+0x38>)
    89ac:	4798      	blx	r3

    /* If still disconnected handle disconnect */
    if(0 == c->isConnected) {
    89ae:	7823      	ldrb	r3, [r4, #0]
        return MQTT_ATTEMPTING_RECONNECT;
    89b0:	2003      	movs	r0, #3

    /* Ignoring return code. failures expected if network is disconnected */
    rc = MQTTConnect(c, NULL);

    /* If still disconnected handle disconnect */
    if(0 == c->isConnected) {
    89b2:	2b00      	cmp	r3, #0
    89b4:	d00d      	beq.n	89d2 <MQTTAttemptReconnect+0x36>
        return MQTT_ATTEMPTING_RECONNECT;
    }

    rc = MQTTResubscribe(c);
    89b6:	0020      	movs	r0, r4
    89b8:	4b07      	ldr	r3, [pc, #28]	; (89d8 <MQTTAttemptReconnect+0x3c>)
    89ba:	4798      	blx	r3
    89bc:	0003      	movs	r3, r0
    if(SUCCESS != rc) {
        return rc;
    }

    return MQTT_NETWORK_RECONNECTED;
    89be:	2001      	movs	r0, #1
    if(0 == c->isConnected) {
        return MQTT_ATTEMPTING_RECONNECT;
    }

    rc = MQTTResubscribe(c);
    if(SUCCESS != rc) {
    89c0:	2b00      	cmp	r3, #0
    89c2:	d006      	beq.n	89d2 <MQTTAttemptReconnect+0x36>
        return rc;
    89c4:	0018      	movs	r0, r3
    89c6:	e004      	b.n	89d2 <MQTTAttemptReconnect+0x36>
    return MQTT_NETWORK_DISCONNECTED_ERROR;
}

MQTTReturnCode MQTTAttemptReconnect(Client *c) {
    if(NULL == c) {
        return MQTT_NULL_VALUE_ERROR;
    89c8:	2006      	movs	r0, #6
    89ca:	4240      	negs	r0, r0
    89cc:	e001      	b.n	89d2 <MQTTAttemptReconnect+0x36>
    }

    if(1 == c->isConnected) {
        return MQTT_NETWORK_ALREADY_CONNECTED_ERROR;
    89ce:	2005      	movs	r0, #5
    89d0:	4240      	negs	r0, r0
    if(SUCCESS != rc) {
        return rc;
    }

    return MQTT_NETWORK_RECONNECTED;
}
    89d2:	bd10      	pop	{r4, pc}
    89d4:	00008619 	.word	0x00008619
    89d8:	00008895 	.word	0x00008895

000089dc <handleReconnect>:

MQTTReturnCode handleReconnect(Client *c) {
    89dc:	b570      	push	{r4, r5, r6, lr}
    89de:	1e04      	subs	r4, r0, #0
    if(NULL == c) {
    89e0:	d024      	beq.n	8a2c <handleReconnect+0x50>
        return MQTT_NULL_VALUE_ERROR;
    }

    if(!expired(&(c->reconnectDelayTimer))) {
    89e2:	0006      	movs	r6, r0
    89e4:	36bc      	adds	r6, #188	; 0xbc
    89e6:	0030      	movs	r0, r6
    89e8:	4b15      	ldr	r3, [pc, #84]	; (8a40 <handleReconnect+0x64>)
    89ea:	4798      	blx	r3
        /* Timer has not expired. Not time to attempt reconnect yet.
         * Return attempting reconnect */
        return MQTT_ATTEMPTING_RECONNECT;
    89ec:	2303      	movs	r3, #3
MQTTReturnCode handleReconnect(Client *c) {
    if(NULL == c) {
        return MQTT_NULL_VALUE_ERROR;
    }

    if(!expired(&(c->reconnectDelayTimer))) {
    89ee:	2800      	cmp	r0, #0
    89f0:	d023      	beq.n	8a3a <handleReconnect+0x5e>
         * Return attempting reconnect */
        return MQTT_ATTEMPTING_RECONNECT;
    }

    int8_t isPhysicalLayerConnected = 1;
    if(NULL != c->networkStack.isConnected) {
    89f2:	33a9      	adds	r3, #169	; 0xa9
    89f4:	58e3      	ldr	r3, [r4, r3]
    89f6:	2b00      	cmp	r3, #0
    89f8:	d006      	beq.n	8a08 <handleReconnect+0x2c>
        isPhysicalLayerConnected = (int8_t)c->networkStack.isConnected(&(c->networkStack));
    89fa:	0020      	movs	r0, r4
    89fc:	3098      	adds	r0, #152	; 0x98
    89fe:	4798      	blx	r3
    }

    MQTTReturnCode rc = MQTT_NETWORK_RECONNECTED;
    if(isPhysicalLayerConnected) {
    8a00:	b240      	sxtb	r0, r0
    int8_t isPhysicalLayerConnected = 1;
    if(NULL != c->networkStack.isConnected) {
        isPhysicalLayerConnected = (int8_t)c->networkStack.isConnected(&(c->networkStack));
    }

    MQTTReturnCode rc = MQTT_NETWORK_RECONNECTED;
    8a02:	2501      	movs	r5, #1
    if(isPhysicalLayerConnected) {
    8a04:	2800      	cmp	r0, #0
    8a06:	d005      	beq.n	8a14 <handleReconnect+0x38>
        rc = MQTTAttemptReconnect(c);
    8a08:	0020      	movs	r0, r4
    8a0a:	4b0e      	ldr	r3, [pc, #56]	; (8a44 <handleReconnect+0x68>)
    8a0c:	4798      	blx	r3
    8a0e:	1e05      	subs	r5, r0, #0
        if(MQTT_NETWORK_RECONNECTED == rc) {
    8a10:	2d01      	cmp	r5, #1
    8a12:	d00e      	beq.n	8a32 <handleReconnect+0x56>
            return MQTT_NETWORK_RECONNECTED;
        }
    }

    c->currentReconnectWaitInterval *= 2;
    8a14:	6923      	ldr	r3, [r4, #16]
    8a16:	0059      	lsls	r1, r3, #1
    8a18:	6121      	str	r1, [r4, #16]

    if(MAX_RECONNECT_WAIT_INTERVAL < c->currentReconnectWaitInterval) {
    8a1a:	23fa      	movs	r3, #250	; 0xfa
    8a1c:	015b      	lsls	r3, r3, #5
    8a1e:	4299      	cmp	r1, r3
    8a20:	d809      	bhi.n	8a36 <handleReconnect+0x5a>
        return MQTT_RECONNECT_TIMED_OUT;
    }
    countdown_ms(&(c->reconnectDelayTimer), c->currentReconnectWaitInterval);
    8a22:	0030      	movs	r0, r6
    8a24:	4b08      	ldr	r3, [pc, #32]	; (8a48 <handleReconnect+0x6c>)
    8a26:	4798      	blx	r3
    return rc;
    8a28:	002b      	movs	r3, r5
    8a2a:	e006      	b.n	8a3a <handleReconnect+0x5e>
    return MQTT_NETWORK_RECONNECTED;
}

MQTTReturnCode handleReconnect(Client *c) {
    if(NULL == c) {
        return MQTT_NULL_VALUE_ERROR;
    8a2c:	2306      	movs	r3, #6
    8a2e:	425b      	negs	r3, r3
    8a30:	e003      	b.n	8a3a <handleReconnect+0x5e>

    MQTTReturnCode rc = MQTT_NETWORK_RECONNECTED;
    if(isPhysicalLayerConnected) {
        rc = MQTTAttemptReconnect(c);
        if(MQTT_NETWORK_RECONNECTED == rc) {
            return MQTT_NETWORK_RECONNECTED;
    8a32:	2301      	movs	r3, #1
    8a34:	e001      	b.n	8a3a <handleReconnect+0x5e>
    }

    c->currentReconnectWaitInterval *= 2;

    if(MAX_RECONNECT_WAIT_INTERVAL < c->currentReconnectWaitInterval) {
        return MQTT_RECONNECT_TIMED_OUT;
    8a36:	2308      	movs	r3, #8
    8a38:	425b      	negs	r3, r3
    }
    countdown_ms(&(c->reconnectDelayTimer), c->currentReconnectWaitInterval);
    return rc;
}
    8a3a:	0018      	movs	r0, r3
    8a3c:	bd70      	pop	{r4, r5, r6, pc}
    8a3e:	46c0      	nop			; (mov r8, r8)
    8a40:	00007b15 	.word	0x00007b15
    8a44:	0000899d 	.word	0x0000899d
    8a48:	00007b35 	.word	0x00007b35

00008a4c <MQTTPublish>:
    }

    return SUCCESS;
}

MQTTReturnCode MQTTPublish(Client *c, const char *topicName, MQTTMessage *message) {
    8a4c:	b5f0      	push	{r4, r5, r6, r7, lr}
    8a4e:	464f      	mov	r7, r9
    8a50:	4646      	mov	r6, r8
    8a52:	b4c0      	push	{r6, r7}
    8a54:	b091      	sub	sp, #68	; 0x44
    8a56:	0005      	movs	r5, r0
    8a58:	0014      	movs	r4, r2
    if(NULL == c || NULL == topicName || NULL == message) {
    8a5a:	2800      	cmp	r0, #0
    8a5c:	d05e      	beq.n	8b1c <MQTTPublish+0xd0>
    8a5e:	2900      	cmp	r1, #0
    8a60:	d05f      	beq.n	8b22 <MQTTPublish+0xd6>
    8a62:	2a00      	cmp	r2, #0
    8a64:	d060      	beq.n	8b28 <MQTTPublish+0xdc>
        return MQTT_NULL_VALUE_ERROR;
    }

    if(!c->isConnected) {
    8a66:	7803      	ldrb	r3, [r0, #0]
    8a68:	2b00      	cmp	r3, #0
    8a6a:	d060      	beq.n	8b2e <MQTTPublish+0xe2>
        return MQTT_NETWORK_DISCONNECTED_ERROR;
    }

    Timer timer;
    MQTTString topic = MQTTString_initializer;
    8a6c:	2300      	movs	r3, #0
    8a6e:	930c      	str	r3, [sp, #48]	; 0x30
    8a70:	930d      	str	r3, [sp, #52]	; 0x34
    topic.cstring = (char *)topicName;
    8a72:	910b      	str	r1, [sp, #44]	; 0x2c
    uint32_t len = 0;
    8a74:	930a      	str	r3, [sp, #40]	; 0x28
    uint8_t packetType = PUBACK;
    uint16_t packet_id;
    unsigned char dup, type;
    MQTTReturnCode rc = FAILURE;

    InitTimer(&timer);
    8a76:	a80e      	add	r0, sp, #56	; 0x38
    8a78:	4b30      	ldr	r3, [pc, #192]	; (8b3c <MQTTPublish+0xf0>)
    8a7a:	4798      	blx	r3
    countdown_ms(&timer, c->commandTimeoutMs);
    8a7c:	68a9      	ldr	r1, [r5, #8]
    8a7e:	a80e      	add	r0, sp, #56	; 0x38
    8a80:	4b2f      	ldr	r3, [pc, #188]	; (8b40 <MQTTPublish+0xf4>)
    8a82:	4798      	blx	r3

    if(QOS1 == message->qos || QOS2 == message->qos) {
    8a84:	7823      	ldrb	r3, [r4, #0]
    8a86:	3b01      	subs	r3, #1
    8a88:	2b01      	cmp	r3, #1
    8a8a:	d80b      	bhi.n	8aa4 <MQTTPublish+0x58>
        message->id = getNextPacketId(c);
    8a8c:	0028      	movs	r0, r5
    8a8e:	4b2d      	ldr	r3, [pc, #180]	; (8b44 <MQTTPublish+0xf8>)
    8a90:	4798      	blx	r3
    8a92:	80a0      	strh	r0, [r4, #4]
        waitForAck = 1;
        if(QOS2 == message->qos) {
    8a94:	7823      	ldrb	r3, [r4, #0]
    8a96:	2b02      	cmp	r3, #2
    8a98:	d109      	bne.n	8aae <MQTTPublish+0x62>
            packetType = PUBCOMP;
    8a9a:	3305      	adds	r3, #5
    8a9c:	4699      	mov	r9, r3
    InitTimer(&timer);
    countdown_ms(&timer, c->commandTimeoutMs);

    if(QOS1 == message->qos || QOS2 == message->qos) {
        message->id = getNextPacketId(c);
        waitForAck = 1;
    8a9e:	3b06      	subs	r3, #6
    8aa0:	4698      	mov	r8, r3
    8aa2:	e008      	b.n	8ab6 <MQTTPublish+0x6a>
    Timer timer;
    MQTTString topic = MQTTString_initializer;
    topic.cstring = (char *)topicName;
    uint32_t len = 0;
    uint8_t waitForAck = 0;
    uint8_t packetType = PUBACK;
    8aa4:	2304      	movs	r3, #4
    8aa6:	4699      	mov	r9, r3

    Timer timer;
    MQTTString topic = MQTTString_initializer;
    topic.cstring = (char *)topicName;
    uint32_t len = 0;
    uint8_t waitForAck = 0;
    8aa8:	2300      	movs	r3, #0
    8aaa:	4698      	mov	r8, r3
    8aac:	e003      	b.n	8ab6 <MQTTPublish+0x6a>
    uint8_t packetType = PUBACK;
    8aae:	2304      	movs	r3, #4
    8ab0:	4699      	mov	r9, r3
    InitTimer(&timer);
    countdown_ms(&timer, c->commandTimeoutMs);

    if(QOS1 == message->qos || QOS2 == message->qos) {
        message->id = getNextPacketId(c);
        waitForAck = 1;
    8ab2:	3b03      	subs	r3, #3
    8ab4:	4698      	mov	r8, r3
        if(QOS2 == message->qos) {
            packetType = PUBCOMP;
        }
    }

    rc = MQTTSerialize_publish(c->buf, c->bufSize, 0, message->qos, message->retained, message->id,
    8ab6:	7823      	ldrb	r3, [r4, #0]
    8ab8:	aa0a      	add	r2, sp, #40	; 0x28
    8aba:	9207      	str	r2, [sp, #28]
    8abc:	68e2      	ldr	r2, [r4, #12]
    8abe:	9206      	str	r2, [sp, #24]
    8ac0:	68a2      	ldr	r2, [r4, #8]
    8ac2:	9205      	str	r2, [sp, #20]
    8ac4:	aa0b      	add	r2, sp, #44	; 0x2c
    8ac6:	a902      	add	r1, sp, #8
    8ac8:	cac1      	ldmia	r2!, {r0, r6, r7}
    8aca:	c1c1      	stmia	r1!, {r0, r6, r7}
    8acc:	88a2      	ldrh	r2, [r4, #4]
    8ace:	9201      	str	r2, [sp, #4]
    8ad0:	7862      	ldrb	r2, [r4, #1]
    8ad2:	9200      	str	r2, [sp, #0]
    8ad4:	2200      	movs	r2, #0
    8ad6:	69a9      	ldr	r1, [r5, #24]
    8ad8:	6a28      	ldr	r0, [r5, #32]
    8ada:	4c1b      	ldr	r4, [pc, #108]	; (8b48 <MQTTPublish+0xfc>)
    8adc:	47a0      	blx	r4
              topic, (unsigned char*)message->payload, message->payloadlen, &len);
    if(SUCCESS != rc) {
    8ade:	2800      	cmp	r0, #0
    8ae0:	d127      	bne.n	8b32 <MQTTPublish+0xe6>
        return rc;
    }

    /* send the publish packet */
    rc = sendPacket(c, len, &timer);
    8ae2:	aa0e      	add	r2, sp, #56	; 0x38
    8ae4:	990a      	ldr	r1, [sp, #40]	; 0x28
    8ae6:	0028      	movs	r0, r5
    8ae8:	4b18      	ldr	r3, [pc, #96]	; (8b4c <MQTTPublish+0x100>)
    8aea:	4798      	blx	r3
    if(SUCCESS != rc) {
    8aec:	2800      	cmp	r0, #0
    8aee:	d120      	bne.n	8b32 <MQTTPublish+0xe6>
        if(SUCCESS != rc) {
            return rc;
        }
    }

    return SUCCESS;
    8af0:	2000      	movs	r0, #0
    if(SUCCESS != rc) {
        return rc;
    }

    /* Wait for ack if QoS1 or QoS2 */
    if(1 == waitForAck) {
    8af2:	4643      	mov	r3, r8
    8af4:	2b01      	cmp	r3, #1
    8af6:	d11c      	bne.n	8b32 <MQTTPublish+0xe6>
        rc = waitfor(c, packetType, &timer);
    8af8:	aa0e      	add	r2, sp, #56	; 0x38
    8afa:	4649      	mov	r1, r9
    8afc:	0028      	movs	r0, r5
    8afe:	4b14      	ldr	r3, [pc, #80]	; (8b50 <MQTTPublish+0x104>)
    8b00:	4798      	blx	r3
        if(SUCCESS != rc) {
    8b02:	2800      	cmp	r0, #0
    8b04:	d115      	bne.n	8b32 <MQTTPublish+0xe6>
            return rc;
        }

        rc = MQTTDeserialize_ack(&type, &dup, &packet_id, c->readbuf, c->readBufSize);
    8b06:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    8b08:	69ea      	ldr	r2, [r5, #28]
    8b0a:	9200      	str	r2, [sp, #0]
    8b0c:	2226      	movs	r2, #38	; 0x26
    8b0e:	446a      	add	r2, sp
    8b10:	2125      	movs	r1, #37	; 0x25
    8b12:	4469      	add	r1, sp
    8b14:	a809      	add	r0, sp, #36	; 0x24
    8b16:	4c0f      	ldr	r4, [pc, #60]	; (8b54 <MQTTPublish+0x108>)
    8b18:	47a0      	blx	r4
    8b1a:	e00a      	b.n	8b32 <MQTTPublish+0xe6>
    return SUCCESS;
}

MQTTReturnCode MQTTPublish(Client *c, const char *topicName, MQTTMessage *message) {
    if(NULL == c || NULL == topicName || NULL == message) {
        return MQTT_NULL_VALUE_ERROR;
    8b1c:	2006      	movs	r0, #6
    8b1e:	4240      	negs	r0, r0
    8b20:	e007      	b.n	8b32 <MQTTPublish+0xe6>
    8b22:	2006      	movs	r0, #6
    8b24:	4240      	negs	r0, r0
    8b26:	e004      	b.n	8b32 <MQTTPublish+0xe6>
    8b28:	2006      	movs	r0, #6
    8b2a:	4240      	negs	r0, r0
    8b2c:	e001      	b.n	8b32 <MQTTPublish+0xe6>
    }

    if(!c->isConnected) {
        return MQTT_NETWORK_DISCONNECTED_ERROR;
    8b2e:	2004      	movs	r0, #4
    8b30:	4240      	negs	r0, r0
            return rc;
        }
    }

    return SUCCESS;
}
    8b32:	b011      	add	sp, #68	; 0x44
    8b34:	bc0c      	pop	{r2, r3}
    8b36:	4690      	mov	r8, r2
    8b38:	4699      	mov	r9, r3
    8b3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8b3c:	00007b95 	.word	0x00007b95
    8b40:	00007b35 	.word	0x00007b35
    8b44:	00007f41 	.word	0x00007f41
    8b48:	000096ed 	.word	0x000096ed
    8b4c:	00007f5d 	.word	0x00007f5d
    8b50:	00008599 	.word	0x00008599
    8b54:	00009229 	.word	0x00009229

00008b58 <MQTTDisconnect>:
	c->isConnected = 0;
	c->networkStack.disconnect(&(c->networkStack));
	c->networkStack.destroy(&(c->networkStack));
}

MQTTReturnCode MQTTDisconnect(Client *c) {
    8b58:	b530      	push	{r4, r5, lr}
    8b5a:	b085      	sub	sp, #20
    8b5c:	1e04      	subs	r4, r0, #0
    if(NULL == c) {
    8b5e:	d02d      	beq.n	8bbc <MQTTDisconnect+0x64>
        return MQTT_NULL_VALUE_ERROR;
    }

    if(0 == c->isConnected) {
    8b60:	7803      	ldrb	r3, [r0, #0]
    8b62:	2b00      	cmp	r3, #0
    8b64:	d02d      	beq.n	8bc2 <MQTTDisconnect+0x6a>
    }

    MQTTReturnCode rc = FAILURE;
    /* We might wait for incomplete incoming publishes to complete */
    Timer timer;
    uint32_t serialized_len = 0;
    8b66:	2300      	movs	r3, #0
    8b68:	9301      	str	r3, [sp, #4]
    rc = MQTTSerialize_disconnect(c->buf, c->bufSize, &serialized_len);
    8b6a:	aa01      	add	r2, sp, #4
    8b6c:	6981      	ldr	r1, [r0, #24]
    8b6e:	6a00      	ldr	r0, [r0, #32]
    8b70:	4b17      	ldr	r3, [pc, #92]	; (8bd0 <MQTTDisconnect+0x78>)
    8b72:	4798      	blx	r3
    if(SUCCESS != rc) {
    8b74:	2800      	cmp	r0, #0
    8b76:	d129      	bne.n	8bcc <MQTTDisconnect+0x74>
        return rc;
    }

    InitTimer(&timer);
    8b78:	a802      	add	r0, sp, #8
    8b7a:	4b16      	ldr	r3, [pc, #88]	; (8bd4 <MQTTDisconnect+0x7c>)
    8b7c:	4798      	blx	r3
    countdown_ms(&timer, c->commandTimeoutMs);
    8b7e:	68a1      	ldr	r1, [r4, #8]
    8b80:	a802      	add	r0, sp, #8
    8b82:	4b15      	ldr	r3, [pc, #84]	; (8bd8 <MQTTDisconnect+0x80>)
    8b84:	4798      	blx	r3

    /* send the disconnect packet */
    if(serialized_len > 0) {
    8b86:	9901      	ldr	r1, [sp, #4]
    8b88:	2900      	cmp	r1, #0
    8b8a:	d005      	beq.n	8b98 <MQTTDisconnect+0x40>
        rc = sendPacket(c, serialized_len, &timer);
    8b8c:	aa02      	add	r2, sp, #8
    8b8e:	0020      	movs	r0, r4
    8b90:	4b12      	ldr	r3, [pc, #72]	; (8bdc <MQTTDisconnect+0x84>)
    8b92:	4798      	blx	r3
        if(SUCCESS != rc) {
    8b94:	2800      	cmp	r0, #0
    8b96:	d119      	bne.n	8bcc <MQTTDisconnect+0x74>
            return rc;
        }
    }

    /* Clean network stack */
    c->networkStack.disconnect(&(c->networkStack));
    8b98:	0025      	movs	r5, r4
    8b9a:	3598      	adds	r5, #152	; 0x98
    8b9c:	23a8      	movs	r3, #168	; 0xa8
    8b9e:	58e3      	ldr	r3, [r4, r3]
    8ba0:	0028      	movs	r0, r5
    8ba2:	4798      	blx	r3
    rc = c->networkStack.destroy(&(c->networkStack));
    8ba4:	23b0      	movs	r3, #176	; 0xb0
    8ba6:	58e3      	ldr	r3, [r4, r3]
    8ba8:	0028      	movs	r0, r5
    8baa:	4798      	blx	r3
    if(0 != rc) {
    8bac:	b240      	sxtb	r0, r0
    8bae:	2800      	cmp	r0, #0
    8bb0:	d10a      	bne.n	8bc8 <MQTTDisconnect+0x70>
        /* TLS Destroy failed, return error */
        return FAILURE;
    }

    c->isConnected = 0;
    8bb2:	2300      	movs	r3, #0
    8bb4:	7023      	strb	r3, [r4, #0]

    /* Always set to 1 whenever disconnect is called. Keepalive resets to 0 */
    c->wasManuallyDisconnected = 1;
    8bb6:	3301      	adds	r3, #1
    8bb8:	7063      	strb	r3, [r4, #1]

    return SUCCESS;
    8bba:	e007      	b.n	8bcc <MQTTDisconnect+0x74>
	c->networkStack.destroy(&(c->networkStack));
}

MQTTReturnCode MQTTDisconnect(Client *c) {
    if(NULL == c) {
        return MQTT_NULL_VALUE_ERROR;
    8bbc:	2006      	movs	r0, #6
    8bbe:	4240      	negs	r0, r0
    8bc0:	e004      	b.n	8bcc <MQTTDisconnect+0x74>
    }

    if(0 == c->isConnected) {
        /* Network is already disconnected. Do nothing */
        return MQTT_NETWORK_DISCONNECTED_ERROR;
    8bc2:	2004      	movs	r0, #4
    8bc4:	4240      	negs	r0, r0
    8bc6:	e001      	b.n	8bcc <MQTTDisconnect+0x74>
    /* Clean network stack */
    c->networkStack.disconnect(&(c->networkStack));
    rc = c->networkStack.destroy(&(c->networkStack));
    if(0 != rc) {
        /* TLS Destroy failed, return error */
        return FAILURE;
    8bc8:	2001      	movs	r0, #1
    8bca:	4240      	negs	r0, r0

    /* Always set to 1 whenever disconnect is called. Keepalive resets to 0 */
    c->wasManuallyDisconnected = 1;

    return SUCCESS;
}
    8bcc:	b005      	add	sp, #20
    8bce:	bd30      	pop	{r4, r5, pc}
    8bd0:	00009129 	.word	0x00009129
    8bd4:	00007b95 	.word	0x00007b95
    8bd8:	00007b35 	.word	0x00007b35
    8bdc:	00007f5d 	.word	0x00007f5d

00008be0 <handleDisconnect>:

    /* Message handler not found for topic */
    return FAILURE;
}

MQTTReturnCode handleDisconnect(Client *c) {
    8be0:	b570      	push	{r4, r5, r6, lr}
    8be2:	1e04      	subs	r4, r0, #0
    if(NULL == c) {
    8be4:	d01a      	beq.n	8c1c <handleDisconnect+0x3c>
        return MQTT_NULL_VALUE_ERROR;
    }

    MQTTReturnCode rc = MQTTDisconnect(c);
    8be6:	4b0f      	ldr	r3, [pc, #60]	; (8c24 <handleDisconnect+0x44>)
    8be8:	4798      	blx	r3
    if(rc != SUCCESS){
    8bea:	2800      	cmp	r0, #0
    8bec:	d00b      	beq.n	8c06 <handleDisconnect+0x26>
}
/**
 * This is for the case when the sendPacket Fails.
 */
static void MQTTForceDisconnect(Client *c){
	c->isConnected = 0;
    8bee:	2300      	movs	r3, #0
    8bf0:	7023      	strb	r3, [r4, #0]
	c->networkStack.disconnect(&(c->networkStack));
    8bf2:	0025      	movs	r5, r4
    8bf4:	3598      	adds	r5, #152	; 0x98
    8bf6:	33a8      	adds	r3, #168	; 0xa8
    8bf8:	58e3      	ldr	r3, [r4, r3]
    8bfa:	0028      	movs	r0, r5
    8bfc:	4798      	blx	r3
	c->networkStack.destroy(&(c->networkStack));
    8bfe:	23b0      	movs	r3, #176	; 0xb0
    8c00:	58e3      	ldr	r3, [r4, r3]
    8c02:	0028      	movs	r0, r5
    8c04:	4798      	blx	r3
    if(rc != SUCCESS){
    	// If the sendPacket prevents us from sending a disconnect packet then we have to clean the stack
    	MQTTForceDisconnect(c);
    }

    if(NULL != c->disconnectHandler) {
    8c06:	238c      	movs	r3, #140	; 0x8c
    8c08:	005b      	lsls	r3, r3, #1
    8c0a:	58e3      	ldr	r3, [r4, r3]
    8c0c:	2b00      	cmp	r3, #0
    8c0e:	d000      	beq.n	8c12 <handleDisconnect+0x32>
        c->disconnectHandler();
    8c10:	4798      	blx	r3
    }

    /* Reset to 0 since this was not a manual disconnect */
    c->wasManuallyDisconnected = 0;
    8c12:	2300      	movs	r3, #0
    8c14:	7063      	strb	r3, [r4, #1]
    return MQTT_NETWORK_DISCONNECTED_ERROR;
    8c16:	2004      	movs	r0, #4
    8c18:	4240      	negs	r0, r0
    8c1a:	e001      	b.n	8c20 <handleDisconnect+0x40>
    return FAILURE;
}

MQTTReturnCode handleDisconnect(Client *c) {
    if(NULL == c) {
        return MQTT_NULL_VALUE_ERROR;
    8c1c:	2006      	movs	r0, #6
    8c1e:	4240      	negs	r0, r0
    }

    /* Reset to 0 since this was not a manual disconnect */
    c->wasManuallyDisconnected = 0;
    return MQTT_NETWORK_DISCONNECTED_ERROR;
}
    8c20:	bd70      	pop	{r4, r5, r6, pc}
    8c22:	46c0      	nop			; (mov r8, r8)
    8c24:	00008b59 	.word	0x00008b59

00008c28 <keepalive>:
    }
    countdown_ms(&(c->reconnectDelayTimer), c->currentReconnectWaitInterval);
    return rc;
}

MQTTReturnCode keepalive(Client *c) {
    8c28:	b530      	push	{r4, r5, lr}
    8c2a:	b085      	sub	sp, #20
    8c2c:	1e04      	subs	r4, r0, #0
    if(NULL == c) {
    8c2e:	d037      	beq.n	8ca0 <keepalive+0x78>
        return MQTT_NULL_VALUE_ERROR;
    }

	if(0 == c->keepAliveInterval) {
		return SUCCESS;
    8c30:	2000      	movs	r0, #0
MQTTReturnCode keepalive(Client *c) {
    if(NULL == c) {
        return MQTT_NULL_VALUE_ERROR;
    }

	if(0 == c->keepAliveInterval) {
    8c32:	68e3      	ldr	r3, [r4, #12]
    8c34:	2b00      	cmp	r3, #0
    8c36:	d035      	beq.n	8ca4 <keepalive+0x7c>
		return SUCCESS;
	}

	if(!expired(&c->pingTimer)) {
    8c38:	0025      	movs	r5, r4
    8c3a:	35b4      	adds	r5, #180	; 0xb4
    8c3c:	0028      	movs	r0, r5
    8c3e:	4b1a      	ldr	r3, [pc, #104]	; (8ca8 <keepalive+0x80>)
    8c40:	4798      	blx	r3
    8c42:	0003      	movs	r3, r0
        return SUCCESS;
    8c44:	2000      	movs	r0, #0

	if(0 == c->keepAliveInterval) {
		return SUCCESS;
	}

	if(!expired(&c->pingTimer)) {
    8c46:	2b00      	cmp	r3, #0
    8c48:	d02c      	beq.n	8ca4 <keepalive+0x7c>
        return SUCCESS;
    }

    if(c->isPingOutstanding) {
    8c4a:	78a3      	ldrb	r3, [r4, #2]
    8c4c:	2b00      	cmp	r3, #0
    8c4e:	d003      	beq.n	8c58 <keepalive+0x30>
        return handleDisconnect(c);
    8c50:	0020      	movs	r0, r4
    8c52:	4b16      	ldr	r3, [pc, #88]	; (8cac <keepalive+0x84>)
    8c54:	4798      	blx	r3
    8c56:	e025      	b.n	8ca4 <keepalive+0x7c>
    }

    /* there is no ping outstanding - send one */
    MQTTReturnCode rc = SUCCESS;
    Timer timer;
    InitTimer(&timer);
    8c58:	a802      	add	r0, sp, #8
    8c5a:	4b15      	ldr	r3, [pc, #84]	; (8cb0 <keepalive+0x88>)
    8c5c:	4798      	blx	r3
    countdown_ms(&timer, c->commandTimeoutMs);
    8c5e:	68a1      	ldr	r1, [r4, #8]
    8c60:	a802      	add	r0, sp, #8
    8c62:	4b14      	ldr	r3, [pc, #80]	; (8cb4 <keepalive+0x8c>)
    8c64:	4798      	blx	r3
    uint32_t serialized_len = 0;
    8c66:	2300      	movs	r3, #0
    8c68:	9301      	str	r3, [sp, #4]
    rc = MQTTSerialize_pingreq(c->buf, c->bufSize, &serialized_len);
    8c6a:	aa01      	add	r2, sp, #4
    8c6c:	69a1      	ldr	r1, [r4, #24]
    8c6e:	6a20      	ldr	r0, [r4, #32]
    8c70:	4b11      	ldr	r3, [pc, #68]	; (8cb8 <keepalive+0x90>)
    8c72:	4798      	blx	r3
    if(SUCCESS != rc) {
    8c74:	2800      	cmp	r0, #0
    8c76:	d115      	bne.n	8ca4 <keepalive+0x7c>
        return rc;
    }

    /* send the ping packet */
    rc = sendPacket(c, serialized_len, &timer);
    8c78:	aa02      	add	r2, sp, #8
    8c7a:	9901      	ldr	r1, [sp, #4]
    8c7c:	0020      	movs	r0, r4
    8c7e:	4b0f      	ldr	r3, [pc, #60]	; (8cbc <keepalive+0x94>)
    8c80:	4798      	blx	r3
    if(SUCCESS != rc) {
    8c82:	2800      	cmp	r0, #0
    8c84:	d003      	beq.n	8c8e <keepalive+0x66>
    	//If sending a PING fails we can no longer determine if we are connected.  In this case we decide we are disconnected and begin reconnection attempts
        return handleDisconnect(c);
    8c86:	0020      	movs	r0, r4
    8c88:	4b08      	ldr	r3, [pc, #32]	; (8cac <keepalive+0x84>)
    8c8a:	4798      	blx	r3
    8c8c:	e00a      	b.n	8ca4 <keepalive+0x7c>
    }

    c->isPingOutstanding = 1;
    8c8e:	2301      	movs	r3, #1
    8c90:	70a3      	strb	r3, [r4, #2]
    /* start a timer to wait for PINGRESP from server */
    countdown(&c->pingTimer, c->keepAliveInterval / 2);
    8c92:	68e1      	ldr	r1, [r4, #12]
    8c94:	0849      	lsrs	r1, r1, #1
    8c96:	0028      	movs	r0, r5
    8c98:	4b09      	ldr	r3, [pc, #36]	; (8cc0 <keepalive+0x98>)
    8c9a:	4798      	blx	r3

    return SUCCESS;
    8c9c:	2000      	movs	r0, #0
    8c9e:	e001      	b.n	8ca4 <keepalive+0x7c>
    return rc;
}

MQTTReturnCode keepalive(Client *c) {
    if(NULL == c) {
        return MQTT_NULL_VALUE_ERROR;
    8ca0:	2006      	movs	r0, #6
    8ca2:	4240      	negs	r0, r0
    c->isPingOutstanding = 1;
    /* start a timer to wait for PINGRESP from server */
    countdown(&c->pingTimer, c->keepAliveInterval / 2);

    return SUCCESS;
}
    8ca4:	b005      	add	sp, #20
    8ca6:	bd30      	pop	{r4, r5, pc}
    8ca8:	00007b15 	.word	0x00007b15
    8cac:	00008be1 	.word	0x00008be1
    8cb0:	00007b95 	.word	0x00007b95
    8cb4:	00007b35 	.word	0x00007b35
    8cb8:	00009139 	.word	0x00009139
    8cbc:	00007f5d 	.word	0x00007f5d
    8cc0:	00007b55 	.word	0x00007b55

00008cc4 <MQTTYield>:
    }

    return rc;
}

MQTTReturnCode MQTTYield(Client *c, uint32_t timeout_ms) {
    8cc4:	b5f0      	push	{r4, r5, r6, r7, lr}
    8cc6:	b085      	sub	sp, #20
    8cc8:	0005      	movs	r5, r0
    8cca:	000c      	movs	r4, r1
    if(NULL == c) {
    8ccc:	2800      	cmp	r0, #0
    8cce:	d045      	beq.n	8d5c <MQTTYield+0x98>
        return MQTT_NULL_VALUE_ERROR;
    }

    /* Check if network was manually disconnected */
    if(0 == c->isConnected && 1 == c->wasManuallyDisconnected) {
    8cd0:	8802      	ldrh	r2, [r0, #0]
        return MQTT_NETWORK_MANUALLY_DISCONNECTED;
    8cd2:	2005      	movs	r0, #5
    if(NULL == c) {
        return MQTT_NULL_VALUE_ERROR;
    }

    /* Check if network was manually disconnected */
    if(0 == c->isConnected && 1 == c->wasManuallyDisconnected) {
    8cd4:	2380      	movs	r3, #128	; 0x80
    8cd6:	005b      	lsls	r3, r3, #1
    8cd8:	429a      	cmp	r2, r3
    8cda:	d04b      	beq.n	8d74 <MQTTYield+0xb0>
        return MQTT_NETWORK_MANUALLY_DISCONNECTED;
    }

    /* Check if network is disconnected and auto-reconnect is not enabled */
    if(0 == c->isConnected && 0 == c->isAutoReconnectEnabled) {
    8cdc:	4b26      	ldr	r3, [pc, #152]	; (8d78 <MQTTYield+0xb4>)
    8cde:	682a      	ldr	r2, [r5, #0]
    8ce0:	421a      	tst	r2, r3
    8ce2:	d03e      	beq.n	8d62 <MQTTYield+0x9e>
        return MQTT_NETWORK_DISCONNECTED_ERROR;
    }

    MQTTReturnCode rc = SUCCESS;
    Timer timer;
    InitTimer(&timer);
    8ce4:	a802      	add	r0, sp, #8
    8ce6:	4b25      	ldr	r3, [pc, #148]	; (8d7c <MQTTYield+0xb8>)
    8ce8:	4798      	blx	r3
    uint8_t packet_type;
    countdown_ms(&timer, timeout_ms);
    8cea:	0021      	movs	r1, r4
    8cec:	a802      	add	r0, sp, #8
    8cee:	4b24      	ldr	r3, [pc, #144]	; (8d80 <MQTTYield+0xbc>)
    8cf0:	4798      	blx	r3
    /* Check if network is disconnected and auto-reconnect is not enabled */
    if(0 == c->isConnected && 0 == c->isAutoReconnectEnabled) {
        return MQTT_NETWORK_DISCONNECTED_ERROR;
    }

    MQTTReturnCode rc = SUCCESS;
    8cf2:	2400      	movs	r4, #0
    Timer timer;
    InitTimer(&timer);
    uint8_t packet_type;
    countdown_ms(&timer, timeout_ms);

    while(!expired(&timer)) {
    8cf4:	4f23      	ldr	r7, [pc, #140]	; (8d84 <MQTTYield+0xc0>)
            /* Network reconnect attempted, check if yield timer expired before
             * doing anything else */
            continue;
        }

        rc = cycle(c, &timer, &packet_type);
    8cf6:	4e24      	ldr	r6, [pc, #144]	; (8d88 <MQTTYield+0xc4>)
    Timer timer;
    InitTimer(&timer);
    uint8_t packet_type;
    countdown_ms(&timer, timeout_ms);

    while(!expired(&timer)) {
    8cf8:	e02a      	b.n	8d50 <MQTTYield+0x8c>
        if(0 == c->isConnected) {
    8cfa:	782b      	ldrb	r3, [r5, #0]
    8cfc:	2b00      	cmp	r3, #0
    8cfe:	d109      	bne.n	8d14 <MQTTYield+0x50>
            if(MAX_RECONNECT_WAIT_INTERVAL < c->currentReconnectWaitInterval) {
    8d00:	23fa      	movs	r3, #250	; 0xfa
    8d02:	015b      	lsls	r3, r3, #5
    8d04:	692a      	ldr	r2, [r5, #16]
    8d06:	429a      	cmp	r2, r3
    8d08:	d82e      	bhi.n	8d68 <MQTTYield+0xa4>
                rc = MQTT_RECONNECT_TIMED_OUT;
                break;
            }
            rc = handleReconnect(c);
    8d0a:	0028      	movs	r0, r5
    8d0c:	4b1f      	ldr	r3, [pc, #124]	; (8d8c <MQTTYield+0xc8>)
    8d0e:	4798      	blx	r3
    8d10:	0004      	movs	r4, r0
            /* Network reconnect attempted, check if yield timer expired before
             * doing anything else */
            continue;
    8d12:	e01d      	b.n	8d50 <MQTTYield+0x8c>
        }

        rc = cycle(c, &timer, &packet_type);
    8d14:	466b      	mov	r3, sp
    8d16:	1dda      	adds	r2, r3, #7
    8d18:	a902      	add	r1, sp, #8
    8d1a:	0028      	movs	r0, r5
    8d1c:	47b0      	blx	r6
        if(SUCCESS != rc) {
    8d1e:	2800      	cmp	r0, #0
    8d20:	d128      	bne.n	8d74 <MQTTYield+0xb0>
            break;
        }

        rc = keepalive(c);
    8d22:	0028      	movs	r0, r5
    8d24:	4b1a      	ldr	r3, [pc, #104]	; (8d90 <MQTTYield+0xcc>)
    8d26:	4798      	blx	r3
    8d28:	0004      	movs	r4, r0
        if(MQTT_NETWORK_DISCONNECTED_ERROR == rc && 1 == c->isAutoReconnectEnabled) {
    8d2a:	1d03      	adds	r3, r0, #4
    8d2c:	d10e      	bne.n	8d4c <MQTTYield+0x88>
    8d2e:	78eb      	ldrb	r3, [r5, #3]
    8d30:	2b01      	cmp	r3, #1
    8d32:	d11c      	bne.n	8d6e <MQTTYield+0xaa>
            c->currentReconnectWaitInterval = MIN_RECONNECT_WAIT_INTERVAL;
    8d34:	21fa      	movs	r1, #250	; 0xfa
    8d36:	0089      	lsls	r1, r1, #2
    8d38:	6129      	str	r1, [r5, #16]
            countdown_ms(&(c->reconnectDelayTimer), c->currentReconnectWaitInterval);
    8d3a:	0028      	movs	r0, r5
    8d3c:	30bc      	adds	r0, #188	; 0xbc
    8d3e:	4b10      	ldr	r3, [pc, #64]	; (8d80 <MQTTYield+0xbc>)
    8d40:	4798      	blx	r3
            c->counterNetworkDisconnected++;
    8d42:	696b      	ldr	r3, [r5, #20]
    8d44:	3301      	adds	r3, #1
    8d46:	616b      	str	r3, [r5, #20]
            /* Depending on timer values, it is possible that yield timer has expired
             * Set to rc to attempting reconnect to inform client that autoreconnect
             * attempt has started */
            rc = MQTT_ATTEMPTING_RECONNECT;
    8d48:	3407      	adds	r4, #7
    8d4a:	e001      	b.n	8d50 <MQTTYield+0x8c>
        } else if(SUCCESS != rc) {
    8d4c:	2800      	cmp	r0, #0
    8d4e:	d111      	bne.n	8d74 <MQTTYield+0xb0>
    Timer timer;
    InitTimer(&timer);
    uint8_t packet_type;
    countdown_ms(&timer, timeout_ms);

    while(!expired(&timer)) {
    8d50:	a802      	add	r0, sp, #8
    8d52:	47b8      	blx	r7
    8d54:	2800      	cmp	r0, #0
    8d56:	d0d0      	beq.n	8cfa <MQTTYield+0x36>
    8d58:	0020      	movs	r0, r4
    8d5a:	e00b      	b.n	8d74 <MQTTYield+0xb0>
    return rc;
}

MQTTReturnCode MQTTYield(Client *c, uint32_t timeout_ms) {
    if(NULL == c) {
        return MQTT_NULL_VALUE_ERROR;
    8d5c:	2006      	movs	r0, #6
    8d5e:	4240      	negs	r0, r0
    8d60:	e008      	b.n	8d74 <MQTTYield+0xb0>
        return MQTT_NETWORK_MANUALLY_DISCONNECTED;
    }

    /* Check if network is disconnected and auto-reconnect is not enabled */
    if(0 == c->isConnected && 0 == c->isAutoReconnectEnabled) {
        return MQTT_NETWORK_DISCONNECTED_ERROR;
    8d62:	2004      	movs	r0, #4
    8d64:	4240      	negs	r0, r0
    8d66:	e005      	b.n	8d74 <MQTTYield+0xb0>
    countdown_ms(&timer, timeout_ms);

    while(!expired(&timer)) {
        if(0 == c->isConnected) {
            if(MAX_RECONNECT_WAIT_INTERVAL < c->currentReconnectWaitInterval) {
                rc = MQTT_RECONNECT_TIMED_OUT;
    8d68:	2008      	movs	r0, #8
    8d6a:	4240      	negs	r0, r0
    8d6c:	e002      	b.n	8d74 <MQTTYield+0xb0>
        rc = cycle(c, &timer, &packet_type);
        if(SUCCESS != rc) {
            break;
        }

        rc = keepalive(c);
    8d6e:	2004      	movs	r0, #4
    8d70:	4240      	negs	r0, r0
    8d72:	e7ff      	b.n	8d74 <MQTTYield+0xb0>
            break;
        }
    }

    return rc;
}
    8d74:	b005      	add	sp, #20
    8d76:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8d78:	ff0000ff 	.word	0xff0000ff
    8d7c:	00007b95 	.word	0x00007b95
    8d80:	00007b35 	.word	0x00007b35
    8d84:	00007b15 	.word	0x00007b15
    8d88:	00008519 	.word	0x00008519
    8d8c:	000089dd 	.word	0x000089dd
    8d90:	00008c29 	.word	0x00008c29

00008d94 <MQTTIsAutoReconnectEnabled>:

    return c->isConnected;
}

uint8_t MQTTIsAutoReconnectEnabled(Client *c) {
    if(NULL == c) {
    8d94:	2800      	cmp	r0, #0
    8d96:	d001      	beq.n	8d9c <MQTTIsAutoReconnectEnabled+0x8>
        return 0;
    }

    return c->isAutoReconnectEnabled;
    8d98:	78c0      	ldrb	r0, [r0, #3]
    8d9a:	e000      	b.n	8d9e <MQTTIsAutoReconnectEnabled+0xa>
    return c->isConnected;
}

uint8_t MQTTIsAutoReconnectEnabled(Client *c) {
    if(NULL == c) {
        return 0;
    8d9c:	2000      	movs	r0, #0
    }

    return c->isAutoReconnectEnabled;
}
    8d9e:	4770      	bx	lr

00008da0 <setDisconnectHandler>:

MQTTReturnCode setDisconnectHandler(Client *c, disconnectHandler_t disconnectHandler) {
    if(NULL == c || NULL == disconnectHandler) {
    8da0:	2800      	cmp	r0, #0
    8da2:	d006      	beq.n	8db2 <setDisconnectHandler+0x12>
    8da4:	2900      	cmp	r1, #0
    8da6:	d007      	beq.n	8db8 <setDisconnectHandler+0x18>
        return MQTT_NULL_VALUE_ERROR;
    }

    c->disconnectHandler = disconnectHandler;
    8da8:	238c      	movs	r3, #140	; 0x8c
    8daa:	005b      	lsls	r3, r3, #1
    8dac:	50c1      	str	r1, [r0, r3]
    return SUCCESS;
    8dae:	2000      	movs	r0, #0
    8db0:	e004      	b.n	8dbc <setDisconnectHandler+0x1c>
    return c->isAutoReconnectEnabled;
}

MQTTReturnCode setDisconnectHandler(Client *c, disconnectHandler_t disconnectHandler) {
    if(NULL == c || NULL == disconnectHandler) {
        return MQTT_NULL_VALUE_ERROR;
    8db2:	2006      	movs	r0, #6
    8db4:	4240      	negs	r0, r0
    8db6:	e001      	b.n	8dbc <setDisconnectHandler+0x1c>
    8db8:	2006      	movs	r0, #6
    8dba:	4240      	negs	r0, r0
    }

    c->disconnectHandler = disconnectHandler;
    return SUCCESS;
}
    8dbc:	4770      	bx	lr
    8dbe:	46c0      	nop			; (mov r8, r8)

00008dc0 <setAutoReconnectEnabled>:

MQTTReturnCode setAutoReconnectEnabled(Client *c, uint8_t value) {
    if(NULL == c) {
    8dc0:	2800      	cmp	r0, #0
    8dc2:	d002      	beq.n	8dca <setAutoReconnectEnabled+0xa>
        return FAILURE;
    }
    c->isAutoReconnectEnabled = value;
    8dc4:	70c1      	strb	r1, [r0, #3]
    return SUCCESS;
    8dc6:	2000      	movs	r0, #0
    8dc8:	e001      	b.n	8dce <setAutoReconnectEnabled+0xe>
    return SUCCESS;
}

MQTTReturnCode setAutoReconnectEnabled(Client *c, uint8_t value) {
    if(NULL == c) {
        return FAILURE;
    8dca:	2001      	movs	r0, #1
    8dcc:	4240      	negs	r0, r0
    }
    c->isAutoReconnectEnabled = value;
    return SUCCESS;
}
    8dce:	4770      	bx	lr

00008dd0 <MQTTSerialize_GetConnectLength>:
  * Determines the length of the MQTT connect packet that would be produced using the supplied connect options.
  * @param options the options to be used to build the connect packet
  * @param the length of buffer needed to contain the serialized version of the packet
  * @return MQTTReturnCode indicating function execution status
  */
size_t MQTTSerialize_GetConnectLength(MQTTPacket_connectData *options) {
    8dd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8dd2:	0004      	movs	r4, r0
	FUNC_ENTRY;

	size_t len = 0;
	/* variable depending on MQTT or MQIsdp */
	if(3 == options->MQTTVersion) {
    8dd4:	7943      	ldrb	r3, [r0, #5]
    8dd6:	2b03      	cmp	r3, #3
    8dd8:	d004      	beq.n	8de4 <MQTTSerialize_GetConnectLength+0x14>
  * @return MQTTReturnCode indicating function execution status
  */
size_t MQTTSerialize_GetConnectLength(MQTTPacket_connectData *options) {
	FUNC_ENTRY;

	size_t len = 0;
    8dda:	2500      	movs	r5, #0
	/* variable depending on MQTT or MQIsdp */
	if(3 == options->MQTTVersion) {
		len = 12;
	} else if(4 == options->MQTTVersion) {
    8ddc:	2b04      	cmp	r3, #4
    8dde:	d102      	bne.n	8de6 <MQTTSerialize_GetConnectLength+0x16>
		len = 10;
    8de0:	350a      	adds	r5, #10
    8de2:	e000      	b.n	8de6 <MQTTSerialize_GetConnectLength+0x16>
	FUNC_ENTRY;

	size_t len = 0;
	/* variable depending on MQTT or MQIsdp */
	if(3 == options->MQTTVersion) {
		len = 12;
    8de4:	250c      	movs	r5, #12
	} else if(4 == options->MQTTVersion) {
		len = 10;
	}

	len += MQTTstrlen(options->clientID) + 2;
    8de6:	68a0      	ldr	r0, [r4, #8]
    8de8:	68e1      	ldr	r1, [r4, #12]
    8dea:	6922      	ldr	r2, [r4, #16]
    8dec:	4b18      	ldr	r3, [pc, #96]	; (8e50 <MQTTSerialize_GetConnectLength+0x80>)
    8dee:	4798      	blx	r3
    8df0:	182d      	adds	r5, r5, r0

	if(options->willFlag) {
    8df2:	7de3      	ldrb	r3, [r4, #23]
    8df4:	2b00      	cmp	r3, #0
    8df6:	d101      	bne.n	8dfc <MQTTSerialize_GetConnectLength+0x2c>
		len = 12;
	} else if(4 == options->MQTTVersion) {
		len = 10;
	}

	len += MQTTstrlen(options->clientID) + 2;
    8df8:	3502      	adds	r5, #2
    8dfa:	e00c      	b.n	8e16 <MQTTSerialize_GetConnectLength+0x46>

	if(options->willFlag) {
		len += MQTTstrlen(options->will.topicName) + 2 + MQTTstrlen(options->will.message) + 2;
    8dfc:	6a20      	ldr	r0, [r4, #32]
    8dfe:	6a61      	ldr	r1, [r4, #36]	; 0x24
    8e00:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    8e02:	4f13      	ldr	r7, [pc, #76]	; (8e50 <MQTTSerialize_GetConnectLength+0x80>)
    8e04:	47b8      	blx	r7
    8e06:	0006      	movs	r6, r0
    8e08:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    8e0a:	6b21      	ldr	r1, [r4, #48]	; 0x30
    8e0c:	6b62      	ldr	r2, [r4, #52]	; 0x34
    8e0e:	47b8      	blx	r7
    8e10:	3506      	adds	r5, #6
    8e12:	19ad      	adds	r5, r5, r6
    8e14:	182d      	adds	r5, r5, r0
	}

	if(options->username.cstring || options->username.lenstring.data) {
    8e16:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    8e18:	2b00      	cmp	r3, #0
    8e1a:	d102      	bne.n	8e22 <MQTTSerialize_GetConnectLength+0x52>
    8e1c:	6c63      	ldr	r3, [r4, #68]	; 0x44
    8e1e:	2b00      	cmp	r3, #0
    8e20:	d006      	beq.n	8e30 <MQTTSerialize_GetConnectLength+0x60>
		len += MQTTstrlen(options->username) + 2;
    8e22:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    8e24:	6c21      	ldr	r1, [r4, #64]	; 0x40
    8e26:	6c62      	ldr	r2, [r4, #68]	; 0x44
    8e28:	4b09      	ldr	r3, [pc, #36]	; (8e50 <MQTTSerialize_GetConnectLength+0x80>)
    8e2a:	4798      	blx	r3
    8e2c:	3502      	adds	r5, #2
    8e2e:	1945      	adds	r5, r0, r5
	}

	if(options->password.cstring || options->password.lenstring.data) {
    8e30:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    8e32:	2b00      	cmp	r3, #0
    8e34:	d102      	bne.n	8e3c <MQTTSerialize_GetConnectLength+0x6c>
    8e36:	6d23      	ldr	r3, [r4, #80]	; 0x50
    8e38:	2b00      	cmp	r3, #0
    8e3a:	d006      	beq.n	8e4a <MQTTSerialize_GetConnectLength+0x7a>
		len += MQTTstrlen(options->password) + 2;
    8e3c:	6ca0      	ldr	r0, [r4, #72]	; 0x48
    8e3e:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
    8e40:	6d22      	ldr	r2, [r4, #80]	; 0x50
    8e42:	4b03      	ldr	r3, [pc, #12]	; (8e50 <MQTTSerialize_GetConnectLength+0x80>)
    8e44:	4798      	blx	r3
    8e46:	3502      	adds	r5, #2
    8e48:	1945      	adds	r5, r0, r5
	}

	FUNC_EXIT_RC(len);
	return len;
}
    8e4a:	0028      	movs	r0, r5
    8e4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8e4e:	46c0      	nop			; (mov r8, r8)
    8e50:	00009519 	.word	0x00009519

00008e54 <MQTTSerialize_connect>:
  * @param serialized length
  * @return MQTTReturnCode indicating function execution status
  */
MQTTReturnCode MQTTSerialize_connect(unsigned char *buf, size_t buflen,
									 MQTTPacket_connectData *options,
									 uint32_t *serialized_len) {
    8e54:	b5f0      	push	{r4, r5, r6, r7, lr}
    8e56:	464f      	mov	r7, r9
    8e58:	4646      	mov	r6, r8
    8e5a:	b4c0      	push	{r6, r7}
    8e5c:	b085      	sub	sp, #20
    8e5e:	0006      	movs	r6, r0
    8e60:	000d      	movs	r5, r1
    8e62:	0014      	movs	r4, r2
    8e64:	4699      	mov	r9, r3
	FUNC_ENTRY;
	if(NULL == buf || NULL == options || NULL == serialized_len) {
    8e66:	2800      	cmp	r0, #0
    8e68:	d100      	bne.n	8e6c <MQTTSerialize_connect+0x18>
    8e6a:	e098      	b.n	8f9e <MQTTSerialize_connect+0x14a>
    8e6c:	2a00      	cmp	r2, #0
    8e6e:	d100      	bne.n	8e72 <MQTTSerialize_connect+0x1e>
    8e70:	e098      	b.n	8fa4 <MQTTSerialize_connect+0x150>
    8e72:	2b00      	cmp	r3, #0
    8e74:	d100      	bne.n	8e78 <MQTTSerialize_connect+0x24>
    8e76:	e098      	b.n	8faa <MQTTSerialize_connect+0x156>
		FUNC_EXIT_RC(MQTT_NULL_VALUE_ERROR);
		return MQTT_NULL_VALUE_ERROR;
	}

	unsigned char *ptr = buf;
    8e78:	9003      	str	r0, [sp, #12]
	MQTTHeader header = {0};
    8e7a:	2300      	movs	r3, #0
    8e7c:	9302      	str	r3, [sp, #8]
	MQTTConnectFlags flags = {0};
	size_t len = 0;

	len = MQTTSerialize_GetConnectLength(options);
    8e7e:	0010      	movs	r0, r2
    8e80:	4b4f      	ldr	r3, [pc, #316]	; (8fc0 <MQTTSerialize_connect+0x16c>)
    8e82:	4798      	blx	r3
    8e84:	0007      	movs	r7, r0
	if(MQTTPacket_len(len) > buflen) {
    8e86:	4b4f      	ldr	r3, [pc, #316]	; (8fc4 <MQTTSerialize_connect+0x170>)
    8e88:	4798      	blx	r3
    8e8a:	42a8      	cmp	r0, r5
    8e8c:	d900      	bls.n	8e90 <MQTTSerialize_connect+0x3c>
    8e8e:	e08f      	b.n	8fb0 <MQTTSerialize_connect+0x15c>
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
	}

	MQTTReturnCode rc = MQTTPacket_InitHeader(&header, CONNECT, QOS0, 0, 0);
    8e90:	2300      	movs	r3, #0
    8e92:	9300      	str	r3, [sp, #0]
    8e94:	2200      	movs	r2, #0
    8e96:	2101      	movs	r1, #1
    8e98:	a802      	add	r0, sp, #8
    8e9a:	4d4b      	ldr	r5, [pc, #300]	; (8fc8 <MQTTSerialize_connect+0x174>)
    8e9c:	47a8      	blx	r5
	if(SUCCESS != rc) {
    8e9e:	2800      	cmp	r0, #0
    8ea0:	d000      	beq.n	8ea4 <MQTTSerialize_connect+0x50>
    8ea2:	e087      	b.n	8fb4 <MQTTSerialize_connect+0x160>
		FUNC_EXIT_RC(rc);
		return rc;
	}

	writeChar(&ptr, header.byte); /* write header */
    8ea4:	ab02      	add	r3, sp, #8
    8ea6:	7819      	ldrb	r1, [r3, #0]
    8ea8:	a803      	add	r0, sp, #12
    8eaa:	4b48      	ldr	r3, [pc, #288]	; (8fcc <MQTTSerialize_connect+0x178>)
    8eac:	4798      	blx	r3

	ptr += MQTTPacket_encode(ptr, len); /* write remaining length */
    8eae:	0039      	movs	r1, r7
    8eb0:	9803      	ldr	r0, [sp, #12]
    8eb2:	4b47      	ldr	r3, [pc, #284]	; (8fd0 <MQTTSerialize_connect+0x17c>)
    8eb4:	4798      	blx	r3
    8eb6:	9b03      	ldr	r3, [sp, #12]
    8eb8:	469c      	mov	ip, r3
    8eba:	4460      	add	r0, ip
    8ebc:	9003      	str	r0, [sp, #12]

	if(4 == options->MQTTVersion) {
    8ebe:	7963      	ldrb	r3, [r4, #5]
    8ec0:	2b04      	cmp	r3, #4
    8ec2:	d108      	bne.n	8ed6 <MQTTSerialize_connect+0x82>
		writeCString(&ptr, "MQTT");
    8ec4:	4943      	ldr	r1, [pc, #268]	; (8fd4 <MQTTSerialize_connect+0x180>)
    8ec6:	a803      	add	r0, sp, #12
    8ec8:	4b43      	ldr	r3, [pc, #268]	; (8fd8 <MQTTSerialize_connect+0x184>)
    8eca:	4798      	blx	r3
		writeChar(&ptr, (char) 4);
    8ecc:	2104      	movs	r1, #4
    8ece:	a803      	add	r0, sp, #12
    8ed0:	4b3e      	ldr	r3, [pc, #248]	; (8fcc <MQTTSerialize_connect+0x178>)
    8ed2:	4798      	blx	r3
    8ed4:	e007      	b.n	8ee6 <MQTTSerialize_connect+0x92>
	} else {
		writeCString(&ptr, "MQIsdp");
    8ed6:	4941      	ldr	r1, [pc, #260]	; (8fdc <MQTTSerialize_connect+0x188>)
    8ed8:	a803      	add	r0, sp, #12
    8eda:	4b3f      	ldr	r3, [pc, #252]	; (8fd8 <MQTTSerialize_connect+0x184>)
    8edc:	4798      	blx	r3
		writeChar(&ptr, (char) 3);
    8ede:	2103      	movs	r1, #3
    8ee0:	a803      	add	r0, sp, #12
    8ee2:	4b3a      	ldr	r3, [pc, #232]	; (8fcc <MQTTSerialize_connect+0x178>)
    8ee4:	4798      	blx	r3
	}

	flags.all = 0;
	flags.bits.cleansession = (options->cleansession) ? 1 : 0;
    8ee6:	7da5      	ldrb	r5, [r4, #22]
    8ee8:	1e6b      	subs	r3, r5, #1
    8eea:	419d      	sbcs	r5, r3
	flags.bits.will = (options->willFlag) ? 1 : 0;
    8eec:	7de3      	ldrb	r3, [r4, #23]
    8eee:	1e5a      	subs	r2, r3, #1
    8ef0:	4193      	sbcs	r3, r2
    8ef2:	009b      	lsls	r3, r3, #2
    8ef4:	006d      	lsls	r5, r5, #1
	if(flags.bits.will) {
    8ef6:	431d      	orrs	r5, r3
    8ef8:	2b00      	cmp	r3, #0
    8efa:	d00b      	beq.n	8f14 <MQTTSerialize_connect+0xc0>
		flags.bits.willQoS = options->will.qos;
    8efc:	2339      	movs	r3, #57	; 0x39
    8efe:	5ce3      	ldrb	r3, [r4, r3]
    8f00:	2203      	movs	r2, #3
    8f02:	4013      	ands	r3, r2
    8f04:	00db      	lsls	r3, r3, #3
		flags.bits.willRetain = (options->will.retained) ? 1 : 0;
    8f06:	3235      	adds	r2, #53	; 0x35
    8f08:	5ca2      	ldrb	r2, [r4, r2]
    8f0a:	1e51      	subs	r1, r2, #1
    8f0c:	418a      	sbcs	r2, r1
    8f0e:	0152      	lsls	r2, r2, #5
    8f10:	431d      	orrs	r5, r3
    8f12:	4315      	orrs	r5, r2
	}

	if(options->username.cstring || options->username.lenstring.data) {
    8f14:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    8f16:	2b00      	cmp	r3, #0
    8f18:	d102      	bne.n	8f20 <MQTTSerialize_connect+0xcc>
    8f1a:	6c63      	ldr	r3, [r4, #68]	; 0x44
    8f1c:	2b00      	cmp	r3, #0
    8f1e:	d001      	beq.n	8f24 <MQTTSerialize_connect+0xd0>
		flags.bits.username = 1;
    8f20:	2380      	movs	r3, #128	; 0x80
    8f22:	431d      	orrs	r5, r3
	}

	if(options->password.cstring || options->password.lenstring.data) {
    8f24:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    8f26:	2b00      	cmp	r3, #0
    8f28:	d102      	bne.n	8f30 <MQTTSerialize_connect+0xdc>
    8f2a:	6d23      	ldr	r3, [r4, #80]	; 0x50
    8f2c:	2b00      	cmp	r3, #0
    8f2e:	d001      	beq.n	8f34 <MQTTSerialize_connect+0xe0>
		flags.bits.password = 1;
    8f30:	2340      	movs	r3, #64	; 0x40
    8f32:	431d      	orrs	r5, r3
	}

	writeChar(&ptr, flags.all);
    8f34:	b2e9      	uxtb	r1, r5
    8f36:	a803      	add	r0, sp, #12
    8f38:	4b24      	ldr	r3, [pc, #144]	; (8fcc <MQTTSerialize_connect+0x178>)
    8f3a:	4798      	blx	r3
	writeInt(&ptr, options->keepAliveInterval);
    8f3c:	8aa1      	ldrh	r1, [r4, #20]
    8f3e:	a803      	add	r0, sp, #12
    8f40:	4b27      	ldr	r3, [pc, #156]	; (8fe0 <MQTTSerialize_connect+0x18c>)
    8f42:	4798      	blx	r3
	writeMQTTString(&ptr, options->clientID);
    8f44:	68a1      	ldr	r1, [r4, #8]
    8f46:	68e2      	ldr	r2, [r4, #12]
    8f48:	6923      	ldr	r3, [r4, #16]
    8f4a:	a803      	add	r0, sp, #12
    8f4c:	4f25      	ldr	r7, [pc, #148]	; (8fe4 <MQTTSerialize_connect+0x190>)
    8f4e:	47b8      	blx	r7
	if(options->willFlag) {
    8f50:	7de3      	ldrb	r3, [r4, #23]
    8f52:	2b00      	cmp	r3, #0
    8f54:	d00a      	beq.n	8f6c <MQTTSerialize_connect+0x118>
		writeMQTTString(&ptr, options->will.topicName);
    8f56:	6a21      	ldr	r1, [r4, #32]
    8f58:	6a62      	ldr	r2, [r4, #36]	; 0x24
    8f5a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    8f5c:	a803      	add	r0, sp, #12
    8f5e:	4f21      	ldr	r7, [pc, #132]	; (8fe4 <MQTTSerialize_connect+0x190>)
    8f60:	47b8      	blx	r7
		writeMQTTString(&ptr, options->will.message);
    8f62:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    8f64:	6b22      	ldr	r2, [r4, #48]	; 0x30
    8f66:	6b63      	ldr	r3, [r4, #52]	; 0x34
    8f68:	a803      	add	r0, sp, #12
    8f6a:	47b8      	blx	r7
	}

	if(flags.bits.username) {
    8f6c:	b2eb      	uxtb	r3, r5
    8f6e:	4698      	mov	r8, r3
    8f70:	062b      	lsls	r3, r5, #24
    8f72:	d505      	bpl.n	8f80 <MQTTSerialize_connect+0x12c>
		writeMQTTString(&ptr, options->username);
    8f74:	6be1      	ldr	r1, [r4, #60]	; 0x3c
    8f76:	6c22      	ldr	r2, [r4, #64]	; 0x40
    8f78:	6c63      	ldr	r3, [r4, #68]	; 0x44
    8f7a:	a803      	add	r0, sp, #12
    8f7c:	4d19      	ldr	r5, [pc, #100]	; (8fe4 <MQTTSerialize_connect+0x190>)
    8f7e:	47a8      	blx	r5
	}

	if(flags.bits.password) {
    8f80:	4643      	mov	r3, r8
    8f82:	065b      	lsls	r3, r3, #25
    8f84:	d505      	bpl.n	8f92 <MQTTSerialize_connect+0x13e>
		writeMQTTString(&ptr, options->password);
    8f86:	6ca1      	ldr	r1, [r4, #72]	; 0x48
    8f88:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
    8f8a:	6d23      	ldr	r3, [r4, #80]	; 0x50
    8f8c:	a803      	add	r0, sp, #12
    8f8e:	4c15      	ldr	r4, [pc, #84]	; (8fe4 <MQTTSerialize_connect+0x190>)
    8f90:	47a0      	blx	r4
	}

	*serialized_len = (uint32_t)(ptr - buf);
    8f92:	9b03      	ldr	r3, [sp, #12]
    8f94:	1b9e      	subs	r6, r3, r6
    8f96:	464b      	mov	r3, r9
    8f98:	601e      	str	r6, [r3, #0]

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    8f9a:	2000      	movs	r0, #0
    8f9c:	e00a      	b.n	8fb4 <MQTTSerialize_connect+0x160>
									 MQTTPacket_connectData *options,
									 uint32_t *serialized_len) {
	FUNC_ENTRY;
	if(NULL == buf || NULL == options || NULL == serialized_len) {
		FUNC_EXIT_RC(MQTT_NULL_VALUE_ERROR);
		return MQTT_NULL_VALUE_ERROR;
    8f9e:	2006      	movs	r0, #6
    8fa0:	4240      	negs	r0, r0
    8fa2:	e007      	b.n	8fb4 <MQTTSerialize_connect+0x160>
    8fa4:	2006      	movs	r0, #6
    8fa6:	4240      	negs	r0, r0
    8fa8:	e004      	b.n	8fb4 <MQTTSerialize_connect+0x160>
    8faa:	2006      	movs	r0, #6
    8fac:	4240      	negs	r0, r0
    8fae:	e001      	b.n	8fb4 <MQTTSerialize_connect+0x160>
	size_t len = 0;

	len = MQTTSerialize_GetConnectLength(options);
	if(MQTTPacket_len(len) > buflen) {
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
    8fb0:	2009      	movs	r0, #9
    8fb2:	4240      	negs	r0, r0

	*serialized_len = (uint32_t)(ptr - buf);

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
}
    8fb4:	b005      	add	sp, #20
    8fb6:	bc0c      	pop	{r2, r3}
    8fb8:	4690      	mov	r8, r2
    8fba:	4699      	mov	r9, r3
    8fbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8fbe:	46c0      	nop			; (mov r8, r8)
    8fc0:	00008dd1 	.word	0x00008dd1
    8fc4:	0000936d 	.word	0x0000936d
    8fc8:	00009575 	.word	0x00009575
    8fcc:	000093e5 	.word	0x000093e5
    8fd0:	000092e5 	.word	0x000092e5
    8fd4:	00015390 	.word	0x00015390
    8fd8:	0000944d 	.word	0x0000944d
    8fdc:	00015398 	.word	0x00015398
    8fe0:	00009409 	.word	0x00009409
    8fe4:	00009485 	.word	0x00009485

00008fe8 <MQTTDeserialize_connack>:
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return MQTTReturnCode indicating function execution status
  */
MQTTReturnCode MQTTDeserialize_connack(unsigned char *sessionPresent,
									   MQTTReturnCode *connack_rc,
									   unsigned char *buf, size_t buflen) {
    8fe8:	b570      	push	{r4, r5, r6, lr}
    8fea:	b084      	sub	sp, #16
    8fec:	0004      	movs	r4, r0
    8fee:	000d      	movs	r5, r1
	FUNC_ENTRY;
	if(NULL == sessionPresent || NULL == connack_rc || NULL == buf) {
    8ff0:	2800      	cmp	r0, #0
    8ff2:	d049      	beq.n	9088 <MQTTDeserialize_connack+0xa0>
    8ff4:	2900      	cmp	r1, #0
    8ff6:	d04a      	beq.n	908e <MQTTDeserialize_connack+0xa6>
    8ff8:	2a00      	cmp	r2, #0
    8ffa:	d04b      	beq.n	9094 <MQTTDeserialize_connack+0xac>
	}

	/* CONNACK header size is fixed at two bytes for fixed and 2 bytes for variable,
	 * using that as minimum size
	 * MQTT v3.1.1 Specification 3.2.1 */
	if(4 > buflen) {
    8ffc:	2b03      	cmp	r3, #3
    8ffe:	d94c      	bls.n	909a <MQTTDeserialize_connack+0xb2>
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
	}

	MQTTHeader header = {0};
	unsigned char *curdata = buf;
    9000:	9203      	str	r2, [sp, #12]
	unsigned char *enddata = NULL;
	MQTTReturnCode rc = FAILURE;
	uint32_t decodedLen = 0;
    9002:	2300      	movs	r3, #0
    9004:	9302      	str	r3, [sp, #8]
	uint32_t readBytesLen = 0;
    9006:	9301      	str	r3, [sp, #4]
	MQTTConnackFlags flags = {0};

	header.byte = readChar(&curdata);
    9008:	a803      	add	r0, sp, #12
    900a:	4b29      	ldr	r3, [pc, #164]	; (90b0 <MQTTDeserialize_connack+0xc8>)
    900c:	4798      	blx	r3
	if(CONNACK != header.bits.type) {
    900e:	23f0      	movs	r3, #240	; 0xf0
    9010:	4018      	ands	r0, r3
    9012:	2820      	cmp	r0, #32
    9014:	d144      	bne.n	90a0 <MQTTDeserialize_connack+0xb8>
		FUNC_EXIT_RC(FAILURE);
		return FAILURE;
	}

	/* read remaining length */
	rc = MQTTPacket_decodeBuf(curdata, &decodedLen, &readBytesLen);
    9016:	aa01      	add	r2, sp, #4
    9018:	a902      	add	r1, sp, #8
    901a:	9803      	ldr	r0, [sp, #12]
    901c:	4b25      	ldr	r3, [pc, #148]	; (90b4 <MQTTDeserialize_connack+0xcc>)
    901e:	4798      	blx	r3
	if(SUCCESS != rc) {
    9020:	2800      	cmp	r0, #0
    9022:	d142      	bne.n	90aa <MQTTDeserialize_connack+0xc2>
		FUNC_EXIT_RC(rc);
		return rc;
	}

	curdata += (readBytesLen);
    9024:	9b03      	ldr	r3, [sp, #12]
    9026:	9a01      	ldr	r2, [sp, #4]
    9028:	4694      	mov	ip, r2
    902a:	4463      	add	r3, ip
    902c:	9303      	str	r3, [sp, #12]
	enddata = curdata + decodedLen;
	if(enddata - curdata < 2) {
    902e:	9b02      	ldr	r3, [sp, #8]
    9030:	2b01      	cmp	r3, #1
    9032:	dd38      	ble.n	90a6 <MQTTDeserialize_connack+0xbe>
		FUNC_EXIT_RC(FAILURE);
		return FAILURE;
	}

	flags.all = readChar(&curdata);
    9034:	a803      	add	r0, sp, #12
    9036:	4e1e      	ldr	r6, [pc, #120]	; (90b0 <MQTTDeserialize_connack+0xc8>)
    9038:	47b0      	blx	r6
	*sessionPresent = flags.bits.sessionpresent;
    903a:	0600      	lsls	r0, r0, #24
    903c:	0fc0      	lsrs	r0, r0, #31
    903e:	7020      	strb	r0, [r4, #0]
	unsigned char connack_rc_char = readChar(&curdata);
    9040:	a803      	add	r0, sp, #12
    9042:	47b0      	blx	r6
	switch(connack_rc_char) {
    9044:	2805      	cmp	r0, #5
    9046:	d81b      	bhi.n	9080 <MQTTDeserialize_connack+0x98>
    9048:	0080      	lsls	r0, r0, #2
    904a:	4b1b      	ldr	r3, [pc, #108]	; (90b8 <MQTTDeserialize_connack+0xd0>)
    904c:	581b      	ldr	r3, [r3, r0]
    904e:	469f      	mov	pc, r3
		case CONNACK_CONNECTION_ACCEPTED:
			*connack_rc = MQTT_CONNACK_CONNECTION_ACCEPTED;
    9050:	2304      	movs	r3, #4
    9052:	702b      	strb	r3, [r5, #0]
			*connack_rc = MQTT_CONNACK_UNKNOWN_ERROR;
			break;
	}

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    9054:	2000      	movs	r0, #0
	*sessionPresent = flags.bits.sessionpresent;
	unsigned char connack_rc_char = readChar(&curdata);
	switch(connack_rc_char) {
		case CONNACK_CONNECTION_ACCEPTED:
			*connack_rc = MQTT_CONNACK_CONNECTION_ACCEPTED;
			break;
    9056:	e028      	b.n	90aa <MQTTDeserialize_connack+0xc2>
		case CONANCK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR:
			*connack_rc = MQTT_CONANCK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR;
    9058:	23f3      	movs	r3, #243	; 0xf3
    905a:	702b      	strb	r3, [r5, #0]
			*connack_rc = MQTT_CONNACK_UNKNOWN_ERROR;
			break;
	}

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    905c:	2000      	movs	r0, #0
		case CONNACK_CONNECTION_ACCEPTED:
			*connack_rc = MQTT_CONNACK_CONNECTION_ACCEPTED;
			break;
		case CONANCK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR:
			*connack_rc = MQTT_CONANCK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR;
			break;
    905e:	e024      	b.n	90aa <MQTTDeserialize_connack+0xc2>
		case CONNACK_IDENTIFIER_REJECTED_ERROR:
			*connack_rc = MQTT_CONNACK_IDENTIFIER_REJECTED_ERROR;
    9060:	23f2      	movs	r3, #242	; 0xf2
    9062:	702b      	strb	r3, [r5, #0]
			*connack_rc = MQTT_CONNACK_UNKNOWN_ERROR;
			break;
	}

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    9064:	2000      	movs	r0, #0
		case CONANCK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR:
			*connack_rc = MQTT_CONANCK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR;
			break;
		case CONNACK_IDENTIFIER_REJECTED_ERROR:
			*connack_rc = MQTT_CONNACK_IDENTIFIER_REJECTED_ERROR;
			break;
    9066:	e020      	b.n	90aa <MQTTDeserialize_connack+0xc2>
		case CONNACK_SERVER_UNAVAILABLE_ERROR:
			*connack_rc = MQTT_CONNACK_SERVER_UNAVAILABLE_ERROR;
    9068:	23f1      	movs	r3, #241	; 0xf1
    906a:	702b      	strb	r3, [r5, #0]
			*connack_rc = MQTT_CONNACK_UNKNOWN_ERROR;
			break;
	}

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    906c:	2000      	movs	r0, #0
		case CONNACK_IDENTIFIER_REJECTED_ERROR:
			*connack_rc = MQTT_CONNACK_IDENTIFIER_REJECTED_ERROR;
			break;
		case CONNACK_SERVER_UNAVAILABLE_ERROR:
			*connack_rc = MQTT_CONNACK_SERVER_UNAVAILABLE_ERROR;
			break;
    906e:	e01c      	b.n	90aa <MQTTDeserialize_connack+0xc2>
		case CONNACK_BAD_USERDATA_ERROR:
			*connack_rc = MQTT_CONNACK_BAD_USERDATA_ERROR;
    9070:	23f0      	movs	r3, #240	; 0xf0
    9072:	702b      	strb	r3, [r5, #0]
			*connack_rc = MQTT_CONNACK_UNKNOWN_ERROR;
			break;
	}

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    9074:	2000      	movs	r0, #0
		case CONNACK_SERVER_UNAVAILABLE_ERROR:
			*connack_rc = MQTT_CONNACK_SERVER_UNAVAILABLE_ERROR;
			break;
		case CONNACK_BAD_USERDATA_ERROR:
			*connack_rc = MQTT_CONNACK_BAD_USERDATA_ERROR;
			break;
    9076:	e018      	b.n	90aa <MQTTDeserialize_connack+0xc2>
		case CONNACK_NOT_AUTHORIZED_ERROR:
			*connack_rc = MQTT_CONNACK_NOT_AUTHORIZED_ERROR;
    9078:	23ef      	movs	r3, #239	; 0xef
    907a:	702b      	strb	r3, [r5, #0]
			*connack_rc = MQTT_CONNACK_UNKNOWN_ERROR;
			break;
	}

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    907c:	2000      	movs	r0, #0
		case CONNACK_BAD_USERDATA_ERROR:
			*connack_rc = MQTT_CONNACK_BAD_USERDATA_ERROR;
			break;
		case CONNACK_NOT_AUTHORIZED_ERROR:
			*connack_rc = MQTT_CONNACK_NOT_AUTHORIZED_ERROR;
			break;
    907e:	e014      	b.n	90aa <MQTTDeserialize_connack+0xc2>
		default:
			*connack_rc = MQTT_CONNACK_UNKNOWN_ERROR;
    9080:	23f4      	movs	r3, #244	; 0xf4
    9082:	702b      	strb	r3, [r5, #0]
			break;
	}

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    9084:	2000      	movs	r0, #0
		case CONNACK_NOT_AUTHORIZED_ERROR:
			*connack_rc = MQTT_CONNACK_NOT_AUTHORIZED_ERROR;
			break;
		default:
			*connack_rc = MQTT_CONNACK_UNKNOWN_ERROR;
			break;
    9086:	e010      	b.n	90aa <MQTTDeserialize_connack+0xc2>
									   MQTTReturnCode *connack_rc,
									   unsigned char *buf, size_t buflen) {
	FUNC_ENTRY;
	if(NULL == sessionPresent || NULL == connack_rc || NULL == buf) {
		FUNC_EXIT_RC(MQTT_NULL_VALUE_ERROR);
		return MQTT_NULL_VALUE_ERROR;
    9088:	2006      	movs	r0, #6
    908a:	4240      	negs	r0, r0
    908c:	e00d      	b.n	90aa <MQTTDeserialize_connack+0xc2>
    908e:	2006      	movs	r0, #6
    9090:	4240      	negs	r0, r0
    9092:	e00a      	b.n	90aa <MQTTDeserialize_connack+0xc2>
    9094:	2006      	movs	r0, #6
    9096:	4240      	negs	r0, r0
    9098:	e007      	b.n	90aa <MQTTDeserialize_connack+0xc2>
	/* CONNACK header size is fixed at two bytes for fixed and 2 bytes for variable,
	 * using that as minimum size
	 * MQTT v3.1.1 Specification 3.2.1 */
	if(4 > buflen) {
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
    909a:	2009      	movs	r0, #9
    909c:	4240      	negs	r0, r0
    909e:	e004      	b.n	90aa <MQTTDeserialize_connack+0xc2>
	MQTTConnackFlags flags = {0};

	header.byte = readChar(&curdata);
	if(CONNACK != header.bits.type) {
		FUNC_EXIT_RC(FAILURE);
		return FAILURE;
    90a0:	2001      	movs	r0, #1
    90a2:	4240      	negs	r0, r0
    90a4:	e001      	b.n	90aa <MQTTDeserialize_connack+0xc2>

	curdata += (readBytesLen);
	enddata = curdata + decodedLen;
	if(enddata - curdata < 2) {
		FUNC_EXIT_RC(FAILURE);
		return FAILURE;
    90a6:	2001      	movs	r0, #1
    90a8:	4240      	negs	r0, r0
			break;
	}

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
}
    90aa:	b004      	add	sp, #16
    90ac:	bd70      	pop	{r4, r5, r6, pc}
    90ae:	46c0      	nop			; (mov r8, r8)
    90b0:	000093d9 	.word	0x000093d9
    90b4:	00009395 	.word	0x00009395
    90b8:	00015378 	.word	0x00015378

000090bc <MQTTSerialize_zero>:
  * @param serialized length
  * @return MQTTReturnCode indicating function execution status
  */
MQTTReturnCode MQTTSerialize_zero(unsigned char *buf, size_t buflen,
								  unsigned char packetType,
								  uint32_t *serialized_length) {
    90bc:	b570      	push	{r4, r5, r6, lr}
    90be:	b084      	sub	sp, #16
    90c0:	0004      	movs	r4, r0
    90c2:	001e      	movs	r6, r3
	FUNC_ENTRY;
	if(NULL == buf || NULL == serialized_length) {
    90c4:	2800      	cmp	r0, #0
    90c6:	d01e      	beq.n	9106 <MQTTSerialize_zero+0x4a>
    90c8:	2b00      	cmp	r3, #0
    90ca:	d01f      	beq.n	910c <MQTTSerialize_zero+0x50>
		FUNC_EXIT_RC(MQTT_NULL_VALUE_ERROR);
		return MQTT_NULL_VALUE_ERROR;
	}

	/* Buffer should have at least 2 bytes for the header */
	if(4 > buflen) {
    90cc:	2903      	cmp	r1, #3
    90ce:	d920      	bls.n	9112 <MQTTSerialize_zero+0x56>
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
	}

	MQTTHeader header = {0};
    90d0:	2300      	movs	r3, #0
    90d2:	9303      	str	r3, [sp, #12]
	unsigned char *ptr = buf;
    90d4:	9002      	str	r0, [sp, #8]

	MQTTReturnCode rc = MQTTPacket_InitHeader(&header, packetType, QOS0, 0, 0);
    90d6:	b251      	sxtb	r1, r2
    90d8:	9300      	str	r3, [sp, #0]
    90da:	2200      	movs	r2, #0
    90dc:	a803      	add	r0, sp, #12
    90de:	4d0f      	ldr	r5, [pc, #60]	; (911c <MQTTSerialize_zero+0x60>)
    90e0:	47a8      	blx	r5
    90e2:	1e05      	subs	r5, r0, #0
	if(SUCCESS != rc) {
    90e4:	d117      	bne.n	9116 <MQTTSerialize_zero+0x5a>
		FUNC_EXIT_RC(rc);
		return rc;
	}

	/* write header */
	writeChar(&ptr, header.byte);
    90e6:	ab03      	add	r3, sp, #12
    90e8:	7819      	ldrb	r1, [r3, #0]
    90ea:	a802      	add	r0, sp, #8
    90ec:	4b0c      	ldr	r3, [pc, #48]	; (9120 <MQTTSerialize_zero+0x64>)
    90ee:	4798      	blx	r3

	/* write remaining length */
	ptr += MQTTPacket_encode(ptr, 0);
    90f0:	2100      	movs	r1, #0
    90f2:	9802      	ldr	r0, [sp, #8]
    90f4:	4b0b      	ldr	r3, [pc, #44]	; (9124 <MQTTSerialize_zero+0x68>)
    90f6:	4798      	blx	r3
	*serialized_length = (uint32_t)(ptr - buf);
    90f8:	9b02      	ldr	r3, [sp, #8]
    90fa:	469c      	mov	ip, r3
    90fc:	4460      	add	r0, ip
    90fe:	1b04      	subs	r4, r0, r4
    9100:	6034      	str	r4, [r6, #0]

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    9102:	0028      	movs	r0, r5
    9104:	e007      	b.n	9116 <MQTTSerialize_zero+0x5a>
								  unsigned char packetType,
								  uint32_t *serialized_length) {
	FUNC_ENTRY;
	if(NULL == buf || NULL == serialized_length) {
		FUNC_EXIT_RC(MQTT_NULL_VALUE_ERROR);
		return MQTT_NULL_VALUE_ERROR;
    9106:	2006      	movs	r0, #6
    9108:	4240      	negs	r0, r0
    910a:	e004      	b.n	9116 <MQTTSerialize_zero+0x5a>
    910c:	2006      	movs	r0, #6
    910e:	4240      	negs	r0, r0
    9110:	e001      	b.n	9116 <MQTTSerialize_zero+0x5a>
	}

	/* Buffer should have at least 2 bytes for the header */
	if(4 > buflen) {
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
    9112:	2009      	movs	r0, #9
    9114:	4240      	negs	r0, r0
	ptr += MQTTPacket_encode(ptr, 0);
	*serialized_length = (uint32_t)(ptr - buf);

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
}
    9116:	b004      	add	sp, #16
    9118:	bd70      	pop	{r4, r5, r6, pc}
    911a:	46c0      	nop			; (mov r8, r8)
    911c:	00009575 	.word	0x00009575
    9120:	000093e5 	.word	0x000093e5
    9124:	000092e5 	.word	0x000092e5

00009128 <MQTTSerialize_disconnect>:
  * @param buflen the length in bytes of the supplied buffer, to avoid overruns
  * @param serialized length
  * @return MQTTReturnCode indicating function execution status
  */
MQTTReturnCode MQTTSerialize_disconnect(unsigned char *buf, size_t buflen,
										uint32_t *serialized_length) {
    9128:	b510      	push	{r4, lr}
    912a:	0013      	movs	r3, r2
	return MQTTSerialize_zero(buf, buflen, DISCONNECT, serialized_length);
    912c:	220e      	movs	r2, #14
    912e:	4c01      	ldr	r4, [pc, #4]	; (9134 <MQTTSerialize_disconnect+0xc>)
    9130:	47a0      	blx	r4
}
    9132:	bd10      	pop	{r4, pc}
    9134:	000090bd 	.word	0x000090bd

00009138 <MQTTSerialize_pingreq>:
  * @param buflen the length in bytes of the supplied buffer, to avoid overruns
  * @param serialized length
  * @return MQTTReturnCode indicating function execution status
  */
MQTTReturnCode MQTTSerialize_pingreq(unsigned char *buf, size_t buflen,
									 uint32_t *serialized_length) {
    9138:	b510      	push	{r4, lr}
    913a:	0013      	movs	r3, r2
	return MQTTSerialize_zero(buf, buflen, PINGREQ, serialized_length);
    913c:	220c      	movs	r2, #12
    913e:	4c01      	ldr	r4, [pc, #4]	; (9144 <MQTTSerialize_pingreq+0xc>)
    9140:	47a0      	blx	r4
}
    9142:	bd10      	pop	{r4, pc}
    9144:	000090bd 	.word	0x000090bd

00009148 <MQTTDeserialize_publish>:
  * @return error code.  1 is success
  */
MQTTReturnCode MQTTDeserialize_publish(unsigned char *dup, QoS *qos,
									   unsigned char *retained, uint16_t *packetid,
									   MQTTString* topicName, unsigned char **payload,
									   uint32_t *payloadlen, unsigned char *buf, size_t buflen) {
    9148:	b5f0      	push	{r4, r5, r6, r7, lr}
    914a:	b085      	sub	sp, #20
    914c:	0007      	movs	r7, r0
    914e:	000c      	movs	r4, r1
    9150:	0015      	movs	r5, r2
    9152:	001e      	movs	r6, r3
	FUNC_ENTRY;
	if(NULL == dup || NULL == qos || NULL == retained || NULL == packetid) {
    9154:	2800      	cmp	r0, #0
    9156:	d045      	beq.n	91e4 <MQTTDeserialize_publish+0x9c>
    9158:	2900      	cmp	r1, #0
    915a:	d046      	beq.n	91ea <MQTTDeserialize_publish+0xa2>
    915c:	2a00      	cmp	r2, #0
    915e:	d047      	beq.n	91f0 <MQTTDeserialize_publish+0xa8>
    9160:	2b00      	cmp	r3, #0
    9162:	d048      	beq.n	91f6 <MQTTDeserialize_publish+0xae>
	 * Fixed header is two bytes.
	 * Variable header size depends on QoS And Topic Name.
	 * QoS level 0 doesn't have a message identifier (0 - 2 bytes)
	 * Topic Name length fields decide size of topic name field (at least 2 bytes)
	 * MQTT v3.1.1 Specification 3.3.1 */
	if(4 > buflen) {
    9164:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    9166:	2b03      	cmp	r3, #3
    9168:	d948      	bls.n	91fc <MQTTDeserialize_publish+0xb4>
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
	}

	MQTTHeader header = {0};
	unsigned char *curdata = buf;
    916a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    916c:	9303      	str	r3, [sp, #12]
	unsigned char *enddata = NULL;
	MQTTReturnCode rc = FAILURE;
	uint32_t decodedLen = 0;
    916e:	2300      	movs	r3, #0
    9170:	9302      	str	r3, [sp, #8]
	uint32_t readBytesLen = 0;
    9172:	9301      	str	r3, [sp, #4]

	header.byte = readChar(&curdata);
    9174:	a803      	add	r0, sp, #12
    9176:	4b28      	ldr	r3, [pc, #160]	; (9218 <MQTTDeserialize_publish+0xd0>)
    9178:	4798      	blx	r3
	if(PUBLISH != header.bits.type) {
    917a:	23f0      	movs	r3, #240	; 0xf0
    917c:	4003      	ands	r3, r0
    917e:	2b30      	cmp	r3, #48	; 0x30
    9180:	d13f      	bne.n	9202 <MQTTDeserialize_publish+0xba>
		FUNC_EXIT_RC(FAILURE);
		return FAILURE;
	}

	*dup = header.bits.dup;
    9182:	0703      	lsls	r3, r0, #28
    9184:	0fdb      	lsrs	r3, r3, #31
    9186:	703b      	strb	r3, [r7, #0]
	*qos = (QoS)header.bits.qos;
    9188:	0743      	lsls	r3, r0, #29
    918a:	0f9b      	lsrs	r3, r3, #30
    918c:	7023      	strb	r3, [r4, #0]
	*retained = header.bits.retain;
    918e:	07c0      	lsls	r0, r0, #31
    9190:	0fc0      	lsrs	r0, r0, #31
    9192:	7028      	strb	r0, [r5, #0]

	/* read remaining length */
	rc = MQTTPacket_decodeBuf(curdata, &decodedLen, &readBytesLen);
    9194:	aa01      	add	r2, sp, #4
    9196:	a902      	add	r1, sp, #8
    9198:	9803      	ldr	r0, [sp, #12]
    919a:	4b20      	ldr	r3, [pc, #128]	; (921c <MQTTDeserialize_publish+0xd4>)
    919c:	4798      	blx	r3
	if(SUCCESS != rc) {
		FUNC_EXIT_RC(rc);
		return rc;
    919e:	1e05      	subs	r5, r0, #0
	*qos = (QoS)header.bits.qos;
	*retained = header.bits.retain;

	/* read remaining length */
	rc = MQTTPacket_decodeBuf(curdata, &decodedLen, &readBytesLen);
	if(SUCCESS != rc) {
    91a0:	d137      	bne.n	9212 <MQTTDeserialize_publish+0xca>
		FUNC_EXIT_RC(rc);
		return rc;
	}
	curdata += (readBytesLen);
    91a2:	9b03      	ldr	r3, [sp, #12]
    91a4:	9a01      	ldr	r2, [sp, #4]
    91a6:	4694      	mov	ip, r2
    91a8:	4463      	add	r3, ip
    91aa:	001f      	movs	r7, r3
    91ac:	9303      	str	r3, [sp, #12]
	enddata = curdata + decodedLen;
    91ae:	9b02      	ldr	r3, [sp, #8]
    91b0:	469c      	mov	ip, r3
    91b2:	4467      	add	r7, ip

	/* do we have enough data to read the protocol version byte? */
	if(SUCCESS != readMQTTLenString(topicName, &curdata, enddata) || (0 > (enddata - curdata))) {
    91b4:	003a      	movs	r2, r7
    91b6:	a903      	add	r1, sp, #12
    91b8:	980a      	ldr	r0, [sp, #40]	; 0x28
    91ba:	4b19      	ldr	r3, [pc, #100]	; (9220 <MQTTDeserialize_publish+0xd8>)
    91bc:	4798      	blx	r3
    91be:	1e05      	subs	r5, r0, #0
    91c0:	d122      	bne.n	9208 <MQTTDeserialize_publish+0xc0>
    91c2:	9b03      	ldr	r3, [sp, #12]
    91c4:	1afb      	subs	r3, r7, r3
    91c6:	d422      	bmi.n	920e <MQTTDeserialize_publish+0xc6>
		FUNC_EXIT_RC(FAILURE);
		return FAILURE;
	}

	if(QOS0 != *qos) {
    91c8:	7823      	ldrb	r3, [r4, #0]
    91ca:	2b00      	cmp	r3, #0
    91cc:	d003      	beq.n	91d6 <MQTTDeserialize_publish+0x8e>
		*packetid = readPacketId(&curdata);
    91ce:	a803      	add	r0, sp, #12
    91d0:	4b14      	ldr	r3, [pc, #80]	; (9224 <MQTTDeserialize_publish+0xdc>)
    91d2:	4798      	blx	r3
    91d4:	8030      	strh	r0, [r6, #0]
	}

	*payloadlen = (uint32_t)(enddata - curdata);
    91d6:	9b03      	ldr	r3, [sp, #12]
    91d8:	1aff      	subs	r7, r7, r3
    91da:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    91dc:	6017      	str	r7, [r2, #0]
	*payload = curdata;
    91de:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    91e0:	6013      	str	r3, [r2, #0]

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    91e2:	e016      	b.n	9212 <MQTTDeserialize_publish+0xca>
									   MQTTString* topicName, unsigned char **payload,
									   uint32_t *payloadlen, unsigned char *buf, size_t buflen) {
	FUNC_ENTRY;
	if(NULL == dup || NULL == qos || NULL == retained || NULL == packetid) {
		FUNC_EXIT_RC(FAILURE);
		return FAILURE;
    91e4:	2501      	movs	r5, #1
    91e6:	426d      	negs	r5, r5
    91e8:	e013      	b.n	9212 <MQTTDeserialize_publish+0xca>
    91ea:	2501      	movs	r5, #1
    91ec:	426d      	negs	r5, r5
    91ee:	e010      	b.n	9212 <MQTTDeserialize_publish+0xca>
    91f0:	2501      	movs	r5, #1
    91f2:	426d      	negs	r5, r5
    91f4:	e00d      	b.n	9212 <MQTTDeserialize_publish+0xca>
    91f6:	2501      	movs	r5, #1
    91f8:	426d      	negs	r5, r5
    91fa:	e00a      	b.n	9212 <MQTTDeserialize_publish+0xca>
	 * QoS level 0 doesn't have a message identifier (0 - 2 bytes)
	 * Topic Name length fields decide size of topic name field (at least 2 bytes)
	 * MQTT v3.1.1 Specification 3.3.1 */
	if(4 > buflen) {
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
    91fc:	2509      	movs	r5, #9
    91fe:	426d      	negs	r5, r5
    9200:	e007      	b.n	9212 <MQTTDeserialize_publish+0xca>
	uint32_t readBytesLen = 0;

	header.byte = readChar(&curdata);
	if(PUBLISH != header.bits.type) {
		FUNC_EXIT_RC(FAILURE);
		return FAILURE;
    9202:	2501      	movs	r5, #1
    9204:	426d      	negs	r5, r5
    9206:	e004      	b.n	9212 <MQTTDeserialize_publish+0xca>
	enddata = curdata + decodedLen;

	/* do we have enough data to read the protocol version byte? */
	if(SUCCESS != readMQTTLenString(topicName, &curdata, enddata) || (0 > (enddata - curdata))) {
		FUNC_EXIT_RC(FAILURE);
		return FAILURE;
    9208:	2501      	movs	r5, #1
    920a:	426d      	negs	r5, r5
    920c:	e001      	b.n	9212 <MQTTDeserialize_publish+0xca>
    920e:	2501      	movs	r5, #1
    9210:	426d      	negs	r5, r5
	*payloadlen = (uint32_t)(enddata - curdata);
	*payload = curdata;

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
}
    9212:	0028      	movs	r0, r5
    9214:	b005      	add	sp, #20
    9216:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9218:	000093d9 	.word	0x000093d9
    921c:	00009395 	.word	0x00009395
    9220:	000094d5 	.word	0x000094d5
    9224:	000093c5 	.word	0x000093c5

00009228 <MQTTDeserialize_ack>:
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success, 0 is failure
  */
MQTTReturnCode MQTTDeserialize_ack(unsigned char *packettype, unsigned char *dup,
								   uint16_t *packetid, unsigned char *buf,
								   size_t buflen) {
    9228:	b570      	push	{r4, r5, r6, lr}
    922a:	b084      	sub	sp, #16
    922c:	0004      	movs	r4, r0
    922e:	000e      	movs	r6, r1
    9230:	0015      	movs	r5, r2
	FUNC_ENTRY;
	if(NULL == packettype || NULL == dup || NULL == packetid || NULL == buf) {
    9232:	2800      	cmp	r0, #0
    9234:	d02a      	beq.n	928c <MQTTDeserialize_ack+0x64>
    9236:	2900      	cmp	r1, #0
    9238:	d02b      	beq.n	9292 <MQTTDeserialize_ack+0x6a>
    923a:	2a00      	cmp	r2, #0
    923c:	d02c      	beq.n	9298 <MQTTDeserialize_ack+0x70>
    923e:	2b00      	cmp	r3, #0
    9240:	d02d      	beq.n	929e <MQTTDeserialize_ack+0x76>
		FUNC_EXIT_RC(MQTT_NULL_VALUE_ERROR);
		return MQTT_NULL_VALUE_ERROR;
	}

	/* PUBACK fixed header size is two bytes, variable header is 2 bytes, MQTT v3.1.1 Specification 3.4.1 */
	if(4 > buflen) {
    9242:	9a08      	ldr	r2, [sp, #32]
    9244:	2a03      	cmp	r2, #3
    9246:	d92d      	bls.n	92a4 <MQTTDeserialize_ack+0x7c>
		return MQTTPACKET_BUFFER_TOO_SHORT;
	}

	MQTTReturnCode rc = FAILURE;
	MQTTHeader header = {0};
	unsigned char *curdata = buf;
    9248:	9303      	str	r3, [sp, #12]
	unsigned char *enddata = NULL;
	uint32_t decodedLen = 0;
    924a:	2300      	movs	r3, #0
    924c:	9302      	str	r3, [sp, #8]
	uint32_t readBytesLen = 0;
    924e:	9301      	str	r3, [sp, #4]

	header.byte = readChar(&curdata);
    9250:	a803      	add	r0, sp, #12
    9252:	4b18      	ldr	r3, [pc, #96]	; (92b4 <MQTTDeserialize_ack+0x8c>)
    9254:	4798      	blx	r3
	*dup = header.bits.dup;
    9256:	0703      	lsls	r3, r0, #28
    9258:	0fdb      	lsrs	r3, r3, #31
    925a:	7033      	strb	r3, [r6, #0]
	*packettype = header.bits.type;
    925c:	0600      	lsls	r0, r0, #24
    925e:	0f00      	lsrs	r0, r0, #28
    9260:	7020      	strb	r0, [r4, #0]

	/* read remaining length */
	rc = MQTTPacket_decodeBuf(curdata, &decodedLen, &readBytesLen);
    9262:	aa01      	add	r2, sp, #4
    9264:	a902      	add	r1, sp, #8
    9266:	9803      	ldr	r0, [sp, #12]
    9268:	4b13      	ldr	r3, [pc, #76]	; (92b8 <MQTTDeserialize_ack+0x90>)
    926a:	4798      	blx	r3
	if(SUCCESS != rc) {
    926c:	2800      	cmp	r0, #0
    926e:	d11e      	bne.n	92ae <MQTTDeserialize_ack+0x86>
		FUNC_EXIT_RC(rc);
		return rc;
	}
	curdata += (readBytesLen);
    9270:	9b03      	ldr	r3, [sp, #12]
    9272:	9a01      	ldr	r2, [sp, #4]
    9274:	4694      	mov	ip, r2
    9276:	4463      	add	r3, ip
    9278:	9303      	str	r3, [sp, #12]
	enddata = curdata + decodedLen;

	if(enddata - curdata < 2) {
    927a:	9b02      	ldr	r3, [sp, #8]
    927c:	2b01      	cmp	r3, #1
    927e:	dd14      	ble.n	92aa <MQTTDeserialize_ack+0x82>
		FUNC_EXIT_RC(FAILURE);
		return FAILURE;
	}

	*packetid = readPacketId(&curdata);
    9280:	a803      	add	r0, sp, #12
    9282:	4b0e      	ldr	r3, [pc, #56]	; (92bc <MQTTDeserialize_ack+0x94>)
    9284:	4798      	blx	r3
    9286:	8028      	strh	r0, [r5, #0]

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    9288:	2000      	movs	r0, #0
    928a:	e010      	b.n	92ae <MQTTDeserialize_ack+0x86>
								   uint16_t *packetid, unsigned char *buf,
								   size_t buflen) {
	FUNC_ENTRY;
	if(NULL == packettype || NULL == dup || NULL == packetid || NULL == buf) {
		FUNC_EXIT_RC(MQTT_NULL_VALUE_ERROR);
		return MQTT_NULL_VALUE_ERROR;
    928c:	2006      	movs	r0, #6
    928e:	4240      	negs	r0, r0
    9290:	e00d      	b.n	92ae <MQTTDeserialize_ack+0x86>
    9292:	2006      	movs	r0, #6
    9294:	4240      	negs	r0, r0
    9296:	e00a      	b.n	92ae <MQTTDeserialize_ack+0x86>
    9298:	2006      	movs	r0, #6
    929a:	4240      	negs	r0, r0
    929c:	e007      	b.n	92ae <MQTTDeserialize_ack+0x86>
    929e:	2006      	movs	r0, #6
    92a0:	4240      	negs	r0, r0
    92a2:	e004      	b.n	92ae <MQTTDeserialize_ack+0x86>
	}

	/* PUBACK fixed header size is two bytes, variable header is 2 bytes, MQTT v3.1.1 Specification 3.4.1 */
	if(4 > buflen) {
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
    92a4:	2009      	movs	r0, #9
    92a6:	4240      	negs	r0, r0
    92a8:	e001      	b.n	92ae <MQTTDeserialize_ack+0x86>
	curdata += (readBytesLen);
	enddata = curdata + decodedLen;

	if(enddata - curdata < 2) {
		FUNC_EXIT_RC(FAILURE);
		return FAILURE;
    92aa:	2001      	movs	r0, #1
    92ac:	4240      	negs	r0, r0

	*packetid = readPacketId(&curdata);

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    92ae:	b004      	add	sp, #16
    92b0:	bd70      	pop	{r4, r5, r6, pc}
    92b2:	46c0      	nop			; (mov r8, r8)
    92b4:	000093d9 	.word	0x000093d9
    92b8:	00009395 	.word	0x00009395
    92bc:	000093c5 	.word	0x000093c5

000092c0 <bufchar>:
	return rem_len;
}

static unsigned char *bufptr;

uint32_t bufchar(unsigned char *c, uint32_t count) {
    92c0:	b530      	push	{r4, r5, lr}
	uint32_t i;

	for(i = 0; i < count; ++i) {
    92c2:	2900      	cmp	r1, #0
    92c4:	d00a      	beq.n	92dc <bufchar+0x1c>
    92c6:	4b06      	ldr	r3, [pc, #24]	; (92e0 <bufchar+0x20>)
    92c8:	681b      	ldr	r3, [r3, #0]
    92ca:	185d      	adds	r5, r3, r1
    92cc:	002c      	movs	r4, r5
		*c = *bufptr++;
    92ce:	781a      	ldrb	r2, [r3, #0]
    92d0:	7002      	strb	r2, [r0, #0]
    92d2:	3301      	adds	r3, #1
static unsigned char *bufptr;

uint32_t bufchar(unsigned char *c, uint32_t count) {
	uint32_t i;

	for(i = 0; i < count; ++i) {
    92d4:	42a3      	cmp	r3, r4
    92d6:	d1fa      	bne.n	92ce <bufchar+0xe>
    92d8:	4b01      	ldr	r3, [pc, #4]	; (92e0 <bufchar+0x20>)
    92da:	601d      	str	r5, [r3, #0]
		*c = *bufptr++;
	}

	return count;
}
    92dc:	0008      	movs	r0, r1
    92de:	bd30      	pop	{r4, r5, pc}
    92e0:	200017c8 	.word	0x200017c8

000092e4 <MQTTPacket_encode>:
 * Encodes the message length according to the MQTT algorithm
 * @param buf the buffer into which the encoded data is written
 * @param length the length to be encoded
 * @return the number of bytes written to buffer
 */
uint32_t MQTTPacket_encode(unsigned char *buf, size_t length) {
    92e4:	b530      	push	{r4, r5, lr}
    92e6:	0002      	movs	r2, r0
    92e8:	2000      	movs	r0, #0
	uint32_t outLen = 0;

	FUNC_ENTRY;
	do {
		int16_t d = length % 128;
    92ea:	247f      	movs	r4, #127	; 0x7f
		length /= 128;
		/* if there are more digits to encode, set the top bit of this digit */
		if(length > 0) {
			d |= 0x80;
		}
		buf[outLen++] = (unsigned char)d;
    92ec:	2580      	movs	r5, #128	; 0x80
uint32_t MQTTPacket_encode(unsigned char *buf, size_t length) {
	uint32_t outLen = 0;

	FUNC_ENTRY;
	do {
		int16_t d = length % 128;
    92ee:	0023      	movs	r3, r4
    92f0:	400b      	ands	r3, r1
		length /= 128;
    92f2:	09c9      	lsrs	r1, r1, #7
		/* if there are more digits to encode, set the top bit of this digit */
		if(length > 0) {
    92f4:	d003      	beq.n	92fe <MQTTPacket_encode+0x1a>
			d |= 0x80;
		}
		buf[outLen++] = (unsigned char)d;
    92f6:	432b      	orrs	r3, r5
    92f8:	5413      	strb	r3, [r2, r0]
    92fa:	3001      	adds	r0, #1
    92fc:	e7f7      	b.n	92ee <MQTTPacket_encode+0xa>
    92fe:	5413      	strb	r3, [r2, r0]
	}while(length > 0);

	FUNC_EXIT_RC(outLen);
	return outLen;
    9300:	3001      	adds	r0, #1
}
    9302:	bd30      	pop	{r4, r5, pc}

00009304 <MQTTPacket_decode>:
 * Decodes the message length according to the MQTT algorithm
 * @param getcharfn pointer to function to read the next character from the data source
 * @param value the decoded length returned
 * @return the number of bytes read from the socket
 */
MQTTReturnCode MQTTPacket_decode(uint32_t (*getcharfn)(unsigned char *, uint32_t), uint32_t *value, uint32_t *readBytesLen) {
    9304:	b5f0      	push	{r4, r5, r6, r7, lr}
    9306:	464f      	mov	r7, r9
    9308:	4646      	mov	r6, r8
    930a:	b4c0      	push	{r6, r7}
    930c:	b085      	sub	sp, #20
    930e:	4681      	mov	r9, r0
    9310:	000e      	movs	r6, r1
    9312:	9201      	str	r2, [sp, #4]
	uint32_t len = 0;
	uint32_t getLen = 0;
#define MAX_NO_OF_REMAINING_LENGTH_BYTES 4

	FUNC_ENTRY;
	*value = 0;
    9314:	2300      	movs	r3, #0
    9316:	600b      	str	r3, [r1, #0]
	do {
		if(++len > MAX_NO_OF_REMAINING_LENGTH_BYTES) {
    9318:	2701      	movs	r7, #1
 * @param value the decoded length returned
 * @return the number of bytes read from the socket
 */
MQTTReturnCode MQTTPacket_decode(uint32_t (*getcharfn)(unsigned char *, uint32_t), uint32_t *value, uint32_t *readBytesLen) {
	unsigned char c;
	uint32_t multiplier = 1;
    931a:	2401      	movs	r4, #1
		if(++len > MAX_NO_OF_REMAINING_LENGTH_BYTES) {
			/* bad data */
			FUNC_EXIT_RC(MQTTPACKET_READ_ERROR);
			return MQTTPACKET_READ_ERROR;
		}
		getLen = (*getcharfn)(&c, 1);
    931c:	ab02      	add	r3, sp, #8
    931e:	1ddd      	adds	r5, r3, #7
		if(1 != getLen) {
			FUNC_EXIT_RC(FAILURE);
			return FAILURE;
		}
		*value += (c & 127) * multiplier;
    9320:	237f      	movs	r3, #127	; 0x7f
    9322:	4698      	mov	r8, r3
    9324:	e002      	b.n	932c <MQTTPacket_decode+0x28>
#define MAX_NO_OF_REMAINING_LENGTH_BYTES 4

	FUNC_ENTRY;
	*value = 0;
	do {
		if(++len > MAX_NO_OF_REMAINING_LENGTH_BYTES) {
    9326:	3701      	adds	r7, #1
    9328:	2f05      	cmp	r7, #5
    932a:	d014      	beq.n	9356 <MQTTPacket_decode+0x52>
			/* bad data */
			FUNC_EXIT_RC(MQTTPACKET_READ_ERROR);
			return MQTTPACKET_READ_ERROR;
		}
		getLen = (*getcharfn)(&c, 1);
    932c:	2101      	movs	r1, #1
    932e:	0028      	movs	r0, r5
    9330:	47c8      	blx	r9
		if(1 != getLen) {
    9332:	2801      	cmp	r0, #1
    9334:	d112      	bne.n	935c <MQTTPacket_decode+0x58>
			FUNC_EXIT_RC(FAILURE);
			return FAILURE;
		}
		*value += (c & 127) * multiplier;
    9336:	782a      	ldrb	r2, [r5, #0]
    9338:	4643      	mov	r3, r8
    933a:	4013      	ands	r3, r2
    933c:	4363      	muls	r3, r4
    933e:	6831      	ldr	r1, [r6, #0]
    9340:	468c      	mov	ip, r1
    9342:	4463      	add	r3, ip
    9344:	6033      	str	r3, [r6, #0]
		multiplier *= 128;
    9346:	01e4      	lsls	r4, r4, #7
	}while((c & 128) != 0);
    9348:	b252      	sxtb	r2, r2
    934a:	2a00      	cmp	r2, #0
    934c:	dbeb      	blt.n	9326 <MQTTPacket_decode+0x22>

	*readBytesLen = len;
    934e:	9b01      	ldr	r3, [sp, #4]
    9350:	601f      	str	r7, [r3, #0]

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    9352:	2000      	movs	r0, #0
    9354:	e004      	b.n	9360 <MQTTPacket_decode+0x5c>
	*value = 0;
	do {
		if(++len > MAX_NO_OF_REMAINING_LENGTH_BYTES) {
			/* bad data */
			FUNC_EXIT_RC(MQTTPACKET_READ_ERROR);
			return MQTTPACKET_READ_ERROR;
    9356:	200a      	movs	r0, #10
    9358:	4240      	negs	r0, r0
    935a:	e001      	b.n	9360 <MQTTPacket_decode+0x5c>
		}
		getLen = (*getcharfn)(&c, 1);
		if(1 != getLen) {
			FUNC_EXIT_RC(FAILURE);
			return FAILURE;
    935c:	2001      	movs	r0, #1
    935e:	4240      	negs	r0, r0

	*readBytesLen = len;

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
}
    9360:	b005      	add	sp, #20
    9362:	bc0c      	pop	{r2, r3}
    9364:	4690      	mov	r8, r2
    9366:	4699      	mov	r9, r3
    9368:	bdf0      	pop	{r4, r5, r6, r7, pc}
    936a:	46c0      	nop			; (mov r8, r8)

0000936c <MQTTPacket_len>:

size_t MQTTPacket_len(size_t rem_len) {
    936c:	0003      	movs	r3, r0
	rem_len += 1; /* header byte */
    936e:	1c42      	adds	r2, r0, #1

	/* now remaining_length field */
	if(rem_len < 128) {
		rem_len += 1;
    9370:	3002      	adds	r0, #2

size_t MQTTPacket_len(size_t rem_len) {
	rem_len += 1; /* header byte */

	/* now remaining_length field */
	if(rem_len < 128) {
    9372:	2a7f      	cmp	r2, #127	; 0x7f
    9374:	d908      	bls.n	9388 <MQTTPacket_len+0x1c>
		rem_len += 1;
	} else if (rem_len < 16384) {
    9376:	4905      	ldr	r1, [pc, #20]	; (938c <MQTTPacket_len+0x20>)
		rem_len += 2;
    9378:	1cd8      	adds	r0, r3, #3
	rem_len += 1; /* header byte */

	/* now remaining_length field */
	if(rem_len < 128) {
		rem_len += 1;
	} else if (rem_len < 16384) {
    937a:	428a      	cmp	r2, r1
    937c:	d904      	bls.n	9388 <MQTTPacket_len+0x1c>
		rem_len += 2;
	} else if (rem_len < 2097151) {
		rem_len += 3;
	} else {
		rem_len += 4;
    937e:	1d58      	adds	r0, r3, #5
	/* now remaining_length field */
	if(rem_len < 128) {
		rem_len += 1;
	} else if (rem_len < 16384) {
		rem_len += 2;
	} else if (rem_len < 2097151) {
    9380:	4903      	ldr	r1, [pc, #12]	; (9390 <MQTTPacket_len+0x24>)
    9382:	428a      	cmp	r2, r1
    9384:	d800      	bhi.n	9388 <MQTTPacket_len+0x1c>
		rem_len += 3;
    9386:	1d18      	adds	r0, r3, #4
	} else {
		rem_len += 4;
	}

	return rem_len;
}
    9388:	4770      	bx	lr
    938a:	46c0      	nop			; (mov r8, r8)
    938c:	00003fff 	.word	0x00003fff
    9390:	001ffffe 	.word	0x001ffffe

00009394 <MQTTPacket_decodeBuf>:
	}

	return count;
}

MQTTReturnCode MQTTPacket_decodeBuf(unsigned char *buf, uint32_t *value, uint32_t *readBytesLen) {
    9394:	b510      	push	{r4, lr}
	bufptr = buf;
    9396:	4b03      	ldr	r3, [pc, #12]	; (93a4 <MQTTPacket_decodeBuf+0x10>)
    9398:	6018      	str	r0, [r3, #0]
	return MQTTPacket_decode(bufchar, value, readBytesLen);
    939a:	4803      	ldr	r0, [pc, #12]	; (93a8 <MQTTPacket_decodeBuf+0x14>)
    939c:	4b03      	ldr	r3, [pc, #12]	; (93ac <MQTTPacket_decodeBuf+0x18>)
    939e:	4798      	blx	r3
}
    93a0:	bd10      	pop	{r4, pc}
    93a2:	46c0      	nop			; (mov r8, r8)
    93a4:	200017c8 	.word	0x200017c8
    93a8:	000092c1 	.word	0x000092c1
    93ac:	00009305 	.word	0x00009305

000093b0 <readSizeT>:
/**
 * Calculates an integer from two bytes read from the input buffer
 * @param pptr pointer to the input buffer - incremented by the number of bytes used & returned
 * @return the integer value calculated
 */
size_t readSizeT(unsigned char **pptr) {
    93b0:	b510      	push	{r4, lr}
    93b2:	0004      	movs	r4, r0
	unsigned char *ptr = *pptr;
    93b4:	6803      	ldr	r3, [r0, #0]
	size_t firstByte = (size_t)(*ptr);
	size_t secondByte = (size_t)(*(ptr+1));
	size_t size = 256 * firstByte + secondByte;
    93b6:	7819      	ldrb	r1, [r3, #0]
    93b8:	0209      	lsls	r1, r1, #8
    93ba:	785a      	ldrb	r2, [r3, #1]
    93bc:	1888      	adds	r0, r1, r2
	*pptr += 2;
    93be:	3302      	adds	r3, #2
    93c0:	6023      	str	r3, [r4, #0]
	return size;
}
    93c2:	bd10      	pop	{r4, pc}

000093c4 <readPacketId>:
/**
 * Calculates uint16 packet id from two bytes read from the input buffer
 * @param pptr pointer to the input buffer - incremented by the number of bytes used & returned
 * @return the value calculated
 */
uint16_t readPacketId(unsigned char **pptr) {
    93c4:	0001      	movs	r1, r0
	unsigned char *ptr = *pptr;
    93c6:	6802      	ldr	r2, [r0, #0]
	uint8_t firstByte = (uint8_t)(*ptr);
	uint8_t secondByte = (uint8_t)(*(ptr + 1));
	uint16_t len = (uint16_t)(secondByte + (256 * firstByte));
    93c8:	7813      	ldrb	r3, [r2, #0]
    93ca:	021b      	lsls	r3, r3, #8
    93cc:	7850      	ldrb	r0, [r2, #1]
    93ce:	18c3      	adds	r3, r0, r3
    93d0:	b298      	uxth	r0, r3
	*pptr += 2;
    93d2:	3202      	adds	r2, #2
    93d4:	600a      	str	r2, [r1, #0]
	return len;
}
    93d6:	4770      	bx	lr

000093d8 <readChar>:
/**
 * Reads one character from the input buffer.
 * @param pptr pointer to the input buffer - incremented by the number of bytes used & returned
 * @return the character read
 */
unsigned char readChar(unsigned char **pptr) {
    93d8:	0002      	movs	r2, r0
	unsigned char c = **pptr;
    93da:	6803      	ldr	r3, [r0, #0]
    93dc:	7818      	ldrb	r0, [r3, #0]
	(*pptr)++;
    93de:	3301      	adds	r3, #1
    93e0:	6013      	str	r3, [r2, #0]
	return c;
}
    93e2:	4770      	bx	lr

000093e4 <writeChar>:
 * Writes one character to an output buffer.
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param c the character to write
 */
void writeChar(unsigned char **pptr, unsigned char c) {
	**pptr = c;
    93e4:	6803      	ldr	r3, [r0, #0]
    93e6:	7019      	strb	r1, [r3, #0]
	(*pptr)++;
    93e8:	6803      	ldr	r3, [r0, #0]
    93ea:	3301      	adds	r3, #1
    93ec:	6003      	str	r3, [r0, #0]
}
    93ee:	4770      	bx	lr

000093f0 <writePacketId>:
 * Writes an integer as 2 bytes to an output buffer.
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param anInt the integer to write
 */
void writePacketId(unsigned char** pptr, uint16_t anInt) {
	**pptr = (unsigned char)(anInt / 256);
    93f0:	0a0b      	lsrs	r3, r1, #8
    93f2:	6802      	ldr	r2, [r0, #0]
    93f4:	7013      	strb	r3, [r2, #0]
	(*pptr)++;
    93f6:	6803      	ldr	r3, [r0, #0]
    93f8:	1c5a      	adds	r2, r3, #1
    93fa:	6002      	str	r2, [r0, #0]
	**pptr = (unsigned char)(anInt % 256);
    93fc:	7059      	strb	r1, [r3, #1]
	(*pptr)++;
    93fe:	6803      	ldr	r3, [r0, #0]
    9400:	3301      	adds	r3, #1
    9402:	6003      	str	r3, [r0, #0]
}
    9404:	4770      	bx	lr
    9406:	46c0      	nop			; (mov r8, r8)

00009408 <writeInt>:
/**
 * Writes an integer as 2 bytes to an output buffer.
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param anInt the integer to write
 */
void writeInt(unsigned char **pptr, int32_t anInt) {
    9408:	b530      	push	{r4, r5, lr}
	**pptr = (unsigned char)(anInt / 256);
    940a:	17cb      	asrs	r3, r1, #31
    940c:	24ff      	movs	r4, #255	; 0xff
    940e:	0022      	movs	r2, r4
    9410:	401a      	ands	r2, r3
    9412:	1852      	adds	r2, r2, r1
    9414:	1212      	asrs	r2, r2, #8
    9416:	6805      	ldr	r5, [r0, #0]
    9418:	702a      	strb	r2, [r5, #0]
	(*pptr)++;
    941a:	6802      	ldr	r2, [r0, #0]
    941c:	1c55      	adds	r5, r2, #1
    941e:	6005      	str	r5, [r0, #0]
	**pptr = (unsigned char)(anInt % 256);
    9420:	0e1b      	lsrs	r3, r3, #24
    9422:	18c9      	adds	r1, r1, r3
    9424:	4021      	ands	r1, r4
    9426:	1ac9      	subs	r1, r1, r3
    9428:	7051      	strb	r1, [r2, #1]
	(*pptr)++;
    942a:	6803      	ldr	r3, [r0, #0]
    942c:	3301      	adds	r3, #1
    942e:	6003      	str	r3, [r0, #0]
}
    9430:	bd30      	pop	{r4, r5, pc}
    9432:	46c0      	nop			; (mov r8, r8)

00009434 <writeSizeT>:
 * Writes size as 2 bytes to an output buffer.
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param anInt the integer to write
 */
void writeSizeT(unsigned char **pptr, size_t size) {
	**pptr = (unsigned char)(size / 256);
    9434:	0a0b      	lsrs	r3, r1, #8
    9436:	6802      	ldr	r2, [r0, #0]
    9438:	7013      	strb	r3, [r2, #0]
	(*pptr)++;
    943a:	6803      	ldr	r3, [r0, #0]
    943c:	1c5a      	adds	r2, r3, #1
    943e:	6002      	str	r2, [r0, #0]
	**pptr = (unsigned char)(size % 256);
    9440:	7059      	strb	r1, [r3, #1]
	(*pptr)++;
    9442:	6803      	ldr	r3, [r0, #0]
    9444:	3301      	adds	r3, #1
    9446:	6003      	str	r3, [r0, #0]
}
    9448:	4770      	bx	lr
    944a:	46c0      	nop			; (mov r8, r8)

0000944c <writeCString>:
/**
 * Writes a "UTF" string to an output buffer.  Converts C string to length-delimited.
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param string the C string to write
 */
void writeCString(unsigned char **pptr, const char *string) {
    944c:	b570      	push	{r4, r5, r6, lr}
    944e:	0005      	movs	r5, r0
    9450:	000e      	movs	r6, r1
	size_t len = strlen(string);
    9452:	0008      	movs	r0, r1
    9454:	4b08      	ldr	r3, [pc, #32]	; (9478 <writeCString+0x2c>)
    9456:	4798      	blx	r3
    9458:	0004      	movs	r4, r0
	writeSizeT(pptr, len);
    945a:	0001      	movs	r1, r0
    945c:	0028      	movs	r0, r5
    945e:	4b07      	ldr	r3, [pc, #28]	; (947c <writeCString+0x30>)
    9460:	4798      	blx	r3
	memcpy(*pptr, string, len);
    9462:	0022      	movs	r2, r4
    9464:	0031      	movs	r1, r6
    9466:	6828      	ldr	r0, [r5, #0]
    9468:	4b05      	ldr	r3, [pc, #20]	; (9480 <writeCString+0x34>)
    946a:	4798      	blx	r3
	*pptr += len;
    946c:	682b      	ldr	r3, [r5, #0]
    946e:	469c      	mov	ip, r3
    9470:	4464      	add	r4, ip
    9472:	602c      	str	r4, [r5, #0]
}
    9474:	bd70      	pop	{r4, r5, r6, pc}
    9476:	46c0      	nop			; (mov r8, r8)
    9478:	00011d75 	.word	0x00011d75
    947c:	00009435 	.word	0x00009435
    9480:	00011833 	.word	0x00011833

00009484 <writeMQTTString>:

void writeMQTTString(unsigned char **pptr, MQTTString mqttstring) {
    9484:	b530      	push	{r4, r5, lr}
    9486:	b085      	sub	sp, #20
    9488:	0005      	movs	r5, r0
    948a:	9101      	str	r1, [sp, #4]
    948c:	9303      	str	r3, [sp, #12]
    948e:	1e14      	subs	r4, r2, #0
	if(mqttstring.lenstring.len > 0) {
    9490:	d00c      	beq.n	94ac <writeMQTTString+0x28>
		writeSizeT(pptr, mqttstring.lenstring.len);
    9492:	0011      	movs	r1, r2
    9494:	4b0b      	ldr	r3, [pc, #44]	; (94c4 <writeMQTTString+0x40>)
    9496:	4798      	blx	r3
		memcpy(*pptr, mqttstring.lenstring.data, mqttstring.lenstring.len);
    9498:	0022      	movs	r2, r4
    949a:	9903      	ldr	r1, [sp, #12]
    949c:	6828      	ldr	r0, [r5, #0]
    949e:	4b0a      	ldr	r3, [pc, #40]	; (94c8 <writeMQTTString+0x44>)
    94a0:	4798      	blx	r3
		*pptr += mqttstring.lenstring.len;
    94a2:	682b      	ldr	r3, [r5, #0]
    94a4:	469c      	mov	ip, r3
    94a6:	4464      	add	r4, ip
    94a8:	602c      	str	r4, [r5, #0]
    94aa:	e008      	b.n	94be <writeMQTTString+0x3a>
    94ac:	9901      	ldr	r1, [sp, #4]
	} else if (mqttstring.cstring) {
    94ae:	2900      	cmp	r1, #0
    94b0:	d002      	beq.n	94b8 <writeMQTTString+0x34>
		writeCString(pptr, mqttstring.cstring);
    94b2:	4b06      	ldr	r3, [pc, #24]	; (94cc <writeMQTTString+0x48>)
    94b4:	4798      	blx	r3
    94b6:	e002      	b.n	94be <writeMQTTString+0x3a>
	} else {
		writeInt(pptr, 0);
    94b8:	2100      	movs	r1, #0
    94ba:	4b05      	ldr	r3, [pc, #20]	; (94d0 <writeMQTTString+0x4c>)
    94bc:	4798      	blx	r3
	}
}
    94be:	b005      	add	sp, #20
    94c0:	bd30      	pop	{r4, r5, pc}
    94c2:	46c0      	nop			; (mov r8, r8)
    94c4:	00009435 	.word	0x00009435
    94c8:	00011833 	.word	0x00011833
    94cc:	0000944d 	.word	0x0000944d
    94d0:	00009409 	.word	0x00009409

000094d4 <readMQTTLenString>:
 * @param mqttstring the MQTTString structure into which the data is to be read
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param enddata pointer to the end of the data: do not read beyond
 * @return SUCCESS if successful, FAILURE if not
 */
MQTTReturnCode readMQTTLenString(MQTTString *mqttstring, unsigned char **pptr, unsigned char *enddata) {
    94d4:	b570      	push	{r4, r5, r6, lr}
    94d6:	0005      	movs	r5, r0
    94d8:	000c      	movs	r4, r1
    94da:	0016      	movs	r6, r2
	MQTTReturnCode rc = FAILURE;

	FUNC_ENTRY;
	/* the first two bytes are the length of the string */
	/* enough length to read the integer? */
	if(enddata - (*pptr) > 1) {
    94dc:	680b      	ldr	r3, [r1, #0]
    94de:	1ad3      	subs	r3, r2, r3
    94e0:	2b01      	cmp	r3, #1
    94e2:	dd0e      	ble.n	9502 <readMQTTLenString+0x2e>
		mqttstring->lenstring.len = readSizeT(pptr); /* increments pptr to point past length */
    94e4:	0008      	movs	r0, r1
    94e6:	4b0b      	ldr	r3, [pc, #44]	; (9514 <readMQTTLenString+0x40>)
    94e8:	4798      	blx	r3
    94ea:	6068      	str	r0, [r5, #4]
		if(&(*pptr)[mqttstring->lenstring.len] <= enddata) {
    94ec:	6823      	ldr	r3, [r4, #0]
    94ee:	181a      	adds	r2, r3, r0
    94f0:	4296      	cmp	r6, r2
    94f2:	d309      	bcc.n	9508 <readMQTTLenString+0x34>
			mqttstring->lenstring.data = (char*)*pptr;
    94f4:	60ab      	str	r3, [r5, #8]
			*pptr += mqttstring->lenstring.len;
    94f6:	6823      	ldr	r3, [r4, #0]
    94f8:	469c      	mov	ip, r3
    94fa:	4460      	add	r0, ip
    94fc:	6020      	str	r0, [r4, #0]
			rc = SUCCESS;
    94fe:	2000      	movs	r0, #0
    9500:	e004      	b.n	950c <readMQTTLenString+0x38>
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param enddata pointer to the end of the data: do not read beyond
 * @return SUCCESS if successful, FAILURE if not
 */
MQTTReturnCode readMQTTLenString(MQTTString *mqttstring, unsigned char **pptr, unsigned char *enddata) {
	MQTTReturnCode rc = FAILURE;
    9502:	2001      	movs	r0, #1
    9504:	4240      	negs	r0, r0
    9506:	e001      	b.n	950c <readMQTTLenString+0x38>
    9508:	2001      	movs	r0, #1
    950a:	4240      	negs	r0, r0
			mqttstring->lenstring.data = (char*)*pptr;
			*pptr += mqttstring->lenstring.len;
			rc = SUCCESS;
		}
	}
	mqttstring->cstring = NULL;
    950c:	2300      	movs	r3, #0
    950e:	602b      	str	r3, [r5, #0]

	FUNC_EXIT_RC(rc);
	return rc;
}
    9510:	bd70      	pop	{r4, r5, r6, pc}
    9512:	46c0      	nop			; (mov r8, r8)
    9514:	000093b1 	.word	0x000093b1

00009518 <MQTTstrlen>:
/**
 * Return the length of the MQTTstring - C string if there is one, otherwise the length delimited string
 * @param mqttstring the string to return the length of
 * @return the length of the string
 */
size_t MQTTstrlen(MQTTString mqttstring) {
    9518:	b500      	push	{lr}
    951a:	b085      	sub	sp, #20
    951c:	9102      	str	r1, [sp, #8]
	size_t len = 0;

	if(mqttstring.cstring) {
    951e:	2800      	cmp	r0, #0
    9520:	d002      	beq.n	9528 <MQTTstrlen+0x10>
		len = strlen(mqttstring.cstring);
    9522:	4b03      	ldr	r3, [pc, #12]	; (9530 <MQTTstrlen+0x18>)
    9524:	4798      	blx	r3
    9526:	e000      	b.n	952a <MQTTstrlen+0x12>
	} else {
		len = mqttstring.lenstring.len;
    9528:	9802      	ldr	r0, [sp, #8]
	}

	return len;
}
    952a:	b005      	add	sp, #20
    952c:	bd00      	pop	{pc}
    952e:	46c0      	nop			; (mov r8, r8)
    9530:	00011d75 	.word	0x00011d75

00009534 <MQTTPacket_equals>:
 * Compares an MQTTString to a C string
 * @param a the MQTTString to compare
 * @param bptr the C string to compare
 * @return boolean - equal or not
 */
uint8_t MQTTPacket_equals(MQTTString *a, char *bptr) {
    9534:	b570      	push	{r4, r5, r6, lr}
    9536:	000d      	movs	r5, r1
	size_t alen = 0;
	size_t	blen = 0;
	char *aptr;
	
	if(a->cstring) {
    9538:	6806      	ldr	r6, [r0, #0]
    953a:	2e00      	cmp	r6, #0
    953c:	d004      	beq.n	9548 <MQTTPacket_equals+0x14>
		aptr = a->cstring;
		alen = strlen(a->cstring);
    953e:	0030      	movs	r0, r6
    9540:	4b0a      	ldr	r3, [pc, #40]	; (956c <MQTTPacket_equals+0x38>)
    9542:	4798      	blx	r3
    9544:	0004      	movs	r4, r0
    9546:	e001      	b.n	954c <MQTTPacket_equals+0x18>
	} else {
		aptr = a->lenstring.data;
    9548:	6886      	ldr	r6, [r0, #8]
		alen = a->lenstring.len;
    954a:	6844      	ldr	r4, [r0, #4]
	}
	blen = strlen(bptr);
    954c:	0028      	movs	r0, r5
    954e:	4b07      	ldr	r3, [pc, #28]	; (956c <MQTTPacket_equals+0x38>)
    9550:	4798      	blx	r3
	
	return (alen == blen) && (strncmp(aptr, bptr, alen) == 0);
    9552:	2300      	movs	r3, #0
    9554:	4284      	cmp	r4, r0
    9556:	d106      	bne.n	9566 <MQTTPacket_equals+0x32>
    9558:	0022      	movs	r2, r4
    955a:	0029      	movs	r1, r5
    955c:	0030      	movs	r0, r6
    955e:	4b04      	ldr	r3, [pc, #16]	; (9570 <MQTTPacket_equals+0x3c>)
    9560:	4798      	blx	r3
    9562:	4243      	negs	r3, r0
    9564:	4143      	adcs	r3, r0
    9566:	b2d8      	uxtb	r0, r3
}
    9568:	bd70      	pop	{r4, r5, r6, pc}
    956a:	46c0      	nop			; (mov r8, r8)
    956c:	00011d75 	.word	0x00011d75
    9570:	00011d83 	.word	0x00011d83

00009574 <MQTTPacket_InitHeader>:
 * always initialized using the proper mappings. No Endianness issues here since
 * the individual fields are all less than a byte. Also generates no warnings since
 * all fields are initialized using hex constants
 */
MQTTReturnCode MQTTPacket_InitHeader(MQTTHeader *header, MessageTypes message_type,
						   QoS qos, uint8_t dup, uint8_t retained) {
    9574:	b530      	push	{r4, r5, lr}
    9576:	ac03      	add	r4, sp, #12
    9578:	7824      	ldrb	r4, [r4, #0]
	if(NULL == header) {
    957a:	2800      	cmp	r0, #0
    957c:	d100      	bne.n	9580 <MQTTPacket_InitHeader+0xc>
    957e:	e09b      	b.n	96b8 <MQTTPacket_InitHeader+0x144>
		return MQTT_NULL_VALUE_ERROR;
	}

	/* Set all bits to zero */
	header->byte = 0;
    9580:	2500      	movs	r5, #0
    9582:	7005      	strb	r5, [r0, #0]
	switch(message_type) {
    9584:	b2cd      	uxtb	r5, r1
    9586:	2d0e      	cmp	r5, #14
    9588:	d900      	bls.n	958c <MQTTPacket_InitHeader+0x18>
    958a:	e098      	b.n	96be <MQTTPacket_InitHeader+0x14a>
    958c:	00a9      	lsls	r1, r5, #2
    958e:	4d4d      	ldr	r5, [pc, #308]	; (96c4 <MQTTPacket_InitHeader+0x150>)
    9590:	5869      	ldr	r1, [r5, r1]
    9592:	468f      	mov	pc, r1
		case UNKNOWN:
			/* Should never happen */
			return MQTT_UNKNOWN_ERROR;
		case CONNECT:
			header->bits.type = 0x01;
    9594:	7801      	ldrb	r1, [r0, #0]
    9596:	250f      	movs	r5, #15
    9598:	4029      	ands	r1, r5
    959a:	2510      	movs	r5, #16
    959c:	4329      	orrs	r1, r5
    959e:	7001      	strb	r1, [r0, #0]
			break;
    95a0:	e059      	b.n	9656 <MQTTPacket_InitHeader+0xe2>
		case CONNACK:
			header->bits.type = 0x02;
    95a2:	7801      	ldrb	r1, [r0, #0]
    95a4:	250f      	movs	r5, #15
    95a6:	4029      	ands	r1, r5
    95a8:	2520      	movs	r5, #32
    95aa:	4329      	orrs	r1, r5
    95ac:	7001      	strb	r1, [r0, #0]
			break;
    95ae:	e052      	b.n	9656 <MQTTPacket_InitHeader+0xe2>
		case PUBLISH:
			header->bits.type = 0x03;
    95b0:	7801      	ldrb	r1, [r0, #0]
    95b2:	250f      	movs	r5, #15
    95b4:	4029      	ands	r1, r5
    95b6:	2530      	movs	r5, #48	; 0x30
    95b8:	4329      	orrs	r1, r5
    95ba:	7001      	strb	r1, [r0, #0]
			break;
    95bc:	e04b      	b.n	9656 <MQTTPacket_InitHeader+0xe2>
		case PUBACK:
			header->bits.type = 0x04;
    95be:	7801      	ldrb	r1, [r0, #0]
    95c0:	250f      	movs	r5, #15
    95c2:	4029      	ands	r1, r5
    95c4:	2540      	movs	r5, #64	; 0x40
    95c6:	4329      	orrs	r1, r5
    95c8:	7001      	strb	r1, [r0, #0]
			break;
    95ca:	e044      	b.n	9656 <MQTTPacket_InitHeader+0xe2>
		case PUBREC:
			header->bits.type = 0x05;
    95cc:	7801      	ldrb	r1, [r0, #0]
    95ce:	250f      	movs	r5, #15
    95d0:	4029      	ands	r1, r5
    95d2:	2550      	movs	r5, #80	; 0x50
    95d4:	4329      	orrs	r1, r5
    95d6:	7001      	strb	r1, [r0, #0]
			break;
    95d8:	e03d      	b.n	9656 <MQTTPacket_InitHeader+0xe2>
		case PUBREL:
			header->bits.type = 0x06;
    95da:	7801      	ldrb	r1, [r0, #0]
    95dc:	250f      	movs	r5, #15
    95de:	4029      	ands	r1, r5
    95e0:	2560      	movs	r5, #96	; 0x60
    95e2:	4329      	orrs	r1, r5
    95e4:	7001      	strb	r1, [r0, #0]
			break;
    95e6:	e036      	b.n	9656 <MQTTPacket_InitHeader+0xe2>
		case PUBCOMP:
			header->bits.type = 0x07;
    95e8:	7801      	ldrb	r1, [r0, #0]
    95ea:	250f      	movs	r5, #15
    95ec:	4029      	ands	r1, r5
    95ee:	2570      	movs	r5, #112	; 0x70
    95f0:	4329      	orrs	r1, r5
    95f2:	7001      	strb	r1, [r0, #0]
			break;
    95f4:	e02f      	b.n	9656 <MQTTPacket_InitHeader+0xe2>
		case SUBSCRIBE:
			header->bits.type = 0x08;
    95f6:	7801      	ldrb	r1, [r0, #0]
    95f8:	250f      	movs	r5, #15
    95fa:	4029      	ands	r1, r5
    95fc:	3d8f      	subs	r5, #143	; 0x8f
    95fe:	4329      	orrs	r1, r5
    9600:	7001      	strb	r1, [r0, #0]
			break;
    9602:	e028      	b.n	9656 <MQTTPacket_InitHeader+0xe2>
		case SUBACK:
			header->bits.type = 0x09;
    9604:	7801      	ldrb	r1, [r0, #0]
    9606:	250f      	movs	r5, #15
    9608:	4029      	ands	r1, r5
    960a:	3d7f      	subs	r5, #127	; 0x7f
    960c:	4329      	orrs	r1, r5
    960e:	7001      	strb	r1, [r0, #0]
			break;
    9610:	e021      	b.n	9656 <MQTTPacket_InitHeader+0xe2>
		case UNSUBSCRIBE:
			header->bits.type = 0x0A;
    9612:	7801      	ldrb	r1, [r0, #0]
    9614:	250f      	movs	r5, #15
    9616:	4029      	ands	r1, r5
    9618:	3d6f      	subs	r5, #111	; 0x6f
    961a:	4329      	orrs	r1, r5
    961c:	7001      	strb	r1, [r0, #0]
			break;
    961e:	e01a      	b.n	9656 <MQTTPacket_InitHeader+0xe2>
		case UNSUBACK:
			header->bits.type = 0x0B;
    9620:	7801      	ldrb	r1, [r0, #0]
    9622:	250f      	movs	r5, #15
    9624:	4029      	ands	r1, r5
    9626:	3d5f      	subs	r5, #95	; 0x5f
    9628:	4329      	orrs	r1, r5
    962a:	7001      	strb	r1, [r0, #0]
			break;
    962c:	e013      	b.n	9656 <MQTTPacket_InitHeader+0xe2>
		case PINGREQ:
			header->bits.type = 0x0C;
    962e:	7801      	ldrb	r1, [r0, #0]
    9630:	250f      	movs	r5, #15
    9632:	4029      	ands	r1, r5
    9634:	3d4f      	subs	r5, #79	; 0x4f
    9636:	4329      	orrs	r1, r5
    9638:	7001      	strb	r1, [r0, #0]
			break;
    963a:	e00c      	b.n	9656 <MQTTPacket_InitHeader+0xe2>
		case PINGRESP:
			header->bits.type = 0x0D;
    963c:	7801      	ldrb	r1, [r0, #0]
    963e:	250f      	movs	r5, #15
    9640:	4029      	ands	r1, r5
    9642:	3d3f      	subs	r5, #63	; 0x3f
    9644:	4329      	orrs	r1, r5
    9646:	7001      	strb	r1, [r0, #0]
			break;
    9648:	e005      	b.n	9656 <MQTTPacket_InitHeader+0xe2>
		case DISCONNECT:
			header->bits.type = 0x0E;
    964a:	7801      	ldrb	r1, [r0, #0]
    964c:	250f      	movs	r5, #15
    964e:	4029      	ands	r1, r5
    9650:	3d2f      	subs	r5, #47	; 0x2f
    9652:	4329      	orrs	r1, r5
    9654:	7001      	strb	r1, [r0, #0]
		default:
			/* Should never happen */
			return MQTT_UNKNOWN_ERROR;
	}

	header->bits.dup = (1 == dup) ? 0x01 : 0x00;
    9656:	3b01      	subs	r3, #1
    9658:	4259      	negs	r1, r3
    965a:	414b      	adcs	r3, r1
    965c:	00d9      	lsls	r1, r3, #3
    965e:	7803      	ldrb	r3, [r0, #0]
    9660:	2508      	movs	r5, #8
    9662:	43ab      	bics	r3, r5
    9664:	430b      	orrs	r3, r1
    9666:	7003      	strb	r3, [r0, #0]
	switch(qos) {
    9668:	2a01      	cmp	r2, #1
    966a:	d009      	beq.n	9680 <MQTTPacket_InitHeader+0x10c>
    966c:	2a00      	cmp	r2, #0
    966e:	d002      	beq.n	9676 <MQTTPacket_InitHeader+0x102>
    9670:	2a02      	cmp	r2, #2
    9672:	d00c      	beq.n	968e <MQTTPacket_InitHeader+0x11a>
    9674:	e012      	b.n	969c <MQTTPacket_InitHeader+0x128>
		case QOS0:
			header->bits.qos = 0x00;
    9676:	7803      	ldrb	r3, [r0, #0]
    9678:	2206      	movs	r2, #6
    967a:	4393      	bics	r3, r2
    967c:	7003      	strb	r3, [r0, #0]
			break;
    967e:	e011      	b.n	96a4 <MQTTPacket_InitHeader+0x130>
		case QOS1:
			header->bits.qos = 0x01;
    9680:	7803      	ldrb	r3, [r0, #0]
    9682:	2206      	movs	r2, #6
    9684:	4393      	bics	r3, r2
    9686:	2202      	movs	r2, #2
    9688:	4313      	orrs	r3, r2
    968a:	7003      	strb	r3, [r0, #0]
			break;
    968c:	e00a      	b.n	96a4 <MQTTPacket_InitHeader+0x130>
		case QOS2:
			header->bits.qos = 0x02;
    968e:	7803      	ldrb	r3, [r0, #0]
    9690:	2206      	movs	r2, #6
    9692:	4393      	bics	r3, r2
    9694:	2204      	movs	r2, #4
    9696:	4313      	orrs	r3, r2
    9698:	7003      	strb	r3, [r0, #0]
			break;
    969a:	e003      	b.n	96a4 <MQTTPacket_InitHeader+0x130>
		default:
			/* Using QOS0 as default */
			header->bits.qos = 0x00;
    969c:	7803      	ldrb	r3, [r0, #0]
    969e:	2206      	movs	r2, #6
    96a0:	4393      	bics	r3, r2
    96a2:	7003      	strb	r3, [r0, #0]
			break;
	}

	header->bits.retain = (1 == retained) ? 0x01 : 0x00;
    96a4:	3c01      	subs	r4, #1
    96a6:	4263      	negs	r3, r4
    96a8:	4163      	adcs	r3, r4
    96aa:	7804      	ldrb	r4, [r0, #0]
    96ac:	2201      	movs	r2, #1
    96ae:	4394      	bics	r4, r2
    96b0:	431c      	orrs	r4, r3
    96b2:	7004      	strb	r4, [r0, #0]

	return SUCCESS;
    96b4:	2000      	movs	r0, #0
    96b6:	e004      	b.n	96c2 <MQTTPacket_InitHeader+0x14e>
 * all fields are initialized using hex constants
 */
MQTTReturnCode MQTTPacket_InitHeader(MQTTHeader *header, MessageTypes message_type,
						   QoS qos, uint8_t dup, uint8_t retained) {
	if(NULL == header) {
		return MQTT_NULL_VALUE_ERROR;
    96b8:	2006      	movs	r0, #6
    96ba:	4240      	negs	r0, r0
    96bc:	e001      	b.n	96c2 <MQTTPacket_InitHeader+0x14e>
	/* Set all bits to zero */
	header->byte = 0;
	switch(message_type) {
		case UNKNOWN:
			/* Should never happen */
			return MQTT_UNKNOWN_ERROR;
    96be:	2003      	movs	r0, #3
    96c0:	4240      	negs	r0, r0
	}

	header->bits.retain = (1 == retained) ? 0x01 : 0x00;

	return SUCCESS;
}
    96c2:	bd30      	pop	{r4, r5, pc}
    96c4:	000153a0 	.word	0x000153a0

000096c8 <MQTTSerialize_GetPublishLength>:
  * @param qos the MQTT QoS of the publish (packetid is omitted for QoS 0)
  * @param topicName the topic name to be used in the publish  
  * @param payloadlen the length of the payload to be sent
  * @return the length of buffer needed to contain the serialized version of the packet
  */
size_t MQTTSerialize_GetPublishLength(uint8_t qos, MQTTString topicName, size_t payloadlen) {
    96c8:	b510      	push	{r4, lr}
    96ca:	b084      	sub	sp, #16
    96cc:	0004      	movs	r4, r0
	size_t len = 0;

	len += 2 + MQTTstrlen(topicName) + payloadlen;
    96ce:	0008      	movs	r0, r1
    96d0:	0011      	movs	r1, r2
    96d2:	001a      	movs	r2, r3
    96d4:	4b04      	ldr	r3, [pc, #16]	; (96e8 <MQTTSerialize_GetPublishLength+0x20>)
    96d6:	4798      	blx	r3
    96d8:	9b06      	ldr	r3, [sp, #24]
    96da:	18c3      	adds	r3, r0, r3
	if(qos > 0) {
		len += 2; /* packetid */
    96dc:	1d18      	adds	r0, r3, #4
  */
size_t MQTTSerialize_GetPublishLength(uint8_t qos, MQTTString topicName, size_t payloadlen) {
	size_t len = 0;

	len += 2 + MQTTstrlen(topicName) + payloadlen;
	if(qos > 0) {
    96de:	2c00      	cmp	r4, #0
    96e0:	d100      	bne.n	96e4 <MQTTSerialize_GetPublishLength+0x1c>
  * @return the length of buffer needed to contain the serialized version of the packet
  */
size_t MQTTSerialize_GetPublishLength(uint8_t qos, MQTTString topicName, size_t payloadlen) {
	size_t len = 0;

	len += 2 + MQTTstrlen(topicName) + payloadlen;
    96e2:	1c98      	adds	r0, r3, #2
	if(qos > 0) {
		len += 2; /* packetid */
	}
	return len;
}
    96e4:	b004      	add	sp, #16
    96e6:	bd10      	pop	{r4, pc}
    96e8:	00009519 	.word	0x00009519

000096ec <MQTTSerialize_publish>:
  * @return the length of the serialized data.  <= 0 indicates error
  */
MQTTReturnCode MQTTSerialize_publish(unsigned char *buf, size_t buflen, uint8_t dup,
						  QoS qos, uint8_t retained, uint16_t packetid,
						  MQTTString topicName, unsigned char *payload, size_t payloadlen,
						  uint32_t *serialized_len) {
    96ec:	b5f0      	push	{r4, r5, r6, r7, lr}
    96ee:	464f      	mov	r7, r9
    96f0:	b480      	push	{r7}
    96f2:	b086      	sub	sp, #24
    96f4:	0004      	movs	r4, r0
    96f6:	000d      	movs	r5, r1
    96f8:	9203      	str	r2, [sp, #12]
    96fa:	0018      	movs	r0, r3
    96fc:	9302      	str	r3, [sp, #8]
    96fe:	ab0c      	add	r3, sp, #48	; 0x30
    9700:	781f      	ldrb	r7, [r3, #0]
    9702:	ab0d      	add	r3, sp, #52	; 0x34
    9704:	8819      	ldrh	r1, [r3, #0]
    9706:	4689      	mov	r9, r1
	FUNC_ENTRY;
	if(NULL == buf || NULL == payload || NULL == serialized_len) {
    9708:	2c00      	cmp	r4, #0
    970a:	d045      	beq.n	9798 <MQTTSerialize_publish+0xac>
    970c:	9911      	ldr	r1, [sp, #68]	; 0x44
    970e:	2900      	cmp	r1, #0
    9710:	d045      	beq.n	979e <MQTTSerialize_publish+0xb2>
    9712:	9913      	ldr	r1, [sp, #76]	; 0x4c
    9714:	2900      	cmp	r1, #0
    9716:	d045      	beq.n	97a4 <MQTTSerialize_publish+0xb8>
		FUNC_EXIT_RC(MQTT_NULL_VALUE_ERROR);
		return MQTT_NULL_VALUE_ERROR;
	}

	unsigned char *ptr = buf;
    9718:	9405      	str	r4, [sp, #20]
	MQTTHeader header = {0};
    971a:	2300      	movs	r3, #0
    971c:	9304      	str	r3, [sp, #16]
	size_t rem_len = 0;

	rem_len = MQTTSerialize_GetPublishLength(qos, topicName, payloadlen);
    971e:	9912      	ldr	r1, [sp, #72]	; 0x48
    9720:	9100      	str	r1, [sp, #0]
    9722:	990e      	ldr	r1, [sp, #56]	; 0x38
    9724:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    9726:	9b10      	ldr	r3, [sp, #64]	; 0x40
    9728:	4e23      	ldr	r6, [pc, #140]	; (97b8 <MQTTSerialize_publish+0xcc>)
    972a:	47b0      	blx	r6
    972c:	0006      	movs	r6, r0
	if(MQTTPacket_len(rem_len) > buflen) {
    972e:	4b23      	ldr	r3, [pc, #140]	; (97bc <MQTTSerialize_publish+0xd0>)
    9730:	4798      	blx	r3
    9732:	42a8      	cmp	r0, r5
    9734:	d839      	bhi.n	97aa <MQTTSerialize_publish+0xbe>
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
	}

	MQTTReturnCode rc = MQTTPacket_InitHeader(&header, PUBLISH, qos, dup, retained);
    9736:	9700      	str	r7, [sp, #0]
    9738:	9b03      	ldr	r3, [sp, #12]
    973a:	9a02      	ldr	r2, [sp, #8]
    973c:	2103      	movs	r1, #3
    973e:	a804      	add	r0, sp, #16
    9740:	4f1f      	ldr	r7, [pc, #124]	; (97c0 <MQTTSerialize_publish+0xd4>)
    9742:	47b8      	blx	r7
	if(SUCCESS != rc) {
    9744:	2800      	cmp	r0, #0
    9746:	d132      	bne.n	97ae <MQTTSerialize_publish+0xc2>
		FUNC_EXIT_RC(rc);
		return rc;
	}
	writeChar(&ptr, header.byte); /* write header */
    9748:	ab04      	add	r3, sp, #16
    974a:	7819      	ldrb	r1, [r3, #0]
    974c:	a805      	add	r0, sp, #20
    974e:	4b1d      	ldr	r3, [pc, #116]	; (97c4 <MQTTSerialize_publish+0xd8>)
    9750:	4798      	blx	r3

	ptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;
    9752:	0031      	movs	r1, r6
    9754:	9805      	ldr	r0, [sp, #20]
    9756:	4b1c      	ldr	r3, [pc, #112]	; (97c8 <MQTTSerialize_publish+0xdc>)
    9758:	4798      	blx	r3
    975a:	9b05      	ldr	r3, [sp, #20]
    975c:	469c      	mov	ip, r3
    975e:	4460      	add	r0, ip
    9760:	9005      	str	r0, [sp, #20]

	writeMQTTString(&ptr, topicName);
    9762:	990e      	ldr	r1, [sp, #56]	; 0x38
    9764:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    9766:	9b10      	ldr	r3, [sp, #64]	; 0x40
    9768:	a805      	add	r0, sp, #20
    976a:	4e18      	ldr	r6, [pc, #96]	; (97cc <MQTTSerialize_publish+0xe0>)
    976c:	47b0      	blx	r6

	if(qos > 0) {
    976e:	9b02      	ldr	r3, [sp, #8]
    9770:	2b00      	cmp	r3, #0
    9772:	d003      	beq.n	977c <MQTTSerialize_publish+0x90>
		writeInt(&ptr, packetid);
    9774:	4649      	mov	r1, r9
    9776:	a805      	add	r0, sp, #20
    9778:	4b15      	ldr	r3, [pc, #84]	; (97d0 <MQTTSerialize_publish+0xe4>)
    977a:	4798      	blx	r3
	}

	memcpy(ptr, payload, payloadlen);
    977c:	9a12      	ldr	r2, [sp, #72]	; 0x48
    977e:	9911      	ldr	r1, [sp, #68]	; 0x44
    9780:	9805      	ldr	r0, [sp, #20]
    9782:	4b14      	ldr	r3, [pc, #80]	; (97d4 <MQTTSerialize_publish+0xe8>)
    9784:	4798      	blx	r3
	ptr += payloadlen;

	*serialized_len = (uint32_t)(ptr - buf);
    9786:	9b05      	ldr	r3, [sp, #20]
    9788:	9a12      	ldr	r2, [sp, #72]	; 0x48
    978a:	4694      	mov	ip, r2
    978c:	4463      	add	r3, ip
    978e:	1b18      	subs	r0, r3, r4
    9790:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    9792:	6018      	str	r0, [r3, #0]

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    9794:	2000      	movs	r0, #0
    9796:	e00a      	b.n	97ae <MQTTSerialize_publish+0xc2>
						  MQTTString topicName, unsigned char *payload, size_t payloadlen,
						  uint32_t *serialized_len) {
	FUNC_ENTRY;
	if(NULL == buf || NULL == payload || NULL == serialized_len) {
		FUNC_EXIT_RC(MQTT_NULL_VALUE_ERROR);
		return MQTT_NULL_VALUE_ERROR;
    9798:	2006      	movs	r0, #6
    979a:	4240      	negs	r0, r0
    979c:	e007      	b.n	97ae <MQTTSerialize_publish+0xc2>
    979e:	2006      	movs	r0, #6
    97a0:	4240      	negs	r0, r0
    97a2:	e004      	b.n	97ae <MQTTSerialize_publish+0xc2>
    97a4:	2006      	movs	r0, #6
    97a6:	4240      	negs	r0, r0
    97a8:	e001      	b.n	97ae <MQTTSerialize_publish+0xc2>
	size_t rem_len = 0;

	rem_len = MQTTSerialize_GetPublishLength(qos, topicName, payloadlen);
	if(MQTTPacket_len(rem_len) > buflen) {
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
    97aa:	2009      	movs	r0, #9
    97ac:	4240      	negs	r0, r0

	*serialized_len = (uint32_t)(ptr - buf);

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
}
    97ae:	b006      	add	sp, #24
    97b0:	bc04      	pop	{r2}
    97b2:	4691      	mov	r9, r2
    97b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    97b6:	46c0      	nop			; (mov r8, r8)
    97b8:	000096c9 	.word	0x000096c9
    97bc:	0000936d 	.word	0x0000936d
    97c0:	00009575 	.word	0x00009575
    97c4:	000093e5 	.word	0x000093e5
    97c8:	000092e5 	.word	0x000092e5
    97cc:	00009485 	.word	0x00009485
    97d0:	00009409 	.word	0x00009409
    97d4:	00011833 	.word	0x00011833

000097d8 <MQTTSerialize_ack>:
  * @param packetid the MQTT packet identifier
  * @return serialized length, or error if 0
  */
MQTTReturnCode MQTTSerialize_ack(unsigned char *buf, size_t buflen,
					  unsigned char type, uint8_t dup, uint16_t packetid,
					  uint32_t *serialized_len) {
    97d8:	b570      	push	{r4, r5, r6, lr}
    97da:	b084      	sub	sp, #16
    97dc:	0005      	movs	r5, r0
    97de:	0014      	movs	r4, r2
    97e0:	aa08      	add	r2, sp, #32
    97e2:	8816      	ldrh	r6, [r2, #0]
	FUNC_ENTRY;
	if(NULL == buf || serialized_len == NULL) {
    97e4:	2800      	cmp	r0, #0
    97e6:	d02a      	beq.n	983e <MQTTSerialize_ack+0x66>
    97e8:	9a09      	ldr	r2, [sp, #36]	; 0x24
    97ea:	2a00      	cmp	r2, #0
    97ec:	d02a      	beq.n	9844 <MQTTSerialize_ack+0x6c>
		FUNC_EXIT_RC(MQTT_NULL_VALUE_ERROR);
		return MQTT_NULL_VALUE_ERROR;
	}

	MQTTHeader header = {0};
    97ee:	2200      	movs	r2, #0
    97f0:	9203      	str	r2, [sp, #12]
	unsigned char *ptr = buf;
    97f2:	9002      	str	r0, [sp, #8]

	/* Minimum byte length required by ACK headers is
	 * 2 for fixed and 2 for variable part */
	if(4 > buflen) {
    97f4:	2903      	cmp	r1, #3
    97f6:	d928      	bls.n	984a <MQTTSerialize_ack+0x72>
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
	}

	QoS requestQoS = (PUBREL == type) ? QOS1 : QOS0;
	MQTTReturnCode rc = MQTTPacket_InitHeader(&header, type, requestQoS, dup, 0);
    97f8:	1fa0      	subs	r0, r4, #6
    97fa:	4242      	negs	r2, r0
    97fc:	4150      	adcs	r0, r2
    97fe:	b2c2      	uxtb	r2, r0
    9800:	b261      	sxtb	r1, r4
    9802:	2000      	movs	r0, #0
    9804:	9000      	str	r0, [sp, #0]
    9806:	a803      	add	r0, sp, #12
    9808:	4c12      	ldr	r4, [pc, #72]	; (9854 <MQTTSerialize_ack+0x7c>)
    980a:	47a0      	blx	r4
    980c:	1e04      	subs	r4, r0, #0
	if(SUCCESS != rc) {
    980e:	d11e      	bne.n	984e <MQTTSerialize_ack+0x76>
		FUNC_EXIT_RC(rc);
		return rc;
	}
	writeChar(&ptr, header.byte); /* write header */
    9810:	ab03      	add	r3, sp, #12
    9812:	7819      	ldrb	r1, [r3, #0]
    9814:	a802      	add	r0, sp, #8
    9816:	4b10      	ldr	r3, [pc, #64]	; (9858 <MQTTSerialize_ack+0x80>)
    9818:	4798      	blx	r3

	ptr += MQTTPacket_encode(ptr, 2); /* write remaining length */
    981a:	2102      	movs	r1, #2
    981c:	9802      	ldr	r0, [sp, #8]
    981e:	4b0f      	ldr	r3, [pc, #60]	; (985c <MQTTSerialize_ack+0x84>)
    9820:	4798      	blx	r3
    9822:	9b02      	ldr	r3, [sp, #8]
    9824:	469c      	mov	ip, r3
    9826:	4460      	add	r0, ip
    9828:	9002      	str	r0, [sp, #8]
	writePacketId(&ptr, packetid);
    982a:	0031      	movs	r1, r6
    982c:	a802      	add	r0, sp, #8
    982e:	4b0c      	ldr	r3, [pc, #48]	; (9860 <MQTTSerialize_ack+0x88>)
    9830:	4798      	blx	r3
	*serialized_len = (uint32_t)(ptr - buf);
    9832:	9b02      	ldr	r3, [sp, #8]
    9834:	1b5d      	subs	r5, r3, r5
    9836:	9b09      	ldr	r3, [sp, #36]	; 0x24
    9838:	601d      	str	r5, [r3, #0]

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    983a:	0020      	movs	r0, r4
    983c:	e007      	b.n	984e <MQTTSerialize_ack+0x76>
					  unsigned char type, uint8_t dup, uint16_t packetid,
					  uint32_t *serialized_len) {
	FUNC_ENTRY;
	if(NULL == buf || serialized_len == NULL) {
		FUNC_EXIT_RC(MQTT_NULL_VALUE_ERROR);
		return MQTT_NULL_VALUE_ERROR;
    983e:	2006      	movs	r0, #6
    9840:	4240      	negs	r0, r0
    9842:	e004      	b.n	984e <MQTTSerialize_ack+0x76>
    9844:	2006      	movs	r0, #6
    9846:	4240      	negs	r0, r0
    9848:	e001      	b.n	984e <MQTTSerialize_ack+0x76>

	/* Minimum byte length required by ACK headers is
	 * 2 for fixed and 2 for variable part */
	if(4 > buflen) {
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
    984a:	2009      	movs	r0, #9
    984c:	4240      	negs	r0, r0
	writePacketId(&ptr, packetid);
	*serialized_len = (uint32_t)(ptr - buf);

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
}
    984e:	b004      	add	sp, #16
    9850:	bd70      	pop	{r4, r5, r6, pc}
    9852:	46c0      	nop			; (mov r8, r8)
    9854:	00009575 	.word	0x00009575
    9858:	000093e5 	.word	0x000093e5
    985c:	000092e5 	.word	0x000092e5
    9860:	000093f1 	.word	0x000093f1

00009864 <MQTTSerialize_GetSubscribePacketLength>:
  * Determines the length of the MQTT subscribe packet that would be produced using the supplied parameters
  * @param count the number of topic filter strings in topicFilters
  * @param topicFilters the array of topic filter strings to be used in the publish
  * @return the length of buffer needed to contain the serialized version of the packet
  */
size_t MQTTSerialize_GetSubscribePacketLength(uint32_t count, MQTTString topicFilters[]) {
    9864:	b5f0      	push	{r4, r5, r6, r7, lr}
    9866:	4647      	mov	r7, r8
    9868:	b480      	push	{r7}
    986a:	1e07      	subs	r7, r0, #0
	size_t i;
	size_t len = 2; /* packetid */

	for(i = 0; i < count; ++i) {
    986c:	d00f      	beq.n	988e <MQTTSerialize_GetSubscribePacketLength+0x2a>
    986e:	000c      	movs	r4, r1
    9870:	2602      	movs	r6, #2
    9872:	2500      	movs	r5, #0
		len += 2 + MQTTstrlen(topicFilters[i]) + 1; /* length + topic + req_qos */
    9874:	4b08      	ldr	r3, [pc, #32]	; (9898 <MQTTSerialize_GetSubscribePacketLength+0x34>)
    9876:	4698      	mov	r8, r3
    9878:	6820      	ldr	r0, [r4, #0]
    987a:	6861      	ldr	r1, [r4, #4]
    987c:	68a2      	ldr	r2, [r4, #8]
    987e:	47c0      	blx	r8
    9880:	3003      	adds	r0, #3
    9882:	1836      	adds	r6, r6, r0
  */
size_t MQTTSerialize_GetSubscribePacketLength(uint32_t count, MQTTString topicFilters[]) {
	size_t i;
	size_t len = 2; /* packetid */

	for(i = 0; i < count; ++i) {
    9884:	3501      	adds	r5, #1
    9886:	340c      	adds	r4, #12
    9888:	42af      	cmp	r7, r5
    988a:	d1f5      	bne.n	9878 <MQTTSerialize_GetSubscribePacketLength+0x14>
    988c:	e000      	b.n	9890 <MQTTSerialize_GetSubscribePacketLength+0x2c>
  * @param topicFilters the array of topic filter strings to be used in the publish
  * @return the length of buffer needed to contain the serialized version of the packet
  */
size_t MQTTSerialize_GetSubscribePacketLength(uint32_t count, MQTTString topicFilters[]) {
	size_t i;
	size_t len = 2; /* packetid */
    988e:	2602      	movs	r6, #2
	for(i = 0; i < count; ++i) {
		len += 2 + MQTTstrlen(topicFilters[i]) + 1; /* length + topic + req_qos */
	}

	return len;
}
    9890:	0030      	movs	r0, r6
    9892:	bc04      	pop	{r2}
    9894:	4690      	mov	r8, r2
    9896:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9898:	00009519 	.word	0x00009519

0000989c <MQTTSerialize_subscribe>:
  * @return the length of the serialized data.  <= 0 indicates error
  */
MQTTReturnCode MQTTSerialize_subscribe(unsigned char *buf, size_t buflen,
									   unsigned char dup, uint16_t packetid, uint32_t count,
									   MQTTString topicFilters[], QoS requestedQoSs[],
									   uint32_t *serialized_len) {									
    989c:	b5f0      	push	{r4, r5, r6, r7, lr}
    989e:	464f      	mov	r7, r9
    98a0:	4646      	mov	r6, r8
    98a2:	b4c0      	push	{r6, r7}
    98a4:	b085      	sub	sp, #20
    98a6:	4681      	mov	r9, r0
    98a8:	000f      	movs	r7, r1
    98aa:	0016      	movs	r6, r2
    98ac:	001d      	movs	r5, r3
	FUNC_ENTRY;
	if(NULL == buf || NULL == serialized_len) {
    98ae:	2800      	cmp	r0, #0
    98b0:	d049      	beq.n	9946 <MQTTSerialize_subscribe+0xaa>
    98b2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    98b4:	2b00      	cmp	r3, #0
    98b6:	d049      	beq.n	994c <MQTTSerialize_subscribe+0xb0>
		FUNC_EXIT_RC(MQTT_NULL_VALUE_ERROR);
		return MQTT_NULL_VALUE_ERROR;
	}

	unsigned char *ptr = buf;
    98b8:	9003      	str	r0, [sp, #12]
	MQTTHeader header = {0};
    98ba:	2300      	movs	r3, #0
    98bc:	9302      	str	r3, [sp, #8]
	size_t rem_len = 0;
	uint32_t i = 0;

	if(MQTTPacket_len(rem_len = MQTTSerialize_GetSubscribePacketLength(count, topicFilters)) > buflen) {
    98be:	990d      	ldr	r1, [sp, #52]	; 0x34
    98c0:	980c      	ldr	r0, [sp, #48]	; 0x30
    98c2:	4b27      	ldr	r3, [pc, #156]	; (9960 <MQTTSerialize_subscribe+0xc4>)
    98c4:	4798      	blx	r3
    98c6:	0004      	movs	r4, r0
    98c8:	4b26      	ldr	r3, [pc, #152]	; (9964 <MQTTSerialize_subscribe+0xc8>)
    98ca:	4798      	blx	r3
    98cc:	42b8      	cmp	r0, r7
    98ce:	d840      	bhi.n	9952 <MQTTSerialize_subscribe+0xb6>
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
	}

	MQTTReturnCode rc = MQTTPacket_InitHeader(&header, SUBSCRIBE, 1, dup, 0);
    98d0:	2300      	movs	r3, #0
    98d2:	9300      	str	r3, [sp, #0]
    98d4:	0033      	movs	r3, r6
    98d6:	2201      	movs	r2, #1
    98d8:	2108      	movs	r1, #8
    98da:	a802      	add	r0, sp, #8
    98dc:	4e22      	ldr	r6, [pc, #136]	; (9968 <MQTTSerialize_subscribe+0xcc>)
    98de:	47b0      	blx	r6
	if(SUCCESS != rc) {
    98e0:	2800      	cmp	r0, #0
    98e2:	d138      	bne.n	9956 <MQTTSerialize_subscribe+0xba>
		FUNC_EXIT_RC(rc);
		return rc;
	}
	/* write header */
	writeChar(&ptr, header.byte);
    98e4:	ab02      	add	r3, sp, #8
    98e6:	7819      	ldrb	r1, [r3, #0]
    98e8:	a803      	add	r0, sp, #12
    98ea:	4b20      	ldr	r3, [pc, #128]	; (996c <MQTTSerialize_subscribe+0xd0>)
    98ec:	4798      	blx	r3

	/* write remaining length */
	ptr += MQTTPacket_encode(ptr, rem_len);
    98ee:	0021      	movs	r1, r4
    98f0:	9803      	ldr	r0, [sp, #12]
    98f2:	4b1f      	ldr	r3, [pc, #124]	; (9970 <MQTTSerialize_subscribe+0xd4>)
    98f4:	4798      	blx	r3
    98f6:	9b03      	ldr	r3, [sp, #12]
    98f8:	469c      	mov	ip, r3
    98fa:	4460      	add	r0, ip
    98fc:	9003      	str	r0, [sp, #12]

	writePacketId(&ptr, packetid);
    98fe:	0029      	movs	r1, r5
    9900:	a803      	add	r0, sp, #12
    9902:	4b1c      	ldr	r3, [pc, #112]	; (9974 <MQTTSerialize_subscribe+0xd8>)
    9904:	4798      	blx	r3

	for(i = 0; i < count; ++i) {
    9906:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9908:	2b00      	cmp	r3, #0
    990a:	d015      	beq.n	9938 <MQTTSerialize_subscribe+0x9c>
    990c:	9c0d      	ldr	r4, [sp, #52]	; 0x34
    990e:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    9910:	002b      	movs	r3, r5
    9912:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    9914:	4694      	mov	ip, r2
    9916:	4463      	add	r3, ip
    9918:	001e      	movs	r6, r3
		writeMQTTString(&ptr, topicFilters[i]);
    991a:	4b17      	ldr	r3, [pc, #92]	; (9978 <MQTTSerialize_subscribe+0xdc>)
    991c:	4698      	mov	r8, r3
		writeChar(&ptr, (unsigned char)requestedQoSs[i]);
    991e:	4f13      	ldr	r7, [pc, #76]	; (996c <MQTTSerialize_subscribe+0xd0>)
	ptr += MQTTPacket_encode(ptr, rem_len);

	writePacketId(&ptr, packetid);

	for(i = 0; i < count; ++i) {
		writeMQTTString(&ptr, topicFilters[i]);
    9920:	6821      	ldr	r1, [r4, #0]
    9922:	6862      	ldr	r2, [r4, #4]
    9924:	68a3      	ldr	r3, [r4, #8]
    9926:	a803      	add	r0, sp, #12
    9928:	47c0      	blx	r8
		writeChar(&ptr, (unsigned char)requestedQoSs[i]);
    992a:	7829      	ldrb	r1, [r5, #0]
    992c:	a803      	add	r0, sp, #12
    992e:	47b8      	blx	r7
    9930:	340c      	adds	r4, #12
    9932:	3501      	adds	r5, #1
	/* write remaining length */
	ptr += MQTTPacket_encode(ptr, rem_len);

	writePacketId(&ptr, packetid);

	for(i = 0; i < count; ++i) {
    9934:	42b5      	cmp	r5, r6
    9936:	d1f3      	bne.n	9920 <MQTTSerialize_subscribe+0x84>
		writeMQTTString(&ptr, topicFilters[i]);
		writeChar(&ptr, (unsigned char)requestedQoSs[i]);
	}

	*serialized_len = (uint32_t)(ptr - buf);
    9938:	9b03      	ldr	r3, [sp, #12]
    993a:	464a      	mov	r2, r9
    993c:	1a9b      	subs	r3, r3, r2
    993e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    9940:	6013      	str	r3, [r2, #0]

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    9942:	2000      	movs	r0, #0
    9944:	e007      	b.n	9956 <MQTTSerialize_subscribe+0xba>
									   MQTTString topicFilters[], QoS requestedQoSs[],
									   uint32_t *serialized_len) {									
	FUNC_ENTRY;
	if(NULL == buf || NULL == serialized_len) {
		FUNC_EXIT_RC(MQTT_NULL_VALUE_ERROR);
		return MQTT_NULL_VALUE_ERROR;
    9946:	2006      	movs	r0, #6
    9948:	4240      	negs	r0, r0
    994a:	e004      	b.n	9956 <MQTTSerialize_subscribe+0xba>
    994c:	2006      	movs	r0, #6
    994e:	4240      	negs	r0, r0
    9950:	e001      	b.n	9956 <MQTTSerialize_subscribe+0xba>
	size_t rem_len = 0;
	uint32_t i = 0;

	if(MQTTPacket_len(rem_len = MQTTSerialize_GetSubscribePacketLength(count, topicFilters)) > buflen) {
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
    9952:	2009      	movs	r0, #9
    9954:	4240      	negs	r0, r0

	*serialized_len = (uint32_t)(ptr - buf);

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
}
    9956:	b005      	add	sp, #20
    9958:	bc0c      	pop	{r2, r3}
    995a:	4690      	mov	r8, r2
    995c:	4699      	mov	r9, r3
    995e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9960:	00009865 	.word	0x00009865
    9964:	0000936d 	.word	0x0000936d
    9968:	00009575 	.word	0x00009575
    996c:	000093e5 	.word	0x000093e5
    9970:	000092e5 	.word	0x000092e5
    9974:	000093f1 	.word	0x000093f1
    9978:	00009485 	.word	0x00009485

0000997c <MQTTDeserialize_suback>:
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success, 0 is failure
  */
MQTTReturnCode MQTTDeserialize_suback(uint16_t *packetid, uint32_t maxcount,
									  uint32_t *count, QoS grantedQoSs[],
									  unsigned char *buf, size_t buflen) {
    997c:	b5f0      	push	{r4, r5, r6, r7, lr}
    997e:	464f      	mov	r7, r9
    9980:	4646      	mov	r6, r8
    9982:	b4c0      	push	{r6, r7}
    9984:	b085      	sub	sp, #20
    9986:	0004      	movs	r4, r0
    9988:	4688      	mov	r8, r1
    998a:	0015      	movs	r5, r2
    998c:	001f      	movs	r7, r3
	FUNC_ENTRY;
	if(NULL == packetid || NULL == count || NULL == grantedQoSs) {
    998e:	2800      	cmp	r0, #0
    9990:	d03f      	beq.n	9a12 <MQTTDeserialize_suback+0x96>
    9992:	2a00      	cmp	r2, #0
    9994:	d040      	beq.n	9a18 <MQTTDeserialize_suback+0x9c>
    9996:	2b00      	cmp	r3, #0
    9998:	d041      	beq.n	9a1e <MQTTDeserialize_suback+0xa2>
		FUNC_EXIT_RC(MQTT_NULL_VALUE_ERROR);
		return MQTT_NULL_VALUE_ERROR;
	}

	MQTTHeader header = {0};
	unsigned char *curdata = buf;
    999a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    999c:	9303      	str	r3, [sp, #12]
	unsigned char *enddata = NULL;
	MQTTReturnCode decodeRc = FAILURE;
	uint32_t decodedLen = 0;
    999e:	2300      	movs	r3, #0
    99a0:	9302      	str	r3, [sp, #8]
	uint32_t readBytesLen = 0;
    99a2:	9301      	str	r3, [sp, #4]

	/* SUBACK header size is 4 bytes for header and at least one byte for QoS payload
	 * Need at least a 5 bytes buffer. MQTT3.1.1 specification 3.9
	 */
	if(5 > buflen) {
    99a4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    99a6:	2b04      	cmp	r3, #4
    99a8:	d93c      	bls.n	9a24 <MQTTDeserialize_suback+0xa8>
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
	}

	header.byte = readChar(&curdata);
    99aa:	a803      	add	r0, sp, #12
    99ac:	4b25      	ldr	r3, [pc, #148]	; (9a44 <MQTTDeserialize_suback+0xc8>)
    99ae:	4798      	blx	r3
	if (header.bits.type != SUBACK) {
    99b0:	23f0      	movs	r3, #240	; 0xf0
    99b2:	4018      	ands	r0, r3
    99b4:	2890      	cmp	r0, #144	; 0x90
    99b6:	d138      	bne.n	9a2a <MQTTDeserialize_suback+0xae>
		FUNC_EXIT_RC(FAILURE);
		return FAILURE;
	}

	/* read remaining length */
	decodeRc = MQTTPacket_decodeBuf(curdata, &decodedLen, &readBytesLen);
    99b8:	aa01      	add	r2, sp, #4
    99ba:	a902      	add	r1, sp, #8
    99bc:	9803      	ldr	r0, [sp, #12]
    99be:	4b22      	ldr	r3, [pc, #136]	; (9a48 <MQTTDeserialize_suback+0xcc>)
    99c0:	4798      	blx	r3
	if(decodeRc != SUCCESS) {
    99c2:	2800      	cmp	r0, #0
    99c4:	d139      	bne.n	9a3a <MQTTDeserialize_suback+0xbe>
		return decodeRc;
	}

	curdata += (readBytesLen);
    99c6:	9b03      	ldr	r3, [sp, #12]
    99c8:	9a01      	ldr	r2, [sp, #4]
    99ca:	4694      	mov	ip, r2
    99cc:	4463      	add	r3, ip
    99ce:	001e      	movs	r6, r3
    99d0:	9303      	str	r3, [sp, #12]
	enddata = curdata + decodedLen;
    99d2:	9b02      	ldr	r3, [sp, #8]
    99d4:	18f6      	adds	r6, r6, r3
	if (enddata - curdata < 2) {
    99d6:	2b01      	cmp	r3, #1
    99d8:	dd2a      	ble.n	9a30 <MQTTDeserialize_suback+0xb4>
		FUNC_EXIT_RC(FAILURE);
		return FAILURE;
	}

	*packetid = readPacketId(&curdata);
    99da:	a803      	add	r0, sp, #12
    99dc:	4b1b      	ldr	r3, [pc, #108]	; (9a4c <MQTTDeserialize_suback+0xd0>)
    99de:	4798      	blx	r3
    99e0:	8020      	strh	r0, [r4, #0]

	*count = 0;
    99e2:	2300      	movs	r3, #0
    99e4:	602b      	str	r3, [r5, #0]
	while(curdata < enddata) {
    99e6:	9a03      	ldr	r2, [sp, #12]
		}
		grantedQoSs[(*count)++] = (QoS)readChar(&curdata);
	}

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    99e8:	2000      	movs	r0, #0
	}

	*packetid = readPacketId(&curdata);

	*count = 0;
	while(curdata < enddata) {
    99ea:	4296      	cmp	r6, r2
    99ec:	d925      	bls.n	9a3a <MQTTDeserialize_suback+0xbe>
    99ee:	e003      	b.n	99f8 <MQTTDeserialize_suback+0x7c>
		if(*count > maxcount) {
    99f0:	682b      	ldr	r3, [r5, #0]
    99f2:	4543      	cmp	r3, r8
    99f4:	d902      	bls.n	99fc <MQTTDeserialize_suback+0x80>
    99f6:	e01e      	b.n	9a36 <MQTTDeserialize_suback+0xba>
			FUNC_EXIT_RC(FAILURE);
			return FAILURE;
		}
		grantedQoSs[(*count)++] = (QoS)readChar(&curdata);
    99f8:	4a12      	ldr	r2, [pc, #72]	; (9a44 <MQTTDeserialize_suback+0xc8>)
    99fa:	4691      	mov	r9, r2
    99fc:	1c5a      	adds	r2, r3, #1
    99fe:	602a      	str	r2, [r5, #0]
    9a00:	18fc      	adds	r4, r7, r3
    9a02:	a803      	add	r0, sp, #12
    9a04:	47c8      	blx	r9
    9a06:	7020      	strb	r0, [r4, #0]
	}

	*packetid = readPacketId(&curdata);

	*count = 0;
	while(curdata < enddata) {
    9a08:	9b03      	ldr	r3, [sp, #12]
    9a0a:	429e      	cmp	r6, r3
    9a0c:	d8f0      	bhi.n	99f0 <MQTTDeserialize_suback+0x74>
		}
		grantedQoSs[(*count)++] = (QoS)readChar(&curdata);
	}

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
    9a0e:	2000      	movs	r0, #0
    9a10:	e013      	b.n	9a3a <MQTTDeserialize_suback+0xbe>
									  uint32_t *count, QoS grantedQoSs[],
									  unsigned char *buf, size_t buflen) {
	FUNC_ENTRY;
	if(NULL == packetid || NULL == count || NULL == grantedQoSs) {
		FUNC_EXIT_RC(MQTT_NULL_VALUE_ERROR);
		return MQTT_NULL_VALUE_ERROR;
    9a12:	2006      	movs	r0, #6
    9a14:	4240      	negs	r0, r0
    9a16:	e010      	b.n	9a3a <MQTTDeserialize_suback+0xbe>
    9a18:	2006      	movs	r0, #6
    9a1a:	4240      	negs	r0, r0
    9a1c:	e00d      	b.n	9a3a <MQTTDeserialize_suback+0xbe>
    9a1e:	2006      	movs	r0, #6
    9a20:	4240      	negs	r0, r0
    9a22:	e00a      	b.n	9a3a <MQTTDeserialize_suback+0xbe>
	/* SUBACK header size is 4 bytes for header and at least one byte for QoS payload
	 * Need at least a 5 bytes buffer. MQTT3.1.1 specification 3.9
	 */
	if(5 > buflen) {
		FUNC_EXIT_RC(MQTTPACKET_BUFFER_TOO_SHORT);
		return MQTTPACKET_BUFFER_TOO_SHORT;
    9a24:	2009      	movs	r0, #9
    9a26:	4240      	negs	r0, r0
    9a28:	e007      	b.n	9a3a <MQTTDeserialize_suback+0xbe>
	}

	header.byte = readChar(&curdata);
	if (header.bits.type != SUBACK) {
		FUNC_EXIT_RC(FAILURE);
		return FAILURE;
    9a2a:	2001      	movs	r0, #1
    9a2c:	4240      	negs	r0, r0
    9a2e:	e004      	b.n	9a3a <MQTTDeserialize_suback+0xbe>

	curdata += (readBytesLen);
	enddata = curdata + decodedLen;
	if (enddata - curdata < 2) {
		FUNC_EXIT_RC(FAILURE);
		return FAILURE;
    9a30:	2001      	movs	r0, #1
    9a32:	4240      	negs	r0, r0
    9a34:	e001      	b.n	9a3a <MQTTDeserialize_suback+0xbe>

	*count = 0;
	while(curdata < enddata) {
		if(*count > maxcount) {
			FUNC_EXIT_RC(FAILURE);
			return FAILURE;
    9a36:	2001      	movs	r0, #1
    9a38:	4240      	negs	r0, r0
		grantedQoSs[(*count)++] = (QoS)readChar(&curdata);
	}

	FUNC_EXIT_RC(SUCCESS);
	return SUCCESS;
}
    9a3a:	b005      	add	sp, #20
    9a3c:	bc0c      	pop	{r2, r3}
    9a3e:	4690      	mov	r8, r2
    9a40:	4699      	mov	r9, r3
    9a42:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9a44:	000093d9 	.word	0x000093d9
    9a48:	00009395 	.word	0x00009395
    9a4c:	000093c5 	.word	0x000093c5

00009a50 <adc_window_hit_callback>:
 *
 */
void adc_window_hit_callback(struct adc_module *const module)
{
	uint16_t adc_result_hex = 0;
	adc_result_hex = ADC->RESULT.reg;
    9a50:	4b07      	ldr	r3, [pc, #28]	; (9a70 <adc_window_hit_callback+0x20>)
    9a52:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
	low_battery_status = true;
    9a54:	2101      	movs	r1, #1
    9a56:	4a07      	ldr	r2, [pc, #28]	; (9a74 <adc_window_hit_callback+0x24>)
    9a58:	7011      	strb	r1, [r2, #0]
	adc_result_mV = (ADC_REF_mV * (adc_result_hex - 0x82) / (ADC_2POWER_12BIT_RES));
    9a5a:	3b82      	subs	r3, #130	; 0x82
    9a5c:	4a06      	ldr	r2, [pc, #24]	; (9a78 <adc_window_hit_callback+0x28>)
    9a5e:	4353      	muls	r3, r2
    9a60:	17da      	asrs	r2, r3, #31
    9a62:	0512      	lsls	r2, r2, #20
    9a64:	0d12      	lsrs	r2, r2, #20
    9a66:	18d3      	adds	r3, r2, r3
    9a68:	131b      	asrs	r3, r3, #12
    9a6a:	4a04      	ldr	r2, [pc, #16]	; (9a7c <adc_window_hit_callback+0x2c>)
    9a6c:	8013      	strh	r3, [r2, #0]
}
    9a6e:	4770      	bx	lr
    9a70:	43000c00 	.word	0x43000c00
    9a74:	200017ce 	.word	0x200017ce
    9a78:	0000076c 	.word	0x0000076c
    9a7c:	200017cc 	.word	0x200017cc

00009a80 <configure_adc>:

/*! \brief configure adc
 *
 */
void configure_adc(void)
{
    9a80:	b530      	push	{r4, r5, lr}
    9a82:	b08d      	sub	sp, #52	; 0x34
	uint16_t adc_threshold = 0;
	
	struct adc_config config_adc;
	adc_get_config_defaults(&config_adc);
    9a84:	ac01      	add	r4, sp, #4
    9a86:	0020      	movs	r0, r4
    9a88:	4b1e      	ldr	r3, [pc, #120]	; (9b04 <configure_adc+0x84>)
    9a8a:	4798      	blx	r3
	
	//calculate threshold value
	adc_threshold = (VBAT_THRESHOLD_mV * ADC_2POWER_12BIT_RES) / ADC_REF_mV;
	adc_threshold /= 2;

	config_adc.clock_source					= GCLK_GENERATOR_1;
    9a8c:	2301      	movs	r3, #1
    9a8e:	7023      	strb	r3, [r4, #0]
	config_adc.clock_prescaler				= ADC_CLOCK_PRESCALER_DIV16;
    9a90:	3302      	adds	r3, #2
    9a92:	70a3      	strb	r3, [r4, #2]
	config_adc.reference					= ADC_REFERENCE_INTVCC2;
    9a94:	3302      	adds	r3, #2
    9a96:	7063      	strb	r3, [r4, #1]
	config_adc.positive_input				= ADC_POSITIVE_INPUT_PIN0;
    9a98:	2300      	movs	r3, #0
    9a9a:	7123      	strb	r3, [r4, #4]
	config_adc.resolution					= ADC_RESOLUTION_CUSTOM;
    9a9c:	3334      	adds	r3, #52	; 0x34
    9a9e:	70e3      	strb	r3, [r4, #3]
	config_adc.window.window_mode			= ADC_WINDOW_MODE_BELOW_UPPER;
    9aa0:	33cd      	adds	r3, #205	; 0xcd
    9aa2:	33ff      	adds	r3, #255	; 0xff
    9aa4:	8323      	strh	r3, [r4, #24]
	config_adc.window.window_upper_value	= adc_threshold + 0x82;//0x8D0;
    9aa6:	4b18      	ldr	r3, [pc, #96]	; (9b08 <configure_adc+0x88>)
    9aa8:	6223      	str	r3, [r4, #32]
	config_adc.accumulate_samples			= ADC_ACCUMULATE_SAMPLES_512;
    9aaa:	2309      	movs	r3, #9
    9aac:	7223      	strb	r3, [r4, #8]
	config_adc.divide_result				= ADC_DIVIDE_RESULT_16;
    9aae:	3b05      	subs	r3, #5
    9ab0:	7263      	strb	r3, [r4, #9]

	adc_init(&adc_instance, ADC, &config_adc);
    9ab2:	4d16      	ldr	r5, [pc, #88]	; (9b0c <configure_adc+0x8c>)
    9ab4:	0022      	movs	r2, r4
    9ab6:	4916      	ldr	r1, [pc, #88]	; (9b10 <configure_adc+0x90>)
    9ab8:	0028      	movs	r0, r5
    9aba:	4b16      	ldr	r3, [pc, #88]	; (9b14 <configure_adc+0x94>)
    9abc:	4798      	blx	r3
		struct adc_module *const module_inst)
{
	Assert(module_inst);
	Assert(module_inst->hw);

	Adc *const adc_module = module_inst->hw;
    9abe:	682a      	ldr	r2, [r5, #0]
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;

	if (adc_module->SYNCBUSY.reg) {
    9ac0:	8c13      	ldrh	r3, [r2, #32]
    9ac2:	b29b      	uxth	r3, r3

	while (adc_is_syncing(module_inst)) {
    9ac4:	2b00      	cmp	r3, #0
    9ac6:	d1fb      	bne.n	9ac0 <configure_adc+0x40>
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    9ac8:	2180      	movs	r1, #128	; 0x80
    9aca:	03c9      	lsls	r1, r1, #15
    9acc:	4b12      	ldr	r3, [pc, #72]	; (9b18 <configure_adc+0x98>)
    9ace:	6019      	str	r1, [r3, #0]
#	else
		system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_ADC);
#   endif
#endif

	adc_module->CTRLA.reg |= ADC_CTRLA_ENABLE;
    9ad0:	7811      	ldrb	r1, [r2, #0]
    9ad2:	2302      	movs	r3, #2
    9ad4:	430b      	orrs	r3, r1
    9ad6:	7013      	strb	r3, [r2, #0]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    9ad8:	4b0c      	ldr	r3, [pc, #48]	; (9b0c <configure_adc+0x8c>)
    9ada:	681a      	ldr	r2, [r3, #0]

	if (adc_module->SYNCBUSY.reg) {
    9adc:	8c13      	ldrh	r3, [r2, #32]
    9ade:	b29b      	uxth	r3, r3

	while (adc_is_syncing(module_inst)) {
    9ae0:	2b00      	cmp	r3, #0
    9ae2:	d1fb      	bne.n	9adc <configure_adc+0x5c>
	adc_enable(&adc_instance);
	adc_register_callback(&adc_instance,adc_window_hit_callback, ADC_CALLBACK_WINDOW);
    9ae4:	4c09      	ldr	r4, [pc, #36]	; (9b0c <configure_adc+0x8c>)
    9ae6:	2201      	movs	r2, #1
    9ae8:	490c      	ldr	r1, [pc, #48]	; (9b1c <configure_adc+0x9c>)
    9aea:	0020      	movs	r0, r4
    9aec:	4b0c      	ldr	r3, [pc, #48]	; (9b20 <configure_adc+0xa0>)
    9aee:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(module);

	/* Enable callback */
	module->enabled_callback_mask |= (1 << callback_type);
    9af0:	7ee2      	ldrb	r2, [r4, #27]
    9af2:	2302      	movs	r3, #2
    9af4:	4313      	orrs	r3, r2
    9af6:	76e3      	strb	r3, [r4, #27]
{
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	Adc *const adc_module = module_inst->hw;
    9af8:	6823      	ldr	r3, [r4, #0]
	/* Enable interrupt */
	adc_module->INTENSET.reg = interrupt;
    9afa:	2204      	movs	r2, #4
    9afc:	715a      	strb	r2, [r3, #5]
	adc_enable_callback(&adc_instance, ADC_CALLBACK_WINDOW);
}
    9afe:	b00d      	add	sp, #52	; 0x34
    9b00:	bd30      	pop	{r4, r5, pc}
    9b02:	46c0      	nop			; (mov r8, r8)
    9b04:	0000a861 	.word	0x0000a861
    9b08:	00000b08 	.word	0x00000b08
    9b0c:	20002370 	.word	0x20002370
    9b10:	43000c00 	.word	0x43000c00
    9b14:	0000a8a5 	.word	0x0000a8a5
    9b18:	e000e100 	.word	0xe000e100
    9b1c:	00009a51 	.word	0x00009a51
    9b20:	0000ad35 	.word	0x0000ad35

00009b24 <sensors_callback>:

/*! \brief bhi sensor callback
 *
 */
void sensors_callback(bhy_data_generic_t * sensor_data, bhy_virtual_sensor_t sensor_id)
{
    9b24:	b570      	push	{r4, r5, r6, lr}
	s16 tempx,tempy, tempz;
	switch (sensor_id)
    9b26:	2912      	cmp	r1, #18
    9b28:	d86f      	bhi.n	9c0a <sensors_callback+0xe6>
    9b2a:	0089      	lsls	r1, r1, #2
    9b2c:	4b37      	ldr	r3, [pc, #220]	; (9c0c <sensors_callback+0xe8>)
    9b2e:	585b      	ldr	r3, [r3, r1]
    9b30:	469f      	mov	pc, r3
	{
		case VS_ID_GAME_ROTATION_VECTOR:
			quaternion_data.x = sensor_data->data_quaternion.x;
    9b32:	4b37      	ldr	r3, [pc, #220]	; (9c10 <sensors_callback+0xec>)
    9b34:	8842      	ldrh	r2, [r0, #2]
    9b36:	801a      	strh	r2, [r3, #0]
			quaternion_data.y = sensor_data->data_quaternion.y;
    9b38:	8882      	ldrh	r2, [r0, #4]
    9b3a:	805a      	strh	r2, [r3, #2]
			quaternion_data.z = sensor_data->data_quaternion.z;
    9b3c:	88c2      	ldrh	r2, [r0, #6]
    9b3e:	809a      	strh	r2, [r3, #4]
			quaternion_data.w = sensor_data->data_quaternion.w;
    9b40:	8902      	ldrh	r2, [r0, #8]
    9b42:	80da      	strh	r2, [r3, #6]
		break;
    9b44:	e061      	b.n	9c0a <sensors_callback+0xe6>

		case VS_ID_ACCELEROMETER:
			acc_data.x_pos = sensor_data->data_vector.x;
    9b46:	4b33      	ldr	r3, [pc, #204]	; (9c14 <sensors_callback+0xf0>)
    9b48:	8842      	ldrh	r2, [r0, #2]
    9b4a:	801a      	strh	r2, [r3, #0]
			acc_data.y_pos = sensor_data->data_vector.y;
    9b4c:	8882      	ldrh	r2, [r0, #4]
    9b4e:	805a      	strh	r2, [r3, #2]
			acc_data.z_pos = sensor_data->data_vector.z;
    9b50:	88c2      	ldrh	r2, [r0, #6]
    9b52:	809a      	strh	r2, [r3, #4]
		break;
    9b54:	e059      	b.n	9c0a <sensors_callback+0xe6>

		case VS_ID_GYROSCOPE:
			gyro_data.x_pos = sensor_data->data_vector.x/16;
    9b56:	4930      	ldr	r1, [pc, #192]	; (9c18 <sensors_callback+0xf4>)
    9b58:	2302      	movs	r3, #2
    9b5a:	5ec2      	ldrsh	r2, [r0, r3]
    9b5c:	17d3      	asrs	r3, r2, #31
    9b5e:	240f      	movs	r4, #15
    9b60:	4023      	ands	r3, r4
    9b62:	189a      	adds	r2, r3, r2
    9b64:	1112      	asrs	r2, r2, #4
    9b66:	800a      	strh	r2, [r1, #0]
			gyro_data.y_pos = sensor_data->data_vector.y/16;
    9b68:	2304      	movs	r3, #4
    9b6a:	5ec2      	ldrsh	r2, [r0, r3]
    9b6c:	17d3      	asrs	r3, r2, #31
    9b6e:	4023      	ands	r3, r4
    9b70:	189a      	adds	r2, r3, r2
    9b72:	1112      	asrs	r2, r2, #4
    9b74:	804a      	strh	r2, [r1, #2]
			gyro_data.z_pos = sensor_data->data_vector.z/16;
    9b76:	2206      	movs	r2, #6
    9b78:	5e83      	ldrsh	r3, [r0, r2]
    9b7a:	17da      	asrs	r2, r3, #31
    9b7c:	4022      	ands	r2, r4
    9b7e:	18d3      	adds	r3, r2, r3
    9b80:	111b      	asrs	r3, r3, #4
    9b82:	808b      	strh	r3, [r1, #4]
		break;
    9b84:	e041      	b.n	9c0a <sensors_callback+0xe6>

		case VS_ID_STEP_DETECTOR:
			step_detected = true;
    9b86:	2201      	movs	r2, #1
    9b88:	4b24      	ldr	r3, [pc, #144]	; (9c1c <sensors_callback+0xf8>)
    9b8a:	701a      	strb	r2, [r3, #0]
		break;
    9b8c:	e03d      	b.n	9c0a <sensors_callback+0xe6>

		case VS_ID_GRAVITY:
			gra_x_data = sensor_data->data_vector.x;
    9b8e:	2302      	movs	r3, #2
    9b90:	5ec5      	ldrsh	r5, [r0, r3]
    9b92:	4b23      	ldr	r3, [pc, #140]	; (9c20 <sensors_callback+0xfc>)
    9b94:	801d      	strh	r5, [r3, #0]
			gra_y_data = sensor_data->data_vector.y;
    9b96:	2304      	movs	r3, #4
    9b98:	5ec4      	ldrsh	r4, [r0, r3]
    9b9a:	4b22      	ldr	r3, [pc, #136]	; (9c24 <sensors_callback+0x100>)
    9b9c:	801c      	strh	r4, [r3, #0]
			gra_z_data = sensor_data->data_vector.z;
    9b9e:	2306      	movs	r3, #6
    9ba0:	5ec0      	ldrsh	r0, [r0, r3]
    9ba2:	4b21      	ldr	r3, [pc, #132]	; (9c28 <sensors_callback+0x104>)
    9ba4:	8018      	strh	r0, [r3, #0]

			if((gra_x_data) > (gra_x_data_prev))
    9ba6:	4b21      	ldr	r3, [pc, #132]	; (9c2c <sensors_callback+0x108>)
    9ba8:	2200      	movs	r2, #0
    9baa:	5e9b      	ldrsh	r3, [r3, r2]
    9bac:	429d      	cmp	r5, r3
    9bae:	dd02      	ble.n	9bb6 <sensors_callback+0x92>
			tempx = (gra_x_data) - (gra_x_data_prev);
    9bb0:	1aeb      	subs	r3, r5, r3
    9bb2:	b219      	sxth	r1, r3
    9bb4:	e001      	b.n	9bba <sensors_callback+0x96>
			else
			tempx = (gra_x_data_prev) - (gra_x_data);
    9bb6:	1b5b      	subs	r3, r3, r5
    9bb8:	b219      	sxth	r1, r3

			if((gra_y_data) > (gra_y_data_prev))
    9bba:	4b1d      	ldr	r3, [pc, #116]	; (9c30 <sensors_callback+0x10c>)
    9bbc:	2200      	movs	r2, #0
    9bbe:	5e9b      	ldrsh	r3, [r3, r2]
    9bc0:	429c      	cmp	r4, r3
    9bc2:	dd02      	ble.n	9bca <sensors_callback+0xa6>
			tempy = (gra_y_data) - (gra_y_data_prev);
    9bc4:	1ae3      	subs	r3, r4, r3
    9bc6:	b21b      	sxth	r3, r3
    9bc8:	e001      	b.n	9bce <sensors_callback+0xaa>
			else
			tempy = (gra_y_data_prev) - (gra_y_data);
    9bca:	1b1b      	subs	r3, r3, r4
    9bcc:	b21b      	sxth	r3, r3

			if((gra_z_data) > (gra_z_data_prev))
    9bce:	4a19      	ldr	r2, [pc, #100]	; (9c34 <sensors_callback+0x110>)
    9bd0:	2600      	movs	r6, #0
    9bd2:	5f92      	ldrsh	r2, [r2, r6]
    9bd4:	4290      	cmp	r0, r2
    9bd6:	dd02      	ble.n	9bde <sensors_callback+0xba>
			tempz = (gra_z_data) - (gra_z_data_prev);
    9bd8:	1a82      	subs	r2, r0, r2
    9bda:	b212      	sxth	r2, r2
    9bdc:	e001      	b.n	9be2 <sensors_callback+0xbe>
			else
			tempz = (gra_z_data_prev) - (gra_z_data);
    9bde:	1a12      	subs	r2, r2, r0
    9be0:	b212      	sxth	r2, r2

			if ((tempx >ACC_GRAVITY_THRESHOLD_X) ||  \
    9be2:	26c8      	movs	r6, #200	; 0xc8
    9be4:	00b6      	lsls	r6, r6, #2
    9be6:	42b1      	cmp	r1, r6
    9be8:	dc05      	bgt.n	9bf6 <sensors_callback+0xd2>
    9bea:	42b3      	cmp	r3, r6
    9bec:	dc03      	bgt.n	9bf6 <sensors_callback+0xd2>
			    (tempy >ACC_GRAVITY_THRESHOLD_Y) ||  \
    9bee:	23af      	movs	r3, #175	; 0xaf
    9bf0:	009b      	lsls	r3, r3, #2
    9bf2:	429a      	cmp	r2, r3
    9bf4:	dd03      	ble.n	9bfe <sensors_callback+0xda>
				(tempz >ACC_GRAVITY_THRESHOLD_Z))
			{
				device_drop_detected++;
    9bf6:	4a10      	ldr	r2, [pc, #64]	; (9c38 <sensors_callback+0x114>)
    9bf8:	8813      	ldrh	r3, [r2, #0]
    9bfa:	3301      	adds	r3, #1
    9bfc:	8013      	strh	r3, [r2, #0]
			}

			gra_x_data_prev = gra_x_data;
    9bfe:	4b0b      	ldr	r3, [pc, #44]	; (9c2c <sensors_callback+0x108>)
    9c00:	801d      	strh	r5, [r3, #0]
			gra_y_data_prev = gra_y_data;
    9c02:	4b0b      	ldr	r3, [pc, #44]	; (9c30 <sensors_callback+0x10c>)
    9c04:	801c      	strh	r4, [r3, #0]
			gra_z_data_prev = gra_z_data;
    9c06:	4b0b      	ldr	r3, [pc, #44]	; (9c34 <sensors_callback+0x110>)
    9c08:	8018      	strh	r0, [r3, #0]
		break;
		default:
		break;
	}

}
    9c0a:	bd70      	pop	{r4, r5, r6, pc}
    9c0c:	000153dc 	.word	0x000153dc
    9c10:	200023a8 	.word	0x200023a8
    9c14:	20002398 	.word	0x20002398
    9c18:	200023a0 	.word	0x200023a0
    9c1c:	200017db 	.word	0x200017db
    9c20:	20002396 	.word	0x20002396
    9c24:	20002392 	.word	0x20002392
    9c28:	20002390 	.word	0x20002390
    9c2c:	200024aa 	.word	0x200024aa
    9c30:	200024ac 	.word	0x200024ac
    9c34:	20002394 	.word	0x20002394
    9c38:	200017d8 	.word	0x200017d8

00009c3c <process_motion_sensor_data>:

/*! \brief process motion sensor data
 *
 */
void process_motion_sensor_data(void)
{
    9c3c:	b570      	push	{r4, r5, r6, lr}
    9c3e:	b088      	sub	sp, #32
	u8 bytes_left_in_fifo=0;
	u16 bytes_remaining = 0;
    9c40:	2300      	movs	r3, #0
    9c42:	221e      	movs	r2, #30
    9c44:	446a      	add	r2, sp
    9c46:	8013      	strh	r3, [r2, #0]
	u16 bytes_read = 0;
    9c48:	aa07      	add	r2, sp, #28
    9c4a:	8013      	strh	r3, [r2, #0]
	BHY_RETURN_FUNCTION_TYPE result;

	/* enable i2c */
	//enable_i2c();

	if(acc_sens_stat || gyro_sens_stat || rot_sens_stat ||	gra_sens_stat || stp_sens_stat)
    9c4c:	4b28      	ldr	r3, [pc, #160]	; (9cf0 <process_motion_sensor_data+0xb4>)
    9c4e:	781b      	ldrb	r3, [r3, #0]
    9c50:	2b00      	cmp	r3, #0
    9c52:	d10f      	bne.n	9c74 <process_motion_sensor_data+0x38>
    9c54:	4b27      	ldr	r3, [pc, #156]	; (9cf4 <process_motion_sensor_data+0xb8>)
    9c56:	781b      	ldrb	r3, [r3, #0]
    9c58:	2b00      	cmp	r3, #0
    9c5a:	d10b      	bne.n	9c74 <process_motion_sensor_data+0x38>
    9c5c:	4b26      	ldr	r3, [pc, #152]	; (9cf8 <process_motion_sensor_data+0xbc>)
    9c5e:	781b      	ldrb	r3, [r3, #0]
    9c60:	2b00      	cmp	r3, #0
    9c62:	d107      	bne.n	9c74 <process_motion_sensor_data+0x38>
    9c64:	4b25      	ldr	r3, [pc, #148]	; (9cfc <process_motion_sensor_data+0xc0>)
    9c66:	781b      	ldrb	r3, [r3, #0]
    9c68:	2b00      	cmp	r3, #0
    9c6a:	d103      	bne.n	9c74 <process_motion_sensor_data+0x38>
    9c6c:	4b24      	ldr	r3, [pc, #144]	; (9d00 <process_motion_sensor_data+0xc4>)
    9c6e:	781b      	ldrb	r3, [r3, #0]
    9c70:	2b00      	cmp	r3, #0
    9c72:	d03b      	beq.n	9cec <process_motion_sensor_data+0xb0>
	{
		//while (!port_pin_get_input_level(BHI_SENSOR_INT_PIN) /*&& !bytes_remaining*/) ;
		if(bhy_read_fifo(array+bytes_left_in_fifo, ARRAYSIZE-bytes_left_in_fifo, &bytes_read, &bytes_remaining) == BHY_SUCCESS)
    9c74:	231e      	movs	r3, #30
    9c76:	446b      	add	r3, sp
    9c78:	aa07      	add	r2, sp, #28
    9c7a:	21fa      	movs	r1, #250	; 0xfa
    9c7c:	4821      	ldr	r0, [pc, #132]	; (9d04 <process_motion_sensor_data+0xc8>)
    9c7e:	4c22      	ldr	r4, [pc, #136]	; (9d08 <process_motion_sensor_data+0xcc>)
    9c80:	47a0      	blx	r4
    9c82:	2800      	cmp	r0, #0
    9c84:	d132      	bne.n	9cec <process_motion_sensor_data+0xb0>
		{
			bytes_read += bytes_left_in_fifo;

			fifoptr = array;
    9c86:	4a1f      	ldr	r2, [pc, #124]	; (9d04 <process_motion_sensor_data+0xc8>)
    9c88:	4b20      	ldr	r3, [pc, #128]	; (9d0c <process_motion_sensor_data+0xd0>)
    9c8a:	601a      	str	r2, [r3, #0]
			packet_type = BHY_DATA_TYPE_PADDING;
    9c8c:	2200      	movs	r2, #0
    9c8e:	466b      	mov	r3, sp
    9c90:	71da      	strb	r2, [r3, #7]

			do {
				/* this function will call callbacks that are registered */
				result = bhy_parse_next_fifo_packet( &fifoptr, &bytes_read, &fifo_packet, &packet_type );
    9c92:	4c1e      	ldr	r4, [pc, #120]	; (9d0c <process_motion_sensor_data+0xd0>)
    9c94:	4d1e      	ldr	r5, [pc, #120]	; (9d10 <process_motion_sensor_data+0xd4>)
    9c96:	466b      	mov	r3, sp
    9c98:	3307      	adds	r3, #7
    9c9a:	aa02      	add	r2, sp, #8
    9c9c:	a907      	add	r1, sp, #28
    9c9e:	0020      	movs	r0, r4
    9ca0:	47a8      	blx	r5
				/* the logic here is that if doing a partial parsing of the fifo, then we should not parse	*/
				/* the last 18 bytes (max length of a packet) so that we don't try to parse an incomplete	*/
				/* packet																					*/
			} while ( (result == BHY_SUCCESS) && (bytes_read > (bytes_remaining ? 18 : 0)) );
    9ca2:	2800      	cmp	r0, #0
    9ca4:	d10b      	bne.n	9cbe <process_motion_sensor_data+0x82>
    9ca6:	ab07      	add	r3, sp, #28
    9ca8:	8819      	ldrh	r1, [r3, #0]
    9caa:	231e      	movs	r3, #30
    9cac:	446b      	add	r3, sp
    9cae:	881b      	ldrh	r3, [r3, #0]
    9cb0:	2212      	movs	r2, #18
    9cb2:	1e58      	subs	r0, r3, #1
    9cb4:	4183      	sbcs	r3, r0
    9cb6:	425b      	negs	r3, r3
    9cb8:	401a      	ands	r2, r3
    9cba:	428a      	cmp	r2, r1
    9cbc:	dbeb      	blt.n	9c96 <process_motion_sensor_data+0x5a>
			bytes_left_in_fifo = 0;

			if (bytes_remaining) {
    9cbe:	231e      	movs	r3, #30
    9cc0:	446b      	add	r3, sp
    9cc2:	881b      	ldrh	r3, [r3, #0]
    9cc4:	2b00      	cmp	r3, #0
    9cc6:	d011      	beq.n	9cec <process_motion_sensor_data+0xb0>
				/* shifts the remaining bytes to the beginning of the buffer */
				while (bytes_left_in_fifo < bytes_read)
    9cc8:	ab07      	add	r3, sp, #28
    9cca:	881d      	ldrh	r5, [r3, #0]
    9ccc:	2d00      	cmp	r5, #0
    9cce:	d00d      	beq.n	9cec <process_motion_sensor_data+0xb0>
    9cd0:	2200      	movs	r2, #0
				array[bytes_left_in_fifo++] = *(fifoptr++);
    9cd2:	480e      	ldr	r0, [pc, #56]	; (9d0c <process_motion_sensor_data+0xd0>)
    9cd4:	4e0b      	ldr	r6, [pc, #44]	; (9d04 <process_motion_sensor_data+0xc8>)
    9cd6:	1c53      	adds	r3, r2, #1
    9cd8:	b2db      	uxtb	r3, r3
    9cda:	6801      	ldr	r1, [r0, #0]
    9cdc:	1c4c      	adds	r4, r1, #1
    9cde:	6004      	str	r4, [r0, #0]
    9ce0:	7809      	ldrb	r1, [r1, #0]
    9ce2:	54b1      	strb	r1, [r6, r2]
    9ce4:	001a      	movs	r2, r3
			} while ( (result == BHY_SUCCESS) && (bytes_read > (bytes_remaining ? 18 : 0)) );
			bytes_left_in_fifo = 0;

			if (bytes_remaining) {
				/* shifts the remaining bytes to the beginning of the buffer */
				while (bytes_left_in_fifo < bytes_read)
    9ce6:	b29b      	uxth	r3, r3
    9ce8:	42ab      	cmp	r3, r5
    9cea:	d3f4      	bcc.n	9cd6 <process_motion_sensor_data+0x9a>
		}
	}

	/* disable i2c */
	//disable_i2c();
}
    9cec:	b008      	add	sp, #32
    9cee:	bd70      	pop	{r4, r5, r6, pc}
    9cf0:	200017d4 	.word	0x200017d4
    9cf4:	200017cf 	.word	0x200017cf
    9cf8:	200017d6 	.word	0x200017d6
    9cfc:	200017da 	.word	0x200017da
    9d00:	200017d5 	.word	0x200017d5
    9d04:	200023b0 	.word	0x200023b0
    9d08:	0000a3b5 	.word	0x0000a3b5
    9d0c:	200017d0 	.word	0x200017d0
    9d10:	0000a46d 	.word	0x0000a46d

00009d14 <enable_rotation_vector>:

/*! \brief enable rotation vector
 *
 */
void enable_rotation_vector(void)
{
    9d14:	b510      	push	{r4, lr}
    9d16:	b084      	sub	sp, #16
	if(bhy_enable_virtual_sensor(VS_TYPE_GAME_ROTATION_VECTOR, VS_NON_WAKEUP, SAMPLE_DATA_RATE, 0, VS_FLUSH_ALL, 0, 0) != BHY_SUCCESS)
    9d18:	2300      	movs	r3, #0
    9d1a:	9302      	str	r3, [sp, #8]
    9d1c:	9301      	str	r3, [sp, #4]
    9d1e:	33ff      	adds	r3, #255	; 0xff
    9d20:	9300      	str	r3, [sp, #0]
    9d22:	2300      	movs	r3, #0
    9d24:	22c8      	movs	r2, #200	; 0xc8
    9d26:	2100      	movs	r1, #0
    9d28:	200f      	movs	r0, #15
    9d2a:	4c07      	ldr	r4, [pc, #28]	; (9d48 <enable_rotation_vector+0x34>)
    9d2c:	47a0      	blx	r4
    9d2e:	2800      	cmp	r0, #0
    9d30:	d000      	beq.n	9d34 <enable_rotation_vector+0x20>
    9d32:	e7fe      	b.n	9d32 <enable_rotation_vector+0x1e>
	{
		while(1);
	}
	bhy_install_sensor_callback(VS_TYPE_GAME_ROTATION_VECTOR, VS_NON_WAKEUP, sensors_callback);
    9d34:	4a05      	ldr	r2, [pc, #20]	; (9d4c <enable_rotation_vector+0x38>)
    9d36:	2100      	movs	r1, #0
    9d38:	200f      	movs	r0, #15
    9d3a:	4b05      	ldr	r3, [pc, #20]	; (9d50 <enable_rotation_vector+0x3c>)
    9d3c:	4798      	blx	r3
	rot_sens_stat = true;
    9d3e:	2201      	movs	r2, #1
    9d40:	4b04      	ldr	r3, [pc, #16]	; (9d54 <enable_rotation_vector+0x40>)
    9d42:	701a      	strb	r2, [r3, #0]
}
    9d44:	b004      	add	sp, #16
    9d46:	bd10      	pop	{r4, pc}
    9d48:	0000a301 	.word	0x0000a301
    9d4c:	00009b25 	.word	0x00009b25
    9d50:	0000a769 	.word	0x0000a769
    9d54:	200017d6 	.word	0x200017d6

00009d58 <bhy_init>:
 *	affect the reference value of the parameter
 *	(Better case don't change the reference value of the parameter)
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_init(struct bhy_t *bhy)
{
    9d58:	b570      	push	{r4, r5, r6, lr}
    9d5a:	b082      	sub	sp, #8
    9d5c:	0003      	movs	r3, r0
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
    9d5e:	466a      	mov	r2, sp
    9d60:	1dd4      	adds	r4, r2, #7
    9d62:	2200      	movs	r2, #0
    9d64:	7022      	strb	r2, [r4, #0]
	/* assign bhy ptr */
	p_bhy = bhy;
    9d66:	4d06      	ldr	r5, [pc, #24]	; (9d80 <bhy_init+0x28>)
    9d68:	6028      	str	r0, [r5, #0]
	com_rslt =
    9d6a:	7840      	ldrb	r0, [r0, #1]
    9d6c:	689e      	ldr	r6, [r3, #8]
    9d6e:	2301      	movs	r3, #1
    9d70:	0022      	movs	r2, r4
    9d72:	2190      	movs	r1, #144	; 0x90
    9d74:	47b0      	blx	r6
	p_bhy->BHY_BUS_READ_FUNC(p_bhy->device_addr,
	BHY_I2C_REG_PRODUCT_ID_ADDR,
	&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
	/* read product Id */
	p_bhy->product_id = v_data_u8;
    9d76:	7822      	ldrb	r2, [r4, #0]
    9d78:	682b      	ldr	r3, [r5, #0]
    9d7a:	701a      	strb	r2, [r3, #0]
	return com_rslt;
}
    9d7c:	b002      	add	sp, #8
    9d7e:	bd70      	pop	{r4, r5, r6, pc}
    9d80:	200017e4 	.word	0x200017e4

00009d84 <bhy_write_reg>:
 *
 *
 */
BHY_RETURN_FUNCTION_TYPE bhy_write_reg(u8 v_addr_u8,
u8 *v_data_u8, u16 v_len_u16)
{
    9d84:	b570      	push	{r4, r5, r6, lr}
    9d86:	0005      	movs	r5, r0
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	/* check the p_bhy structure as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    9d88:	4c06      	ldr	r4, [pc, #24]	; (9da4 <bhy_write_reg+0x20>)
    9d8a:	6824      	ldr	r4, [r4, #0]
    9d8c:	2c00      	cmp	r4, #0
    9d8e:	d006      	beq.n	9d9e <bhy_write_reg+0x1a>
		com_rslt =  BHY_NULL;
		} else {
			/* write data from register*/
			com_rslt =
    9d90:	7860      	ldrb	r0, [r4, #1]
    9d92:	6864      	ldr	r4, [r4, #4]
    9d94:	0013      	movs	r3, r2
    9d96:	000a      	movs	r2, r1
    9d98:	0029      	movs	r1, r5
    9d9a:	47a0      	blx	r4
    9d9c:	e000      	b.n	9da0 <bhy_write_reg+0x1c>
{
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	/* check the p_bhy structure as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    9d9e:	2000      	movs	r0, #0
			com_rslt =
			p_bhy->BHY_BUS_WRITE_FUNC(p_bhy->device_addr,
			v_addr_u8, v_data_u8, v_len_u16);
		}
	return com_rslt;
}
    9da0:	bd70      	pop	{r4, r5, r6, pc}
    9da2:	46c0      	nop			; (mov r8, r8)
    9da4:	200017e4 	.word	0x200017e4

00009da8 <bhy_read_reg>:
 *
 *
 */
BHY_RETURN_FUNCTION_TYPE bhy_read_reg(u8 v_addr_u8,
u8 *v_data_u8, u16 v_len_u16)
{
    9da8:	b570      	push	{r4, r5, r6, lr}
    9daa:	0005      	movs	r5, r0
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	/* check the p_bhy structure as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    9dac:	4c06      	ldr	r4, [pc, #24]	; (9dc8 <bhy_read_reg+0x20>)
    9dae:	6824      	ldr	r4, [r4, #0]
    9db0:	2c00      	cmp	r4, #0
    9db2:	d006      	beq.n	9dc2 <bhy_read_reg+0x1a>
		com_rslt =  BHY_NULL;
		} else {
			/* Read data from register*/
			com_rslt =
    9db4:	7860      	ldrb	r0, [r4, #1]
    9db6:	68a4      	ldr	r4, [r4, #8]
    9db8:	0013      	movs	r3, r2
    9dba:	000a      	movs	r2, r1
    9dbc:	0029      	movs	r1, r5
    9dbe:	47a0      	blx	r4
    9dc0:	e000      	b.n	9dc4 <bhy_read_reg+0x1c>
{
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	/* check the p_bhy structure as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    9dc2:	2000      	movs	r0, #0
			com_rslt =
			p_bhy->BHY_BUS_READ_FUNC(p_bhy->device_addr,
			v_addr_u8, v_data_u8, v_len_u16);
		}
	return com_rslt;
}
    9dc4:	bd70      	pop	{r4, r5, r6, pc}
    9dc6:	46c0      	nop			; (mov r8, r8)
    9dc8:	200017e4 	.word	0x200017e4

00009dcc <bhy_set_fifo_flush>:
 *	@retval 0 -> Success
 *	@retval -1 -> Error
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_set_fifo_flush(u8 v_fifo_flush_u8)
{
    9dcc:	b530      	push	{r4, r5, lr}
    9dce:	b083      	sub	sp, #12
    9dd0:	0004      	movs	r4, r0
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
    9dd2:	2200      	movs	r2, #0
    9dd4:	466b      	mov	r3, sp
    9dd6:	71da      	strb	r2, [r3, #7]

	if (BHY_NULL_PTR == p_bhy) {
    9dd8:	4b0d      	ldr	r3, [pc, #52]	; (9e10 <bhy_set_fifo_flush+0x44>)
    9dda:	681b      	ldr	r3, [r3, #0]
    9ddc:	2b00      	cmp	r3, #0
    9dde:	d013      	beq.n	9e08 <bhy_set_fifo_flush+0x3c>
		com_rslt = BHY_NULL;
		} else {
		com_rslt =
    9de0:	7858      	ldrb	r0, [r3, #1]
    9de2:	689d      	ldr	r5, [r3, #8]
    9de4:	2301      	movs	r3, #1
    9de6:	466a      	mov	r2, sp
    9de8:	3207      	adds	r2, #7
    9dea:	2132      	movs	r1, #50	; 0x32
    9dec:	47a8      	blx	r5
		p_bhy->BHY_BUS_READ_FUNC(p_bhy->device_addr,
		BHY_I2C_REG_FIFO_FLUSH__REG,
		&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
		if (BHY_SUCCESS == com_rslt) {
    9dee:	2800      	cmp	r0, #0
    9df0:	d10b      	bne.n	9e0a <bhy_set_fifo_flush+0x3e>
			v_data_u8 = BHY_SET_BITSLICE(v_data_u8,
    9df2:	466b      	mov	r3, sp
    9df4:	1dda      	adds	r2, r3, #7
    9df6:	7014      	strb	r4, [r2, #0]
			BHY_I2C_REG_FIFO_FLUSH,
			v_fifo_flush_u8);
			com_rslt += p_bhy->BHY_BUS_WRITE_FUNC
    9df8:	4b05      	ldr	r3, [pc, #20]	; (9e10 <bhy_set_fifo_flush+0x44>)
    9dfa:	681b      	ldr	r3, [r3, #0]
    9dfc:	7858      	ldrb	r0, [r3, #1]
    9dfe:	685c      	ldr	r4, [r3, #4]
    9e00:	2301      	movs	r3, #1
    9e02:	2132      	movs	r1, #50	; 0x32
    9e04:	47a0      	blx	r4
    9e06:	e000      	b.n	9e0a <bhy_set_fifo_flush+0x3e>
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;

	if (BHY_NULL_PTR == p_bhy) {
		com_rslt = BHY_NULL;
    9e08:	2000      	movs	r0, #0
			BHY_I2C_REG_FIFO_FLUSH__REG,
			&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
		}
	}
	return com_rslt;
}
    9e0a:	b003      	add	sp, #12
    9e0c:	bd30      	pop	{r4, r5, pc}
    9e0e:	46c0      	nop			; (mov r8, r8)
    9e10:	200017e4 	.word	0x200017e4

00009e14 <bhy_read_bytes_remaining>:
 *
 *
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_read_bytes_remaining(u16 *v_bytes_remaining_u16)
{
    9e14:	b570      	push	{r4, r5, r6, lr}
    9e16:	b082      	sub	sp, #8
    9e18:	0005      	movs	r5, r0
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	/* Array contains the bytes reaming of FIFO lSB and MSB data
		v_data_u8[LSB_ZERO] - LSB
		v_data_u8[MSB_ONE] - MSB*/
	u8 v_data_u8[BHY_BYTES_REMAINING_SIZE] = {BHY_INIT_VALUE,
    9e1a:	ab01      	add	r3, sp, #4
    9e1c:	2200      	movs	r2, #0
    9e1e:	701a      	strb	r2, [r3, #0]
    9e20:	705a      	strb	r2, [r3, #1]
	BHY_INIT_VALUE};
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    9e22:	4b0a      	ldr	r3, [pc, #40]	; (9e4c <bhy_read_bytes_remaining+0x38>)
    9e24:	681b      	ldr	r3, [r3, #0]
    9e26:	2b00      	cmp	r3, #0
    9e28:	d00c      	beq.n	9e44 <bhy_read_bytes_remaining+0x30>
		com_rslt = BHY_NULL;
		} else {
			/* read bytes remaining data */
			com_rslt =
    9e2a:	ac01      	add	r4, sp, #4
    9e2c:	7858      	ldrb	r0, [r3, #1]
    9e2e:	689e      	ldr	r6, [r3, #8]
    9e30:	2302      	movs	r3, #2
    9e32:	0022      	movs	r2, r4
    9e34:	2138      	movs	r1, #56	; 0x38
    9e36:	47b0      	blx	r6
			p_bhy->BHY_BUS_READ_FUNC(p_bhy->device_addr,
			BHY_I2C_REG_BYTES_REMAINING_LSB_ADDR,
			v_data_u8, BHY_BYTES_REMAINING_LENGTH);
			/* get the bytes remaining data*/
			*v_bytes_remaining_u16 = (u16)
    9e38:	7863      	ldrb	r3, [r4, #1]
    9e3a:	021b      	lsls	r3, r3, #8
    9e3c:	7822      	ldrb	r2, [r4, #0]
    9e3e:	4313      	orrs	r3, r2
    9e40:	802b      	strh	r3, [r5, #0]
    9e42:	e000      	b.n	9e46 <bhy_read_bytes_remaining+0x32>
		v_data_u8[MSB_ONE] - MSB*/
	u8 v_data_u8[BHY_BYTES_REMAINING_SIZE] = {BHY_INIT_VALUE,
	BHY_INIT_VALUE};
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt = BHY_NULL;
    9e44:	2000      	movs	r0, #0
			((v_data_u8[BHY_BYTES_REMAINING_MSB]
			<< BHY_SHIFT_BIT_POSITION_BY_08_BITS)
			| (v_data_u8[BHY_BYTES_REMAINING_LSB]));
		}
	return com_rslt;
}
    9e46:	b002      	add	sp, #8
    9e48:	bd70      	pop	{r4, r5, r6, pc}
    9e4a:	46c0      	nop			; (mov r8, r8)
    9e4c:	200017e4 	.word	0x200017e4

00009e50 <bhy_get_parameter_acknowledge>:
 *
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_get_parameter_acknowledge(
u8 *v_parameter_acknowledge_u8)
{
    9e50:	b570      	push	{r4, r5, r6, lr}
    9e52:	b082      	sub	sp, #8
    9e54:	0005      	movs	r5, r0
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
    9e56:	2200      	movs	r2, #0
    9e58:	466b      	mov	r3, sp
    9e5a:	71da      	strb	r2, [r3, #7]
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    9e5c:	4b08      	ldr	r3, [pc, #32]	; (9e80 <bhy_get_parameter_acknowledge+0x30>)
    9e5e:	681b      	ldr	r3, [r3, #0]
    9e60:	2b00      	cmp	r3, #0
    9e62:	d00a      	beq.n	9e7a <bhy_get_parameter_acknowledge+0x2a>
		com_rslt =  BHY_NULL;
		} else {
			/* read the parameter acknowledgement*/
			com_rslt =
    9e64:	466a      	mov	r2, sp
    9e66:	1dd4      	adds	r4, r2, #7
    9e68:	7858      	ldrb	r0, [r3, #1]
    9e6a:	689e      	ldr	r6, [r3, #8]
    9e6c:	2301      	movs	r3, #1
    9e6e:	0022      	movs	r2, r4
    9e70:	213a      	movs	r1, #58	; 0x3a
    9e72:	47b0      	blx	r6
			p_bhy->BHY_BUS_READ_FUNC(p_bhy->device_addr,
			BHY_I2C_REG_PARAMETER_ACKNOWLEDGE_ADDR,
			&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
			*v_parameter_acknowledge_u8 = v_data_u8;
    9e74:	7823      	ldrb	r3, [r4, #0]
    9e76:	702b      	strb	r3, [r5, #0]
    9e78:	e000      	b.n	9e7c <bhy_get_parameter_acknowledge+0x2c>
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    9e7a:	2000      	movs	r0, #0
			BHY_I2C_REG_PARAMETER_ACKNOWLEDGE_ADDR,
			&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
			*v_parameter_acknowledge_u8 = v_data_u8;
		}
	return com_rslt;
}
    9e7c:	b002      	add	sp, #8
    9e7e:	bd70      	pop	{r4, r5, r6, pc}
    9e80:	200017e4 	.word	0x200017e4

00009e84 <bhy_set_parameter_page_select>:
 *
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_set_parameter_page_select(
u8 v_page_select_u8)
{
    9e84:	b510      	push	{r4, lr}
    9e86:	b082      	sub	sp, #8
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    9e88:	4b07      	ldr	r3, [pc, #28]	; (9ea8 <bhy_set_parameter_page_select+0x24>)
    9e8a:	681b      	ldr	r3, [r3, #0]
    9e8c:	2b00      	cmp	r3, #0
    9e8e:	d008      	beq.n	9ea2 <bhy_set_parameter_page_select+0x1e>
		com_rslt =  BHY_NULL;
		} else {
			v_data_u8 = v_page_select_u8;
    9e90:	466a      	mov	r2, sp
    9e92:	3207      	adds	r2, #7
    9e94:	7010      	strb	r0, [r2, #0]
			/* read the parameter page information*/
			com_rslt = p_bhy->BHY_BUS_WRITE_FUNC
    9e96:	7858      	ldrb	r0, [r3, #1]
    9e98:	685c      	ldr	r4, [r3, #4]
    9e9a:	2301      	movs	r3, #1
    9e9c:	2154      	movs	r1, #84	; 0x54
    9e9e:	47a0      	blx	r4
    9ea0:	e000      	b.n	9ea4 <bhy_set_parameter_page_select+0x20>
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    9ea2:	2000      	movs	r0, #0
			(p_bhy->device_addr,
			BHY_I2C_REG_PARAMETER_PAGE_SELECT__REG,
			&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
			}
			return com_rslt;
		}
    9ea4:	b002      	add	sp, #8
    9ea6:	bd10      	pop	{r4, pc}
    9ea8:	200017e4 	.word	0x200017e4

00009eac <bhy_set_parameter_request>:
 *
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_set_parameter_request(
u8 v_parameter_request_u8)
{
    9eac:	b510      	push	{r4, lr}
    9eae:	b082      	sub	sp, #8
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    9eb0:	4b07      	ldr	r3, [pc, #28]	; (9ed0 <bhy_set_parameter_request+0x24>)
    9eb2:	681b      	ldr	r3, [r3, #0]
    9eb4:	2b00      	cmp	r3, #0
    9eb6:	d008      	beq.n	9eca <bhy_set_parameter_request+0x1e>
		com_rslt =  BHY_NULL;
		} else {
			/* write load parameter request*/
			 v_data_u8 = v_parameter_request_u8;
    9eb8:	466a      	mov	r2, sp
    9eba:	3207      	adds	r2, #7
    9ebc:	7010      	strb	r0, [r2, #0]
			com_rslt = p_bhy->BHY_BUS_WRITE_FUNC
    9ebe:	7858      	ldrb	r0, [r3, #1]
    9ec0:	685c      	ldr	r4, [r3, #4]
    9ec2:	2301      	movs	r3, #1
    9ec4:	2164      	movs	r1, #100	; 0x64
    9ec6:	47a0      	blx	r4
    9ec8:	e000      	b.n	9ecc <bhy_set_parameter_request+0x20>
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    9eca:	2000      	movs	r0, #0
			(p_bhy->device_addr,
			BHY_I2C_REG_LOAD_PARAMETER_REQUEST__REG,
			&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
		}
	return com_rslt;
}
    9ecc:	b002      	add	sp, #8
    9ece:	bd10      	pop	{r4, pc}
    9ed0:	200017e4 	.word	0x200017e4

00009ed4 <bhy_get_crc_host>:
 *	@retval -1 -> Error
 *
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_get_crc_host(u32 *v_crc_host_u32)
{
    9ed4:	b570      	push	{r4, r5, r6, lr}
    9ed6:	b082      	sub	sp, #8
    9ed8:	0005      	movs	r5, r0
	a_data_u8[0] - crc HOST
	a_data_u8[1] - crc HOST
	a_data_u8[2] - crc HOST
	a_data_u8[3] - crc HOST
	*/
	u8 a_data_u8[BHY_CRC_HOST_SIZE] = {BHY_INIT_VALUE,
    9eda:	2300      	movs	r3, #0
    9edc:	9301      	str	r3, [sp, #4]
	BHY_INIT_VALUE, BHY_INIT_VALUE, BHY_INIT_VALUE};
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    9ede:	4b0d      	ldr	r3, [pc, #52]	; (9f14 <bhy_get_crc_host+0x40>)
    9ee0:	681b      	ldr	r3, [r3, #0]
    9ee2:	2b00      	cmp	r3, #0
    9ee4:	d012      	beq.n	9f0c <bhy_get_crc_host+0x38>
		com_rslt =  BHY_NULL;
		} else {
			com_rslt =
    9ee6:	ac01      	add	r4, sp, #4
    9ee8:	7858      	ldrb	r0, [r3, #1]
    9eea:	689e      	ldr	r6, [r3, #8]
    9eec:	2304      	movs	r3, #4
    9eee:	0022      	movs	r2, r4
    9ef0:	2197      	movs	r1, #151	; 0x97
    9ef2:	47b0      	blx	r6
			p_bhy->BHY_BUS_READ_FUNC(p_bhy->device_addr,
			BHY_I2C_REG_CRC_HOST_ADDR,
			a_data_u8, BHY_CRC_HOST_LENGTH);
			*v_crc_host_u32 = (u32)
    9ef4:	78e3      	ldrb	r3, [r4, #3]
    9ef6:	061a      	lsls	r2, r3, #24
    9ef8:	78a3      	ldrb	r3, [r4, #2]
    9efa:	041b      	lsls	r3, r3, #16
    9efc:	4313      	orrs	r3, r2
    9efe:	7822      	ldrb	r2, [r4, #0]
    9f00:	4313      	orrs	r3, r2
    9f02:	7862      	ldrb	r2, [r4, #1]
    9f04:	0212      	lsls	r2, r2, #8
    9f06:	4313      	orrs	r3, r2
    9f08:	602b      	str	r3, [r5, #0]
    9f0a:	e000      	b.n	9f0e <bhy_get_crc_host+0x3a>
	*/
	u8 a_data_u8[BHY_CRC_HOST_SIZE] = {BHY_INIT_VALUE,
	BHY_INIT_VALUE, BHY_INIT_VALUE, BHY_INIT_VALUE};
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    9f0c:	2000      	movs	r0, #0
			|(a_data_u8[BHY_CRC_HOST_XLSB]
			<< BHY_SHIFT_BIT_POSITION_BY_08_BITS)
			| (a_data_u8[BHY_CRC_HOST_LSB]));
		}
	return com_rslt;
}
    9f0e:	b002      	add	sp, #8
    9f10:	bd70      	pop	{r4, r5, r6, pc}
    9f12:	46c0      	nop			; (mov r8, r8)
    9f14:	200017e4 	.word	0x200017e4

00009f18 <bhy_set_reset_request>:
 *	@retval -1 -> Error
 *
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_set_reset_request(u8 v_reset_request_u8)
{
    9f18:	b510      	push	{r4, lr}
    9f1a:	b082      	sub	sp, #8
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    9f1c:	4b07      	ldr	r3, [pc, #28]	; (9f3c <bhy_set_reset_request+0x24>)
    9f1e:	681b      	ldr	r3, [r3, #0]
    9f20:	2b00      	cmp	r3, #0
    9f22:	d008      	beq.n	9f36 <bhy_set_reset_request+0x1e>
		com_rslt =  BHY_NULL;
		} else {
			v_data_u8 = v_reset_request_u8;
    9f24:	466a      	mov	r2, sp
    9f26:	3207      	adds	r2, #7
    9f28:	7010      	strb	r0, [r2, #0]
			/* write load parameter request*/
			com_rslt = p_bhy->BHY_BUS_WRITE_FUNC
    9f2a:	7858      	ldrb	r0, [r3, #1]
    9f2c:	685c      	ldr	r4, [r3, #4]
    9f2e:	2301      	movs	r3, #1
    9f30:	219b      	movs	r1, #155	; 0x9b
    9f32:	47a0      	blx	r4
    9f34:	e000      	b.n	9f38 <bhy_set_reset_request+0x20>
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    9f36:	2000      	movs	r0, #0
			(p_bhy->device_addr,
			BHY_I2C_REG_RESET_REQUEST__REG,
			&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
		}
	return com_rslt;
}
    9f38:	b002      	add	sp, #8
    9f3a:	bd10      	pop	{r4, pc}
    9f3c:	200017e4 	.word	0x200017e4

00009f40 <bhy_initialize_from_rom>:
		}
		return com_rslt;
}
BHY_RETURN_FUNCTION_TYPE bhy_initialize_from_rom(
const u8 *memory, const u32 v_file_length_u32)
{
    9f40:	b5f0      	push	{r4, r5, r6, r7, lr}
    9f42:	465f      	mov	r7, fp
    9f44:	4656      	mov	r6, sl
    9f46:	464d      	mov	r5, r9
    9f48:	4644      	mov	r4, r8
    9f4a:	b4f0      	push	{r4, r5, r6, r7}
    9f4c:	b095      	sub	sp, #84	; 0x54
    9f4e:	0005      	movs	r5, r0
    9f50:	000c      	movs	r4, r1
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_upload_addr = BHY_UPLOAD_DATA;
    9f52:	2300      	movs	r3, #0
    9f54:	223f      	movs	r2, #63	; 0x3f
    9f56:	a904      	add	r1, sp, #16
    9f58:	468c      	mov	ip, r1
    9f5a:	4462      	add	r2, ip
    9f5c:	7013      	strb	r3, [r2, #0]
	u8 v_chip_control_u8 = BHY_CHIP_CTRL_ENABLE_1;
    9f5e:	2102      	movs	r1, #2
    9f60:	223e      	movs	r2, #62	; 0x3e
    9f62:	4462      	add	r2, ip
    9f64:	7011      	strb	r1, [r2, #0]
	u32 v_crc_from_memory_u32 = BHY_INIT_VALUE;
	u32 v_crc_host_u32 = BHY_INIT_VALUE;
    9f66:	9312      	str	r3, [sp, #72]	; 0x48
    9f68:	ab0d      	add	r3, sp, #52	; 0x34
    9f6a:	3133      	adds	r1, #51	; 0x33
    9f6c:	4461      	add	r1, ip
	u32 data_to_process = BHY_INIT_VALUE;
	u32 packet_length = BHY_INIT_VALUE;;
	u8 i = BHY_INIT_VALUE;
	/* initialize the array*/
	for (; i < BHY_SIGNATURE_MEM_LEN; i++)
	data_from_mem[i] = BHY_INIT_VALUE;
    9f6e:	2200      	movs	r2, #0
    9f70:	701a      	strb	r2, [r3, #0]
    9f72:	3301      	adds	r3, #1
	u32 write_length = BHY_INIT_VALUE;
	u32 data_to_process = BHY_INIT_VALUE;
	u32 packet_length = BHY_INIT_VALUE;;
	u8 i = BHY_INIT_VALUE;
	/* initialize the array*/
	for (; i < BHY_SIGNATURE_MEM_LEN; i++)
    9f74:	428b      	cmp	r3, r1
    9f76:	d1fb      	bne.n	9f70 <bhy_initialize_from_rom+0x30>
	data_from_mem[i] = BHY_INIT_VALUE;
	for (i = BHY_INIT_VALUE; i < BHY_RAM_WRITE_LENGTH; i++)
	data_byte[i] = BHY_INIT_VALUE;
    9f78:	ab05      	add	r3, sp, #20
    9f7a:	2200      	movs	r2, #0
    9f7c:	701a      	strb	r2, [r3, #0]
    9f7e:	705a      	strb	r2, [r3, #1]
    9f80:	709a      	strb	r2, [r3, #2]
    9f82:	70da      	strb	r2, [r3, #3]
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    9f84:	4b4b      	ldr	r3, [pc, #300]	; (a0b4 <bhy_initialize_from_rom+0x174>)
    9f86:	681b      	ldr	r3, [r3, #0]
    9f88:	2b00      	cmp	r3, #0
    9f8a:	d100      	bne.n	9f8e <bhy_initialize_from_rom+0x4e>
    9f8c:	e08a      	b.n	a0a4 <bhy_initialize_from_rom+0x164>
    9f8e:	2300      	movs	r3, #0
    9f90:	0028      	movs	r0, r5
		com_rslt =  BHY_NULL;
		} else {
		/* Assign the memory data into the local array*/
		for (read_index_u8 = BHY_INIT_VALUE;
		read_index_u8 <= BHY_SIGNATURE_LENGTH; read_index_u8++) {
			data_from_mem[read_index_u8] = *(memory+read_index_u8);
    9f92:	5cc1      	ldrb	r1, [r0, r3]
    9f94:	aa0d      	add	r2, sp, #52	; 0x34
    9f96:	5499      	strb	r1, [r3, r2]
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
		} else {
		/* Assign the memory data into the local array*/
		for (read_index_u8 = BHY_INIT_VALUE;
		read_index_u8 <= BHY_SIGNATURE_LENGTH; read_index_u8++) {
    9f98:	3301      	adds	r3, #1
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
		} else {
		/* Assign the memory data into the local array*/
		for (read_index_u8 = BHY_INIT_VALUE;
    9f9a:	2b11      	cmp	r3, #17
    9f9c:	d1f9      	bne.n	9f92 <bhy_initialize_from_rom+0x52>
			com_rslt = BHY_SUCCESS;
			} else {
			com_rslt = BHY_ERROR;
		}
		/* read the CRC data from memory */
		v_crc_from_memory_u32 = (u32)
    9f9e:	79d3      	ldrb	r3, [r2, #7]
    9fa0:	0619      	lsls	r1, r3, #24
    9fa2:	7993      	ldrb	r3, [r2, #6]
    9fa4:	041b      	lsls	r3, r3, #16
    9fa6:	430b      	orrs	r3, r1
    9fa8:	7911      	ldrb	r1, [r2, #4]
    9faa:	430b      	orrs	r3, r1
    9fac:	7952      	ldrb	r2, [r2, #5]
    9fae:	0212      	lsls	r2, r2, #8
    9fb0:	4313      	orrs	r3, r2
    9fb2:	9302      	str	r3, [sp, #8]
		| (data_from_mem[BHY_CRC_HOST_FILE_LSB]));
		/* Remove the first 16 bytes*/
		data_to_process = v_file_length_u32 - BHY_SIGNATURE_LENGTH;

		/* set the reset as 0x01*/
		com_rslt = bhy_set_reset_request(BHY_RESET_ENABLE);
    9fb4:	2001      	movs	r0, #1
    9fb6:	4b40      	ldr	r3, [pc, #256]	; (a0b8 <bhy_initialize_from_rom+0x178>)
    9fb8:	4798      	blx	r3
    9fba:	0006      	movs	r6, r0
		com_rslt += bhy_write_reg(BHY_I2C_REG_CHIP_CONTROL_ADDR,
    9fbc:	2201      	movs	r2, #1
    9fbe:	213e      	movs	r1, #62	; 0x3e
    9fc0:	ab04      	add	r3, sp, #16
    9fc2:	469c      	mov	ip, r3
    9fc4:	4461      	add	r1, ip
    9fc6:	2034      	movs	r0, #52	; 0x34
    9fc8:	4f3c      	ldr	r7, [pc, #240]	; (a0bc <bhy_initialize_from_rom+0x17c>)
    9fca:	47b8      	blx	r7
    9fcc:	1986      	adds	r6, r0, r6
    9fce:	b2f6      	uxtb	r6, r6
		&v_chip_control_u8, BHY_GEN_READ_WRITE_LENGTH);
		/* set the upload data*/
		com_rslt += bhy_write_reg(BHY_I2C_REG_UPLOAD_0_ADDR,
    9fd0:	2201      	movs	r2, #1
    9fd2:	233f      	movs	r3, #63	; 0x3f
    9fd4:	a904      	add	r1, sp, #16
    9fd6:	468c      	mov	ip, r1
    9fd8:	4463      	add	r3, ip
    9fda:	0019      	movs	r1, r3
    9fdc:	2094      	movs	r0, #148	; 0x94
    9fde:	47b8      	blx	r7
    9fe0:	1830      	adds	r0, r6, r0
    9fe2:	b2c6      	uxtb	r6, r0
		&v_upload_addr, BHY_GEN_READ_WRITE_LENGTH);
		com_rslt += bhy_write_reg(BHY_I2C_REG_UPLOAD_1_ADDR,
    9fe4:	2201      	movs	r2, #1
    9fe6:	233f      	movs	r3, #63	; 0x3f
    9fe8:	a904      	add	r1, sp, #16
    9fea:	468c      	mov	ip, r1
    9fec:	4463      	add	r3, ip
    9fee:	0019      	movs	r1, r3
    9ff0:	2095      	movs	r0, #149	; 0x95
    9ff2:	47b8      	blx	r7


		/* write the memory of data */
		/*skips first 16 bytes*/
		write_data += 16;
		if (com_rslt == BHY_SUCCESS) {
    9ff4:	1830      	adds	r0, r6, r0
    9ff6:	b2c3      	uxtb	r3, r0
    9ff8:	2b00      	cmp	r3, #0
    9ffa:	d13b      	bne.n	a074 <bhy_initialize_from_rom+0x134>
		<< BHY_SHIFT_BIT_POSITION_BY_16_BITS)
		|(data_from_mem[BHY_CRC_HOST_FILE_XLSB]
		<< BHY_SHIFT_BIT_POSITION_BY_08_BITS)
		| (data_from_mem[BHY_CRC_HOST_FILE_LSB]));
		/* Remove the first 16 bytes*/
		data_to_process = v_file_length_u32 - BHY_SIGNATURE_LENGTH;
    9ffc:	3c10      	subs	r4, #16
		com_rslt += bhy_write_reg(BHY_I2C_REG_UPLOAD_0_ADDR,
		&v_upload_addr, BHY_GEN_READ_WRITE_LENGTH);
		com_rslt += bhy_write_reg(BHY_I2C_REG_UPLOAD_1_ADDR,
		&v_upload_addr, BHY_GEN_READ_WRITE_LENGTH);
		/* write the chip control register as 0x02*/
		write_length =
    9ffe:	0963      	lsrs	r3, r4, #5
    a000:	4698      	mov	r8, r3
			for (read_index_u8 = BHY_INIT_VALUE;
			read_index_u8 <=
			write_length; read_index_u8++) {

				packet_length = read_index_u8 == write_length ?
				(data_to_process % BHY_RAM_WRITE_LENGTH_API) / BHY_RAM_WRITE_LENGTH :
    a002:	06e4      	lsls	r4, r4, #27
    a004:	0f63      	lsrs	r3, r4, #29
    a006:	9303      	str	r3, [sp, #12]
    a008:	2300      	movs	r3, #0
    a00a:	469b      	mov	fp, r3
    a00c:	3310      	adds	r3, #16
    a00e:	469a      	mov	sl, r3
						- (reverse_index_u32+1));
						}
					}

				com_rslt +=
				bhy_write_reg(BHY_I2C_REG_UPLOAD_DATA_ADDR,
    a010:	4b2a      	ldr	r3, [pc, #168]	; (a0bc <bhy_initialize_from_rom+0x17c>)
    a012:	4699      	mov	r9, r3
    a014:	465b      	mov	r3, fp
    a016:	9301      	str	r3, [sp, #4]
    a018:	46d3      	mov	fp, sl
    a01a:	46c2      	mov	sl, r8
    a01c:	46a8      	mov	r8, r5
			for (read_index_u8 = BHY_INIT_VALUE;
			read_index_u8 <=
			write_length; read_index_u8++) {

				packet_length = read_index_u8 == write_length ?
				(data_to_process % BHY_RAM_WRITE_LENGTH_API) / BHY_RAM_WRITE_LENGTH :
    a01e:	2408      	movs	r4, #8
    a020:	9b01      	ldr	r3, [sp, #4]
    a022:	459a      	cmp	sl, r3
    a024:	d111      	bne.n	a04a <bhy_initialize_from_rom+0x10a>
				BHY_RAM_WRITE_LENGTH_API / BHY_RAM_WRITE_LENGTH;

				/*reverse the data*/
				for (reverse_block_index_u32 = 1 ; reverse_block_index_u32 <=
    a026:	9b03      	ldr	r3, [sp, #12]
    a028:	2b00      	cmp	r3, #0
    a02a:	d10d      	bne.n	a048 <bhy_initialize_from_rom+0x108>
			for (read_index_u8 = BHY_INIT_VALUE;
			read_index_u8 <=
			write_length; read_index_u8++) {

				packet_length = read_index_u8 == write_length ?
				(data_to_process % BHY_RAM_WRITE_LENGTH_API) / BHY_RAM_WRITE_LENGTH :
    a02c:	001c      	movs	r4, r3
    a02e:	e016      	b.n	a05e <bhy_initialize_from_rom+0x11e>
				for (reverse_block_index_u32 = 1 ; reverse_block_index_u32 <=
					packet_length ;
					reverse_block_index_u32++) {
					for (reverse_index_u32 = 0; reverse_index_u32 <
						BHY_RAM_WRITE_LENGTH; reverse_index_u32++) {
						data_byte[reverse_index_u32 + ((reverse_block_index_u32-1)*BHY_RAM_WRITE_LENGTH)] =
    a030:	7819      	ldrb	r1, [r3, #0]
    a032:	7011      	strb	r1, [r2, #0]
    a034:	3b01      	subs	r3, #1
    a036:	3201      	adds	r2, #1

				/*reverse the data*/
				for (reverse_block_index_u32 = 1 ; reverse_block_index_u32 <=
					packet_length ;
					reverse_block_index_u32++) {
					for (reverse_index_u32 = 0; reverse_index_u32 <
    a038:	4283      	cmp	r3, r0
    a03a:	d1f9      	bne.n	a030 <bhy_initialize_from_rom+0xf0>
				BHY_RAM_WRITE_LENGTH_API / BHY_RAM_WRITE_LENGTH;

				/*reverse the data*/
				for (reverse_block_index_u32 = 1 ; reverse_block_index_u32 <=
					packet_length ;
					reverse_block_index_u32++) {
    a03c:	3701      	adds	r7, #1
    a03e:	3504      	adds	r5, #4
    a040:	3604      	adds	r6, #4
				packet_length = read_index_u8 == write_length ?
				(data_to_process % BHY_RAM_WRITE_LENGTH_API) / BHY_RAM_WRITE_LENGTH :
				BHY_RAM_WRITE_LENGTH_API / BHY_RAM_WRITE_LENGTH;

				/*reverse the data*/
				for (reverse_block_index_u32 = 1 ; reverse_block_index_u32 <=
    a042:	42bc      	cmp	r4, r7
    a044:	d207      	bcs.n	a056 <bhy_initialize_from_rom+0x116>
    a046:	e00a      	b.n	a05e <bhy_initialize_from_rom+0x11e>
			for (read_index_u8 = BHY_INIT_VALUE;
			read_index_u8 <=
			write_length; read_index_u8++) {

				packet_length = read_index_u8 == write_length ?
				(data_to_process % BHY_RAM_WRITE_LENGTH_API) / BHY_RAM_WRITE_LENGTH :
    a048:	9c03      	ldr	r4, [sp, #12]
    a04a:	465b      	mov	r3, fp
    a04c:	3303      	adds	r3, #3
    a04e:	4443      	add	r3, r8
    a050:	001d      	movs	r5, r3
    a052:	ae05      	add	r6, sp, #20
    a054:	2701      	movs	r7, #1
    a056:	1f28      	subs	r0, r5, #4
    a058:	0032      	movs	r2, r6
    a05a:	002b      	movs	r3, r5
    a05c:	e7e8      	b.n	a030 <bhy_initialize_from_rom+0xf0>
						- (reverse_index_u32+1));
						}
					}

				com_rslt +=
				bhy_write_reg(BHY_I2C_REG_UPLOAD_DATA_ADDR,
    a05e:	00a2      	lsls	r2, r4, #2
    a060:	a905      	add	r1, sp, #20
    a062:	2096      	movs	r0, #150	; 0x96
    a064:	47c8      	blx	r9
				data_byte,
				packet_length * BHY_RAM_WRITE_LENGTH);
				write_data = write_data
    a066:	00a4      	lsls	r4, r4, #2
    a068:	44a3      	add	fp, r4
		/*skips first 16 bytes*/
		write_data += 16;
		if (com_rslt == BHY_SUCCESS) {
			for (read_index_u8 = BHY_INIT_VALUE;
			read_index_u8 <=
			write_length; read_index_u8++) {
    a06a:	9b01      	ldr	r3, [sp, #4]
    a06c:	3301      	adds	r3, #1
    a06e:	9301      	str	r3, [sp, #4]

		/* write the memory of data */
		/*skips first 16 bytes*/
		write_data += 16;
		if (com_rslt == BHY_SUCCESS) {
			for (read_index_u8 = BHY_INIT_VALUE;
    a070:	459a      	cmp	sl, r3
    a072:	d2d4      	bcs.n	a01e <bhy_initialize_from_rom+0xde>
				+ (packet_length * BHY_RAM_WRITE_LENGTH);
			}
		}

		/* Check the CRC success*/
		com_rslt = bhy_get_crc_host(&v_crc_host_u32);
    a074:	a812      	add	r0, sp, #72	; 0x48
    a076:	4b12      	ldr	r3, [pc, #72]	; (a0c0 <bhy_initialize_from_rom+0x180>)
    a078:	4798      	blx	r3
		if (v_crc_from_memory_u32 == v_crc_host_u32)
    a07a:	9b02      	ldr	r3, [sp, #8]
    a07c:	9a12      	ldr	r2, [sp, #72]	; 0x48
    a07e:	4293      	cmp	r3, r2
    a080:	d002      	beq.n	a088 <bhy_initialize_from_rom+0x148>
		com_rslt = BHY_SUCCESS;
		else
		com_rslt = BHY_ERROR;
    a082:	2403      	movs	r4, #3
    a084:	4264      	negs	r4, r4
    a086:	e000      	b.n	a08a <bhy_initialize_from_rom+0x14a>
		}

		/* Check the CRC success*/
		com_rslt = bhy_get_crc_host(&v_crc_host_u32);
		if (v_crc_from_memory_u32 == v_crc_host_u32)
		com_rslt = BHY_SUCCESS;
    a088:	2400      	movs	r4, #0
		else
		com_rslt = BHY_ERROR;
		/* disable upload mode*/
		v_chip_control_u8 = BHY_CHIP_CTRL_ENABLE_2;
    a08a:	213e      	movs	r1, #62	; 0x3e
    a08c:	ab04      	add	r3, sp, #16
    a08e:	469c      	mov	ip, r3
    a090:	4461      	add	r1, ip
    a092:	2301      	movs	r3, #1
    a094:	700b      	strb	r3, [r1, #0]
		/* write the chip control register as 0x02*/
		com_rslt += bhy_write_reg(BHY_I2C_REG_CHIP_CONTROL_ADDR,
    a096:	2201      	movs	r2, #1
    a098:	2034      	movs	r0, #52	; 0x34
    a09a:	4b08      	ldr	r3, [pc, #32]	; (a0bc <bhy_initialize_from_rom+0x17c>)
    a09c:	4798      	blx	r3
    a09e:	1900      	adds	r0, r0, r4
    a0a0:	b240      	sxtb	r0, r0
    a0a2:	e000      	b.n	a0a6 <bhy_initialize_from_rom+0x166>
	data_from_mem[i] = BHY_INIT_VALUE;
	for (i = BHY_INIT_VALUE; i < BHY_RAM_WRITE_LENGTH; i++)
	data_byte[i] = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    a0a4:	2000      	movs	r0, #0
		com_rslt += bhy_write_reg(BHY_I2C_REG_CHIP_CONTROL_ADDR,
		&v_chip_control_u8, BHY_GEN_READ_WRITE_LENGTH);

	}
	return com_rslt;
}
    a0a6:	b015      	add	sp, #84	; 0x54
    a0a8:	bc3c      	pop	{r2, r3, r4, r5}
    a0aa:	4690      	mov	r8, r2
    a0ac:	4699      	mov	r9, r3
    a0ae:	46a2      	mov	sl, r4
    a0b0:	46ab      	mov	fp, r5
    a0b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a0b4:	200017e4 	.word	0x200017e4
    a0b8:	00009f19 	.word	0x00009f19
    a0bc:	00009d85 	.word	0x00009d85
    a0c0:	00009ed5 	.word	0x00009ed5

0000a0c4 <bhy_write_parameter_bytes>:
 *
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_write_parameter_bytes(
u8 v_page_select_u8, u8 v_parameter_request_u8)
{
    a0c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    a0c6:	4657      	mov	r7, sl
    a0c8:	464e      	mov	r6, r9
    a0ca:	4645      	mov	r5, r8
    a0cc:	b4e0      	push	{r5, r6, r7}
    a0ce:	b084      	sub	sp, #16
    a0d0:	0004      	movs	r4, r0
    a0d2:	468a      	mov	sl, r1
/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_parameter_ack_u8 = BHY_INIT_VALUE;
    a0d4:	2200      	movs	r2, #0
    a0d6:	230f      	movs	r3, #15
    a0d8:	446b      	add	r3, sp
    a0da:	701a      	strb	r2, [r3, #0]
    a0dc:	2300      	movs	r3, #0
	u8 v_parameter_ack_check_u8 = BHY_INIT_VALUE;
	u8 v_write_parameter_byte_u8[BHY_WRITE_BUFFER_SIZE];
	u8 init_array_data = BHY_INIT_VALUE;

	for (; init_array_data < BHY_WRITE_BUFFER_SIZE; init_array_data++)
		v_write_parameter_byte_u8[init_array_data] = BHY_INIT_VALUE;
    a0de:	2100      	movs	r1, #0
    a0e0:	aa01      	add	r2, sp, #4
    a0e2:	5499      	strb	r1, [r3, r2]
    a0e4:	3301      	adds	r3, #1
	u8 v_parameter_ack_u8 = BHY_INIT_VALUE;
	u8 v_parameter_ack_check_u8 = BHY_INIT_VALUE;
	u8 v_write_parameter_byte_u8[BHY_WRITE_BUFFER_SIZE];
	u8 init_array_data = BHY_INIT_VALUE;

	for (; init_array_data < BHY_WRITE_BUFFER_SIZE; init_array_data++)
    a0e6:	2b08      	cmp	r3, #8
    a0e8:	d1fa      	bne.n	a0e0 <bhy_write_parameter_bytes+0x1c>
		v_write_parameter_byte_u8[init_array_data] = BHY_INIT_VALUE;
	/* check the p_bhy structure as NULL*/
	if (p_bhy == BHY_NULL) {
    a0ea:	4b26      	ldr	r3, [pc, #152]	; (a184 <bhy_write_parameter_bytes+0xc0>)
    a0ec:	6819      	ldr	r1, [r3, #0]
    a0ee:	2900      	cmp	r1, #0
    a0f0:	d03e      	beq.n	a170 <bhy_write_parameter_bytes+0xac>
		return BHY_NULL;
		} else {
		/* Assign the load parameters*/
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_1_REG]
		= write_buffer.write_parameter_byte1;
    a0f2:	4b25      	ldr	r3, [pc, #148]	; (a188 <bhy_write_parameter_bytes+0xc4>)
    a0f4:	7818      	ldrb	r0, [r3, #0]
    a0f6:	7010      	strb	r0, [r2, #0]
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_2_REG]
		= write_buffer.write_parameter_byte2;
    a0f8:	7858      	ldrb	r0, [r3, #1]
    a0fa:	7050      	strb	r0, [r2, #1]
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_3_REG]
		= write_buffer.write_parameter_byte3;
    a0fc:	7898      	ldrb	r0, [r3, #2]
    a0fe:	7090      	strb	r0, [r2, #2]
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_4_REG]
		= write_buffer.write_parameter_byte4;
    a100:	78d8      	ldrb	r0, [r3, #3]
    a102:	70d0      	strb	r0, [r2, #3]
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_5_REG]
		= write_buffer.write_parameter_byte5;
    a104:	7918      	ldrb	r0, [r3, #4]
    a106:	7110      	strb	r0, [r2, #4]
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_6_REG]
		= write_buffer.write_parameter_byte6;
    a108:	7958      	ldrb	r0, [r3, #5]
    a10a:	7150      	strb	r0, [r2, #5]
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_7_REG]
		= write_buffer.write_parameter_byte7;
    a10c:	7998      	ldrb	r0, [r3, #6]
    a10e:	7190      	strb	r0, [r2, #6]
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_8_REG]
		= write_buffer.write_parameter_byte8;
    a110:	79db      	ldrb	r3, [r3, #7]
    a112:	71d3      	strb	r3, [r2, #7]
		/* write values to the load address*/
		com_rslt = p_bhy->BHY_BUS_WRITE_FUNC
    a114:	7848      	ldrb	r0, [r1, #1]
    a116:	684d      	ldr	r5, [r1, #4]
    a118:	2308      	movs	r3, #8
    a11a:	215c      	movs	r1, #92	; 0x5c
    a11c:	47a8      	blx	r5
    a11e:	0005      	movs	r5, r0
		(p_bhy->device_addr,
		BHY_I2C_REG_PARAMETER_WRITE_BUFFER_ZERO,
		&v_write_parameter_byte_u8[BHY_WRITE_BUFFER_1_REG],
		BHY_WRITE_BUFFER_SIZE);
		/* select the page*/
		com_rslt += bhy_set_parameter_page_select(v_page_select_u8);
    a120:	0020      	movs	r0, r4
    a122:	4b1a      	ldr	r3, [pc, #104]	; (a18c <bhy_write_parameter_bytes+0xc8>)
    a124:	4798      	blx	r3
    a126:	1945      	adds	r5, r0, r5
    a128:	b2ec      	uxtb	r4, r5
		/* select the parameter*/
		com_rslt += bhy_set_parameter_request(v_parameter_request_u8);
    a12a:	4650      	mov	r0, sl
    a12c:	4b18      	ldr	r3, [pc, #96]	; (a190 <bhy_write_parameter_bytes+0xcc>)
    a12e:	4798      	blx	r3
    a130:	1824      	adds	r4, r4, r0
    a132:	b267      	sxtb	r7, r4
    a134:	2614      	movs	r6, #20
		for (v_parameter_ack_check_u8 = BHY_INIT_VALUE;
		v_parameter_ack_check_u8 < BHY_PARAMETER_ACK_LENGTH;
		v_parameter_ack_check_u8++) {
			/* read the acknowledgement*/
			com_rslt += bhy_get_parameter_acknowledge(
    a136:	250f      	movs	r5, #15
    a138:	446d      	add	r5, sp
    a13a:	4b16      	ldr	r3, [pc, #88]	; (a194 <bhy_write_parameter_bytes+0xd0>)
    a13c:	4698      	mov	r8, r3
			if (v_parameter_ack_u8 == v_parameter_request_u8) {
				com_rslt += BHY_SUCCESS;
				break;
			} else if (v_parameter_ack_u8
			== BHY_PARAMETER_ACK_CHECK) {
				p_bhy->delay_msec(BHY_PARAMETER_ACK_DELAY);
    a13e:	4b11      	ldr	r3, [pc, #68]	; (a184 <bhy_write_parameter_bytes+0xc0>)
    a140:	4699      	mov	r9, r3
		com_rslt += bhy_set_parameter_request(v_parameter_request_u8);
		for (v_parameter_ack_check_u8 = BHY_INIT_VALUE;
		v_parameter_ack_check_u8 < BHY_PARAMETER_ACK_LENGTH;
		v_parameter_ack_check_u8++) {
			/* read the acknowledgement*/
			com_rslt += bhy_get_parameter_acknowledge(
    a142:	0028      	movs	r0, r5
    a144:	47c0      	blx	r8
    a146:	19c0      	adds	r0, r0, r7
    a148:	b2c4      	uxtb	r4, r0
    a14a:	b267      	sxtb	r7, r4
			&v_parameter_ack_u8);
			if (v_parameter_ack_u8 == v_parameter_request_u8) {
    a14c:	782b      	ldrb	r3, [r5, #0]
    a14e:	459a      	cmp	sl, r3
    a150:	d010      	beq.n	a174 <bhy_write_parameter_bytes+0xb0>
				com_rslt += BHY_SUCCESS;
				break;
			} else if (v_parameter_ack_u8
    a152:	2b80      	cmp	r3, #128	; 0x80
    a154:	d106      	bne.n	a164 <bhy_write_parameter_bytes+0xa0>
			== BHY_PARAMETER_ACK_CHECK) {
				p_bhy->delay_msec(BHY_PARAMETER_ACK_DELAY);
    a156:	464b      	mov	r3, r9
    a158:	681b      	ldr	r3, [r3, #0]
    a15a:	691b      	ldr	r3, [r3, #16]
    a15c:	2032      	movs	r0, #50	; 0x32
    a15e:	4798      	blx	r3
				com_rslt += BHY_ERROR;
    a160:	3c03      	subs	r4, #3
    a162:	b267      	sxtb	r7, r4
    a164:	3e01      	subs	r6, #1
    a166:	b2f6      	uxtb	r6, r6
		BHY_WRITE_BUFFER_SIZE);
		/* select the page*/
		com_rslt += bhy_set_parameter_page_select(v_page_select_u8);
		/* select the parameter*/
		com_rslt += bhy_set_parameter_request(v_parameter_request_u8);
		for (v_parameter_ack_check_u8 = BHY_INIT_VALUE;
    a168:	2e00      	cmp	r6, #0
    a16a:	d1ea      	bne.n	a142 <bhy_write_parameter_bytes+0x7e>
    a16c:	0038      	movs	r0, r7
    a16e:	e002      	b.n	a176 <bhy_write_parameter_bytes+0xb2>

	for (; init_array_data < BHY_WRITE_BUFFER_SIZE; init_array_data++)
		v_write_parameter_byte_u8[init_array_data] = BHY_INIT_VALUE;
	/* check the p_bhy structure as NULL*/
	if (p_bhy == BHY_NULL) {
		return BHY_NULL;
    a170:	2000      	movs	r0, #0
    a172:	e000      	b.n	a176 <bhy_write_parameter_bytes+0xb2>
		com_rslt += bhy_set_parameter_request(v_parameter_request_u8);
		for (v_parameter_ack_check_u8 = BHY_INIT_VALUE;
		v_parameter_ack_check_u8 < BHY_PARAMETER_ACK_LENGTH;
		v_parameter_ack_check_u8++) {
			/* read the acknowledgement*/
			com_rslt += bhy_get_parameter_acknowledge(
    a174:	0038      	movs	r0, r7
			}
		}

	}
	return com_rslt;
}
    a176:	b004      	add	sp, #16
    a178:	bc1c      	pop	{r2, r3, r4}
    a17a:	4690      	mov	r8, r2
    a17c:	4699      	mov	r9, r3
    a17e:	46a2      	mov	sl, r4
    a180:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a182:	46c0      	nop			; (mov r8, r8)
    a184:	200017e4 	.word	0x200017e4
    a188:	200017dc 	.word	0x200017dc
    a18c:	00009e85 	.word	0x00009e85
    a190:	00009ead 	.word	0x00009ead
    a194:	00009e51 	.word	0x00009e51

0000a198 <bhy_set_non_wakeup_sensor_configuration>:
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_set_non_wakeup_sensor_configuration(
struct sensor_configuration_non_wakeup_t *sensor_configuration,
u8 v_parameter_request_u8)
{
    a198:	b510      	push	{r4, lr}
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	/* write sample rate*/
	write_buffer.write_parameter_byte1 = (u8)(
	sensor_configuration->non_wakeup_sample_rate & BHY_MASK_LSB_DATA);
    a19a:	8802      	ldrh	r2, [r0, #0]
u8 v_parameter_request_u8)
{
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	/* write sample rate*/
	write_buffer.write_parameter_byte1 = (u8)(
    a19c:	4b09      	ldr	r3, [pc, #36]	; (a1c4 <bhy_set_non_wakeup_sensor_configuration+0x2c>)
    a19e:	701a      	strb	r2, [r3, #0]
	sensor_configuration->non_wakeup_sample_rate & BHY_MASK_LSB_DATA);
	write_buffer.write_parameter_byte2 = (u8)
    a1a0:	0a12      	lsrs	r2, r2, #8
    a1a2:	705a      	strb	r2, [r3, #1]
	(sensor_configuration->non_wakeup_sample_rate
	>> BHY_SHIFT_BIT_POSITION_BY_08_BITS);
	/* write maximum report latency*/
	write_buffer.write_parameter_byte3 = (u8)(
	sensor_configuration->non_wakeup_max_report_latency
    a1a4:	8842      	ldrh	r2, [r0, #2]
	sensor_configuration->non_wakeup_sample_rate & BHY_MASK_LSB_DATA);
	write_buffer.write_parameter_byte2 = (u8)
	(sensor_configuration->non_wakeup_sample_rate
	>> BHY_SHIFT_BIT_POSITION_BY_08_BITS);
	/* write maximum report latency*/
	write_buffer.write_parameter_byte3 = (u8)(
    a1a6:	709a      	strb	r2, [r3, #2]
	sensor_configuration->non_wakeup_max_report_latency
	& BHY_MASK_LSB_DATA);
	write_buffer.write_parameter_byte4 = (u8)
    a1a8:	0a12      	lsrs	r2, r2, #8
    a1aa:	70da      	strb	r2, [r3, #3]
	(sensor_configuration->non_wakeup_max_report_latency
	>> BHY_SHIFT_BIT_POSITION_BY_08_BITS);
	/* write sensitivity*/
	write_buffer.write_parameter_byte5 = (u8)(
	sensor_configuration->non_wakeup_change_sensitivity
    a1ac:	8882      	ldrh	r2, [r0, #4]
	& BHY_MASK_LSB_DATA);
	write_buffer.write_parameter_byte4 = (u8)
	(sensor_configuration->non_wakeup_max_report_latency
	>> BHY_SHIFT_BIT_POSITION_BY_08_BITS);
	/* write sensitivity*/
	write_buffer.write_parameter_byte5 = (u8)(
    a1ae:	711a      	strb	r2, [r3, #4]
	sensor_configuration->non_wakeup_change_sensitivity
	 & BHY_MASK_LSB_DATA);
	write_buffer.write_parameter_byte6 = (u8)
    a1b0:	0a12      	lsrs	r2, r2, #8
    a1b2:	715a      	strb	r2, [r3, #5]
	(sensor_configuration->non_wakeup_change_sensitivity
	>> BHY_SHIFT_BIT_POSITION_BY_08_BITS);
	/* write dynamic range*/
	write_buffer.write_parameter_byte7 = (u8)(
	sensor_configuration->non_wakeup_dynamic_range & BHY_MASK_LSB_DATA);
    a1b4:	88c2      	ldrh	r2, [r0, #6]
	 & BHY_MASK_LSB_DATA);
	write_buffer.write_parameter_byte6 = (u8)
	(sensor_configuration->non_wakeup_change_sensitivity
	>> BHY_SHIFT_BIT_POSITION_BY_08_BITS);
	/* write dynamic range*/
	write_buffer.write_parameter_byte7 = (u8)(
    a1b6:	719a      	strb	r2, [r3, #6]
	sensor_configuration->non_wakeup_dynamic_range & BHY_MASK_LSB_DATA);
	write_buffer.write_parameter_byte8 = (u8)
    a1b8:	0a12      	lsrs	r2, r2, #8
    a1ba:	71da      	strb	r2, [r3, #7]
	(sensor_configuration->non_wakeup_dynamic_range
	>> BHY_SHIFT_BIT_POSITION_BY_08_BITS);
	/* load the parameter of non wakeup sensor configuration*/
	com_rslt = bhy_write_parameter_bytes(
    a1bc:	2003      	movs	r0, #3
    a1be:	4b02      	ldr	r3, [pc, #8]	; (a1c8 <bhy_set_non_wakeup_sensor_configuration+0x30>)
    a1c0:	4798      	blx	r3
	BHY_PAGE_3, v_parameter_request_u8);

	return com_rslt;
}
    a1c2:	bd10      	pop	{r4, pc}
    a1c4:	200017dc 	.word	0x200017dc
    a1c8:	0000a0c5 	.word	0x0000a0c5

0000a1cc <bhy_i2c_write>:
}



int8_t bhy_i2c_write(uint8_t dev_addr, uint8_t reg_addr, uint8_t *reg_data, uint16_t length)
{
    a1cc:	b5b0      	push	{r4, r5, r7, lr}
    a1ce:	af00      	add	r7, sp, #0
	enum status_code bhy_write_stat = STATUS_BUSY;

    uint8_t i, buffer[length + REG_ADDR_LENGTH_BYTE];
    a1d0:	001c      	movs	r4, r3
    a1d2:	3408      	adds	r4, #8
    a1d4:	08e4      	lsrs	r4, r4, #3
    a1d6:	00e4      	lsls	r4, r4, #3
    a1d8:	466d      	mov	r5, sp
    a1da:	1b2c      	subs	r4, r5, r4
    a1dc:	46a5      	mov	sp, r4
    a1de:	466d      	mov	r5, sp


    buffer[0] = reg_addr;
    a1e0:	7029      	strb	r1, [r5, #0]

	for (i=1; i<=length; i++)
    a1e2:	2b00      	cmp	r3, #0
    a1e4:	d008      	beq.n	a1f8 <bhy_i2c_write+0x2c>
    a1e6:	2101      	movs	r1, #1
	{
		buffer[i] = *reg_data++;
    a1e8:	7814      	ldrb	r4, [r2, #0]
    a1ea:	546c      	strb	r4, [r5, r1]
    uint8_t i, buffer[length + REG_ADDR_LENGTH_BYTE];


    buffer[0] = reg_addr;

	for (i=1; i<=length; i++)
    a1ec:	3101      	adds	r1, #1
    a1ee:	b2c9      	uxtb	r1, r1
    a1f0:	3201      	adds	r2, #1
    a1f2:	b28c      	uxth	r4, r1
    a1f4:	42a3      	cmp	r3, r4
    a1f6:	d2f7      	bcs.n	a1e8 <bhy_i2c_write+0x1c>
	{
		buffer[i] = *reg_data++;
	}

 	bhy_i2c_wr_pkt.address	   = dev_addr;	//i2c slave address
    a1f8:	4908      	ldr	r1, [pc, #32]	; (a21c <bhy_i2c_write+0x50>)
    a1fa:	8008      	strh	r0, [r1, #0]
	bhy_i2c_wr_pkt.data	       = buffer; //&reg_addr; // send register address
    a1fc:	604d      	str	r5, [r1, #4]
	bhy_i2c_wr_pkt.data_length = length + REG_ADDR_LENGTH_BYTE; //REG_ADDR_LENGTH_BYTE; // address length always one byte
    a1fe:	3301      	adds	r3, #1
    a200:	804b      	strh	r3, [r1, #2]
	bhy_i2c_wr_pkt.ten_bit_address = false;
    a202:	2300      	movs	r3, #0
    a204:	720b      	strb	r3, [r1, #8]
	bhy_i2c_wr_pkt.high_speed = false;
    a206:	724b      	strb	r3, [r1, #9]
	bhy_write_stat = i2c_master_write_packet_wait(&i2c_master_instance, &bhy_i2c_wr_pkt);
    a208:	4805      	ldr	r0, [pc, #20]	; (a220 <bhy_i2c_write+0x54>)
    a20a:	4b06      	ldr	r3, [pc, #24]	; (a224 <bhy_i2c_write+0x58>)
    a20c:	4798      	blx	r3


	if (bhy_write_stat != STATUS_OK){
    a20e:	2800      	cmp	r0, #0
    a210:	d001      	beq.n	a216 <bhy_i2c_write+0x4a>
		return BHY_ERROR;
    a212:	2003      	movs	r0, #3
    a214:	4240      	negs	r0, r0
	}
	return BHY_SUCCESS;
}
    a216:	46bd      	mov	sp, r7
    a218:	bdb0      	pop	{r4, r5, r7, pc}
    a21a:	46c0      	nop			; (mov r8, r8)
    a21c:	20001bec 	.word	0x20001bec
    a220:	20001c04 	.word	0x20001c04
    a224:	0000b279 	.word	0x0000b279

0000a228 <bhy_i2c_read>:


int8_t bhy_i2c_read(uint8_t dev_addr, uint8_t reg_addr, uint8_t *rx_data, uint16_t length)
{
    a228:	b570      	push	{r4, r5, r6, lr}
    a22a:	b082      	sub	sp, #8
    a22c:	0016      	movs	r6, r2
    a22e:	001d      	movs	r5, r3
    a230:	466b      	mov	r3, sp
    a232:	71d9      	strb	r1, [r3, #7]
    a234:	3307      	adds	r3, #7
	enum status_code bhy_read_stat = STATUS_BUSY, bhy_write_stat = STATUS_BUSY;

	bhy_i2c_wr_pkt.address	   = dev_addr;	//i2c slave address
    a236:	b284      	uxth	r4, r0
    a238:	4910      	ldr	r1, [pc, #64]	; (a27c <bhy_i2c_read+0x54>)
    a23a:	800c      	strh	r4, [r1, #0]
	bhy_i2c_wr_pkt.data	       = &reg_addr; // send register address
    a23c:	604b      	str	r3, [r1, #4]
	bhy_i2c_wr_pkt.data_length = REG_ADDR_LENGTH_BYTE; // address length always one byte
    a23e:	2301      	movs	r3, #1
    a240:	804b      	strh	r3, [r1, #2]
	bhy_i2c_wr_pkt.ten_bit_address = false;
    a242:	2300      	movs	r3, #0
    a244:	720b      	strb	r3, [r1, #8]
	bhy_i2c_wr_pkt.high_speed = false;
    a246:	724b      	strb	r3, [r1, #9]
	bhy_write_stat = i2c_master_write_packet_wait_no_stop(&i2c_master_instance, &bhy_i2c_wr_pkt);
    a248:	480d      	ldr	r0, [pc, #52]	; (a280 <bhy_i2c_read+0x58>)
    a24a:	4b0e      	ldr	r3, [pc, #56]	; (a284 <bhy_i2c_read+0x5c>)
    a24c:	4798      	blx	r3

	if (bhy_write_stat != STATUS_OK){
    a24e:	2800      	cmp	r0, #0
    a250:	d10c      	bne.n	a26c <bhy_i2c_read+0x44>
		return BHY_ERROR;
	}

	bhy_i2c_rd_pkt.address	   = dev_addr;	//i2c slave address
    a252:	490d      	ldr	r1, [pc, #52]	; (a288 <bhy_i2c_read+0x60>)
    a254:	800c      	strh	r4, [r1, #0]
	bhy_i2c_rd_pkt.data	       = rx_data; // send register address
    a256:	604e      	str	r6, [r1, #4]
	bhy_i2c_rd_pkt.data_length = length; // address length always one byte
    a258:	804d      	strh	r5, [r1, #2]
	bhy_i2c_rd_pkt.ten_bit_address = false;
    a25a:	2300      	movs	r3, #0
    a25c:	720b      	strb	r3, [r1, #8]
	bhy_i2c_rd_pkt.high_speed = false;
    a25e:	724b      	strb	r3, [r1, #9]
	bhy_read_stat = i2c_master_read_packet_wait(&i2c_master_instance, &bhy_i2c_rd_pkt);
    a260:	4807      	ldr	r0, [pc, #28]	; (a280 <bhy_i2c_read+0x58>)
    a262:	4b0a      	ldr	r3, [pc, #40]	; (a28c <bhy_i2c_read+0x64>)
    a264:	4798      	blx	r3

	if (bhy_read_stat != STATUS_OK){
    a266:	2800      	cmp	r0, #0
    a268:	d103      	bne.n	a272 <bhy_i2c_read+0x4a>
    a26a:	e004      	b.n	a276 <bhy_i2c_read+0x4e>
	bhy_i2c_wr_pkt.ten_bit_address = false;
	bhy_i2c_wr_pkt.high_speed = false;
	bhy_write_stat = i2c_master_write_packet_wait_no_stop(&i2c_master_instance, &bhy_i2c_wr_pkt);

	if (bhy_write_stat != STATUS_OK){
		return BHY_ERROR;
    a26c:	2003      	movs	r0, #3
    a26e:	4240      	negs	r0, r0
    a270:	e001      	b.n	a276 <bhy_i2c_read+0x4e>
	bhy_i2c_rd_pkt.ten_bit_address = false;
	bhy_i2c_rd_pkt.high_speed = false;
	bhy_read_stat = i2c_master_read_packet_wait(&i2c_master_instance, &bhy_i2c_rd_pkt);

	if (bhy_read_stat != STATUS_OK){
		return BHY_ERROR;
    a272:	2003      	movs	r0, #3
    a274:	4240      	negs	r0, r0
	}

	return BHY_SUCCESS;
}
    a276:	b002      	add	sp, #8
    a278:	bd70      	pop	{r4, r5, r6, pc}
    a27a:	46c0      	nop			; (mov r8, r8)
    a27c:	20001bec 	.word	0x20001bec
    a280:	20001c04 	.word	0x20001c04
    a284:	0000b299 	.word	0x0000b299
    a288:	20001bf8 	.word	0x20001bf8
    a28c:	0000b259 	.word	0x0000b259

0000a290 <bhy_delay_msec>:


void bhy_delay_msec(u32 msec)
{
    a290:	b510      	push	{r4, lr}
	//mdelay(msec);
	delay_ms(msec);
    a292:	4b01      	ldr	r3, [pc, #4]	; (a298 <bhy_delay_msec+0x8>)
    a294:	4798      	blx	r3
}
    a296:	bd10      	pop	{r4, pc}
    a298:	0000c4f5 	.word	0x0000c4f5

0000a29c <bhy_reset>:


void bhy_reset(void)
{
    a29c:	b510      	push	{r4, lr}
	bhy_set_reset_request(BHY_RESET_ENABLE);
    a29e:	2001      	movs	r0, #1
    a2a0:	4b01      	ldr	r3, [pc, #4]	; (a2a8 <bhy_reset+0xc>)
    a2a2:	4798      	blx	r3
}
    a2a4:	bd10      	pop	{r4, pc}
    a2a6:	46c0      	nop			; (mov r8, r8)
    a2a8:	00009f19 	.word	0x00009f19

0000a2ac <bhy_initialize_support>:


extern void mdelay(uint32_t ul_dly_ticks);

void bhy_initialize_support(void)
{
    a2ac:	b510      	push	{r4, lr}
	bhy.bus_write = &bhy_i2c_write;
    a2ae:	4c07      	ldr	r4, [pc, #28]	; (a2cc <bhy_initialize_support+0x20>)
    a2b0:	4b07      	ldr	r3, [pc, #28]	; (a2d0 <bhy_initialize_support+0x24>)
    a2b2:	6063      	str	r3, [r4, #4]
	bhy.bus_read = &bhy_i2c_read;
    a2b4:	4b07      	ldr	r3, [pc, #28]	; (a2d4 <bhy_initialize_support+0x28>)
    a2b6:	60a3      	str	r3, [r4, #8]
	bhy.delay_msec = &bhy_delay_msec;
    a2b8:	4b07      	ldr	r3, [pc, #28]	; (a2d8 <bhy_initialize_support+0x2c>)
    a2ba:	6123      	str	r3, [r4, #16]
	bhy.device_addr = BHY_I2C_SLAVE_ADDRESS;
    a2bc:	2328      	movs	r3, #40	; 0x28
    a2be:	7063      	strb	r3, [r4, #1]

	bhy_reset();
    a2c0:	4b06      	ldr	r3, [pc, #24]	; (a2dc <bhy_initialize_support+0x30>)
    a2c2:	4798      	blx	r3

	bhy_init(&bhy);
    a2c4:	0020      	movs	r0, r4
    a2c6:	4b06      	ldr	r3, [pc, #24]	; (a2e0 <bhy_initialize_support+0x34>)
    a2c8:	4798      	blx	r3
}
    a2ca:	bd10      	pop	{r4, pc}
    a2cc:	20001bd4 	.word	0x20001bd4
    a2d0:	0000a1cd 	.word	0x0000a1cd
    a2d4:	0000a229 	.word	0x0000a229
    a2d8:	0000a291 	.word	0x0000a291
    a2dc:	0000a29d 	.word	0x0000a29d
    a2e0:	00009d59 	.word	0x00009d59

0000a2e4 <bhy_driver_init>:


/* initializes the driver, the API and loads the ram patch into the sensor */
BHY_RETURN_FUNCTION_TYPE bhy_driver_init(
	const u8 *bhy_fw_data, const u32 bhy_fw_len)
{
    a2e4:	b570      	push	{r4, r5, r6, lr}
    a2e6:	0004      	movs	r4, r0
    a2e8:	000d      	movs	r5, r1
	BHY_RETURN_FUNCTION_TYPE result= BHY_SUCCESS;

	bhy_initialize_support();
    a2ea:	4b03      	ldr	r3, [pc, #12]	; (a2f8 <bhy_driver_init+0x14>)
    a2ec:	4798      	blx	r3

	/* downloads the ram patch to the BHy */
	result += bhy_initialize_from_rom(bhy_fw_data, bhy_fw_len);
    a2ee:	0029      	movs	r1, r5
    a2f0:	0020      	movs	r0, r4
    a2f2:	4b02      	ldr	r3, [pc, #8]	; (a2fc <bhy_driver_init+0x18>)
    a2f4:	4798      	blx	r3

	return result;
}
    a2f6:	bd70      	pop	{r4, r5, r6, pc}
    a2f8:	0000a2ad 	.word	0x0000a2ad
    a2fc:	00009f41 	.word	0x00009f41

0000a300 <bhy_enable_virtual_sensor>:

/* this functions enables the selected virtual sensor */
BHY_RETURN_FUNCTION_TYPE bhy_enable_virtual_sensor
	(	bhy_virtual_sensor_t sensor_id, u8 wakeup_status, u16 sample_rate,
		u16 max_report_latency_ms, u8 flush_sensor, u16 change_sensitivity,
		u16 dynamic_range ) {
    a300:	b5f0      	push	{r4, r5, r6, r7, lr}
    a302:	4657      	mov	r7, sl
    a304:	b480      	push	{r7}
    a306:	b084      	sub	sp, #16
    a308:	000f      	movs	r7, r1
    a30a:	9200      	str	r2, [sp, #0]
    a30c:	9301      	str	r3, [sp, #4]
    a30e:	ab0a      	add	r3, sp, #40	; 0x28
    a310:	781b      	ldrb	r3, [r3, #0]
    a312:	aa0b      	add	r2, sp, #44	; 0x2c
    a314:	8816      	ldrh	r6, [r2, #0]
    a316:	aa0c      	add	r2, sp, #48	; 0x30
    a318:	8815      	ldrh	r5, [r2, #0]
		struct sensor_configuration_wakeup_t sensor_configuration_wakeup;
		struct sensor_configuration_non_wakeup_t sensor_configuration_non_wakeup;
	} sensor_configuration;

	/* checks if sensor id is in range */
	if (sensor_id >= 32)
    a31a:	281f      	cmp	r0, #31
    a31c:	d839      	bhi.n	a392 <bhy_enable_virtual_sensor+0x92>
		return BHY_OUT_OF_RANGE;

	/*computes the sensor id */
	sensor_id += wakeup_status;
    a31e:	1840      	adds	r0, r0, r1
    a320:	b2c4      	uxtb	r4, r0

	/* flush the fifo if requested */
	switch (flush_sensor) {
    a322:	2b01      	cmp	r3, #1
    a324:	d004      	beq.n	a330 <bhy_enable_virtual_sensor+0x30>
    a326:	2b00      	cmp	r3, #0
    a328:	d00c      	beq.n	a344 <bhy_enable_virtual_sensor+0x44>
    a32a:	2bff      	cmp	r3, #255	; 0xff
    a32c:	d005      	beq.n	a33a <bhy_enable_virtual_sensor+0x3a>
    a32e:	e033      	b.n	a398 <bhy_enable_virtual_sensor+0x98>
		case VS_FLUSH_SINGLE:
			result += bhy_set_fifo_flush(sensor_id);
    a330:	0020      	movs	r0, r4
    a332:	4b1e      	ldr	r3, [pc, #120]	; (a3ac <bhy_enable_virtual_sensor+0xac>)
    a334:	4798      	blx	r3
    a336:	4682      	mov	sl, r0
			break;
    a338:	e006      	b.n	a348 <bhy_enable_virtual_sensor+0x48>
		case VS_FLUSH_ALL:
			result += bhy_set_fifo_flush(VS_FLUSH_ALL);
    a33a:	20ff      	movs	r0, #255	; 0xff
    a33c:	4b1b      	ldr	r3, [pc, #108]	; (a3ac <bhy_enable_virtual_sensor+0xac>)
    a33e:	4798      	blx	r3
    a340:	4682      	mov	sl, r0
			break;
    a342:	e001      	b.n	a348 <bhy_enable_virtual_sensor+0x48>
BHY_RETURN_FUNCTION_TYPE bhy_enable_virtual_sensor
	(	bhy_virtual_sensor_t sensor_id, u8 wakeup_status, u16 sample_rate,
		u16 max_report_latency_ms, u8 flush_sensor, u16 change_sensitivity,
		u16 dynamic_range ) {

	BHY_RETURN_FUNCTION_TYPE result= BHY_SUCCESS;
    a344:	2300      	movs	r3, #0
    a346:	469a      	mov	sl, r3
		default:
			return BHY_OUT_OF_RANGE;
	}

	/* computes the param page as sensor_id + 0xC0 (sensor parameter write)*/
	sensor_id+= 0xC0;
    a348:	3c40      	subs	r4, #64	; 0x40
    a34a:	b2e1      	uxtb	r1, r4

	/*calls the right function */
	switch (wakeup_status) {
    a34c:	2f00      	cmp	r7, #0
    a34e:	d002      	beq.n	a356 <bhy_enable_virtual_sensor+0x56>
    a350:	2f20      	cmp	r7, #32
    a352:	d00f      	beq.n	a374 <bhy_enable_virtual_sensor+0x74>
    a354:	e023      	b.n	a39e <bhy_enable_virtual_sensor+0x9e>
		case VS_NON_WAKEUP:
		sensor_configuration.sensor_configuration_non_wakeup.non_wakeup_sample_rate = sample_rate;
    a356:	ab02      	add	r3, sp, #8
    a358:	466a      	mov	r2, sp
    a35a:	8812      	ldrh	r2, [r2, #0]
    a35c:	801a      	strh	r2, [r3, #0]
		sensor_configuration.sensor_configuration_non_wakeup.non_wakeup_max_report_latency = max_report_latency_ms;
    a35e:	466a      	mov	r2, sp
    a360:	8892      	ldrh	r2, [r2, #4]
    a362:	805a      	strh	r2, [r3, #2]
		sensor_configuration.sensor_configuration_non_wakeup.non_wakeup_change_sensitivity = change_sensitivity;
    a364:	809e      	strh	r6, [r3, #4]
		sensor_configuration.sensor_configuration_non_wakeup.non_wakeup_dynamic_range = dynamic_range;
    a366:	80dd      	strh	r5, [r3, #6]
		result += bhy_set_non_wakeup_sensor_configuration( &sensor_configuration.sensor_configuration_non_wakeup, sensor_id);
    a368:	0018      	movs	r0, r3
    a36a:	4b11      	ldr	r3, [pc, #68]	; (a3b0 <bhy_enable_virtual_sensor+0xb0>)
    a36c:	4798      	blx	r3
    a36e:	4450      	add	r0, sl
    a370:	b240      	sxtb	r0, r0
		return result;
    a372:	e016      	b.n	a3a2 <bhy_enable_virtual_sensor+0xa2>

		case VS_WAKEUP:
		sensor_configuration.sensor_configuration_wakeup.wakeup_sample_rate = sample_rate;
    a374:	ab02      	add	r3, sp, #8
    a376:	466a      	mov	r2, sp
    a378:	8812      	ldrh	r2, [r2, #0]
    a37a:	801a      	strh	r2, [r3, #0]
		sensor_configuration.sensor_configuration_wakeup.wakeup_max_report_latency = max_report_latency_ms;
    a37c:	466a      	mov	r2, sp
    a37e:	8892      	ldrh	r2, [r2, #4]
    a380:	805a      	strh	r2, [r3, #2]
		sensor_configuration.sensor_configuration_wakeup.wakeup_change_sensitivity = change_sensitivity;
    a382:	809e      	strh	r6, [r3, #4]
		sensor_configuration.sensor_configuration_wakeup.wakeup_dynamic_range = dynamic_range;
    a384:	80dd      	strh	r5, [r3, #6]
		result += bhy_set_non_wakeup_sensor_configuration( &sensor_configuration.sensor_configuration_non_wakeup, sensor_id);
    a386:	0018      	movs	r0, r3
    a388:	4b09      	ldr	r3, [pc, #36]	; (a3b0 <bhy_enable_virtual_sensor+0xb0>)
    a38a:	4798      	blx	r3
    a38c:	4450      	add	r0, sl
    a38e:	b240      	sxtb	r0, r0
		return result;
    a390:	e007      	b.n	a3a2 <bhy_enable_virtual_sensor+0xa2>
		struct sensor_configuration_non_wakeup_t sensor_configuration_non_wakeup;
	} sensor_configuration;

	/* checks if sensor id is in range */
	if (sensor_id >= 32)
		return BHY_OUT_OF_RANGE;
    a392:	2002      	movs	r0, #2
    a394:	4240      	negs	r0, r0
    a396:	e004      	b.n	a3a2 <bhy_enable_virtual_sensor+0xa2>
			result += bhy_set_fifo_flush(VS_FLUSH_ALL);
			break;
		case VS_FLUSH_NONE:
			break;
		default:
			return BHY_OUT_OF_RANGE;
    a398:	2002      	movs	r0, #2
    a39a:	4240      	negs	r0, r0
    a39c:	e001      	b.n	a3a2 <bhy_enable_virtual_sensor+0xa2>
		sensor_configuration.sensor_configuration_wakeup.wakeup_dynamic_range = dynamic_range;
		result += bhy_set_non_wakeup_sensor_configuration( &sensor_configuration.sensor_configuration_non_wakeup, sensor_id);
		return result;

		default:
		return BHY_OUT_OF_RANGE;
    a39e:	2002      	movs	r0, #2
    a3a0:	4240      	negs	r0, r0
	}
}
    a3a2:	b004      	add	sp, #16
    a3a4:	bc04      	pop	{r2}
    a3a6:	4692      	mov	sl, r2
    a3a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a3aa:	46c0      	nop			; (mov r8, r8)
    a3ac:	00009dcd 	.word	0x00009dcd
    a3b0:	0000a199 	.word	0x0000a199

0000a3b4 <bhy_read_fifo>:
}

/* retrieves the fifo data. it needs a buffer of at least 51 bytes to work */
/* it outputs the data into the variable buffer. the number of bytes read */
/* into bytes_read  and the bytes remaining in the fifo into bytes_left */
BHY_RETURN_FUNCTION_TYPE bhy_read_fifo(u8 * buffer, const u16 buffer_size, u16 * bytes_read, u16 * bytes_left) {
    a3b4:	b5f0      	push	{r4, r5, r6, r7, lr}
    a3b6:	464f      	mov	r7, r9
    a3b8:	b480      	push	{r7}
    a3ba:	b082      	sub	sp, #8
    a3bc:	9001      	str	r0, [sp, #4]
    a3be:	000c      	movs	r4, r1
    a3c0:	0016      	movs	r6, r2
    a3c2:	001d      	movs	r5, r3
	BHY_RETURN_FUNCTION_TYPE result = BHY_SUCCESS;
	static u16 current_index = 0;
	static u16 current_transaction_size = 0;

	if (buffer_size <= 50)
    a3c4:	2932      	cmp	r1, #50	; 0x32
    a3c6:	d940      	bls.n	a44a <bhy_read_fifo+0x96>
		return BHY_OUT_OF_RANGE;

	/* gets the number of bytes left in the fifo either from memory of from */
	/* the register															*/
	if (current_transaction_size == 0)
    a3c8:	4b23      	ldr	r3, [pc, #140]	; (a458 <bhy_read_fifo+0xa4>)
    a3ca:	881b      	ldrh	r3, [r3, #0]

/* retrieves the fifo data. it needs a buffer of at least 51 bytes to work */
/* it outputs the data into the variable buffer. the number of bytes read */
/* into bytes_read  and the bytes remaining in the fifo into bytes_left */
BHY_RETURN_FUNCTION_TYPE bhy_read_fifo(u8 * buffer, const u16 buffer_size, u16 * bytes_read, u16 * bytes_left) {
	BHY_RETURN_FUNCTION_TYPE result = BHY_SUCCESS;
    a3cc:	2700      	movs	r7, #0
	if (buffer_size <= 50)
		return BHY_OUT_OF_RANGE;

	/* gets the number of bytes left in the fifo either from memory of from */
	/* the register															*/
	if (current_transaction_size == 0)
    a3ce:	2b00      	cmp	r3, #0
    a3d0:	d109      	bne.n	a3e6 <bhy_read_fifo+0x32>
		result = bhy_read_bytes_remaining(&current_transaction_size);
    a3d2:	4b21      	ldr	r3, [pc, #132]	; (a458 <bhy_read_fifo+0xa4>)
    a3d4:	4699      	mov	r9, r3
    a3d6:	0018      	movs	r0, r3
    a3d8:	4b20      	ldr	r3, [pc, #128]	; (a45c <bhy_read_fifo+0xa8>)
    a3da:	4798      	blx	r3
    a3dc:	0007      	movs	r7, r0

	/* if there are bytes in the fifo to read */
	if (current_transaction_size) {
    a3de:	464b      	mov	r3, r9
    a3e0:	881b      	ldrh	r3, [r3, #0]
    a3e2:	2b00      	cmp	r3, #0
    a3e4:	d02d      	beq.n	a442 <bhy_read_fifo+0x8e>

		/* calculates the number of bytes to read. either the number of 	*/
		/* bytes left, or the buffer size, or just enough so the last page 	*/
		/* does not get turned												*/
		if (buffer_size >= current_transaction_size-current_index)
    a3e6:	4a1e      	ldr	r2, [pc, #120]	; (a460 <bhy_read_fifo+0xac>)
    a3e8:	8810      	ldrh	r0, [r2, #0]
    a3ea:	1a1a      	subs	r2, r3, r0
    a3ec:	4294      	cmp	r4, r2
    a3ee:	db01      	blt.n	a3f4 <bhy_read_fifo+0x40>
			*bytes_read = current_transaction_size-current_index;
    a3f0:	8032      	strh	r2, [r6, #0]
    a3f2:	e008      	b.n	a406 <bhy_read_fifo+0x52>

		else if (current_transaction_size - (current_index+buffer_size) <= 50)
    a3f4:	1822      	adds	r2, r4, r0
    a3f6:	1a9a      	subs	r2, r3, r2
    a3f8:	2a32      	cmp	r2, #50	; 0x32
    a3fa:	dc03      	bgt.n	a404 <bhy_read_fifo+0x50>
			*bytes_read = (current_transaction_size-51) - current_index;
    a3fc:	1a1b      	subs	r3, r3, r0
    a3fe:	3b33      	subs	r3, #51	; 0x33
    a400:	8033      	strh	r3, [r6, #0]
    a402:	e000      	b.n	a406 <bhy_read_fifo+0x52>

		else
			*bytes_read = buffer_size;
    a404:	8034      	strh	r4, [r6, #0]

		result += bhy_read_reg(current_index%50, buffer, *bytes_read );
    a406:	8834      	ldrh	r4, [r6, #0]
    a408:	2132      	movs	r1, #50	; 0x32
    a40a:	4b16      	ldr	r3, [pc, #88]	; (a464 <bhy_read_fifo+0xb0>)
    a40c:	4798      	blx	r3
    a40e:	b2c8      	uxtb	r0, r1
    a410:	0022      	movs	r2, r4
    a412:	9901      	ldr	r1, [sp, #4]
    a414:	4b14      	ldr	r3, [pc, #80]	; (a468 <bhy_read_fifo+0xb4>)
    a416:	4798      	blx	r3
    a418:	19c7      	adds	r7, r0, r7
    a41a:	b27b      	sxtb	r3, r7

		current_index += *bytes_read;
    a41c:	4910      	ldr	r1, [pc, #64]	; (a460 <bhy_read_fifo+0xac>)
    a41e:	8830      	ldrh	r0, [r6, #0]
    a420:	880a      	ldrh	r2, [r1, #0]
    a422:	1882      	adds	r2, r0, r2
    a424:	b292      	uxth	r2, r2
    a426:	800a      	strh	r2, [r1, #0]

		*bytes_left = current_transaction_size-current_index;
    a428:	490b      	ldr	r1, [pc, #44]	; (a458 <bhy_read_fifo+0xa4>)
    a42a:	8809      	ldrh	r1, [r1, #0]
    a42c:	1a8a      	subs	r2, r1, r2
    a42e:	b292      	uxth	r2, r2
    a430:	802a      	strh	r2, [r5, #0]
		*bytes_read=0;
		*bytes_left=0;
		return result;
	}

	return result;
    a432:	0018      	movs	r0, r3

		current_index += *bytes_read;

		*bytes_left = current_transaction_size-current_index;

		if (*bytes_left == 0) {
    a434:	2a00      	cmp	r2, #0
    a436:	d10a      	bne.n	a44e <bhy_read_fifo+0x9a>
			current_index = 0;
    a438:	4909      	ldr	r1, [pc, #36]	; (a460 <bhy_read_fifo+0xac>)
    a43a:	800a      	strh	r2, [r1, #0]
			current_transaction_size = 0;
    a43c:	4906      	ldr	r1, [pc, #24]	; (a458 <bhy_read_fifo+0xa4>)
    a43e:	800a      	strh	r2, [r1, #0]
    a440:	e005      	b.n	a44e <bhy_read_fifo+0x9a>
		}

	} else {
		*bytes_read=0;
    a442:	2300      	movs	r3, #0
    a444:	8033      	strh	r3, [r6, #0]
		*bytes_left=0;
    a446:	802b      	strh	r3, [r5, #0]
		return result;
    a448:	e001      	b.n	a44e <bhy_read_fifo+0x9a>
	BHY_RETURN_FUNCTION_TYPE result = BHY_SUCCESS;
	static u16 current_index = 0;
	static u16 current_transaction_size = 0;

	if (buffer_size <= 50)
		return BHY_OUT_OF_RANGE;
    a44a:	2002      	movs	r0, #2
    a44c:	4240      	negs	r0, r0
		*bytes_left=0;
		return result;
	}

	return result;
}
    a44e:	b002      	add	sp, #8
    a450:	bc04      	pop	{r2}
    a452:	4691      	mov	r9, r2
    a454:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a456:	46c0      	nop			; (mov r8, r8)
    a458:	20001932 	.word	0x20001932
    a45c:	00009e15 	.word	0x00009e15
    a460:	20001930 	.word	0x20001930
    a464:	0000f939 	.word	0x0000f939
    a468:	00009da9 	.word	0x00009da9

0000a46c <bhy_parse_next_fifo_packet>:

BHY_RETURN_FUNCTION_TYPE bhy_parse_next_fifo_packet
	(u8 **fifo_buffer, u16 *fifo_buffer_length,
	bhy_data_generic_t * fifo_data_output, bhy_data_type_t * fifo_data_type) {
    a46c:	b570      	push	{r4, r5, r6, lr}
    a46e:	0004      	movs	r4, r0
    a470:	000d      	movs	r5, r1
    a472:	001e      	movs	r6, r3

	if (*fifo_buffer_length == 0)
    a474:	880b      	ldrh	r3, [r1, #0]
		/* there are no more bytes in the fifo buffer to read */
		return BHY_SUCCESS;
    a476:	2000      	movs	r0, #0

BHY_RETURN_FUNCTION_TYPE bhy_parse_next_fifo_packet
	(u8 **fifo_buffer, u16 *fifo_buffer_length,
	bhy_data_generic_t * fifo_data_output, bhy_data_type_t * fifo_data_type) {

	if (*fifo_buffer_length == 0)
    a478:	2b00      	cmp	r3, #0
    a47a:	d100      	bne.n	a47e <bhy_parse_next_fifo_packet+0x12>
    a47c:	e169      	b.n	a752 <bhy_parse_next_fifo_packet+0x2e6>
		/* there are no more bytes in the fifo buffer to read */
		return BHY_SUCCESS;

	/* the first fifo byte should be a known virtual sensor ID */
	switch (**fifo_buffer) {
    a47e:	6821      	ldr	r1, [r4, #0]
    a480:	7808      	ldrb	r0, [r1, #0]
    a482:	28fe      	cmp	r0, #254	; 0xfe
    a484:	d900      	bls.n	a488 <bhy_parse_next_fifo_packet+0x1c>
    a486:	e147      	b.n	a718 <bhy_parse_next_fifo_packet+0x2ac>
    a488:	0081      	lsls	r1, r0, #2
    a48a:	48b2      	ldr	r0, [pc, #712]	; (a754 <bhy_parse_next_fifo_packet+0x2e8>)
    a48c:	5841      	ldr	r1, [r0, r1]
    a48e:	468f      	mov	pc, r1

		case VS_ID_PADDING:
			*fifo_data_type = BHY_DATA_TYPE_PADDING;
    a490:	2300      	movs	r3, #0
    a492:	7033      	strb	r3, [r6, #0]

			fifo_data_output->data_padding.sensor_id = **fifo_buffer;
    a494:	6823      	ldr	r3, [r4, #0]
    a496:	781b      	ldrb	r3, [r3, #0]
    a498:	7013      	strb	r3, [r2, #0]

			break;
    a49a:	e100      	b.n	a69e <bhy_parse_next_fifo_packet+0x232>
		case VS_ID_ROTATION_VECTOR_WAKEUP:
		case VS_ID_GAME_ROTATION_VECTOR:
		case VS_ID_GAME_ROTATION_VECTOR_WAKEUP:
		case VS_ID_GEOMAGNETIC_ROTATION_VECTOR:
		case VS_ID_GEOMAGNETIC_ROTATION_VECTOR_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_QUATERNION])
    a49c:	2b0a      	cmp	r3, #10
    a49e:	d800      	bhi.n	a4a2 <bhy_parse_next_fifo_packet+0x36>
    a4a0:	e13d      	b.n	a71e <bhy_parse_next_fifo_packet+0x2b2>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_QUATERNION;
    a4a2:	2301      	movs	r3, #1
    a4a4:	7033      	strb	r3, [r6, #0]

			fifo_data_output->data_quaternion.sensor_id = **fifo_buffer;
    a4a6:	6823      	ldr	r3, [r4, #0]
    a4a8:	781b      	ldrb	r3, [r3, #0]
    a4aa:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_quaternion.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
    a4ac:	6821      	ldr	r1, [r4, #0]
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_QUATERNION;

			fifo_data_output->data_quaternion.sensor_id = **fifo_buffer;
			fifo_data_output->data_quaternion.x =
    a4ae:	788b      	ldrb	r3, [r1, #2]
    a4b0:	021b      	lsls	r3, r3, #8
    a4b2:	7849      	ldrb	r1, [r1, #1]
    a4b4:	430b      	orrs	r3, r1
    a4b6:	8053      	strh	r3, [r2, #2]
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_quaternion.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
    a4b8:	6821      	ldr	r1, [r4, #0]
			*fifo_data_type = BHY_DATA_TYPE_QUATERNION;

			fifo_data_output->data_quaternion.sensor_id = **fifo_buffer;
			fifo_data_output->data_quaternion.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_quaternion.y =
    a4ba:	790b      	ldrb	r3, [r1, #4]
    a4bc:	021b      	lsls	r3, r3, #8
    a4be:	78c9      	ldrb	r1, [r1, #3]
    a4c0:	430b      	orrs	r3, r1
    a4c2:	8093      	strh	r3, [r2, #4]
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_quaternion.z =
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
    a4c4:	6821      	ldr	r1, [r4, #0]
			fifo_data_output->data_quaternion.sensor_id = **fifo_buffer;
			fifo_data_output->data_quaternion.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_quaternion.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_quaternion.z =
    a4c6:	798b      	ldrb	r3, [r1, #6]
    a4c8:	021b      	lsls	r3, r3, #8
    a4ca:	7949      	ldrb	r1, [r1, #5]
    a4cc:	430b      	orrs	r3, r1
    a4ce:	80d3      	strh	r3, [r2, #6]
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_quaternion.w =
			(s16)( ((u16)*(*fifo_buffer+7)) | ((u16)*(*fifo_buffer+8) << 8));
    a4d0:	6821      	ldr	r1, [r4, #0]
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_quaternion.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_quaternion.z =
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_quaternion.w =
    a4d2:	7a0b      	ldrb	r3, [r1, #8]
    a4d4:	021b      	lsls	r3, r3, #8
    a4d6:	79c9      	ldrb	r1, [r1, #7]
    a4d8:	430b      	orrs	r3, r1
    a4da:	8113      	strh	r3, [r2, #8]
			(s16)( ((u16)*(*fifo_buffer+7)) | ((u16)*(*fifo_buffer+8) << 8));
			fifo_data_output->data_quaternion.estimated_accuracy =
			(s16)( ((u16)*(*fifo_buffer+9)) | ((u16)*(*fifo_buffer+10) << 8));
    a4dc:	6821      	ldr	r1, [r4, #0]
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_quaternion.z =
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_quaternion.w =
			(s16)( ((u16)*(*fifo_buffer+7)) | ((u16)*(*fifo_buffer+8) << 8));
			fifo_data_output->data_quaternion.estimated_accuracy =
    a4de:	7a8b      	ldrb	r3, [r1, #10]
    a4e0:	021b      	lsls	r3, r3, #8
    a4e2:	7a49      	ldrb	r1, [r1, #9]
    a4e4:	430b      	orrs	r3, r1
    a4e6:	8153      	strh	r3, [r2, #10]
			(s16)( ((u16)*(*fifo_buffer+9)) | ((u16)*(*fifo_buffer+10) << 8));

			break;
    a4e8:	e0d9      	b.n	a69e <bhy_parse_next_fifo_packet+0x232>
		case VS_ID_GYROSCOPE_WAKEUP:
		case VS_ID_GRAVITY:
		case VS_ID_GRAVITY_WAKEUP:
		case VS_ID_LINEAR_ACCELERATION:
		case VS_ID_LINEAR_ACCELERATION_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_VECTOR])
    a4ea:	2b07      	cmp	r3, #7
    a4ec:	d800      	bhi.n	a4f0 <bhy_parse_next_fifo_packet+0x84>
    a4ee:	e119      	b.n	a724 <bhy_parse_next_fifo_packet+0x2b8>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_VECTOR;
    a4f0:	2302      	movs	r3, #2
    a4f2:	7033      	strb	r3, [r6, #0]

			fifo_data_output->data_vector.sensor_id = **fifo_buffer;
    a4f4:	6823      	ldr	r3, [r4, #0]
    a4f6:	781b      	ldrb	r3, [r3, #0]
    a4f8:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_vector.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
    a4fa:	6821      	ldr	r1, [r4, #0]
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_VECTOR;

			fifo_data_output->data_vector.sensor_id = **fifo_buffer;
			fifo_data_output->data_vector.x =
    a4fc:	788b      	ldrb	r3, [r1, #2]
    a4fe:	021b      	lsls	r3, r3, #8
    a500:	7849      	ldrb	r1, [r1, #1]
    a502:	430b      	orrs	r3, r1
    a504:	8053      	strh	r3, [r2, #2]
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_vector.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
    a506:	6821      	ldr	r1, [r4, #0]
			*fifo_data_type = BHY_DATA_TYPE_VECTOR;

			fifo_data_output->data_vector.sensor_id = **fifo_buffer;
			fifo_data_output->data_vector.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_vector.y =
    a508:	790b      	ldrb	r3, [r1, #4]
    a50a:	021b      	lsls	r3, r3, #8
    a50c:	78c9      	ldrb	r1, [r1, #3]
    a50e:	430b      	orrs	r3, r1
    a510:	8093      	strh	r3, [r2, #4]
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_vector.z =
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
    a512:	6821      	ldr	r1, [r4, #0]
			fifo_data_output->data_vector.sensor_id = **fifo_buffer;
			fifo_data_output->data_vector.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_vector.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_vector.z =
    a514:	798b      	ldrb	r3, [r1, #6]
    a516:	021b      	lsls	r3, r3, #8
    a518:	7949      	ldrb	r1, [r1, #5]
    a51a:	430b      	orrs	r3, r1
    a51c:	80d3      	strh	r3, [r2, #6]
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_vector.status = *(*fifo_buffer+7);
    a51e:	6823      	ldr	r3, [r4, #0]
    a520:	79db      	ldrb	r3, [r3, #7]
    a522:	7213      	strb	r3, [r2, #8]

			break;
    a524:	e0bb      	b.n	a69e <bhy_parse_next_fifo_packet+0x232>

		case VS_ID_HEART_RATE:
		case VS_ID_HEART_RATE_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U8])
    a526:	2b01      	cmp	r3, #1
    a528:	d800      	bhi.n	a52c <bhy_parse_next_fifo_packet+0xc0>
    a52a:	e0fe      	b.n	a72a <bhy_parse_next_fifo_packet+0x2be>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_SCALAR_U8;
    a52c:	2303      	movs	r3, #3
    a52e:	7033      	strb	r3, [r6, #0]
			fifo_data_output->data_scalar_u8.sensor_id = **fifo_buffer;
    a530:	6823      	ldr	r3, [r4, #0]
    a532:	781b      	ldrb	r3, [r3, #0]
    a534:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_scalar_u8.data = *(*fifo_buffer+1);
    a536:	6823      	ldr	r3, [r4, #0]
    a538:	785b      	ldrb	r3, [r3, #1]
    a53a:	7053      	strb	r3, [r2, #1]

			break;
    a53c:	e0af      	b.n	a69e <bhy_parse_next_fifo_packet+0x232>
		case VS_ID_ACTIVITY_WAKEUP:
		case VS_ID_TIMESTAMP_LSW:
		case VS_ID_TIMESTAMP_LSW_WAKEUP:
		case VS_ID_TIMESTAMP_MSW:
		case VS_ID_TIMESTAMP_MSW_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U16])
    a53e:	2b02      	cmp	r3, #2
    a540:	d800      	bhi.n	a544 <bhy_parse_next_fifo_packet+0xd8>
    a542:	e0f5      	b.n	a730 <bhy_parse_next_fifo_packet+0x2c4>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_SCALAR_U16;
    a544:	2304      	movs	r3, #4
    a546:	7033      	strb	r3, [r6, #0]
			fifo_data_output->data_scalar_u16.sensor_id = **fifo_buffer;
    a548:	6823      	ldr	r3, [r4, #0]
    a54a:	781b      	ldrb	r3, [r3, #0]
    a54c:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_scalar_u16.data =
			(u16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
    a54e:	6821      	ldr	r1, [r4, #0]
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U16])
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_SCALAR_U16;
			fifo_data_output->data_scalar_u16.sensor_id = **fifo_buffer;
			fifo_data_output->data_scalar_u16.data =
    a550:	788b      	ldrb	r3, [r1, #2]
    a552:	021b      	lsls	r3, r3, #8
    a554:	7849      	ldrb	r1, [r1, #1]
    a556:	430b      	orrs	r3, r1
    a558:	8053      	strh	r3, [r2, #2]
			(u16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));

			break;
    a55a:	e0a0      	b.n	a69e <bhy_parse_next_fifo_packet+0x232>

		case VS_ID_TEMPERATURE:
		case VS_ID_TEMPERATURE_WAKEUP:
		case VS_ID_AMBIENT_TEMPERATURE:
		case VS_ID_AMBIENT_TEMPERATURE_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_S16])
    a55c:	2b02      	cmp	r3, #2
    a55e:	d800      	bhi.n	a562 <bhy_parse_next_fifo_packet+0xf6>
    a560:	e0e9      	b.n	a736 <bhy_parse_next_fifo_packet+0x2ca>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_SCALAR_S16;
    a562:	2305      	movs	r3, #5
    a564:	7033      	strb	r3, [r6, #0]
			fifo_data_output->data_scalar_s16.sensor_id = **fifo_buffer;
    a566:	6823      	ldr	r3, [r4, #0]
    a568:	781b      	ldrb	r3, [r3, #0]
    a56a:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_scalar_s16.data =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
    a56c:	6821      	ldr	r1, [r4, #0]
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_S16])
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_SCALAR_S16;
			fifo_data_output->data_scalar_s16.sensor_id = **fifo_buffer;
			fifo_data_output->data_scalar_s16.data =
    a56e:	788b      	ldrb	r3, [r1, #2]
    a570:	021b      	lsls	r3, r3, #8
    a572:	7849      	ldrb	r1, [r1, #1]
    a574:	430b      	orrs	r3, r1
    a576:	8053      	strh	r3, [r2, #2]
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));

			break;
    a578:	e091      	b.n	a69e <bhy_parse_next_fifo_packet+0x232>

		case VS_ID_BAROMETER:
		case VS_ID_BAROMETER_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U24])
    a57a:	2b03      	cmp	r3, #3
    a57c:	d800      	bhi.n	a580 <bhy_parse_next_fifo_packet+0x114>
    a57e:	e0dd      	b.n	a73c <bhy_parse_next_fifo_packet+0x2d0>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_SCALAR_U24;
    a580:	2306      	movs	r3, #6
    a582:	7033      	strb	r3, [r6, #0]
			fifo_data_output->data_scalar_u24.sensor_id = **fifo_buffer;
    a584:	6823      	ldr	r3, [r4, #0]
    a586:	781b      	ldrb	r3, [r3, #0]
    a588:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_scalar_u24.data =
			(u32)( ((u32)*(*fifo_buffer+1)) | ((u32)*(*fifo_buffer+2) << 8) |
    a58a:	6821      	ldr	r1, [r4, #0]
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U24])
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_SCALAR_U24;
			fifo_data_output->data_scalar_u24.sensor_id = **fifo_buffer;
			fifo_data_output->data_scalar_u24.data =
    a58c:	788b      	ldrb	r3, [r1, #2]
    a58e:	0218      	lsls	r0, r3, #8
    a590:	78cb      	ldrb	r3, [r1, #3]
    a592:	041b      	lsls	r3, r3, #16
    a594:	4303      	orrs	r3, r0
    a596:	7849      	ldrb	r1, [r1, #1]
    a598:	430b      	orrs	r3, r1
    a59a:	6053      	str	r3, [r2, #4]
			(u32)( ((u32)*(*fifo_buffer+1)) | ((u32)*(*fifo_buffer+2) << 8) |
					((u32)*(*fifo_buffer+3) << 16));

			break;
    a59c:	e07f      	b.n	a69e <bhy_parse_next_fifo_packet+0x232>
		case VS_ID_WAKE_GESTURE_WAKEUP:
		case VS_ID_GLANCE_GESTURE:
		case VS_ID_GLANCE_GESTURE_WAKEUP:
		case VS_ID_PICKUP_GESTURE:
		case VS_ID_PICKUP_GESTURE_WAKEUP:
			*fifo_data_type = BHY_DATA_TYPE_SENSOR_EVENT;
    a59e:	2307      	movs	r3, #7
    a5a0:	7033      	strb	r3, [r6, #0]

			fifo_data_output->data_sensor_event.sensor_id = **fifo_buffer;
    a5a2:	6823      	ldr	r3, [r4, #0]
    a5a4:	781b      	ldrb	r3, [r3, #0]
    a5a6:	7013      	strb	r3, [r2, #0]

			break;
    a5a8:	e079      	b.n	a69e <bhy_parse_next_fifo_packet+0x232>
		case VS_ID_UNCALIBRATED_MAGNETOMETER:
		case VS_ID_UNCALIBRATED_MAGNETOMETER_WAKEUP:
		case VS_ID_UNCALIBRATED_GYROSCOPE:
		case VS_ID_UNCALIBRATED_GYROSCOPE_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_UNCALIB_VECTOR])
    a5aa:	2b0d      	cmp	r3, #13
    a5ac:	d800      	bhi.n	a5b0 <bhy_parse_next_fifo_packet+0x144>
    a5ae:	e0c8      	b.n	a742 <bhy_parse_next_fifo_packet+0x2d6>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_UNCALIB_VECTOR;
    a5b0:	2308      	movs	r3, #8
    a5b2:	7033      	strb	r3, [r6, #0]
			fifo_data_output->data_uncalib_vector.sensor_id = **fifo_buffer;
    a5b4:	6823      	ldr	r3, [r4, #0]
    a5b6:	781b      	ldrb	r3, [r3, #0]
    a5b8:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_uncalib_vector.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
    a5ba:	6821      	ldr	r1, [r4, #0]
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_UNCALIB_VECTOR])
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_UNCALIB_VECTOR;
			fifo_data_output->data_uncalib_vector.sensor_id = **fifo_buffer;
			fifo_data_output->data_uncalib_vector.x =
    a5bc:	788b      	ldrb	r3, [r1, #2]
    a5be:	021b      	lsls	r3, r3, #8
    a5c0:	7849      	ldrb	r1, [r1, #1]
    a5c2:	430b      	orrs	r3, r1
    a5c4:	8053      	strh	r3, [r2, #2]
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_uncalib_vector.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
    a5c6:	6821      	ldr	r1, [r4, #0]

			*fifo_data_type = BHY_DATA_TYPE_UNCALIB_VECTOR;
			fifo_data_output->data_uncalib_vector.sensor_id = **fifo_buffer;
			fifo_data_output->data_uncalib_vector.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_uncalib_vector.y =
    a5c8:	790b      	ldrb	r3, [r1, #4]
    a5ca:	021b      	lsls	r3, r3, #8
    a5cc:	78c9      	ldrb	r1, [r1, #3]
    a5ce:	430b      	orrs	r3, r1
    a5d0:	8093      	strh	r3, [r2, #4]
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_uncalib_vector.z =
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
    a5d2:	6821      	ldr	r1, [r4, #0]
			fifo_data_output->data_uncalib_vector.sensor_id = **fifo_buffer;
			fifo_data_output->data_uncalib_vector.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_uncalib_vector.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_uncalib_vector.z =
    a5d4:	798b      	ldrb	r3, [r1, #6]
    a5d6:	021b      	lsls	r3, r3, #8
    a5d8:	7949      	ldrb	r1, [r1, #5]
    a5da:	430b      	orrs	r3, r1
    a5dc:	80d3      	strh	r3, [r2, #6]
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_uncalib_vector.x_bias =
			(s16)( ((u16)*(*fifo_buffer+7)) | ((u16)*(*fifo_buffer+8) << 8));
    a5de:	6821      	ldr	r1, [r4, #0]
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_uncalib_vector.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_uncalib_vector.z =
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_uncalib_vector.x_bias =
    a5e0:	7a0b      	ldrb	r3, [r1, #8]
    a5e2:	021b      	lsls	r3, r3, #8
    a5e4:	79c9      	ldrb	r1, [r1, #7]
    a5e6:	430b      	orrs	r3, r1
    a5e8:	8113      	strh	r3, [r2, #8]
			(s16)( ((u16)*(*fifo_buffer+7)) | ((u16)*(*fifo_buffer+8) << 8));
			fifo_data_output->data_uncalib_vector.y_bias =
			(s16)( ((u16)*(*fifo_buffer+9)) | ((u16)*(*fifo_buffer+10) << 8));
    a5ea:	6821      	ldr	r1, [r4, #0]
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_uncalib_vector.z =
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_uncalib_vector.x_bias =
			(s16)( ((u16)*(*fifo_buffer+7)) | ((u16)*(*fifo_buffer+8) << 8));
			fifo_data_output->data_uncalib_vector.y_bias =
    a5ec:	7a8b      	ldrb	r3, [r1, #10]
    a5ee:	021b      	lsls	r3, r3, #8
    a5f0:	7a49      	ldrb	r1, [r1, #9]
    a5f2:	430b      	orrs	r3, r1
    a5f4:	8153      	strh	r3, [r2, #10]
			(s16)( ((u16)*(*fifo_buffer+9)) | ((u16)*(*fifo_buffer+10) << 8));
			fifo_data_output->data_uncalib_vector.z_bias =
			(s16)( ((u16)*(*fifo_buffer+11)) | ((u16)*(*fifo_buffer+12) << 8));
    a5f6:	6821      	ldr	r1, [r4, #0]
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_uncalib_vector.x_bias =
			(s16)( ((u16)*(*fifo_buffer+7)) | ((u16)*(*fifo_buffer+8) << 8));
			fifo_data_output->data_uncalib_vector.y_bias =
			(s16)( ((u16)*(*fifo_buffer+9)) | ((u16)*(*fifo_buffer+10) << 8));
			fifo_data_output->data_uncalib_vector.z_bias =
    a5f8:	7b0b      	ldrb	r3, [r1, #12]
    a5fa:	021b      	lsls	r3, r3, #8
    a5fc:	7ac9      	ldrb	r1, [r1, #11]
    a5fe:	430b      	orrs	r3, r1
    a600:	8193      	strh	r3, [r2, #12]
			(s16)( ((u16)*(*fifo_buffer+11)) | ((u16)*(*fifo_buffer+12) << 8));
			fifo_data_output->data_uncalib_vector.status = *(*fifo_buffer+13);
    a602:	6823      	ldr	r3, [r4, #0]
    a604:	7b5b      	ldrb	r3, [r3, #13]
    a606:	7393      	strb	r3, [r2, #14]
			break;
    a608:	e049      	b.n	a69e <bhy_parse_next_fifo_packet+0x232>

		case VS_ID_META_EVENT:
		case VS_ID_META_EVENT_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_META_EVENT])
    a60a:	2b03      	cmp	r3, #3
    a60c:	d800      	bhi.n	a610 <bhy_parse_next_fifo_packet+0x1a4>
    a60e:	e09b      	b.n	a748 <bhy_parse_next_fifo_packet+0x2dc>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_META_EVENT;
    a610:	2309      	movs	r3, #9
    a612:	7033      	strb	r3, [r6, #0]
			fifo_data_output->data_meta_event.meta_event_id =	**fifo_buffer;
    a614:	6823      	ldr	r3, [r4, #0]
    a616:	781b      	ldrb	r3, [r3, #0]
    a618:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_meta_event.event_number =	(bhy_meta_event_type_t)(*(*fifo_buffer+1));
    a61a:	6823      	ldr	r3, [r4, #0]
    a61c:	785b      	ldrb	r3, [r3, #1]
    a61e:	7053      	strb	r3, [r2, #1]
			fifo_data_output->data_meta_event.sensor_type =		*(*fifo_buffer+2);
    a620:	6823      	ldr	r3, [r4, #0]
    a622:	789b      	ldrb	r3, [r3, #2]
    a624:	7093      	strb	r3, [r2, #2]
			fifo_data_output->data_meta_event.event_specific =	*(*fifo_buffer+3);
    a626:	6823      	ldr	r3, [r4, #0]
    a628:	78db      	ldrb	r3, [r3, #3]
    a62a:	70d3      	strb	r3, [r2, #3]

			break;
    a62c:	e037      	b.n	a69e <bhy_parse_next_fifo_packet+0x232>
#endif

		case VS_ID_BSX_C:
		case VS_ID_BSX_B:
		case VS_ID_BSX_A:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_BSX])
    a62e:	2b10      	cmp	r3, #16
    a630:	d800      	bhi.n	a634 <bhy_parse_next_fifo_packet+0x1c8>
    a632:	e08c      	b.n	a74e <bhy_parse_next_fifo_packet+0x2e2>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_BSX;
    a634:	230a      	movs	r3, #10
    a636:	7033      	strb	r3, [r6, #0]
			fifo_data_output->data_bsx.sensor_id =	**fifo_buffer;
    a638:	6823      	ldr	r3, [r4, #0]
    a63a:	781b      	ldrb	r3, [r3, #0]
    a63c:	7013      	strb	r3, [r2, #0]

			fifo_data_output->data_bsx.x =
			(u32)( ((u32)*(*fifo_buffer+1)) | ((u32)*(*fifo_buffer+2) << 8) |
    a63e:	6821      	ldr	r1, [r4, #0]
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_BSX;
			fifo_data_output->data_bsx.sensor_id =	**fifo_buffer;

			fifo_data_output->data_bsx.x =
    a640:	788b      	ldrb	r3, [r1, #2]
    a642:	0218      	lsls	r0, r3, #8
    a644:	78cb      	ldrb	r3, [r1, #3]
    a646:	041b      	lsls	r3, r3, #16
    a648:	4303      	orrs	r3, r0
    a64a:	7848      	ldrb	r0, [r1, #1]
    a64c:	4303      	orrs	r3, r0
    a64e:	7909      	ldrb	r1, [r1, #4]
    a650:	0609      	lsls	r1, r1, #24
    a652:	430b      	orrs	r3, r1
    a654:	6053      	str	r3, [r2, #4]
			(u32)( ((u32)*(*fifo_buffer+1)) | ((u32)*(*fifo_buffer+2) << 8) |
					((u32)*(*fifo_buffer+3) << 16) | ((u32)*(*fifo_buffer+4) << 24));

			fifo_data_output->data_bsx.y =
			(u32)( ((u32)*(*fifo_buffer+5)) | ((u32)*(*fifo_buffer+6) << 8) |
    a656:	6821      	ldr	r1, [r4, #0]

			fifo_data_output->data_bsx.x =
			(u32)( ((u32)*(*fifo_buffer+1)) | ((u32)*(*fifo_buffer+2) << 8) |
					((u32)*(*fifo_buffer+3) << 16) | ((u32)*(*fifo_buffer+4) << 24));

			fifo_data_output->data_bsx.y =
    a658:	798b      	ldrb	r3, [r1, #6]
    a65a:	0218      	lsls	r0, r3, #8
    a65c:	79cb      	ldrb	r3, [r1, #7]
    a65e:	041b      	lsls	r3, r3, #16
    a660:	4303      	orrs	r3, r0
    a662:	7948      	ldrb	r0, [r1, #5]
    a664:	4303      	orrs	r3, r0
    a666:	7a09      	ldrb	r1, [r1, #8]
    a668:	0609      	lsls	r1, r1, #24
    a66a:	430b      	orrs	r3, r1
    a66c:	6093      	str	r3, [r2, #8]
			(u32)( ((u32)*(*fifo_buffer+5)) | ((u32)*(*fifo_buffer+6) << 8) |
					((u32)*(*fifo_buffer+7) << 16) | ((u32)*(*fifo_buffer+8) << 24));

			fifo_data_output->data_bsx.z =
			(u32)( ((u32)*(*fifo_buffer+9)) | ((u32)*(*fifo_buffer+10) << 8) |
    a66e:	6821      	ldr	r1, [r4, #0]

			fifo_data_output->data_bsx.y =
			(u32)( ((u32)*(*fifo_buffer+5)) | ((u32)*(*fifo_buffer+6) << 8) |
					((u32)*(*fifo_buffer+7) << 16) | ((u32)*(*fifo_buffer+8) << 24));

			fifo_data_output->data_bsx.z =
    a670:	7a8b      	ldrb	r3, [r1, #10]
    a672:	0218      	lsls	r0, r3, #8
    a674:	7acb      	ldrb	r3, [r1, #11]
    a676:	041b      	lsls	r3, r3, #16
    a678:	4303      	orrs	r3, r0
    a67a:	7a48      	ldrb	r0, [r1, #9]
    a67c:	4303      	orrs	r3, r0
    a67e:	7b09      	ldrb	r1, [r1, #12]
    a680:	0609      	lsls	r1, r1, #24
    a682:	430b      	orrs	r3, r1
    a684:	60d3      	str	r3, [r2, #12]
			(u32)( ((u32)*(*fifo_buffer+9)) | ((u32)*(*fifo_buffer+10) << 8) |
					((u32)*(*fifo_buffer+11) << 16) | ((u32)*(*fifo_buffer+12) << 24));

			fifo_data_output->data_bsx.timestamp =
			(u32)( ((u32)*(*fifo_buffer+13)) | ((u32)*(*fifo_buffer+14) << 8) |
    a686:	6821      	ldr	r1, [r4, #0]

			fifo_data_output->data_bsx.z =
			(u32)( ((u32)*(*fifo_buffer+9)) | ((u32)*(*fifo_buffer+10) << 8) |
					((u32)*(*fifo_buffer+11) << 16) | ((u32)*(*fifo_buffer+12) << 24));

			fifo_data_output->data_bsx.timestamp =
    a688:	7b8b      	ldrb	r3, [r1, #14]
    a68a:	0218      	lsls	r0, r3, #8
    a68c:	7bcb      	ldrb	r3, [r1, #15]
    a68e:	041b      	lsls	r3, r3, #16
    a690:	4303      	orrs	r3, r0
    a692:	7b48      	ldrb	r0, [r1, #13]
    a694:	4303      	orrs	r3, r0
    a696:	7c09      	ldrb	r1, [r1, #16]
    a698:	0609      	lsls	r1, r1, #24
    a69a:	430b      	orrs	r3, r1
    a69c:	6113      	str	r3, [r2, #16]




#if BHY_CALLBACK_MODE
	if( (**fifo_buffer) < 0x40 ) {
    a69e:	6823      	ldr	r3, [r4, #0]
    a6a0:	7819      	ldrb	r1, [r3, #0]
    a6a2:	293f      	cmp	r1, #63	; 0x3f
    a6a4:	d807      	bhi.n	a6b6 <bhy_parse_next_fifo_packet+0x24a>
		if (g_sensor_callback_list[(**fifo_buffer)] != 0) {
    a6a6:	008b      	lsls	r3, r1, #2
    a6a8:	482b      	ldr	r0, [pc, #172]	; (a758 <bhy_parse_next_fifo_packet+0x2ec>)
    a6aa:	581b      	ldr	r3, [r3, r0]
    a6ac:	2b00      	cmp	r3, #0
    a6ae:	d025      	beq.n	a6fc <bhy_parse_next_fifo_packet+0x290>
			g_sensor_callback_list[(**fifo_buffer)](fifo_data_output, (**fifo_buffer));
    a6b0:	0010      	movs	r0, r2
    a6b2:	4798      	blx	r3
    a6b4:	e022      	b.n	a6fc <bhy_parse_next_fifo_packet+0x290>
		}
	} else if ( (**fifo_buffer) == VS_ID_TIMESTAMP_LSW ||
    a6b6:	1d0b      	adds	r3, r1, #4
    a6b8:	b2db      	uxtb	r3, r3
    a6ba:	2b01      	cmp	r3, #1
    a6bc:	d806      	bhi.n	a6cc <bhy_parse_next_fifo_packet+0x260>
				(**fifo_buffer) == VS_ID_TIMESTAMP_MSW ) {
		if ( g_timestamp_callback_list[0] != 0 ) {
    a6be:	4b27      	ldr	r3, [pc, #156]	; (a75c <bhy_parse_next_fifo_packet+0x2f0>)
    a6c0:	681b      	ldr	r3, [r3, #0]
    a6c2:	2b00      	cmp	r3, #0
    a6c4:	d01a      	beq.n	a6fc <bhy_parse_next_fifo_packet+0x290>
			g_timestamp_callback_list[0](&fifo_data_output->data_scalar_u16);
    a6c6:	0010      	movs	r0, r2
    a6c8:	4798      	blx	r3
    a6ca:	e017      	b.n	a6fc <bhy_parse_next_fifo_packet+0x290>
		}
	} else if ( (**fifo_buffer) == VS_ID_TIMESTAMP_LSW_WAKEUP ||
    a6cc:	000b      	movs	r3, r1
    a6ce:	330a      	adds	r3, #10
    a6d0:	b2db      	uxtb	r3, r3
    a6d2:	2b01      	cmp	r3, #1
    a6d4:	d806      	bhi.n	a6e4 <bhy_parse_next_fifo_packet+0x278>
				(**fifo_buffer) == VS_ID_TIMESTAMP_MSW_WAKEUP ) {
		if ( g_timestamp_callback_list[1] != 0 ) {
    a6d6:	4b21      	ldr	r3, [pc, #132]	; (a75c <bhy_parse_next_fifo_packet+0x2f0>)
    a6d8:	685b      	ldr	r3, [r3, #4]
    a6da:	2b00      	cmp	r3, #0
    a6dc:	d00e      	beq.n	a6fc <bhy_parse_next_fifo_packet+0x290>
			g_timestamp_callback_list[1](&fifo_data_output->data_scalar_u16);
    a6de:	0010      	movs	r0, r2
    a6e0:	4798      	blx	r3
    a6e2:	e00b      	b.n	a6fc <bhy_parse_next_fifo_packet+0x290>
		}
	} else if ( (**fifo_buffer) == VS_ID_META_EVENT ||
    a6e4:	29fe      	cmp	r1, #254	; 0xfe
    a6e6:	d001      	beq.n	a6ec <bhy_parse_next_fifo_packet+0x280>
    a6e8:	29f8      	cmp	r1, #248	; 0xf8
    a6ea:	d107      	bne.n	a6fc <bhy_parse_next_fifo_packet+0x290>
				(**fifo_buffer) == VS_ID_META_EVENT_WAKEUP ) {
		if ( g_meta_event_callback_list[fifo_data_output->data_meta_event.event_number] != 0) {
    a6ec:	7851      	ldrb	r1, [r2, #1]
    a6ee:	0088      	lsls	r0, r1, #2
    a6f0:	4b1b      	ldr	r3, [pc, #108]	; (a760 <bhy_parse_next_fifo_packet+0x2f4>)
    a6f2:	58c3      	ldr	r3, [r0, r3]
    a6f4:	2b00      	cmp	r3, #0
    a6f6:	d001      	beq.n	a6fc <bhy_parse_next_fifo_packet+0x290>
			g_meta_event_callback_list[fifo_data_output->data_meta_event.event_number](&fifo_data_output->data_meta_event, fifo_data_output->data_meta_event.event_number);
    a6f8:	0010      	movs	r0, r2
    a6fa:	4798      	blx	r3
		}
	}

#endif

	(*fifo_buffer) += _fifoSizes[*fifo_data_type];
    a6fc:	4a19      	ldr	r2, [pc, #100]	; (a764 <bhy_parse_next_fifo_packet+0x2f8>)
    a6fe:	7833      	ldrb	r3, [r6, #0]
    a700:	5cd3      	ldrb	r3, [r2, r3]
    a702:	6821      	ldr	r1, [r4, #0]
    a704:	468c      	mov	ip, r1
    a706:	4463      	add	r3, ip
    a708:	6023      	str	r3, [r4, #0]
	*fifo_buffer_length -= _fifoSizes[*fifo_data_type];
    a70a:	7833      	ldrb	r3, [r6, #0]
    a70c:	5cd2      	ldrb	r2, [r2, r3]
    a70e:	882b      	ldrh	r3, [r5, #0]
    a710:	1a9b      	subs	r3, r3, r2
    a712:	802b      	strh	r3, [r5, #0]

	return BHY_SUCCESS;
    a714:	2000      	movs	r0, #0
    a716:	e01c      	b.n	a752 <bhy_parse_next_fifo_packet+0x2e6>

		/* the VS sensor ID is unknown. Either the sync has been lost or the */
		/* ram patch implements a new sensor ID that this driver doesn't yet */
		/* support															 */
		default:
		return BHY_OUT_OF_RANGE;
    a718:	2002      	movs	r0, #2
    a71a:	4240      	negs	r0, r0
    a71c:	e019      	b.n	a752 <bhy_parse_next_fifo_packet+0x2e6>
		case VS_ID_GAME_ROTATION_VECTOR:
		case VS_ID_GAME_ROTATION_VECTOR_WAKEUP:
		case VS_ID_GEOMAGNETIC_ROTATION_VECTOR:
		case VS_ID_GEOMAGNETIC_ROTATION_VECTOR_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_QUATERNION])
				return BHY_OUT_OF_RANGE;
    a71e:	2002      	movs	r0, #2
    a720:	4240      	negs	r0, r0
    a722:	e016      	b.n	a752 <bhy_parse_next_fifo_packet+0x2e6>
		case VS_ID_GRAVITY:
		case VS_ID_GRAVITY_WAKEUP:
		case VS_ID_LINEAR_ACCELERATION:
		case VS_ID_LINEAR_ACCELERATION_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_VECTOR])
				return BHY_OUT_OF_RANGE;
    a724:	2002      	movs	r0, #2
    a726:	4240      	negs	r0, r0
    a728:	e013      	b.n	a752 <bhy_parse_next_fifo_packet+0x2e6>
			break;

		case VS_ID_HEART_RATE:
		case VS_ID_HEART_RATE_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U8])
				return BHY_OUT_OF_RANGE;
    a72a:	2002      	movs	r0, #2
    a72c:	4240      	negs	r0, r0
    a72e:	e010      	b.n	a752 <bhy_parse_next_fifo_packet+0x2e6>
		case VS_ID_TIMESTAMP_LSW:
		case VS_ID_TIMESTAMP_LSW_WAKEUP:
		case VS_ID_TIMESTAMP_MSW:
		case VS_ID_TIMESTAMP_MSW_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U16])
				return BHY_OUT_OF_RANGE;
    a730:	2002      	movs	r0, #2
    a732:	4240      	negs	r0, r0
    a734:	e00d      	b.n	a752 <bhy_parse_next_fifo_packet+0x2e6>
		case VS_ID_TEMPERATURE:
		case VS_ID_TEMPERATURE_WAKEUP:
		case VS_ID_AMBIENT_TEMPERATURE:
		case VS_ID_AMBIENT_TEMPERATURE_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_S16])
				return BHY_OUT_OF_RANGE;
    a736:	2002      	movs	r0, #2
    a738:	4240      	negs	r0, r0
    a73a:	e00a      	b.n	a752 <bhy_parse_next_fifo_packet+0x2e6>
			break;

		case VS_ID_BAROMETER:
		case VS_ID_BAROMETER_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U24])
				return BHY_OUT_OF_RANGE;
    a73c:	2002      	movs	r0, #2
    a73e:	4240      	negs	r0, r0
    a740:	e007      	b.n	a752 <bhy_parse_next_fifo_packet+0x2e6>
		case VS_ID_UNCALIBRATED_MAGNETOMETER:
		case VS_ID_UNCALIBRATED_MAGNETOMETER_WAKEUP:
		case VS_ID_UNCALIBRATED_GYROSCOPE:
		case VS_ID_UNCALIBRATED_GYROSCOPE_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_UNCALIB_VECTOR])
				return BHY_OUT_OF_RANGE;
    a742:	2002      	movs	r0, #2
    a744:	4240      	negs	r0, r0
    a746:	e004      	b.n	a752 <bhy_parse_next_fifo_packet+0x2e6>
			break;

		case VS_ID_META_EVENT:
		case VS_ID_META_EVENT_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_META_EVENT])
				return BHY_OUT_OF_RANGE;
    a748:	2002      	movs	r0, #2
    a74a:	4240      	negs	r0, r0
    a74c:	e001      	b.n	a752 <bhy_parse_next_fifo_packet+0x2e6>

		case VS_ID_BSX_C:
		case VS_ID_BSX_B:
		case VS_ID_BSX_A:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_BSX])
				return BHY_OUT_OF_RANGE;
    a74e:	2002      	movs	r0, #2
    a750:	4240      	negs	r0, r0

	(*fifo_buffer) += _fifoSizes[*fifo_data_type];
	*fifo_buffer_length -= _fifoSizes[*fifo_data_type];

	return BHY_SUCCESS;
};
    a752:	bd70      	pop	{r4, r5, r6, pc}
    a754:	0001b8f4 	.word	0x0001b8f4
    a758:	2000182c 	.word	0x2000182c
    a75c:	20001928 	.word	0x20001928
    a760:	200017e8 	.word	0x200017e8
    a764:	0001bcf0 	.word	0x0001bcf0

0000a768 <bhy_install_sensor_callback>:
#endif

#if BHY_CALLBACK_MODE

BHY_RETURN_FUNCTION_TYPE bhy_install_sensor_callback ( bhy_virtual_sensor_t sensor_id, u8 wakeup_status, void (*sensor_callback)(bhy_data_generic_t *, bhy_virtual_sensor_t) ){
	if (sensor_id > 0x3F) {
    a768:	283f      	cmp	r0, #63	; 0x3f
    a76a:	d80c      	bhi.n	a786 <bhy_install_sensor_callback+0x1e>
		/* Invalid sensor ID */
		return BHY_OUT_OF_RANGE;
	}
	sensor_id = (sensor_id&0x1F) + wakeup_status;
    a76c:	231f      	movs	r3, #31
    a76e:	4018      	ands	r0, r3
	if (g_sensor_callback_list[sensor_id] != 0) {
    a770:	1841      	adds	r1, r0, r1
    a772:	b2c9      	uxtb	r1, r1
    a774:	0088      	lsls	r0, r1, #2
    a776:	4b07      	ldr	r3, [pc, #28]	; (a794 <bhy_install_sensor_callback+0x2c>)
    a778:	58c3      	ldr	r3, [r0, r3]
    a77a:	2b00      	cmp	r3, #0
    a77c:	d106      	bne.n	a78c <bhy_install_sensor_callback+0x24>
		/* There is already a callback installed */
		return BHY_OUT_OF_RANGE;
	} else {
		g_sensor_callback_list[sensor_id] = sensor_callback;
    a77e:	4b05      	ldr	r3, [pc, #20]	; (a794 <bhy_install_sensor_callback+0x2c>)
    a780:	50c2      	str	r2, [r0, r3]
		return BHY_SUCCESS;
    a782:	2000      	movs	r0, #0
    a784:	e004      	b.n	a790 <bhy_install_sensor_callback+0x28>
#if BHY_CALLBACK_MODE

BHY_RETURN_FUNCTION_TYPE bhy_install_sensor_callback ( bhy_virtual_sensor_t sensor_id, u8 wakeup_status, void (*sensor_callback)(bhy_data_generic_t *, bhy_virtual_sensor_t) ){
	if (sensor_id > 0x3F) {
		/* Invalid sensor ID */
		return BHY_OUT_OF_RANGE;
    a786:	2002      	movs	r0, #2
    a788:	4240      	negs	r0, r0
    a78a:	e001      	b.n	a790 <bhy_install_sensor_callback+0x28>
	}
	sensor_id = (sensor_id&0x1F) + wakeup_status;
	if (g_sensor_callback_list[sensor_id] != 0) {
		/* There is already a callback installed */
		return BHY_OUT_OF_RANGE;
    a78c:	2002      	movs	r0, #2
    a78e:	4240      	negs	r0, r0
	} else {
		g_sensor_callback_list[sensor_id] = sensor_callback;
		return BHY_SUCCESS;
	}
}
    a790:	4770      	bx	lr
    a792:	46c0      	nop			; (mov r8, r8)
    a794:	2000182c 	.word	0x2000182c

0000a798 <_i2c_master_wait_for_sync>:
{
	/* Sanity check */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_hw = &(module->hw->I2CM);
    a798:	6801      	ldr	r1, [r0, #0]
		const struct i2c_master_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
    a79a:	2207      	movs	r2, #7
	SercomI2cm *const i2c_hw = &(module->hw->I2CM);

#if defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_1)
	return (i2c_hw->STATUS.reg & SERCOM_I2CM_STATUS_SYNCBUSY);
#elif defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_2)
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
    a79c:	69cb      	ldr	r3, [r1, #28]
		const struct i2c_master_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
    a79e:	421a      	tst	r2, r3
    a7a0:	d1fc      	bne.n	a79c <_i2c_master_wait_for_sync+0x4>
		/* Wait for I2C module to sync. */
	}
}
    a7a2:	4770      	bx	lr

0000a7a4 <configure_sensor_i2c>:

/*! \brief Configure I2C peripheral
 *
 */
void configure_sensor_i2c(void)
{
    a7a4:	b530      	push	{r4, r5, lr}
    a7a6:	b08f      	sub	sp, #60	; 0x3c
static inline void i2c_master_get_config_defaults(
		struct i2c_master_config *const config)
{
	/*Sanity check argument */
	Assert(config);
	config->baud_rate        = I2C_MASTER_BAUD_RATE_100KHZ;
    a7a8:	ab01      	add	r3, sp, #4
    a7aa:	2264      	movs	r2, #100	; 0x64
    a7ac:	9201      	str	r2, [sp, #4]
#ifdef FEATURE_I2C_FAST_MODE_PLUS_AND_HIGH_SPEED
	config->baud_rate_high_speed = I2C_MASTER_BAUD_RATE_3400KHZ;
    a7ae:	4a22      	ldr	r2, [pc, #136]	; (a838 <configure_sensor_i2c+0x94>)
    a7b0:	9202      	str	r2, [sp, #8]
	config->transfer_speed       = I2C_MASTER_SPEED_STANDARD_AND_FAST;
    a7b2:	2200      	movs	r2, #0
    a7b4:	9203      	str	r2, [sp, #12]
#endif
	config->generator_source = GCLK_GENERATOR_0;
    a7b6:	731a      	strb	r2, [r3, #12]
	config->run_in_standby   = false;
    a7b8:	761a      	strb	r2, [r3, #24]
	config->start_hold_time  = I2C_MASTER_START_HOLD_TIME_300NS_600NS;
    a7ba:	2180      	movs	r1, #128	; 0x80
    a7bc:	0389      	lsls	r1, r1, #14
    a7be:	9105      	str	r1, [sp, #20]
	config->buffer_timeout   = 65535;
    a7c0:	2101      	movs	r1, #1
    a7c2:	4249      	negs	r1, r1
    a7c4:	82d9      	strh	r1, [r3, #22]
	config->unknown_bus_state_timeout = 65535;
    a7c6:	8299      	strh	r1, [r3, #20]
	config->pinmux_pad0      = PINMUX_DEFAULT;
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->scl_low_timeout  = false;
    a7c8:	3125      	adds	r1, #37	; 0x25
    a7ca:	545a      	strb	r2, [r3, r1]
	config->inactive_timeout = I2C_MASTER_INACTIVE_TIMEOUT_DISABLED;
    a7cc:	920b      	str	r2, [sp, #44]	; 0x2c
#ifdef FEATURE_I2C_SCL_STRETCH_MODE
	config->scl_stretch_only_after_ack_bit = false;
    a7ce:	3108      	adds	r1, #8
    a7d0:	545a      	strb	r2, [r3, r1]
#endif
#ifdef FEATURE_I2C_SCL_EXTEND_TIMEOUT
	config->slave_scl_low_extend_timeout   = false;
    a7d2:	3101      	adds	r1, #1
    a7d4:	545a      	strb	r2, [r3, r1]
	config->master_scl_low_extend_timeout  = false;
    a7d6:	3101      	adds	r1, #1
    a7d8:	545a      	strb	r2, [r3, r1]
#endif
	/* The typical value is 215ns */
	config->sda_scl_rise_time_ns = 215;
    a7da:	32d7      	adds	r2, #215	; 0xd7
    a7dc:	861a      	strh	r2, [r3, #48]	; 0x30
	/* Initialize config structure and software module */

	struct i2c_master_config config_i2c_master;
	i2c_master_get_config_defaults(&config_i2c_master);
	
	config_i2c_master.pinmux_pad0 = SENSOR_I2C_PINMUX_PAD0;
    a7de:	4a17      	ldr	r2, [pc, #92]	; (a83c <configure_sensor_i2c+0x98>)
    a7e0:	9208      	str	r2, [sp, #32]
	config_i2c_master.pinmux_pad1 = SENSOR_I2C_PINMUX_PAD1;
    a7e2:	4a17      	ldr	r2, [pc, #92]	; (a840 <configure_sensor_i2c+0x9c>)
    a7e4:	9209      	str	r2, [sp, #36]	; 0x24
	//config_i2c_master.generator_source = GCLK_GENERATOR_1;
	//config_i2c_master.generator_source = GCLK_GENERATOR_2;
	/* Initialize and enable device with config */
	while(i2c_master_init(&i2c_master_instance, SENSOR_I2C, &config_i2c_master)     \
    a7e6:	4d17      	ldr	r5, [pc, #92]	; (a844 <configure_sensor_i2c+0xa0>)
    a7e8:	4c17      	ldr	r4, [pc, #92]	; (a848 <configure_sensor_i2c+0xa4>)
    a7ea:	aa01      	add	r2, sp, #4
    a7ec:	4917      	ldr	r1, [pc, #92]	; (a84c <configure_sensor_i2c+0xa8>)
    a7ee:	0028      	movs	r0, r5
    a7f0:	47a0      	blx	r4
    a7f2:	2800      	cmp	r0, #0
    a7f4:	d1f9      	bne.n	a7ea <configure_sensor_i2c+0x46>
{
	/* Sanity check of arguments */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    a7f6:	4d13      	ldr	r5, [pc, #76]	; (a844 <configure_sensor_i2c+0xa0>)
    a7f8:	682c      	ldr	r4, [r5, #0]

	/* Timeout counter used to force bus state */
	uint32_t timeout_counter = 0;

	/* Wait for module to sync */
	_i2c_master_wait_for_sync(module);
    a7fa:	0028      	movs	r0, r5
    a7fc:	4b14      	ldr	r3, [pc, #80]	; (a850 <configure_sensor_i2c+0xac>)
    a7fe:	4798      	blx	r3

	/* Enable module */
	i2c_module->CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
    a800:	6822      	ldr	r2, [r4, #0]
    a802:	2302      	movs	r3, #2
    a804:	4313      	orrs	r3, r2
    a806:	6023      	str	r3, [r4, #0]

#if I2C_MASTER_CALLBACK_MODE == true
	/* Enable module interrupts */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    a808:	6828      	ldr	r0, [r5, #0]
    a80a:	4b12      	ldr	r3, [pc, #72]	; (a854 <configure_sensor_i2c+0xb0>)
    a80c:	4798      	blx	r3
    a80e:	231f      	movs	r3, #31
    a810:	4018      	ands	r0, r3
    a812:	3b1e      	subs	r3, #30
    a814:	4083      	lsls	r3, r0
    a816:	4a10      	ldr	r2, [pc, #64]	; (a858 <configure_sensor_i2c+0xb4>)
    a818:	6013      	str	r3, [r2, #0]
#endif
	/* Start timeout if bus state is unknown */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
		timeout_counter++;
		if(timeout_counter >= (module->unknown_bus_state_timeout)) {
    a81a:	88e8      	ldrh	r0, [r5, #6]
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Timeout counter used to force bus state */
	uint32_t timeout_counter = 0;
    a81c:	2300      	movs	r3, #0
#if I2C_MASTER_CALLBACK_MODE == true
	/* Enable module interrupts */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#endif
	/* Start timeout if bus state is unknown */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
    a81e:	2110      	movs	r1, #16
    a820:	e005      	b.n	a82e <configure_sensor_i2c+0x8a>
		timeout_counter++;
    a822:	3301      	adds	r3, #1
		if(timeout_counter >= (module->unknown_bus_state_timeout)) {
    a824:	4283      	cmp	r3, r0
    a826:	d302      	bcc.n	a82e <configure_sensor_i2c+0x8a>
			/* Timeout, force bus state to idle */
			i2c_module->STATUS.reg = SERCOM_I2CM_STATUS_BUSSTATE(1);
    a828:	2310      	movs	r3, #16
    a82a:	8363      	strh	r3, [r4, #26]
    a82c:	e002      	b.n	a834 <configure_sensor_i2c+0x90>
#if I2C_MASTER_CALLBACK_MODE == true
	/* Enable module interrupts */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#endif
	/* Start timeout if bus state is unknown */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
    a82e:	8b62      	ldrh	r2, [r4, #26]
    a830:	420a      	tst	r2, r1
    a832:	d0f6      	beq.n	a822 <configure_sensor_i2c+0x7e>
	!= STATUS_OK);

	i2c_master_enable(&i2c_master_instance);
}
    a834:	b00f      	add	sp, #60	; 0x3c
    a836:	bd30      	pop	{r4, r5, pc}
    a838:	00000d48 	.word	0x00000d48
    a83c:	000c0003 	.word	0x000c0003
    a840:	000d0003 	.word	0x000d0003
    a844:	20001c04 	.word	0x20001c04
    a848:	0000ad55 	.word	0x0000ad55
    a84c:	42001000 	.word	0x42001000
    a850:	0000a799 	.word	0x0000a799
    a854:	0000cc25 	.word	0x0000cc25
    a858:	e000e100 	.word	0xe000e100

0000a85c <_adc_get_inst_index>:
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
}
    a85c:	2000      	movs	r0, #0
    a85e:	4770      	bx	lr

0000a860 <adc_get_config_defaults>:
 *
 * \param[out] config  Pointer to configuration struct to initialize to
 *                     default values
 */
void adc_get_config_defaults(struct adc_config *const config)
{
    a860:	b510      	push	{r4, lr}
	Assert(config);
	config->clock_source                  = GCLK_GENERATOR_0;
    a862:	2300      	movs	r3, #0
    a864:	2200      	movs	r2, #0
    a866:	7003      	strb	r3, [r0, #0]
	config->reference                     = ADC_REFERENCE_INTREF;
    a868:	7043      	strb	r3, [r0, #1]
	config->clock_prescaler               = ADC_CLOCK_PRESCALER_DIV2;
    a86a:	7083      	strb	r3, [r0, #2]
	config->resolution                    = ADC_RESOLUTION_12BIT;
    a86c:	70c3      	strb	r3, [r0, #3]
	config->window.window_mode            = ADC_WINDOW_MODE_DISABLE;
    a86e:	2100      	movs	r1, #0
    a870:	8303      	strh	r3, [r0, #24]
	config->window.window_upper_value     = 0;
    a872:	6203      	str	r3, [r0, #32]
	config->window.window_lower_value     = 0;
    a874:	61c3      	str	r3, [r0, #28]
	config->positive_input                = ADC_POSITIVE_INPUT_PIN1;
    a876:	2401      	movs	r4, #1
    a878:	7104      	strb	r4, [r0, #4]
	config->negative_input                = ADC_NEGATIVE_INPUT_GND;
    a87a:	24c0      	movs	r4, #192	; 0xc0
    a87c:	0164      	lsls	r4, r4, #5
    a87e:	80c4      	strh	r4, [r0, #6]
	config->accumulate_samples            = ADC_ACCUMULATE_DISABLE;
    a880:	7201      	strb	r1, [r0, #8]
	config->divide_result                 = ADC_DIVIDE_RESULT_DISABLE;
    a882:	7242      	strb	r2, [r0, #9]
	config->left_adjust                   = false;
    a884:	7282      	strb	r2, [r0, #10]
	config->differential_mode             = false;
    a886:	72c2      	strb	r2, [r0, #11]
	config->freerunning                   = false;
    a888:	7302      	strb	r2, [r0, #12]
	config->event_action                  = ADC_EVENT_ACTION_DISABLED;
    a88a:	242a      	movs	r4, #42	; 0x2a
    a88c:	5502      	strb	r2, [r0, r4]
	config->run_in_standby                = false;
    a88e:	7342      	strb	r2, [r0, #13]
	config->on_demand                     = false;
    a890:	7382      	strb	r2, [r0, #14]
	config->sampling_time_compensation_enable  = false;
    a892:	73c2      	strb	r2, [r0, #15]
	config->positive_input_sequence_mask_enable = 0;
    a894:	6103      	str	r3, [r0, #16]
	config->reference_compensation_enable = false;
    a896:	7502      	strb	r2, [r0, #20]
	config->correction.correction_enable  = false;
    a898:	3c06      	subs	r4, #6
    a89a:	5502      	strb	r2, [r0, r4]
	config->correction.gain_correction    = ADC_GAINCORR_RESETVALUE;
    a89c:	84c3      	strh	r3, [r0, #38]	; 0x26
	config->correction.offset_correction  = ADC_OFFSETCORR_RESETVALUE;
    a89e:	8503      	strh	r3, [r0, #40]	; 0x28
	config->sample_length                 = 0;
    a8a0:	7541      	strb	r1, [r0, #21]
}
    a8a2:	bd10      	pop	{r4, pc}

0000a8a4 <adc_init>:
 */
enum status_code adc_init(
		struct adc_module *const module_inst,
		Adc *hw,
		struct adc_config *config)
{
    a8a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    a8a6:	464f      	mov	r7, r9
    a8a8:	b480      	push	{r7}
    a8aa:	b09a      	sub	sp, #104	; 0x68
    a8ac:	0005      	movs	r5, r0
    a8ae:	000c      	movs	r4, r1
    a8b0:	0016      	movs	r6, r2
	Assert(module_inst);
	Assert(hw);
	Assert(config);

	/* Temporary variable to hold ADC instance number */
	uint8_t instance = _adc_get_inst_index(hw);
    a8b2:	0008      	movs	r0, r1
    a8b4:	4ba9      	ldr	r3, [pc, #676]	; (ab5c <adc_init+0x2b8>)
    a8b6:	4798      	blx	r3

	/* Associate the software module instance with the hardware module */
	module_inst->hw = hw;
    a8b8:	602c      	str	r4, [r5, #0]
    a8ba:	4aa9      	ldr	r2, [pc, #676]	; (ab60 <adc_init+0x2bc>)
    a8bc:	6a11      	ldr	r1, [r2, #32]
    a8be:	2308      	movs	r3, #8
    a8c0:	430b      	orrs	r3, r1
    a8c2:	6213      	str	r3, [r2, #32]
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, MCLK_APBDMASK_ADC);
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, _adc_apbcmasks[instance]);
#endif

	if (hw->CTRLA.reg & ADC_CTRLA_SWRST) {
    a8c4:	7822      	ldrb	r2, [r4, #0]
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
    a8c6:	2305      	movs	r3, #5
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, MCLK_APBDMASK_ADC);
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, _adc_apbcmasks[instance]);
#endif

	if (hw->CTRLA.reg & ADC_CTRLA_SWRST) {
    a8c8:	07d2      	lsls	r2, r2, #31
    a8ca:	d500      	bpl.n	a8ce <adc_init+0x2a>
    a8cc:	e1c9      	b.n	ac62 <adc_init+0x3be>
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    a8ce:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    a8d0:	8c13      	ldrh	r3, [r2, #32]
    a8d2:	b29b      	uxth	r3, r3
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
	}

	while (adc_is_syncing(module_inst)) {
    a8d4:	2b00      	cmp	r3, #0
    a8d6:	d1fb      	bne.n	a8d0 <adc_init+0x2c>
		/* Wait for synchronization */
	}

	if (hw->CTRLA.reg & ADC_CTRLA_ENABLE) {
    a8d8:	7822      	ldrb	r2, [r4, #0]
		/* Module must be disabled before initialization. Abort. */
		return STATUS_ERR_DENIED;
    a8da:	331c      	adds	r3, #28

	while (adc_is_syncing(module_inst)) {
		/* Wait for synchronization */
	}

	if (hw->CTRLA.reg & ADC_CTRLA_ENABLE) {
    a8dc:	0792      	lsls	r2, r2, #30
    a8de:	d500      	bpl.n	a8e2 <adc_init+0x3e>
    a8e0:	e1bf      	b.n	ac62 <adc_init+0x3be>
		/* Module must be disabled before initialization. Abort. */
		return STATUS_ERR_DENIED;
	}

	/* Store the selected reference for later use */
	module_inst->reference = config->reference;
    a8e2:	7873      	ldrb	r3, [r6, #1]
    a8e4:	712b      	strb	r3, [r5, #4]

	/* Make sure the voltage reference is enabled if requested by the config */
	if (module_inst->reference == ADC_REFERENCE_INTREF) {
    a8e6:	2b00      	cmp	r3, #0
    a8e8:	d104      	bne.n	a8f4 <adc_init+0x50>
	switch (vref) {
		case SYSTEM_VOLTAGE_REFERENCE_TEMPSENSE:
			SUPC->VREF.reg |= SUPC_VREF_TSEN;
			break;
		case SYSTEM_VOLTAGE_REFERENCE_OUTPUT:
			SUPC->VREF.reg |= SUPC_VREF_VREFOE;
    a8ea:	4a9e      	ldr	r2, [pc, #632]	; (ab64 <adc_init+0x2c0>)
    a8ec:	69d1      	ldr	r1, [r2, #28]
    a8ee:	3304      	adds	r3, #4
    a8f0:	430b      	orrs	r3, r1
    a8f2:	61d3      	str	r3, [r2, #28]
		system_voltage_reference_enable(SYSTEM_VOLTAGE_REFERENCE_OUTPUT);
	}

#if ADC_CALLBACK_MODE == true
	for (uint8_t i = 0; i < ADC_CALLBACK_N; i++) {
		module_inst->callback[i] = NULL;
    a8f4:	2300      	movs	r3, #0
    a8f6:	60ab      	str	r3, [r5, #8]
    a8f8:	60eb      	str	r3, [r5, #12]
    a8fa:	612b      	str	r3, [r5, #16]
	};

	module_inst->registered_callback_mask = 0;
    a8fc:	76ab      	strb	r3, [r5, #26]
	module_inst->enabled_callback_mask = 0;
    a8fe:	76eb      	strb	r3, [r5, #27]
	module_inst->remaining_conversions = 0;
    a900:	832b      	strh	r3, [r5, #24]
	module_inst->job_status = STATUS_OK;
    a902:	772b      	strb	r3, [r5, #28]

	_adc_instances[instance] = module_inst;
    a904:	0080      	lsls	r0, r0, #2
    a906:	4b98      	ldr	r3, [pc, #608]	; (ab68 <adc_init+0x2c4>)
    a908:	50c5      	str	r5, [r0, r3]

	if (config->event_action == ADC_EVENT_ACTION_DISABLED &&
    a90a:	232a      	movs	r3, #42	; 0x2a
    a90c:	5cf3      	ldrb	r3, [r6, r3]
    a90e:	2b00      	cmp	r3, #0
    a910:	d105      	bne.n	a91e <adc_init+0x7a>
    a912:	7b33      	ldrb	r3, [r6, #12]
    a914:	2b00      	cmp	r3, #0
    a916:	d102      	bne.n	a91e <adc_init+0x7a>
			!config->freerunning) {
		module_inst->software_trigger = true;
    a918:	3301      	adds	r3, #1
    a91a:	776b      	strb	r3, [r5, #29]
    a91c:	e001      	b.n	a922 <adc_init+0x7e>
	} else {
		module_inst->software_trigger = false;
    a91e:	2300      	movs	r3, #0
    a920:	776b      	strb	r3, [r5, #29]
	uint8_t adjres = 0;
	uint32_t resolution = ADC_RESOLUTION_16BIT;
	enum adc_accumulate_samples accumulate = ADC_ACCUMULATE_DISABLE;

	/* Get the hardware module pointer */
	Adc *const adc_module = module_inst->hw;
    a922:	682f      	ldr	r7, [r5, #0]

	/* Configure GCLK channel and enable clock */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->clock_source;
    a924:	7833      	ldrb	r3, [r6, #0]
    a926:	466a      	mov	r2, sp
    a928:	7013      	strb	r3, [r2, #0]
	system_gclk_chan_set_config(_adc_gclk_ids[index], &gclk_chan_conf);
    a92a:	4669      	mov	r1, sp
    a92c:	201e      	movs	r0, #30
    a92e:	4b8f      	ldr	r3, [pc, #572]	; (ab6c <adc_init+0x2c8>)
    a930:	4798      	blx	r3
	system_gclk_chan_enable(_adc_gclk_ids[index]);
    a932:	201e      	movs	r0, #30
    a934:	4b8e      	ldr	r3, [pc, #568]	; (ab70 <adc_init+0x2cc>)
    a936:	4798      	blx	r3

	/* Setup pinmuxing for analog inputs */
	_adc_configure_ain_pin(index, config->positive_input);
    a938:	7934      	ldrb	r4, [r6, #4]
{
#define PIN_INVALID_ADC_AIN    0xFFFFUL

	/* Pinmapping table for AINxx -> GPIO pin number */
#if (SAML21) || (SAML22)
	const uint32_t pinmapping[] = {
    a93a:	2260      	movs	r2, #96	; 0x60
    a93c:	498d      	ldr	r1, [pc, #564]	; (ab74 <adc_init+0x2d0>)
    a93e:	a802      	add	r0, sp, #8
    a940:	4b8d      	ldr	r3, [pc, #564]	; (ab78 <adc_init+0x2d4>)
    a942:	4798      	blx	r3
	Assert(pinmapping);
#endif

	uint32_t pin_map_result = PIN_INVALID_ADC_AIN;

	if (pin <= _adc_extchannel_msb[index]) {
    a944:	2c13      	cmp	r4, #19
    a946:	d80c      	bhi.n	a962 <adc_init+0xbe>
		pin_map_result = pinmapping[pin >> ADC_INPUTCTRL_MUXPOS_Pos];
    a948:	00a4      	lsls	r4, r4, #2
    a94a:	ab02      	add	r3, sp, #8
    a94c:	58e0      	ldr	r0, [r4, r3]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    a94e:	a901      	add	r1, sp, #4
    a950:	2300      	movs	r3, #0
    a952:	704b      	strb	r3, [r1, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    a954:	70cb      	strb	r3, [r1, #3]

		struct system_pinmux_config config;
		system_pinmux_get_config_defaults(&config);

		/* Analog functions are all on MUX setting B */
		config.input_pull   = SYSTEM_PINMUX_PIN_PULL_NONE;
    a956:	708b      	strb	r3, [r1, #2]
		config.mux_position = 1;
    a958:	3301      	adds	r3, #1
    a95a:	700b      	strb	r3, [r1, #0]

		system_pinmux_pin_set_config(pin_map_result, &config);
    a95c:	b2c0      	uxtb	r0, r0
    a95e:	4b87      	ldr	r3, [pc, #540]	; (ab7c <adc_init+0x2d8>)
    a960:	4798      	blx	r3
	system_gclk_chan_set_config(_adc_gclk_ids[index], &gclk_chan_conf);
	system_gclk_chan_enable(_adc_gclk_ids[index]);

	/* Setup pinmuxing for analog inputs */
	_adc_configure_ain_pin(index, config->positive_input);
	_adc_configure_ain_pin(index, config->negative_input);
    a962:	88f4      	ldrh	r4, [r6, #6]
{
#define PIN_INVALID_ADC_AIN    0xFFFFUL

	/* Pinmapping table for AINxx -> GPIO pin number */
#if (SAML21) || (SAML22)
	const uint32_t pinmapping[] = {
    a964:	2260      	movs	r2, #96	; 0x60
    a966:	4983      	ldr	r1, [pc, #524]	; (ab74 <adc_init+0x2d0>)
    a968:	a802      	add	r0, sp, #8
    a96a:	4b83      	ldr	r3, [pc, #524]	; (ab78 <adc_init+0x2d4>)
    a96c:	4798      	blx	r3
	Assert(pinmapping);
#endif

	uint32_t pin_map_result = PIN_INVALID_ADC_AIN;

	if (pin <= _adc_extchannel_msb[index]) {
    a96e:	2c13      	cmp	r4, #19
    a970:	d80c      	bhi.n	a98c <adc_init+0xe8>
		pin_map_result = pinmapping[pin >> ADC_INPUTCTRL_MUXPOS_Pos];
    a972:	00a4      	lsls	r4, r4, #2
    a974:	ab02      	add	r3, sp, #8
    a976:	58e0      	ldr	r0, [r4, r3]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    a978:	a901      	add	r1, sp, #4
    a97a:	2300      	movs	r3, #0
    a97c:	704b      	strb	r3, [r1, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    a97e:	70cb      	strb	r3, [r1, #3]

		struct system_pinmux_config config;
		system_pinmux_get_config_defaults(&config);

		/* Analog functions are all on MUX setting B */
		config.input_pull   = SYSTEM_PINMUX_PIN_PULL_NONE;
    a980:	708b      	strb	r3, [r1, #2]
		config.mux_position = 1;
    a982:	3301      	adds	r3, #1
    a984:	700b      	strb	r3, [r1, #0]

		system_pinmux_pin_set_config(pin_map_result, &config);
    a986:	b2c0      	uxtb	r0, r0
    a988:	4b7c      	ldr	r3, [pc, #496]	; (ab7c <adc_init+0x2d8>)
    a98a:	4798      	blx	r3
    a98c:	2400      	movs	r4, #0
{
#define PIN_INVALID_ADC_AIN    0xFFFFUL

	/* Pinmapping table for AINxx -> GPIO pin number */
#if (SAML21) || (SAML22)
	const uint32_t pinmapping[] = {
    a98e:	4b7a      	ldr	r3, [pc, #488]	; (ab78 <adc_init+0x2d4>)
    a990:	4699      	mov	r9, r3
	_adc_configure_ain_pin(index, config->positive_input);
	_adc_configure_ain_pin(index, config->negative_input);

	/* Set pinmux for positive input sequence*/
	for(uint8_t i=0;i <= _adc_extchannel_msb[index];i++){
		if(config->positive_input_sequence_mask_enable & (1 << i)){
    a992:	2301      	movs	r3, #1
    a994:	40a3      	lsls	r3, r4
    a996:	6932      	ldr	r2, [r6, #16]
    a998:	421a      	tst	r2, r3
    a99a:	d012      	beq.n	a9c2 <adc_init+0x11e>
{
#define PIN_INVALID_ADC_AIN    0xFFFFUL

	/* Pinmapping table for AINxx -> GPIO pin number */
#if (SAML21) || (SAML22)
	const uint32_t pinmapping[] = {
    a99c:	2260      	movs	r2, #96	; 0x60
    a99e:	4975      	ldr	r1, [pc, #468]	; (ab74 <adc_init+0x2d0>)
    a9a0:	a802      	add	r0, sp, #8
    a9a2:	47c8      	blx	r9
	Assert(pinmapping);
#endif

	uint32_t pin_map_result = PIN_INVALID_ADC_AIN;

	if (pin <= _adc_extchannel_msb[index]) {
    a9a4:	2c13      	cmp	r4, #19
    a9a6:	d80c      	bhi.n	a9c2 <adc_init+0x11e>
		pin_map_result = pinmapping[pin >> ADC_INPUTCTRL_MUXPOS_Pos];
    a9a8:	00a3      	lsls	r3, r4, #2
    a9aa:	aa02      	add	r2, sp, #8
    a9ac:	5898      	ldr	r0, [r3, r2]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    a9ae:	a901      	add	r1, sp, #4
    a9b0:	2300      	movs	r3, #0
    a9b2:	704b      	strb	r3, [r1, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    a9b4:	70cb      	strb	r3, [r1, #3]

		struct system_pinmux_config config;
		system_pinmux_get_config_defaults(&config);

		/* Analog functions are all on MUX setting B */
		config.input_pull   = SYSTEM_PINMUX_PIN_PULL_NONE;
    a9b6:	708b      	strb	r3, [r1, #2]
		config.mux_position = 1;
    a9b8:	3301      	adds	r3, #1
    a9ba:	700b      	strb	r3, [r1, #0]

		system_pinmux_pin_set_config(pin_map_result, &config);
    a9bc:	b2c0      	uxtb	r0, r0
    a9be:	4b6f      	ldr	r3, [pc, #444]	; (ab7c <adc_init+0x2d8>)
    a9c0:	4798      	blx	r3
    a9c2:	3401      	adds	r4, #1
	/* Setup pinmuxing for analog inputs */
	_adc_configure_ain_pin(index, config->positive_input);
	_adc_configure_ain_pin(index, config->negative_input);

	/* Set pinmux for positive input sequence*/
	for(uint8_t i=0;i <= _adc_extchannel_msb[index];i++){
    a9c4:	2c14      	cmp	r4, #20
    a9c6:	d1e4      	bne.n	a992 <adc_init+0xee>
			_adc_configure_ain_pin(index, i);
		}
	}

	/* Configure run in standby and on demand */
	adc_module->CTRLA.reg = ((config->run_in_standby << ADC_CTRLA_RUNSTDBY_Pos)
    a9c8:	7b73      	ldrb	r3, [r6, #13]
    a9ca:	019a      	lsls	r2, r3, #6
    a9cc:	7bb3      	ldrb	r3, [r6, #14]
    a9ce:	01db      	lsls	r3, r3, #7
    a9d0:	4313      	orrs	r3, r2
    a9d2:	b2db      	uxtb	r3, r3
    a9d4:	703b      	strb	r3, [r7, #0]
						    | (config->on_demand << ADC_CTRLA_ONDEMAND_Pos)) ;

	/* Configure reference */
	adc_module->REFCTRL.reg =
    a9d6:	7d33      	ldrb	r3, [r6, #20]
    a9d8:	01db      	lsls	r3, r3, #7
    a9da:	7872      	ldrb	r2, [r6, #1]
    a9dc:	4313      	orrs	r3, r2
    a9de:	b2db      	uxtb	r3, r3
    a9e0:	70bb      	strb	r3, [r7, #2]
			(config->reference_compensation_enable << ADC_REFCTRL_REFCOMP_Pos)
			| (config->reference);

	/* Set adjusting result and number of samples */
	switch (config->resolution) {
    a9e2:	78f3      	ldrb	r3, [r6, #3]
    a9e4:	2b34      	cmp	r3, #52	; 0x34
    a9e6:	d900      	bls.n	a9ea <adc_init+0x146>
    a9e8:	e13a      	b.n	ac60 <adc_init+0x3bc>
    a9ea:	009b      	lsls	r3, r3, #2
    a9ec:	4a64      	ldr	r2, [pc, #400]	; (ab80 <adc_init+0x2dc>)
    a9ee:	58d3      	ldr	r3, [r2, r3]
    a9f0:	469f      	mov	pc, r3
		break;

	case ADC_RESOLUTION_14BIT:
		/* Increase resolution by 2 bit */
		adjres = ADC_DIVIDE_RESULT_4;
		accumulate = ADC_ACCUMULATE_SAMPLES_16;
    a9f2:	2004      	movs	r0, #4
		/* 16-bit result register */
		resolution = ADC_RESOLUTION_16BIT;
    a9f4:	2110      	movs	r1, #16
		resolution = ADC_RESOLUTION_16BIT;
		break;

	case ADC_RESOLUTION_14BIT:
		/* Increase resolution by 2 bit */
		adjres = ADC_DIVIDE_RESULT_4;
    a9f6:	2202      	movs	r2, #2
    a9f8:	e01a      	b.n	aa30 <adc_init+0x18c>

	/* Set adjusting result and number of samples */
	switch (config->resolution) {

	case ADC_RESOLUTION_CUSTOM:
		adjres = config->divide_result;
    a9fa:	7a72      	ldrb	r2, [r6, #9]
		accumulate = config->accumulate_samples;
    a9fc:	7a30      	ldrb	r0, [r6, #8]
		/* 16-bit result register */
		resolution = ADC_RESOLUTION_16BIT;
    a9fe:	2110      	movs	r1, #16
    aa00:	e016      	b.n	aa30 <adc_init+0x18c>
		resolution = ADC_RESOLUTION_16BIT;
		break;
	case ADC_RESOLUTION_15BIT:
		/* Increase resolution by 3 bit */
		adjres = ADC_DIVIDE_RESULT_2;
		accumulate = ADC_ACCUMULATE_SAMPLES_64;
    aa02:	2006      	movs	r0, #6
		/* 16-bit result register */
		resolution = ADC_RESOLUTION_16BIT;
    aa04:	2110      	movs	r1, #16
		/* 16-bit result register */
		resolution = ADC_RESOLUTION_16BIT;
		break;
	case ADC_RESOLUTION_15BIT:
		/* Increase resolution by 3 bit */
		adjres = ADC_DIVIDE_RESULT_2;
    aa06:	2201      	movs	r2, #1
    aa08:	e012      	b.n	aa30 <adc_init+0x18c>
		break;

	case ADC_RESOLUTION_16BIT:
		/* Increase resolution by 4 bit */
		adjres = ADC_DIVIDE_RESULT_DISABLE;
		accumulate = ADC_ACCUMULATE_SAMPLES_256;
    aa0a:	2008      	movs	r0, #8
		/* 16-bit result register */
		resolution = ADC_RESOLUTION_16BIT;
    aa0c:	2110      	movs	r1, #16
		resolution = ADC_RESOLUTION_16BIT;
		break;

	case ADC_RESOLUTION_16BIT:
		/* Increase resolution by 4 bit */
		adjres = ADC_DIVIDE_RESULT_DISABLE;
    aa0e:	2200      	movs	r2, #0
    aa10:	e00e      	b.n	aa30 <adc_init+0x18c>
		struct adc_module *const module_inst,
		struct adc_config *const config)
{
	uint8_t adjres = 0;
	uint32_t resolution = ADC_RESOLUTION_16BIT;
	enum adc_accumulate_samples accumulate = ADC_ACCUMULATE_DISABLE;
    aa12:	2000      	movs	r0, #0
		/* 16-bit result register */
		resolution = ADC_RESOLUTION_16BIT;
		break;
	case ADC_RESOLUTION_8BIT:
		/* 8-bit result register */
		resolution = ADC_RESOLUTION_8BIT;
    aa14:	2130      	movs	r1, #48	; 0x30
static enum status_code _adc_set_config(
		uint8_t index,
		struct adc_module *const module_inst,
		struct adc_config *const config)
{
	uint8_t adjres = 0;
    aa16:	2200      	movs	r2, #0
    aa18:	e00a      	b.n	aa30 <adc_init+0x18c>
	uint32_t resolution = ADC_RESOLUTION_16BIT;
	enum adc_accumulate_samples accumulate = ADC_ACCUMULATE_DISABLE;
    aa1a:	2000      	movs	r0, #0
		/* 8-bit result register */
		resolution = ADC_RESOLUTION_8BIT;
		break;
	case ADC_RESOLUTION_10BIT:
		/* 10-bit result register */
		resolution = ADC_RESOLUTION_10BIT;
    aa1c:	2120      	movs	r1, #32
static enum status_code _adc_set_config(
		uint8_t index,
		struct adc_module *const module_inst,
		struct adc_config *const config)
{
	uint8_t adjres = 0;
    aa1e:	2200      	movs	r2, #0
    aa20:	e006      	b.n	aa30 <adc_init+0x18c>
	uint32_t resolution = ADC_RESOLUTION_16BIT;
	enum adc_accumulate_samples accumulate = ADC_ACCUMULATE_DISABLE;
    aa22:	2000      	movs	r0, #0
		/* 10-bit result register */
		resolution = ADC_RESOLUTION_10BIT;
		break;
	case ADC_RESOLUTION_12BIT:
		/* 12-bit result register */
		resolution = ADC_RESOLUTION_12BIT;
    aa24:	2100      	movs	r1, #0
static enum status_code _adc_set_config(
		uint8_t index,
		struct adc_module *const module_inst,
		struct adc_config *const config)
{
	uint8_t adjres = 0;
    aa26:	2200      	movs	r2, #0
    aa28:	e002      	b.n	aa30 <adc_init+0x18c>
		break;

	case ADC_RESOLUTION_13BIT:
		/* Increase resolution by 1 bit */
		adjres = ADC_DIVIDE_RESULT_2;
		accumulate = ADC_ACCUMULATE_SAMPLES_4;
    aa2a:	2002      	movs	r0, #2
		/* 16-bit result register */
		resolution = ADC_RESOLUTION_16BIT;
    aa2c:	2110      	movs	r1, #16
		resolution = ADC_RESOLUTION_16BIT;
		break;

	case ADC_RESOLUTION_13BIT:
		/* Increase resolution by 1 bit */
		adjres = ADC_DIVIDE_RESULT_2;
    aa2e:	2201      	movs	r2, #1
	default:
		/* Unknown. Abort. */
		return STATUS_ERR_INVALID_ARG;
	}

	adc_module->AVGCTRL.reg = ADC_AVGCTRL_ADJRES(adjres) | accumulate;
    aa30:	0112      	lsls	r2, r2, #4
    aa32:	2370      	movs	r3, #112	; 0x70
    aa34:	4013      	ands	r3, r2
    aa36:	4303      	orrs	r3, r0
    aa38:	733b      	strb	r3, [r7, #12]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    aa3a:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    aa3c:	8c13      	ldrh	r3, [r2, #32]
    aa3e:	b29b      	uxth	r3, r3

	while (adc_is_syncing(module_inst)) {
    aa40:	2b00      	cmp	r3, #0
    aa42:	d1fb      	bne.n	aa3c <adc_init+0x198>
		/* Wait for synchronization */
	}

	/* Check validity of sample length value */
	if (config->sample_length > 63) {
    aa44:	7d72      	ldrb	r2, [r6, #21]
		return STATUS_ERR_INVALID_ARG;
    aa46:	3317      	adds	r3, #23
	while (adc_is_syncing(module_inst)) {
		/* Wait for synchronization */
	}

	/* Check validity of sample length value */
	if (config->sample_length > 63) {
    aa48:	2a3f      	cmp	r2, #63	; 0x3f
    aa4a:	d900      	bls.n	aa4e <adc_init+0x1aa>
    aa4c:	e109      	b.n	ac62 <adc_init+0x3be>
		return STATUS_ERR_INVALID_ARG;
	} else {
		/* Configure sample length */
		adc_module->SAMPCTRL.reg =
    aa4e:	7bf3      	ldrb	r3, [r6, #15]
    aa50:	01db      	lsls	r3, r3, #7
    aa52:	431a      	orrs	r2, r3
    aa54:	b2d2      	uxtb	r2, r2
    aa56:	737a      	strb	r2, [r7, #13]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    aa58:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    aa5a:	8c13      	ldrh	r3, [r2, #32]
    aa5c:	b29b      	uxth	r3, r3
				(config->sample_length << ADC_SAMPCTRL_SAMPLEN_Pos)
				| (config->sampling_time_compensation_enable << ADC_SAMPCTRL_OFFCOMP_Pos);
	}

	while (adc_is_syncing(module_inst)) {
    aa5e:	2b00      	cmp	r3, #0
    aa60:	d1fb      	bne.n	aa5a <adc_init+0x1b6>
		/* Wait for synchronization */
	}

	/* Configure CTRLB */
	adc_module->CTRLB.reg =
			config->clock_prescaler;
    aa62:	78b3      	ldrb	r3, [r6, #2]
	while (adc_is_syncing(module_inst)) {
		/* Wait for synchronization */
	}

	/* Configure CTRLB */
	adc_module->CTRLB.reg =
    aa64:	707b      	strb	r3, [r7, #1]
			config->clock_prescaler;
	adc_module->CTRLC.reg =
			resolution |
			(config->correction.correction_enable << ADC_CTRLC_CORREN_Pos) |
    aa66:	2324      	movs	r3, #36	; 0x24
	}

	/* Configure CTRLB */
	adc_module->CTRLB.reg =
			config->clock_prescaler;
	adc_module->CTRLC.reg =
    aa68:	5cf2      	ldrb	r2, [r6, r3]
    aa6a:	00d2      	lsls	r2, r2, #3
    aa6c:	7b33      	ldrb	r3, [r6, #12]
    aa6e:	009b      	lsls	r3, r3, #2
    aa70:	4313      	orrs	r3, r2
    aa72:	7af2      	ldrb	r2, [r6, #11]
    aa74:	431a      	orrs	r2, r3
    aa76:	7ab3      	ldrb	r3, [r6, #10]
    aa78:	005b      	lsls	r3, r3, #1
    aa7a:	4313      	orrs	r3, r2
    aa7c:	430b      	orrs	r3, r1
    aa7e:	817b      	strh	r3, [r7, #10]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    aa80:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    aa82:	8c13      	ldrh	r3, [r2, #32]
    aa84:	b29b      	uxth	r3, r3
			(config->correction.correction_enable << ADC_CTRLC_CORREN_Pos) |
			(config->freerunning << ADC_CTRLC_FREERUN_Pos) |
			(config->left_adjust << ADC_CTRLC_LEFTADJ_Pos) |
			(config->differential_mode << ADC_CTRLC_DIFFMODE_Pos);

	while (adc_is_syncing(module_inst)) {
    aa86:	2b00      	cmp	r3, #0
    aa88:	d1fb      	bne.n	aa82 <adc_init+0x1de>
		/* Wait for synchronization */
	}

	/* Check validity of window thresholds */
	if (config->window.window_mode != ADC_WINDOW_MODE_DISABLE) {
    aa8a:	8b32      	ldrh	r2, [r6, #24]
    aa8c:	2a00      	cmp	r2, #0
    aa8e:	d100      	bne.n	aa92 <adc_init+0x1ee>
    aa90:	e098      	b.n	abc4 <adc_init+0x320>
		switch (resolution) {
    aa92:	2910      	cmp	r1, #16
    aa94:	d07a      	beq.n	ab8c <adc_init+0x2e8>
    aa96:	d802      	bhi.n	aa9e <adc_init+0x1fa>
    aa98:	2900      	cmp	r1, #0
    aa9a:	d03e      	beq.n	ab1a <adc_init+0x276>
    aa9c:	e092      	b.n	abc4 <adc_init+0x320>
    aa9e:	2920      	cmp	r1, #32
    aaa0:	d01a      	beq.n	aad8 <adc_init+0x234>
    aaa2:	2930      	cmp	r1, #48	; 0x30
    aaa4:	d000      	beq.n	aaa8 <adc_init+0x204>
    aaa6:	e08d      	b.n	abc4 <adc_init+0x320>
		case ADC_RESOLUTION_8BIT:
			if (config->differential_mode &&
    aaa8:	7af3      	ldrb	r3, [r6, #11]
    aaaa:	2b00      	cmp	r3, #0
    aaac:	d00a      	beq.n	aac4 <adc_init+0x220>
    aaae:	69f1      	ldr	r1, [r6, #28]
    aab0:	3180      	adds	r1, #128	; 0x80
					(config->window.window_lower_value > 127 ||
					config->window.window_lower_value < -128 ||
					config->window.window_upper_value > 127 ||
					config->window.window_upper_value < -128)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    aab2:	2317      	movs	r3, #23

	/* Check validity of window thresholds */
	if (config->window.window_mode != ADC_WINDOW_MODE_DISABLE) {
		switch (resolution) {
		case ADC_RESOLUTION_8BIT:
			if (config->differential_mode &&
    aab4:	29ff      	cmp	r1, #255	; 0xff
    aab6:	d900      	bls.n	aaba <adc_init+0x216>
    aab8:	e0d3      	b.n	ac62 <adc_init+0x3be>
					(config->window.window_lower_value > 127 ||
					config->window.window_lower_value < -128 ||
    aaba:	6a31      	ldr	r1, [r6, #32]
    aabc:	3180      	adds	r1, #128	; 0x80
    aabe:	29ff      	cmp	r1, #255	; 0xff
    aac0:	d900      	bls.n	aac4 <adc_init+0x220>
    aac2:	e0ce      	b.n	ac62 <adc_init+0x3be>
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 255 ||
					config->window.window_upper_value > 255){
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    aac4:	2317      	movs	r3, #23
					config->window.window_lower_value < -128 ||
					config->window.window_upper_value > 127 ||
					config->window.window_upper_value < -128)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 255 ||
    aac6:	69f1      	ldr	r1, [r6, #28]
    aac8:	29ff      	cmp	r1, #255	; 0xff
    aaca:	dd00      	ble.n	aace <adc_init+0x22a>
    aacc:	e0c9      	b.n	ac62 <adc_init+0x3be>
    aace:	6a31      	ldr	r1, [r6, #32]
    aad0:	29ff      	cmp	r1, #255	; 0xff
    aad2:	dd00      	ble.n	aad6 <adc_init+0x232>
    aad4:	e0c5      	b.n	ac62 <adc_init+0x3be>
    aad6:	e075      	b.n	abc4 <adc_init+0x320>
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			}
			break;
		case ADC_RESOLUTION_10BIT:
			if (config->differential_mode &&
    aad8:	7af3      	ldrb	r3, [r6, #11]
    aada:	2b00      	cmp	r3, #0
    aadc:	d012      	beq.n	ab04 <adc_init+0x260>
    aade:	69f3      	ldr	r3, [r6, #28]
    aae0:	2080      	movs	r0, #128	; 0x80
    aae2:	0080      	lsls	r0, r0, #2
    aae4:	4684      	mov	ip, r0
    aae6:	4463      	add	r3, ip
    aae8:	0019      	movs	r1, r3
					(config->window.window_lower_value > 511 ||
					config->window.window_lower_value < -512 ||
					config->window.window_upper_value > 511 ||
					config->window.window_upper_value < -512)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    aaea:	2317      	movs	r3, #23
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			}
			break;
		case ADC_RESOLUTION_10BIT:
			if (config->differential_mode &&
    aaec:	4825      	ldr	r0, [pc, #148]	; (ab84 <adc_init+0x2e0>)
    aaee:	4281      	cmp	r1, r0
    aaf0:	d900      	bls.n	aaf4 <adc_init+0x250>
    aaf2:	e0b6      	b.n	ac62 <adc_init+0x3be>
					(config->window.window_lower_value > 511 ||
					config->window.window_lower_value < -512 ||
    aaf4:	6a33      	ldr	r3, [r6, #32]
    aaf6:	4463      	add	r3, ip
    aaf8:	0019      	movs	r1, r3
					config->window.window_upper_value > 511 ||
					config->window.window_upper_value < -512)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    aafa:	2317      	movs	r3, #23
			}
			break;
		case ADC_RESOLUTION_10BIT:
			if (config->differential_mode &&
					(config->window.window_lower_value > 511 ||
					config->window.window_lower_value < -512 ||
    aafc:	4821      	ldr	r0, [pc, #132]	; (ab84 <adc_init+0x2e0>)
    aafe:	4281      	cmp	r1, r0
    ab00:	d900      	bls.n	ab04 <adc_init+0x260>
    ab02:	e0ae      	b.n	ac62 <adc_init+0x3be>
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 1023 ||
					config->window.window_upper_value > 1023){
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    ab04:	2317      	movs	r3, #23
					config->window.window_lower_value < -512 ||
					config->window.window_upper_value > 511 ||
					config->window.window_upper_value < -512)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 1023 ||
    ab06:	491f      	ldr	r1, [pc, #124]	; (ab84 <adc_init+0x2e0>)
    ab08:	69f0      	ldr	r0, [r6, #28]
    ab0a:	4288      	cmp	r0, r1
    ab0c:	dd00      	ble.n	ab10 <adc_init+0x26c>
    ab0e:	e0a8      	b.n	ac62 <adc_init+0x3be>
    ab10:	6a30      	ldr	r0, [r6, #32]
    ab12:	4288      	cmp	r0, r1
    ab14:	dd00      	ble.n	ab18 <adc_init+0x274>
    ab16:	e0a4      	b.n	ac62 <adc_init+0x3be>
    ab18:	e054      	b.n	abc4 <adc_init+0x320>
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			}
			break;
		case ADC_RESOLUTION_12BIT:
			if (config->differential_mode &&
    ab1a:	7af3      	ldrb	r3, [r6, #11]
    ab1c:	2b00      	cmp	r3, #0
    ab1e:	d012      	beq.n	ab46 <adc_init+0x2a2>
    ab20:	69f3      	ldr	r3, [r6, #28]
    ab22:	2080      	movs	r0, #128	; 0x80
    ab24:	0100      	lsls	r0, r0, #4
    ab26:	4684      	mov	ip, r0
    ab28:	4463      	add	r3, ip
    ab2a:	0019      	movs	r1, r3
					(config->window.window_lower_value > 2047 ||
					config->window.window_lower_value < -2048 ||
					config->window.window_upper_value > 2047 ||
					config->window.window_upper_value < -2048)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    ab2c:	2317      	movs	r3, #23
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			}
			break;
		case ADC_RESOLUTION_12BIT:
			if (config->differential_mode &&
    ab2e:	4816      	ldr	r0, [pc, #88]	; (ab88 <adc_init+0x2e4>)
    ab30:	4281      	cmp	r1, r0
    ab32:	d900      	bls.n	ab36 <adc_init+0x292>
    ab34:	e095      	b.n	ac62 <adc_init+0x3be>
					(config->window.window_lower_value > 2047 ||
					config->window.window_lower_value < -2048 ||
    ab36:	6a33      	ldr	r3, [r6, #32]
    ab38:	4463      	add	r3, ip
    ab3a:	0019      	movs	r1, r3
					config->window.window_upper_value > 2047 ||
					config->window.window_upper_value < -2048)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    ab3c:	2317      	movs	r3, #23
			}
			break;
		case ADC_RESOLUTION_12BIT:
			if (config->differential_mode &&
					(config->window.window_lower_value > 2047 ||
					config->window.window_lower_value < -2048 ||
    ab3e:	4812      	ldr	r0, [pc, #72]	; (ab88 <adc_init+0x2e4>)
    ab40:	4281      	cmp	r1, r0
    ab42:	d900      	bls.n	ab46 <adc_init+0x2a2>
    ab44:	e08d      	b.n	ac62 <adc_init+0x3be>
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 4095 ||
					config->window.window_upper_value > 4095){
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    ab46:	2317      	movs	r3, #23
					config->window.window_lower_value < -2048 ||
					config->window.window_upper_value > 2047 ||
					config->window.window_upper_value < -2048)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 4095 ||
    ab48:	490f      	ldr	r1, [pc, #60]	; (ab88 <adc_init+0x2e4>)
    ab4a:	69f0      	ldr	r0, [r6, #28]
    ab4c:	4288      	cmp	r0, r1
    ab4e:	dd00      	ble.n	ab52 <adc_init+0x2ae>
    ab50:	e087      	b.n	ac62 <adc_init+0x3be>
    ab52:	6a30      	ldr	r0, [r6, #32]
    ab54:	4288      	cmp	r0, r1
    ab56:	dd00      	ble.n	ab5a <adc_init+0x2b6>
    ab58:	e083      	b.n	ac62 <adc_init+0x3be>
    ab5a:	e033      	b.n	abc4 <adc_init+0x320>
    ab5c:	0000a85d 	.word	0x0000a85d
    ab60:	40000400 	.word	0x40000400
    ab64:	40001400 	.word	0x40001400
    ab68:	200024b0 	.word	0x200024b0
    ab6c:	0000d959 	.word	0x0000d959
    ab70:	0000d8e9 	.word	0x0000d8e9
    ab74:	0001bdd0 	.word	0x0001bdd0
    ab78:	00011833 	.word	0x00011833
    ab7c:	0000da55 	.word	0x0000da55
    ab80:	0001bcfc 	.word	0x0001bcfc
    ab84:	000003ff 	.word	0x000003ff
    ab88:	00000fff 	.word	0x00000fff
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			}
			break;
		case ADC_RESOLUTION_16BIT:
			if (config->differential_mode &&
    ab8c:	7af3      	ldrb	r3, [r6, #11]
    ab8e:	2b00      	cmp	r3, #0
    ab90:	d010      	beq.n	abb4 <adc_init+0x310>
    ab92:	69f3      	ldr	r3, [r6, #28]
    ab94:	2080      	movs	r0, #128	; 0x80
    ab96:	0200      	lsls	r0, r0, #8
    ab98:	4684      	mov	ip, r0
    ab9a:	4463      	add	r3, ip
    ab9c:	0019      	movs	r1, r3
					(config->window.window_lower_value > 32767 ||
					config->window.window_lower_value < -32768 ||
					config->window.window_upper_value > 32767 ||
					config->window.window_upper_value < -32768)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    ab9e:	2317      	movs	r3, #23
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			}
			break;
		case ADC_RESOLUTION_16BIT:
			if (config->differential_mode &&
    aba0:	4832      	ldr	r0, [pc, #200]	; (ac6c <adc_init+0x3c8>)
    aba2:	4281      	cmp	r1, r0
    aba4:	d85d      	bhi.n	ac62 <adc_init+0x3be>
					(config->window.window_lower_value > 32767 ||
					config->window.window_lower_value < -32768 ||
    aba6:	6a33      	ldr	r3, [r6, #32]
    aba8:	4463      	add	r3, ip
    abaa:	0019      	movs	r1, r3
					config->window.window_upper_value > 32767 ||
					config->window.window_upper_value < -32768)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    abac:	2317      	movs	r3, #23
			}
			break;
		case ADC_RESOLUTION_16BIT:
			if (config->differential_mode &&
					(config->window.window_lower_value > 32767 ||
					config->window.window_lower_value < -32768 ||
    abae:	482f      	ldr	r0, [pc, #188]	; (ac6c <adc_init+0x3c8>)
    abb0:	4281      	cmp	r1, r0
    abb2:	d856      	bhi.n	ac62 <adc_init+0x3be>
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 65535 ||
					config->window.window_upper_value > 65535){
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    abb4:	2317      	movs	r3, #23
					config->window.window_lower_value < -32768 ||
					config->window.window_upper_value > 32767 ||
					config->window.window_upper_value < -32768)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 65535 ||
    abb6:	492d      	ldr	r1, [pc, #180]	; (ac6c <adc_init+0x3c8>)
    abb8:	69f0      	ldr	r0, [r6, #28]
    abba:	4288      	cmp	r0, r1
    abbc:	dc51      	bgt.n	ac62 <adc_init+0x3be>
    abbe:	6a30      	ldr	r0, [r6, #32]
    abc0:	4288      	cmp	r0, r1
    abc2:	dc4e      	bgt.n	ac62 <adc_init+0x3be>
			break;
		}
	}

	/* Configure window mode */
	adc_module->CTRLC.reg |= config->window.window_mode;
    abc4:	897b      	ldrh	r3, [r7, #10]
    abc6:	431a      	orrs	r2, r3
    abc8:	817a      	strh	r2, [r7, #10]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    abca:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    abcc:	8c13      	ldrh	r3, [r2, #32]
    abce:	b29b      	uxth	r3, r3

	while (adc_is_syncing(module_inst)) {
    abd0:	2b00      	cmp	r3, #0
    abd2:	d1fb      	bne.n	abcc <adc_init+0x328>
		/* Wait for synchronization */
	}

	/* Configure lower threshold */
	adc_module->WINLT.reg =
    abd4:	8bb3      	ldrh	r3, [r6, #28]
    abd6:	81fb      	strh	r3, [r7, #14]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    abd8:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    abda:	8c13      	ldrh	r3, [r2, #32]
    abdc:	b29b      	uxth	r3, r3
			config->window.window_lower_value << ADC_WINLT_WINLT_Pos;

	while (adc_is_syncing(module_inst)) {
    abde:	2b00      	cmp	r3, #0
    abe0:	d1fb      	bne.n	abda <adc_init+0x336>
		/* Wait for synchronization */
	}

	/* Configure lower threshold */
	adc_module->WINUT.reg = config->window.window_upper_value <<
    abe2:	8c33      	ldrh	r3, [r6, #32]
    abe4:	823b      	strh	r3, [r7, #16]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    abe6:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    abe8:	8c13      	ldrh	r3, [r2, #32]
    abea:	b29b      	uxth	r3, r3
			ADC_WINUT_WINUT_Pos;

	while (adc_is_syncing(module_inst)) {
    abec:	2b00      	cmp	r3, #0
    abee:	d1fb      	bne.n	abe8 <adc_init+0x344>
		/* Wait for synchronization */
	}

	/* Configure pin scan mode and positive and negative input pins */
	adc_module->INPUTCTRL.reg =
    abf0:	7932      	ldrb	r2, [r6, #4]
    abf2:	88f3      	ldrh	r3, [r6, #6]
    abf4:	4313      	orrs	r3, r2
    abf6:	813b      	strh	r3, [r7, #8]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    abf8:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    abfa:	8c13      	ldrh	r3, [r2, #32]
    abfc:	b29b      	uxth	r3, r3
			config->negative_input |
			config->positive_input;

	while (adc_is_syncing(module_inst)) {
    abfe:	2b00      	cmp	r3, #0
    ac00:	d1fb      	bne.n	abfa <adc_init+0x356>
		/* Wait for synchronization */
	}

	/* Configure events */
	adc_module->EVCTRL.reg = config->event_action;
    ac02:	332a      	adds	r3, #42	; 0x2a
    ac04:	5cf3      	ldrb	r3, [r6, r3]
    ac06:	70fb      	strb	r3, [r7, #3]

	/* Disable all interrupts */
	adc_module->INTENCLR.reg =
    ac08:	2307      	movs	r3, #7
    ac0a:	713b      	strb	r3, [r7, #4]
			(1 << ADC_INTENCLR_WINMON_Pos) |(1 << ADC_INTENCLR_OVERRUN_Pos)
			| (1 << ADC_INTENCLR_RESRDY_Pos);

	if (config->correction.correction_enable){
    ac0c:	331d      	adds	r3, #29
    ac0e:	5cf3      	ldrb	r3, [r6, r3]
    ac10:	2b00      	cmp	r3, #0
    ac12:	d019      	beq.n	ac48 <adc_init+0x3a4>
		/* Make sure gain_correction value is valid */
		if (config->correction.gain_correction > ADC_GAINCORR_GAINCORR_Msk) {
    ac14:	8cf2      	ldrh	r2, [r6, #38]	; 0x26
			return STATUS_ERR_INVALID_ARG;
    ac16:	2317      	movs	r3, #23
			(1 << ADC_INTENCLR_WINMON_Pos) |(1 << ADC_INTENCLR_OVERRUN_Pos)
			| (1 << ADC_INTENCLR_RESRDY_Pos);

	if (config->correction.correction_enable){
		/* Make sure gain_correction value is valid */
		if (config->correction.gain_correction > ADC_GAINCORR_GAINCORR_Msk) {
    ac18:	4915      	ldr	r1, [pc, #84]	; (ac70 <adc_init+0x3cc>)
    ac1a:	428a      	cmp	r2, r1
    ac1c:	d821      	bhi.n	ac62 <adc_init+0x3be>
			return STATUS_ERR_INVALID_ARG;
		} else {
			/* Set gain correction value */
			adc_module->GAINCORR.reg = config->correction.gain_correction <<
    ac1e:	827a      	strh	r2, [r7, #18]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    ac20:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    ac22:	8c13      	ldrh	r3, [r2, #32]
    ac24:	b29b      	uxth	r3, r3
					ADC_GAINCORR_GAINCORR_Pos;
		}

		while (adc_is_syncing(module_inst)) {
    ac26:	2b00      	cmp	r3, #0
    ac28:	d1fb      	bne.n	ac22 <adc_init+0x37e>
			/* Wait for synchronization */
		}

		/* Make sure offset correction value is valid */
		if (config->correction.offset_correction > 2047 ||
    ac2a:	8d31      	ldrh	r1, [r6, #40]	; 0x28
    ac2c:	2380      	movs	r3, #128	; 0x80
    ac2e:	011b      	lsls	r3, r3, #4
    ac30:	18ca      	adds	r2, r1, r3
    ac32:	b292      	uxth	r2, r2
				config->correction.offset_correction < -2048) {
			return STATUS_ERR_INVALID_ARG;
    ac34:	2317      	movs	r3, #23
		while (adc_is_syncing(module_inst)) {
			/* Wait for synchronization */
		}

		/* Make sure offset correction value is valid */
		if (config->correction.offset_correction > 2047 ||
    ac36:	480e      	ldr	r0, [pc, #56]	; (ac70 <adc_init+0x3cc>)
    ac38:	4282      	cmp	r2, r0
    ac3a:	d812      	bhi.n	ac62 <adc_init+0x3be>
				config->correction.offset_correction < -2048) {
			return STATUS_ERR_INVALID_ARG;
		} else {
			/* Set offset correction value */
			adc_module->OFFSETCORR.reg = config->correction.offset_correction <<
    ac3c:	82b9      	strh	r1, [r7, #20]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    ac3e:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    ac40:	8c13      	ldrh	r3, [r2, #32]
    ac42:	b29b      	uxth	r3, r3
					ADC_OFFSETCORR_OFFSETCORR_Pos;
		}

		while (adc_is_syncing(module_inst)) {
    ac44:	2b00      	cmp	r3, #0
    ac46:	d1fb      	bne.n	ac40 <adc_init+0x39c>
		}
	}

	/* Load in the fixed device ADC calibration constants */
	adc_module->CALIB.reg =
			ADC_CALIB_BIASREFBUF(
    ac48:	4b0a      	ldr	r3, [pc, #40]	; (ac74 <adc_init+0x3d0>)
    ac4a:	681b      	ldr	r3, [r3, #0]
			/* Wait for synchronization */
		}
	}

	/* Load in the fixed device ADC calibration constants */
	adc_module->CALIB.reg =
    ac4c:	0219      	lsls	r1, r3, #8
    ac4e:	22e0      	movs	r2, #224	; 0xe0
    ac50:	00d2      	lsls	r2, r2, #3
    ac52:	400a      	ands	r2, r1
    ac54:	069b      	lsls	r3, r3, #26
    ac56:	0f5b      	lsrs	r3, r3, #29
    ac58:	4313      	orrs	r3, r2
    ac5a:	85bb      	strh	r3, [r7, #44]	; 0x2c
			) |
			ADC_CALIB_BIASCOMP(
				(*(uint32_t *)_adc_biascomp_addr[index] >> _adc_biascomp_pos[index])
			);

	return STATUS_OK;
    ac5c:	2300      	movs	r3, #0
    ac5e:	e000      	b.n	ac62 <adc_init+0x3be>
		resolution = ADC_RESOLUTION_12BIT;
		break;

	default:
		/* Unknown. Abort. */
		return STATUS_ERR_INVALID_ARG;
    ac60:	2317      	movs	r3, #23
	}
#endif

	/* Write configuration to module */
	return _adc_set_config(instance, module_inst, config);
}
    ac62:	0018      	movs	r0, r3
    ac64:	b01a      	add	sp, #104	; 0x68
    ac66:	bc04      	pop	{r2}
    ac68:	4691      	mov	r9, r2
    ac6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ac6c:	0000ffff 	.word	0x0000ffff
    ac70:	00000fff 	.word	0x00000fff
    ac74:	00806020 	.word	0x00806020

0000ac78 <ADC_Handler>:
		}

	MREPEAT(ADC_INST_NUM, _ADC_INTERRUPT_HANDLER, 0)
#else
void ADC_Handler(void)
{
    ac78:	b570      	push	{r4, r5, r6, lr}

struct adc_module *_adc_instances[ADC_INST_NUM];

static void _adc_interrupt_handler(const uint8_t instance)
{
	struct adc_module *module = _adc_instances[instance];
    ac7a:	4b2d      	ldr	r3, [pc, #180]	; (ad30 <ADC_Handler+0xb8>)
    ac7c:	681c      	ldr	r4, [r3, #0]

	/* get interrupt flags and mask out enabled callbacks */
	uint32_t flags = module->hw->INTFLAG.reg;
    ac7e:	6823      	ldr	r3, [r4, #0]
    ac80:	799d      	ldrb	r5, [r3, #6]
    ac82:	b2ed      	uxtb	r5, r5

	if (flags & ADC_INTFLAG_RESRDY) {
    ac84:	07ea      	lsls	r2, r5, #31
    ac86:	d535      	bpl.n	acf4 <ADC_Handler+0x7c>
		if ((module->enabled_callback_mask & (1 << ADC_CALLBACK_READ_BUFFER)) &&
    ac88:	7ee2      	ldrb	r2, [r4, #27]
    ac8a:	07d2      	lsls	r2, r2, #31
    ac8c:	d532      	bpl.n	acf4 <ADC_Handler+0x7c>
    ac8e:	7ea2      	ldrb	r2, [r4, #26]
    ac90:	07d2      	lsls	r2, r2, #31
    ac92:	d52f      	bpl.n	acf4 <ADC_Handler+0x7c>
				(module->registered_callback_mask & (1 << ADC_CALLBACK_READ_BUFFER))) {
			/* clear interrupt flag */
			module->hw->INTFLAG.reg = ADC_INTFLAG_RESRDY;
    ac94:	2201      	movs	r2, #1
    ac96:	719a      	strb	r2, [r3, #6]

			/* store ADC result in job buffer */
			*(module->job_buffer++) = module->hw->RESULT.reg;
    ac98:	6962      	ldr	r2, [r4, #20]
    ac9a:	1c93      	adds	r3, r2, #2
    ac9c:	6163      	str	r3, [r4, #20]
    ac9e:	6823      	ldr	r3, [r4, #0]
    aca0:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    aca2:	b29b      	uxth	r3, r3
    aca4:	8013      	strh	r3, [r2, #0]

			if (--module->remaining_conversions > 0) {
    aca6:	8b23      	ldrh	r3, [r4, #24]
    aca8:	3b01      	subs	r3, #1
    acaa:	b29b      	uxth	r3, r3
    acac:	8323      	strh	r3, [r4, #24]
    acae:	2b00      	cmp	r3, #0
    acb0:	d015      	beq.n	acde <ADC_Handler+0x66>
				if (module->software_trigger == true
    acb2:	7f63      	ldrb	r3, [r4, #29]
    acb4:	2b00      	cmp	r3, #0
    acb6:	d01d      	beq.n	acf4 <ADC_Handler+0x7c>
					&& (!(module->hw->SEQSTATUS.reg & ADC_SEQSTATUS_SEQBUSY))) {
    acb8:	6822      	ldr	r2, [r4, #0]
    acba:	79d3      	ldrb	r3, [r2, #7]
    acbc:	b25b      	sxtb	r3, r3
    acbe:	2b00      	cmp	r3, #0
    acc0:	db18      	blt.n	acf4 <ADC_Handler+0x7c>
    acc2:	8c13      	ldrh	r3, [r2, #32]
    acc4:	b29b      	uxth	r3, r3
	Assert(module_inst);
	Assert(module_inst->hw);

	Adc *const adc_module = module_inst->hw;

	while (adc_is_syncing(module_inst)) {
    acc6:	2b00      	cmp	r3, #0
    acc8:	d1fb      	bne.n	acc2 <ADC_Handler+0x4a>
		/* Wait for synchronization */
	}

	adc_module->SWTRIG.reg |= ADC_SWTRIG_START;
    acca:	7e11      	ldrb	r1, [r2, #24]
    accc:	3302      	adds	r3, #2
    acce:	430b      	orrs	r3, r1
    acd0:	7613      	strb	r3, [r2, #24]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    acd2:	6822      	ldr	r2, [r4, #0]

	if (adc_module->SYNCBUSY.reg) {
    acd4:	8c13      	ldrh	r3, [r2, #32]
    acd6:	b29b      	uxth	r3, r3

	while (adc_is_syncing(module_inst)) {
    acd8:	2b00      	cmp	r3, #0
    acda:	d1fb      	bne.n	acd4 <ADC_Handler+0x5c>
    acdc:	e00a      	b.n	acf4 <ADC_Handler+0x7c>
					adc_start_conversion(module);
				}
			} else {
				if (module->job_status == STATUS_BUSY) {
    acde:	7f23      	ldrb	r3, [r4, #28]
    ace0:	2b05      	cmp	r3, #5
    ace2:	d107      	bne.n	acf4 <ADC_Handler+0x7c>
					/* job is complete. update status,disable interrupt
					 *and call callback */
					module->job_status = STATUS_OK;
    ace4:	2300      	movs	r3, #0
    ace6:	7723      	strb	r3, [r4, #28]
	Assert(module_inst);
	Assert(module_inst->hw);

	Adc *const adc_module = module_inst->hw;
	/* Enable interrupt */
	adc_module->INTENCLR.reg = interrupt;
    ace8:	3301      	adds	r3, #1
    acea:	6822      	ldr	r2, [r4, #0]
    acec:	7113      	strb	r3, [r2, #4]
					adc_disable_interrupt(module, ADC_INTERRUPT_RESULT_READY);
					(module->callback[ADC_CALLBACK_READ_BUFFER])(module);
    acee:	0020      	movs	r0, r4
    acf0:	68a3      	ldr	r3, [r4, #8]
    acf2:	4798      	blx	r3
				}
			}
		}
	}

	if (flags & ADC_INTFLAG_WINMON) {
    acf4:	076b      	lsls	r3, r5, #29
    acf6:	d50b      	bpl.n	ad10 <ADC_Handler+0x98>
		module->hw->INTFLAG.reg = ADC_INTFLAG_WINMON;
    acf8:	2304      	movs	r3, #4
    acfa:	6822      	ldr	r2, [r4, #0]
    acfc:	7193      	strb	r3, [r2, #6]
		if ((module->enabled_callback_mask & (1 << ADC_CALLBACK_WINDOW)) &&
    acfe:	7ee3      	ldrb	r3, [r4, #27]
    ad00:	079b      	lsls	r3, r3, #30
    ad02:	d505      	bpl.n	ad10 <ADC_Handler+0x98>
    ad04:	7ea3      	ldrb	r3, [r4, #26]
    ad06:	079b      	lsls	r3, r3, #30
    ad08:	d502      	bpl.n	ad10 <ADC_Handler+0x98>
				(module->registered_callback_mask & (1 << ADC_CALLBACK_WINDOW))) {
			(module->callback[ADC_CALLBACK_WINDOW])(module);
    ad0a:	0020      	movs	r0, r4
    ad0c:	68e3      	ldr	r3, [r4, #12]
    ad0e:	4798      	blx	r3
		}

	}

	if (flags & ADC_INTFLAG_OVERRUN) {
    ad10:	07ab      	lsls	r3, r5, #30
    ad12:	d50b      	bpl.n	ad2c <ADC_Handler+0xb4>
		module->hw->INTFLAG.reg = ADC_INTFLAG_OVERRUN;
    ad14:	2302      	movs	r3, #2
    ad16:	6822      	ldr	r2, [r4, #0]
    ad18:	7193      	strb	r3, [r2, #6]
		if ((module->enabled_callback_mask & (1 << ADC_CALLBACK_ERROR)) &&
    ad1a:	7ee3      	ldrb	r3, [r4, #27]
    ad1c:	075b      	lsls	r3, r3, #29
    ad1e:	d505      	bpl.n	ad2c <ADC_Handler+0xb4>
    ad20:	7ea3      	ldrb	r3, [r4, #26]
    ad22:	075b      	lsls	r3, r3, #29
    ad24:	d502      	bpl.n	ad2c <ADC_Handler+0xb4>
				(module->registered_callback_mask & (1 << ADC_CALLBACK_ERROR))) {
			(module->callback[ADC_CALLBACK_ERROR])(module);
    ad26:	6923      	ldr	r3, [r4, #16]
    ad28:	0020      	movs	r0, r4
    ad2a:	4798      	blx	r3
	MREPEAT(ADC_INST_NUM, _ADC_INTERRUPT_HANDLER, 0)
#else
void ADC_Handler(void)
{
	_adc_interrupt_handler(0);
}
    ad2c:	bd70      	pop	{r4, r5, r6, pc}
    ad2e:	46c0      	nop			; (mov r8, r8)
    ad30:	200024b0 	.word	0x200024b0

0000ad34 <adc_register_callback>:
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
    ad34:	1c93      	adds	r3, r2, #2
    ad36:	009b      	lsls	r3, r3, #2
    ad38:	5019      	str	r1, [r3, r0]

	/* Set the bit corresponding to the callback_type */
	module->registered_callback_mask |= (1 << callback_type);
    ad3a:	2301      	movs	r3, #1
    ad3c:	4093      	lsls	r3, r2
    ad3e:	7e82      	ldrb	r2, [r0, #26]
    ad40:	4313      	orrs	r3, r2
    ad42:	7683      	strb	r3, [r0, #26]
}
    ad44:	4770      	bx	lr
    ad46:	46c0      	nop			; (mov r8, r8)

0000ad48 <_i2c_master_wait_for_sync>:
{
	/* Sanity check */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_hw = &(module->hw->I2CM);
    ad48:	6801      	ldr	r1, [r0, #0]
		const struct i2c_master_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
    ad4a:	2207      	movs	r2, #7
	SercomI2cm *const i2c_hw = &(module->hw->I2CM);

#if defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_1)
	return (i2c_hw->STATUS.reg & SERCOM_I2CM_STATUS_SYNCBUSY);
#elif defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_2)
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
    ad4c:	69cb      	ldr	r3, [r1, #28]
		const struct i2c_master_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
    ad4e:	421a      	tst	r2, r3
    ad50:	d1fc      	bne.n	ad4c <_i2c_master_wait_for_sync+0x4>
		/* Wait for I2C module to sync. */
	}
}
    ad52:	4770      	bx	lr

0000ad54 <i2c_master_init>:
 */
enum status_code i2c_master_init(
		struct i2c_master_module *const module,
		Sercom *const hw,
		const struct i2c_master_config *const config)
{
    ad54:	b5f0      	push	{r4, r5, r6, r7, lr}
    ad56:	464f      	mov	r7, r9
    ad58:	4646      	mov	r6, r8
    ad5a:	b4c0      	push	{r6, r7}
    ad5c:	b083      	sub	sp, #12
    ad5e:	0007      	movs	r7, r0
    ad60:	000d      	movs	r5, r1
    ad62:	0016      	movs	r6, r2
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize software module */
	module->hw = hw;
    ad64:	6039      	str	r1, [r7, #0]

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    ad66:	0008      	movs	r0, r1
    ad68:	4b71      	ldr	r3, [pc, #452]	; (af30 <i2c_master_init+0x1dc>)
    ad6a:	4798      	blx	r3

#if (SAML22) || (SAMC20)
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#elif (SAML21)
	if (sercom_index == 5) {
    ad6c:	2805      	cmp	r0, #5
    ad6e:	d100      	bne.n	ad72 <i2c_master_init+0x1e>
    ad70:	e0c6      	b.n	af00 <i2c_master_init+0x1ac>
		pm_index     = MCLK_APBDMASK_SERCOM5_Pos;
		gclk_index   = SERCOM5_GCLK_ID_CORE;
	} else {
		pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
		gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    ad72:	0004      	movs	r4, r0
    ad74:	3412      	adds	r4, #18
		case SYSTEM_CLOCK_APB_APBB:
			MCLK->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			MCLK->APBCMASK.reg |= mask;
    ad76:	496f      	ldr	r1, [pc, #444]	; (af34 <i2c_master_init+0x1e0>)
    ad78:	69ca      	ldr	r2, [r1, #28]
    ad7a:	2301      	movs	r3, #1
    ad7c:	4083      	lsls	r3, r0
    ad7e:	4313      	orrs	r3, r2
    ad80:	61cb      	str	r3, [r1, #28]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    ad82:	a901      	add	r1, sp, #4
    ad84:	7b33      	ldrb	r3, [r6, #12]
    ad86:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    ad88:	b2e4      	uxtb	r4, r4
    ad8a:	0020      	movs	r0, r4
    ad8c:	4b6a      	ldr	r3, [pc, #424]	; (af38 <i2c_master_init+0x1e4>)
    ad8e:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    ad90:	0020      	movs	r0, r4
    ad92:	4b6a      	ldr	r3, [pc, #424]	; (af3c <i2c_master_init+0x1e8>)
    ad94:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    ad96:	7b30      	ldrb	r0, [r6, #12]
    ad98:	2100      	movs	r1, #0
    ad9a:	4b69      	ldr	r3, [pc, #420]	; (af40 <i2c_master_init+0x1ec>)
    ad9c:	4798      	blx	r3

	/* Check if module is enabled. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_ENABLE) {
    ad9e:	682b      	ldr	r3, [r5, #0]
		return STATUS_ERR_DENIED;
    ada0:	201c      	movs	r0, #28
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
	system_gclk_chan_enable(gclk_index);
	sercom_set_gclk_generator(config->generator_source, false);

	/* Check if module is enabled. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_ENABLE) {
    ada2:	079b      	lsls	r3, r3, #30
    ada4:	d500      	bpl.n	ada8 <i2c_master_init+0x54>
    ada6:	e0bd      	b.n	af24 <i2c_master_init+0x1d0>
		return STATUS_ERR_DENIED;
	}

	/* Check if reset is in progress. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_SWRST) {
    ada8:	682b      	ldr	r3, [r5, #0]
		return STATUS_BUSY;
    adaa:	3817      	subs	r0, #23
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_ENABLE) {
		return STATUS_ERR_DENIED;
	}

	/* Check if reset is in progress. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_SWRST) {
    adac:	07db      	lsls	r3, r3, #31
    adae:	d500      	bpl.n	adb2 <i2c_master_init+0x5e>
    adb0:	e0b8      	b.n	af24 <i2c_master_init+0x1d0>
		return STATUS_BUSY;
	}

#if I2C_MASTER_CALLBACK_MODE == true
	/* Get sercom instance index and register callback. */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
    adb2:	6838      	ldr	r0, [r7, #0]
    adb4:	4b5e      	ldr	r3, [pc, #376]	; (af30 <i2c_master_init+0x1dc>)
    adb6:	4698      	mov	r8, r3
    adb8:	4798      	blx	r3
    adba:	0004      	movs	r4, r0
	_sercom_set_handler(instance_index, _i2c_master_interrupt_handler);
    adbc:	4961      	ldr	r1, [pc, #388]	; (af44 <i2c_master_init+0x1f0>)
    adbe:	4b62      	ldr	r3, [pc, #392]	; (af48 <i2c_master_init+0x1f4>)
    adc0:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    adc2:	00a4      	lsls	r4, r4, #2
    adc4:	4b61      	ldr	r3, [pc, #388]	; (af4c <i2c_master_init+0x1f8>)
    adc6:	50e7      	str	r7, [r4, r3]

	/* Initialize values in module. */
	module->registered_callback = 0;
    adc8:	2300      	movs	r3, #0
    adca:	763b      	strb	r3, [r7, #24]
	module->enabled_callback = 0;
    adcc:	767b      	strb	r3, [r7, #25]
	module->buffer_length = 0;
    adce:	2400      	movs	r4, #0
    add0:	837b      	strh	r3, [r7, #26]
	module->buffer_remaining = 0;
    add2:	83bb      	strh	r3, [r7, #28]

	module->status = STATUS_OK;
    add4:	2225      	movs	r2, #37	; 0x25
    add6:	54bc      	strb	r4, [r7, r2]
	module->buffer = NULL;
    add8:	623b      	str	r3, [r7, #32]
#endif

	/* Set sercom module to operate in I2C master mode. */
	i2c_module->CTRLA.reg = SERCOM_I2CM_CTRLA_MODE(0x5);
    adda:	3314      	adds	r3, #20
    addc:	602b      	str	r3, [r5, #0]
	uint32_t tmp_ctrla;
	int32_t tmp_baud;
	int32_t tmp_baud_hs;
	enum status_code tmp_status_code = STATUS_OK;

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    adde:	683d      	ldr	r5, [r7, #0]
	Sercom *const sercom_hw = module->hw;

	uint8_t sercom_index = _sercom_get_sercom_inst_index(sercom_hw);
    ade0:	0028      	movs	r0, r5
    ade2:	47c0      	blx	r8
    ade4:	4680      	mov	r8, r0
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    ade6:	2380      	movs	r3, #128	; 0x80
    ade8:	466a      	mov	r2, sp
    adea:	7013      	strb	r3, [r2, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    adec:	7054      	strb	r4, [r2, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    adee:	2301      	movs	r3, #1
    adf0:	7093      	strb	r3, [r2, #2]
	config->powersave    = false;
    adf2:	70d4      	strb	r4, [r2, #3]

	/* Pin configuration */
	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);

	uint32_t pad0 = config->pinmux_pad0;
    adf4:	69f0      	ldr	r0, [r6, #28]
	uint32_t pad1 = config->pinmux_pad1;
    adf6:	6a34      	ldr	r4, [r6, #32]

	/* SERCOM PAD0 - SDA */
	if (pad0 == PINMUX_DEFAULT) {
    adf8:	2800      	cmp	r0, #0
    adfa:	d103      	bne.n	ae04 <i2c_master_init+0xb0>
		pad0 = _sercom_get_default_pad(sercom_hw, 0);
    adfc:	2100      	movs	r1, #0
    adfe:	0028      	movs	r0, r5
    ae00:	4b53      	ldr	r3, [pc, #332]	; (af50 <i2c_master_init+0x1fc>)
    ae02:	4798      	blx	r3
	}
	pin_conf.mux_position = pad0 & 0xFFFF;
    ae04:	466b      	mov	r3, sp
    ae06:	7018      	strb	r0, [r3, #0]
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
    ae08:	2302      	movs	r3, #2
    ae0a:	466a      	mov	r2, sp
    ae0c:	7053      	strb	r3, [r2, #1]
	system_pinmux_pin_set_config(pad0 >> 16, &pin_conf);
    ae0e:	0c00      	lsrs	r0, r0, #16
    ae10:	b2c0      	uxtb	r0, r0
    ae12:	4669      	mov	r1, sp
    ae14:	4b4f      	ldr	r3, [pc, #316]	; (af54 <i2c_master_init+0x200>)
    ae16:	4798      	blx	r3

	/* SERCOM PAD1 - SCL */
	if (pad1 == PINMUX_DEFAULT) {
    ae18:	2c00      	cmp	r4, #0
    ae1a:	d104      	bne.n	ae26 <i2c_master_init+0xd2>
		pad1 = _sercom_get_default_pad(sercom_hw, 1);
    ae1c:	2101      	movs	r1, #1
    ae1e:	0028      	movs	r0, r5
    ae20:	4b4b      	ldr	r3, [pc, #300]	; (af50 <i2c_master_init+0x1fc>)
    ae22:	4798      	blx	r3
    ae24:	0004      	movs	r4, r0
	}
	pin_conf.mux_position = pad1 & 0xFFFF;
    ae26:	466b      	mov	r3, sp
    ae28:	701c      	strb	r4, [r3, #0]
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
    ae2a:	2302      	movs	r3, #2
    ae2c:	466a      	mov	r2, sp
    ae2e:	7053      	strb	r3, [r2, #1]
	system_pinmux_pin_set_config(pad1 >> 16, &pin_conf);
    ae30:	0c20      	lsrs	r0, r4, #16
    ae32:	b2c0      	uxtb	r0, r0
    ae34:	4669      	mov	r1, sp
    ae36:	4b47      	ldr	r3, [pc, #284]	; (af54 <i2c_master_init+0x200>)
    ae38:	4798      	blx	r3

	/* Save timeout on unknown bus state in software module. */
	module->unknown_bus_state_timeout = config->unknown_bus_state_timeout;
    ae3a:	8ab3      	ldrh	r3, [r6, #20]
    ae3c:	80fb      	strh	r3, [r7, #6]

	/* Save timeout on buffer write. */
	module->buffer_timeout = config->buffer_timeout;
    ae3e:	8af3      	ldrh	r3, [r6, #22]
    ae40:	813b      	strh	r3, [r7, #8]

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    ae42:	7e32      	ldrb	r2, [r6, #24]
		tmp_ctrla = SERCOM_I2CM_CTRLA_RUNSTDBY;
    ae44:	2380      	movs	r3, #128	; 0x80

	/* Save timeout on buffer write. */
	module->buffer_timeout = config->buffer_timeout;

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    ae46:	2a00      	cmp	r2, #0
    ae48:	d104      	bne.n	ae54 <i2c_master_init+0x100>
    ae4a:	4b43      	ldr	r3, [pc, #268]	; (af58 <i2c_master_init+0x204>)
    ae4c:	789b      	ldrb	r3, [r3, #2]
    ae4e:	079b      	lsls	r3, r3, #30
		tmp_ctrla = SERCOM_I2CM_CTRLA_RUNSTDBY;
    ae50:	0fdb      	lsrs	r3, r3, #31
    ae52:	01db      	lsls	r3, r3, #7
	if (config->start_hold_time != I2C_MASTER_START_HOLD_TIME_DISABLED) {
		tmp_ctrla |= config->start_hold_time;
	}

	/* Check and set transfer speed */
	tmp_ctrla |= config->transfer_speed;
    ae54:	6932      	ldr	r2, [r6, #16]
    ae56:	68b1      	ldr	r1, [r6, #8]
    ae58:	430a      	orrs	r2, r1
    ae5a:	4313      	orrs	r3, r2

	/* Check and set SCL low timeout. */
	if (config->scl_low_timeout) {
    ae5c:	2224      	movs	r2, #36	; 0x24
    ae5e:	5cb2      	ldrb	r2, [r6, r2]
    ae60:	2a00      	cmp	r2, #0
    ae62:	d002      	beq.n	ae6a <i2c_master_init+0x116>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_LOWTOUTEN;
    ae64:	2280      	movs	r2, #128	; 0x80
    ae66:	05d2      	lsls	r2, r2, #23
    ae68:	4313      	orrs	r3, r2
	}

	/* Check and set inactive bus timeout. */
	if (config->inactive_timeout != I2C_MASTER_INACTIVE_TIMEOUT_DISABLED) {
		tmp_ctrla |= config->inactive_timeout;
    ae6a:	6ab2      	ldr	r2, [r6, #40]	; 0x28
    ae6c:	4313      	orrs	r3, r2
	}

	/* Check and set SCL clock stretch mode. */
	if (config->scl_stretch_only_after_ack_bit) {
    ae6e:	222c      	movs	r2, #44	; 0x2c
    ae70:	5cb2      	ldrb	r2, [r6, r2]
    ae72:	2a00      	cmp	r2, #0
    ae74:	d002      	beq.n	ae7c <i2c_master_init+0x128>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_SCLSM;
    ae76:	2280      	movs	r2, #128	; 0x80
    ae78:	0512      	lsls	r2, r2, #20
    ae7a:	4313      	orrs	r3, r2
	}

	/* Check and set slave SCL low extend timeout. */
	if (config->slave_scl_low_extend_timeout) {
    ae7c:	222d      	movs	r2, #45	; 0x2d
    ae7e:	5cb2      	ldrb	r2, [r6, r2]
    ae80:	2a00      	cmp	r2, #0
    ae82:	d002      	beq.n	ae8a <i2c_master_init+0x136>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_SEXTTOEN;
    ae84:	2280      	movs	r2, #128	; 0x80
    ae86:	0412      	lsls	r2, r2, #16
    ae88:	4313      	orrs	r3, r2
	}

	/* Check and set master SCL low extend timeout. */
	if (config->master_scl_low_extend_timeout) {
    ae8a:	222e      	movs	r2, #46	; 0x2e
    ae8c:	5cb2      	ldrb	r2, [r6, r2]
    ae8e:	2a00      	cmp	r2, #0
    ae90:	d002      	beq.n	ae98 <i2c_master_init+0x144>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_MEXTTOEN;
    ae92:	2280      	movs	r2, #128	; 0x80
    ae94:	03d2      	lsls	r2, r2, #15
    ae96:	4313      	orrs	r3, r2
	}

	/* Write config to register CTRLA. */
	i2c_module->CTRLA.reg |= tmp_ctrla;
    ae98:	682a      	ldr	r2, [r5, #0]
    ae9a:	4313      	orrs	r3, r2
    ae9c:	602b      	str	r3, [r5, #0]

	/* Set configurations in CTRLB. */
	i2c_module->CTRLB.reg = SERCOM_I2CM_CTRLB_SMEN;
    ae9e:	2380      	movs	r3, #128	; 0x80
    aea0:	005b      	lsls	r3, r3, #1
    aea2:	606b      	str	r3, [r5, #4]

	/* Find and set baudrate, considering sda/scl rise time */
	uint32_t fgclk       = system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index);
    aea4:	4644      	mov	r4, r8
    aea6:	3412      	adds	r4, #18
    aea8:	b2e3      	uxtb	r3, r4
    aeaa:	4698      	mov	r8, r3
    aeac:	0018      	movs	r0, r3
    aeae:	4b2b      	ldr	r3, [pc, #172]	; (af5c <i2c_master_init+0x208>)
    aeb0:	4798      	blx	r3
    aeb2:	0004      	movs	r4, r0
	uint32_t fscl        = 1000*config->baud_rate;
    aeb4:	20fa      	movs	r0, #250	; 0xfa
    aeb6:	0080      	lsls	r0, r0, #2
    aeb8:	6833      	ldr	r3, [r6, #0]
    aeba:	4343      	muls	r3, r0
    aebc:	4699      	mov	r9, r3
	uint32_t trise       = config->sda_scl_rise_time_ns;
	int32_t  numerator   = fgclk - fscl*(10 + fgclk*trise/1000000000);
	int32_t  denominator = 2*fscl;
    aebe:	005f      	lsls	r7, r3, #1
	/* For more accurate result, can use round div. */
	tmp_baud = (int32_t)(div_ceil(numerator, denominator));

	/* Check that baudrate is supported at current speed. */
	if (tmp_baud > 255 || tmp_baud < 0) {
    aec0:	8e30      	ldrh	r0, [r6, #48]	; 0x30
    aec2:	4360      	muls	r0, r4
    aec4:	4926      	ldr	r1, [pc, #152]	; (af60 <i2c_master_init+0x20c>)
    aec6:	4b27      	ldr	r3, [pc, #156]	; (af64 <i2c_master_init+0x210>)
    aec8:	4798      	blx	r3
    aeca:	300a      	adds	r0, #10
    aecc:	464b      	mov	r3, r9
    aece:	4358      	muls	r0, r3
    aed0:	1a20      	subs	r0, r4, r0
    aed2:	19c0      	adds	r0, r0, r7
    aed4:	3801      	subs	r0, #1
    aed6:	0039      	movs	r1, r7
    aed8:	4b23      	ldr	r3, [pc, #140]	; (af68 <i2c_master_init+0x214>)
    aeda:	4798      	blx	r3
    aedc:	1e04      	subs	r4, r0, #0
    aede:	2cff      	cmp	r4, #255	; 0xff
    aee0:	d81f      	bhi.n	af22 <i2c_master_init+0x1ce>
		/* Baud rate not supported. */
		tmp_status_code = STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		/* Find baudrate for high speed */
		tmp_baud_hs = (int32_t)(div_ceil(
    aee2:	4640      	mov	r0, r8
    aee4:	4b1d      	ldr	r3, [pc, #116]	; (af5c <i2c_master_init+0x208>)
    aee6:	4798      	blx	r3
    aee8:	6871      	ldr	r1, [r6, #4]
    aeea:	23fa      	movs	r3, #250	; 0xfa
    aeec:	00db      	lsls	r3, r3, #3
    aeee:	4359      	muls	r1, r3
				system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index),
				(2000*(config->baud_rate_high_speed))) - 1);
    aef0:	1e4b      	subs	r3, r1, #1
    aef2:	1818      	adds	r0, r3, r0
    aef4:	4b1b      	ldr	r3, [pc, #108]	; (af64 <i2c_master_init+0x210>)
    aef6:	4798      	blx	r3
    aef8:	3801      	subs	r0, #1

		/* Check that baudrate is supported at current speed. */
		if (tmp_baud_hs > 255 || tmp_baud_hs < 0) {
    aefa:	28ff      	cmp	r0, #255	; 0xff
    aefc:	d811      	bhi.n	af22 <i2c_master_init+0x1ce>
    aefe:	e006      	b.n	af0e <i2c_master_init+0x1ba>
			break;
		case SYSTEM_CLOCK_APB_APBD:
			MCLK->APBDMASK.reg |= mask;
    af00:	4a0c      	ldr	r2, [pc, #48]	; (af34 <i2c_master_init+0x1e0>)
    af02:	6a11      	ldr	r1, [r2, #32]
    af04:	2302      	movs	r3, #2
    af06:	430b      	orrs	r3, r1
    af08:	6213      	str	r3, [r2, #32]
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#elif (SAML21)
	if (sercom_index == 5) {
		pm_index     = MCLK_APBDMASK_SERCOM5_Pos;
		gclk_index   = SERCOM5_GCLK_ID_CORE;
    af0a:	2418      	movs	r4, #24
    af0c:	e739      	b.n	ad82 <i2c_master_init+0x2e>
			tmp_status_code = STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
	}
	if (tmp_status_code != STATUS_ERR_BAUDRATE_UNAVAILABLE) {
		/* Baud rate acceptable. */
		i2c_module->BAUD.reg = SERCOM_I2CM_BAUD_BAUD(tmp_baud) |
    af0e:	0400      	lsls	r0, r0, #16
    af10:	23ff      	movs	r3, #255	; 0xff
    af12:	041b      	lsls	r3, r3, #16
    af14:	4018      	ands	r0, r3
    af16:	23ff      	movs	r3, #255	; 0xff
    af18:	401c      	ands	r4, r3
    af1a:	4304      	orrs	r4, r0
    af1c:	60ec      	str	r4, [r5, #12]

	/* Temporary variables. */
	uint32_t tmp_ctrla;
	int32_t tmp_baud;
	int32_t tmp_baud_hs;
	enum status_code tmp_status_code = STATUS_OK;
    af1e:	2000      	movs	r0, #0
    af20:	e000      	b.n	af24 <i2c_master_init+0x1d0>
	/* Save timeout on buffer write. */
	module->buffer_timeout = config->buffer_timeout;

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
		tmp_ctrla = SERCOM_I2CM_CTRLA_RUNSTDBY;
    af22:	2040      	movs	r0, #64	; 0x40
	/* Set sercom module to operate in I2C master mode. */
	i2c_module->CTRLA.reg = SERCOM_I2CM_CTRLA_MODE(0x5);

	/* Set config and return status. */
	return _i2c_master_set_config(module, config);
}
    af24:	b003      	add	sp, #12
    af26:	bc0c      	pop	{r2, r3}
    af28:	4690      	mov	r8, r2
    af2a:	4699      	mov	r9, r3
    af2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    af2e:	46c0      	nop			; (mov r8, r8)
    af30:	0000cba9 	.word	0x0000cba9
    af34:	40000400 	.word	0x40000400
    af38:	0000d959 	.word	0x0000d959
    af3c:	0000d8e9 	.word	0x0000d8e9
    af40:	0000c9d9 	.word	0x0000c9d9
    af44:	0000b385 	.word	0x0000b385
    af48:	0000cbe9 	.word	0x0000cbe9
    af4c:	20002850 	.word	0x20002850
    af50:	0000ca25 	.word	0x0000ca25
    af54:	0000da55 	.word	0x0000da55
    af58:	41002000 	.word	0x41002000
    af5c:	0000d97d 	.word	0x0000d97d
    af60:	3b9aca00 	.word	0x3b9aca00
    af64:	0000f82d 	.word	0x0000f82d
    af68:	0000f941 	.word	0x0000f941

0000af6c <_i2c_master_address_response>:
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    af6c:	6803      	ldr	r3, [r0, #0]

	/* Check for error and ignore bus-error; workaround for BUSSTATE stuck in
	 * BUSY */
	if (i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB) {
    af6e:	7e1a      	ldrb	r2, [r3, #24]
    af70:	0792      	lsls	r2, r2, #30
    af72:	d507      	bpl.n	af84 <_i2c_master_address_response+0x18>

		/* Clear write interrupt flag */
		i2c_module->INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    af74:	2202      	movs	r2, #2
    af76:	761a      	strb	r2, [r3, #24]

		/* Check arbitration. */
		if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_ARBLOST) {
    af78:	8b5b      	ldrh	r3, [r3, #26]
    af7a:	079b      	lsls	r3, r3, #30
			/* Return packet collision. */
			return STATUS_ERR_PACKET_COLLISION;
    af7c:	2041      	movs	r0, #65	; 0x41

		/* Return bad address value. */
		return STATUS_ERR_BAD_ADDRESS;
	}

	return STATUS_OK;
    af7e:	17db      	asrs	r3, r3, #31
    af80:	4018      	ands	r0, r3
    af82:	e00a      	b.n	af9a <_i2c_master_address_response+0x2e>
		if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_ARBLOST) {
			/* Return packet collision. */
			return STATUS_ERR_PACKET_COLLISION;
		}
	/* Check that slave responded with ack. */
	} else if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK) {
    af84:	8b5a      	ldrh	r2, [r3, #26]
    af86:	0752      	lsls	r2, r2, #29
    af88:	d506      	bpl.n	af98 <_i2c_master_address_response+0x2c>
		/* Slave busy. Issue ack and stop command. */
		i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
    af8a:	685a      	ldr	r2, [r3, #4]
    af8c:	21c0      	movs	r1, #192	; 0xc0
    af8e:	0289      	lsls	r1, r1, #10
    af90:	430a      	orrs	r2, r1
    af92:	605a      	str	r2, [r3, #4]

		/* Return bad address value. */
		return STATUS_ERR_BAD_ADDRESS;
    af94:	2018      	movs	r0, #24
    af96:	e000      	b.n	af9a <_i2c_master_address_response+0x2e>
	}

	return STATUS_OK;
    af98:	2000      	movs	r0, #0
}
    af9a:	4770      	bx	lr

0000af9c <_i2c_master_wait_for_bus>:
 * \retval STATUS_ERR_TIMEOUT  If no response was given within specified timeout
 *                             period
 */
enum status_code _i2c_master_wait_for_bus(
		struct i2c_master_module *const module)
{
    af9c:	b530      	push	{r4, r5, lr}
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    af9e:	6802      	ldr	r2, [r0, #0]

	/* Wait for reply. */
	uint16_t timeout_counter = 0;
    afa0:	2300      	movs	r3, #0
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
    afa2:	2401      	movs	r4, #1
    afa4:	2502      	movs	r5, #2
    afa6:	e004      	b.n	afb2 <_i2c_master_wait_for_bus+0x16>
			!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB)) {

		/* Check timeout condition. */
		if (++timeout_counter >= module->buffer_timeout) {
    afa8:	3301      	adds	r3, #1
    afaa:	b29b      	uxth	r3, r3
    afac:	8901      	ldrh	r1, [r0, #8]
    afae:	4299      	cmp	r1, r3
    afb0:	d907      	bls.n	afc2 <_i2c_master_wait_for_bus+0x26>

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Wait for reply. */
	uint16_t timeout_counter = 0;
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
    afb2:	7e11      	ldrb	r1, [r2, #24]
    afb4:	4221      	tst	r1, r4
    afb6:	d106      	bne.n	afc6 <_i2c_master_wait_for_bus+0x2a>
			!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB)) {
    afb8:	7e11      	ldrb	r1, [r2, #24]

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Wait for reply. */
	uint16_t timeout_counter = 0;
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
    afba:	4229      	tst	r1, r5
    afbc:	d0f4      	beq.n	afa8 <_i2c_master_wait_for_bus+0xc>
		/* Check timeout condition. */
		if (++timeout_counter >= module->buffer_timeout) {
			return STATUS_ERR_TIMEOUT;
		}
	}
	return STATUS_OK;
    afbe:	2000      	movs	r0, #0
    afc0:	e002      	b.n	afc8 <_i2c_master_wait_for_bus+0x2c>
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
			!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB)) {

		/* Check timeout condition. */
		if (++timeout_counter >= module->buffer_timeout) {
			return STATUS_ERR_TIMEOUT;
    afc2:	2012      	movs	r0, #18
    afc4:	e000      	b.n	afc8 <_i2c_master_wait_for_bus+0x2c>
		}
	}
	return STATUS_OK;
    afc6:	2000      	movs	r0, #0
}
    afc8:	bd30      	pop	{r4, r5, pc}
    afca:	46c0      	nop			; (mov r8, r8)

0000afcc <_i2c_master_send_hs_master_code>:
 * \retval STATUS_OK           No error happen
 */
enum status_code _i2c_master_send_hs_master_code(
		struct i2c_master_module *const module,
		uint8_t hs_master_code)
{
    afcc:	b510      	push	{r4, lr}
	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    afce:	6804      	ldr	r4, [r0, #0]
	/* Return value. */
	enum status_code tmp_status;

	/* Set NACK for high speed code */
	i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    afd0:	6863      	ldr	r3, [r4, #4]
    afd2:	2280      	movs	r2, #128	; 0x80
    afd4:	02d2      	lsls	r2, r2, #11
    afd6:	4313      	orrs	r3, r2
    afd8:	6063      	str	r3, [r4, #4]
	/* Send high speed code */
	i2c_module->ADDR.reg = hs_master_code;
    afda:	6261      	str	r1, [r4, #36]	; 0x24
	/* Wait for response on bus. */
	tmp_status = _i2c_master_wait_for_bus(module);
    afdc:	4b02      	ldr	r3, [pc, #8]	; (afe8 <_i2c_master_send_hs_master_code+0x1c>)
    afde:	4798      	blx	r3
	/* Clear write interrupt flag */
	i2c_module->INTFLAG.reg = SERCOM_I2CM_INTENCLR_MB;
    afe0:	2301      	movs	r3, #1
    afe2:	7623      	strb	r3, [r4, #24]

	return tmp_status;
}
    afe4:	bd10      	pop	{r4, pc}
    afe6:	46c0      	nop			; (mov r8, r8)
    afe8:	0000af9d 	.word	0x0000af9d

0000afec <_i2c_master_read_packet>:
 *
 */
static enum status_code _i2c_master_read_packet(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
    afec:	b5f0      	push	{r4, r5, r6, r7, lr}
    afee:	465f      	mov	r7, fp
    aff0:	4656      	mov	r6, sl
    aff2:	464d      	mov	r5, r9
    aff4:	4644      	mov	r4, r8
    aff6:	b4f0      	push	{r4, r5, r6, r7}
    aff8:	b083      	sub	sp, #12
    affa:	0006      	movs	r6, r0
    affc:	4689      	mov	r9, r1
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);
	Assert(packet);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    affe:	6805      	ldr	r5, [r0, #0]

	/* Return value. */
	enum status_code tmp_status;
	uint16_t tmp_data_length = packet->data_length;
    b000:	884c      	ldrh	r4, [r1, #2]

	/* Written buffer counter. */
	uint16_t counter = 0;

	bool sclsm_flag = i2c_module->CTRLA.bit.SCLSM;
    b002:	682b      	ldr	r3, [r5, #0]
    b004:	011b      	lsls	r3, r3, #4
    b006:	0fdb      	lsrs	r3, r3, #31
    b008:	469a      	mov	sl, r3

	/* Switch to high speed mode */
	if (packet->high_speed) {
    b00a:	7a4b      	ldrb	r3, [r1, #9]
    b00c:	2b00      	cmp	r3, #0
    b00e:	d002      	beq.n	b016 <_i2c_master_read_packet+0x2a>
		_i2c_master_send_hs_master_code(module, packet->hs_master_code);
    b010:	7a89      	ldrb	r1, [r1, #10]
    b012:	4b4f      	ldr	r3, [pc, #316]	; (b150 <_i2c_master_read_packet+0x164>)
    b014:	4798      	blx	r3
	}

	/* Set action to ACK. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    b016:	686a      	ldr	r2, [r5, #4]
    b018:	4b4e      	ldr	r3, [pc, #312]	; (b154 <_i2c_master_read_packet+0x168>)
    b01a:	4013      	ands	r3, r2
    b01c:	606b      	str	r3, [r5, #4]

	/* Set address and direction bit. Will send start command on bus. */
	if (packet->ten_bit_address) {
    b01e:	464b      	mov	r3, r9
    b020:	7a1b      	ldrb	r3, [r3, #8]
    b022:	2b00      	cmp	r3, #0
    b024:	d026      	beq.n	b074 <_i2c_master_read_packet+0x88>
		/*
		 * Write ADDR.ADDR[10:1] with the 10-bit address. ADDR.TENBITEN must
		 * be set and read/write bit (ADDR.ADDR[0]) equal to 0.
		 */
		i2c_module->ADDR.reg = (packet->address << 1) |
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
    b026:	464b      	mov	r3, r9
    b028:	881b      	ldrh	r3, [r3, #0]
    b02a:	005a      	lsls	r2, r3, #1
    b02c:	464b      	mov	r3, r9
    b02e:	7a5b      	ldrb	r3, [r3, #9]
    b030:	039b      	lsls	r3, r3, #14
    b032:	4313      	orrs	r3, r2
    b034:	2280      	movs	r2, #128	; 0x80
    b036:	0212      	lsls	r2, r2, #8
    b038:	4313      	orrs	r3, r2
	if (packet->ten_bit_address) {
		/*
		 * Write ADDR.ADDR[10:1] with the 10-bit address. ADDR.TENBITEN must
		 * be set and read/write bit (ADDR.ADDR[0]) equal to 0.
		 */
		i2c_module->ADDR.reg = (packet->address << 1) |
    b03a:	626b      	str	r3, [r5, #36]	; 0x24
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
			SERCOM_I2CM_ADDR_TENBITEN;

		/* Wait for response on bus. */
		tmp_status = _i2c_master_wait_for_bus(module);
    b03c:	0030      	movs	r0, r6
    b03e:	4b46      	ldr	r3, [pc, #280]	; (b158 <_i2c_master_read_packet+0x16c>)
    b040:	4798      	blx	r3

		/* Set action to ack. */
		i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    b042:	686a      	ldr	r2, [r5, #4]
    b044:	4b43      	ldr	r3, [pc, #268]	; (b154 <_i2c_master_read_packet+0x168>)
    b046:	4013      	ands	r3, r2
    b048:	606b      	str	r3, [r5, #4]
		i2c_module->ADDR.reg = (packet->address << 1) |
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
			SERCOM_I2CM_ADDR_TENBITEN;

		/* Wait for response on bus. */
		tmp_status = _i2c_master_wait_for_bus(module);
    b04a:	1e03      	subs	r3, r0, #0
		/* Set action to ack. */
		i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;

		/* Check for address response error unless previous error is
		 * detected. */
		if (tmp_status == STATUS_OK) {
    b04c:	d178      	bne.n	b140 <_i2c_master_read_packet+0x154>
			tmp_status = _i2c_master_address_response(module);
    b04e:	0030      	movs	r0, r6
    b050:	4b42      	ldr	r3, [pc, #264]	; (b15c <_i2c_master_read_packet+0x170>)
    b052:	4798      	blx	r3
    b054:	1e03      	subs	r3, r0, #0
		}

		if (tmp_status == STATUS_OK) {
    b056:	d173      	bne.n	b140 <_i2c_master_read_packet+0x154>
			/*
			 * Write ADDR[7:0] register to "11110 address[9:8] 1"
			 * ADDR.TENBITEN must be cleared
			 */
			i2c_module->ADDR.reg = (((packet->address >> 8) | 0x78) << 1) |
    b058:	464b      	mov	r3, r9
    b05a:	881b      	ldrh	r3, [r3, #0]
    b05c:	0a1b      	lsrs	r3, r3, #8
    b05e:	2278      	movs	r2, #120	; 0x78
    b060:	4313      	orrs	r3, r2
    b062:	0059      	lsls	r1, r3, #1
    b064:	464b      	mov	r3, r9
    b066:	7a5b      	ldrb	r3, [r3, #9]
    b068:	039b      	lsls	r3, r3, #14
    b06a:	3a77      	subs	r2, #119	; 0x77
    b06c:	4313      	orrs	r3, r2
    b06e:	430b      	orrs	r3, r1
    b070:	626b      	str	r3, [r5, #36]	; 0x24
    b072:	e009      	b.n	b088 <_i2c_master_read_packet+0x9c>
				I2C_TRANSFER_READ;
		} else {
			return tmp_status;
		}
	} else {
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_READ |
    b074:	464b      	mov	r3, r9
    b076:	881b      	ldrh	r3, [r3, #0]
    b078:	005a      	lsls	r2, r3, #1
    b07a:	464b      	mov	r3, r9
    b07c:	7a5b      	ldrb	r3, [r3, #9]
    b07e:	039b      	lsls	r3, r3, #14
    b080:	4313      	orrs	r3, r2
    b082:	2201      	movs	r2, #1
    b084:	4313      	orrs	r3, r2
    b086:	626b      	str	r3, [r5, #36]	; 0x24
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos);
	}

	/* Wait for response on bus. */
	tmp_status = _i2c_master_wait_for_bus(module);
    b088:	0030      	movs	r0, r6
    b08a:	4b33      	ldr	r3, [pc, #204]	; (b158 <_i2c_master_read_packet+0x16c>)
    b08c:	4798      	blx	r3

	/* Set action to ack. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    b08e:	686a      	ldr	r2, [r5, #4]
    b090:	4b30      	ldr	r3, [pc, #192]	; (b154 <_i2c_master_read_packet+0x168>)
    b092:	4013      	ands	r3, r2
    b094:	606b      	str	r3, [r5, #4]
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_READ |
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos);
	}

	/* Wait for response on bus. */
	tmp_status = _i2c_master_wait_for_bus(module);
    b096:	1e03      	subs	r3, r0, #0
	/* Set action to ack. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;

	/* Check for address response error unless previous error is
	 * detected. */
	if (tmp_status == STATUS_OK) {
    b098:	d152      	bne.n	b140 <_i2c_master_read_packet+0x154>
		tmp_status = _i2c_master_address_response(module);
    b09a:	0030      	movs	r0, r6
    b09c:	4b2f      	ldr	r3, [pc, #188]	; (b15c <_i2c_master_read_packet+0x170>)
    b09e:	4798      	blx	r3
    b0a0:	9001      	str	r0, [sp, #4]
    b0a2:	1e03      	subs	r3, r0, #0
	}

	/* Check that no error has occurred. */
	if (tmp_status == STATUS_OK) {
    b0a4:	d14c      	bne.n	b140 <_i2c_master_read_packet+0x154>
    b0a6:	3c01      	subs	r4, #1
    b0a8:	b2a4      	uxth	r4, r4
    b0aa:	2300      	movs	r3, #0
    b0ac:	4698      	mov	r8, r3
		/* Read data buffer. */
		while (tmp_data_length--) {
    b0ae:	4b2c      	ldr	r3, [pc, #176]	; (b160 <_i2c_master_read_packet+0x174>)
    b0b0:	469b      	mov	fp, r3
    b0b2:	e029      	b.n	b108 <_i2c_master_read_packet+0x11c>
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
    b0b4:	8b6b      	ldrh	r3, [r5, #26]
    b0b6:	069b      	lsls	r3, r3, #26
    b0b8:	d541      	bpl.n	b13e <_i2c_master_read_packet+0x152>
				return STATUS_ERR_PACKET_COLLISION;
			}

			if (module->send_nack && (((!sclsm_flag) && (tmp_data_length == 0)) ||
    b0ba:	7af3      	ldrb	r3, [r6, #11]
    b0bc:	2b00      	cmp	r3, #0
    b0be:	d00f      	beq.n	b0e0 <_i2c_master_read_packet+0xf4>
    b0c0:	4653      	mov	r3, sl
    b0c2:	2b00      	cmp	r3, #0
    b0c4:	d102      	bne.n	b0cc <_i2c_master_read_packet+0xe0>
    b0c6:	2c00      	cmp	r4, #0
    b0c8:	d002      	beq.n	b0d0 <_i2c_master_read_packet+0xe4>
    b0ca:	e009      	b.n	b0e0 <_i2c_master_read_packet+0xf4>
					((sclsm_flag) && (tmp_data_length == 1)))) {
    b0cc:	2c01      	cmp	r4, #1
    b0ce:	d107      	bne.n	b0e0 <_i2c_master_read_packet+0xf4>
				/* Set action to NACK */
				i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    b0d0:	686b      	ldr	r3, [r5, #4]
    b0d2:	2280      	movs	r2, #128	; 0x80
    b0d4:	02d2      	lsls	r2, r2, #11
    b0d6:	4313      	orrs	r3, r2
    b0d8:	606b      	str	r3, [r5, #4]
    b0da:	3c01      	subs	r4, #1
    b0dc:	b2a4      	uxth	r4, r4
    b0de:	e013      	b.n	b108 <_i2c_master_read_packet+0x11c>
			} else {
				/* Save data to buffer. */
				_i2c_master_wait_for_sync(module);
    b0e0:	0030      	movs	r0, r6
    b0e2:	4b20      	ldr	r3, [pc, #128]	; (b164 <_i2c_master_read_packet+0x178>)
    b0e4:	4798      	blx	r3
				packet->data[counter++] = i2c_module->DATA.reg;
    b0e6:	4643      	mov	r3, r8
    b0e8:	1c5f      	adds	r7, r3, #1
    b0ea:	b2bf      	uxth	r7, r7
    b0ec:	2328      	movs	r3, #40	; 0x28
    b0ee:	5ceb      	ldrb	r3, [r5, r3]
    b0f0:	464a      	mov	r2, r9
    b0f2:	6852      	ldr	r2, [r2, #4]
    b0f4:	4641      	mov	r1, r8
    b0f6:	5453      	strb	r3, [r2, r1]
				/* Wait for response. */
				tmp_status = _i2c_master_wait_for_bus(module);
    b0f8:	0030      	movs	r0, r6
    b0fa:	4b17      	ldr	r3, [pc, #92]	; (b158 <_i2c_master_read_packet+0x16c>)
    b0fc:	4798      	blx	r3
    b0fe:	3c01      	subs	r4, #1
    b100:	b2a4      	uxth	r4, r4
			}

			/* Check for error. */
			if (tmp_status != STATUS_OK) {
    b102:	2800      	cmp	r0, #0
    b104:	d103      	bne.n	b10e <_i2c_master_read_packet+0x122>
				/* Set action to NACK */
				i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
			} else {
				/* Save data to buffer. */
				_i2c_master_wait_for_sync(module);
				packet->data[counter++] = i2c_module->DATA.reg;
    b106:	46b8      	mov	r8, r7
	}

	/* Check that no error has occurred. */
	if (tmp_status == STATUS_OK) {
		/* Read data buffer. */
		while (tmp_data_length--) {
    b108:	455c      	cmp	r4, fp
    b10a:	d1d3      	bne.n	b0b4 <_i2c_master_read_packet+0xc8>
    b10c:	e001      	b.n	b112 <_i2c_master_read_packet+0x126>
				/* Set action to NACK */
				i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
			} else {
				/* Save data to buffer. */
				_i2c_master_wait_for_sync(module);
				packet->data[counter++] = i2c_module->DATA.reg;
    b10e:	46b8      	mov	r8, r7
				/* Wait for response. */
				tmp_status = _i2c_master_wait_for_bus(module);
    b110:	9001      	str	r0, [sp, #4]
			if (tmp_status != STATUS_OK) {
				break;
			}
		}

		if (module->send_stop) {
    b112:	7ab3      	ldrb	r3, [r6, #10]
    b114:	2b00      	cmp	r3, #0
    b116:	d007      	beq.n	b128 <_i2c_master_read_packet+0x13c>
			/* Send stop command unless arbitration is lost. */
			_i2c_master_wait_for_sync(module);
    b118:	0030      	movs	r0, r6
    b11a:	4b12      	ldr	r3, [pc, #72]	; (b164 <_i2c_master_read_packet+0x178>)
    b11c:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
    b11e:	686b      	ldr	r3, [r5, #4]
    b120:	22c0      	movs	r2, #192	; 0xc0
    b122:	0292      	lsls	r2, r2, #10
    b124:	4313      	orrs	r3, r2
    b126:	606b      	str	r3, [r5, #4]
		}

		/* Save last data to buffer. */
		_i2c_master_wait_for_sync(module);
    b128:	0030      	movs	r0, r6
    b12a:	4b0e      	ldr	r3, [pc, #56]	; (b164 <_i2c_master_read_packet+0x178>)
    b12c:	4798      	blx	r3
		packet->data[counter] = i2c_module->DATA.reg;
    b12e:	2328      	movs	r3, #40	; 0x28
    b130:	5cea      	ldrb	r2, [r5, r3]
    b132:	464b      	mov	r3, r9
    b134:	685b      	ldr	r3, [r3, #4]
    b136:	4641      	mov	r1, r8
    b138:	545a      	strb	r2, [r3, r1]
    b13a:	9b01      	ldr	r3, [sp, #4]
    b13c:	e000      	b.n	b140 <_i2c_master_read_packet+0x154>
	if (tmp_status == STATUS_OK) {
		/* Read data buffer. */
		while (tmp_data_length--) {
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
				return STATUS_ERR_PACKET_COLLISION;
    b13e:	2341      	movs	r3, #65	; 0x41
		_i2c_master_wait_for_sync(module);
		packet->data[counter] = i2c_module->DATA.reg;
	}

	return tmp_status;
}
    b140:	0018      	movs	r0, r3
    b142:	b003      	add	sp, #12
    b144:	bc3c      	pop	{r2, r3, r4, r5}
    b146:	4690      	mov	r8, r2
    b148:	4699      	mov	r9, r3
    b14a:	46a2      	mov	sl, r4
    b14c:	46ab      	mov	fp, r5
    b14e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b150:	0000afcd 	.word	0x0000afcd
    b154:	fffbffff 	.word	0xfffbffff
    b158:	0000af9d 	.word	0x0000af9d
    b15c:	0000af6d 	.word	0x0000af6d
    b160:	0000ffff 	.word	0x0000ffff
    b164:	0000ad49 	.word	0x0000ad49

0000b168 <_i2c_master_write_packet>:
 *                                      acknowledged the address
 */
static enum status_code _i2c_master_write_packet(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
    b168:	b5f0      	push	{r4, r5, r6, r7, lr}
    b16a:	465f      	mov	r7, fp
    b16c:	4656      	mov	r6, sl
    b16e:	464d      	mov	r5, r9
    b170:	4644      	mov	r4, r8
    b172:	b4f0      	push	{r4, r5, r6, r7}
    b174:	b083      	sub	sp, #12
    b176:	0006      	movs	r6, r0
    b178:	000f      	movs	r7, r1
	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    b17a:	6805      	ldr	r5, [r0, #0]

	/* Return value. */
	enum status_code tmp_status;
	uint16_t tmp_data_length = packet->data_length;
    b17c:	884c      	ldrh	r4, [r1, #2]

	_i2c_master_wait_for_sync(module);
    b17e:	4b31      	ldr	r3, [pc, #196]	; (b244 <_i2c_master_write_packet+0xdc>)
    b180:	4798      	blx	r3

	/* Switch to high speed mode */
	if (packet->high_speed) {
    b182:	7a7b      	ldrb	r3, [r7, #9]
    b184:	2b00      	cmp	r3, #0
    b186:	d003      	beq.n	b190 <_i2c_master_write_packet+0x28>
		_i2c_master_send_hs_master_code(module, packet->hs_master_code);
    b188:	7ab9      	ldrb	r1, [r7, #10]
    b18a:	0030      	movs	r0, r6
    b18c:	4b2e      	ldr	r3, [pc, #184]	; (b248 <_i2c_master_write_packet+0xe0>)
    b18e:	4798      	blx	r3
	}

	/* Set action to ACK. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    b190:	686a      	ldr	r2, [r5, #4]
    b192:	4b2e      	ldr	r3, [pc, #184]	; (b24c <_i2c_master_write_packet+0xe4>)
    b194:	4013      	ands	r3, r2
    b196:	606b      	str	r3, [r5, #4]

	/* Set address and direction bit. Will send start command on bus. */
	if (packet->ten_bit_address) {
    b198:	7a3b      	ldrb	r3, [r7, #8]
    b19a:	2b00      	cmp	r3, #0
    b19c:	d009      	beq.n	b1b2 <_i2c_master_write_packet+0x4a>
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
    b19e:	883b      	ldrh	r3, [r7, #0]
    b1a0:	005a      	lsls	r2, r3, #1
    b1a2:	7a7b      	ldrb	r3, [r7, #9]
    b1a4:	039b      	lsls	r3, r3, #14
    b1a6:	4313      	orrs	r3, r2
    b1a8:	2280      	movs	r2, #128	; 0x80
    b1aa:	0212      	lsls	r2, r2, #8
    b1ac:	4313      	orrs	r3, r2
	/* Set action to ACK. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;

	/* Set address and direction bit. Will send start command on bus. */
	if (packet->ten_bit_address) {
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
    b1ae:	626b      	str	r3, [r5, #36]	; 0x24
    b1b0:	e005      	b.n	b1be <_i2c_master_write_packet+0x56>
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
			SERCOM_I2CM_ADDR_TENBITEN;
	} else {
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
    b1b2:	883b      	ldrh	r3, [r7, #0]
    b1b4:	005a      	lsls	r2, r3, #1
    b1b6:	7a7b      	ldrb	r3, [r7, #9]
    b1b8:	039b      	lsls	r3, r3, #14
    b1ba:	4313      	orrs	r3, r2
    b1bc:	626b      	str	r3, [r5, #36]	; 0x24
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos);
	}
	/* Wait for response on bus. */
	tmp_status = _i2c_master_wait_for_bus(module);
    b1be:	0030      	movs	r0, r6
    b1c0:	4b23      	ldr	r3, [pc, #140]	; (b250 <_i2c_master_write_packet+0xe8>)
    b1c2:	4798      	blx	r3

	/* Check for address response error unless previous error is
	 * detected. */
	if (tmp_status == STATUS_OK) {
    b1c4:	2800      	cmp	r0, #0
    b1c6:	d136      	bne.n	b236 <_i2c_master_write_packet+0xce>
		tmp_status = _i2c_master_address_response(module);
    b1c8:	0030      	movs	r0, r6
    b1ca:	4b22      	ldr	r3, [pc, #136]	; (b254 <_i2c_master_write_packet+0xec>)
    b1cc:	4798      	blx	r3
    b1ce:	1e03      	subs	r3, r0, #0
    b1d0:	9001      	str	r0, [sp, #4]
	}

	/* Check that no error has occurred. */
	if (tmp_status == STATUS_OK) {
    b1d2:	d130      	bne.n	b236 <_i2c_master_write_packet+0xce>
    b1d4:	46a0      	mov	r8, r4
    b1d6:	2400      	movs	r4, #0
		uint16_t buffer_counter = 0;

		/* Write data buffer. */
		while (tmp_data_length--) {
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
    b1d8:	3320      	adds	r3, #32
    b1da:	4699      	mov	r9, r3
				return STATUS_ERR_PACKET_COLLISION;
			}

			/* Write byte to slave. */
			_i2c_master_wait_for_sync(module);
    b1dc:	4b19      	ldr	r3, [pc, #100]	; (b244 <_i2c_master_write_packet+0xdc>)
    b1de:	469b      	mov	fp, r3
			i2c_module->DATA.reg = packet->data[buffer_counter++];

			/* Wait for response. */
			tmp_status = _i2c_master_wait_for_bus(module);
    b1e0:	4b1b      	ldr	r3, [pc, #108]	; (b250 <_i2c_master_write_packet+0xe8>)
    b1e2:	469a      	mov	sl, r3
    b1e4:	e011      	b.n	b20a <_i2c_master_write_packet+0xa2>
		uint16_t buffer_counter = 0;

		/* Write data buffer. */
		while (tmp_data_length--) {
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
    b1e6:	8b6b      	ldrh	r3, [r5, #26]
    b1e8:	464a      	mov	r2, r9
    b1ea:	4213      	tst	r3, r2
    b1ec:	d022      	beq.n	b234 <_i2c_master_write_packet+0xcc>
				return STATUS_ERR_PACKET_COLLISION;
			}

			/* Write byte to slave. */
			_i2c_master_wait_for_sync(module);
    b1ee:	0030      	movs	r0, r6
    b1f0:	47d8      	blx	fp
			i2c_module->DATA.reg = packet->data[buffer_counter++];
    b1f2:	687b      	ldr	r3, [r7, #4]
    b1f4:	5d1a      	ldrb	r2, [r3, r4]
    b1f6:	2328      	movs	r3, #40	; 0x28
    b1f8:	54ea      	strb	r2, [r5, r3]

			/* Wait for response. */
			tmp_status = _i2c_master_wait_for_bus(module);
    b1fa:	0030      	movs	r0, r6
    b1fc:	47d0      	blx	sl

			/* Check for error. */
			if (tmp_status != STATUS_OK) {
    b1fe:	2800      	cmp	r0, #0
    b200:	d106      	bne.n	b210 <_i2c_master_write_packet+0xa8>
				break;
			}

			/* Check for NACK from slave. */
			if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK) {
    b202:	8b6b      	ldrh	r3, [r5, #26]
    b204:	3401      	adds	r4, #1
    b206:	075b      	lsls	r3, r3, #29
    b208:	d404      	bmi.n	b214 <_i2c_master_write_packet+0xac>
	if (tmp_status == STATUS_OK) {
		/* Buffer counter. */
		uint16_t buffer_counter = 0;

		/* Write data buffer. */
		while (tmp_data_length--) {
    b20a:	45a0      	cmp	r8, r4
    b20c:	d1eb      	bne.n	b1e6 <_i2c_master_write_packet+0x7e>
    b20e:	e003      	b.n	b218 <_i2c_master_write_packet+0xb0>
			/* Write byte to slave. */
			_i2c_master_wait_for_sync(module);
			i2c_module->DATA.reg = packet->data[buffer_counter++];

			/* Wait for response. */
			tmp_status = _i2c_master_wait_for_bus(module);
    b210:	9001      	str	r0, [sp, #4]
    b212:	e001      	b.n	b218 <_i2c_master_write_packet+0xb0>
			}

			/* Check for NACK from slave. */
			if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK) {
				/* Return bad data value. */
				tmp_status = STATUS_ERR_OVERFLOW;
    b214:	231e      	movs	r3, #30
    b216:	9301      	str	r3, [sp, #4]
				break;
			}
		}

		if (module->send_stop) {
    b218:	7ab3      	ldrb	r3, [r6, #10]
    b21a:	9801      	ldr	r0, [sp, #4]
    b21c:	2b00      	cmp	r3, #0
    b21e:	d00a      	beq.n	b236 <_i2c_master_write_packet+0xce>
			/* Stop command */
			_i2c_master_wait_for_sync(module);
    b220:	0030      	movs	r0, r6
    b222:	4b08      	ldr	r3, [pc, #32]	; (b244 <_i2c_master_write_packet+0xdc>)
    b224:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
    b226:	686b      	ldr	r3, [r5, #4]
    b228:	22c0      	movs	r2, #192	; 0xc0
    b22a:	0292      	lsls	r2, r2, #10
    b22c:	4313      	orrs	r3, r2
    b22e:	606b      	str	r3, [r5, #4]
    b230:	9801      	ldr	r0, [sp, #4]
    b232:	e000      	b.n	b236 <_i2c_master_write_packet+0xce>

		/* Write data buffer. */
		while (tmp_data_length--) {
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
				return STATUS_ERR_PACKET_COLLISION;
    b234:	2041      	movs	r0, #65	; 0x41
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
		}
	}

	return tmp_status;
}
    b236:	b003      	add	sp, #12
    b238:	bc3c      	pop	{r2, r3, r4, r5}
    b23a:	4690      	mov	r8, r2
    b23c:	4699      	mov	r9, r3
    b23e:	46a2      	mov	sl, r4
    b240:	46ab      	mov	fp, r5
    b242:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b244:	0000ad49 	.word	0x0000ad49
    b248:	0000afcd 	.word	0x0000afcd
    b24c:	fffbffff 	.word	0xfffbffff
    b250:	0000af9d 	.word	0x0000af9d
    b254:	0000af6d 	.word	0x0000af6d

0000b258 <i2c_master_read_packet_wait>:
 *                                      acknowledged the address
 */
enum status_code i2c_master_read_packet_wait(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
    b258:	b510      	push	{r4, lr}
	Assert(module->hw);
	Assert(packet);

#if I2C_MASTER_CALLBACK_MODE == true
	/* Check if the I2C module is busy with a job. */
	if (module->buffer_remaining > 0) {
    b25a:	8b83      	ldrh	r3, [r0, #28]
    b25c:	b29b      	uxth	r3, r3
		return STATUS_BUSY;
    b25e:	2205      	movs	r2, #5
	Assert(module->hw);
	Assert(packet);

#if I2C_MASTER_CALLBACK_MODE == true
	/* Check if the I2C module is busy with a job. */
	if (module->buffer_remaining > 0) {
    b260:	2b00      	cmp	r3, #0
    b262:	d105      	bne.n	b270 <i2c_master_read_packet_wait+0x18>
		return STATUS_BUSY;
	}
#endif

	module->send_stop = true;
    b264:	3301      	adds	r3, #1
    b266:	7283      	strb	r3, [r0, #10]
	module->send_nack = true;
    b268:	72c3      	strb	r3, [r0, #11]

	return _i2c_master_read_packet(module, packet);
    b26a:	4b02      	ldr	r3, [pc, #8]	; (b274 <i2c_master_read_packet_wait+0x1c>)
    b26c:	4798      	blx	r3
    b26e:	0002      	movs	r2, r0
}
    b270:	0010      	movs	r0, r2
    b272:	bd10      	pop	{r4, pc}
    b274:	0000afed 	.word	0x0000afed

0000b278 <i2c_master_write_packet_wait>:
 *                                      last data sent
 */
enum status_code i2c_master_write_packet_wait(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
    b278:	b510      	push	{r4, lr}
	Assert(module->hw);
	Assert(packet);

#if I2C_MASTER_CALLBACK_MODE == true
	/* Check if the I2C module is busy with a job */
	if (module->buffer_remaining > 0) {
    b27a:	8b83      	ldrh	r3, [r0, #28]
    b27c:	b29b      	uxth	r3, r3
		return STATUS_BUSY;
    b27e:	2205      	movs	r2, #5
	Assert(module->hw);
	Assert(packet);

#if I2C_MASTER_CALLBACK_MODE == true
	/* Check if the I2C module is busy with a job */
	if (module->buffer_remaining > 0) {
    b280:	2b00      	cmp	r3, #0
    b282:	d105      	bne.n	b290 <i2c_master_write_packet_wait+0x18>
		return STATUS_BUSY;
	}
#endif

	module->send_stop = true;
    b284:	3301      	adds	r3, #1
    b286:	7283      	strb	r3, [r0, #10]
	module->send_nack = true;
    b288:	72c3      	strb	r3, [r0, #11]

	return _i2c_master_write_packet(module, packet);
    b28a:	4b02      	ldr	r3, [pc, #8]	; (b294 <i2c_master_write_packet_wait+0x1c>)
    b28c:	4798      	blx	r3
    b28e:	0002      	movs	r2, r0
}
    b290:	0010      	movs	r0, r2
    b292:	bd10      	pop	{r4, pc}
    b294:	0000b169 	.word	0x0000b169

0000b298 <i2c_master_write_packet_wait_no_stop>:
 *                                      more data
 */
enum status_code i2c_master_write_packet_wait_no_stop(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
    b298:	b510      	push	{r4, lr}
	Assert(module->hw);
	Assert(packet);

#if I2C_MASTER_CALLBACK_MODE == true
	/* Check if the I2C module is busy with a job */
	if (module->buffer_remaining > 0) {
    b29a:	8b83      	ldrh	r3, [r0, #28]
    b29c:	b29b      	uxth	r3, r3
		return STATUS_BUSY;
    b29e:	2205      	movs	r2, #5
	Assert(module->hw);
	Assert(packet);

#if I2C_MASTER_CALLBACK_MODE == true
	/* Check if the I2C module is busy with a job */
	if (module->buffer_remaining > 0) {
    b2a0:	2b00      	cmp	r3, #0
    b2a2:	d105      	bne.n	b2b0 <i2c_master_write_packet_wait_no_stop+0x18>
		return STATUS_BUSY;
	}
#endif

	module->send_stop = false;
    b2a4:	7283      	strb	r3, [r0, #10]
	module->send_nack = true;
    b2a6:	3301      	adds	r3, #1
    b2a8:	72c3      	strb	r3, [r0, #11]

	return _i2c_master_write_packet(module, packet);
    b2aa:	4b02      	ldr	r3, [pc, #8]	; (b2b4 <i2c_master_write_packet_wait_no_stop+0x1c>)
    b2ac:	4798      	blx	r3
    b2ae:	0002      	movs	r2, r0
}
    b2b0:	0010      	movs	r0, r2
    b2b2:	bd10      	pop	{r4, pc}
    b2b4:	0000b169 	.word	0x0000b169

0000b2b8 <_i2c_master_wait_for_sync>:
{
	/* Sanity check */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_hw = &(module->hw->I2CM);
    b2b8:	6801      	ldr	r1, [r0, #0]
		const struct i2c_master_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
    b2ba:	2207      	movs	r2, #7
	SercomI2cm *const i2c_hw = &(module->hw->I2CM);

#if defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_1)
	return (i2c_hw->STATUS.reg & SERCOM_I2CM_STATUS_SYNCBUSY);
#elif defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_2)
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
    b2bc:	69cb      	ldr	r3, [r1, #28]
		const struct i2c_master_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
    b2be:	421a      	tst	r2, r3
    b2c0:	d1fc      	bne.n	b2bc <_i2c_master_wait_for_sync+0x4>
		/* Wait for I2C module to sync. */
	}
}
    b2c2:	4770      	bx	lr

0000b2c4 <_i2c_master_read>:
 *
 * \param[in,out] module  Pointer to software module structure
 */
static void _i2c_master_read(
		struct i2c_master_module *const module)
{
    b2c4:	b570      	push	{r4, r5, r6, lr}
    b2c6:	0004      	movs	r4, r0
	/* Sanity check arguments. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    b2c8:	6806      	ldr	r6, [r0, #0]
	bool sclsm_flag = i2c_module->CTRLA.bit.SCLSM;
    b2ca:	6832      	ldr	r2, [r6, #0]

	/* Find index to save next value in buffer */
	uint16_t buffer_index = module->buffer_length;
    b2cc:	8b43      	ldrh	r3, [r0, #26]
	buffer_index -= module->buffer_remaining;
    b2ce:	8b85      	ldrh	r5, [r0, #28]
    b2d0:	1b5d      	subs	r5, r3, r5
    b2d2:	b2ad      	uxth	r5, r5

	module->buffer_remaining--;
    b2d4:	8b83      	ldrh	r3, [r0, #28]
    b2d6:	3b01      	subs	r3, #1
    b2d8:	b29b      	uxth	r3, r3
    b2da:	8383      	strh	r3, [r0, #28]

	if (sclsm_flag) {
    b2dc:	0113      	lsls	r3, r2, #4
    b2de:	d50c      	bpl.n	b2fa <_i2c_master_read+0x36>
		if (module->send_nack && module->buffer_remaining == 1) {
    b2e0:	7ac3      	ldrb	r3, [r0, #11]
    b2e2:	2b00      	cmp	r3, #0
    b2e4:	d015      	beq.n	b312 <_i2c_master_read+0x4e>
    b2e6:	8b83      	ldrh	r3, [r0, #28]
    b2e8:	b29b      	uxth	r3, r3
    b2ea:	2b01      	cmp	r3, #1
    b2ec:	d111      	bne.n	b312 <_i2c_master_read+0x4e>
			/* Set action to NACK. */
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    b2ee:	6873      	ldr	r3, [r6, #4]
    b2f0:	2280      	movs	r2, #128	; 0x80
    b2f2:	02d2      	lsls	r2, r2, #11
    b2f4:	4313      	orrs	r3, r2
    b2f6:	6073      	str	r3, [r6, #4]
    b2f8:	e00b      	b.n	b312 <_i2c_master_read+0x4e>
		}
	} else {
		if (module->send_nack && module->buffer_remaining == 0) {
    b2fa:	7ac3      	ldrb	r3, [r0, #11]
    b2fc:	2b00      	cmp	r3, #0
    b2fe:	d008      	beq.n	b312 <_i2c_master_read+0x4e>
    b300:	8b83      	ldrh	r3, [r0, #28]
    b302:	b29b      	uxth	r3, r3
    b304:	2b00      	cmp	r3, #0
    b306:	d104      	bne.n	b312 <_i2c_master_read+0x4e>
			/* Set action to NACK. */
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    b308:	6873      	ldr	r3, [r6, #4]
    b30a:	2280      	movs	r2, #128	; 0x80
    b30c:	02d2      	lsls	r2, r2, #11
    b30e:	4313      	orrs	r3, r2
    b310:	6073      	str	r3, [r6, #4]
		}
	}

	if (module->buffer_remaining == 0) {
    b312:	8ba3      	ldrh	r3, [r4, #28]
    b314:	b29b      	uxth	r3, r3
    b316:	2b00      	cmp	r3, #0
    b318:	d10a      	bne.n	b330 <_i2c_master_read+0x6c>
		if (module->send_stop) {
    b31a:	7aa3      	ldrb	r3, [r4, #10]
    b31c:	2b00      	cmp	r3, #0
    b31e:	d007      	beq.n	b330 <_i2c_master_read+0x6c>
			/* Send stop condition */
			_i2c_master_wait_for_sync(module);
    b320:	0020      	movs	r0, r4
    b322:	4b08      	ldr	r3, [pc, #32]	; (b344 <_i2c_master_read+0x80>)
    b324:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
    b326:	6873      	ldr	r3, [r6, #4]
    b328:	22c0      	movs	r2, #192	; 0xc0
    b32a:	0292      	lsls	r2, r2, #10
    b32c:	4313      	orrs	r3, r2
    b32e:	6073      	str	r3, [r6, #4]
		}
	}
	
	/* Read byte from slave and put in buffer */
	_i2c_master_wait_for_sync(module);
    b330:	0020      	movs	r0, r4
    b332:	4b04      	ldr	r3, [pc, #16]	; (b344 <_i2c_master_read+0x80>)
    b334:	4798      	blx	r3
	module->buffer[buffer_index] = i2c_module->DATA.reg;
    b336:	6a23      	ldr	r3, [r4, #32]
    b338:	195d      	adds	r5, r3, r5
    b33a:	2328      	movs	r3, #40	; 0x28
    b33c:	5cf3      	ldrb	r3, [r6, r3]
    b33e:	b2db      	uxtb	r3, r3
    b340:	702b      	strb	r3, [r5, #0]
}
    b342:	bd70      	pop	{r4, r5, r6, pc}
    b344:	0000b2b9 	.word	0x0000b2b9

0000b348 <_i2c_master_write>:
 * Write next data. Used by interrupt handler to send next data byte to slave.
 *
 * \param[in,out] module  Pointer to software module structure
 */
static void _i2c_master_write(struct i2c_master_module *const module)
{
    b348:	b570      	push	{r4, r5, r6, lr}
    b34a:	0004      	movs	r4, r0
	/* Sanity check arguments. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    b34c:	6806      	ldr	r6, [r0, #0]

	/* Check for ack from slave */
	if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK)
    b34e:	8b73      	ldrh	r3, [r6, #26]
    b350:	075b      	lsls	r3, r3, #29
    b352:	d503      	bpl.n	b35c <_i2c_master_write+0x14>
	{
		/* Set status */
		module->status = STATUS_ERR_OVERFLOW;
    b354:	221e      	movs	r2, #30
    b356:	2325      	movs	r3, #37	; 0x25
    b358:	54c2      	strb	r2, [r0, r3]
		/* Do not write more data */
		return;
    b35a:	e00f      	b.n	b37c <_i2c_master_write+0x34>
	}

	/* Find index to get next byte in buffer */
	uint16_t buffer_index = module->buffer_length;
    b35c:	8b43      	ldrh	r3, [r0, #26]
	buffer_index -= module->buffer_remaining;
    b35e:	8b85      	ldrh	r5, [r0, #28]
    b360:	1b5d      	subs	r5, r3, r5
    b362:	b2ad      	uxth	r5, r5

	module->buffer_remaining--;
    b364:	8b83      	ldrh	r3, [r0, #28]
    b366:	3b01      	subs	r3, #1
    b368:	b29b      	uxth	r3, r3
    b36a:	8383      	strh	r3, [r0, #28]

	/* Write byte from buffer to slave */
	_i2c_master_wait_for_sync(module);
    b36c:	4b04      	ldr	r3, [pc, #16]	; (b380 <_i2c_master_write+0x38>)
    b36e:	4798      	blx	r3
	i2c_module->DATA.reg = module->buffer[buffer_index];
    b370:	6a23      	ldr	r3, [r4, #32]
    b372:	195d      	adds	r5, r3, r5
    b374:	782b      	ldrb	r3, [r5, #0]
    b376:	b2db      	uxtb	r3, r3
    b378:	2228      	movs	r2, #40	; 0x28
    b37a:	54b3      	strb	r3, [r6, r2]
}
    b37c:	bd70      	pop	{r4, r5, r6, pc}
    b37e:	46c0      	nop			; (mov r8, r8)
    b380:	0000b2b9 	.word	0x0000b2b9

0000b384 <_i2c_master_interrupt_handler>:
 *
 * \param[in] instance  SERCOM instance that triggered the interrupt
 */
void _i2c_master_interrupt_handler(
		uint8_t instance)
{
    b384:	b570      	push	{r4, r5, r6, lr}
	/* Get software module for callback handling */
	struct i2c_master_module *module =
    b386:	0080      	lsls	r0, r0, #2
    b388:	4b6f      	ldr	r3, [pc, #444]	; (b548 <_i2c_master_interrupt_handler+0x1c4>)
    b38a:	58c4      	ldr	r4, [r0, r3]
			(struct i2c_master_module*)_sercom_instances[instance];

	Assert(module);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    b38c:	6825      	ldr	r5, [r4, #0]
	bool sclsm_flag = i2c_module->CTRLA.bit.SCLSM;
    b38e:	682b      	ldr	r3, [r5, #0]
    b390:	011b      	lsls	r3, r3, #4
    b392:	0fda      	lsrs	r2, r3, #31

	/* Combine callback registered and enabled masks */
	uint8_t callback_mask = module->enabled_callback;
    b394:	7e63      	ldrb	r3, [r4, #25]
	callback_mask &= module->registered_callback;
    b396:	7e26      	ldrb	r6, [r4, #24]
    b398:	401e      	ands	r6, r3

	/* Check if the module should respond to address ack */
	if ((module->buffer_length <= 0) && (module->buffer_remaining > 0)) {
    b39a:	8b63      	ldrh	r3, [r4, #26]
    b39c:	b29b      	uxth	r3, r3
    b39e:	2b00      	cmp	r3, #0
    b3a0:	d135      	bne.n	b40e <_i2c_master_interrupt_handler+0x8a>
    b3a2:	8ba3      	ldrh	r3, [r4, #28]
    b3a4:	b29b      	uxth	r3, r3
    b3a6:	2b00      	cmp	r3, #0
    b3a8:	d031      	beq.n	b40e <_i2c_master_interrupt_handler+0x8a>
	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Check for error. Ignore bus-error; workaround for bus state stuck in
	 * BUSY.
	 */
	if (i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB)
    b3aa:	7e2b      	ldrb	r3, [r5, #24]
    b3ac:	07db      	lsls	r3, r3, #31
    b3ae:	d508      	bpl.n	b3c2 <_i2c_master_interrupt_handler+0x3e>
	{
		/* Clear write interrupt flag */
		i2c_module->INTFLAG.reg = SERCOM_I2CM_INTENCLR_MB;
    b3b0:	2301      	movs	r3, #1
    b3b2:	762b      	strb	r3, [r5, #24]

		/* Check arbitration */
		if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_ARBLOST) {
    b3b4:	8b6b      	ldrh	r3, [r5, #26]
    b3b6:	079b      	lsls	r3, r3, #30
    b3b8:	d516      	bpl.n	b3e8 <_i2c_master_interrupt_handler+0x64>
			/* Return busy */
			module->status = STATUS_ERR_PACKET_COLLISION;
    b3ba:	2241      	movs	r2, #65	; 0x41
    b3bc:	2325      	movs	r3, #37	; 0x25
    b3be:	54e2      	strb	r2, [r4, r3]
    b3c0:	e012      	b.n	b3e8 <_i2c_master_interrupt_handler+0x64>
		}
	} else if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK) {
    b3c2:	8b6b      	ldrh	r3, [r5, #26]
    b3c4:	075b      	lsls	r3, r3, #29
    b3c6:	d50f      	bpl.n	b3e8 <_i2c_master_interrupt_handler+0x64>
		/* Return bad address value */
		module->status           = STATUS_ERR_BAD_ADDRESS;
    b3c8:	2218      	movs	r2, #24
    b3ca:	2325      	movs	r3, #37	; 0x25
    b3cc:	54e2      	strb	r2, [r4, r3]
		module->buffer_remaining = 0;
    b3ce:	2300      	movs	r3, #0
    b3d0:	83a3      	strh	r3, [r4, #28]

		if (module->send_stop) {
    b3d2:	7aa3      	ldrb	r3, [r4, #10]
    b3d4:	2b00      	cmp	r3, #0
    b3d6:	d007      	beq.n	b3e8 <_i2c_master_interrupt_handler+0x64>
			/* Send stop condition */
			_i2c_master_wait_for_sync(module);
    b3d8:	0020      	movs	r0, r4
    b3da:	4b5c      	ldr	r3, [pc, #368]	; (b54c <_i2c_master_interrupt_handler+0x1c8>)
    b3dc:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
    b3de:	686b      	ldr	r3, [r5, #4]
    b3e0:	22c0      	movs	r2, #192	; 0xc0
    b3e2:	0292      	lsls	r2, r2, #10
    b3e4:	4313      	orrs	r3, r2
    b3e6:	606b      	str	r3, [r5, #4]
		}
	}

	module->buffer_length = module->buffer_remaining;
    b3e8:	8ba3      	ldrh	r3, [r4, #28]
    b3ea:	b29b      	uxth	r3, r3
    b3ec:	8363      	strh	r3, [r4, #26]

	/* Check for status OK. */
	if (module->status == STATUS_BUSY) {
    b3ee:	2325      	movs	r3, #37	; 0x25
    b3f0:	5ce3      	ldrb	r3, [r4, r3]
    b3f2:	2b05      	cmp	r3, #5
    b3f4:	d156      	bne.n	b4a4 <_i2c_master_interrupt_handler+0x120>
		/* Call function based on transfer direction. */
		if (module->transfer_direction == I2C_TRANSFER_WRITE) {
    b3f6:	331f      	adds	r3, #31
    b3f8:	5ce3      	ldrb	r3, [r4, r3]
    b3fa:	2b00      	cmp	r3, #0
    b3fc:	d103      	bne.n	b406 <_i2c_master_interrupt_handler+0x82>
			_i2c_master_write(module);
    b3fe:	0020      	movs	r0, r4
    b400:	4b53      	ldr	r3, [pc, #332]	; (b550 <_i2c_master_interrupt_handler+0x1cc>)
    b402:	4798      	blx	r3
    b404:	e04e      	b.n	b4a4 <_i2c_master_interrupt_handler+0x120>
		} else {
			_i2c_master_read(module);
    b406:	0020      	movs	r0, r4
    b408:	4b52      	ldr	r3, [pc, #328]	; (b554 <_i2c_master_interrupt_handler+0x1d0>)
    b40a:	4798      	blx	r3
    b40c:	e04a      	b.n	b4a4 <_i2c_master_interrupt_handler+0x120>
	if ((module->buffer_length <= 0) && (module->buffer_remaining > 0)) {
		/* Call function for address response */
		_i2c_master_async_address_response(module);

	/* Check if buffer write is done */
	} else if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
    b40e:	8b63      	ldrh	r3, [r4, #26]
    b410:	b29b      	uxth	r3, r3
    b412:	2b00      	cmp	r3, #0
    b414:	d026      	beq.n	b464 <_i2c_master_interrupt_handler+0xe0>
    b416:	8ba3      	ldrh	r3, [r4, #28]
    b418:	b29b      	uxth	r3, r3
    b41a:	2b00      	cmp	r3, #0
    b41c:	d122      	bne.n	b464 <_i2c_master_interrupt_handler+0xe0>
			(module->status == STATUS_BUSY) &&
    b41e:	3325      	adds	r3, #37	; 0x25
    b420:	5ce3      	ldrb	r3, [r4, r3]
	if ((module->buffer_length <= 0) && (module->buffer_remaining > 0)) {
		/* Call function for address response */
		_i2c_master_async_address_response(module);

	/* Check if buffer write is done */
	} else if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
    b422:	2b05      	cmp	r3, #5
    b424:	d11e      	bne.n	b464 <_i2c_master_interrupt_handler+0xe0>
			(module->status == STATUS_BUSY) &&
			(module->transfer_direction == I2C_TRANSFER_WRITE)) {
    b426:	331f      	adds	r3, #31
    b428:	5ce3      	ldrb	r3, [r4, r3]
		/* Call function for address response */
		_i2c_master_async_address_response(module);

	/* Check if buffer write is done */
	} else if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
			(module->status == STATUS_BUSY) &&
    b42a:	2b00      	cmp	r3, #0
    b42c:	d11a      	bne.n	b464 <_i2c_master_interrupt_handler+0xe0>
			(module->transfer_direction == I2C_TRANSFER_WRITE)) {
		/* Stop packet operation */
		i2c_module->INTENCLR.reg =
    b42e:	3303      	adds	r3, #3
    b430:	752b      	strb	r3, [r5, #20]
				SERCOM_I2CM_INTENCLR_MB | SERCOM_I2CM_INTENCLR_SB;

		module->buffer_length = 0;
    b432:	2300      	movs	r3, #0
    b434:	8363      	strh	r3, [r4, #26]
		module->status        = STATUS_OK;
    b436:	3325      	adds	r3, #37	; 0x25
    b438:	2200      	movs	r2, #0
    b43a:	54e2      	strb	r2, [r4, r3]

		if (module->send_stop) {
    b43c:	7aa3      	ldrb	r3, [r4, #10]
    b43e:	2b00      	cmp	r3, #0
    b440:	d008      	beq.n	b454 <_i2c_master_interrupt_handler+0xd0>
			/* Send stop condition */
			_i2c_master_wait_for_sync(module);
    b442:	0020      	movs	r0, r4
    b444:	4b41      	ldr	r3, [pc, #260]	; (b54c <_i2c_master_interrupt_handler+0x1c8>)
    b446:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
    b448:	686b      	ldr	r3, [r5, #4]
    b44a:	22c0      	movs	r2, #192	; 0xc0
    b44c:	0292      	lsls	r2, r2, #10
    b44e:	4313      	orrs	r3, r2
    b450:	606b      	str	r3, [r5, #4]
    b452:	e001      	b.n	b458 <_i2c_master_interrupt_handler+0xd4>
		} else {
			/* Clear write interrupt flag */
			i2c_module->INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    b454:	2301      	movs	r3, #1
    b456:	762b      	strb	r3, [r5, #24]
		}
		
		if (callback_mask & (1 << I2C_MASTER_CALLBACK_WRITE_COMPLETE)) {
    b458:	07f3      	lsls	r3, r6, #31
    b45a:	d523      	bpl.n	b4a4 <_i2c_master_interrupt_handler+0x120>
			module->callbacks[I2C_MASTER_CALLBACK_WRITE_COMPLETE](module);
    b45c:	68e3      	ldr	r3, [r4, #12]
    b45e:	0020      	movs	r0, r4
    b460:	4798      	blx	r3
    b462:	e01f      	b.n	b4a4 <_i2c_master_interrupt_handler+0x120>
		}

	/* Continue buffer write/read */
	} else if ((module->buffer_length > 0) && (module->buffer_remaining > 0)){
    b464:	8b63      	ldrh	r3, [r4, #26]
    b466:	b29b      	uxth	r3, r3
    b468:	2b00      	cmp	r3, #0
    b46a:	d01b      	beq.n	b4a4 <_i2c_master_interrupt_handler+0x120>
    b46c:	8ba3      	ldrh	r3, [r4, #28]
    b46e:	b29b      	uxth	r3, r3
    b470:	2b00      	cmp	r3, #0
    b472:	d017      	beq.n	b4a4 <_i2c_master_interrupt_handler+0x120>
		/* Check that bus ownership is not lost */
		if ((!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) &&
    b474:	8b6b      	ldrh	r3, [r5, #26]
    b476:	069b      	lsls	r3, r3, #26
    b478:	d409      	bmi.n	b48e <_i2c_master_interrupt_handler+0x10a>
    b47a:	2a00      	cmp	r2, #0
    b47c:	d003      	beq.n	b486 <_i2c_master_interrupt_handler+0x102>
				(!(sclsm_flag && (module->buffer_remaining == 1))))	{
    b47e:	8ba3      	ldrh	r3, [r4, #28]
    b480:	b29b      	uxth	r3, r3
    b482:	2b01      	cmp	r3, #1
    b484:	d003      	beq.n	b48e <_i2c_master_interrupt_handler+0x10a>
			module->status = STATUS_ERR_PACKET_COLLISION;
    b486:	2241      	movs	r2, #65	; 0x41
    b488:	2325      	movs	r3, #37	; 0x25
    b48a:	54e2      	strb	r2, [r4, r3]
    b48c:	e00a      	b.n	b4a4 <_i2c_master_interrupt_handler+0x120>
		} else if (module->transfer_direction == I2C_TRANSFER_WRITE) {
    b48e:	2324      	movs	r3, #36	; 0x24
    b490:	5ce3      	ldrb	r3, [r4, r3]
    b492:	2b00      	cmp	r3, #0
    b494:	d103      	bne.n	b49e <_i2c_master_interrupt_handler+0x11a>
			_i2c_master_write(module);
    b496:	0020      	movs	r0, r4
    b498:	4b2d      	ldr	r3, [pc, #180]	; (b550 <_i2c_master_interrupt_handler+0x1cc>)
    b49a:	4798      	blx	r3
    b49c:	e002      	b.n	b4a4 <_i2c_master_interrupt_handler+0x120>
		} else {
			_i2c_master_read(module);
    b49e:	0020      	movs	r0, r4
    b4a0:	4b2c      	ldr	r3, [pc, #176]	; (b554 <_i2c_master_interrupt_handler+0x1d0>)
    b4a2:	4798      	blx	r3
		}
	}

	/* Check if read buffer transfer is complete */
	if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
    b4a4:	8b63      	ldrh	r3, [r4, #26]
    b4a6:	b29b      	uxth	r3, r3
    b4a8:	2b00      	cmp	r3, #0
    b4aa:	d02a      	beq.n	b502 <_i2c_master_interrupt_handler+0x17e>
    b4ac:	8ba3      	ldrh	r3, [r4, #28]
    b4ae:	b29b      	uxth	r3, r3
    b4b0:	2b00      	cmp	r3, #0
    b4b2:	d126      	bne.n	b502 <_i2c_master_interrupt_handler+0x17e>
			(module->status == STATUS_BUSY) &&
    b4b4:	3325      	adds	r3, #37	; 0x25
    b4b6:	5ce3      	ldrb	r3, [r4, r3]
			_i2c_master_read(module);
		}
	}

	/* Check if read buffer transfer is complete */
	if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
    b4b8:	2b05      	cmp	r3, #5
    b4ba:	d122      	bne.n	b502 <_i2c_master_interrupt_handler+0x17e>
			(module->status == STATUS_BUSY) &&
			(module->transfer_direction == I2C_TRANSFER_READ)) {
    b4bc:	331f      	adds	r3, #31
    b4be:	5ce3      	ldrb	r3, [r4, r3]
		}
	}

	/* Check if read buffer transfer is complete */
	if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
			(module->status == STATUS_BUSY) &&
    b4c0:	2b01      	cmp	r3, #1
    b4c2:	d11e      	bne.n	b502 <_i2c_master_interrupt_handler+0x17e>
			(module->transfer_direction == I2C_TRANSFER_READ)) {
		
		/* Clear read interrupt flag */
		if (i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB) {
    b4c4:	7e2b      	ldrb	r3, [r5, #24]
    b4c6:	079b      	lsls	r3, r3, #30
    b4c8:	d501      	bpl.n	b4ce <_i2c_master_interrupt_handler+0x14a>
			i2c_module->INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    b4ca:	2302      	movs	r3, #2
    b4cc:	762b      	strb	r3, [r5, #24]
		}
		/* Stop packet operation */
		i2c_module->INTENCLR.reg =
    b4ce:	2303      	movs	r3, #3
    b4d0:	752b      	strb	r3, [r5, #20]
				SERCOM_I2CM_INTENCLR_MB | SERCOM_I2CM_INTENCLR_SB;
		module->buffer_length = 0;
    b4d2:	2300      	movs	r3, #0
    b4d4:	8363      	strh	r3, [r4, #26]
		module->status        = STATUS_OK;
    b4d6:	3325      	adds	r3, #37	; 0x25
    b4d8:	2200      	movs	r2, #0
    b4da:	54e2      	strb	r2, [r4, r3]

		/* Call appropriate callback if enabled and registered */
		if ((callback_mask & (1 << I2C_MASTER_CALLBACK_READ_COMPLETE))
    b4dc:	07b3      	lsls	r3, r6, #30
    b4de:	d507      	bpl.n	b4f0 <_i2c_master_interrupt_handler+0x16c>
				&& (module->transfer_direction == I2C_TRANSFER_READ)) {
    b4e0:	2324      	movs	r3, #36	; 0x24
    b4e2:	5ce3      	ldrb	r3, [r4, r3]
    b4e4:	2b01      	cmp	r3, #1
    b4e6:	d103      	bne.n	b4f0 <_i2c_master_interrupt_handler+0x16c>
			module->callbacks[I2C_MASTER_CALLBACK_READ_COMPLETE](module);
    b4e8:	6923      	ldr	r3, [r4, #16]
    b4ea:	0020      	movs	r0, r4
    b4ec:	4798      	blx	r3
    b4ee:	e008      	b.n	b502 <_i2c_master_interrupt_handler+0x17e>
		} else if ((callback_mask & (1 << I2C_MASTER_CALLBACK_WRITE_COMPLETE))
    b4f0:	07f3      	lsls	r3, r6, #31
    b4f2:	d506      	bpl.n	b502 <_i2c_master_interrupt_handler+0x17e>
				&& (module->transfer_direction == I2C_TRANSFER_WRITE)) {
    b4f4:	2324      	movs	r3, #36	; 0x24
    b4f6:	5ce3      	ldrb	r3, [r4, r3]
    b4f8:	2b00      	cmp	r3, #0
    b4fa:	d102      	bne.n	b502 <_i2c_master_interrupt_handler+0x17e>
			module->callbacks[I2C_MASTER_CALLBACK_WRITE_COMPLETE](module);
    b4fc:	68e3      	ldr	r3, [r4, #12]
    b4fe:	0020      	movs	r0, r4
    b500:	4798      	blx	r3
		}
	}

	/* Check for error */
	if ((module->status != STATUS_BUSY) && (module->status != STATUS_OK)) {
    b502:	2325      	movs	r3, #37	; 0x25
    b504:	5ce3      	ldrb	r3, [r4, r3]
    b506:	2b05      	cmp	r3, #5
    b508:	d01c      	beq.n	b544 <_i2c_master_interrupt_handler+0x1c0>
    b50a:	2325      	movs	r3, #37	; 0x25
    b50c:	5ce3      	ldrb	r3, [r4, r3]
    b50e:	2b00      	cmp	r3, #0
    b510:	d018      	beq.n	b544 <_i2c_master_interrupt_handler+0x1c0>
		/* Stop packet operation */
		i2c_module->INTENCLR.reg = SERCOM_I2CM_INTENCLR_MB |
    b512:	2303      	movs	r3, #3
    b514:	752b      	strb	r3, [r5, #20]
				SERCOM_I2CM_INTENCLR_SB;

		module->buffer_length = 0;
    b516:	2300      	movs	r3, #0
    b518:	8363      	strh	r3, [r4, #26]
		module->buffer_remaining = 0;
    b51a:	83a3      	strh	r3, [r4, #28]

		/* Send nack and stop command unless arbitration is lost */
		if ((module->status != STATUS_ERR_PACKET_COLLISION) &&
    b51c:	3325      	adds	r3, #37	; 0x25
    b51e:	5ce3      	ldrb	r3, [r4, r3]
    b520:	2b41      	cmp	r3, #65	; 0x41
    b522:	d00a      	beq.n	b53a <_i2c_master_interrupt_handler+0x1b6>
    b524:	7aa3      	ldrb	r3, [r4, #10]
    b526:	2b00      	cmp	r3, #0
    b528:	d007      	beq.n	b53a <_i2c_master_interrupt_handler+0x1b6>
				module->send_stop) {
			_i2c_master_wait_for_sync(module);
    b52a:	0020      	movs	r0, r4
    b52c:	4b07      	ldr	r3, [pc, #28]	; (b54c <_i2c_master_interrupt_handler+0x1c8>)
    b52e:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT |
    b530:	686b      	ldr	r3, [r5, #4]
    b532:	22e0      	movs	r2, #224	; 0xe0
    b534:	02d2      	lsls	r2, r2, #11
    b536:	4313      	orrs	r3, r2
    b538:	606b      	str	r3, [r5, #4]
					SERCOM_I2CM_CTRLB_CMD(3);
		}

		/* Call error callback if enabled and registered */
		if (callback_mask & (1 << I2C_MASTER_CALLBACK_ERROR)) {
    b53a:	0773      	lsls	r3, r6, #29
    b53c:	d502      	bpl.n	b544 <_i2c_master_interrupt_handler+0x1c0>
			module->callbacks[I2C_MASTER_CALLBACK_ERROR](module);
    b53e:	6963      	ldr	r3, [r4, #20]
    b540:	0020      	movs	r0, r4
    b542:	4798      	blx	r3
		}
	}
}
    b544:	bd70      	pop	{r4, r5, r6, pc}
    b546:	46c0      	nop			; (mov r8, r8)
    b548:	20002850 	.word	0x20002850
    b54c:	0000b2b9 	.word	0x0000b2b9
    b550:	0000b349 	.word	0x0000b349
    b554:	0000b2c5 	.word	0x0000b2c5

0000b558 <WDT_Handler>:
	}
}

/** Handler for the WDT hardware module interrupt. */
void WDT_Handler(void)
{
    b558:	b510      	push	{r4, lr}
 */
static inline void wdt_clear_early_warning(void)
{
	Wdt *const WDT_module = WDT;

	WDT_module->INTFLAG.reg = WDT_INTFLAG_EW;
    b55a:	2201      	movs	r2, #1
    b55c:	4b03      	ldr	r3, [pc, #12]	; (b56c <WDT_Handler+0x14>)
    b55e:	719a      	strb	r2, [r3, #6]
	wdt_clear_early_warning();

	if (wdt_early_warning_callback) {
    b560:	4b03      	ldr	r3, [pc, #12]	; (b570 <WDT_Handler+0x18>)
    b562:	681b      	ldr	r3, [r3, #0]
    b564:	2b00      	cmp	r3, #0
    b566:	d000      	beq.n	b56a <WDT_Handler+0x12>
		wdt_early_warning_callback();
    b568:	4798      	blx	r3
	}
}
    b56a:	bd10      	pop	{r4, pc}
    b56c:	40001c00 	.word	0x40001c00
    b570:	200024b4 	.word	0x200024b4

0000b574 <bme280_compensate_temperature_int32>:
 *
 *  @return Returns the actual temperature
 *
*/
s32 bme280_compensate_temperature_int32(s32 v_uncomp_temperature_s32)
{
    b574:	b510      	push	{r4, lr}

	/* calculate x1*/
	v_x1_u32r  =
	((((v_uncomp_temperature_s32
	>> BME280_SHIFT_BIT_POSITION_BY_03_BITS) -
	((s32)p_bme280->cal_param.dig_T1
    b576:	4b0c      	ldr	r3, [pc, #48]	; (b5a8 <bme280_compensate_temperature_int32+0x34>)
    b578:	6819      	ldr	r1, [r3, #0]
    b57a:	880a      	ldrh	r2, [r1, #0]
	BME280_SHIFT_BIT_POSITION_BY_11_BITS;
	/* calculate x2*/
	v_x2_u32r  = (((((v_uncomp_temperature_s32
	>> BME280_SHIFT_BIT_POSITION_BY_04_BITS) -
	((s32)p_bme280->cal_param.dig_T1))
	* ((v_uncomp_temperature_s32 >> BME280_SHIFT_BIT_POSITION_BY_04_BITS) -
    b57c:	1103      	asrs	r3, r0, #4
    b57e:	1a9b      	subs	r3, r3, r2
	((s32)p_bme280->cal_param.dig_T1)))
	>> BME280_SHIFT_BIT_POSITION_BY_12_BITS) *
	((s32)p_bme280->cal_param.dig_T3))
	>> BME280_SHIFT_BIT_POSITION_BY_14_BITS;
	/* calculate t_fine*/
	p_bme280->cal_param.t_fine = v_x1_u32r + v_x2_u32r;
    b580:	10c0      	asrs	r0, r0, #3
    b582:	0052      	lsls	r2, r2, #1
    b584:	1a80      	subs	r0, r0, r2
    b586:	2402      	movs	r4, #2
    b588:	5f0a      	ldrsh	r2, [r1, r4]
    b58a:	4350      	muls	r0, r2
    b58c:	12c0      	asrs	r0, r0, #11
    b58e:	435b      	muls	r3, r3
    b590:	131b      	asrs	r3, r3, #12
    b592:	2404      	movs	r4, #4
    b594:	5f0a      	ldrsh	r2, [r1, r4]
    b596:	4353      	muls	r3, r2
    b598:	139b      	asrs	r3, r3, #14
    b59a:	18c0      	adds	r0, r0, r3
    b59c:	6248      	str	r0, [r1, #36]	; 0x24
	/* calculate temperature*/
	temperature  = (p_bme280->cal_param.t_fine * 5 + 128)
	>> BME280_SHIFT_BIT_POSITION_BY_08_BITS;
	return temperature;
    b59e:	0083      	lsls	r3, r0, #2
    b5a0:	1818      	adds	r0, r3, r0
    b5a2:	3080      	adds	r0, #128	; 0x80
    b5a4:	1200      	asrs	r0, r0, #8
}
    b5a6:	bd10      	pop	{r4, pc}
    b5a8:	20001934 	.word	0x20001934

0000b5ac <bme280_compensate_pressure_int32>:
 *
 *  @return Return the actual pressure output as u32
 *
*/
u32 bme280_compensate_pressure_int32(s32 v_uncomp_pressure_s32)
{
    b5ac:	b570      	push	{r4, r5, r6, lr}
	s32 v_x1_u32 = BME280_INIT_VALUE;
	s32 v_x2_u32 = BME280_INIT_VALUE;
	u32 v_pressure_u32 = BME280_INIT_VALUE;

	/* calculate x1*/
	v_x1_u32 = (((s32)p_bme280->cal_param.t_fine)
    b5ae:	4b29      	ldr	r3, [pc, #164]	; (b654 <bme280_compensate_pressure_int32+0xa8>)
    b5b0:	681c      	ldr	r4, [r3, #0]
    b5b2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    b5b4:	105b      	asrs	r3, r3, #1
    b5b6:	4a28      	ldr	r2, [pc, #160]	; (b658 <bme280_compensate_pressure_int32+0xac>)
    b5b8:	4694      	mov	ip, r2
    b5ba:	4463      	add	r3, ip
	>> BME280_SHIFT_BIT_POSITION_BY_01_BIT) - (s32)64000;
	/* calculate x2*/
	v_x2_u32 = (((v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_02_BITS)
	* (v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_02_BITS)
    b5bc:	1099      	asrs	r1, r3, #2
    b5be:	4349      	muls	r1, r1

	/* calculate x1*/
	v_x1_u32 = (((s32)p_bme280->cal_param.t_fine)
	>> BME280_SHIFT_BIT_POSITION_BY_01_BIT) - (s32)64000;
	/* calculate x2*/
	v_x2_u32 = (((v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_02_BITS)
    b5c0:	12cd      	asrs	r5, r1, #11
    b5c2:	2610      	movs	r6, #16
    b5c4:	5fa2      	ldrsh	r2, [r4, r6]
    b5c6:	4355      	muls	r5, r2
	/* calculate x2*/
	v_x2_u32 = v_x2_u32 + ((v_x1_u32 *
	((s32)p_bme280->cal_param.dig_P5))
	<< BME280_SHIFT_BIT_POSITION_BY_01_BIT);
	/* calculate x2*/
	v_x2_u32 = (v_x2_u32 >> BME280_SHIFT_BIT_POSITION_BY_02_BITS) +
    b5c8:	260e      	movs	r6, #14
    b5ca:	5fa2      	ldrsh	r2, [r4, r6]
    b5cc:	435a      	muls	r2, r3
    b5ce:	0052      	lsls	r2, r2, #1
    b5d0:	1952      	adds	r2, r2, r5
    b5d2:	1092      	asrs	r2, r2, #2
	/* calculate x1*/
	v_x1_u32 = (((p_bme280->cal_param.dig_P3 *
	(((v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_02_BITS) *
	(v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_02_BITS))
	>> BME280_SHIFT_BIT_POSITION_BY_13_BITS))
	>> BME280_SHIFT_BIT_POSITION_BY_03_BITS) +
    b5d4:	260a      	movs	r6, #10
    b5d6:	5fa5      	ldrsh	r5, [r4, r6]
    b5d8:	1349      	asrs	r1, r1, #13
    b5da:	4369      	muls	r1, r5
    b5dc:	10c9      	asrs	r1, r1, #3
    b5de:	2608      	movs	r6, #8
    b5e0:	5fa5      	ldrsh	r5, [r4, r6]
    b5e2:	436b      	muls	r3, r5
    b5e4:	105b      	asrs	r3, r3, #1
    b5e6:	18cb      	adds	r3, r1, r3
	((((s32)p_bme280->cal_param.dig_P2) *
	v_x1_u32) >> BME280_SHIFT_BIT_POSITION_BY_01_BIT))
	>> BME280_SHIFT_BIT_POSITION_BY_18_BITS;
	/* calculate x1*/
	v_x1_u32 = ((((32768 + v_x1_u32)) *
    b5e8:	149b      	asrs	r3, r3, #18
    b5ea:	2180      	movs	r1, #128	; 0x80
    b5ec:	0209      	lsls	r1, r1, #8
    b5ee:	468c      	mov	ip, r1
    b5f0:	4463      	add	r3, ip
    b5f2:	88e1      	ldrh	r1, [r4, #6]
    b5f4:	4359      	muls	r1, r3
    b5f6:	13c9      	asrs	r1, r1, #15
	((s32)p_bme280->cal_param.dig_P1))
	>> BME280_SHIFT_BIT_POSITION_BY_15_BITS);
	/* calculate pressure*/
	v_pressure_u32 =
    b5f8:	4243      	negs	r3, r0
    b5fa:	250c      	movs	r5, #12
    b5fc:	5f60      	ldrsh	r0, [r4, r5]
    b5fe:	0400      	lsls	r0, r0, #16
    b600:	1880      	adds	r0, r0, r2
    b602:	1300      	asrs	r0, r0, #12
    b604:	1a18      	subs	r0, r3, r0
    b606:	4d15      	ldr	r5, [pc, #84]	; (b65c <bme280_compensate_pressure_int32+0xb0>)
    b608:	4368      	muls	r0, r5
	(((u32)(((s32)1048576) - v_uncomp_pressure_s32)
	- (v_x2_u32 >> BME280_SHIFT_BIT_POSITION_BY_12_BITS))) * 3125;
	if (v_pressure_u32
    b60a:	4b15      	ldr	r3, [pc, #84]	; (b660 <bme280_compensate_pressure_int32+0xb4>)
    b60c:	18c2      	adds	r2, r0, r3
    b60e:	d406      	bmi.n	b61e <bme280_compensate_pressure_int32+0x72>
			v_pressure_u32 =
			(v_pressure_u32
			<< BME280_SHIFT_BIT_POSITION_BY_01_BIT) /
			((u32)v_x1_u32);
		else
			return BME280_INVALID_DATA;
    b610:	2000      	movs	r0, #0
	(((u32)(((s32)1048576) - v_uncomp_pressure_s32)
	- (v_x2_u32 >> BME280_SHIFT_BIT_POSITION_BY_12_BITS))) * 3125;
	if (v_pressure_u32
	< 0x80000000)
		/* Avoid exception caused by division by zero */
		if (v_x1_u32 != BME280_INIT_VALUE)
    b612:	2900      	cmp	r1, #0
    b614:	d01c      	beq.n	b650 <bme280_compensate_pressure_int32+0xa4>
			v_pressure_u32 =
			(v_pressure_u32
			<< BME280_SHIFT_BIT_POSITION_BY_01_BIT) /
    b616:	0050      	lsls	r0, r2, #1
	- (v_x2_u32 >> BME280_SHIFT_BIT_POSITION_BY_12_BITS))) * 3125;
	if (v_pressure_u32
	< 0x80000000)
		/* Avoid exception caused by division by zero */
		if (v_x1_u32 != BME280_INIT_VALUE)
			v_pressure_u32 =
    b618:	4b12      	ldr	r3, [pc, #72]	; (b664 <bme280_compensate_pressure_int32+0xb8>)
    b61a:	4798      	blx	r3
    b61c:	e006      	b.n	b62c <bme280_compensate_pressure_int32+0x80>
		/* Avoid exception caused by division by zero */
		if (v_x1_u32 != BME280_INIT_VALUE)
			v_pressure_u32 = (v_pressure_u32
			/ (u32)v_x1_u32) * 2;
		else
			return BME280_INVALID_DATA;
    b61e:	2000      	movs	r0, #0
			((u32)v_x1_u32);
		else
			return BME280_INVALID_DATA;
	else
		/* Avoid exception caused by division by zero */
		if (v_x1_u32 != BME280_INIT_VALUE)
    b620:	2900      	cmp	r1, #0
    b622:	d015      	beq.n	b650 <bme280_compensate_pressure_int32+0xa4>
			v_pressure_u32 = (v_pressure_u32
			/ (u32)v_x1_u32) * 2;
    b624:	0010      	movs	r0, r2
    b626:	4b0f      	ldr	r3, [pc, #60]	; (b664 <bme280_compensate_pressure_int32+0xb8>)
    b628:	4798      	blx	r3
		else
			return BME280_INVALID_DATA;
	else
		/* Avoid exception caused by division by zero */
		if (v_x1_u32 != BME280_INIT_VALUE)
			v_pressure_u32 = (v_pressure_u32
    b62a:	0040      	lsls	r0, r0, #1
		else
			return BME280_INVALID_DATA;

		v_x1_u32 = (((s32)p_bme280->cal_param.dig_P9) *
		((s32)(((v_pressure_u32 >> BME280_SHIFT_BIT_POSITION_BY_03_BITS)
		* (v_pressure_u32 >> BME280_SHIFT_BIT_POSITION_BY_03_BITS))
    b62c:	08c3      	lsrs	r3, r0, #3
		>> BME280_SHIFT_BIT_POSITION_BY_12_BITS;
		v_x2_u32 = (((s32)(v_pressure_u32
		>> BME280_SHIFT_BIT_POSITION_BY_02_BITS)) *
		((s32)p_bme280->cal_param.dig_P8))
		>> BME280_SHIFT_BIT_POSITION_BY_13_BITS;
		v_pressure_u32 = (u32)((s32)v_pressure_u32 +
    b62e:	435b      	muls	r3, r3
    b630:	0b5b      	lsrs	r3, r3, #13
    b632:	2216      	movs	r2, #22
    b634:	5ea1      	ldrsh	r1, [r4, r2]
    b636:	434b      	muls	r3, r1
    b638:	1319      	asrs	r1, r3, #12
    b63a:	0883      	lsrs	r3, r0, #2
    b63c:	2514      	movs	r5, #20
    b63e:	5f62      	ldrsh	r2, [r4, r5]
    b640:	4353      	muls	r3, r2
    b642:	135b      	asrs	r3, r3, #13
    b644:	18cb      	adds	r3, r1, r3
    b646:	2112      	movs	r1, #18
    b648:	5e62      	ldrsh	r2, [r4, r1]
    b64a:	189b      	adds	r3, r3, r2
    b64c:	111b      	asrs	r3, r3, #4
		((v_x1_u32 + v_x2_u32 + p_bme280->cal_param.dig_P7)
		>> BME280_SHIFT_BIT_POSITION_BY_04_BITS));

	return v_pressure_u32;
    b64e:	1818      	adds	r0, r3, r0
}
    b650:	bd70      	pop	{r4, r5, r6, pc}
    b652:	46c0      	nop			; (mov r8, r8)
    b654:	20001934 	.word	0x20001934
    b658:	ffff0600 	.word	0xffff0600
    b65c:	00000c35 	.word	0x00000c35
    b660:	c3500000 	.word	0xc3500000
    b664:	0000f82d 	.word	0x0000f82d

0000b668 <bme280_compensate_humidity_int32>:
 *
 *  @return Return the actual relative humidity output as u32
 *
*/
u32 bme280_compensate_humidity_int32(s32 v_uncomp_humidity_s32)
{
    b668:	b510      	push	{r4, lr}
	s32 v_x1_u32 = BME280_INIT_VALUE;

	/* calculate x1*/
	v_x1_u32 = (p_bme280->cal_param.t_fine - ((s32)76800));
    b66a:	4b20      	ldr	r3, [pc, #128]	; (b6ec <bme280_compensate_humidity_int32+0x84>)
    b66c:	681c      	ldr	r4, [r3, #0]
    b66e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    b670:	4a1f      	ldr	r2, [pc, #124]	; (b6f0 <bme280_compensate_humidity_int32+0x88>)
    b672:	4694      	mov	ip, r2
    b674:	4463      	add	r3, ip
	v_x1_u32 = (((((v_uncomp_humidity_s32
	<< BME280_SHIFT_BIT_POSITION_BY_14_BITS) -
	(((s32)p_bme280->cal_param.dig_H4)
	<< BME280_SHIFT_BIT_POSITION_BY_20_BITS) -
	(((s32)p_bme280->cal_param.dig_H5) * v_x1_u32)) +
	((s32)16384)) >> BME280_SHIFT_BIT_POSITION_BY_15_BITS)
    b676:	0380      	lsls	r0, r0, #14
    b678:	211e      	movs	r1, #30
    b67a:	5e62      	ldrsh	r2, [r4, r1]
    b67c:	0512      	lsls	r2, r2, #20
    b67e:	1a80      	subs	r0, r0, r2
    b680:	2120      	movs	r1, #32
    b682:	5e62      	ldrsh	r2, [r4, r1]
    b684:	435a      	muls	r2, r3
    b686:	1a82      	subs	r2, r0, r2
    b688:	2180      	movs	r1, #128	; 0x80
    b68a:	01c9      	lsls	r1, r1, #7
    b68c:	468c      	mov	ip, r1
    b68e:	4462      	add	r2, ip
    b690:	13d2      	asrs	r2, r2, #15
	((s32)p_bme280->cal_param.dig_H6))
	>> BME280_SHIFT_BIT_POSITION_BY_10_BITS) *
	(((v_x1_u32 * ((s32)p_bme280->cal_param.dig_H3))
	>> BME280_SHIFT_BIT_POSITION_BY_11_BITS) + ((s32)32768)))
	>> BME280_SHIFT_BIT_POSITION_BY_10_BITS) + ((s32)2097152)) *
	((s32)p_bme280->cal_param.dig_H2) + 8192) >> 14));
    b692:	7f20      	ldrb	r0, [r4, #28]
    b694:	4358      	muls	r0, r3
    b696:	12c0      	asrs	r0, r0, #11
    b698:	2180      	movs	r1, #128	; 0x80
    b69a:	0209      	lsls	r1, r1, #8
    b69c:	468c      	mov	ip, r1
    b69e:	4460      	add	r0, ip
	(((s32)p_bme280->cal_param.dig_H4)
	<< BME280_SHIFT_BIT_POSITION_BY_20_BITS) -
	(((s32)p_bme280->cal_param.dig_H5) * v_x1_u32)) +
	((s32)16384)) >> BME280_SHIFT_BIT_POSITION_BY_15_BITS)
	* (((((((v_x1_u32 *
	((s32)p_bme280->cal_param.dig_H6))
    b6a0:	2122      	movs	r1, #34	; 0x22
	>> BME280_SHIFT_BIT_POSITION_BY_10_BITS) *
	(((v_x1_u32 * ((s32)p_bme280->cal_param.dig_H3))
	>> BME280_SHIFT_BIT_POSITION_BY_11_BITS) + ((s32)32768)))
	>> BME280_SHIFT_BIT_POSITION_BY_10_BITS) + ((s32)2097152)) *
	((s32)p_bme280->cal_param.dig_H2) + 8192) >> 14));
    b6a2:	5661      	ldrsb	r1, [r4, r1]
    b6a4:	4359      	muls	r1, r3
    b6a6:	1289      	asrs	r1, r1, #10
    b6a8:	000b      	movs	r3, r1
    b6aa:	4343      	muls	r3, r0
    b6ac:	129b      	asrs	r3, r3, #10
    b6ae:	2180      	movs	r1, #128	; 0x80
    b6b0:	0389      	lsls	r1, r1, #14
    b6b2:	468c      	mov	ip, r1
    b6b4:	4463      	add	r3, ip
    b6b6:	201a      	movs	r0, #26
    b6b8:	5e21      	ldrsh	r1, [r4, r0]
    b6ba:	434b      	muls	r3, r1
    b6bc:	2180      	movs	r1, #128	; 0x80
    b6be:	0189      	lsls	r1, r1, #6
    b6c0:	468c      	mov	ip, r1
    b6c2:	4463      	add	r3, ip
    b6c4:	139b      	asrs	r3, r3, #14
	s32 v_x1_u32 = BME280_INIT_VALUE;

	/* calculate x1*/
	v_x1_u32 = (p_bme280->cal_param.t_fine - ((s32)76800));
	/* calculate x1*/
	v_x1_u32 = (((((v_uncomp_humidity_s32
    b6c6:	435a      	muls	r2, r3
	>> BME280_SHIFT_BIT_POSITION_BY_11_BITS) + ((s32)32768)))
	>> BME280_SHIFT_BIT_POSITION_BY_10_BITS) + ((s32)2097152)) *
	((s32)p_bme280->cal_param.dig_H2) + 8192) >> 14));
	v_x1_u32 = (v_x1_u32 - (((((v_x1_u32
	>> BME280_SHIFT_BIT_POSITION_BY_15_BITS) *
	(v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_15_BITS))
    b6c8:	13d3      	asrs	r3, r2, #15
	>> BME280_SHIFT_BIT_POSITION_BY_10_BITS) *
	(((v_x1_u32 * ((s32)p_bme280->cal_param.dig_H3))
	>> BME280_SHIFT_BIT_POSITION_BY_11_BITS) + ((s32)32768)))
	>> BME280_SHIFT_BIT_POSITION_BY_10_BITS) + ((s32)2097152)) *
	((s32)p_bme280->cal_param.dig_H2) + 8192) >> 14));
	v_x1_u32 = (v_x1_u32 - (((((v_x1_u32
    b6ca:	435b      	muls	r3, r3
    b6cc:	11db      	asrs	r3, r3, #7
    b6ce:	7e20      	ldrb	r0, [r4, #24]
    b6d0:	4343      	muls	r3, r0
    b6d2:	111b      	asrs	r3, r3, #4
    b6d4:	1ad3      	subs	r3, r2, r3
	>> BME280_SHIFT_BIT_POSITION_BY_15_BITS) *
	(v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_15_BITS))
	>> BME280_SHIFT_BIT_POSITION_BY_07_BITS) *
	((s32)p_bme280->cal_param.dig_H1))
	>> BME280_SHIFT_BIT_POSITION_BY_04_BITS));
	v_x1_u32 = (v_x1_u32 < 0 ? 0 : v_x1_u32);
    b6d6:	43d8      	mvns	r0, r3
    b6d8:	17c0      	asrs	r0, r0, #31
	v_x1_u32 = (v_x1_u32 > 419430400 ?
	419430400 : v_x1_u32);
	return (u32)(v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_12_BITS);
    b6da:	4003      	ands	r3, r0
    b6dc:	22c8      	movs	r2, #200	; 0xc8
    b6de:	0552      	lsls	r2, r2, #21
    b6e0:	4293      	cmp	r3, r2
    b6e2:	dd00      	ble.n	b6e6 <bme280_compensate_humidity_int32+0x7e>
    b6e4:	0013      	movs	r3, r2
    b6e6:	1318      	asrs	r0, r3, #12
}
    b6e8:	bd10      	pop	{r4, pc}
    b6ea:	46c0      	nop			; (mov r8, r8)
    b6ec:	20001934 	.word	0x20001934
    b6f0:	fffed400 	.word	0xfffed400

0000b6f4 <bme280_read_uncomp_pressure_temperature_humidity>:
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_read_uncomp_pressure_temperature_humidity(
s32 *v_uncomp_pressure_s32,
s32 *v_uncomp_temperature_s32, s32 *v_uncomp_humidity_s32)
{
    b6f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    b6f6:	b083      	sub	sp, #12
    b6f8:	0006      	movs	r6, r0
    b6fa:	000d      	movs	r5, r1
    b6fc:	0014      	movs	r4, r2
	a_data_u8[1] - Temperature LSB
	a_data_u8[1] - Temperature LSB
	a_data_u8[1] - Humidity MSB
	a_data_u8[1] - Humidity LSB
	*/
	u8 a_data_u8[BME280_DATA_FRAME_SIZE] = {
    b6fe:	2208      	movs	r2, #8
    b700:	2100      	movs	r1, #0
    b702:	4668      	mov	r0, sp
    b704:	4b18      	ldr	r3, [pc, #96]	; (b768 <bme280_read_uncomp_pressure_temperature_humidity+0x74>)
    b706:	4798      	blx	r3
	BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE};
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    b708:	4b18      	ldr	r3, [pc, #96]	; (b76c <bme280_read_uncomp_pressure_temperature_humidity+0x78>)
    b70a:	681b      	ldr	r3, [r3, #0]
    b70c:	2b00      	cmp	r3, #0
    b70e:	d026      	beq.n	b75e <bme280_read_uncomp_pressure_temperature_humidity+0x6a>
		return E_BME280_NULL_PTR;
		} else {
			com_rslt = p_bme280->BME280_BUS_READ_FUNC(
    b710:	2229      	movs	r2, #41	; 0x29
    b712:	5c98      	ldrb	r0, [r3, r2]
    b714:	6b5f      	ldr	r7, [r3, #52]	; 0x34
    b716:	2308      	movs	r3, #8
    b718:	466a      	mov	r2, sp
    b71a:	21f7      	movs	r1, #247	; 0xf7
    b71c:	47b8      	blx	r7
			p_bme280->dev_addr,
			BME280_PRESSURE_MSB_REG,
			a_data_u8, BME280_ALL_DATA_FRAME_LENGTH);
			/*Pressure*/
			*v_uncomp_pressure_s32 = (s32)((
    b71e:	466b      	mov	r3, sp
    b720:	781b      	ldrb	r3, [r3, #0]
    b722:	031a      	lsls	r2, r3, #12
    b724:	466b      	mov	r3, sp
    b726:	785b      	ldrb	r3, [r3, #1]
    b728:	011b      	lsls	r3, r3, #4
    b72a:	4313      	orrs	r3, r2
    b72c:	466a      	mov	r2, sp
    b72e:	7892      	ldrb	r2, [r2, #2]
    b730:	0912      	lsrs	r2, r2, #4
    b732:	4313      	orrs	r3, r2
    b734:	6033      	str	r3, [r6, #0]
			((u32)a_data_u8[
			BME280_DATA_FRAME_PRESSURE_XLSB_BYTE] >>
			BME280_SHIFT_BIT_POSITION_BY_04_BITS));

			/* Temperature */
			*v_uncomp_temperature_s32 = (s32)(((
    b736:	466b      	mov	r3, sp
    b738:	78db      	ldrb	r3, [r3, #3]
    b73a:	031a      	lsls	r2, r3, #12
    b73c:	466b      	mov	r3, sp
    b73e:	791b      	ldrb	r3, [r3, #4]
    b740:	011b      	lsls	r3, r3, #4
    b742:	4313      	orrs	r3, r2
    b744:	466a      	mov	r2, sp
    b746:	7952      	ldrb	r2, [r2, #5]
    b748:	0912      	lsrs	r2, r2, #4
    b74a:	4313      	orrs	r3, r2
    b74c:	602b      	str	r3, [r5, #0]
			| ((u32)a_data_u8[
			BME280_DATA_FRAME_TEMPERATURE_XLSB_BYTE]
			>> BME280_SHIFT_BIT_POSITION_BY_04_BITS));

			/*Humidity*/
			*v_uncomp_humidity_s32 = (s32)((
    b74e:	466b      	mov	r3, sp
    b750:	799b      	ldrb	r3, [r3, #6]
    b752:	021b      	lsls	r3, r3, #8
    b754:	466a      	mov	r2, sp
    b756:	79d2      	ldrb	r2, [r2, #7]
    b758:	4313      	orrs	r3, r2
    b75a:	6023      	str	r3, [r4, #0]
			BME280_DATA_FRAME_HUMIDITY_MSB_BYTE]))
			<< BME280_SHIFT_BIT_POSITION_BY_08_BITS)|
			((u32)(a_data_u8[
			BME280_DATA_FRAME_HUMIDITY_LSB_BYTE])));
		}
	return com_rslt;
    b75c:	e001      	b.n	b762 <bme280_read_uncomp_pressure_temperature_humidity+0x6e>
	BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE};
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    b75e:	207f      	movs	r0, #127	; 0x7f
    b760:	4240      	negs	r0, r0
			<< BME280_SHIFT_BIT_POSITION_BY_08_BITS)|
			((u32)(a_data_u8[
			BME280_DATA_FRAME_HUMIDITY_LSB_BYTE])));
		}
	return com_rslt;
}
    b762:	b003      	add	sp, #12
    b764:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b766:	46c0      	nop			; (mov r8, r8)
    b768:	00011845 	.word	0x00011845
    b76c:	20001934 	.word	0x20001934

0000b770 <bme280_read_pressure_temperature_humidity>:
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_read_pressure_temperature_humidity(
u32 *v_pressure_u32, s32 *v_temperature_s32, u32 *v_humidity_u32)
{
    b770:	b5f0      	push	{r4, r5, r6, r7, lr}
    b772:	b085      	sub	sp, #20
    b774:	0006      	movs	r6, r0
    b776:	000f      	movs	r7, r1
    b778:	0015      	movs	r5, r2
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	s32 v_uncomp_pressure_s32 = BME280_INIT_VALUE;
    b77a:	2300      	movs	r3, #0
    b77c:	9303      	str	r3, [sp, #12]
	s32 v_uncom_temperature_s32 = BME280_INIT_VALUE;
    b77e:	9302      	str	r3, [sp, #8]
	s32 v_uncom_humidity_s32 = BME280_INIT_VALUE;
    b780:	9301      	str	r3, [sp, #4]
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    b782:	4b0e      	ldr	r3, [pc, #56]	; (b7bc <bme280_read_pressure_temperature_humidity+0x4c>)
    b784:	681b      	ldr	r3, [r3, #0]
    b786:	2b00      	cmp	r3, #0
    b788:	d013      	beq.n	b7b2 <bme280_read_pressure_temperature_humidity+0x42>
		return E_BME280_NULL_PTR;
		} else {
			/* read the uncompensated pressure,
			temperature and humidity*/
			com_rslt =
    b78a:	aa01      	add	r2, sp, #4
    b78c:	a902      	add	r1, sp, #8
    b78e:	a803      	add	r0, sp, #12
    b790:	4b0b      	ldr	r3, [pc, #44]	; (b7c0 <bme280_read_pressure_temperature_humidity+0x50>)
    b792:	4798      	blx	r3
    b794:	0004      	movs	r4, r0
			bme280_read_uncomp_pressure_temperature_humidity(
			&v_uncomp_pressure_s32, &v_uncom_temperature_s32,
			&v_uncom_humidity_s32);
			/* read the true pressure, temperature and humidity*/
			*v_temperature_s32 =
			bme280_compensate_temperature_int32(
    b796:	9802      	ldr	r0, [sp, #8]
    b798:	4b0a      	ldr	r3, [pc, #40]	; (b7c4 <bme280_read_pressure_temperature_humidity+0x54>)
    b79a:	4798      	blx	r3
			com_rslt =
			bme280_read_uncomp_pressure_temperature_humidity(
			&v_uncomp_pressure_s32, &v_uncom_temperature_s32,
			&v_uncom_humidity_s32);
			/* read the true pressure, temperature and humidity*/
			*v_temperature_s32 =
    b79c:	6038      	str	r0, [r7, #0]
			bme280_compensate_temperature_int32(
			v_uncom_temperature_s32);
			*v_pressure_u32 = bme280_compensate_pressure_int32(
    b79e:	9803      	ldr	r0, [sp, #12]
    b7a0:	4b09      	ldr	r3, [pc, #36]	; (b7c8 <bme280_read_pressure_temperature_humidity+0x58>)
    b7a2:	4798      	blx	r3
    b7a4:	6030      	str	r0, [r6, #0]
			v_uncomp_pressure_s32);
			*v_humidity_u32 = bme280_compensate_humidity_int32(
    b7a6:	9801      	ldr	r0, [sp, #4]
    b7a8:	4b08      	ldr	r3, [pc, #32]	; (b7cc <bme280_read_pressure_temperature_humidity+0x5c>)
    b7aa:	4798      	blx	r3
    b7ac:	6028      	str	r0, [r5, #0]
			v_uncom_humidity_s32);
		}
	return com_rslt;
    b7ae:	0020      	movs	r0, r4
    b7b0:	e001      	b.n	b7b6 <bme280_read_pressure_temperature_humidity+0x46>
	s32 v_uncomp_pressure_s32 = BME280_INIT_VALUE;
	s32 v_uncom_temperature_s32 = BME280_INIT_VALUE;
	s32 v_uncom_humidity_s32 = BME280_INIT_VALUE;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    b7b2:	207f      	movs	r0, #127	; 0x7f
    b7b4:	4240      	negs	r0, r0
			v_uncomp_pressure_s32);
			*v_humidity_u32 = bme280_compensate_humidity_int32(
			v_uncom_humidity_s32);
		}
	return com_rslt;
}
    b7b6:	b005      	add	sp, #20
    b7b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b7ba:	46c0      	nop			; (mov r8, r8)
    b7bc:	20001934 	.word	0x20001934
    b7c0:	0000b6f5 	.word	0x0000b6f5
    b7c4:	0000b575 	.word	0x0000b575
    b7c8:	0000b5ad 	.word	0x0000b5ad
    b7cc:	0000b669 	.word	0x0000b669

0000b7d0 <bme280_get_calib_param>:
 *	@retval -1 -> Error
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_get_calib_param(void)
{
    b7d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    b7d2:	b089      	sub	sp, #36	; 0x24
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 a_data_u8[BME280_CALIB_DATA_SIZE] = {
    b7d4:	221a      	movs	r2, #26
    b7d6:	2100      	movs	r1, #0
    b7d8:	a801      	add	r0, sp, #4
    b7da:	4b40      	ldr	r3, [pc, #256]	; (b8dc <bme280_get_calib_param+0x10c>)
    b7dc:	4798      	blx	r3
	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE};
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    b7de:	4b40      	ldr	r3, [pc, #256]	; (b8e0 <bme280_get_calib_param+0x110>)
    b7e0:	681b      	ldr	r3, [r3, #0]
    b7e2:	2b00      	cmp	r3, #0
    b7e4:	d100      	bne.n	b7e8 <bme280_get_calib_param+0x18>
    b7e6:	e075      	b.n	b8d4 <bme280_get_calib_param+0x104>
		return E_BME280_NULL_PTR;
		} else {
			com_rslt = p_bme280->BME280_BUS_READ_FUNC(
    b7e8:	ac01      	add	r4, sp, #4
    b7ea:	2629      	movs	r6, #41	; 0x29
    b7ec:	5d98      	ldrb	r0, [r3, r6]
    b7ee:	6b5d      	ldr	r5, [r3, #52]	; 0x34
    b7f0:	231a      	movs	r3, #26
    b7f2:	0022      	movs	r2, r4
    b7f4:	2188      	movs	r1, #136	; 0x88
    b7f6:	47a8      	blx	r5
    b7f8:	0007      	movs	r7, r0
			p_bme280->dev_addr,
			BME280_TEMPERATURE_CALIB_DIG_T1_LSB_REG,
			a_data_u8,
			BME280_PRESSURE_TEMPERATURE_CALIB_DATA_LENGTH);

			p_bme280->cal_param.dig_T1 = (u16)(((
    b7fa:	4d39      	ldr	r5, [pc, #228]	; (b8e0 <bme280_get_calib_param+0x110>)
    b7fc:	682b      	ldr	r3, [r5, #0]
    b7fe:	7862      	ldrb	r2, [r4, #1]
    b800:	0212      	lsls	r2, r2, #8
    b802:	7821      	ldrb	r1, [r4, #0]
    b804:	430a      	orrs	r2, r1
    b806:	801a      	strh	r2, [r3, #0]
			(u16)((u8)a_data_u8[
			BME280_TEMPERATURE_CALIB_DIG_T1_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_TEMPERATURE_CALIB_DIG_T1_LSB]);
			p_bme280->cal_param.dig_T2 = (s16)(((
    b808:	2203      	movs	r2, #3
    b80a:	56a2      	ldrsb	r2, [r4, r2]
    b80c:	0212      	lsls	r2, r2, #8
    b80e:	78a1      	ldrb	r1, [r4, #2]
    b810:	430a      	orrs	r2, r1
    b812:	805a      	strh	r2, [r3, #2]
			(s16)((s8)a_data_u8[
			BME280_TEMPERATURE_CALIB_DIG_T2_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_TEMPERATURE_CALIB_DIG_T2_LSB]);
			p_bme280->cal_param.dig_T3 = (s16)(((
    b814:	2205      	movs	r2, #5
    b816:	56a2      	ldrsb	r2, [r4, r2]
    b818:	0212      	lsls	r2, r2, #8
    b81a:	7921      	ldrb	r1, [r4, #4]
    b81c:	430a      	orrs	r2, r1
    b81e:	809a      	strh	r2, [r3, #4]
			(s16)((s8)a_data_u8[
			BME280_TEMPERATURE_CALIB_DIG_T3_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_TEMPERATURE_CALIB_DIG_T3_LSB]);
			p_bme280->cal_param.dig_P1 = (u16)(((
    b820:	79e2      	ldrb	r2, [r4, #7]
    b822:	0212      	lsls	r2, r2, #8
    b824:	79a1      	ldrb	r1, [r4, #6]
    b826:	430a      	orrs	r2, r1
    b828:	80da      	strh	r2, [r3, #6]
			(u16)((u8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P1_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P1_LSB]);
			p_bme280->cal_param.dig_P2 = (s16)(((
    b82a:	2209      	movs	r2, #9
    b82c:	56a2      	ldrsb	r2, [r4, r2]
    b82e:	0212      	lsls	r2, r2, #8
    b830:	7a21      	ldrb	r1, [r4, #8]
    b832:	430a      	orrs	r2, r1
    b834:	811a      	strh	r2, [r3, #8]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P2_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P2_LSB]);
			p_bme280->cal_param.dig_P3 = (s16)(((
    b836:	220b      	movs	r2, #11
    b838:	56a2      	ldrsb	r2, [r4, r2]
    b83a:	0212      	lsls	r2, r2, #8
    b83c:	7aa1      	ldrb	r1, [r4, #10]
    b83e:	430a      	orrs	r2, r1
    b840:	815a      	strh	r2, [r3, #10]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P3_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P3_LSB]);
			p_bme280->cal_param.dig_P4 = (s16)(((
    b842:	220d      	movs	r2, #13
    b844:	56a2      	ldrsb	r2, [r4, r2]
    b846:	0212      	lsls	r2, r2, #8
    b848:	7b21      	ldrb	r1, [r4, #12]
    b84a:	430a      	orrs	r2, r1
    b84c:	819a      	strh	r2, [r3, #12]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P4_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P4_LSB]);
			p_bme280->cal_param.dig_P5 = (s16)(((
    b84e:	220f      	movs	r2, #15
    b850:	56a2      	ldrsb	r2, [r4, r2]
    b852:	0212      	lsls	r2, r2, #8
    b854:	7ba1      	ldrb	r1, [r4, #14]
    b856:	430a      	orrs	r2, r1
    b858:	81da      	strh	r2, [r3, #14]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P5_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P5_LSB]);
			p_bme280->cal_param.dig_P6 = (s16)(((
    b85a:	2211      	movs	r2, #17
    b85c:	56a2      	ldrsb	r2, [r4, r2]
    b85e:	0212      	lsls	r2, r2, #8
    b860:	7c21      	ldrb	r1, [r4, #16]
    b862:	430a      	orrs	r2, r1
    b864:	821a      	strh	r2, [r3, #16]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P6_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P6_LSB]);
			p_bme280->cal_param.dig_P7 = (s16)(((
    b866:	2213      	movs	r2, #19
    b868:	56a2      	ldrsb	r2, [r4, r2]
    b86a:	0212      	lsls	r2, r2, #8
    b86c:	7ca1      	ldrb	r1, [r4, #18]
    b86e:	430a      	orrs	r2, r1
    b870:	825a      	strh	r2, [r3, #18]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P7_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P7_LSB]);
			p_bme280->cal_param.dig_P8 = (s16)(((
    b872:	2215      	movs	r2, #21
    b874:	56a2      	ldrsb	r2, [r4, r2]
    b876:	0212      	lsls	r2, r2, #8
    b878:	7d21      	ldrb	r1, [r4, #20]
    b87a:	430a      	orrs	r2, r1
    b87c:	829a      	strh	r2, [r3, #20]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P8_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P8_LSB]);
			p_bme280->cal_param.dig_P9 = (s16)(((
    b87e:	2217      	movs	r2, #23
    b880:	56a2      	ldrsb	r2, [r4, r2]
    b882:	0212      	lsls	r2, r2, #8
    b884:	7da1      	ldrb	r1, [r4, #22]
    b886:	430a      	orrs	r2, r1
    b888:	82da      	strh	r2, [r3, #22]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P9_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P9_LSB]);
			p_bme280->cal_param.dig_H1 =
			a_data_u8[BME280_HUMIDITY_CALIB_DIG_H1];
    b88a:	7e62      	ldrb	r2, [r4, #25]
			p_bme280->cal_param.dig_P9 = (s16)(((
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P9_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P9_LSB]);
			p_bme280->cal_param.dig_H1 =
    b88c:	761a      	strb	r2, [r3, #24]
			a_data_u8[BME280_HUMIDITY_CALIB_DIG_H1];
			com_rslt += p_bme280->BME280_BUS_READ_FUNC(
    b88e:	5d98      	ldrb	r0, [r3, r6]
    b890:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    b892:	2307      	movs	r3, #7
    b894:	0022      	movs	r2, r4
    b896:	21e1      	movs	r1, #225	; 0xe1
    b898:	47b0      	blx	r6
    b89a:	19c0      	adds	r0, r0, r7
			p_bme280->dev_addr,
			BME280_HUMIDITY_CALIB_DIG_H2_LSB_REG, a_data_u8,
			BME280_HUMIDITY_CALIB_DATA_LENGTH);
			p_bme280->cal_param.dig_H2 = (s16)(((
    b89c:	682b      	ldr	r3, [r5, #0]
    b89e:	2201      	movs	r2, #1
    b8a0:	56a2      	ldrsb	r2, [r4, r2]
    b8a2:	0212      	lsls	r2, r2, #8
    b8a4:	7821      	ldrb	r1, [r4, #0]
    b8a6:	430a      	orrs	r2, r1
    b8a8:	835a      	strh	r2, [r3, #26]
			(s16)((s8)a_data_u8[
			BME280_HUMIDITY_CALIB_DIG_H2_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_HUMIDITY_CALIB_DIG_H2_LSB]);
			p_bme280->cal_param.dig_H3 =
    b8aa:	78a2      	ldrb	r2, [r4, #2]
    b8ac:	771a      	strb	r2, [r3, #28]
			p_bme280->cal_param.dig_H4 = (s16)(((
			(s16)((s8)a_data_u8[
			BME280_HUMIDITY_CALIB_DIG_H4_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_04_BITS) |
			(((u8)BME280_MASK_DIG_H4) &
			a_data_u8[BME280_HUMIDITY_CALIB_DIG_H4_LSB]));
    b8ae:	7922      	ldrb	r2, [r4, #4]
			BME280_HUMIDITY_CALIB_DIG_H2_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_HUMIDITY_CALIB_DIG_H2_LSB]);
			p_bme280->cal_param.dig_H3 =
			a_data_u8[BME280_HUMIDITY_CALIB_DIG_H3];
			p_bme280->cal_param.dig_H4 = (s16)(((
    b8b0:	2103      	movs	r1, #3
    b8b2:	5661      	ldrsb	r1, [r4, r1]
    b8b4:	010d      	lsls	r5, r1, #4
    b8b6:	210f      	movs	r1, #15
    b8b8:	4011      	ands	r1, r2
    b8ba:	4329      	orrs	r1, r5
    b8bc:	83d9      	strh	r1, [r3, #30]
			(s16)((s8)a_data_u8[
			BME280_HUMIDITY_CALIB_DIG_H4_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_04_BITS) |
			(((u8)BME280_MASK_DIG_H4) &
			a_data_u8[BME280_HUMIDITY_CALIB_DIG_H4_LSB]));
			p_bme280->cal_param.dig_H5 = (s16)(((
    b8be:	2105      	movs	r1, #5
    b8c0:	5661      	ldrsb	r1, [r4, r1]
    b8c2:	0109      	lsls	r1, r1, #4
    b8c4:	0912      	lsrs	r2, r2, #4
    b8c6:	430a      	orrs	r2, r1
    b8c8:	841a      	strh	r2, [r3, #32]
			(s16)((s8)a_data_u8[
			BME280_HUMIDITY_CALIB_DIG_H5_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_04_BITS) |
			(a_data_u8[BME280_HUMIDITY_CALIB_DIG_H4_LSB] >>
			BME280_SHIFT_BIT_POSITION_BY_04_BITS));
			p_bme280->cal_param.dig_H6 =
    b8ca:	79a1      	ldrb	r1, [r4, #6]
    b8cc:	2222      	movs	r2, #34	; 0x22
    b8ce:	5499      	strb	r1, [r3, r2]
			(s8)a_data_u8[BME280_HUMIDITY_CALIB_DIG_H6];
		}
	return com_rslt;
    b8d0:	b240      	sxtb	r0, r0
    b8d2:	e001      	b.n	b8d8 <bme280_get_calib_param+0x108>
	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE};
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    b8d4:	207f      	movs	r0, #127	; 0x7f
    b8d6:	4240      	negs	r0, r0
			BME280_SHIFT_BIT_POSITION_BY_04_BITS));
			p_bme280->cal_param.dig_H6 =
			(s8)a_data_u8[BME280_HUMIDITY_CALIB_DIG_H6];
		}
	return com_rslt;
}
    b8d8:	b009      	add	sp, #36	; 0x24
    b8da:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b8dc:	00011845 	.word	0x00011845
    b8e0:	20001934 	.word	0x20001934

0000b8e4 <bme280_init>:
 *	@retval -1 -> Error
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_init(struct bme280_t *bme280)
{
    b8e4:	b570      	push	{r4, r5, r6, lr}
    b8e6:	b082      	sub	sp, #8
    b8e8:	0003      	movs	r3, r0
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_data_u8 = BME280_INIT_VALUE;
    b8ea:	466a      	mov	r2, sp
    b8ec:	1dd5      	adds	r5, r2, #7
    b8ee:	2200      	movs	r2, #0
    b8f0:	702a      	strb	r2, [r5, #0]

	p_bme280 = bme280;
    b8f2:	4e0a      	ldr	r6, [pc, #40]	; (b91c <bme280_init+0x38>)
    b8f4:	6030      	str	r0, [r6, #0]
	/* assign BME280 ptr */
	com_rslt = p_bme280->BME280_BUS_READ_FUNC(p_bme280->dev_addr,
    b8f6:	3229      	adds	r2, #41	; 0x29
    b8f8:	5c80      	ldrb	r0, [r0, r2]
    b8fa:	6b5c      	ldr	r4, [r3, #52]	; 0x34
    b8fc:	2301      	movs	r3, #1
    b8fe:	002a      	movs	r2, r5
    b900:	21d0      	movs	r1, #208	; 0xd0
    b902:	47a0      	blx	r4
    b904:	0004      	movs	r4, r0
	BME280_CHIP_ID_REG, &v_data_u8,
	BME280_GEN_READ_WRITE_DATA_LENGTH);
	/* read Chip Id */
	p_bme280->chip_id = v_data_u8;
    b906:	6832      	ldr	r2, [r6, #0]
    b908:	7829      	ldrb	r1, [r5, #0]
    b90a:	2328      	movs	r3, #40	; 0x28
    b90c:	54d1      	strb	r1, [r2, r3]

	com_rslt += bme280_get_calib_param();
    b90e:	4b04      	ldr	r3, [pc, #16]	; (b920 <bme280_init+0x3c>)
    b910:	4798      	blx	r3
    b912:	1904      	adds	r4, r0, r4
	/* readout bme280 calibparam structure */
	return com_rslt;
    b914:	b260      	sxtb	r0, r4
}
    b916:	b002      	add	sp, #8
    b918:	bd70      	pop	{r4, r5, r6, pc}
    b91a:	46c0      	nop			; (mov r8, r8)
    b91c:	20001934 	.word	0x20001934
    b920:	0000b7d1 	.word	0x0000b7d1

0000b924 <bme280_get_power_mode>:
 *	@retval -1 -> Error
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_get_power_mode(u8 *v_power_mode_u8)
{
    b924:	b570      	push	{r4, r5, r6, lr}
    b926:	b082      	sub	sp, #8
    b928:	0005      	movs	r5, r0
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_mode_u8r = BME280_INIT_VALUE;
    b92a:	2200      	movs	r2, #0
    b92c:	466b      	mov	r3, sp
    b92e:	71da      	strb	r2, [r3, #7]
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    b930:	4b0a      	ldr	r3, [pc, #40]	; (b95c <bme280_get_power_mode+0x38>)
    b932:	681b      	ldr	r3, [r3, #0]
    b934:	2b00      	cmp	r3, #0
    b936:	d00d      	beq.n	b954 <bme280_get_power_mode+0x30>
		return E_BME280_NULL_PTR;
		} else {
			com_rslt = p_bme280->BME280_BUS_READ_FUNC(
    b938:	466a      	mov	r2, sp
    b93a:	1dd4      	adds	r4, r2, #7
    b93c:	2229      	movs	r2, #41	; 0x29
    b93e:	5c98      	ldrb	r0, [r3, r2]
    b940:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    b942:	2301      	movs	r3, #1
    b944:	0022      	movs	r2, r4
    b946:	21f4      	movs	r1, #244	; 0xf4
    b948:	47b0      	blx	r6
			p_bme280->dev_addr,
			BME280_CTRL_MEAS_REG_POWER_MODE__REG,
			&v_mode_u8r, BME280_GEN_READ_WRITE_DATA_LENGTH);
			*v_power_mode_u8 = BME280_GET_BITSLICE(v_mode_u8r,
    b94a:	7823      	ldrb	r3, [r4, #0]
    b94c:	2203      	movs	r2, #3
    b94e:	4013      	ands	r3, r2
    b950:	702b      	strb	r3, [r5, #0]
			BME280_CTRL_MEAS_REG_POWER_MODE);
		}
	return com_rslt;
    b952:	e001      	b.n	b958 <bme280_get_power_mode+0x34>
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_mode_u8r = BME280_INIT_VALUE;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    b954:	207f      	movs	r0, #127	; 0x7f
    b956:	4240      	negs	r0, r0
			&v_mode_u8r, BME280_GEN_READ_WRITE_DATA_LENGTH);
			*v_power_mode_u8 = BME280_GET_BITSLICE(v_mode_u8r,
			BME280_CTRL_MEAS_REG_POWER_MODE);
		}
	return com_rslt;
}
    b958:	b002      	add	sp, #8
    b95a:	bd70      	pop	{r4, r5, r6, pc}
    b95c:	20001934 	.word	0x20001934

0000b960 <bme280_set_soft_rst>:
 *	@retval -1 -> Error
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_set_soft_rst(void)
{
    b960:	b510      	push	{r4, lr}
    b962:	b082      	sub	sp, #8
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_data_u8 = BME280_SOFT_RESET_CODE;
    b964:	22b6      	movs	r2, #182	; 0xb6
    b966:	466b      	mov	r3, sp
    b968:	71da      	strb	r2, [r3, #7]
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    b96a:	4b08      	ldr	r3, [pc, #32]	; (b98c <bme280_set_soft_rst+0x2c>)
    b96c:	681b      	ldr	r3, [r3, #0]
    b96e:	2b00      	cmp	r3, #0
    b970:	d008      	beq.n	b984 <bme280_set_soft_rst+0x24>
		return E_BME280_NULL_PTR;
		} else {
			com_rslt = p_bme280->BME280_BUS_WRITE_FUNC(
    b972:	3a8d      	subs	r2, #141	; 0x8d
    b974:	5c98      	ldrb	r0, [r3, r2]
    b976:	6b1c      	ldr	r4, [r3, #48]	; 0x30
    b978:	2301      	movs	r3, #1
    b97a:	466a      	mov	r2, sp
    b97c:	3207      	adds	r2, #7
    b97e:	21e0      	movs	r1, #224	; 0xe0
    b980:	47a0      	blx	r4
			p_bme280->dev_addr,
			BME280_RST_REG, &v_data_u8,
			BME280_GEN_READ_WRITE_DATA_LENGTH);
		}
	return com_rslt;
    b982:	e001      	b.n	b988 <bme280_set_soft_rst+0x28>
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_data_u8 = BME280_SOFT_RESET_CODE;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    b984:	207f      	movs	r0, #127	; 0x7f
    b986:	4240      	negs	r0, r0
			p_bme280->dev_addr,
			BME280_RST_REG, &v_data_u8,
			BME280_GEN_READ_WRITE_DATA_LENGTH);
		}
	return com_rslt;
}
    b988:	b002      	add	sp, #8
    b98a:	bd10      	pop	{r4, pc}
    b98c:	20001934 	.word	0x20001934

0000b990 <bme280_write_register>:
 *
 *
 */
BME280_RETURN_FUNCTION_TYPE bme280_write_register(u8 v_addr_u8,
u8 *v_data_u8, u8 v_len_u8)
{
    b990:	b570      	push	{r4, r5, r6, lr}
    b992:	0005      	movs	r5, r0
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    b994:	4c07      	ldr	r4, [pc, #28]	; (b9b4 <bme280_write_register+0x24>)
    b996:	6824      	ldr	r4, [r4, #0]
    b998:	2c00      	cmp	r4, #0
    b99a:	d007      	beq.n	b9ac <bme280_write_register+0x1c>
		return E_BME280_NULL_PTR;
		} else {
			com_rslt = p_bme280->BME280_BUS_WRITE_FUNC(
    b99c:	2329      	movs	r3, #41	; 0x29
    b99e:	5ce0      	ldrb	r0, [r4, r3]
    b9a0:	6b24      	ldr	r4, [r4, #48]	; 0x30
    b9a2:	0013      	movs	r3, r2
    b9a4:	000a      	movs	r2, r1
    b9a6:	0029      	movs	r1, r5
    b9a8:	47a0      	blx	r4
			p_bme280->dev_addr,
			v_addr_u8, v_data_u8, v_len_u8);
		}
	return com_rslt;
    b9aa:	e001      	b.n	b9b0 <bme280_write_register+0x20>
{
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    b9ac:	207f      	movs	r0, #127	; 0x7f
    b9ae:	4240      	negs	r0, r0
			com_rslt = p_bme280->BME280_BUS_WRITE_FUNC(
			p_bme280->dev_addr,
			v_addr_u8, v_data_u8, v_len_u8);
		}
	return com_rslt;
}
    b9b0:	bd70      	pop	{r4, r5, r6, pc}
    b9b2:	46c0      	nop			; (mov r8, r8)
    b9b4:	20001934 	.word	0x20001934

0000b9b8 <bme280_read_register>:
 *
 *
 */
BME280_RETURN_FUNCTION_TYPE bme280_read_register(u8 v_addr_u8,
u8 *v_data_u8, u8 v_len_u8)
{
    b9b8:	b570      	push	{r4, r5, r6, lr}
    b9ba:	0005      	movs	r5, r0
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    b9bc:	4c07      	ldr	r4, [pc, #28]	; (b9dc <bme280_read_register+0x24>)
    b9be:	6824      	ldr	r4, [r4, #0]
    b9c0:	2c00      	cmp	r4, #0
    b9c2:	d007      	beq.n	b9d4 <bme280_read_register+0x1c>
		return E_BME280_NULL_PTR;
		} else {
			com_rslt = p_bme280->BME280_BUS_READ_FUNC(
    b9c4:	2329      	movs	r3, #41	; 0x29
    b9c6:	5ce0      	ldrb	r0, [r4, r3]
    b9c8:	6b64      	ldr	r4, [r4, #52]	; 0x34
    b9ca:	0013      	movs	r3, r2
    b9cc:	000a      	movs	r2, r1
    b9ce:	0029      	movs	r1, r5
    b9d0:	47a0      	blx	r4
			p_bme280->dev_addr,
			v_addr_u8, v_data_u8, v_len_u8);
		}
	return com_rslt;
    b9d2:	e001      	b.n	b9d8 <bme280_read_register+0x20>
{
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    b9d4:	207f      	movs	r0, #127	; 0x7f
    b9d6:	4240      	negs	r0, r0
			com_rslt = p_bme280->BME280_BUS_READ_FUNC(
			p_bme280->dev_addr,
			v_addr_u8, v_data_u8, v_len_u8);
		}
	return com_rslt;
}
    b9d8:	bd70      	pop	{r4, r5, r6, pc}
    b9da:	46c0      	nop			; (mov r8, r8)
    b9dc:	20001934 	.word	0x20001934

0000b9e0 <bme280_set_oversamp_temperature>:
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_set_oversamp_temperature(
u8 v_value_u8)
{
    b9e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    b9e2:	b083      	sub	sp, #12
    b9e4:	0004      	movs	r4, r0
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_data_u8 = BME280_INIT_VALUE;
    b9e6:	2300      	movs	r3, #0
    b9e8:	466a      	mov	r2, sp
    b9ea:	71d3      	strb	r3, [r2, #7]
	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;
    b9ec:	466a      	mov	r2, sp
    b9ee:	7193      	strb	r3, [r2, #6]
	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;
    b9f0:	466a      	mov	r2, sp
    b9f2:	7153      	strb	r3, [r2, #5]
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
    b9f4:	aa01      	add	r2, sp, #4
    b9f6:	7013      	strb	r3, [r2, #0]
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    b9f8:	4b32      	ldr	r3, [pc, #200]	; (bac4 <bme280_set_oversamp_temperature+0xe4>)
    b9fa:	681b      	ldr	r3, [r3, #0]
    b9fc:	2b00      	cmp	r3, #0
    b9fe:	d05d      	beq.n	babc <bme280_set_oversamp_temperature+0xdc>
		return E_BME280_NULL_PTR;
		} else {
			v_data_u8 = p_bme280->ctrl_meas_reg;
    ba00:	222e      	movs	r2, #46	; 0x2e
			v_data_u8 =
    ba02:	5c9b      	ldrb	r3, [r3, r2]
    ba04:	3a0f      	subs	r2, #15
    ba06:	4013      	ands	r3, r2
    ba08:	0142      	lsls	r2, r0, #5
    ba0a:	4313      	orrs	r3, r2
    ba0c:	466a      	mov	r2, sp
    ba0e:	71d3      	strb	r3, [r2, #7]
			BME280_SET_BITSLICE(v_data_u8,
			BME280_CTRL_MEAS_REG_OVERSAMP_TEMPERATURE, v_value_u8);
			com_rslt = bme280_get_power_mode(&v_prev_pow_mode_u8);
    ba10:	466b      	mov	r3, sp
    ba12:	1d9d      	adds	r5, r3, #6
    ba14:	0028      	movs	r0, r5
    ba16:	4b2c      	ldr	r3, [pc, #176]	; (bac8 <bme280_set_oversamp_temperature+0xe8>)
    ba18:	4798      	blx	r3
			if (v_prev_pow_mode_u8 != BME280_SLEEP_MODE) {
    ba1a:	782b      	ldrb	r3, [r5, #0]
    ba1c:	2b00      	cmp	r3, #0
    ba1e:	d01e      	beq.n	ba5e <bme280_set_oversamp_temperature+0x7e>
				com_rslt += bme280_set_soft_rst();
    ba20:	4b2a      	ldr	r3, [pc, #168]	; (bacc <bme280_set_oversamp_temperature+0xec>)
    ba22:	4798      	blx	r3
				p_bme280->delay_msec(BME280_3MS_DELAY);
    ba24:	4e27      	ldr	r6, [pc, #156]	; (bac4 <bme280_set_oversamp_temperature+0xe4>)
    ba26:	6833      	ldr	r3, [r6, #0]
    ba28:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    ba2a:	2003      	movs	r0, #3
    ba2c:	4798      	blx	r3
				/* write previous value
				of configuration register*/
				v_pre_config_value_u8 = p_bme280->config_reg;
    ba2e:	a901      	add	r1, sp, #4
    ba30:	232f      	movs	r3, #47	; 0x2f
    ba32:	6832      	ldr	r2, [r6, #0]
    ba34:	5cd3      	ldrb	r3, [r2, r3]
    ba36:	700b      	strb	r3, [r1, #0]
				com_rslt += bme280_write_register(
    ba38:	2201      	movs	r2, #1
    ba3a:	20f5      	movs	r0, #245	; 0xf5
    ba3c:	4d24      	ldr	r5, [pc, #144]	; (bad0 <bme280_set_oversamp_temperature+0xf0>)
    ba3e:	47a8      	blx	r5
					BME280_CONFIG_REG,
				&v_pre_config_value_u8,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous value
				of humidity oversampling*/
				v_pre_ctrl_hum_value_u8 =
    ba40:	466b      	mov	r3, sp
    ba42:	1d59      	adds	r1, r3, #5
				p_bme280->ctrl_hum_reg;
    ba44:	6832      	ldr	r2, [r6, #0]
    ba46:	232d      	movs	r3, #45	; 0x2d
					BME280_CONFIG_REG,
				&v_pre_config_value_u8,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous value
				of humidity oversampling*/
				v_pre_ctrl_hum_value_u8 =
    ba48:	5cd3      	ldrb	r3, [r2, r3]
    ba4a:	700b      	strb	r3, [r1, #0]
				p_bme280->ctrl_hum_reg;
				com_rslt += bme280_write_register(
    ba4c:	2201      	movs	r2, #1
    ba4e:	20f2      	movs	r0, #242	; 0xf2
    ba50:	47a8      	blx	r5
					BME280_CTRL_HUMIDITY_REG,
				&v_pre_ctrl_hum_value_u8,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous and updated value
				of configuration register*/
				com_rslt += bme280_write_register(
    ba52:	2201      	movs	r2, #1
    ba54:	466b      	mov	r3, sp
    ba56:	1dd9      	adds	r1, r3, #7
    ba58:	20f4      	movs	r0, #244	; 0xf4
    ba5a:	47a8      	blx	r5
    ba5c:	e009      	b.n	ba72 <bme280_set_oversamp_temperature+0x92>
					BME280_CTRL_MEAS_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			} else {
				com_rslt = p_bme280->BME280_BUS_WRITE_FUNC(
    ba5e:	4b19      	ldr	r3, [pc, #100]	; (bac4 <bme280_set_oversamp_temperature+0xe4>)
    ba60:	681b      	ldr	r3, [r3, #0]
    ba62:	2229      	movs	r2, #41	; 0x29
    ba64:	5c98      	ldrb	r0, [r3, r2]
    ba66:	6b1d      	ldr	r5, [r3, #48]	; 0x30
    ba68:	2301      	movs	r3, #1
    ba6a:	466a      	mov	r2, sp
    ba6c:	3207      	adds	r2, #7
    ba6e:	21f4      	movs	r1, #244	; 0xf4
    ba70:	47a8      	blx	r5
				p_bme280->dev_addr,
				BME280_CTRL_MEAS_REG_OVERSAMP_TEMPERATURE__REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			}
				p_bme280->oversamp_temperature = v_value_u8;
    ba72:	4e14      	ldr	r6, [pc, #80]	; (bac4 <bme280_set_oversamp_temperature+0xe4>)
    ba74:	232a      	movs	r3, #42	; 0x2a
    ba76:	6832      	ldr	r2, [r6, #0]
    ba78:	54d4      	strb	r4, [r2, r3]
				/* read the control measurement register value*/
				com_rslt = bme280_read_register(
    ba7a:	466b      	mov	r3, sp
    ba7c:	1ddc      	adds	r4, r3, #7
    ba7e:	2201      	movs	r2, #1
    ba80:	0021      	movs	r1, r4
    ba82:	20f4      	movs	r0, #244	; 0xf4
    ba84:	4f13      	ldr	r7, [pc, #76]	; (bad4 <bme280_set_oversamp_temperature+0xf4>)
    ba86:	47b8      	blx	r7
    ba88:	0005      	movs	r5, r0
					BME280_CTRL_MEAS_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->ctrl_meas_reg = v_data_u8;
    ba8a:	7822      	ldrb	r2, [r4, #0]
    ba8c:	232e      	movs	r3, #46	; 0x2e
    ba8e:	6831      	ldr	r1, [r6, #0]
    ba90:	54ca      	strb	r2, [r1, r3]
				/* read the control humidity register value*/
				com_rslt += bme280_read_register(
    ba92:	2201      	movs	r2, #1
    ba94:	0021      	movs	r1, r4
    ba96:	20f2      	movs	r0, #242	; 0xf2
    ba98:	47b8      	blx	r7
    ba9a:	1945      	adds	r5, r0, r5
    ba9c:	b2ed      	uxtb	r5, r5
					BME280_CTRL_HUMIDITY_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->ctrl_hum_reg = v_data_u8;
    ba9e:	7822      	ldrb	r2, [r4, #0]
    baa0:	232d      	movs	r3, #45	; 0x2d
    baa2:	6831      	ldr	r1, [r6, #0]
    baa4:	54ca      	strb	r2, [r1, r3]
				/* read the control
				configuration register value*/
				com_rslt += bme280_read_register(
    baa6:	2201      	movs	r2, #1
    baa8:	0021      	movs	r1, r4
    baaa:	20f5      	movs	r0, #245	; 0xf5
    baac:	47b8      	blx	r7
    baae:	1828      	adds	r0, r5, r0
					BME280_CONFIG_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->config_reg = v_data_u8;
    bab0:	6832      	ldr	r2, [r6, #0]
    bab2:	7821      	ldrb	r1, [r4, #0]
    bab4:	232f      	movs	r3, #47	; 0x2f
    bab6:	54d1      	strb	r1, [r2, r3]
		}
	return com_rslt;
    bab8:	b240      	sxtb	r0, r0
    baba:	e001      	b.n	bac0 <bme280_set_oversamp_temperature+0xe0>
	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;
	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    babc:	207f      	movs	r0, #127	; 0x7f
    babe:	4240      	negs	r0, r0
					BME280_CONFIG_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->config_reg = v_data_u8;
		}
	return com_rslt;
}
    bac0:	b003      	add	sp, #12
    bac2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bac4:	20001934 	.word	0x20001934
    bac8:	0000b925 	.word	0x0000b925
    bacc:	0000b961 	.word	0x0000b961
    bad0:	0000b991 	.word	0x0000b991
    bad4:	0000b9b9 	.word	0x0000b9b9

0000bad8 <bme280_set_oversamp_pressure>:
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_set_oversamp_pressure(
u8 v_value_u8)
{
    bad8:	b5f0      	push	{r4, r5, r6, r7, lr}
    bada:	b083      	sub	sp, #12
    badc:	0004      	movs	r4, r0
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_data_u8 = BME280_INIT_VALUE;
    bade:	2300      	movs	r3, #0
    bae0:	466a      	mov	r2, sp
    bae2:	71d3      	strb	r3, [r2, #7]
	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;
    bae4:	466a      	mov	r2, sp
    bae6:	7193      	strb	r3, [r2, #6]
	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;
    bae8:	466a      	mov	r2, sp
    baea:	7153      	strb	r3, [r2, #5]
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
    baec:	aa01      	add	r2, sp, #4
    baee:	7013      	strb	r3, [r2, #0]
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    baf0:	4b34      	ldr	r3, [pc, #208]	; (bbc4 <bme280_set_oversamp_pressure+0xec>)
    baf2:	681b      	ldr	r3, [r3, #0]
    baf4:	2b00      	cmp	r3, #0
    baf6:	d060      	beq.n	bbba <bme280_set_oversamp_pressure+0xe2>
		return E_BME280_NULL_PTR;
		} else {
			v_data_u8 = p_bme280->ctrl_meas_reg;
    baf8:	222e      	movs	r2, #46	; 0x2e
			v_data_u8 =
    bafa:	5c9b      	ldrb	r3, [r3, r2]
    bafc:	3a12      	subs	r2, #18
    bafe:	4393      	bics	r3, r2
    bb00:	0019      	movs	r1, r3
    bb02:	0082      	lsls	r2, r0, #2
    bb04:	231c      	movs	r3, #28
    bb06:	4013      	ands	r3, r2
    bb08:	430b      	orrs	r3, r1
    bb0a:	466a      	mov	r2, sp
    bb0c:	71d3      	strb	r3, [r2, #7]
			BME280_SET_BITSLICE(v_data_u8,
			BME280_CTRL_MEAS_REG_OVERSAMP_PRESSURE, v_value_u8);
			com_rslt = bme280_get_power_mode(&v_prev_pow_mode_u8);
    bb0e:	466b      	mov	r3, sp
    bb10:	1d9d      	adds	r5, r3, #6
    bb12:	0028      	movs	r0, r5
    bb14:	4b2c      	ldr	r3, [pc, #176]	; (bbc8 <bme280_set_oversamp_pressure+0xf0>)
    bb16:	4798      	blx	r3
			if (v_prev_pow_mode_u8 != BME280_SLEEP_MODE) {
    bb18:	782b      	ldrb	r3, [r5, #0]
    bb1a:	2b00      	cmp	r3, #0
    bb1c:	d01e      	beq.n	bb5c <bme280_set_oversamp_pressure+0x84>
				com_rslt += bme280_set_soft_rst();
    bb1e:	4b2b      	ldr	r3, [pc, #172]	; (bbcc <bme280_set_oversamp_pressure+0xf4>)
    bb20:	4798      	blx	r3
				p_bme280->delay_msec(BME280_3MS_DELAY);
    bb22:	4e28      	ldr	r6, [pc, #160]	; (bbc4 <bme280_set_oversamp_pressure+0xec>)
    bb24:	6833      	ldr	r3, [r6, #0]
    bb26:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    bb28:	2003      	movs	r0, #3
    bb2a:	4798      	blx	r3
				/* write previous value of
				configuration register*/
				v_pre_config_value_u8 = p_bme280->config_reg;
    bb2c:	a901      	add	r1, sp, #4
    bb2e:	232f      	movs	r3, #47	; 0x2f
    bb30:	6832      	ldr	r2, [r6, #0]
    bb32:	5cd3      	ldrb	r3, [r2, r3]
    bb34:	700b      	strb	r3, [r1, #0]
				com_rslt = bme280_write_register(
    bb36:	2201      	movs	r2, #1
    bb38:	20f5      	movs	r0, #245	; 0xf5
    bb3a:	4d25      	ldr	r5, [pc, #148]	; (bbd0 <bme280_set_oversamp_pressure+0xf8>)
    bb3c:	47a8      	blx	r5
					BME280_CONFIG_REG,
				&v_pre_config_value_u8,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous value of
				humidity oversampling*/
				v_pre_ctrl_hum_value_u8 =
    bb3e:	466b      	mov	r3, sp
    bb40:	1d59      	adds	r1, r3, #5
				p_bme280->ctrl_hum_reg;
    bb42:	6832      	ldr	r2, [r6, #0]
    bb44:	232d      	movs	r3, #45	; 0x2d
					BME280_CONFIG_REG,
				&v_pre_config_value_u8,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous value of
				humidity oversampling*/
				v_pre_ctrl_hum_value_u8 =
    bb46:	5cd3      	ldrb	r3, [r2, r3]
    bb48:	700b      	strb	r3, [r1, #0]
				p_bme280->ctrl_hum_reg;
				com_rslt += bme280_write_register(
    bb4a:	2201      	movs	r2, #1
    bb4c:	20f2      	movs	r0, #242	; 0xf2
    bb4e:	47a8      	blx	r5
					BME280_CTRL_HUMIDITY_REG,
				&v_pre_ctrl_hum_value_u8,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous and updated value of
				control measurement register*/
				bme280_write_register(
    bb50:	2201      	movs	r2, #1
    bb52:	466b      	mov	r3, sp
    bb54:	1dd9      	adds	r1, r3, #7
    bb56:	20f4      	movs	r0, #244	; 0xf4
    bb58:	47a8      	blx	r5
    bb5a:	e009      	b.n	bb70 <bme280_set_oversamp_pressure+0x98>
					BME280_CTRL_MEAS_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			} else {
				com_rslt = p_bme280->BME280_BUS_WRITE_FUNC(
    bb5c:	4b19      	ldr	r3, [pc, #100]	; (bbc4 <bme280_set_oversamp_pressure+0xec>)
    bb5e:	681b      	ldr	r3, [r3, #0]
    bb60:	2229      	movs	r2, #41	; 0x29
    bb62:	5c98      	ldrb	r0, [r3, r2]
    bb64:	6b1d      	ldr	r5, [r3, #48]	; 0x30
    bb66:	2301      	movs	r3, #1
    bb68:	466a      	mov	r2, sp
    bb6a:	3207      	adds	r2, #7
    bb6c:	21f4      	movs	r1, #244	; 0xf4
    bb6e:	47a8      	blx	r5
				p_bme280->dev_addr,
				BME280_CTRL_MEAS_REG_OVERSAMP_PRESSURE__REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			}
				p_bme280->oversamp_pressure = v_value_u8;
    bb70:	4e14      	ldr	r6, [pc, #80]	; (bbc4 <bme280_set_oversamp_pressure+0xec>)
    bb72:	232b      	movs	r3, #43	; 0x2b
    bb74:	6832      	ldr	r2, [r6, #0]
    bb76:	54d4      	strb	r4, [r2, r3]
				/* read the control measurement register value*/
				com_rslt = bme280_read_register(
    bb78:	466b      	mov	r3, sp
    bb7a:	1ddc      	adds	r4, r3, #7
    bb7c:	2201      	movs	r2, #1
    bb7e:	0021      	movs	r1, r4
    bb80:	20f4      	movs	r0, #244	; 0xf4
    bb82:	4f14      	ldr	r7, [pc, #80]	; (bbd4 <bme280_set_oversamp_pressure+0xfc>)
    bb84:	47b8      	blx	r7
    bb86:	0005      	movs	r5, r0
					BME280_CTRL_MEAS_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->ctrl_meas_reg = v_data_u8;
    bb88:	7822      	ldrb	r2, [r4, #0]
    bb8a:	232e      	movs	r3, #46	; 0x2e
    bb8c:	6831      	ldr	r1, [r6, #0]
    bb8e:	54ca      	strb	r2, [r1, r3]
				/* read the control humidity register value*/
				com_rslt += bme280_read_register(
    bb90:	2201      	movs	r2, #1
    bb92:	0021      	movs	r1, r4
    bb94:	20f2      	movs	r0, #242	; 0xf2
    bb96:	47b8      	blx	r7
    bb98:	1945      	adds	r5, r0, r5
    bb9a:	b2ed      	uxtb	r5, r5
					BME280_CTRL_HUMIDITY_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->ctrl_hum_reg = v_data_u8;
    bb9c:	7822      	ldrb	r2, [r4, #0]
    bb9e:	232d      	movs	r3, #45	; 0x2d
    bba0:	6831      	ldr	r1, [r6, #0]
    bba2:	54ca      	strb	r2, [r1, r3]
				/* read the control
				configuration register value*/
				com_rslt += bme280_read_register(
    bba4:	2201      	movs	r2, #1
    bba6:	0021      	movs	r1, r4
    bba8:	20f5      	movs	r0, #245	; 0xf5
    bbaa:	47b8      	blx	r7
    bbac:	1828      	adds	r0, r5, r0
					BME280_CONFIG_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->config_reg = v_data_u8;
    bbae:	6832      	ldr	r2, [r6, #0]
    bbb0:	7821      	ldrb	r1, [r4, #0]
    bbb2:	232f      	movs	r3, #47	; 0x2f
    bbb4:	54d1      	strb	r1, [r2, r3]
		}
	return com_rslt;
    bbb6:	b240      	sxtb	r0, r0
    bbb8:	e001      	b.n	bbbe <bme280_set_oversamp_pressure+0xe6>
	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;
	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    bbba:	207f      	movs	r0, #127	; 0x7f
    bbbc:	4240      	negs	r0, r0
					BME280_CONFIG_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->config_reg = v_data_u8;
		}
	return com_rslt;
}
    bbbe:	b003      	add	sp, #12
    bbc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bbc2:	46c0      	nop			; (mov r8, r8)
    bbc4:	20001934 	.word	0x20001934
    bbc8:	0000b925 	.word	0x0000b925
    bbcc:	0000b961 	.word	0x0000b961
    bbd0:	0000b991 	.word	0x0000b991
    bbd4:	0000b9b9 	.word	0x0000b9b9

0000bbd8 <bme280_set_oversamp_humidity>:
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_set_oversamp_humidity(
u8 v_value_u8)
{
    bbd8:	b5f0      	push	{r4, r5, r6, r7, lr}
    bbda:	4647      	mov	r7, r8
    bbdc:	b480      	push	{r7}
    bbde:	b082      	sub	sp, #8
    bbe0:	0007      	movs	r7, r0
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_data_u8 = BME280_INIT_VALUE;
    bbe2:	2300      	movs	r3, #0
    bbe4:	466a      	mov	r2, sp
    bbe6:	71d3      	strb	r3, [r2, #7]
	u8 pre_ctrl_meas_value = BME280_INIT_VALUE;
    bbe8:	466a      	mov	r2, sp
    bbea:	7193      	strb	r3, [r2, #6]
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
    bbec:	466a      	mov	r2, sp
    bbee:	7153      	strb	r3, [r2, #5]
	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;
    bbf0:	aa01      	add	r2, sp, #4
    bbf2:	7013      	strb	r3, [r2, #0]
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    bbf4:	4b40      	ldr	r3, [pc, #256]	; (bcf8 <bme280_set_oversamp_humidity+0x120>)
    bbf6:	681b      	ldr	r3, [r3, #0]
    bbf8:	2b00      	cmp	r3, #0
    bbfa:	d077      	beq.n	bcec <bme280_set_oversamp_humidity+0x114>
		return E_BME280_NULL_PTR;
		} else {
			/* write humidity oversampling*/
			v_data_u8 = p_bme280->ctrl_hum_reg;
    bbfc:	222d      	movs	r2, #45	; 0x2d
			v_data_u8 =
    bbfe:	5c9b      	ldrb	r3, [r3, r2]
    bc00:	3a26      	subs	r2, #38	; 0x26
    bc02:	4393      	bics	r3, r2
    bc04:	001a      	movs	r2, r3
    bc06:	2307      	movs	r3, #7
    bc08:	4003      	ands	r3, r0
    bc0a:	4313      	orrs	r3, r2
    bc0c:	466a      	mov	r2, sp
    bc0e:	71d3      	strb	r3, [r2, #7]
			BME280_SET_BITSLICE(v_data_u8,
			BME280_CTRL_HUMIDITY_REG_OVERSAMP_HUMIDITY, v_value_u8);
			com_rslt = bme280_get_power_mode(&v_prev_pow_mode_u8);
    bc10:	ac01      	add	r4, sp, #4
    bc12:	0020      	movs	r0, r4
    bc14:	4b39      	ldr	r3, [pc, #228]	; (bcfc <bme280_set_oversamp_humidity+0x124>)
    bc16:	4798      	blx	r3
    bc18:	0005      	movs	r5, r0
			if (v_prev_pow_mode_u8 != BME280_SLEEP_MODE) {
    bc1a:	7823      	ldrb	r3, [r4, #0]
    bc1c:	2b00      	cmp	r3, #0
    bc1e:	d027      	beq.n	bc70 <bme280_set_oversamp_humidity+0x98>
				com_rslt += bme280_set_soft_rst();
    bc20:	4b37      	ldr	r3, [pc, #220]	; (bd00 <bme280_set_oversamp_humidity+0x128>)
    bc22:	4798      	blx	r3
    bc24:	4680      	mov	r8, r0
				p_bme280->delay_msec(BME280_3MS_DELAY);
    bc26:	4c34      	ldr	r4, [pc, #208]	; (bcf8 <bme280_set_oversamp_humidity+0x120>)
    bc28:	6823      	ldr	r3, [r4, #0]
    bc2a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    bc2c:	2003      	movs	r0, #3
    bc2e:	4798      	blx	r3
				/* write previous value of
				configuration register*/
				v_pre_config_value_u8 = p_bme280->config_reg;
    bc30:	466b      	mov	r3, sp
    bc32:	1d59      	adds	r1, r3, #5
    bc34:	232f      	movs	r3, #47	; 0x2f
    bc36:	6822      	ldr	r2, [r4, #0]
    bc38:	5cd3      	ldrb	r3, [r2, r3]
    bc3a:	700b      	strb	r3, [r1, #0]
				com_rslt += bme280_write_register(
    bc3c:	2201      	movs	r2, #1
    bc3e:	20f5      	movs	r0, #245	; 0xf5
    bc40:	4e30      	ldr	r6, [pc, #192]	; (bd04 <bme280_set_oversamp_humidity+0x12c>)
    bc42:	47b0      	blx	r6
    bc44:	4440      	add	r0, r8
    bc46:	1945      	adds	r5, r0, r5
    bc48:	b2ed      	uxtb	r5, r5
					BME280_CONFIG_REG,
				&v_pre_config_value_u8,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write the value of control humidity*/
				com_rslt += bme280_write_register(
    bc4a:	2201      	movs	r2, #1
    bc4c:	466b      	mov	r3, sp
    bc4e:	1dd9      	adds	r1, r3, #7
    bc50:	20f2      	movs	r0, #242	; 0xf2
    bc52:	47b0      	blx	r6
    bc54:	182d      	adds	r5, r5, r0
    bc56:	b2ed      	uxtb	r5, r5
					BME280_CTRL_HUMIDITY_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous value of
				control measurement register*/
				pre_ctrl_meas_value =
    bc58:	466b      	mov	r3, sp
    bc5a:	1d99      	adds	r1, r3, #6
				p_bme280->ctrl_meas_reg;
    bc5c:	6822      	ldr	r2, [r4, #0]
    bc5e:	232e      	movs	r3, #46	; 0x2e
				com_rslt += bme280_write_register(
					BME280_CTRL_HUMIDITY_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous value of
				control measurement register*/
				pre_ctrl_meas_value =
    bc60:	5cd3      	ldrb	r3, [r2, r3]
    bc62:	700b      	strb	r3, [r1, #0]
				p_bme280->ctrl_meas_reg;
				com_rslt += bme280_write_register(
    bc64:	2201      	movs	r2, #1
    bc66:	20f4      	movs	r0, #244	; 0xf4
    bc68:	47b0      	blx	r6
    bc6a:	1828      	adds	r0, r5, r0
    bc6c:	b244      	sxtb	r4, r0
    bc6e:	e017      	b.n	bca0 <bme280_set_oversamp_humidity+0xc8>
					BME280_CTRL_MEAS_REG,
				&pre_ctrl_meas_value,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
			} else {
				com_rslt +=
				p_bme280->BME280_BUS_WRITE_FUNC(
    bc70:	4e21      	ldr	r6, [pc, #132]	; (bcf8 <bme280_set_oversamp_humidity+0x120>)
    bc72:	6833      	ldr	r3, [r6, #0]
    bc74:	2229      	movs	r2, #41	; 0x29
    bc76:	5c98      	ldrb	r0, [r3, r2]
    bc78:	6b1c      	ldr	r4, [r3, #48]	; 0x30
    bc7a:	2301      	movs	r3, #1
    bc7c:	466a      	mov	r2, sp
    bc7e:	3207      	adds	r2, #7
    bc80:	21f2      	movs	r1, #242	; 0xf2
    bc82:	47a0      	blx	r4
    bc84:	0004      	movs	r4, r0
				p_bme280->dev_addr,
				BME280_CTRL_HUMIDITY_REG_OVERSAMP_HUMIDITY__REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* Control humidity write will effective only
				after the control measurement register*/
				pre_ctrl_meas_value =
    bc86:	466b      	mov	r3, sp
    bc88:	1d99      	adds	r1, r3, #6
				p_bme280->ctrl_meas_reg;
    bc8a:	6832      	ldr	r2, [r6, #0]
    bc8c:	232e      	movs	r3, #46	; 0x2e
				p_bme280->dev_addr,
				BME280_CTRL_HUMIDITY_REG_OVERSAMP_HUMIDITY__REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* Control humidity write will effective only
				after the control measurement register*/
				pre_ctrl_meas_value =
    bc8e:	5cd3      	ldrb	r3, [r2, r3]
    bc90:	700b      	strb	r3, [r1, #0]
				p_bme280->ctrl_meas_reg;
				com_rslt += bme280_write_register(
    bc92:	2201      	movs	r2, #1
    bc94:	20f4      	movs	r0, #244	; 0xf4
    bc96:	4b1b      	ldr	r3, [pc, #108]	; (bd04 <bme280_set_oversamp_humidity+0x12c>)
    bc98:	4798      	blx	r3
    bc9a:	1824      	adds	r4, r4, r0
    bc9c:	1965      	adds	r5, r4, r5
    bc9e:	b26c      	sxtb	r4, r5
					BME280_CTRL_MEAS_REG,
				&pre_ctrl_meas_value,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
			}
			p_bme280->oversamp_humidity = v_value_u8;
    bca0:	4e15      	ldr	r6, [pc, #84]	; (bcf8 <bme280_set_oversamp_humidity+0x120>)
    bca2:	232c      	movs	r3, #44	; 0x2c
    bca4:	6832      	ldr	r2, [r6, #0]
    bca6:	54d7      	strb	r7, [r2, r3]
			/* read the control measurement register value*/
			com_rslt += bme280_read_register(BME280_CTRL_MEAS_REG,
    bca8:	466b      	mov	r3, sp
    bcaa:	1ddd      	adds	r5, r3, #7
    bcac:	2201      	movs	r2, #1
    bcae:	0029      	movs	r1, r5
    bcb0:	20f4      	movs	r0, #244	; 0xf4
    bcb2:	4f15      	ldr	r7, [pc, #84]	; (bd08 <bme280_set_oversamp_humidity+0x130>)
    bcb4:	47b8      	blx	r7
    bcb6:	1904      	adds	r4, r0, r4
    bcb8:	b2e4      	uxtb	r4, r4
			&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			p_bme280->ctrl_meas_reg = v_data_u8;
    bcba:	782a      	ldrb	r2, [r5, #0]
    bcbc:	232e      	movs	r3, #46	; 0x2e
    bcbe:	6831      	ldr	r1, [r6, #0]
    bcc0:	54ca      	strb	r2, [r1, r3]
			/* read the control humidity register value*/
			com_rslt += bme280_read_register(
    bcc2:	2201      	movs	r2, #1
    bcc4:	0029      	movs	r1, r5
    bcc6:	20f2      	movs	r0, #242	; 0xf2
    bcc8:	47b8      	blx	r7
    bcca:	1824      	adds	r4, r4, r0
    bccc:	b2e4      	uxtb	r4, r4
			BME280_CTRL_HUMIDITY_REG,
			&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			p_bme280->ctrl_hum_reg = v_data_u8;
    bcce:	782a      	ldrb	r2, [r5, #0]
    bcd0:	232d      	movs	r3, #45	; 0x2d
    bcd2:	6831      	ldr	r1, [r6, #0]
    bcd4:	54ca      	strb	r2, [r1, r3]
			/* read the control configuration register value*/
			com_rslt += bme280_read_register(BME280_CONFIG_REG,
    bcd6:	2201      	movs	r2, #1
    bcd8:	0029      	movs	r1, r5
    bcda:	20f5      	movs	r0, #245	; 0xf5
    bcdc:	47b8      	blx	r7
    bcde:	1820      	adds	r0, r4, r0
			&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			p_bme280->config_reg = v_data_u8;
    bce0:	6832      	ldr	r2, [r6, #0]
    bce2:	7829      	ldrb	r1, [r5, #0]
    bce4:	232f      	movs	r3, #47	; 0x2f
    bce6:	54d1      	strb	r1, [r2, r3]
		}
	return com_rslt;
    bce8:	b240      	sxtb	r0, r0
    bcea:	e001      	b.n	bcf0 <bme280_set_oversamp_humidity+0x118>
	u8 pre_ctrl_meas_value = BME280_INIT_VALUE;
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    bcec:	207f      	movs	r0, #127	; 0x7f
    bcee:	4240      	negs	r0, r0
			com_rslt += bme280_read_register(BME280_CONFIG_REG,
			&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			p_bme280->config_reg = v_data_u8;
		}
	return com_rslt;
}
    bcf0:	b002      	add	sp, #8
    bcf2:	bc04      	pop	{r2}
    bcf4:	4690      	mov	r8, r2
    bcf6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bcf8:	20001934 	.word	0x20001934
    bcfc:	0000b925 	.word	0x0000b925
    bd00:	0000b961 	.word	0x0000b961
    bd04:	0000b991 	.word	0x0000b991
    bd08:	0000b9b9 	.word	0x0000b9b9

0000bd0c <bme280_set_power_mode>:
 *	@retval -1 -> Error
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_set_power_mode(u8 v_power_mode_u8)
{
    bd0c:	b5f0      	push	{r4, r5, r6, r7, lr}
    bd0e:	b083      	sub	sp, #12
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_mode_u8r = BME280_INIT_VALUE;
    bd10:	2300      	movs	r3, #0
    bd12:	466a      	mov	r2, sp
    bd14:	71d3      	strb	r3, [r2, #7]
	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;
    bd16:	466a      	mov	r2, sp
    bd18:	7193      	strb	r3, [r2, #6]
	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;
    bd1a:	466a      	mov	r2, sp
    bd1c:	7153      	strb	r3, [r2, #5]
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
    bd1e:	aa01      	add	r2, sp, #4
    bd20:	7013      	strb	r3, [r2, #0]
	u8 v_data_u8 = BME280_INIT_VALUE;
    bd22:	466a      	mov	r2, sp
    bd24:	70d3      	strb	r3, [r2, #3]
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    bd26:	4b34      	ldr	r3, [pc, #208]	; (bdf8 <bme280_set_power_mode+0xec>)
    bd28:	681b      	ldr	r3, [r3, #0]
    bd2a:	2b00      	cmp	r3, #0
    bd2c:	d05c      	beq.n	bde8 <bme280_set_power_mode+0xdc>
		return E_BME280_NULL_PTR;
		} else {
			if (v_power_mode_u8 <= BME280_NORMAL_MODE) {
    bd2e:	2803      	cmp	r0, #3
    bd30:	d85d      	bhi.n	bdee <bme280_set_power_mode+0xe2>
				v_mode_u8r = p_bme280->ctrl_meas_reg;
    bd32:	222e      	movs	r2, #46	; 0x2e
				v_mode_u8r =
    bd34:	5c9b      	ldrb	r3, [r3, r2]
    bd36:	3a2b      	subs	r2, #43	; 0x2b
    bd38:	4393      	bics	r3, r2
    bd3a:	4010      	ands	r0, r2
    bd3c:	4318      	orrs	r0, r3
    bd3e:	466b      	mov	r3, sp
    bd40:	71d8      	strb	r0, [r3, #7]
				BME280_SET_BITSLICE(v_mode_u8r,
				BME280_CTRL_MEAS_REG_POWER_MODE,
				v_power_mode_u8);
				com_rslt = bme280_get_power_mode(
    bd42:	466b      	mov	r3, sp
    bd44:	1d9c      	adds	r4, r3, #6
    bd46:	0020      	movs	r0, r4
    bd48:	4b2c      	ldr	r3, [pc, #176]	; (bdfc <bme280_set_power_mode+0xf0>)
    bd4a:	4798      	blx	r3
					&v_prev_pow_mode_u8);
				if (v_prev_pow_mode_u8 != BME280_SLEEP_MODE) {
    bd4c:	7823      	ldrb	r3, [r4, #0]
    bd4e:	2b00      	cmp	r3, #0
    bd50:	d01e      	beq.n	bd90 <bme280_set_power_mode+0x84>
					com_rslt += bme280_set_soft_rst();
    bd52:	4b2b      	ldr	r3, [pc, #172]	; (be00 <bme280_set_power_mode+0xf4>)
    bd54:	4798      	blx	r3
					p_bme280->delay_msec(BME280_3MS_DELAY);
    bd56:	4d28      	ldr	r5, [pc, #160]	; (bdf8 <bme280_set_power_mode+0xec>)
    bd58:	682b      	ldr	r3, [r5, #0]
    bd5a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    bd5c:	2003      	movs	r0, #3
    bd5e:	4798      	blx	r3
					/* write previous value of
					configuration register*/
					v_pre_config_value_u8 =
    bd60:	a901      	add	r1, sp, #4
					p_bme280->config_reg;
    bd62:	232f      	movs	r3, #47	; 0x2f
				if (v_prev_pow_mode_u8 != BME280_SLEEP_MODE) {
					com_rslt += bme280_set_soft_rst();
					p_bme280->delay_msec(BME280_3MS_DELAY);
					/* write previous value of
					configuration register*/
					v_pre_config_value_u8 =
    bd64:	682a      	ldr	r2, [r5, #0]
    bd66:	5cd3      	ldrb	r3, [r2, r3]
    bd68:	700b      	strb	r3, [r1, #0]
					p_bme280->config_reg;
					com_rslt = bme280_write_register(
    bd6a:	2201      	movs	r2, #1
    bd6c:	20f5      	movs	r0, #245	; 0xf5
    bd6e:	4c25      	ldr	r4, [pc, #148]	; (be04 <bme280_set_power_mode+0xf8>)
    bd70:	47a0      	blx	r4
						BME280_CONFIG_REG,
					&v_pre_config_value_u8,
					BME280_GEN_READ_WRITE_DATA_LENGTH);
					/* write previous value of
					humidity oversampling*/
					v_pre_ctrl_hum_value_u8 =
    bd72:	466b      	mov	r3, sp
    bd74:	1d59      	adds	r1, r3, #5
					p_bme280->ctrl_hum_reg;
    bd76:	682a      	ldr	r2, [r5, #0]
    bd78:	232d      	movs	r3, #45	; 0x2d
						BME280_CONFIG_REG,
					&v_pre_config_value_u8,
					BME280_GEN_READ_WRITE_DATA_LENGTH);
					/* write previous value of
					humidity oversampling*/
					v_pre_ctrl_hum_value_u8 =
    bd7a:	5cd3      	ldrb	r3, [r2, r3]
    bd7c:	700b      	strb	r3, [r1, #0]
					p_bme280->ctrl_hum_reg;
					com_rslt += bme280_write_register(
    bd7e:	2201      	movs	r2, #1
    bd80:	20f2      	movs	r0, #242	; 0xf2
    bd82:	47a0      	blx	r4
					BME280_CTRL_HUMIDITY_REG,
					&v_pre_ctrl_hum_value_u8,
					BME280_GEN_READ_WRITE_DATA_LENGTH);
					/* write previous and updated value of
					control measurement register*/
					com_rslt += bme280_write_register(
    bd84:	2201      	movs	r2, #1
    bd86:	466b      	mov	r3, sp
    bd88:	1dd9      	adds	r1, r3, #7
    bd8a:	20f4      	movs	r0, #244	; 0xf4
    bd8c:	47a0      	blx	r4
    bd8e:	e009      	b.n	bda4 <bme280_set_power_mode+0x98>
					BME280_CTRL_MEAS_REG,
					&v_mode_u8r,
					BME280_GEN_READ_WRITE_DATA_LENGTH);
				} else {
					com_rslt =
					p_bme280->BME280_BUS_WRITE_FUNC(
    bd90:	4b19      	ldr	r3, [pc, #100]	; (bdf8 <bme280_set_power_mode+0xec>)
    bd92:	681b      	ldr	r3, [r3, #0]
    bd94:	2229      	movs	r2, #41	; 0x29
					com_rslt += bme280_write_register(
					BME280_CTRL_MEAS_REG,
					&v_mode_u8r,
					BME280_GEN_READ_WRITE_DATA_LENGTH);
				} else {
					com_rslt =
    bd96:	5c98      	ldrb	r0, [r3, r2]
    bd98:	6b1c      	ldr	r4, [r3, #48]	; 0x30
    bd9a:	2301      	movs	r3, #1
    bd9c:	466a      	mov	r2, sp
    bd9e:	3207      	adds	r2, #7
    bda0:	21f4      	movs	r1, #244	; 0xf4
    bda2:	47a0      	blx	r4
					BME280_CTRL_MEAS_REG_POWER_MODE__REG,
					&v_mode_u8r,
					BME280_GEN_READ_WRITE_DATA_LENGTH);
				}
				/* read the control measurement register value*/
				com_rslt = bme280_read_register(
    bda4:	466b      	mov	r3, sp
    bda6:	1cdc      	adds	r4, r3, #3
    bda8:	2201      	movs	r2, #1
    bdaa:	0021      	movs	r1, r4
    bdac:	20f4      	movs	r0, #244	; 0xf4
    bdae:	4f16      	ldr	r7, [pc, #88]	; (be08 <bme280_set_power_mode+0xfc>)
    bdb0:	47b8      	blx	r7
    bdb2:	0005      	movs	r5, r0
					BME280_CTRL_MEAS_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->ctrl_meas_reg = v_data_u8;
    bdb4:	4e10      	ldr	r6, [pc, #64]	; (bdf8 <bme280_set_power_mode+0xec>)
    bdb6:	7822      	ldrb	r2, [r4, #0]
    bdb8:	232e      	movs	r3, #46	; 0x2e
    bdba:	6831      	ldr	r1, [r6, #0]
    bdbc:	54ca      	strb	r2, [r1, r3]
				/* read the control humidity register value*/
				com_rslt += bme280_read_register(
    bdbe:	2201      	movs	r2, #1
    bdc0:	0021      	movs	r1, r4
    bdc2:	20f2      	movs	r0, #242	; 0xf2
    bdc4:	47b8      	blx	r7
    bdc6:	1945      	adds	r5, r0, r5
    bdc8:	b2ed      	uxtb	r5, r5
					BME280_CTRL_HUMIDITY_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->ctrl_hum_reg = v_data_u8;
    bdca:	7822      	ldrb	r2, [r4, #0]
    bdcc:	232d      	movs	r3, #45	; 0x2d
    bdce:	6831      	ldr	r1, [r6, #0]
    bdd0:	54ca      	strb	r2, [r1, r3]
				/* read the config register value*/
				com_rslt += bme280_read_register(
    bdd2:	2201      	movs	r2, #1
    bdd4:	0021      	movs	r1, r4
    bdd6:	20f5      	movs	r0, #245	; 0xf5
    bdd8:	47b8      	blx	r7
    bdda:	1828      	adds	r0, r5, r0
					BME280_CONFIG_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->config_reg = v_data_u8;
    bddc:	6832      	ldr	r2, [r6, #0]
    bdde:	7821      	ldrb	r1, [r4, #0]
    bde0:	232f      	movs	r3, #47	; 0x2f
    bde2:	54d1      	strb	r1, [r2, r3]
				com_rslt += bme280_read_register(
					BME280_CTRL_HUMIDITY_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->ctrl_hum_reg = v_data_u8;
				/* read the config register value*/
				com_rslt += bme280_read_register(
    bde4:	b240      	sxtb	r0, r0
    bde6:	e004      	b.n	bdf2 <bme280_set_power_mode+0xe6>
	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
	u8 v_data_u8 = BME280_INIT_VALUE;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    bde8:	207f      	movs	r0, #127	; 0x7f
    bdea:	4240      	negs	r0, r0
    bdec:	e001      	b.n	bdf2 <bme280_set_power_mode+0xe6>
				com_rslt += bme280_read_register(
					BME280_CONFIG_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->config_reg = v_data_u8;
			} else {
			com_rslt = E_BME280_OUT_OF_RANGE;
    bdee:	2002      	movs	r0, #2
    bdf0:	4240      	negs	r0, r0
			}
		}
	return com_rslt;
}
    bdf2:	b003      	add	sp, #12
    bdf4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bdf6:	46c0      	nop			; (mov r8, r8)
    bdf8:	20001934 	.word	0x20001934
    bdfc:	0000b925 	.word	0x0000b925
    be00:	0000b961 	.word	0x0000b961
    be04:	0000b991 	.word	0x0000b991
    be08:	0000b9b9 	.word	0x0000b9b9

0000be0c <BME280_I2C_bus_write>:
 *	\param reg_data : It is a value hold in the array,
 *		will be used for write the value into the register
 *	\param cnt : The no of byte of data to be write
 */
BME280_RETURN_FUNCTION_TYPE BME280_I2C_bus_write(uint8_t dev_addr, uint8_t reg_addr, uint8_t *reg_data, uint8_t cnt)
{
    be0c:	b510      	push	{r4, lr}
    be0e:	b084      	sub	sp, #16
	uint8_t buffer[2];
	buffer[0] = reg_addr;
    be10:	ac03      	add	r4, sp, #12
    be12:	7021      	strb	r1, [r4, #0]
	buffer[1] = *reg_data;
    be14:	7812      	ldrb	r2, [r2, #0]
    be16:	7062      	strb	r2, [r4, #1]
	
	enum status_code sensor_wr_status = STATUS_BUSY;
	
	/* Set up internal EEPROM addr write */
	struct i2c_master_packet sensor_wr_packet = {
    be18:	466a      	mov	r2, sp
    be1a:	8010      	strh	r0, [r2, #0]
    be1c:	3301      	adds	r3, #1
    be1e:	8053      	strh	r3, [r2, #2]
    be20:	9401      	str	r4, [sp, #4]
    be22:	2300      	movs	r3, #0
    be24:	7213      	strb	r3, [r2, #8]
    be26:	7253      	strb	r3, [r2, #9]
    be28:	7293      	strb	r3, [r2, #10]
		.ten_bit_address = false,
		.high_speed      = false,
		.hs_master_code  = 0x0,
	};
	
	sensor_wr_status = i2c_master_write_packet_wait(&i2c_master_instance,&sensor_wr_packet);
    be2a:	4669      	mov	r1, sp
    be2c:	4803      	ldr	r0, [pc, #12]	; (be3c <BME280_I2C_bus_write+0x30>)
    be2e:	4b04      	ldr	r3, [pc, #16]	; (be40 <BME280_I2C_bus_write+0x34>)
    be30:	4798      	blx	r3
    be32:	1e43      	subs	r3, r0, #1
    be34:	4198      	sbcs	r0, r3
    be36:	4240      	negs	r0, r0
	if (sensor_wr_status != STATUS_OK){
		return ERROR;
	}
	
	return SUCCESS;
}
    be38:	b004      	add	sp, #16
    be3a:	bd10      	pop	{r4, pc}
    be3c:	20001c04 	.word	0x20001c04
    be40:	0000b279 	.word	0x0000b279

0000be44 <BME280_I2C_bus_read>:
 *	\param reg_addr : Address of the first register, will data is going to be read
 *	\param reg_data : This data read from the sensor, which is hold in an array
 *	\param cnt : The no of data byte of to be read
 */
BME280_RETURN_FUNCTION_TYPE BME280_I2C_bus_read(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)
{
    be44:	b570      	push	{r4, r5, r6, lr}
    be46:	b088      	sub	sp, #32
    be48:	0015      	movs	r5, r2
    be4a:	001e      	movs	r6, r3
    be4c:	466b      	mov	r3, sp
    be4e:	71d9      	strb	r1, [r3, #7]
    be50:	3307      	adds	r3, #7

		enum status_code sensor_wr_status = STATUS_BUSY;
		enum status_code sensor_rd_status = STATUS_BUSY;
		
		/* Set up internal EEPROM addr write */
		struct i2c_master_packet sensor_wr_packet = {
    be52:	b284      	uxth	r4, r0
    be54:	a905      	add	r1, sp, #20
    be56:	800c      	strh	r4, [r1, #0]
    be58:	2201      	movs	r2, #1
    be5a:	804a      	strh	r2, [r1, #2]
    be5c:	604b      	str	r3, [r1, #4]
    be5e:	2300      	movs	r3, #0
    be60:	720b      	strb	r3, [r1, #8]
    be62:	724b      	strb	r3, [r1, #9]
    be64:	728b      	strb	r3, [r1, #10]
			.ten_bit_address = false,
			.high_speed      = false,
			.hs_master_code  = 0x0,
		};
		
		sensor_wr_status = i2c_master_write_packet_wait_no_stop(&i2c_master_instance,
    be66:	480c      	ldr	r0, [pc, #48]	; (be98 <BME280_I2C_bus_read+0x54>)
    be68:	4b0c      	ldr	r3, [pc, #48]	; (be9c <BME280_I2C_bus_read+0x58>)
    be6a:	4798      	blx	r3
								&sensor_wr_packet);
								
		if (sensor_wr_status != STATUS_OK){
    be6c:	2800      	cmp	r0, #0
    be6e:	d10e      	bne.n	be8e <BME280_I2C_bus_read+0x4a>
			return ERROR;
		}
		
		/* Set up internal EEPROM addr write */
		struct i2c_master_packet sensor_rd_packet = {
    be70:	a902      	add	r1, sp, #8
    be72:	800c      	strh	r4, [r1, #0]
    be74:	804e      	strh	r6, [r1, #2]
    be76:	604d      	str	r5, [r1, #4]
    be78:	2300      	movs	r3, #0
    be7a:	720b      	strb	r3, [r1, #8]
    be7c:	724b      	strb	r3, [r1, #9]
    be7e:	728b      	strb	r3, [r1, #10]
			.ten_bit_address = false,
			.high_speed      = false,
			.hs_master_code  = 0x0,
		};
		
		sensor_rd_status = i2c_master_read_packet_wait(&i2c_master_instance,&sensor_rd_packet);
    be80:	4805      	ldr	r0, [pc, #20]	; (be98 <BME280_I2C_bus_read+0x54>)
    be82:	4b07      	ldr	r3, [pc, #28]	; (bea0 <BME280_I2C_bus_read+0x5c>)
    be84:	4798      	blx	r3
		
		if (sensor_rd_status != STATUS_OK){
    be86:	1e43      	subs	r3, r0, #1
    be88:	4198      	sbcs	r0, r3
    be8a:	4240      	negs	r0, r0
    be8c:	e001      	b.n	be92 <BME280_I2C_bus_read+0x4e>
		
		sensor_wr_status = i2c_master_write_packet_wait_no_stop(&i2c_master_instance,
								&sensor_wr_packet);
								
		if (sensor_wr_status != STATUS_OK){
			return ERROR;
    be8e:	2001      	movs	r0, #1
    be90:	4240      	negs	r0, r0
		}
		
		
		return SUCCESS;
	
}
    be92:	b008      	add	sp, #32
    be94:	bd70      	pop	{r4, r5, r6, pc}
    be96:	46c0      	nop			; (mov r8, r8)
    be98:	20001c04 	.word	0x20001c04
    be9c:	0000b299 	.word	0x0000b299
    bea0:	0000b259 	.word	0x0000b259

0000bea4 <BME280_delay_msek>:

/*	Brief : The delay routine
 *	\param : delay in ms
*/
void BME280_delay_msek(u32 msek)
{
    bea4:	b510      	push	{r4, lr}
	/*Here you can write your own delay routine*/
	delay_ms(msek);
    bea6:	4b01      	ldr	r3, [pc, #4]	; (beac <BME280_delay_msek+0x8>)
    bea8:	4798      	blx	r3
}
    beaa:	bd10      	pop	{r4, pc}
    beac:	0000c4f5 	.word	0x0000c4f5

0000beb0 <I2C_routine>:
 *	Bus write function pointer: BME280_WR_FUNC_PTR
 *	Bus read function pointer: BME280_RD_FUNC_PTR
 *	Delay function pointer: delay_msec
 *	I2C address: dev_addr
 *--------------------------------------------------------------------------*/
	bme280_parameters.bus_write  = BME280_I2C_bus_write;
    beb0:	4b05      	ldr	r3, [pc, #20]	; (bec8 <I2C_routine+0x18>)
    beb2:	4a06      	ldr	r2, [pc, #24]	; (becc <I2C_routine+0x1c>)
    beb4:	631a      	str	r2, [r3, #48]	; 0x30
	bme280_parameters.bus_read   = BME280_I2C_bus_read;
    beb6:	4a06      	ldr	r2, [pc, #24]	; (bed0 <I2C_routine+0x20>)
    beb8:	635a      	str	r2, [r3, #52]	; 0x34
	bme280_parameters.dev_addr   = BME280_I2C_ADDRESS2;
    beba:	2177      	movs	r1, #119	; 0x77
    bebc:	2229      	movs	r2, #41	; 0x29
    bebe:	5499      	strb	r1, [r3, r2]
	bme280_parameters.delay_msec = BME280_delay_msek;
    bec0:	4a04      	ldr	r2, [pc, #16]	; (bed4 <I2C_routine+0x24>)
    bec2:	639a      	str	r2, [r3, #56]	; 0x38
}
    bec4:	4770      	bx	lr
    bec6:	46c0      	nop			; (mov r8, r8)
    bec8:	200024b8 	.word	0x200024b8
    becc:	0000be0d 	.word	0x0000be0d
    bed0:	0000be45 	.word	0x0000be45
    bed4:	0000bea5 	.word	0x0000bea5

0000bed8 <wearable_bme280_init>:
/* This function is an example for reading sensor data
 *	\param: None
 *	\return: communication result
 */
BME280_RETURN_FUNCTION_TYPE wearable_bme280_init(void)
{
    bed8:	b510      	push	{r4, lr}

	/* result of communication results*/
	s32 com_rslt = ERROR;
		
	//Initialize I2C functions	
	I2C_routine();
    beda:	4b09      	ldr	r3, [pc, #36]	; (bf00 <wearable_bme280_init+0x28>)
    bedc:	4798      	blx	r3
 *	I2C address
 *	Bus Write
 *	Bus read
 *	Chip id
*-------------------------------------------------------------------------*/
	com_rslt = bme280_init(&bme280_parameters);
    bede:	4809      	ldr	r0, [pc, #36]	; (bf04 <wearable_bme280_init+0x2c>)
    bee0:	4b09      	ldr	r3, [pc, #36]	; (bf08 <wearable_bme280_init+0x30>)
    bee2:	4798      	blx	r3
	/*	For initialization it is required to set the mode of
	 *	the sensor as "NORMAL"
	 *	data acquisition/read/write is possible in this mode
	 *	by using the below API able to set the power mode as NORMAL*/
	/* Set the power mode as NORMAL*/
	com_rslt = bme280_set_power_mode(BME280_FORCED_MODE);
    bee4:	2001      	movs	r0, #1
    bee6:	4b09      	ldr	r3, [pc, #36]	; (bf0c <wearable_bme280_init+0x34>)
    bee8:	4798      	blx	r3
	 * changes to this registers only become effective after a write operation to
	 * "BME280_CTRLMEAS_REG" register.
	 * In the code automated reading and writing of "BME280_CTRLHUM_REG_OSRSH"
	 * register first set the "BME280_CTRLHUM_REG_OSRSH" and then read and write
	 * the "BME280_CTRLMEAS_REG" register in the function*/
	com_rslt = bme280_set_oversamp_humidity(BME280_OVERSAMP_1X);
    beea:	2001      	movs	r0, #1
    beec:	4b08      	ldr	r3, [pc, #32]	; (bf10 <wearable_bme280_init+0x38>)
    beee:	4798      	blx	r3
	/* set the pressure oversampling*/
	com_rslt = bme280_set_oversamp_pressure(BME280_OVERSAMP_1X);
    bef0:	2001      	movs	r0, #1
    bef2:	4b08      	ldr	r3, [pc, #32]	; (bf14 <wearable_bme280_init+0x3c>)
    bef4:	4798      	blx	r3
	/* set the temperature oversampling*/
	com_rslt = bme280_set_oversamp_temperature(BME280_OVERSAMP_1X);
    bef6:	2001      	movs	r0, #1
    bef8:	4b07      	ldr	r3, [pc, #28]	; (bf18 <wearable_bme280_init+0x40>)
    befa:	4798      	blx	r3
// 	/* This API used to read back the written value of standby time*/
// 	com_rslt = bme280_get_standby_durn(&v_stand_by_time_u8);
	
	return com_rslt;

}
    befc:	bd10      	pop	{r4, pc}
    befe:	46c0      	nop			; (mov r8, r8)
    bf00:	0000beb1 	.word	0x0000beb1
    bf04:	200024b8 	.word	0x200024b8
    bf08:	0000b8e5 	.word	0x0000b8e5
    bf0c:	0000bd0d 	.word	0x0000bd0d
    bf10:	0000bbd9 	.word	0x0000bbd9
    bf14:	0000bad9 	.word	0x0000bad9
    bf18:	0000b9e1 	.word	0x0000b9e1

0000bf1c <rtc_overflow_callback>:

/*! \brief RTC timer overflow callback
 *
 */
void rtc_overflow_callback(void)
{
    bf1c:	b510      	push	{r4, lr}
	uint16_t power_led_period = POWER_LED_PERIOD;
	
	/* Do something on RTC overflow here */
	rtc_count_clear_compare_match(&rtc_instance,RTC_COUNT_COMPARE_0);
    bf1e:	2100      	movs	r1, #0
    bf20:	484f      	ldr	r0, [pc, #316]	; (c060 <rtc_overflow_callback+0x144>)
    bf22:	4b50      	ldr	r3, [pc, #320]	; (c064 <rtc_overflow_callback+0x148>)
    bf24:	4798      	blx	r3
	touch_time.time_to_measure_touch = 1u;
    bf26:	2201      	movs	r2, #1
    bf28:	4b4f      	ldr	r3, [pc, #316]	; (c068 <rtc_overflow_callback+0x14c>)
    bf2a:	711a      	strb	r2, [r3, #4]

	if(low_power_mode==0)
    bf2c:	4b4f      	ldr	r3, [pc, #316]	; (c06c <rtc_overflow_callback+0x150>)
    bf2e:	781b      	ldrb	r3, [r3, #0]
    bf30:	2b00      	cmp	r3, #0
    bf32:	d106      	bne.n	bf42 <rtc_overflow_callback+0x26>
	{
		touch_time.current_time_ms = touch_time.current_time_ms +
    bf34:	4a4c      	ldr	r2, [pc, #304]	; (c068 <rtc_overflow_callback+0x14c>)
    bf36:	8851      	ldrh	r1, [r2, #2]
    bf38:	8813      	ldrh	r3, [r2, #0]
    bf3a:	18cb      	adds	r3, r1, r3
    bf3c:	b29b      	uxth	r3, r3
    bf3e:	8053      	strh	r3, [r2, #2]
    bf40:	e00b      	b.n	bf5a <rtc_overflow_callback+0x3e>
		touch_time.measurement_period_ms;
	}else if(low_power_mode==1)
    bf42:	2b01      	cmp	r3, #1
    bf44:	d109      	bne.n	bf5a <rtc_overflow_callback+0x3e>
	{
		touch_time.current_time_ms = touch_time.current_time_ms +
    bf46:	4a48      	ldr	r2, [pc, #288]	; (c068 <rtc_overflow_callback+0x14c>)
    bf48:	8853      	ldrh	r3, [r2, #2]
    bf4a:	4949      	ldr	r1, [pc, #292]	; (c070 <rtc_overflow_callback+0x154>)
    bf4c:	468c      	mov	ip, r1
    bf4e:	4463      	add	r3, ip
    bf50:	b29b      	uxth	r3, r3
    bf52:	8053      	strh	r3, [r2, #2]
		DEF_LOWPOWER_SENSOR_DRIFT_PERIODICITY_MS;
		drift_wakeup=1;
    bf54:	2201      	movs	r2, #1
    bf56:	4b47      	ldr	r3, [pc, #284]	; (c074 <rtc_overflow_callback+0x158>)
    bf58:	701a      	strb	r2, [r3, #0]
	}

	if(started_advertising == true)
    bf5a:	4b47      	ldr	r3, [pc, #284]	; (c078 <rtc_overflow_callback+0x15c>)
    bf5c:	781b      	ldrb	r3, [r3, #0]
    bf5e:	2b00      	cmp	r3, #0
    bf60:	d003      	beq.n	bf6a <rtc_overflow_callback+0x4e>
	{
		/* advertisement timer */
		advertisement_timer++;
    bf62:	4a46      	ldr	r2, [pc, #280]	; (c07c <rtc_overflow_callback+0x160>)
    bf64:	8813      	ldrh	r3, [r2, #0]
    bf66:	3301      	adds	r3, #1
    bf68:	8013      	strh	r3, [r2, #0]
	}
	
	/* 20ms tick */
	rtc_timer++;
    bf6a:	4b45      	ldr	r3, [pc, #276]	; (c080 <rtc_overflow_callback+0x164>)
    bf6c:	681a      	ldr	r2, [r3, #0]
    bf6e:	1c54      	adds	r4, r2, #1
    bf70:	601c      	str	r4, [r3, #0]
	ms_ticks +=20;
    bf72:	4a44      	ldr	r2, [pc, #272]	; (c084 <rtc_overflow_callback+0x168>)
    bf74:	6813      	ldr	r3, [r2, #0]
    bf76:	3314      	adds	r3, #20
    bf78:	6013      	str	r3, [r2, #0]
	
	tick_bhi = 1;
    bf7a:	2201      	movs	r2, #1
    bf7c:	4b42      	ldr	r3, [pc, #264]	; (c088 <rtc_overflow_callback+0x16c>)
    bf7e:	701a      	strb	r2, [r3, #0]
	
	if(rtc_timer % 3000 == 0)
    bf80:	4942      	ldr	r1, [pc, #264]	; (c08c <rtc_overflow_callback+0x170>)
    bf82:	0020      	movs	r0, r4
    bf84:	4b42      	ldr	r3, [pc, #264]	; (c090 <rtc_overflow_callback+0x174>)
    bf86:	4798      	blx	r3
    bf88:	2900      	cmp	r1, #0
    bf8a:	d102      	bne.n	bf92 <rtc_overflow_callback+0x76>
	{
		tick_60second = 1;
    bf8c:	2201      	movs	r2, #1
    bf8e:	4b41      	ldr	r3, [pc, #260]	; (c094 <rtc_overflow_callback+0x178>)
    bf90:	701a      	strb	r2, [r3, #0]
	if(rtc_timer % 500 == 0)
	{
		//tick_10second = 1;
	}	

	if(rtc_timer % env_sensor_period == 0)
    bf92:	4b41      	ldr	r3, [pc, #260]	; (c098 <rtc_overflow_callback+0x17c>)
    bf94:	7819      	ldrb	r1, [r3, #0]
    bf96:	0020      	movs	r0, r4
    bf98:	4b3d      	ldr	r3, [pc, #244]	; (c090 <rtc_overflow_callback+0x174>)
    bf9a:	4798      	blx	r3
    bf9c:	2900      	cmp	r1, #0
    bf9e:	d102      	bne.n	bfa6 <rtc_overflow_callback+0x8a>
	{
		tick_env_sensor = 1;
    bfa0:	2201      	movs	r2, #1
    bfa2:	4b3e      	ldr	r3, [pc, #248]	; (c09c <rtc_overflow_callback+0x180>)
    bfa4:	701a      	strb	r2, [r3, #0]
	}
	if(rtc_timer % motion_sensor_period == 0)
    bfa6:	4b3e      	ldr	r3, [pc, #248]	; (c0a0 <rtc_overflow_callback+0x184>)
    bfa8:	7819      	ldrb	r1, [r3, #0]
    bfaa:	0020      	movs	r0, r4
    bfac:	4b38      	ldr	r3, [pc, #224]	; (c090 <rtc_overflow_callback+0x174>)
    bfae:	4798      	blx	r3
    bfb0:	2900      	cmp	r1, #0
    bfb2:	d102      	bne.n	bfba <rtc_overflow_callback+0x9e>
	{
		tick_motion_sensor = 1;
    bfb4:	2201      	movs	r2, #1
    bfb6:	4b3b      	ldr	r3, [pc, #236]	; (c0a4 <rtc_overflow_callback+0x188>)
    bfb8:	701a      	strb	r2, [r3, #0]
	}
	
	if(rtc_timer % ble_event_task_period == 0)
    bfba:	4b3b      	ldr	r3, [pc, #236]	; (c0a8 <rtc_overflow_callback+0x18c>)
    bfbc:	7819      	ldrb	r1, [r3, #0]
    bfbe:	0020      	movs	r0, r4
    bfc0:	4b33      	ldr	r3, [pc, #204]	; (c090 <rtc_overflow_callback+0x174>)
    bfc2:	4798      	blx	r3
    bfc4:	2900      	cmp	r1, #0
    bfc6:	d102      	bne.n	bfce <rtc_overflow_callback+0xb2>
	{
		tick_ble_event_task = 1;
    bfc8:	2201      	movs	r2, #1
    bfca:	4b38      	ldr	r3, [pc, #224]	; (c0ac <rtc_overflow_callback+0x190>)
    bfcc:	701a      	strb	r2, [r3, #0]
	}
	if(rtc_timer % 250 == 0)
    bfce:	21fa      	movs	r1, #250	; 0xfa
    bfd0:	0020      	movs	r0, r4
    bfd2:	4b2f      	ldr	r3, [pc, #188]	; (c090 <rtc_overflow_callback+0x174>)
    bfd4:	4798      	blx	r3
    bfd6:	2900      	cmp	r1, #0
    bfd8:	d102      	bne.n	bfe0 <rtc_overflow_callback+0xc4>
	{
		tick_5second = 1;
    bfda:	2201      	movs	r2, #1
    bfdc:	4b34      	ldr	r3, [pc, #208]	; (c0b0 <rtc_overflow_callback+0x194>)
    bfde:	701a      	strb	r2, [r3, #0]
	}
	if(rtc_timer % 100 == 0)
    bfe0:	2164      	movs	r1, #100	; 0x64
    bfe2:	0020      	movs	r0, r4
    bfe4:	4b2a      	ldr	r3, [pc, #168]	; (c090 <rtc_overflow_callback+0x174>)
    bfe6:	4798      	blx	r3
    bfe8:	2900      	cmp	r1, #0
    bfea:	d102      	bne.n	bff2 <rtc_overflow_callback+0xd6>
	{
		tick_2second = 1;
    bfec:	2201      	movs	r2, #1
    bfee:	4b31      	ldr	r3, [pc, #196]	; (c0b4 <rtc_overflow_callback+0x198>)
    bff0:	701a      	strb	r2, [r3, #0]
	}
	if(rtc_timer % 50 == 0)
    bff2:	2132      	movs	r1, #50	; 0x32
    bff4:	0020      	movs	r0, r4
    bff6:	4b26      	ldr	r3, [pc, #152]	; (c090 <rtc_overflow_callback+0x174>)
    bff8:	4798      	blx	r3
    bffa:	2900      	cmp	r1, #0
    bffc:	d109      	bne.n	c012 <rtc_overflow_callback+0xf6>
	{
		tick_1second = 1;
    bffe:	2201      	movs	r2, #1
    c000:	4b2d      	ldr	r3, [pc, #180]	; (c0b8 <rtc_overflow_callback+0x19c>)
    c002:	701a      	strb	r2, [r3, #0]
		if (rotation_data_timer)
    c004:	4b2d      	ldr	r3, [pc, #180]	; (c0bc <rtc_overflow_callback+0x1a0>)
    c006:	781b      	ldrb	r3, [r3, #0]
    c008:	2b00      	cmp	r3, #0
    c00a:	d002      	beq.n	c012 <rtc_overflow_callback+0xf6>
			rotation_data_timer--;
    c00c:	3b01      	subs	r3, #1
    c00e:	4a2b      	ldr	r2, [pc, #172]	; (c0bc <rtc_overflow_callback+0x1a0>)
    c010:	7013      	strb	r3, [r2, #0]
	}
	if(rtc_timer % 25 == 0)
    c012:	2119      	movs	r1, #25
    c014:	0020      	movs	r0, r4
    c016:	4b1e      	ldr	r3, [pc, #120]	; (c090 <rtc_overflow_callback+0x174>)
    c018:	4798      	blx	r3
    c01a:	2900      	cmp	r1, #0
    c01c:	d10a      	bne.n	c034 <rtc_overflow_callback+0x118>
	{
		if (gu8LedMode == LED_MODE_BLINK_NORMAL)
    c01e:	4b28      	ldr	r3, [pc, #160]	; (c0c0 <rtc_overflow_callback+0x1a4>)
    c020:	781b      	ldrb	r3, [r3, #0]
    c022:	2b03      	cmp	r3, #3
    c024:	d101      	bne.n	c02a <rtc_overflow_callback+0x10e>
			toggleLED();
    c026:	4b27      	ldr	r3, [pc, #156]	; (c0c4 <rtc_overflow_callback+0x1a8>)
    c028:	4798      	blx	r3
		tick_rotation_data = 1;
    c02a:	2301      	movs	r3, #1
    c02c:	4a26      	ldr	r2, [pc, #152]	; (c0c8 <rtc_overflow_callback+0x1ac>)
    c02e:	7013      	strb	r3, [r2, #0]
		tick_500ms = 1;
    c030:	4a26      	ldr	r2, [pc, #152]	; (c0cc <rtc_overflow_callback+0x1b0>)
    c032:	7013      	strb	r3, [r2, #0]
	}
	if(rtc_timer % 5 == 0)
    c034:	4b12      	ldr	r3, [pc, #72]	; (c080 <rtc_overflow_callback+0x164>)
    c036:	6818      	ldr	r0, [r3, #0]
    c038:	2105      	movs	r1, #5
    c03a:	4b15      	ldr	r3, [pc, #84]	; (c090 <rtc_overflow_callback+0x174>)
    c03c:	4798      	blx	r3
    c03e:	2900      	cmp	r1, #0
    c040:	d108      	bne.n	c054 <rtc_overflow_callback+0x138>
	{
		if (gu8LedMode == LED_MODE_BLINK_FAST)
    c042:	4b1f      	ldr	r3, [pc, #124]	; (c0c0 <rtc_overflow_callback+0x1a4>)
    c044:	781b      	ldrb	r3, [r3, #0]
    c046:	2b04      	cmp	r3, #4
    c048:	d101      	bne.n	c04e <rtc_overflow_callback+0x132>
			toggleLED();
    c04a:	4b1e      	ldr	r3, [pc, #120]	; (c0c4 <rtc_overflow_callback+0x1a8>)
    c04c:	4798      	blx	r3
		tick_100ms = 1;
    c04e:	2201      	movs	r2, #1
    c050:	4b1f      	ldr	r3, [pc, #124]	; (c0d0 <rtc_overflow_callback+0x1b4>)
    c052:	701a      	strb	r2, [r3, #0]
	}
	
	
	/* power LED handling */
	power_led_timer++;
    c054:	4a1f      	ldr	r2, [pc, #124]	; (c0d4 <rtc_overflow_callback+0x1b8>)
    c056:	8813      	ldrh	r3, [r2, #0]
    c058:	3301      	adds	r3, #1
    c05a:	8013      	strh	r3, [r2, #0]
	{
		power_led_period = POWER_LED_LOW_BATTERY_PERIOD; 	
	}
	
	
}
    c05c:	bd10      	pop	{r4, pc}
    c05e:	46c0      	nop			; (mov r8, r8)
    c060:	20002500 	.word	0x20002500
    c064:	0000c345 	.word	0x0000c345
    c068:	200024f4 	.word	0x200024f4
    c06c:	200028ca 	.word	0x200028ca
    c070:	00002710 	.word	0x00002710
    c074:	20001938 	.word	0x20001938
    c078:	200025f5 	.word	0x200025f5
    c07c:	2000277c 	.word	0x2000277c
    c080:	2000253c 	.word	0x2000253c
    c084:	2000193c 	.word	0x2000193c
    c088:	20002540 	.word	0x20002540
    c08c:	00000bb8 	.word	0x00000bb8
    c090:	0000f939 	.word	0x0000f939
    c094:	200024fc 	.word	0x200024fc
    c098:	2000012c 	.word	0x2000012c
    c09c:	20002547 	.word	0x20002547
    c0a0:	2000012d 	.word	0x2000012d
    c0a4:	2000254b 	.word	0x2000254b
    c0a8:	2000012e 	.word	0x2000012e
    c0ac:	2000254a 	.word	0x2000254a
    c0b0:	2000253a 	.word	0x2000253a
    c0b4:	20002549 	.word	0x20002549
    c0b8:	20002543 	.word	0x20002543
    c0bc:	20002545 	.word	0x20002545
    c0c0:	20001c45 	.word	0x20001c45
    c0c4:	000029e1 	.word	0x000029e1
    c0c8:	20002542 	.word	0x20002542
    c0cc:	20002546 	.word	0x20002546
    c0d0:	20002541 	.word	0x20002541
    c0d4:	20002538 	.word	0x20002538

0000c0d8 <configure_rtc_callbacks>:

/*! \brief Configure the RTC timer callback
 *
 */
void configure_rtc_callbacks(void)
{
    c0d8:	b510      	push	{r4, lr}
	/* register callback */
	rtc_count_register_callback(&rtc_instance,
    c0da:	4c05      	ldr	r4, [pc, #20]	; (c0f0 <configure_rtc_callbacks+0x18>)
    c0dc:	2208      	movs	r2, #8
    c0de:	4905      	ldr	r1, [pc, #20]	; (c0f4 <configure_rtc_callbacks+0x1c>)
    c0e0:	0020      	movs	r0, r4
    c0e2:	4b05      	ldr	r3, [pc, #20]	; (c0f8 <configure_rtc_callbacks+0x20>)
    c0e4:	4798      	blx	r3
			rtc_overflow_callback, RTC_COUNT_CALLBACK_COMPARE_0);
	/* Enable callback */
	rtc_count_enable_callback(&rtc_instance, RTC_COUNT_CALLBACK_COMPARE_0);
    c0e6:	2108      	movs	r1, #8
    c0e8:	0020      	movs	r0, r4
    c0ea:	4b04      	ldr	r3, [pc, #16]	; (c0fc <configure_rtc_callbacks+0x24>)
    c0ec:	4798      	blx	r3
}
    c0ee:	bd10      	pop	{r4, pc}
    c0f0:	20002500 	.word	0x20002500
    c0f4:	0000bf1d 	.word	0x0000bf1d
    c0f8:	0000c379 	.word	0x0000c379
    c0fc:	0000c3b5 	.word	0x0000c3b5

0000c100 <configure_rtc_count>:

/*! \brief Configure the RTC timer count after which interrupts comes
 *
 */
void configure_rtc_count(void)
{
    c100:	b530      	push	{r4, r5, lr}
    c102:	b089      	sub	sp, #36	; 0x24
	volatile uint16_t temp;
	
	struct rtc_count_events config_rtc_event
    c104:	ac04      	add	r4, sp, #16
    c106:	220b      	movs	r2, #11
    c108:	2100      	movs	r1, #0
    c10a:	0020      	movs	r0, r4
    c10c:	4b1c      	ldr	r3, [pc, #112]	; (c180 <configure_rtc_count+0x80>)
    c10e:	4798      	blx	r3
    c110:	2301      	movs	r3, #1
    c112:	7263      	strb	r3, [r4, #9]
	/* Sanity check argument */
	Assert(config);

	/* Set default into configuration structure */
	config->prescaler           = RTC_COUNT_PRESCALER_DIV_1024;
	config->mode                = RTC_COUNT_MODE_32BIT;
    c114:	466a      	mov	r2, sp
    c116:	7093      	strb	r3, [r2, #2]
	config->clear_on_match      = false;

#ifdef FEATURE_RTC_CONTINUOUSLY_UPDATED
	config->continuously_update = false;
    c118:	2200      	movs	r2, #0
    c11a:	4669      	mov	r1, sp
    c11c:	710a      	strb	r2, [r1, #4]
#if (SAML22)
	config->enable_read_sync    = true;
#endif

	for (uint8_t i = 0; i < RTC_NUM_OF_COMP16; i++) {
		config->compare_values[i] = 0;
    c11e:	9202      	str	r2, [sp, #8]
    c120:	9203      	str	r2, [sp, #12]
		 = { .generate_event_on_periodic[DEF_LOWPOWER_SENSOR_EVENT_PERIODICITY_OFFSET] = true };
	struct rtc_count_config config_rtc_count;
	rtc_count_get_config_defaults(&config_rtc_count);

	config_rtc_count.prescaler           = RTC_MODE0_CTRLA_PRESCALER_DIV1;
    c122:	3201      	adds	r2, #1
    c124:	32ff      	adds	r2, #255	; 0xff
    c126:	800a      	strh	r2, [r1, #0]
	config_rtc_count.mode                = RTC_COUNT_MODE_32BIT;
	config_rtc_count.clear_on_match =true;
    c128:	466a      	mov	r2, sp
    c12a:	70cb      	strb	r3, [r1, #3]

	/* initialize rtc */
	rtc_count_init(&rtc_instance, RTC, &config_rtc_count);
    c12c:	4c15      	ldr	r4, [pc, #84]	; (c184 <configure_rtc_count+0x84>)
    c12e:	4916      	ldr	r1, [pc, #88]	; (c188 <configure_rtc_count+0x88>)
    c130:	0020      	movs	r0, r4
    c132:	4b16      	ldr	r3, [pc, #88]	; (c18c <configure_rtc_count+0x8c>)
    c134:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    c136:	6825      	ldr	r5, [r4, #0]
    c138:	2300      	movs	r3, #0
    c13a:	2100      	movs	r1, #0
	}

	/* Check if the user has requested any periodic events */
	for (uint8_t i = 0; i < 8; i++) {
		if (events->generate_event_on_periodic[i]) {
			event_mask |= RTC_MODE0_EVCTRL_PEREO(1 << i);
    c13c:	2401      	movs	r4, #1
    c13e:	20ff      	movs	r0, #255	; 0xff
		}
	}

	/* Check if the user has requested any periodic events */
	for (uint8_t i = 0; i < 8; i++) {
		if (events->generate_event_on_periodic[i]) {
    c140:	aa04      	add	r2, sp, #16
    c142:	18d2      	adds	r2, r2, r3
    c144:	78d2      	ldrb	r2, [r2, #3]
    c146:	2a00      	cmp	r2, #0
    c148:	d003      	beq.n	c152 <configure_rtc_count+0x52>
			event_mask |= RTC_MODE0_EVCTRL_PEREO(1 << i);
    c14a:	0022      	movs	r2, r4
    c14c:	409a      	lsls	r2, r3
    c14e:	4002      	ands	r2, r0
    c150:	4311      	orrs	r1, r2
    c152:	3301      	adds	r3, #1
			event_mask |= RTC_MODE0_EVCTRL_CMPEO(1 << i);
		}
	}

	/* Check if the user has requested any periodic events */
	for (uint8_t i = 0; i < 8; i++) {
    c154:	2b08      	cmp	r3, #8
    c156:	d1f3      	bne.n	c140 <configure_rtc_count+0x40>
		event_mask |= RTC_MODE0_EVCTRL_TAMPEVEI;
	}
#endif

	/* Enable given event(s). */
	rtc_module->MODE0.EVCTRL.reg |= event_mask;
    c158:	686b      	ldr	r3, [r5, #4]
    c15a:	4319      	orrs	r1, r3
    c15c:	6069      	str	r1, [r5, #4]
	/* Enable RTC events */
	config_rtc_event.generate_event_on_periodic[DEF_LOWPOWER_SENSOR_EVENT_PERIODICITY_OFFSET] = true;
	
	rtc_count_enable_events(&rtc_instance, &config_rtc_event);

	temp = TIME_PERIOD_1MSEC * DEF_TOUCH_MEASUREMENT_PERIOD_MS;
    c15e:	231e      	movs	r3, #30
    c160:	446b      	add	r3, sp
    c162:	2214      	movs	r2, #20
    c164:	801a      	strh	r2, [r3, #0]

	rtc_count_set_compare(&rtc_instance,temp,RTC_COUNT_COMPARE_0);
    c166:	8819      	ldrh	r1, [r3, #0]
    c168:	b289      	uxth	r1, r1
    c16a:	4c06      	ldr	r4, [pc, #24]	; (c184 <configure_rtc_count+0x84>)
    c16c:	2200      	movs	r2, #0
    c16e:	0020      	movs	r0, r4
    c170:	4b07      	ldr	r3, [pc, #28]	; (c190 <configure_rtc_count+0x90>)
    c172:	4798      	blx	r3

	/* enable rtc */
	rtc_count_enable(&rtc_instance);
    c174:	0020      	movs	r0, r4
    c176:	4b07      	ldr	r3, [pc, #28]	; (c194 <configure_rtc_count+0x94>)
    c178:	4798      	blx	r3

}
    c17a:	b009      	add	sp, #36	; 0x24
    c17c:	bd30      	pop	{r4, r5, pc}
    c17e:	46c0      	nop			; (mov r8, r8)
    c180:	00011845 	.word	0x00011845
    c184:	20002500 	.word	0x20002500
    c188:	40002000 	.word	0x40002000
    c18c:	0000c2ad 	.word	0x0000c2ad
    c190:	0000c249 	.word	0x0000c249
    c194:	0000c215 	.word	0x0000c215

0000c198 <rtc_init>:

/*! \brief Initialize RTC timer
 *
 */
void rtc_init(void)
{
    c198:	b510      	push	{r4, lr}
	/* Configure and enable RTC */
	configure_rtc_count();
    c19a:	4b02      	ldr	r3, [pc, #8]	; (c1a4 <rtc_init+0xc>)
    c19c:	4798      	blx	r3

	/* Configure and enable callback */
	configure_rtc_callbacks();
    c19e:	4b02      	ldr	r3, [pc, #8]	; (c1a8 <rtc_init+0x10>)
    c1a0:	4798      	blx	r3
}
    c1a2:	bd10      	pop	{r4, pc}
    c1a4:	0000c101 	.word	0x0000c101
    c1a8:	0000c0d9 	.word	0x0000c0d9

0000c1ac <EVSYS_Handler>:

	return STATUS_OK;
}

void EVSYS_Handler(void)
{
    c1ac:	b510      	push	{r4, lr}
	struct events_hook *current_hook = _events_inst.hook_list;
    c1ae:	4b0c      	ldr	r3, [pc, #48]	; (c1e0 <EVSYS_Handler+0x34>)
    c1b0:	691c      	ldr	r4, [r3, #16]
	uint32_t flag;

	/* Synch the interrupt flag buffer with the hardware register */
	flag = EVSYS->INTFLAG.reg;
    c1b2:	2186      	movs	r1, #134	; 0x86
    c1b4:	05c9      	lsls	r1, r1, #23
    c1b6:	6988      	ldr	r0, [r1, #24]
	_events_inst.interrupt_flag_buffer |= flag;
    c1b8:	689a      	ldr	r2, [r3, #8]
    c1ba:	4302      	orrs	r2, r0
    c1bc:	609a      	str	r2, [r3, #8]
	/* Clear all hardware interrupt flags */
	EVSYS->INTFLAG.reg = _EVENTS_INTFLAGS_MASK;
    c1be:	4b09      	ldr	r3, [pc, #36]	; (c1e4 <EVSYS_Handler+0x38>)
    c1c0:	618b      	str	r3, [r1, #24]

	/* Traverse the linked list */
	while (current_hook != NULL) {
    c1c2:	2c00      	cmp	r4, #0
    c1c4:	d005      	beq.n	c1d2 <EVSYS_Handler+0x26>
		current_hook->hook_func(current_hook->resource);
    c1c6:	6820      	ldr	r0, [r4, #0]
    c1c8:	6863      	ldr	r3, [r4, #4]
    c1ca:	4798      	blx	r3
		current_hook = current_hook->next;
    c1cc:	68a4      	ldr	r4, [r4, #8]
	_events_inst.interrupt_flag_buffer |= flag;
	/* Clear all hardware interrupt flags */
	EVSYS->INTFLAG.reg = _EVENTS_INTFLAGS_MASK;

	/* Traverse the linked list */
	while (current_hook != NULL) {
    c1ce:	2c00      	cmp	r4, #0
    c1d0:	d1f9      	bne.n	c1c6 <EVSYS_Handler+0x1a>
		current_hook->hook_func(current_hook->resource);
		current_hook = current_hook->next;
	}

	/* Clear acknowledged interrupt sources from the interrupt flag buffer */
	flag = _events_inst.interrupt_flag_ack_buffer;
    c1d2:	4b03      	ldr	r3, [pc, #12]	; (c1e0 <EVSYS_Handler+0x34>)
    c1d4:	68d9      	ldr	r1, [r3, #12]
	_events_inst.interrupt_flag_buffer &= ~flag;
    c1d6:	689a      	ldr	r2, [r3, #8]
    c1d8:	438a      	bics	r2, r1
    c1da:	609a      	str	r2, [r3, #8]
}
    c1dc:	bd10      	pop	{r4, pc}
    c1de:	46c0      	nop			; (mov r8, r8)
    c1e0:	20000118 	.word	0x20000118
    c1e4:	0fff0fff 	.word	0x0fff0fff

0000c1e8 <_system_events_init>:
    c1e8:	4906      	ldr	r1, [pc, #24]	; (c204 <_system_events_init+0x1c>)
    c1ea:	6a0b      	ldr	r3, [r1, #32]
    c1ec:	2201      	movs	r2, #1
    c1ee:	4313      	orrs	r3, r2
    c1f0:	620b      	str	r3, [r1, #32]
	/* Enable EVSYS register interface */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, MCLK_APBDMASK_EVSYS);
#endif

	/* Make sure the EVSYS module is properly reset */
	EVSYS->CTRLA.reg = EVSYS_CTRLA_SWRST;
    c1f2:	2386      	movs	r3, #134	; 0x86
    c1f4:	05db      	lsls	r3, r3, #23
    c1f6:	701a      	strb	r2, [r3, #0]

	while (EVSYS->CTRLA.reg & EVSYS_CTRLA_SWRST) {
    c1f8:	0019      	movs	r1, r3
    c1fa:	780b      	ldrb	r3, [r1, #0]
    c1fc:	4213      	tst	r3, r2
    c1fe:	d1fc      	bne.n	c1fa <_system_events_init+0x12>
	}
}
    c200:	4770      	bx	lr
    c202:	46c0      	nop			; (mov r8, r8)
    c204:	40000400 	.word	0x40000400

0000c208 <rtc_count_is_syncing>:
{
 	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    c208:	6803      	ldr	r3, [r0, #0]

	if (rtc_module->MODE0.SYNCBUSY.reg) {
    c20a:	6918      	ldr	r0, [r3, #16]
    c20c:	1e43      	subs	r3, r0, #1
    c20e:	4198      	sbcs	r0, r3
    c210:	b2c0      	uxtb	r0, r0
		return true;
	}

	return false;
}
    c212:	4770      	bx	lr

0000c214 <rtc_count_enable>:
 * module configuration parameters cannot be altered while the module is enabled.
 *
 * \param[in,out]  module  RTC hardware module
 */
void rtc_count_enable(struct rtc_module *const module)
{
    c214:	b570      	push	{r4, r5, r6, lr}
    c216:	0004      	movs	r4, r0
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    c218:	6806      	ldr	r6, [r0, #0]
    c21a:	2204      	movs	r2, #4
    c21c:	4b08      	ldr	r3, [pc, #32]	; (c240 <rtc_count_enable+0x2c>)
    c21e:	601a      	str	r2, [r3, #0]

#if RTC_COUNT_ASYNC == true
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_RTC);
#endif

	while (rtc_count_is_syncing(module)) {
    c220:	4d08      	ldr	r5, [pc, #32]	; (c244 <rtc_count_enable+0x30>)
    c222:	0020      	movs	r0, r4
    c224:	47a8      	blx	r5
    c226:	2800      	cmp	r0, #0
    c228:	d1fb      	bne.n	c222 <rtc_count_enable+0xe>
		/* Wait for synchronization */
	}

	/* Enable RTC module. */
	rtc_module->MODE0.CTRLA.reg |= RTC_MODE0_CTRLA_ENABLE;
    c22a:	8832      	ldrh	r2, [r6, #0]
    c22c:	2302      	movs	r3, #2
    c22e:	4313      	orrs	r3, r2
    c230:	8033      	strh	r3, [r6, #0]

	while (rtc_count_is_syncing(module)) {
    c232:	4d04      	ldr	r5, [pc, #16]	; (c244 <rtc_count_enable+0x30>)
    c234:	0020      	movs	r0, r4
    c236:	47a8      	blx	r5
    c238:	2800      	cmp	r0, #0
    c23a:	d1fb      	bne.n	c234 <rtc_count_enable+0x20>
		/* Wait for synchronization */
	}
}
    c23c:	bd70      	pop	{r4, r5, r6, pc}
    c23e:	46c0      	nop			; (mov r8, r8)
    c240:	e000e100 	.word	0xe000e100
    c244:	0000c209 	.word	0x0000c209

0000c248 <rtc_count_set_compare>:
 */
enum status_code rtc_count_set_compare(
		struct rtc_module *const module,
		const uint32_t comp_value,
		const enum rtc_count_compare comp_index)
{
    c248:	b5f0      	push	{r4, r5, r6, r7, lr}
    c24a:	b083      	sub	sp, #12
    c24c:	0004      	movs	r4, r0
    c24e:	9101      	str	r1, [sp, #4]
    c250:	0015      	movs	r5, r2
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    c252:	6806      	ldr	r6, [r0, #0]

	while (rtc_count_is_syncing(module)) {
    c254:	4f13      	ldr	r7, [pc, #76]	; (c2a4 <rtc_count_set_compare+0x5c>)
    c256:	0020      	movs	r0, r4
    c258:	47b8      	blx	r7
    c25a:	2800      	cmp	r0, #0
    c25c:	d1fb      	bne.n	c256 <rtc_count_set_compare+0xe>
		/* Wait for synchronization */
	}

	/* Set compare values based on operation mode. */
	switch (module->mode) {
    c25e:	7923      	ldrb	r3, [r4, #4]
    c260:	2b00      	cmp	r3, #0
    c262:	d009      	beq.n	c278 <rtc_count_set_compare+0x30>
    c264:	2b01      	cmp	r3, #1
    c266:	d119      	bne.n	c29c <rtc_count_set_compare+0x54>
		case RTC_COUNT_MODE_32BIT:
			/* Check sanity of comp_index. */
			if ((uint32_t)comp_index > RTC_COMP32_NUM) {
				return STATUS_ERR_INVALID_ARG;
    c268:	3017      	adds	r0, #23

	/* Set compare values based on operation mode. */
	switch (module->mode) {
		case RTC_COUNT_MODE_32BIT:
			/* Check sanity of comp_index. */
			if ((uint32_t)comp_index > RTC_COMP32_NUM) {
    c26a:	2d01      	cmp	r5, #1
    c26c:	d817      	bhi.n	c29e <rtc_count_set_compare+0x56>
				return STATUS_ERR_INVALID_ARG;
			}

			/* Set compare value for COMP. */
			rtc_module->MODE0.COMP[comp_index].reg = comp_value;
    c26e:	3508      	adds	r5, #8
    c270:	00ad      	lsls	r5, r5, #2
    c272:	9b01      	ldr	r3, [sp, #4]
    c274:	51ab      	str	r3, [r5, r6]

			break;
    c276:	e00b      	b.n	c290 <rtc_count_set_compare+0x48>

		case RTC_COUNT_MODE_16BIT:
			/* Check sanity of comp_index. */
			if ((uint32_t)comp_index > RTC_NUM_OF_COMP16) {
				return STATUS_ERR_INVALID_ARG;
    c278:	2017      	movs	r0, #23

			break;

		case RTC_COUNT_MODE_16BIT:
			/* Check sanity of comp_index. */
			if ((uint32_t)comp_index > RTC_NUM_OF_COMP16) {
    c27a:	2d02      	cmp	r5, #2
    c27c:	d80f      	bhi.n	c29e <rtc_count_set_compare+0x56>
				return STATUS_ERR_INVALID_ARG;
			}

			/* Check that 16-bit value is provided. */
			if (comp_value > 0xffff) {
    c27e:	4b0a      	ldr	r3, [pc, #40]	; (c2a8 <rtc_count_set_compare+0x60>)
    c280:	9a01      	ldr	r2, [sp, #4]
    c282:	429a      	cmp	r2, r3
    c284:	d80b      	bhi.n	c29e <rtc_count_set_compare+0x56>
				Assert(false);
				return STATUS_ERR_INVALID_ARG;
			}

			/* Set compare value for COMP. */
			rtc_module->MODE1.COMP[comp_index].reg = comp_value & 0xffff;
    c286:	466b      	mov	r3, sp
    c288:	889b      	ldrh	r3, [r3, #4]
    c28a:	3510      	adds	r5, #16
    c28c:	006d      	lsls	r5, r5, #1
    c28e:	53ab      	strh	r3, [r5, r6]
		default:
			Assert(false);
			return STATUS_ERR_BAD_FORMAT;
	}

	while (rtc_count_is_syncing(module)) {
    c290:	4d04      	ldr	r5, [pc, #16]	; (c2a4 <rtc_count_set_compare+0x5c>)
    c292:	0020      	movs	r0, r4
    c294:	47a8      	blx	r5
    c296:	2800      	cmp	r0, #0
    c298:	d1fb      	bne.n	c292 <rtc_count_set_compare+0x4a>
    c29a:	e000      	b.n	c29e <rtc_count_set_compare+0x56>

			break;

		default:
			Assert(false);
			return STATUS_ERR_BAD_FORMAT;
    c29c:	201a      	movs	r0, #26
		/* Wait for synchronization */
	}

	/* Return status if everything is OK. */
	return STATUS_OK;
}
    c29e:	b003      	add	sp, #12
    c2a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c2a2:	46c0      	nop			; (mov r8, r8)
    c2a4:	0000c209 	.word	0x0000c209
    c2a8:	0000ffff 	.word	0x0000ffff

0000c2ac <rtc_count_init>:
 */
enum status_code rtc_count_init(
		struct rtc_module *const module,
		Rtc *const hw,
		const struct rtc_count_config *const config)
{
    c2ac:	b570      	push	{r4, r5, r6, lr}
    c2ae:	0005      	movs	r5, r0
    c2b0:	0014      	movs	r4, r2
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize device instance */
	module->hw = hw;
    c2b2:	6001      	str	r1, [r0, #0]
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			MCLK->APBAMASK.reg |= mask;
    c2b4:	4a1f      	ldr	r2, [pc, #124]	; (c334 <rtc_count_init+0x88>)
    c2b6:	6953      	ldr	r3, [r2, #20]
    c2b8:	2180      	movs	r1, #128	; 0x80
    c2ba:	0049      	lsls	r1, r1, #1
    c2bc:	430b      	orrs	r3, r1
    c2be:	6153      	str	r3, [r2, #20]

	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, MCLK_APBAMASK_RTC);

	/* Select RTC clock */
	OSC32KCTRL->RTCCTRL.reg = RTC_CLOCK_SOURCE;
    c2c0:	2200      	movs	r2, #0
    c2c2:	4b1d      	ldr	r3, [pc, #116]	; (c338 <rtc_count_init+0x8c>)
    c2c4:	611a      	str	r2, [r3, #16]
     */ 
	/* Reset module to hardware defaults. */
    /* rtc_count_reset(module); */

	/* Save conf_struct internally for continued use. */
	module->mode                = config->mode;
    c2c6:	78a3      	ldrb	r3, [r4, #2]
    c2c8:	7103      	strb	r3, [r0, #4]

#  if (RTC_INST_NUM == 1)
	_rtc_instance[0] = module;
    c2ca:	4b1c      	ldr	r3, [pc, #112]	; (c33c <rtc_count_init+0x90>)
    c2cc:	6018      	str	r0, [r3, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    c2ce:	6801      	ldr	r1, [r0, #0]

#if SAML21
	rtc_module->MODE0.CTRLA.reg = RTC_MODE0_CTRLA_MODE(0)
    c2d0:	7963      	ldrb	r3, [r4, #5]
    c2d2:	03db      	lsls	r3, r3, #15
    c2d4:	8822      	ldrh	r2, [r4, #0]
    c2d6:	4313      	orrs	r3, r2
    c2d8:	b29b      	uxth	r3, r3
    c2da:	800b      	strh	r3, [r1, #0]
	rtc_module->MODE0.CTRLA.reg = RTC_MODE0_CTRLA_MODE(0) | config->prescaler
			| (config->enable_read_sync << RTC_MODE0_CTRLA_COUNTSYNC_Pos);
#endif

	/* Set mode and clear on match if applicable. */
	switch (config->mode) {
    c2dc:	78a3      	ldrb	r3, [r4, #2]
    c2de:	2b00      	cmp	r3, #0
    c2e0:	d013      	beq.n	c30a <rtc_count_init+0x5e>
						(enum rtc_count_compare)i);
			}
			break;
		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    c2e2:	2017      	movs	r0, #23
	rtc_module->MODE0.CTRLA.reg = RTC_MODE0_CTRLA_MODE(0) | config->prescaler
			| (config->enable_read_sync << RTC_MODE0_CTRLA_COUNTSYNC_Pos);
#endif

	/* Set mode and clear on match if applicable. */
	switch (config->mode) {
    c2e4:	2b01      	cmp	r3, #1
    c2e6:	d123      	bne.n	c330 <rtc_count_init+0x84>
		case RTC_COUNT_MODE_32BIT:
			/* Set 32-bit mode and clear on match if applicable. */
			rtc_module->MODE0.CTRLA.reg |= RTC_MODE0_CTRLA_MODE(0);
    c2e8:	880b      	ldrh	r3, [r1, #0]
    c2ea:	b29b      	uxth	r3, r3
    c2ec:	800b      	strh	r3, [r1, #0]

			/* Check if clear on compare match should be set. */
			if (config->clear_on_match) {
    c2ee:	78e3      	ldrb	r3, [r4, #3]
    c2f0:	2b00      	cmp	r3, #0
    c2f2:	d003      	beq.n	c2fc <rtc_count_init+0x50>
				/* Set clear on match. */
				rtc_module->MODE0.CTRLA.reg |= RTC_MODE0_CTRLA_MATCHCLR;
    c2f4:	880a      	ldrh	r2, [r1, #0]
    c2f6:	2380      	movs	r3, #128	; 0x80
    c2f8:	4313      	orrs	r3, r2
    c2fa:	800b      	strh	r3, [r1, #0]
			}
			/* Set compare values. */
			for (uint8_t i = 0; i < RTC_COMP32_NUM; i++) {
				rtc_count_set_compare(module, config->compare_values[i],
    c2fc:	68a1      	ldr	r1, [r4, #8]
    c2fe:	2200      	movs	r2, #0
    c300:	0028      	movs	r0, r5
    c302:	4b0f      	ldr	r3, [pc, #60]	; (c340 <rtc_count_init+0x94>)
    c304:	4798      	blx	r3
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
	}

	/* Return status OK if everything was configured. */
	return STATUS_OK;
    c306:	2000      	movs	r0, #0
    c308:	e012      	b.n	c330 <rtc_count_init+0x84>
			}
			break;

		case RTC_COUNT_MODE_16BIT:
			/* Set 16bit mode. */
			rtc_module->MODE1.CTRLA.reg |= RTC_MODE1_CTRLA_MODE(1);
    c30a:	880a      	ldrh	r2, [r1, #0]
    c30c:	2304      	movs	r3, #4
    c30e:	4313      	orrs	r3, r2
    c310:	800b      	strh	r3, [r1, #0]

			/* Check if match on clear is set, and return invalid
			 * argument if set. */
			if (config->clear_on_match) {
    c312:	78e3      	ldrb	r3, [r4, #3]
				Assert(false);
				return STATUS_ERR_INVALID_ARG;
    c314:	2017      	movs	r0, #23
			/* Set 16bit mode. */
			rtc_module->MODE1.CTRLA.reg |= RTC_MODE1_CTRLA_MODE(1);

			/* Check if match on clear is set, and return invalid
			 * argument if set. */
			if (config->clear_on_match) {
    c316:	2b00      	cmp	r3, #0
    c318:	d10a      	bne.n	c330 <rtc_count_init+0x84>
				Assert(false);
				return STATUS_ERR_INVALID_ARG;
			}
			/* Set compare values. */
			for (uint8_t i = 0; i < RTC_NUM_OF_COMP16; i++) {
				rtc_count_set_compare(module, config->compare_values[i],
    c31a:	2200      	movs	r2, #0
    c31c:	68a1      	ldr	r1, [r4, #8]
    c31e:	0028      	movs	r0, r5
    c320:	4e07      	ldr	r6, [pc, #28]	; (c340 <rtc_count_init+0x94>)
    c322:	47b0      	blx	r6
    c324:	68e1      	ldr	r1, [r4, #12]
    c326:	2201      	movs	r2, #1
    c328:	0028      	movs	r0, r5
    c32a:	47b0      	blx	r6
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
	}

	/* Return status OK if everything was configured. */
	return STATUS_OK;
    c32c:	2000      	movs	r0, #0
    c32e:	e7ff      	b.n	c330 <rtc_count_init+0x84>
	_rtc_instance[_rtc_get_inst_index(hw)] = module;
#  endif

	/* Set config and return status. */
	return _rtc_count_set_config(module, config);
}
    c330:	bd70      	pop	{r4, r5, r6, pc}
    c332:	46c0      	nop			; (mov r8, r8)
    c334:	40000400 	.word	0x40000400
    c338:	40001000 	.word	0x40001000
    c33c:	2000254c 	.word	0x2000254c
    c340:	0000c249 	.word	0x0000c249

0000c344 <rtc_count_clear_compare_match>:
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;

	/* Check sanity. */
	switch (module->mode){
    c344:	7903      	ldrb	r3, [r0, #4]
    c346:	2b00      	cmp	r3, #0
    c348:	d005      	beq.n	c356 <rtc_count_clear_compare_match+0x12>
    c34a:	2b01      	cmp	r3, #1
    c34c:	d110      	bne.n	c370 <rtc_count_clear_compare_match+0x2c>
		case RTC_COUNT_MODE_32BIT:
			/* Check sanity for 32-bit mode. */
			if (comp_index > RTC_COMP32_NUM) {
				return STATUS_ERR_INVALID_ARG;
    c34e:	3316      	adds	r3, #22

	/* Check sanity. */
	switch (module->mode){
		case RTC_COUNT_MODE_32BIT:
			/* Check sanity for 32-bit mode. */
			if (comp_index > RTC_COMP32_NUM) {
    c350:	2901      	cmp	r1, #1
    c352:	d80e      	bhi.n	c372 <rtc_count_clear_compare_match+0x2e>
    c354:	e002      	b.n	c35c <rtc_count_clear_compare_match+0x18>
			break;

		case RTC_COUNT_MODE_16BIT:
			/* Check sanity for 16-bit mode. */
			if (comp_index > RTC_NUM_OF_COMP16) {
				return STATUS_ERR_INVALID_ARG;
    c356:	2317      	movs	r3, #23

			break;

		case RTC_COUNT_MODE_16BIT:
			/* Check sanity for 16-bit mode. */
			if (comp_index > RTC_NUM_OF_COMP16) {
    c358:	2902      	cmp	r1, #2
    c35a:	d80a      	bhi.n	c372 <rtc_count_clear_compare_match+0x2e>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    c35c:	6800      	ldr	r0, [r0, #0]
			Assert(false);
			return STATUS_ERR_BAD_FORMAT;
	}

	/* Clear INTFLAG. */
	rtc_module->MODE0.INTFLAG.reg = RTC_MODE1_INTFLAG_CMP(1 << comp_index);
    c35e:	2380      	movs	r3, #128	; 0x80
    c360:	005b      	lsls	r3, r3, #1
    c362:	408b      	lsls	r3, r1
    c364:	22c0      	movs	r2, #192	; 0xc0
    c366:	0092      	lsls	r2, r2, #2
    c368:	4013      	ands	r3, r2
    c36a:	8183      	strh	r3, [r0, #12]

	return STATUS_OK;
    c36c:	2300      	movs	r3, #0
    c36e:	e000      	b.n	c372 <rtc_count_clear_compare_match+0x2e>

			break;

		default:
			Assert(false);
			return STATUS_ERR_BAD_FORMAT;
    c370:	231a      	movs	r3, #26

	/* Clear INTFLAG. */
	rtc_module->MODE0.INTFLAG.reg = RTC_MODE1_INTFLAG_CMP(1 << comp_index);

	return STATUS_OK;
}
    c372:	0018      	movs	r0, r3
    c374:	4770      	bx	lr
    c376:	46c0      	nop			; (mov r8, r8)

0000c378 <rtc_count_register_callback>:
{

	enum status_code status = STATUS_OK;

	/* Overflow callback */
	if (callback_type == RTC_COUNT_CALLBACK_OVERFLOW
    c378:	2a0a      	cmp	r2, #10
    c37a:	d00d      	beq.n	c398 <rtc_count_register_callback+0x20>
#ifdef FEATURE_RTC_TAMPER_DETECTION
		|| callback_type == RTC_COUNT_CALLBACK_TAMPER
#endif
		|| (callback_type >= RTC_COUNT_CALLBACK_PERIODIC_INTERVAL_0
    c37c:	2a07      	cmp	r2, #7
    c37e:	d90b      	bls.n	c398 <rtc_count_register_callback+0x20>
			&& callback_type <= RTC_COUNT_CALLBACK_PERIODIC_INTERVAL_7)) {
		status = STATUS_OK;
	} else {
		/* Make sure callback type can be registered */
		switch (module->mode) {
    c380:	7903      	ldrb	r3, [r0, #4]
    c382:	2b00      	cmp	r3, #0
    c384:	d005      	beq.n	c392 <rtc_count_register_callback+0x1a>
    c386:	2b01      	cmp	r3, #1
    c388:	d111      	bne.n	c3ae <rtc_count_register_callback+0x36>
    c38a:	3316      	adds	r3, #22
		case RTC_COUNT_MODE_32BIT:
			/* Check sanity for 32-bit mode. */
			if (callback_type > (RTC_COMP32_NUM + RTC_PER_NUM)) {
    c38c:	2a09      	cmp	r2, #9
    c38e:	d80f      	bhi.n	c3b0 <rtc_count_register_callback+0x38>
    c390:	e002      	b.n	c398 <rtc_count_register_callback+0x20>
    c392:	2317      	movs	r3, #23
			}

			break;
		case RTC_COUNT_MODE_16BIT:
			/* Check sanity for 16-bit mode. */
			if (callback_type > (RTC_NUM_OF_COMP16 + RTC_PER_NUM)) {
    c394:	2a0a      	cmp	r2, #10
    c396:	d80b      	bhi.n	c3b0 <rtc_count_register_callback+0x38>
		}
	}

	if (status == STATUS_OK) {
		/* Register callback */
		module->callbacks[callback_type] = callback;
    c398:	1c93      	adds	r3, r2, #2
    c39a:	009b      	lsls	r3, r3, #2
    c39c:	5019      	str	r1, [r3, r0]
		/* Set corresponding bit to set callback as registered */
		module->registered_callback |= (1 << callback_type);
    c39e:	8e81      	ldrh	r1, [r0, #52]	; 0x34
    c3a0:	2301      	movs	r3, #1
    c3a2:	4093      	lsls	r3, r2
    c3a4:	430b      	orrs	r3, r1
    c3a6:	b29b      	uxth	r3, r3
    c3a8:	8683      	strh	r3, [r0, #52]	; 0x34
    c3aa:	2300      	movs	r3, #0
    c3ac:	e000      	b.n	c3b0 <rtc_count_register_callback+0x38>
			if (callback_type > (RTC_NUM_OF_COMP16 + RTC_PER_NUM)) {
				status = STATUS_ERR_INVALID_ARG;
			}
			break;
		default:
			status = STATUS_ERR_INVALID_ARG;
    c3ae:	2317      	movs	r3, #23
		/* Set corresponding bit to set callback as registered */
		module->registered_callback |= (1 << callback_type);
	}

	return status;
}
    c3b0:	0018      	movs	r0, r3
    c3b2:	4770      	bx	lr

0000c3b4 <rtc_count_enable_callback>:
 * \param[in]     callback_type Callback type to enable
 */
void rtc_count_enable_callback(
		struct rtc_module *const module,
		enum rtc_count_callback callback_type)
{
    c3b4:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    c3b6:	6803      	ldr	r3, [r0, #0]

	if (callback_type == RTC_COUNT_CALLBACK_OVERFLOW) {
    c3b8:	290a      	cmp	r1, #10
    c3ba:	d102      	bne.n	c3c2 <rtc_count_enable_callback+0xe>
		rtc_module->MODE0.INTENSET.reg = RTC_MODE0_INTFLAG_OVF;
    c3bc:	4a0d      	ldr	r2, [pc, #52]	; (c3f4 <rtc_count_enable_callback+0x40>)
    c3be:	815a      	strh	r2, [r3, #10]
    c3c0:	e010      	b.n	c3e4 <rtc_count_enable_callback+0x30>
#ifdef FEATURE_RTC_TAMPER_DETECTION
	} else if (callback_type == RTC_COUNT_CALLBACK_TAMPER) {
		rtc_module->MODE0.INTENSET.reg = RTC_MODE0_INTFLAG_TAMPER;
#endif
	} else if (callback_type >= RTC_COUNT_CALLBACK_PERIODIC_INTERVAL_0
    c3c2:	2907      	cmp	r1, #7
    c3c4:	d805      	bhi.n	c3d2 <rtc_count_enable_callback+0x1e>
			&& callback_type <= RTC_COUNT_CALLBACK_PERIODIC_INTERVAL_7) {
		rtc_module->MODE0.INTENSET.reg = RTC_MODE1_INTFLAG_PER(1 << callback_type);
    c3c6:	2201      	movs	r2, #1
    c3c8:	408a      	lsls	r2, r1
    c3ca:	24ff      	movs	r4, #255	; 0xff
    c3cc:	4022      	ands	r2, r4
    c3ce:	815a      	strh	r2, [r3, #10]
    c3d0:	e008      	b.n	c3e4 <rtc_count_enable_callback+0x30>
	}else {
		rtc_module->MODE0.INTENSET.reg = RTC_MODE1_INTFLAG_CMP(1 << (callback_type - RTC_PER_NUM));
    c3d2:	2280      	movs	r2, #128	; 0x80
    c3d4:	0052      	lsls	r2, r2, #1
    c3d6:	000c      	movs	r4, r1
    c3d8:	3c08      	subs	r4, #8
    c3da:	40a2      	lsls	r2, r4
    c3dc:	24c0      	movs	r4, #192	; 0xc0
    c3de:	00a4      	lsls	r4, r4, #2
    c3e0:	4022      	ands	r2, r4
    c3e2:	815a      	strh	r2, [r3, #10]
	}
	/* Mark callback as enabled. */
	module->enabled_callback |= (1 << callback_type);
    c3e4:	8ec2      	ldrh	r2, [r0, #54]	; 0x36
    c3e6:	2301      	movs	r3, #1
    c3e8:	408b      	lsls	r3, r1
    c3ea:	4313      	orrs	r3, r2
    c3ec:	b29b      	uxth	r3, r3
    c3ee:	86c3      	strh	r3, [r0, #54]	; 0x36
}
    c3f0:	bd10      	pop	{r4, pc}
    c3f2:	46c0      	nop			; (mov r8, r8)
    c3f4:	ffff8000 	.word	0xffff8000

0000c3f8 <RTC_Handler>:
/**
 * \internal ISR handler for RTC
 */
#if (RTC_INST_NUM == 1)
void RTC_Handler(void)
{
    c3f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c3fa:	465f      	mov	r7, fp
    c3fc:	4656      	mov	r6, sl
    c3fe:	464d      	mov	r5, r9
    c400:	4644      	mov	r4, r8
    c402:	b4f0      	push	{r4, r5, r6, r7}
 *
 * \param [in] instance_index  Default value 0
 */
static void _rtc_interrupt_handler(const uint32_t instance_index)
{
	struct rtc_module *module = _rtc_instance[instance_index];
    c404:	4b29      	ldr	r3, [pc, #164]	; (c4ac <RTC_Handler+0xb4>)
    c406:	681b      	ldr	r3, [r3, #0]
    c408:	469a      	mov	sl, r3

	Rtc *const rtc_module = module->hw;
    c40a:	681e      	ldr	r6, [r3, #0]

	/* Combine callback registered and enabled masks */
	uint16_t callback_mask = module->enabled_callback;
    c40c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
	callback_mask &= module->registered_callback;
    c40e:	4652      	mov	r2, sl
    c410:	8e92      	ldrh	r2, [r2, #52]	; 0x34
    c412:	401a      	ands	r2, r3
    c414:	4690      	mov	r8, r2

	/* Read and mask interrupt flag register */
	uint16_t interrupt_status = rtc_module->MODE0.INTFLAG.reg;
    c416:	89b3      	ldrh	r3, [r6, #12]
	interrupt_status &= rtc_module->MODE0.INTENSET.reg;
    c418:	8972      	ldrh	r2, [r6, #10]
    c41a:	4013      	ands	r3, r2

	if (interrupt_status & RTC_MODE0_INTFLAG_OVF) {
    c41c:	b21a      	sxth	r2, r3
    c41e:	2a00      	cmp	r2, #0
    c420:	da08      	bge.n	c434 <RTC_Handler+0x3c>
		/* Overflow interrupt */
		if (callback_mask & (1 << RTC_COUNT_CALLBACK_OVERFLOW)) {
    c422:	4643      	mov	r3, r8
    c424:	055b      	lsls	r3, r3, #21
    c426:	d502      	bpl.n	c42e <RTC_Handler+0x36>
			module->callbacks[RTC_COUNT_CALLBACK_OVERFLOW]();
    c428:	4653      	mov	r3, sl
    c42a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    c42c:	4798      	blx	r3
		}

		/* Clear interrupt flag */
		rtc_module->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_OVF;
    c42e:	4b20      	ldr	r3, [pc, #128]	; (c4b0 <RTC_Handler+0xb8>)
    c430:	81b3      	strh	r3, [r6, #12]
    c432:	e034      	b.n	c49e <RTC_Handler+0xa6>
    c434:	27ff      	movs	r7, #255	; 0xff
    c436:	401f      	ands	r7, r3

		/* Clear interrupt flag */
		rtc_module->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_TAMPER;
#endif

	} else if (interrupt_status & RTC_MODE1_INTFLAG_PER(0xff)) {
    c438:	d01a      	beq.n	c470 <RTC_Handler+0x78>
    c43a:	2400      	movs	r4, #0
		uint8_t i  = 0;
		for ( i = 0;i < RTC_PER_NUM;i++) {
			if ((interrupt_status & RTC_MODE1_INTFLAG_PER(1 << i))
    c43c:	2301      	movs	r3, #1
    c43e:	4699      	mov	r9, r3
			  && (callback_mask & (1 << i))) {
				module->callbacks[i]();
			}

			/* Clear interrupt flag */
			rtc_module->MODE0.INTFLAG.reg = RTC_MODE1_INTFLAG_PER(1<<i);
    c440:	33fe      	adds	r3, #254	; 0xfe
    c442:	469b      	mov	fp, r3
#endif

	} else if (interrupt_status & RTC_MODE1_INTFLAG_PER(0xff)) {
		uint8_t i  = 0;
		for ( i = 0;i < RTC_PER_NUM;i++) {
			if ((interrupt_status & RTC_MODE1_INTFLAG_PER(1 << i))
    c444:	0023      	movs	r3, r4
    c446:	464d      	mov	r5, r9
    c448:	40a5      	lsls	r5, r4
    c44a:	422f      	tst	r7, r5
    c44c:	d009      	beq.n	c462 <RTC_Handler+0x6a>
			  && (callback_mask & (1 << i))) {
    c44e:	4642      	mov	r2, r8
    c450:	4122      	asrs	r2, r4
    c452:	4649      	mov	r1, r9
    c454:	4211      	tst	r1, r2
    c456:	d004      	beq.n	c462 <RTC_Handler+0x6a>
				module->callbacks[i]();
    c458:	3302      	adds	r3, #2
    c45a:	009b      	lsls	r3, r3, #2
    c45c:	4652      	mov	r2, sl
    c45e:	589b      	ldr	r3, [r3, r2]
    c460:	4798      	blx	r3
			}

			/* Clear interrupt flag */
			rtc_module->MODE0.INTFLAG.reg = RTC_MODE1_INTFLAG_PER(1<<i);
    c462:	465b      	mov	r3, fp
    c464:	401d      	ands	r5, r3
    c466:	81b5      	strh	r5, [r6, #12]
    c468:	3401      	adds	r4, #1
		rtc_module->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_TAMPER;
#endif

	} else if (interrupt_status & RTC_MODE1_INTFLAG_PER(0xff)) {
		uint8_t i  = 0;
		for ( i = 0;i < RTC_PER_NUM;i++) {
    c46a:	2c08      	cmp	r4, #8
    c46c:	d1ea      	bne.n	c444 <RTC_Handler+0x4c>
    c46e:	e016      	b.n	c49e <RTC_Handler+0xa6>
			}

			/* Clear interrupt flag */
			rtc_module->MODE0.INTFLAG.reg = RTC_MODE1_INTFLAG_PER(1<<i);
		}
	}else if (interrupt_status & RTC_MODE1_INTFLAG_CMP(1 << 0)) {
    c470:	05da      	lsls	r2, r3, #23
    c472:	d509      	bpl.n	c488 <RTC_Handler+0x90>
		/* Compare 0 interrupt */
		if (callback_mask & (1 << RTC_COUNT_CALLBACK_COMPARE_0)) {
    c474:	4643      	mov	r3, r8
    c476:	05db      	lsls	r3, r3, #23
    c478:	d502      	bpl.n	c480 <RTC_Handler+0x88>
			module->callbacks[RTC_COUNT_CALLBACK_COMPARE_0]();
    c47a:	4653      	mov	r3, sl
    c47c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    c47e:	4798      	blx	r3
		}
		/* Clear interrupt flag */
		rtc_module->MODE0.INTFLAG.reg = RTC_MODE1_INTFLAG_CMP(1 << 0);
    c480:	2380      	movs	r3, #128	; 0x80
    c482:	005b      	lsls	r3, r3, #1
    c484:	81b3      	strh	r3, [r6, #12]
    c486:	e00a      	b.n	c49e <RTC_Handler+0xa6>

	} else if (interrupt_status & RTC_MODE1_INTFLAG_CMP(1 << 1)) {
    c488:	059b      	lsls	r3, r3, #22
    c48a:	d508      	bpl.n	c49e <RTC_Handler+0xa6>
		#if (RTC_NUM_OF_COMP16 > 1) || defined(__DOXYGEN__)
		/* Compare 1 interrupt */
		if (callback_mask & (1 << RTC_COUNT_CALLBACK_COMPARE_1)) {
    c48c:	4643      	mov	r3, r8
    c48e:	059b      	lsls	r3, r3, #22
    c490:	d502      	bpl.n	c498 <RTC_Handler+0xa0>
			module->callbacks[RTC_COUNT_CALLBACK_COMPARE_1]();
    c492:	4653      	mov	r3, sl
    c494:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    c496:	4798      	blx	r3
		}
		/* Clear interrupt flag */
		rtc_module->MODE0.INTFLAG.reg = RTC_MODE1_INTFLAG_CMP(1 << 1);
    c498:	2380      	movs	r3, #128	; 0x80
    c49a:	009b      	lsls	r3, r3, #2
    c49c:	81b3      	strh	r3, [r6, #12]
 */
#if (RTC_INST_NUM == 1)
void RTC_Handler(void)
{
	_rtc_interrupt_handler(0);
}
    c49e:	bc3c      	pop	{r2, r3, r4, r5}
    c4a0:	4690      	mov	r8, r2
    c4a2:	4699      	mov	r9, r3
    c4a4:	46a2      	mov	sl, r4
    c4a6:	46ab      	mov	fp, r5
    c4a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c4aa:	46c0      	nop			; (mov r8, r8)
    c4ac:	2000254c 	.word	0x2000254c
    c4b0:	ffff8000 	.word	0xffff8000

0000c4b4 <delay_init>:
 *
 * This must be called during start up to initialize the delay routine with
 * the current used main clock. It must run any time the main CPU clock is changed.
 */
void delay_init(void)
{
    c4b4:	b570      	push	{r4, r5, r6, lr}
	cycles_per_ms = system_gclk_gen_get_hz(0);
    c4b6:	2000      	movs	r0, #0
    c4b8:	4b08      	ldr	r3, [pc, #32]	; (c4dc <delay_init+0x28>)
    c4ba:	4798      	blx	r3
    c4bc:	0005      	movs	r5, r0
	cycles_per_ms /= 1000;
    c4be:	4c08      	ldr	r4, [pc, #32]	; (c4e0 <delay_init+0x2c>)
    c4c0:	21fa      	movs	r1, #250	; 0xfa
    c4c2:	0089      	lsls	r1, r1, #2
    c4c4:	47a0      	blx	r4
    c4c6:	4b07      	ldr	r3, [pc, #28]	; (c4e4 <delay_init+0x30>)
    c4c8:	6018      	str	r0, [r3, #0]
	cycles_per_us = cycles_per_ms / 1000;
    c4ca:	4907      	ldr	r1, [pc, #28]	; (c4e8 <delay_init+0x34>)
    c4cc:	0028      	movs	r0, r5
    c4ce:	47a0      	blx	r4
    c4d0:	4b06      	ldr	r3, [pc, #24]	; (c4ec <delay_init+0x38>)
    c4d2:	6018      	str	r0, [r3, #0]

	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
    c4d4:	2205      	movs	r2, #5
    c4d6:	4b06      	ldr	r3, [pc, #24]	; (c4f0 <delay_init+0x3c>)
    c4d8:	601a      	str	r2, [r3, #0]
}
    c4da:	bd70      	pop	{r4, r5, r6, pc}
    c4dc:	0000d87d 	.word	0x0000d87d
    c4e0:	0000f82d 	.word	0x0000f82d
    c4e4:	20000134 	.word	0x20000134
    c4e8:	000f4240 	.word	0x000f4240
    c4ec:	20000130 	.word	0x20000130
    c4f0:	e000e010 	.word	0xe000e010

0000c4f4 <delay_cycles_ms>:
 *
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
    c4f4:	b530      	push	{r4, r5, lr}
	while (n--) {
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
    c4f6:	4b08      	ldr	r3, [pc, #32]	; (c518 <delay_cycles_ms+0x24>)
    c4f8:	681c      	ldr	r4, [r3, #0]
 */
static inline void delay_cycles(
		const uint32_t n)
{
	if (n > 0) {
		SysTick->LOAD = n;
    c4fa:	4a08      	ldr	r2, [pc, #32]	; (c51c <delay_cycles_ms+0x28>)
		SysTick->VAL = 0;
    c4fc:	2500      	movs	r5, #0

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
    c4fe:	2180      	movs	r1, #128	; 0x80
    c500:	0249      	lsls	r1, r1, #9
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
	while (n--) {
    c502:	e006      	b.n	c512 <delay_cycles_ms+0x1e>
 * \param n  Number of cycles to delay
 */
static inline void delay_cycles(
		const uint32_t n)
{
	if (n > 0) {
    c504:	2c00      	cmp	r4, #0
    c506:	d004      	beq.n	c512 <delay_cycles_ms+0x1e>
		SysTick->LOAD = n;
    c508:	6054      	str	r4, [r2, #4]
		SysTick->VAL = 0;
    c50a:	6095      	str	r5, [r2, #8]

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
    c50c:	6813      	ldr	r3, [r2, #0]
    c50e:	420b      	tst	r3, r1
    c510:	d0fc      	beq.n	c50c <delay_cycles_ms+0x18>
    c512:	3801      	subs	r0, #1
    c514:	d2f6      	bcs.n	c504 <delay_cycles_ms+0x10>
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
	}
}
    c516:	bd30      	pop	{r4, r5, pc}
    c518:	20000134 	.word	0x20000134
    c51c:	e000e010 	.word	0xe000e010

0000c520 <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
    c520:	4b0c      	ldr	r3, [pc, #48]	; (c554 <cpu_irq_enter_critical+0x34>)
    c522:	681b      	ldr	r3, [r3, #0]
    c524:	2b00      	cmp	r3, #0
    c526:	d110      	bne.n	c54a <cpu_irq_enter_critical+0x2a>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    c528:	f3ef 8310 	mrs	r3, PRIMASK
		if (cpu_irq_is_enabled()) {
    c52c:	2b00      	cmp	r3, #0
    c52e:	d109      	bne.n	c544 <cpu_irq_enter_critical+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    c530:	b672      	cpsid	i
    c532:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    c536:	2200      	movs	r2, #0
    c538:	4b07      	ldr	r3, [pc, #28]	; (c558 <cpu_irq_enter_critical+0x38>)
    c53a:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
    c53c:	3201      	adds	r2, #1
    c53e:	4b07      	ldr	r3, [pc, #28]	; (c55c <cpu_irq_enter_critical+0x3c>)
    c540:	701a      	strb	r2, [r3, #0]
    c542:	e002      	b.n	c54a <cpu_irq_enter_critical+0x2a>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    c544:	2200      	movs	r2, #0
    c546:	4b05      	ldr	r3, [pc, #20]	; (c55c <cpu_irq_enter_critical+0x3c>)
    c548:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    c54a:	4a02      	ldr	r2, [pc, #8]	; (c554 <cpu_irq_enter_critical+0x34>)
    c54c:	6813      	ldr	r3, [r2, #0]
    c54e:	3301      	adds	r3, #1
    c550:	6013      	str	r3, [r2, #0]
}
    c552:	4770      	bx	lr
    c554:	20001940 	.word	0x20001940
    c558:	20000138 	.word	0x20000138
    c55c:	20001944 	.word	0x20001944

0000c560 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    c560:	4b08      	ldr	r3, [pc, #32]	; (c584 <cpu_irq_leave_critical+0x24>)
    c562:	681a      	ldr	r2, [r3, #0]
    c564:	3a01      	subs	r2, #1
    c566:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    c568:	681b      	ldr	r3, [r3, #0]
    c56a:	2b00      	cmp	r3, #0
    c56c:	d109      	bne.n	c582 <cpu_irq_leave_critical+0x22>
    c56e:	4b06      	ldr	r3, [pc, #24]	; (c588 <cpu_irq_leave_critical+0x28>)
    c570:	781b      	ldrb	r3, [r3, #0]
    c572:	2b00      	cmp	r3, #0
    c574:	d005      	beq.n	c582 <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
    c576:	2201      	movs	r2, #1
    c578:	4b04      	ldr	r3, [pc, #16]	; (c58c <cpu_irq_leave_critical+0x2c>)
    c57a:	701a      	strb	r2, [r3, #0]
    c57c:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    c580:	b662      	cpsie	i
	}
}
    c582:	4770      	bx	lr
    c584:	20001940 	.word	0x20001940
    c588:	20001944 	.word	0x20001944
    c58c:	20000138 	.word	0x20000138

0000c590 <extint_register_callback>:
	/* Sanity check arguments */
	Assert(callback);

	if (type != EXTINT_CALLBACK_TYPE_DETECT) {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    c590:	2317      	movs	r3, #23
	const enum extint_callback_type type)
{
	/* Sanity check arguments */
	Assert(callback);

	if (type != EXTINT_CALLBACK_TYPE_DETECT) {
    c592:	2a00      	cmp	r2, #0
    c594:	d10d      	bne.n	c5b2 <extint_register_callback+0x22>
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	if (_extint_dev.callbacks[channel] == NULL) {
    c596:	008b      	lsls	r3, r1, #2
    c598:	4a07      	ldr	r2, [pc, #28]	; (c5b8 <extint_register_callback+0x28>)
    c59a:	589b      	ldr	r3, [r3, r2]
    c59c:	2b00      	cmp	r3, #0
    c59e:	d103      	bne.n	c5a8 <extint_register_callback+0x18>
		_extint_dev.callbacks[channel] = callback;
    c5a0:	0089      	lsls	r1, r1, #2
    c5a2:	5088      	str	r0, [r1, r2]
		return STATUS_OK;
    c5a4:	2300      	movs	r3, #0
    c5a6:	e004      	b.n	c5b2 <extint_register_callback+0x22>
	} else if (_extint_dev.callbacks[channel] == callback) {
    c5a8:	4283      	cmp	r3, r0
    c5aa:	d001      	beq.n	c5b0 <extint_register_callback+0x20>
		return STATUS_OK;
	}

	return STATUS_ERR_ALREADY_INITIALIZED;
    c5ac:	231d      	movs	r3, #29
    c5ae:	e000      	b.n	c5b2 <extint_register_callback+0x22>

	if (_extint_dev.callbacks[channel] == NULL) {
		_extint_dev.callbacks[channel] = callback;
		return STATUS_OK;
	} else if (_extint_dev.callbacks[channel] == callback) {
		return STATUS_OK;
    c5b0:	2300      	movs	r3, #0
	}

	return STATUS_ERR_ALREADY_INITIALIZED;
}
    c5b2:	0018      	movs	r0, r3
    c5b4:	4770      	bx	lr
    c5b6:	46c0      	nop			; (mov r8, r8)
    c5b8:	20002810 	.word	0x20002810

0000c5bc <extint_chan_enable_callback>:

		eic->INTENSET.reg = (1UL << channel);
	}
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    c5bc:	2317      	movs	r3, #23
 */
enum status_code extint_chan_enable_callback(
	const uint8_t channel,
	const enum extint_callback_type type)
{
	if (type == EXTINT_CALLBACK_TYPE_DETECT) {
    c5be:	2900      	cmp	r1, #0
    c5c0:	d107      	bne.n	c5d2 <extint_chan_enable_callback+0x16>
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
	} else {
		Assert(false);
		return NULL;
    c5c2:	2200      	movs	r2, #0
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    c5c4:	281f      	cmp	r0, #31
    c5c6:	d800      	bhi.n	c5ca <extint_chan_enable_callback+0xe>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    c5c8:	4a03      	ldr	r2, [pc, #12]	; (c5d8 <extint_chan_enable_callback+0x1c>)
		Eic *const eic = _extint_get_eic_from_channel(channel);

		eic->INTENSET.reg = (1UL << channel);
    c5ca:	2301      	movs	r3, #1
    c5cc:	4083      	lsls	r3, r0
    c5ce:	6113      	str	r3, [r2, #16]
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    c5d0:	2300      	movs	r3, #0
}
    c5d2:	0018      	movs	r0, r3
    c5d4:	4770      	bx	lr
    c5d6:	46c0      	nop			; (mov r8, r8)
    c5d8:	40002400 	.word	0x40002400

0000c5dc <extint_chan_disable_callback>:

		eic->INTENCLR.reg = (1UL << channel);
	}
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    c5dc:	2317      	movs	r3, #23
 */
enum status_code extint_chan_disable_callback(
	const uint8_t channel,
	const enum extint_callback_type type)
{
	if (type == EXTINT_CALLBACK_TYPE_DETECT) {
    c5de:	2900      	cmp	r1, #0
    c5e0:	d107      	bne.n	c5f2 <extint_chan_disable_callback+0x16>
	} else {
		Assert(false);
		return NULL;
    c5e2:	2200      	movs	r2, #0
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    c5e4:	281f      	cmp	r0, #31
    c5e6:	d800      	bhi.n	c5ea <extint_chan_disable_callback+0xe>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    c5e8:	4a03      	ldr	r2, [pc, #12]	; (c5f8 <extint_chan_disable_callback+0x1c>)
		Eic *const eic = _extint_get_eic_from_channel(channel);

		eic->INTENCLR.reg = (1UL << channel);
    c5ea:	2301      	movs	r3, #1
    c5ec:	4083      	lsls	r3, r0
    c5ee:	60d3      	str	r3, [r2, #12]
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    c5f0:	2300      	movs	r3, #0
}
    c5f2:	0018      	movs	r0, r3
    c5f4:	4770      	bx	lr
    c5f6:	46c0      	nop			; (mov r8, r8)
    c5f8:	40002400 	.word	0x40002400

0000c5fc <EIC_Handler>:
	return _current_channel;
}

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
    c5fc:	b570      	push	{r4, r5, r6, lr}
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    c5fe:	2200      	movs	r2, #0
    c600:	4b15      	ldr	r3, [pc, #84]	; (c658 <EIC_Handler+0x5c>)
    c602:	701a      	strb	r2, [r3, #0]
    c604:	2300      	movs	r3, #0
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
    c606:	251f      	movs	r5, #31
		if (extint_chan_is_detected(_current_channel)) {
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
    c608:	4e14      	ldr	r6, [pc, #80]	; (c65c <EIC_Handler+0x60>)

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    c60a:	4c13      	ldr	r4, [pc, #76]	; (c658 <EIC_Handler+0x5c>)
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    c60c:	2b1f      	cmp	r3, #31
    c60e:	d919      	bls.n	c644 <EIC_Handler+0x48>
    c610:	e00f      	b.n	c632 <EIC_Handler+0x36>
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
	} else {
		Assert(false);
		return NULL;
    c612:	2100      	movs	r1, #0
    c614:	e000      	b.n	c618 <EIC_Handler+0x1c>

	if (eic_index < EIC_INST_NUM) {
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    c616:	4912      	ldr	r1, [pc, #72]	; (c660 <EIC_Handler+0x64>)
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));

	eic_module->INTFLAG.reg = eic_mask;
    c618:	614a      	str	r2, [r1, #20]
		if (extint_chan_is_detected(_current_channel)) {
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
    c61a:	009b      	lsls	r3, r3, #2
    c61c:	599b      	ldr	r3, [r3, r6]
    c61e:	2b00      	cmp	r3, #0
    c620:	d000      	beq.n	c624 <EIC_Handler+0x28>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
    c622:	4798      	blx	r3

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    c624:	7823      	ldrb	r3, [r4, #0]
    c626:	3301      	adds	r3, #1
    c628:	b2db      	uxtb	r3, r3
    c62a:	7023      	strb	r3, [r4, #0]
    c62c:	2b0f      	cmp	r3, #15
    c62e:	d9ed      	bls.n	c60c <EIC_Handler+0x10>
    c630:	e011      	b.n	c656 <EIC_Handler+0x5a>
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
    c632:	0029      	movs	r1, r5
    c634:	4019      	ands	r1, r3
    c636:	2201      	movs	r2, #1
    c638:	408a      	lsls	r2, r1

	return (eic_module->INTFLAG.reg & eic_mask);
    c63a:	2100      	movs	r1, #0
    c63c:	6949      	ldr	r1, [r1, #20]
		if (extint_chan_is_detected(_current_channel)) {
    c63e:	4211      	tst	r1, r2
    c640:	d1e7      	bne.n	c612 <EIC_Handler+0x16>
    c642:	e7ef      	b.n	c624 <EIC_Handler+0x28>
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
    c644:	0029      	movs	r1, r5
    c646:	4019      	ands	r1, r3
    c648:	2201      	movs	r2, #1
    c64a:	408a      	lsls	r2, r1

	return (eic_module->INTFLAG.reg & eic_mask);
    c64c:	4904      	ldr	r1, [pc, #16]	; (c660 <EIC_Handler+0x64>)
    c64e:	6949      	ldr	r1, [r1, #20]
    c650:	4211      	tst	r1, r2
    c652:	d1e0      	bne.n	c616 <EIC_Handler+0x1a>
    c654:	e7e6      	b.n	c624 <EIC_Handler+0x28>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
			}
		}
	}
}
    c656:	bd70      	pop	{r4, r5, r6, pc}
    c658:	2000280d 	.word	0x2000280d
    c65c:	20002810 	.word	0x20002810
    c660:	40002400 	.word	0x40002400

0000c664 <_extint_enable>:
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRLA.reg |= EIC_CTRLA_ENABLE;
    c664:	4a06      	ldr	r2, [pc, #24]	; (c680 <_extint_enable+0x1c>)
    c666:	7811      	ldrb	r1, [r2, #0]
    c668:	2302      	movs	r3, #2
    c66a:	430b      	orrs	r3, r1
    c66c:	7013      	strb	r3, [r2, #0]
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if((eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_ENABLE)
    c66e:	2102      	movs	r1, #2
		 || (eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_SWRST)){
    c670:	2001      	movs	r0, #1
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if((eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_ENABLE)
    c672:	6853      	ldr	r3, [r2, #4]
    c674:	4219      	tst	r1, r3
    c676:	d1fc      	bne.n	c672 <_extint_enable+0xe>
		 || (eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_SWRST)){
    c678:	6853      	ldr	r3, [r2, #4]
    c67a:	4218      	tst	r0, r3
    c67c:	d1f9      	bne.n	c672 <_extint_enable+0xe>
	}

	while (extint_is_syncing()) {
		/* Wait for all hardware modules to complete synchronization */
	}
}
    c67e:	4770      	bx	lr
    c680:	40002400 	.word	0x40002400

0000c684 <_extint_disable>:
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	/* Disable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRLA.reg &= ~EIC_CTRLA_ENABLE;
    c684:	4a06      	ldr	r2, [pc, #24]	; (c6a0 <_extint_disable+0x1c>)
    c686:	7813      	ldrb	r3, [r2, #0]
    c688:	2102      	movs	r1, #2
    c68a:	438b      	bics	r3, r1
    c68c:	7013      	strb	r3, [r2, #0]
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if((eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_ENABLE)
		 || (eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_SWRST)){
    c68e:	2001      	movs	r0, #1
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if((eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_ENABLE)
    c690:	6853      	ldr	r3, [r2, #4]
    c692:	4219      	tst	r1, r3
    c694:	d1fc      	bne.n	c690 <_extint_disable+0xc>
		 || (eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_SWRST)){
    c696:	6853      	ldr	r3, [r2, #4]
    c698:	4218      	tst	r0, r3
    c69a:	d1f9      	bne.n	c690 <_extint_disable+0xc>
	}

	while (extint_is_syncing()) {
		/* Wait for all hardware modules to complete synchronization */
	}
}
    c69c:	4770      	bx	lr
    c69e:	46c0      	nop			; (mov r8, r8)
    c6a0:	40002400 	.word	0x40002400

0000c6a4 <_system_extint_init>:
 * \note When SYSTEM module is used, this function will be invoked by
 * \ref system_init() automatically if the module is included.
 */
void _system_extint_init(void);
void _system_extint_init(void)
{
    c6a4:	b500      	push	{lr}
    c6a6:	b083      	sub	sp, #12
    c6a8:	4a18      	ldr	r2, [pc, #96]	; (c70c <_system_extint_init+0x68>)
    c6aa:	6953      	ldr	r3, [r2, #20]
    c6ac:	2180      	movs	r1, #128	; 0x80
    c6ae:	0089      	lsls	r1, r1, #2
    c6b0:	430b      	orrs	r3, r1
    c6b2:	6153      	str	r3, [r2, #20]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    c6b4:	a901      	add	r1, sp, #4
    c6b6:	2300      	movs	r3, #0
    c6b8:	700b      	strb	r3, [r1, #0]
#if (EXTINT_CLOCK_SELECTION == EXTINT_CLK_GCLK)
	/* Configure the generic clock for the module and enable it */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = EXTINT_CLOCK_SOURCE;
	system_gclk_chan_set_config(EIC_GCLK_ID, &gclk_chan_conf);
    c6ba:	2003      	movs	r0, #3
    c6bc:	4b14      	ldr	r3, [pc, #80]	; (c710 <_system_extint_init+0x6c>)
    c6be:	4798      	blx	r3

	/* Enable the clock anyway, since when needed it will be requested
	 * by External Interrupt driver */
	system_gclk_chan_enable(EIC_GCLK_ID);
    c6c0:	2003      	movs	r0, #3
    c6c2:	4b14      	ldr	r3, [pc, #80]	; (c714 <_system_extint_init+0x70>)
    c6c4:	4798      	blx	r3
#endif

	/* Reset all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRLA.reg |= EIC_CTRLA_SWRST;
    c6c6:	4a14      	ldr	r2, [pc, #80]	; (c718 <_system_extint_init+0x74>)
    c6c8:	7811      	ldrb	r1, [r2, #0]
    c6ca:	2301      	movs	r3, #1
    c6cc:	430b      	orrs	r3, r1
    c6ce:	7013      	strb	r3, [r2, #0]
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if((eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_ENABLE)
    c6d0:	2102      	movs	r1, #2
		 || (eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_SWRST)){
    c6d2:	2001      	movs	r0, #1
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if((eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_ENABLE)
    c6d4:	6853      	ldr	r3, [r2, #4]
    c6d6:	4219      	tst	r1, r3
    c6d8:	d1fc      	bne.n	c6d4 <_system_extint_init+0x30>
		 || (eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_SWRST)){
    c6da:	6853      	ldr	r3, [r2, #4]
    c6dc:	4218      	tst	r0, r3
    c6de:	d009      	beq.n	c6f4 <_system_extint_init+0x50>
    c6e0:	e7f8      	b.n	c6d4 <_system_extint_init+0x30>

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
		_extint_dev.callbacks[j] = NULL;
    c6e2:	c304      	stmia	r3!, {r2}
#endif

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
    c6e4:	428b      	cmp	r3, r1
    c6e6:	d1fc      	bne.n	c6e2 <_system_extint_init+0x3e>
    c6e8:	2208      	movs	r2, #8
    c6ea:	4b0c      	ldr	r3, [pc, #48]	; (c71c <_system_extint_init+0x78>)
    c6ec:	601a      	str	r2, [r3, #0]
	}
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_EIC);
#endif

	/* Enables the driver for further use */
	_extint_enable();
    c6ee:	4b0c      	ldr	r3, [pc, #48]	; (c720 <_system_extint_init+0x7c>)
    c6f0:	4798      	blx	r3
}
    c6f2:	e009      	b.n	c708 <_system_extint_init+0x64>
		/* Wait for all hardware modules to complete synchronization */
	}

#if (EXTINT_CLOCK_SELECTION == EXTINT_CLK_GCLK)
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRLA.bit.CKSEL = EXTINT_CLK_GCLK;
    c6f4:	4a08      	ldr	r2, [pc, #32]	; (c718 <_system_extint_init+0x74>)
    c6f6:	7813      	ldrb	r3, [r2, #0]
    c6f8:	2110      	movs	r1, #16
    c6fa:	438b      	bics	r3, r1
    c6fc:	7013      	strb	r3, [r2, #0]
    c6fe:	4b09      	ldr	r3, [pc, #36]	; (c724 <_system_extint_init+0x80>)
    c700:	0019      	movs	r1, r3
    c702:	3140      	adds	r1, #64	; 0x40

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
		_extint_dev.callbacks[j] = NULL;
    c704:	2200      	movs	r2, #0
    c706:	e7ec      	b.n	c6e2 <_system_extint_init+0x3e>
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_EIC);
#endif

	/* Enables the driver for further use */
	_extint_enable();
}
    c708:	b003      	add	sp, #12
    c70a:	bd00      	pop	{pc}
    c70c:	40000400 	.word	0x40000400
    c710:	0000d959 	.word	0x0000d959
    c714:	0000d8e9 	.word	0x0000d8e9
    c718:	40002400 	.word	0x40002400
    c71c:	e000e100 	.word	0xe000e100
    c720:	0000c665 	.word	0x0000c665
    c724:	20002810 	.word	0x20002810

0000c728 <extint_chan_get_config_defaults>:
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->gpio_pin            = 0;
    c728:	2300      	movs	r3, #0
    c72a:	6003      	str	r3, [r0, #0]
	config->gpio_pin_mux        = 0;
    c72c:	6043      	str	r3, [r0, #4]
	config->gpio_pin_pull       = EXTINT_PULL_UP;
    c72e:	2201      	movs	r2, #1
    c730:	7202      	strb	r2, [r0, #8]
	config->filter_input_signal = false;
    c732:	7283      	strb	r3, [r0, #10]
	config->detection_criteria  = EXTINT_DETECT_FALLING;
    c734:	3201      	adds	r2, #1
    c736:	72c2      	strb	r2, [r0, #11]
	config->enable_async_edge_detection = false;
    c738:	7243      	strb	r3, [r0, #9]
}
    c73a:	4770      	bx	lr

0000c73c <extint_chan_set_config>:

 */
void extint_chan_set_config(
		const uint8_t channel,
		const struct extint_chan_conf *const config)
{
    c73c:	b5f0      	push	{r4, r5, r6, r7, lr}
    c73e:	b083      	sub	sp, #12
    c740:	0005      	movs	r5, r0
    c742:	000c      	movs	r4, r1
	/* Sanity check arguments */
	Assert(config);
	_extint_disable();
    c744:	4b1b      	ldr	r3, [pc, #108]	; (c7b4 <extint_chan_set_config+0x78>)
    c746:	4798      	blx	r3
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    c748:	a901      	add	r1, sp, #4
    c74a:	2300      	movs	r3, #0
    c74c:	704b      	strb	r3, [r1, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    c74e:	70cb      	strb	r3, [r1, #3]
			config->detection_criteria)));
#endif
	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = config->gpio_pin_mux;
    c750:	7923      	ldrb	r3, [r4, #4]
    c752:	700b      	strb	r3, [r1, #0]
	pinmux_config.direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->gpio_pin_pull;
    c754:	7a23      	ldrb	r3, [r4, #8]
    c756:	708b      	strb	r3, [r1, #2]
	system_pinmux_pin_set_config(config->gpio_pin, &pinmux_config);
    c758:	7820      	ldrb	r0, [r4, #0]
    c75a:	4b17      	ldr	r3, [pc, #92]	; (c7b8 <extint_chan_set_config+0x7c>)
    c75c:	4798      	blx	r3
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
	} else {
		Assert(false);
		return NULL;
    c75e:	2000      	movs	r0, #0
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    c760:	2d1f      	cmp	r5, #31
    c762:	d800      	bhi.n	c766 <extint_chan_set_config+0x2a>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    c764:	4815      	ldr	r0, [pc, #84]	; (c7bc <extint_chan_set_config+0x80>)

	/* Get a pointer to the module hardware instance */
	Eic *const EIC_module = _extint_get_eic_from_channel(channel);

	uint32_t config_pos = (4 * (channel % 8));
    c766:	2107      	movs	r1, #7
    c768:	4029      	ands	r1, r5
    c76a:	0089      	lsls	r1, r1, #2
	uint32_t new_config;

	/* Determine the channel's new edge detection configuration */
	new_config = (config->detection_criteria << EIC_CONFIG_SENSE0_Pos);
    c76c:	7ae2      	ldrb	r2, [r4, #11]

	/* Enable the hardware signal filter if requested in the config */
	if (config->filter_input_signal) {
    c76e:	7aa3      	ldrb	r3, [r4, #10]
    c770:	2b00      	cmp	r3, #0
    c772:	d001      	beq.n	c778 <extint_chan_set_config+0x3c>
		new_config |= EIC_CONFIG_FILTEN0;
    c774:	2308      	movs	r3, #8
    c776:	431a      	orrs	r2, r3
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
    c778:	08eb      	lsrs	r3, r5, #3
    c77a:	009b      	lsls	r3, r3, #2
    c77c:	18c3      	adds	r3, r0, r3
		= (EIC_module->CONFIG[channel / 8].reg &
    c77e:	69de      	ldr	r6, [r3, #28]
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
    c780:	270f      	movs	r7, #15
    c782:	408f      	lsls	r7, r1
    c784:	43be      	bics	r6, r7
    c786:	408a      	lsls	r2, r1
    c788:	4332      	orrs	r2, r6
		new_config |= EIC_CONFIG_FILTEN0;
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
    c78a:	61da      	str	r2, [r3, #28]
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
			(new_config << config_pos);
#if (SAML22) || (SAML21XXXB)
	/* Config asynchronous edge detection */
	if (config->enable_async_edge_detection) {
    c78c:	7a63      	ldrb	r3, [r4, #9]
    c78e:	2b00      	cmp	r3, #0
    c790:	d005      	beq.n	c79e <extint_chan_set_config+0x62>
		EIC_module->ASYNCH.reg |= (1UL << channel);
    c792:	6982      	ldr	r2, [r0, #24]
    c794:	2301      	movs	r3, #1
    c796:	40ab      	lsls	r3, r5
    c798:	4313      	orrs	r3, r2
    c79a:	6183      	str	r3, [r0, #24]
    c79c:	e006      	b.n	c7ac <extint_chan_set_config+0x70>
	} else {
		EIC_module->ASYNCH.reg &= (EIC_ASYNCH_MASK & (~(1UL << channel)));
    c79e:	6983      	ldr	r3, [r0, #24]
    c7a0:	2201      	movs	r2, #1
    c7a2:	40aa      	lsls	r2, r5
    c7a4:	041b      	lsls	r3, r3, #16
    c7a6:	0c1b      	lsrs	r3, r3, #16
    c7a8:	4393      	bics	r3, r2
    c7aa:	6183      	str	r3, [r0, #24]
		EIC_module->EIC_ASYNCH.reg |= (1UL << channel);
	} else {
		EIC_module->EIC_ASYNCH.reg &= (EIC_EIC_ASYNCH_MASK & (~(1UL << channel)));
	}
#endif
	_extint_enable();
    c7ac:	4b04      	ldr	r3, [pc, #16]	; (c7c0 <extint_chan_set_config+0x84>)
    c7ae:	4798      	blx	r3
}
    c7b0:	b003      	add	sp, #12
    c7b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c7b4:	0000c685 	.word	0x0000c685
    c7b8:	0000da55 	.word	0x0000da55
    c7bc:	40002400 	.word	0x40002400
    c7c0:	0000c665 	.word	0x0000c665

0000c7c4 <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
    c7c4:	b500      	push	{lr}
    c7c6:	b083      	sub	sp, #12
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    c7c8:	ab01      	add	r3, sp, #4
    c7ca:	2280      	movs	r2, #128	; 0x80
    c7cc:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
    c7ce:	780a      	ldrb	r2, [r1, #0]
    c7d0:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
    c7d2:	784a      	ldrb	r2, [r1, #1]
    c7d4:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
    c7d6:	788a      	ldrb	r2, [r1, #2]
    c7d8:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    c7da:	0019      	movs	r1, r3
    c7dc:	4b01      	ldr	r3, [pc, #4]	; (c7e4 <port_pin_set_config+0x20>)
    c7de:	4798      	blx	r3
}
    c7e0:	b003      	add	sp, #12
    c7e2:	bd00      	pop	{pc}
    c7e4:	0000da55 	.word	0x0000da55

0000c7e8 <_sercom_get_sync_baud_val>:
 */
enum status_code _sercom_get_sync_baud_val(
		const uint32_t baudrate,
		const uint32_t external_clock,
		uint16_t *const baudvalue)
{
    c7e8:	b510      	push	{r4, lr}
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
    c7ea:	0849      	lsrs	r1, r1, #1
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    c7ec:	2340      	movs	r3, #64	; 0x40
    c7ee:	2400      	movs	r4, #0
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
    c7f0:	4281      	cmp	r1, r0
    c7f2:	d201      	bcs.n	c7f8 <_sercom_get_sync_baud_val+0x10>
    c7f4:	e00a      	b.n	c80c <_sercom_get_sync_baud_val+0x24>

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
		clock_value = clock_value - baudrate;
		baud_calculated++;
    c7f6:	001c      	movs	r4, r3
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
		clock_value = clock_value - baudrate;
    c7f8:	1a09      	subs	r1, r1, r0
		baud_calculated++;
    c7fa:	1c63      	adds	r3, r4, #1
    c7fc:	b29b      	uxth	r3, r3
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
    c7fe:	4288      	cmp	r0, r1
    c800:	d9f9      	bls.n	c7f6 <_sercom_get_sync_baud_val+0xe>

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    c802:	2340      	movs	r3, #64	; 0x40
	}
	baud_calculated = baud_calculated - 1;

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
    c804:	2cff      	cmp	r4, #255	; 0xff
    c806:	d801      	bhi.n	c80c <_sercom_get_sync_baud_val+0x24>
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		*baudvalue = baud_calculated;
    c808:	8014      	strh	r4, [r2, #0]
		return STATUS_OK;
    c80a:	2300      	movs	r3, #0
	}
}
    c80c:	0018      	movs	r0, r3
    c80e:	bd10      	pop	{r4, pc}

0000c810 <_sercom_get_async_baud_val>:
		const uint32_t baudrate,
		const uint32_t peripheral_clock,
		uint16_t *const baudval,
		enum sercom_asynchronous_operation_mode mode,
		enum sercom_asynchronous_sample_num sample_num)
{
    c810:	b5f0      	push	{r4, r5, r6, r7, lr}
    c812:	465f      	mov	r7, fp
    c814:	4656      	mov	r6, sl
    c816:	464d      	mov	r5, r9
    c818:	4644      	mov	r4, r8
    c81a:	b4f0      	push	{r4, r5, r6, r7}
    c81c:	b089      	sub	sp, #36	; 0x24
    c81e:	000c      	movs	r4, r1
    c820:	9205      	str	r2, [sp, #20]
    c822:	aa12      	add	r2, sp, #72	; 0x48
    c824:	7811      	ldrb	r1, [r2, #0]
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
    c826:	0002      	movs	r2, r0
    c828:	434a      	muls	r2, r1
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    c82a:	2540      	movs	r5, #64	; 0x40
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
    c82c:	42a2      	cmp	r2, r4
    c82e:	d900      	bls.n	c832 <_sercom_get_async_baud_val+0x22>
    c830:	e0c6      	b.n	c9c0 <_sercom_get_async_baud_val+0x1b0>
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
    c832:	2b00      	cmp	r3, #0
    c834:	d151      	bne.n	c8da <_sercom_get_async_baud_val+0xca>
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
    c836:	0002      	movs	r2, r0
    c838:	0008      	movs	r0, r1
    c83a:	2100      	movs	r1, #0
    c83c:	4d64      	ldr	r5, [pc, #400]	; (c9d0 <_sercom_get_async_baud_val+0x1c0>)
    c83e:	47a8      	blx	r5
    c840:	4683      	mov	fp, r0
		ratio = long_division(temp1, peripheral_clock);
    c842:	0026      	movs	r6, r4
    c844:	2700      	movs	r7, #0
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
    c846:	2300      	movs	r3, #0
    c848:	2400      	movs	r4, #0
    c84a:	9300      	str	r3, [sp, #0]
    c84c:	9401      	str	r4, [sp, #4]
    c84e:	2200      	movs	r2, #0
    c850:	2300      	movs	r3, #0
	for (i = 63; i >= 0; i--) {
    c852:	203f      	movs	r0, #63	; 0x3f
		bit_shift = (uint64_t)1 << i;
    c854:	2120      	movs	r1, #32
    c856:	468c      	mov	ip, r1
    c858:	391f      	subs	r1, #31
    c85a:	9602      	str	r6, [sp, #8]
    c85c:	9703      	str	r7, [sp, #12]
    c85e:	2420      	movs	r4, #32
    c860:	4264      	negs	r4, r4
    c862:	1904      	adds	r4, r0, r4
    c864:	d403      	bmi.n	c86e <_sercom_get_async_baud_val+0x5e>
    c866:	000d      	movs	r5, r1
    c868:	40a5      	lsls	r5, r4
    c86a:	46a8      	mov	r8, r5
    c86c:	e004      	b.n	c878 <_sercom_get_async_baud_val+0x68>
    c86e:	4664      	mov	r4, ip
    c870:	1a24      	subs	r4, r4, r0
    c872:	000d      	movs	r5, r1
    c874:	40e5      	lsrs	r5, r4
    c876:	46a8      	mov	r8, r5
    c878:	000c      	movs	r4, r1
    c87a:	4084      	lsls	r4, r0
    c87c:	46a1      	mov	r9, r4

		r = r << 1;
    c87e:	0014      	movs	r4, r2
    c880:	001d      	movs	r5, r3
    c882:	18a4      	adds	r4, r4, r2
    c884:	415d      	adcs	r5, r3
    c886:	0022      	movs	r2, r4
    c888:	002b      	movs	r3, r5

		if (n & bit_shift) {
    c88a:	4646      	mov	r6, r8
    c88c:	465f      	mov	r7, fp
    c88e:	423e      	tst	r6, r7
    c890:	d003      	beq.n	c89a <_sercom_get_async_baud_val+0x8a>
			r |= 0x01;
    c892:	000e      	movs	r6, r1
    c894:	4326      	orrs	r6, r4
    c896:	0032      	movs	r2, r6
    c898:	002b      	movs	r3, r5
		}

		if (r >= d) {
    c89a:	9c02      	ldr	r4, [sp, #8]
    c89c:	9d03      	ldr	r5, [sp, #12]
    c89e:	429d      	cmp	r5, r3
    c8a0:	d80f      	bhi.n	c8c2 <_sercom_get_async_baud_val+0xb2>
    c8a2:	d101      	bne.n	c8a8 <_sercom_get_async_baud_val+0x98>
    c8a4:	4294      	cmp	r4, r2
    c8a6:	d80c      	bhi.n	c8c2 <_sercom_get_async_baud_val+0xb2>
			r = r - d;
    c8a8:	9c02      	ldr	r4, [sp, #8]
    c8aa:	9d03      	ldr	r5, [sp, #12]
    c8ac:	1b12      	subs	r2, r2, r4
    c8ae:	41ab      	sbcs	r3, r5
			q |= bit_shift;
    c8b0:	464d      	mov	r5, r9
    c8b2:	9e00      	ldr	r6, [sp, #0]
    c8b4:	9f01      	ldr	r7, [sp, #4]
    c8b6:	4335      	orrs	r5, r6
    c8b8:	003c      	movs	r4, r7
    c8ba:	4646      	mov	r6, r8
    c8bc:	4334      	orrs	r4, r6
    c8be:	9500      	str	r5, [sp, #0]
    c8c0:	9401      	str	r4, [sp, #4]
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
    c8c2:	3801      	subs	r0, #1
    c8c4:	d2cb      	bcs.n	c85e <_sercom_get_async_baud_val+0x4e>
	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
    c8c6:	2200      	movs	r2, #0
    c8c8:	2301      	movs	r3, #1
    c8ca:	9800      	ldr	r0, [sp, #0]
    c8cc:	9901      	ldr	r1, [sp, #4]
    c8ce:	1a12      	subs	r2, r2, r0
    c8d0:	418b      	sbcs	r3, r1
    c8d2:	0c12      	lsrs	r2, r2, #16
    c8d4:	041b      	lsls	r3, r3, #16
    c8d6:	431a      	orrs	r2, r3
    c8d8:	e06f      	b.n	c9ba <_sercom_get_async_baud_val+0x1aa>
		enum sercom_asynchronous_sample_num sample_num)
{
	/* Temporary variables  */
	uint64_t ratio = 0;
	uint64_t scale = 0;
	uint64_t baud_calculated = 0;
    c8da:	2200      	movs	r2, #0
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
    c8dc:	2b01      	cmp	r3, #1
    c8de:	d16c      	bne.n	c9ba <_sercom_get_async_baud_val+0x1aa>
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
    c8e0:	0f63      	lsrs	r3, r4, #29
    c8e2:	9304      	str	r3, [sp, #16]
    c8e4:	00e3      	lsls	r3, r4, #3
    c8e6:	4698      	mov	r8, r3
			temp2 = ((uint64_t)baudrate * sample_num);
    c8e8:	000a      	movs	r2, r1
    c8ea:	2300      	movs	r3, #0
    c8ec:	2100      	movs	r1, #0
    c8ee:	4c38      	ldr	r4, [pc, #224]	; (c9d0 <_sercom_get_async_baud_val+0x1c0>)
    c8f0:	47a0      	blx	r4
    c8f2:	0004      	movs	r4, r0
    c8f4:	000d      	movs	r5, r1
    c8f6:	2300      	movs	r3, #0
    c8f8:	469c      	mov	ip, r3
    c8fa:	9306      	str	r3, [sp, #24]
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;
    c8fc:	3320      	adds	r3, #32
    c8fe:	469b      	mov	fp, r3
    c900:	2601      	movs	r6, #1
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
			baud_int = baud_int / BAUD_FP_MAX;
			if(baud_int < BAUD_INT_MAX) {
    c902:	4663      	mov	r3, ip
    c904:	9307      	str	r3, [sp, #28]
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
    c906:	2300      	movs	r3, #0
    c908:	9302      	str	r3, [sp, #8]
    c90a:	2200      	movs	r2, #0
    c90c:	2300      	movs	r3, #0
	for (i = 63; i >= 0; i--) {
    c90e:	213f      	movs	r1, #63	; 0x3f
    c910:	9400      	str	r4, [sp, #0]
    c912:	9501      	str	r5, [sp, #4]
    c914:	000f      	movs	r7, r1
		bit_shift = (uint64_t)1 << i;
    c916:	2120      	movs	r1, #32
    c918:	4249      	negs	r1, r1
    c91a:	1879      	adds	r1, r7, r1
    c91c:	d403      	bmi.n	c926 <_sercom_get_async_baud_val+0x116>
    c91e:	0030      	movs	r0, r6
    c920:	4088      	lsls	r0, r1
    c922:	4684      	mov	ip, r0
    c924:	e004      	b.n	c930 <_sercom_get_async_baud_val+0x120>
    c926:	4659      	mov	r1, fp
    c928:	1bc9      	subs	r1, r1, r7
    c92a:	0030      	movs	r0, r6
    c92c:	40c8      	lsrs	r0, r1
    c92e:	4684      	mov	ip, r0
    c930:	0031      	movs	r1, r6
    c932:	40b9      	lsls	r1, r7
    c934:	4689      	mov	r9, r1

		r = r << 1;
    c936:	0010      	movs	r0, r2
    c938:	0019      	movs	r1, r3
    c93a:	1880      	adds	r0, r0, r2
    c93c:	4159      	adcs	r1, r3
    c93e:	0002      	movs	r2, r0
    c940:	000b      	movs	r3, r1

		if (n & bit_shift) {
    c942:	4644      	mov	r4, r8
    c944:	464d      	mov	r5, r9
    c946:	402c      	ands	r4, r5
    c948:	46a2      	mov	sl, r4
    c94a:	4664      	mov	r4, ip
    c94c:	9d04      	ldr	r5, [sp, #16]
    c94e:	402c      	ands	r4, r5
    c950:	46a4      	mov	ip, r4
    c952:	4654      	mov	r4, sl
    c954:	4665      	mov	r5, ip
    c956:	432c      	orrs	r4, r5
    c958:	d003      	beq.n	c962 <_sercom_get_async_baud_val+0x152>
			r |= 0x01;
    c95a:	0034      	movs	r4, r6
    c95c:	4304      	orrs	r4, r0
    c95e:	0022      	movs	r2, r4
    c960:	000b      	movs	r3, r1
		}

		if (r >= d) {
    c962:	9800      	ldr	r0, [sp, #0]
    c964:	9901      	ldr	r1, [sp, #4]
    c966:	4299      	cmp	r1, r3
    c968:	d80a      	bhi.n	c980 <_sercom_get_async_baud_val+0x170>
    c96a:	d101      	bne.n	c970 <_sercom_get_async_baud_val+0x160>
    c96c:	4290      	cmp	r0, r2
    c96e:	d807      	bhi.n	c980 <_sercom_get_async_baud_val+0x170>
			r = r - d;
    c970:	9800      	ldr	r0, [sp, #0]
    c972:	9901      	ldr	r1, [sp, #4]
    c974:	1a12      	subs	r2, r2, r0
    c976:	418b      	sbcs	r3, r1
			q |= bit_shift;
    c978:	9902      	ldr	r1, [sp, #8]
    c97a:	4648      	mov	r0, r9
    c97c:	4301      	orrs	r1, r0
    c97e:	9102      	str	r1, [sp, #8]
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
    c980:	3f01      	subs	r7, #1
    c982:	d2c8      	bcs.n	c916 <_sercom_get_async_baud_val+0x106>
    c984:	9c00      	ldr	r4, [sp, #0]
    c986:	9d01      	ldr	r5, [sp, #4]
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
    c988:	9902      	ldr	r1, [sp, #8]
    c98a:	9a07      	ldr	r2, [sp, #28]
    c98c:	1a8b      	subs	r3, r1, r2
			baud_int = baud_int / BAUD_FP_MAX;
    c98e:	08db      	lsrs	r3, r3, #3
			if(baud_int < BAUD_INT_MAX) {
    c990:	4910      	ldr	r1, [pc, #64]	; (c9d4 <_sercom_get_async_baud_val+0x1c4>)
    c992:	428b      	cmp	r3, r1
    c994:	d90b      	bls.n	c9ae <_sercom_get_async_baud_val+0x19e>
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
    c996:	9b06      	ldr	r3, [sp, #24]
    c998:	3301      	adds	r3, #1
    c99a:	b2db      	uxtb	r3, r3
    c99c:	0019      	movs	r1, r3
    c99e:	9306      	str	r3, [sp, #24]
    c9a0:	0013      	movs	r3, r2
    c9a2:	3301      	adds	r3, #1
    c9a4:	9307      	str	r3, [sp, #28]
    c9a6:	2908      	cmp	r1, #8
    c9a8:	d1ad      	bne.n	c906 <_sercom_get_async_baud_val+0xf6>
			if(baud_int < BAUD_INT_MAX) {
				break;
			}
		}
		if(baud_fp == BAUD_FP_MAX) {
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    c9aa:	2540      	movs	r5, #64	; 0x40
    c9ac:	e008      	b.n	c9c0 <_sercom_get_async_baud_val+0x1b0>
    c9ae:	2540      	movs	r5, #64	; 0x40
			baud_int = baud_int / BAUD_FP_MAX;
			if(baud_int < BAUD_INT_MAX) {
				break;
			}
		}
		if(baud_fp == BAUD_FP_MAX) {
    c9b0:	9a06      	ldr	r2, [sp, #24]
    c9b2:	2a08      	cmp	r2, #8
    c9b4:	d004      	beq.n	c9c0 <_sercom_get_async_baud_val+0x1b0>
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
		baud_calculated = baud_int | (baud_fp << 13);
    c9b6:	0352      	lsls	r2, r2, #13
    c9b8:	431a      	orrs	r2, r3
	}

	*baudval = baud_calculated;
    c9ba:	9b05      	ldr	r3, [sp, #20]
    c9bc:	801a      	strh	r2, [r3, #0]
	return STATUS_OK;
    c9be:	2500      	movs	r5, #0
}
    c9c0:	0028      	movs	r0, r5
    c9c2:	b009      	add	sp, #36	; 0x24
    c9c4:	bc3c      	pop	{r2, r3, r4, r5}
    c9c6:	4690      	mov	r8, r2
    c9c8:	4699      	mov	r9, r3
    c9ca:	46a2      	mov	sl, r4
    c9cc:	46ab      	mov	fp, r5
    c9ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c9d0:	0000fb95 	.word	0x0000fb95
    c9d4:	00001fff 	.word	0x00001fff

0000c9d8 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
    c9d8:	b510      	push	{r4, lr}
    c9da:	b082      	sub	sp, #8
    c9dc:	0004      	movs	r4, r0
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
    c9de:	4b0e      	ldr	r3, [pc, #56]	; (ca18 <sercom_set_gclk_generator+0x40>)
    c9e0:	781b      	ldrb	r3, [r3, #0]
    c9e2:	2b00      	cmp	r3, #0
    c9e4:	d001      	beq.n	c9ea <sercom_set_gclk_generator+0x12>
    c9e6:	2900      	cmp	r1, #0
    c9e8:	d00d      	beq.n	ca06 <sercom_set_gclk_generator+0x2e>
		/* Create and fill a GCLK configuration structure for the new config */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
		gclk_chan_conf.source_generator = generator_source;
    c9ea:	a901      	add	r1, sp, #4
    c9ec:	700c      	strb	r4, [r1, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
    c9ee:	2011      	movs	r0, #17
    c9f0:	4b0a      	ldr	r3, [pc, #40]	; (ca1c <sercom_set_gclk_generator+0x44>)
    c9f2:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
    c9f4:	2011      	movs	r0, #17
    c9f6:	4b0a      	ldr	r3, [pc, #40]	; (ca20 <sercom_set_gclk_generator+0x48>)
    c9f8:	4798      	blx	r3

		/* Save config */
		_sercom_config.generator_source = generator_source;
    c9fa:	4b07      	ldr	r3, [pc, #28]	; (ca18 <sercom_set_gclk_generator+0x40>)
    c9fc:	705c      	strb	r4, [r3, #1]
		_sercom_config.generator_is_set = true;
    c9fe:	2201      	movs	r2, #1
    ca00:	701a      	strb	r2, [r3, #0]

		return STATUS_OK;
    ca02:	2000      	movs	r0, #0
    ca04:	e006      	b.n	ca14 <sercom_set_gclk_generator+0x3c>
	} else if (generator_source == _sercom_config.generator_source) {
    ca06:	4b04      	ldr	r3, [pc, #16]	; (ca18 <sercom_set_gclk_generator+0x40>)
    ca08:	785b      	ldrb	r3, [r3, #1]
    ca0a:	4283      	cmp	r3, r0
    ca0c:	d001      	beq.n	ca12 <sercom_set_gclk_generator+0x3a>
		/* Return status OK if same config */
		return STATUS_OK;
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
    ca0e:	201d      	movs	r0, #29
    ca10:	e000      	b.n	ca14 <sercom_set_gclk_generator+0x3c>
		_sercom_config.generator_is_set = true;

		return STATUS_OK;
	} else if (generator_source == _sercom_config.generator_source) {
		/* Return status OK if same config */
		return STATUS_OK;
    ca12:	2000      	movs	r0, #0
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
}
    ca14:	b002      	add	sp, #8
    ca16:	bd10      	pop	{r4, pc}
    ca18:	20001948 	.word	0x20001948
    ca1c:	0000d959 	.word	0x0000d959
    ca20:	0000d8e9 	.word	0x0000d8e9

0000ca24 <_sercom_get_default_pad>:
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
    ca24:	4b44      	ldr	r3, [pc, #272]	; (cb38 <_sercom_get_default_pad+0x114>)
    ca26:	4298      	cmp	r0, r3
    ca28:	d034      	beq.n	ca94 <_sercom_get_default_pad+0x70>
    ca2a:	d807      	bhi.n	ca3c <_sercom_get_default_pad+0x18>
    ca2c:	2384      	movs	r3, #132	; 0x84
    ca2e:	05db      	lsls	r3, r3, #23
    ca30:	4298      	cmp	r0, r3
    ca32:	d00d      	beq.n	ca50 <_sercom_get_default_pad+0x2c>
    ca34:	4b41      	ldr	r3, [pc, #260]	; (cb3c <_sercom_get_default_pad+0x118>)
    ca36:	4298      	cmp	r0, r3
    ca38:	d01b      	beq.n	ca72 <_sercom_get_default_pad+0x4e>
    ca3a:	e06f      	b.n	cb1c <_sercom_get_default_pad+0xf8>
    ca3c:	4b40      	ldr	r3, [pc, #256]	; (cb40 <_sercom_get_default_pad+0x11c>)
    ca3e:	4298      	cmp	r0, r3
    ca40:	d04a      	beq.n	cad8 <_sercom_get_default_pad+0xb4>
    ca42:	4b40      	ldr	r3, [pc, #256]	; (cb44 <_sercom_get_default_pad+0x120>)
    ca44:	4298      	cmp	r0, r3
    ca46:	d058      	beq.n	cafa <_sercom_get_default_pad+0xd6>
    ca48:	4b3f      	ldr	r3, [pc, #252]	; (cb48 <_sercom_get_default_pad+0x124>)
    ca4a:	4298      	cmp	r0, r3
    ca4c:	d166      	bne.n	cb1c <_sercom_get_default_pad+0xf8>
    ca4e:	e032      	b.n	cab6 <_sercom_get_default_pad+0x92>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    ca50:	2901      	cmp	r1, #1
    ca52:	d006      	beq.n	ca62 <_sercom_get_default_pad+0x3e>
    ca54:	2900      	cmp	r1, #0
    ca56:	d063      	beq.n	cb20 <_sercom_get_default_pad+0xfc>
    ca58:	2902      	cmp	r1, #2
    ca5a:	d006      	beq.n	ca6a <_sercom_get_default_pad+0x46>
    ca5c:	2903      	cmp	r1, #3
    ca5e:	d006      	beq.n	ca6e <_sercom_get_default_pad+0x4a>
    ca60:	e001      	b.n	ca66 <_sercom_get_default_pad+0x42>
    ca62:	483a      	ldr	r0, [pc, #232]	; (cb4c <_sercom_get_default_pad+0x128>)
    ca64:	e067      	b.n	cb36 <_sercom_get_default_pad+0x112>
	}

	Assert(false);
	return 0;
    ca66:	2000      	movs	r0, #0
    ca68:	e065      	b.n	cb36 <_sercom_get_default_pad+0x112>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    ca6a:	4839      	ldr	r0, [pc, #228]	; (cb50 <_sercom_get_default_pad+0x12c>)
    ca6c:	e063      	b.n	cb36 <_sercom_get_default_pad+0x112>
    ca6e:	4839      	ldr	r0, [pc, #228]	; (cb54 <_sercom_get_default_pad+0x130>)
    ca70:	e061      	b.n	cb36 <_sercom_get_default_pad+0x112>
    ca72:	2901      	cmp	r1, #1
    ca74:	d006      	beq.n	ca84 <_sercom_get_default_pad+0x60>
    ca76:	2900      	cmp	r1, #0
    ca78:	d054      	beq.n	cb24 <_sercom_get_default_pad+0x100>
    ca7a:	2902      	cmp	r1, #2
    ca7c:	d006      	beq.n	ca8c <_sercom_get_default_pad+0x68>
    ca7e:	2903      	cmp	r1, #3
    ca80:	d006      	beq.n	ca90 <_sercom_get_default_pad+0x6c>
    ca82:	e001      	b.n	ca88 <_sercom_get_default_pad+0x64>
    ca84:	4834      	ldr	r0, [pc, #208]	; (cb58 <_sercom_get_default_pad+0x134>)
    ca86:	e056      	b.n	cb36 <_sercom_get_default_pad+0x112>
	}

	Assert(false);
	return 0;
    ca88:	2000      	movs	r0, #0
    ca8a:	e054      	b.n	cb36 <_sercom_get_default_pad+0x112>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    ca8c:	4833      	ldr	r0, [pc, #204]	; (cb5c <_sercom_get_default_pad+0x138>)
    ca8e:	e052      	b.n	cb36 <_sercom_get_default_pad+0x112>
    ca90:	4833      	ldr	r0, [pc, #204]	; (cb60 <_sercom_get_default_pad+0x13c>)
    ca92:	e050      	b.n	cb36 <_sercom_get_default_pad+0x112>
    ca94:	2901      	cmp	r1, #1
    ca96:	d006      	beq.n	caa6 <_sercom_get_default_pad+0x82>
    ca98:	2900      	cmp	r1, #0
    ca9a:	d045      	beq.n	cb28 <_sercom_get_default_pad+0x104>
    ca9c:	2902      	cmp	r1, #2
    ca9e:	d006      	beq.n	caae <_sercom_get_default_pad+0x8a>
    caa0:	2903      	cmp	r1, #3
    caa2:	d006      	beq.n	cab2 <_sercom_get_default_pad+0x8e>
    caa4:	e001      	b.n	caaa <_sercom_get_default_pad+0x86>
    caa6:	482f      	ldr	r0, [pc, #188]	; (cb64 <_sercom_get_default_pad+0x140>)
    caa8:	e045      	b.n	cb36 <_sercom_get_default_pad+0x112>
	}

	Assert(false);
	return 0;
    caaa:	2000      	movs	r0, #0
    caac:	e043      	b.n	cb36 <_sercom_get_default_pad+0x112>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    caae:	482e      	ldr	r0, [pc, #184]	; (cb68 <_sercom_get_default_pad+0x144>)
    cab0:	e041      	b.n	cb36 <_sercom_get_default_pad+0x112>
    cab2:	482e      	ldr	r0, [pc, #184]	; (cb6c <_sercom_get_default_pad+0x148>)
    cab4:	e03f      	b.n	cb36 <_sercom_get_default_pad+0x112>
    cab6:	2901      	cmp	r1, #1
    cab8:	d006      	beq.n	cac8 <_sercom_get_default_pad+0xa4>
    caba:	2900      	cmp	r1, #0
    cabc:	d036      	beq.n	cb2c <_sercom_get_default_pad+0x108>
    cabe:	2902      	cmp	r1, #2
    cac0:	d006      	beq.n	cad0 <_sercom_get_default_pad+0xac>
    cac2:	2903      	cmp	r1, #3
    cac4:	d006      	beq.n	cad4 <_sercom_get_default_pad+0xb0>
    cac6:	e001      	b.n	cacc <_sercom_get_default_pad+0xa8>
    cac8:	4829      	ldr	r0, [pc, #164]	; (cb70 <_sercom_get_default_pad+0x14c>)
    caca:	e034      	b.n	cb36 <_sercom_get_default_pad+0x112>
	}

	Assert(false);
	return 0;
    cacc:	2000      	movs	r0, #0
    cace:	e032      	b.n	cb36 <_sercom_get_default_pad+0x112>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    cad0:	4828      	ldr	r0, [pc, #160]	; (cb74 <_sercom_get_default_pad+0x150>)
    cad2:	e030      	b.n	cb36 <_sercom_get_default_pad+0x112>
    cad4:	4828      	ldr	r0, [pc, #160]	; (cb78 <_sercom_get_default_pad+0x154>)
    cad6:	e02e      	b.n	cb36 <_sercom_get_default_pad+0x112>
    cad8:	2901      	cmp	r1, #1
    cada:	d006      	beq.n	caea <_sercom_get_default_pad+0xc6>
    cadc:	2900      	cmp	r1, #0
    cade:	d027      	beq.n	cb30 <_sercom_get_default_pad+0x10c>
    cae0:	2902      	cmp	r1, #2
    cae2:	d006      	beq.n	caf2 <_sercom_get_default_pad+0xce>
    cae4:	2903      	cmp	r1, #3
    cae6:	d006      	beq.n	caf6 <_sercom_get_default_pad+0xd2>
    cae8:	e001      	b.n	caee <_sercom_get_default_pad+0xca>
    caea:	4824      	ldr	r0, [pc, #144]	; (cb7c <_sercom_get_default_pad+0x158>)
    caec:	e023      	b.n	cb36 <_sercom_get_default_pad+0x112>
	}

	Assert(false);
	return 0;
    caee:	2000      	movs	r0, #0
    caf0:	e021      	b.n	cb36 <_sercom_get_default_pad+0x112>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    caf2:	4823      	ldr	r0, [pc, #140]	; (cb80 <_sercom_get_default_pad+0x15c>)
    caf4:	e01f      	b.n	cb36 <_sercom_get_default_pad+0x112>
    caf6:	4823      	ldr	r0, [pc, #140]	; (cb84 <_sercom_get_default_pad+0x160>)
    caf8:	e01d      	b.n	cb36 <_sercom_get_default_pad+0x112>
    cafa:	2901      	cmp	r1, #1
    cafc:	d006      	beq.n	cb0c <_sercom_get_default_pad+0xe8>
    cafe:	2900      	cmp	r1, #0
    cb00:	d018      	beq.n	cb34 <_sercom_get_default_pad+0x110>
    cb02:	2902      	cmp	r1, #2
    cb04:	d006      	beq.n	cb14 <_sercom_get_default_pad+0xf0>
    cb06:	2903      	cmp	r1, #3
    cb08:	d006      	beq.n	cb18 <_sercom_get_default_pad+0xf4>
    cb0a:	e001      	b.n	cb10 <_sercom_get_default_pad+0xec>
    cb0c:	481e      	ldr	r0, [pc, #120]	; (cb88 <_sercom_get_default_pad+0x164>)
    cb0e:	e012      	b.n	cb36 <_sercom_get_default_pad+0x112>
	}

	Assert(false);
	return 0;
    cb10:	2000      	movs	r0, #0
    cb12:	e010      	b.n	cb36 <_sercom_get_default_pad+0x112>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    cb14:	481d      	ldr	r0, [pc, #116]	; (cb8c <_sercom_get_default_pad+0x168>)
    cb16:	e00e      	b.n	cb36 <_sercom_get_default_pad+0x112>
    cb18:	481d      	ldr	r0, [pc, #116]	; (cb90 <_sercom_get_default_pad+0x16c>)
    cb1a:	e00c      	b.n	cb36 <_sercom_get_default_pad+0x112>
	}

	Assert(false);
	return 0;
    cb1c:	2000      	movs	r0, #0
    cb1e:	e00a      	b.n	cb36 <_sercom_get_default_pad+0x112>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    cb20:	481c      	ldr	r0, [pc, #112]	; (cb94 <_sercom_get_default_pad+0x170>)
    cb22:	e008      	b.n	cb36 <_sercom_get_default_pad+0x112>
    cb24:	2003      	movs	r0, #3
    cb26:	e006      	b.n	cb36 <_sercom_get_default_pad+0x112>
    cb28:	481b      	ldr	r0, [pc, #108]	; (cb98 <_sercom_get_default_pad+0x174>)
    cb2a:	e004      	b.n	cb36 <_sercom_get_default_pad+0x112>
    cb2c:	481b      	ldr	r0, [pc, #108]	; (cb9c <_sercom_get_default_pad+0x178>)
    cb2e:	e002      	b.n	cb36 <_sercom_get_default_pad+0x112>
    cb30:	481b      	ldr	r0, [pc, #108]	; (cba0 <_sercom_get_default_pad+0x17c>)
    cb32:	e000      	b.n	cb36 <_sercom_get_default_pad+0x112>
    cb34:	481b      	ldr	r0, [pc, #108]	; (cba4 <_sercom_get_default_pad+0x180>)
	}

	Assert(false);
	return 0;
}
    cb36:	4770      	bx	lr
    cb38:	42000800 	.word	0x42000800
    cb3c:	42000400 	.word	0x42000400
    cb40:	42001000 	.word	0x42001000
    cb44:	43000400 	.word	0x43000400
    cb48:	42000c00 	.word	0x42000c00
    cb4c:	00050003 	.word	0x00050003
    cb50:	00060003 	.word	0x00060003
    cb54:	00070003 	.word	0x00070003
    cb58:	00010003 	.word	0x00010003
    cb5c:	001e0003 	.word	0x001e0003
    cb60:	001f0003 	.word	0x001f0003
    cb64:	00090003 	.word	0x00090003
    cb68:	000a0003 	.word	0x000a0003
    cb6c:	000b0003 	.word	0x000b0003
    cb70:	00110003 	.word	0x00110003
    cb74:	00120003 	.word	0x00120003
    cb78:	00130003 	.word	0x00130003
    cb7c:	000d0003 	.word	0x000d0003
    cb80:	000e0003 	.word	0x000e0003
    cb84:	000f0003 	.word	0x000f0003
    cb88:	00170003 	.word	0x00170003
    cb8c:	00180003 	.word	0x00180003
    cb90:	00190003 	.word	0x00190003
    cb94:	00040003 	.word	0x00040003
    cb98:	00080003 	.word	0x00080003
    cb9c:	00100003 	.word	0x00100003
    cba0:	000c0003 	.word	0x000c0003
    cba4:	00160003 	.word	0x00160003

0000cba8 <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
    cba8:	b530      	push	{r4, r5, lr}
    cbaa:	b087      	sub	sp, #28
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
    cbac:	4b0c      	ldr	r3, [pc, #48]	; (cbe0 <_sercom_get_sercom_inst_index+0x38>)
    cbae:	466a      	mov	r2, sp
    cbb0:	cb32      	ldmia	r3!, {r1, r4, r5}
    cbb2:	c232      	stmia	r2!, {r1, r4, r5}
    cbb4:	cb32      	ldmia	r3!, {r1, r4, r5}
    cbb6:	c232      	stmia	r2!, {r1, r4, r5}

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
    cbb8:	9b00      	ldr	r3, [sp, #0]
    cbba:	4283      	cmp	r3, r0
    cbbc:	d006      	beq.n	cbcc <_sercom_get_sercom_inst_index+0x24>
    cbbe:	2301      	movs	r3, #1
    cbc0:	009a      	lsls	r2, r3, #2
    cbc2:	4669      	mov	r1, sp
    cbc4:	5852      	ldr	r2, [r2, r1]
    cbc6:	4282      	cmp	r2, r0
    cbc8:	d103      	bne.n	cbd2 <_sercom_get_sercom_inst_index+0x2a>
    cbca:	e000      	b.n	cbce <_sercom_get_sercom_inst_index+0x26>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    cbcc:	2300      	movs	r3, #0
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
			return i;
    cbce:	b2d8      	uxtb	r0, r3
    cbd0:	e003      	b.n	cbda <_sercom_get_sercom_inst_index+0x32>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    cbd2:	3301      	adds	r3, #1
    cbd4:	2b06      	cmp	r3, #6
    cbd6:	d1f3      	bne.n	cbc0 <_sercom_get_sercom_inst_index+0x18>
		}
	}

	/* Invalid data given */
	Assert(false);
	return 0;
    cbd8:	2000      	movs	r0, #0
}
    cbda:	b007      	add	sp, #28
    cbdc:	bd30      	pop	{r4, r5, pc}
    cbde:	46c0      	nop			; (mov r8, r8)
    cbe0:	0001be30 	.word	0x0001be30

0000cbe4 <_sercom_default_handler>:
 */
static void _sercom_default_handler(
		const uint8_t instance)
{
	Assert(false);
}
    cbe4:	4770      	bx	lr
    cbe6:	46c0      	nop			; (mov r8, r8)

0000cbe8 <_sercom_set_handler>:
 * \param[in]  interrupt_handler  Pointer to instance callback handler.
 */
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
    cbe8:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
    cbea:	4b0a      	ldr	r3, [pc, #40]	; (cc14 <_sercom_set_handler+0x2c>)
    cbec:	781b      	ldrb	r3, [r3, #0]
    cbee:	2b00      	cmp	r3, #0
    cbf0:	d10c      	bne.n	cc0c <_sercom_set_handler+0x24>
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    cbf2:	4f09      	ldr	r7, [pc, #36]	; (cc18 <_sercom_set_handler+0x30>)
    cbf4:	4e09      	ldr	r6, [pc, #36]	; (cc1c <_sercom_set_handler+0x34>)
			_sercom_instances[i] = NULL;
    cbf6:	4d0a      	ldr	r5, [pc, #40]	; (cc20 <_sercom_set_handler+0x38>)
    cbf8:	2400      	movs	r4, #0
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    cbfa:	51de      	str	r6, [r3, r7]
			_sercom_instances[i] = NULL;
    cbfc:	195a      	adds	r2, r3, r5
    cbfe:	6014      	str	r4, [r2, #0]
    cc00:	3304      	adds	r3, #4
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    cc02:	2b18      	cmp	r3, #24
    cc04:	d1f9      	bne.n	cbfa <_sercom_set_handler+0x12>
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
			_sercom_instances[i] = NULL;
		}

		_handler_table_initialized = true;
    cc06:	2201      	movs	r2, #1
    cc08:	4b02      	ldr	r3, [pc, #8]	; (cc14 <_sercom_set_handler+0x2c>)
    cc0a:	701a      	strb	r2, [r3, #0]
	}

	/* Save interrupt handler */
	_sercom_interrupt_handlers[instance] = interrupt_handler;
    cc0c:	0080      	lsls	r0, r0, #2
    cc0e:	4b02      	ldr	r3, [pc, #8]	; (cc18 <_sercom_set_handler+0x30>)
    cc10:	50c1      	str	r1, [r0, r3]
}
    cc12:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cc14:	2000194a 	.word	0x2000194a
    cc18:	2000194c 	.word	0x2000194c
    cc1c:	0000cbe5 	.word	0x0000cbe5
    cc20:	20002850 	.word	0x20002850

0000cc24 <_sercom_get_interrupt_vector>:
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM6
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM7
 */
enum system_interrupt_vector _sercom_get_interrupt_vector(
		Sercom *const sercom_instance)
{
    cc24:	b510      	push	{r4, lr}
    cc26:	b082      	sub	sp, #8
    cc28:	0004      	movs	r4, r0
	const uint8_t sercom_int_vectors[SERCOM_INST_NUM] =
    cc2a:	2206      	movs	r2, #6
    cc2c:	4905      	ldr	r1, [pc, #20]	; (cc44 <_sercom_get_interrupt_vector+0x20>)
    cc2e:	4668      	mov	r0, sp
    cc30:	4b05      	ldr	r3, [pc, #20]	; (cc48 <_sercom_get_interrupt_vector+0x24>)
    cc32:	4798      	blx	r3
		{
			MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_VECT_NUM, ~)
		};

	/* Retrieve the index of the SERCOM being requested */
	uint8_t instance_index = _sercom_get_sercom_inst_index(sercom_instance);
    cc34:	0020      	movs	r0, r4
    cc36:	4b05      	ldr	r3, [pc, #20]	; (cc4c <_sercom_get_interrupt_vector+0x28>)
    cc38:	4798      	blx	r3

	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
    cc3a:	466b      	mov	r3, sp
    cc3c:	5618      	ldrsb	r0, [r3, r0]
}
    cc3e:	b002      	add	sp, #8
    cc40:	bd10      	pop	{r4, pc}
    cc42:	46c0      	nop			; (mov r8, r8)
    cc44:	0001be48 	.word	0x0001be48
    cc48:	00011833 	.word	0x00011833
    cc4c:	0000cba9 	.word	0x0000cba9

0000cc50 <SERCOM0_Handler>:

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
    cc50:	b510      	push	{r4, lr}
    cc52:	4b02      	ldr	r3, [pc, #8]	; (cc5c <SERCOM0_Handler+0xc>)
    cc54:	681b      	ldr	r3, [r3, #0]
    cc56:	2000      	movs	r0, #0
    cc58:	4798      	blx	r3
    cc5a:	bd10      	pop	{r4, pc}
    cc5c:	2000194c 	.word	0x2000194c

0000cc60 <SERCOM1_Handler>:
    cc60:	b510      	push	{r4, lr}
    cc62:	4b02      	ldr	r3, [pc, #8]	; (cc6c <SERCOM1_Handler+0xc>)
    cc64:	685b      	ldr	r3, [r3, #4]
    cc66:	2001      	movs	r0, #1
    cc68:	4798      	blx	r3
    cc6a:	bd10      	pop	{r4, pc}
    cc6c:	2000194c 	.word	0x2000194c

0000cc70 <SERCOM2_Handler>:
    cc70:	b510      	push	{r4, lr}
    cc72:	4b02      	ldr	r3, [pc, #8]	; (cc7c <SERCOM2_Handler+0xc>)
    cc74:	689b      	ldr	r3, [r3, #8]
    cc76:	2002      	movs	r0, #2
    cc78:	4798      	blx	r3
    cc7a:	bd10      	pop	{r4, pc}
    cc7c:	2000194c 	.word	0x2000194c

0000cc80 <SERCOM3_Handler>:
    cc80:	b510      	push	{r4, lr}
    cc82:	4b02      	ldr	r3, [pc, #8]	; (cc8c <SERCOM3_Handler+0xc>)
    cc84:	68db      	ldr	r3, [r3, #12]
    cc86:	2003      	movs	r0, #3
    cc88:	4798      	blx	r3
    cc8a:	bd10      	pop	{r4, pc}
    cc8c:	2000194c 	.word	0x2000194c

0000cc90 <SERCOM4_Handler>:
    cc90:	b510      	push	{r4, lr}
    cc92:	4b02      	ldr	r3, [pc, #8]	; (cc9c <SERCOM4_Handler+0xc>)
    cc94:	691b      	ldr	r3, [r3, #16]
    cc96:	2004      	movs	r0, #4
    cc98:	4798      	blx	r3
    cc9a:	bd10      	pop	{r4, pc}
    cc9c:	2000194c 	.word	0x2000194c

0000cca0 <SERCOM5_Handler>:
    cca0:	b510      	push	{r4, lr}
    cca2:	4b02      	ldr	r3, [pc, #8]	; (ccac <SERCOM5_Handler+0xc>)
    cca4:	695b      	ldr	r3, [r3, #20]
    cca6:	2005      	movs	r0, #5
    cca8:	4798      	blx	r3
    ccaa:	bd10      	pop	{r4, pc}
    ccac:	2000194c 	.word	0x2000194c

0000ccb0 <usart_init>:
 */
enum status_code usart_init(
		struct usart_module *const module,
		Sercom *const hw,
		const struct usart_config *const config)
{
    ccb0:	b5f0      	push	{r4, r5, r6, r7, lr}
    ccb2:	465f      	mov	r7, fp
    ccb4:	4656      	mov	r6, sl
    ccb6:	464d      	mov	r5, r9
    ccb8:	4644      	mov	r4, r8
    ccba:	b4f0      	push	{r4, r5, r6, r7}
    ccbc:	b091      	sub	sp, #68	; 0x44
    ccbe:	0005      	movs	r5, r0
    ccc0:	000c      	movs	r4, r1
    ccc2:	0016      	movs	r6, r2
	Assert(config);

	enum status_code status_code = STATUS_OK;

	/* Assign module pointer to software instance struct */
	module->hw = hw;
    ccc4:	6029      	str	r1, [r5, #0]

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    ccc6:	0008      	movs	r0, r1
    ccc8:	4bc4      	ldr	r3, [pc, #784]	; (cfdc <usart_init+0x32c>)
    ccca:	4798      	blx	r3
    cccc:	1e02      	subs	r2, r0, #0
	uint32_t pm_index, gclk_index; 
#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
#if (SAML21)
	if (sercom_index == 5) {
    ccce:	2a05      	cmp	r2, #5
    ccd0:	d003      	beq.n	ccda <usart_init+0x2a>
		pm_index     = MCLK_APBDMASK_SERCOM5_Pos;
		gclk_index   = SERCOM5_GCLK_ID_CORE;
	} else {
		pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
		gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    ccd2:	0007      	movs	r7, r0
    ccd4:	3712      	adds	r7, #18
#if (SAML21)
	if (sercom_index == 5) {
		pm_index     = MCLK_APBDMASK_SERCOM5_Pos;
		gclk_index   = SERCOM5_GCLK_ID_CORE;
	} else {
		pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
    ccd6:	0003      	movs	r3, r0
    ccd8:	e001      	b.n	ccde <usart_init+0x2e>
	uint32_t pm_index, gclk_index; 
#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
#if (SAML21)
	if (sercom_index == 5) {
		pm_index     = MCLK_APBDMASK_SERCOM5_Pos;
		gclk_index   = SERCOM5_GCLK_ID_CORE;
    ccda:	2718      	movs	r7, #24
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
	uint32_t pm_index, gclk_index; 
#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
#if (SAML21)
	if (sercom_index == 5) {
		pm_index     = MCLK_APBDMASK_SERCOM5_Pos;
    ccdc:	2301      	movs	r3, #1
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    ccde:	6821      	ldr	r1, [r4, #0]
		/* The module is busy resetting itself */
		return STATUS_BUSY;
    cce0:	2005      	movs	r0, #5
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    cce2:	07c9      	lsls	r1, r1, #31
    cce4:	d500      	bpl.n	cce8 <usart_init+0x38>
    cce6:	e171      	b.n	cfcc <usart_init+0x31c>
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    cce8:	6821      	ldr	r1, [r4, #0]
		/* Check the module is enabled */
		return STATUS_ERR_DENIED;
    ccea:	3017      	adds	r0, #23
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    ccec:	0789      	lsls	r1, r1, #30
    ccee:	d500      	bpl.n	ccf2 <usart_init+0x42>
    ccf0:	e16c      	b.n	cfcc <usart_init+0x31c>
		return STATUS_ERR_DENIED;
	}

	/* Turn on module in PM */
#if (SAML21)
	if (sercom_index == 5) {
    ccf2:	2a05      	cmp	r2, #5
    ccf4:	d107      	bne.n	cd06 <usart_init+0x56>

		case SYSTEM_CLOCK_APB_APBC:
			MCLK->APBCMASK.reg |= mask;
			break;
		case SYSTEM_CLOCK_APB_APBD:
			MCLK->APBDMASK.reg |= mask;
    ccf6:	48ba      	ldr	r0, [pc, #744]	; (cfe0 <usart_init+0x330>)
    ccf8:	6a02      	ldr	r2, [r0, #32]
    ccfa:	2101      	movs	r1, #1
    ccfc:	4099      	lsls	r1, r3
    ccfe:	000b      	movs	r3, r1
    cd00:	4313      	orrs	r3, r2
    cd02:	6203      	str	r3, [r0, #32]
    cd04:	e006      	b.n	cd14 <usart_init+0x64>
		case SYSTEM_CLOCK_APB_APBB:
			MCLK->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			MCLK->APBCMASK.reg |= mask;
    cd06:	48b6      	ldr	r0, [pc, #728]	; (cfe0 <usart_init+0x330>)
    cd08:	69c2      	ldr	r2, [r0, #28]
    cd0a:	2101      	movs	r1, #1
    cd0c:	4099      	lsls	r1, r3
    cd0e:	000b      	movs	r3, r1
    cd10:	4313      	orrs	r3, r2
    cd12:	61c3      	str	r3, [r0, #28]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    cd14:	a90f      	add	r1, sp, #60	; 0x3c
    cd16:	232d      	movs	r3, #45	; 0x2d
    cd18:	4698      	mov	r8, r3
    cd1a:	5cf3      	ldrb	r3, [r6, r3]
    cd1c:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    cd1e:	b2ff      	uxtb	r7, r7
    cd20:	0038      	movs	r0, r7
    cd22:	4bb0      	ldr	r3, [pc, #704]	; (cfe4 <usart_init+0x334>)
    cd24:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    cd26:	0038      	movs	r0, r7
    cd28:	4baf      	ldr	r3, [pc, #700]	; (cfe8 <usart_init+0x338>)
    cd2a:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    cd2c:	4643      	mov	r3, r8
    cd2e:	5cf0      	ldrb	r0, [r6, r3]
    cd30:	2100      	movs	r1, #0
    cd32:	4bae      	ldr	r3, [pc, #696]	; (cfec <usart_init+0x33c>)
    cd34:	4798      	blx	r3

	/* Set character size */
	module->character_size = config->character_size;
    cd36:	7af3      	ldrb	r3, [r6, #11]
    cd38:	716b      	strb	r3, [r5, #5]

	/* Set transmitter and receiver status */
	module->receiver_enabled = config->receiver_enable;
    cd3a:	2324      	movs	r3, #36	; 0x24
    cd3c:	5cf3      	ldrb	r3, [r6, r3]
    cd3e:	71ab      	strb	r3, [r5, #6]
	module->transmitter_enabled = config->transmitter_enable;
    cd40:	2325      	movs	r3, #37	; 0x25
    cd42:	5cf3      	ldrb	r3, [r6, r3]
    cd44:	71eb      	strb	r3, [r5, #7]

#ifdef FEATURE_USART_LIN_SLAVE
	module->lin_slave_enabled = config->lin_slave_enable;
    cd46:	7ef3      	ldrb	r3, [r6, #27]
    cd48:	722b      	strb	r3, [r5, #8]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	module->start_frame_detection_enabled = config->start_frame_detection_enable;
    cd4a:	7f33      	ldrb	r3, [r6, #28]
    cd4c:	726b      	strb	r3, [r5, #9]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    cd4e:	682b      	ldr	r3, [r5, #0]
    cd50:	4699      	mov	r9, r3

	/* Index for generic clock */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    cd52:	0018      	movs	r0, r3
    cd54:	4ba1      	ldr	r3, [pc, #644]	; (cfdc <usart_init+0x32c>)
    cd56:	4798      	blx	r3
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    cd58:	3012      	adds	r0, #18
	uint32_t ctrla = 0;
	uint32_t ctrlb = 0;
#ifdef FEATURE_USART_ISO7816
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
    cd5a:	2200      	movs	r2, #0
    cd5c:	230e      	movs	r3, #14
    cd5e:	a906      	add	r1, sp, #24
    cd60:	468c      	mov	ip, r1
    cd62:	4463      	add	r3, ip
    cd64:	801a      	strh	r2, [r3, #0]

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;

#ifdef FEATURE_USART_OVER_SAMPLE
	switch (config->sample_rate) {
    cd66:	8a32      	ldrh	r2, [r6, #16]
    cd68:	9202      	str	r2, [sp, #8]
    cd6a:	2380      	movs	r3, #128	; 0x80
    cd6c:	01db      	lsls	r3, r3, #7
    cd6e:	429a      	cmp	r2, r3
    cd70:	d01a      	beq.n	cda8 <usart_init+0xf8>
    cd72:	d804      	bhi.n	cd7e <usart_init+0xce>
    cd74:	2380      	movs	r3, #128	; 0x80
    cd76:	019b      	lsls	r3, r3, #6
    cd78:	429a      	cmp	r2, r3
    cd7a:	d00b      	beq.n	cd94 <usart_init+0xe4>
    cd7c:	e107      	b.n	cf8e <usart_init+0x2de>
    cd7e:	23c0      	movs	r3, #192	; 0xc0
    cd80:	01db      	lsls	r3, r3, #7
    cd82:	9a02      	ldr	r2, [sp, #8]
    cd84:	429a      	cmp	r2, r3
    cd86:	d00a      	beq.n	cd9e <usart_init+0xee>
    cd88:	2380      	movs	r3, #128	; 0x80
    cd8a:	021b      	lsls	r3, r3, #8
    cd8c:	429a      	cmp	r2, r3
    cd8e:	d100      	bne.n	cd92 <usart_init+0xe2>
    cd90:	e102      	b.n	cf98 <usart_init+0x2e8>
    cd92:	e0fc      	b.n	cf8e <usart_init+0x2de>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
			break;
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    cd94:	2310      	movs	r3, #16
    cd96:	9306      	str	r3, [sp, #24]
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
			break;
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
    cd98:	3b0f      	subs	r3, #15
    cd9a:	9307      	str	r3, [sp, #28]
    cd9c:	e100      	b.n	cfa0 <usart_init+0x2f0>
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    cd9e:	2308      	movs	r3, #8
    cda0:	9306      	str	r3, [sp, #24]
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
    cda2:	3b07      	subs	r3, #7
    cda4:	9307      	str	r3, [sp, #28]
    cda6:	e0fb      	b.n	cfa0 <usart_init+0x2f0>
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
    cda8:	6833      	ldr	r3, [r6, #0]
    cdaa:	9304      	str	r3, [sp, #16]
		(uint32_t)config->mux_setting |
    cdac:	68f3      	ldr	r3, [r6, #12]
    cdae:	469b      	mov	fp, r3
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
    cdb0:	6973      	ldr	r3, [r6, #20]
    cdb2:	9303      	str	r3, [sp, #12]
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    cdb4:	7e33      	ldrb	r3, [r6, #24]
    cdb6:	4698      	mov	r8, r3
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    cdb8:	2326      	movs	r3, #38	; 0x26
    cdba:	5cf3      	ldrb	r3, [r6, r3]
    cdbc:	9305      	str	r3, [sp, #20]

	enum status_code status_code = STATUS_OK;

	transfer_mode = (uint32_t)config->transfer_mode;
    cdbe:	6873      	ldr	r3, [r6, #4]
    cdc0:	469a      	mov	sl, r3
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
    cdc2:	2b00      	cmp	r3, #0
    cdc4:	d016      	beq.n	cdf4 <usart_init+0x144>
    cdc6:	2380      	movs	r3, #128	; 0x80
    cdc8:	055b      	lsls	r3, r3, #21
    cdca:	459a      	cmp	sl, r3
    cdcc:	d139      	bne.n	ce42 <usart_init+0x192>
	{
		case USART_TRANSFER_SYNCHRONOUSLY:
			if (!config->use_external_clock) {
    cdce:	2327      	movs	r3, #39	; 0x27
    cdd0:	5cf3      	ldrb	r3, [r6, r3]
    cdd2:	2b00      	cmp	r3, #0
    cdd4:	d139      	bne.n	ce4a <usart_init+0x19a>
				status_code = _sercom_get_sync_baud_val(config->baudrate,
    cdd6:	6a33      	ldr	r3, [r6, #32]
    cdd8:	001f      	movs	r7, r3
    cdda:	b2c0      	uxtb	r0, r0
    cddc:	4b84      	ldr	r3, [pc, #528]	; (cff0 <usart_init+0x340>)
    cdde:	4798      	blx	r3
    cde0:	0001      	movs	r1, r0
    cde2:	220e      	movs	r2, #14
    cde4:	ab06      	add	r3, sp, #24
    cde6:	469c      	mov	ip, r3
    cde8:	4462      	add	r2, ip
    cdea:	0038      	movs	r0, r7
    cdec:	4b81      	ldr	r3, [pc, #516]	; (cff4 <usart_init+0x344>)
    cdee:	4798      	blx	r3
    cdf0:	0003      	movs	r3, r0
    cdf2:	e027      	b.n	ce44 <usart_init+0x194>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    cdf4:	2308      	movs	r3, #8
    cdf6:	9306      	str	r3, [sp, #24]
		case USART_SAMPLE_RATE_16X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    cdf8:	2300      	movs	r3, #0
    cdfa:	9307      	str	r3, [sp, #28]
			}

			break;

		case USART_TRANSFER_ASYNCHRONOUSLY:
			if (config->use_external_clock) {
    cdfc:	2327      	movs	r3, #39	; 0x27
    cdfe:	5cf3      	ldrb	r3, [r6, r3]
    ce00:	2b00      	cmp	r3, #0
    ce02:	d00c      	beq.n	ce1e <usart_init+0x16e>
				status_code =
    ce04:	9b06      	ldr	r3, [sp, #24]
    ce06:	9300      	str	r3, [sp, #0]
    ce08:	9b07      	ldr	r3, [sp, #28]
    ce0a:	220e      	movs	r2, #14
    ce0c:	a906      	add	r1, sp, #24
    ce0e:	468c      	mov	ip, r1
    ce10:	4462      	add	r2, ip
    ce12:	6ab1      	ldr	r1, [r6, #40]	; 0x28
    ce14:	6a30      	ldr	r0, [r6, #32]
    ce16:	4f78      	ldr	r7, [pc, #480]	; (cff8 <usart_init+0x348>)
    ce18:	47b8      	blx	r7
    ce1a:	0003      	movs	r3, r0
    ce1c:	e012      	b.n	ce44 <usart_init+0x194>
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
    ce1e:	6a33      	ldr	r3, [r6, #32]
    ce20:	001f      	movs	r7, r3
    ce22:	b2c0      	uxtb	r0, r0
    ce24:	4b72      	ldr	r3, [pc, #456]	; (cff0 <usart_init+0x340>)
    ce26:	4798      	blx	r3
    ce28:	0001      	movs	r1, r0
			if (config->use_external_clock) {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
    ce2a:	9b06      	ldr	r3, [sp, #24]
    ce2c:	9300      	str	r3, [sp, #0]
    ce2e:	9b07      	ldr	r3, [sp, #28]
    ce30:	220e      	movs	r2, #14
    ce32:	a806      	add	r0, sp, #24
    ce34:	4684      	mov	ip, r0
    ce36:	4462      	add	r2, ip
    ce38:	0038      	movs	r0, r7
    ce3a:	4f6f      	ldr	r7, [pc, #444]	; (cff8 <usart_init+0x348>)
    ce3c:	47b8      	blx	r7
    ce3e:	0003      	movs	r3, r0
    ce40:	e000      	b.n	ce44 <usart_init+0x194>
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);

	enum status_code status_code = STATUS_OK;
    ce42:	2300      	movs	r3, #0
    ce44:	1e18      	subs	r0, r3, #0

			break;
	}

	/* Check if calculating the baudrate failed */
	if (status_code != STATUS_OK) {
    ce46:	d000      	beq.n	ce4a <usart_init+0x19a>
    ce48:	e0c0      	b.n	cfcc <usart_init+0x31c>
#ifdef FEATURE_USART_ISO7816
	}
#endif

#ifdef FEATURE_USART_IRDA
	if(config->encoding_format_enable) {
    ce4a:	7e73      	ldrb	r3, [r6, #25]
    ce4c:	2b00      	cmp	r3, #0
    ce4e:	d002      	beq.n	ce56 <usart_init+0x1a6>
		usart_hw->RXPL.reg = config->receive_pulse_length;
    ce50:	7eb3      	ldrb	r3, [r6, #26]
    ce52:	464a      	mov	r2, r9
    ce54:	7393      	strb	r3, [r2, #14]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    ce56:	682a      	ldr	r2, [r5, #0]
    ce58:	9f02      	ldr	r7, [sp, #8]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    ce5a:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    ce5c:	2b00      	cmp	r3, #0
    ce5e:	d1fc      	bne.n	ce5a <usart_init+0x1aa>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/*Set baud val */
	usart_hw->BAUD.reg = baud;
    ce60:	330e      	adds	r3, #14
    ce62:	aa06      	add	r2, sp, #24
    ce64:	4694      	mov	ip, r2
    ce66:	4463      	add	r3, ip
    ce68:	881b      	ldrh	r3, [r3, #0]
    ce6a:	464a      	mov	r2, r9
    ce6c:	8193      	strh	r3, [r2, #12]

	/* Set sample mode */
	ctrla |= transfer_mode;
    ce6e:	9b04      	ldr	r3, [sp, #16]
    ce70:	465a      	mov	r2, fp
    ce72:	4313      	orrs	r3, r2
    ce74:	9a03      	ldr	r2, [sp, #12]
    ce76:	4313      	orrs	r3, r2
    ce78:	4652      	mov	r2, sl
    ce7a:	4313      	orrs	r3, r2
    ce7c:	433b      	orrs	r3, r7
    ce7e:	4642      	mov	r2, r8
    ce80:	0212      	lsls	r2, r2, #8
    ce82:	4313      	orrs	r3, r2
    ce84:	9a05      	ldr	r2, [sp, #20]
    ce86:	0757      	lsls	r7, r2, #29
    ce88:	431f      	orrs	r7, r3

	if (config->use_external_clock == false) {
    ce8a:	2327      	movs	r3, #39	; 0x27
    ce8c:	5cf3      	ldrb	r3, [r6, r3]
    ce8e:	2b00      	cmp	r3, #0
    ce90:	d101      	bne.n	ce96 <usart_init+0x1e6>
		ctrla |= SERCOM_USART_CTRLA_MODE(0x1);
    ce92:	3304      	adds	r3, #4
    ce94:	431f      	orrs	r7, r3
	else {
		ctrla |= SERCOM_USART_CTRLA_MODE(0x0);
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
    ce96:	7e71      	ldrb	r1, [r6, #25]
    ce98:	0289      	lsls	r1, r1, #10
    ce9a:	7f33      	ldrb	r3, [r6, #28]
    ce9c:	025b      	lsls	r3, r3, #9
    ce9e:	4319      	orrs	r1, r3
    cea0:	7f73      	ldrb	r3, [r6, #29]
    cea2:	021b      	lsls	r3, r3, #8
    cea4:	4319      	orrs	r1, r3
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
    cea6:	2324      	movs	r3, #36	; 0x24
	else {
		ctrla |= SERCOM_USART_CTRLA_MODE(0x0);
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
    cea8:	5cf3      	ldrb	r3, [r6, r3]
    ceaa:	045b      	lsls	r3, r3, #17
    ceac:	4319      	orrs	r1, r3
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
			(config->transmitter_enable << SERCOM_USART_CTRLB_TXEN_Pos);
    ceae:	2325      	movs	r3, #37	; 0x25
	else {
		ctrla |= SERCOM_USART_CTRLA_MODE(0x0);
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
    ceb0:	5cf2      	ldrb	r2, [r6, r3]
    ceb2:	0412      	lsls	r2, r2, #16
    ceb4:	4311      	orrs	r1, r2
				ctrlb |= USART_STOPBITS_1;
				break;		
		}
	} else {
#endif
	ctrlb |= (uint32_t)config->character_size;
    ceb6:	7af3      	ldrb	r3, [r6, #11]
    ceb8:	4319      	orrs	r1, r3
	/* Check parity mode bits */
	if (config->parity != USART_PARITY_NONE) {
    ceba:	8933      	ldrh	r3, [r6, #8]
    cebc:	2bff      	cmp	r3, #255	; 0xff
    cebe:	d004      	beq.n	ceca <usart_init+0x21a>
		ctrla |= SERCOM_USART_CTRLA_FORM(1);
    cec0:	2280      	movs	r2, #128	; 0x80
    cec2:	0452      	lsls	r2, r2, #17
    cec4:	4317      	orrs	r7, r2
		ctrlb |= config->parity;
    cec6:	4319      	orrs	r1, r3
    cec8:	e005      	b.n	ced6 <usart_init+0x226>
	} else {
#ifdef FEATURE_USART_LIN_SLAVE
		if(config->lin_slave_enable) {
    ceca:	7ef3      	ldrb	r3, [r6, #27]
    cecc:	2b00      	cmp	r3, #0
    cece:	d002      	beq.n	ced6 <usart_init+0x226>
			ctrla |= SERCOM_USART_CTRLA_FORM(0x4);
    ced0:	2380      	movs	r3, #128	; 0x80
    ced2:	04db      	lsls	r3, r3, #19
    ced4:	431f      	orrs	r7, r3
		ctrla |= config->lin_node;
	}
#endif

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    ced6:	232c      	movs	r3, #44	; 0x2c
    ced8:	5cf3      	ldrb	r3, [r6, r3]
    ceda:	2b00      	cmp	r3, #0
    cedc:	d103      	bne.n	cee6 <usart_init+0x236>
    cede:	4b47      	ldr	r3, [pc, #284]	; (cffc <usart_init+0x34c>)
    cee0:	789b      	ldrb	r3, [r3, #2]
    cee2:	079b      	lsls	r3, r3, #30
    cee4:	d501      	bpl.n	ceea <usart_init+0x23a>
		ctrla |= SERCOM_USART_CTRLA_RUNSTDBY;
    cee6:	2380      	movs	r3, #128	; 0x80
    cee8:	431f      	orrs	r7, r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    ceea:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    ceec:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    ceee:	2b00      	cmp	r3, #0
    cef0:	d1fc      	bne.n	ceec <usart_init+0x23c>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLB */
	usart_hw->CTRLB.reg = ctrlb;
    cef2:	464b      	mov	r3, r9
    cef4:	6059      	str	r1, [r3, #4]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    cef6:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    cef8:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    cefa:	2b00      	cmp	r3, #0
    cefc:	d1fc      	bne.n	cef8 <usart_init+0x248>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLA */
	usart_hw->CTRLA.reg = ctrla;
    cefe:	464b      	mov	r3, r9
    cf00:	601f      	str	r7, [r3, #0]
    cf02:	ab0e      	add	r3, sp, #56	; 0x38
    cf04:	2280      	movs	r2, #128	; 0x80
    cf06:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    cf08:	2200      	movs	r2, #0
    cf0a:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    cf0c:	70da      	strb	r2, [r3, #3]
	}

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    cf0e:	709a      	strb	r2, [r3, #2]

	uint32_t pad_pinmuxes[] = {
    cf10:	6b33      	ldr	r3, [r6, #48]	; 0x30
    cf12:	930a      	str	r3, [sp, #40]	; 0x28
    cf14:	6b73      	ldr	r3, [r6, #52]	; 0x34
    cf16:	930b      	str	r3, [sp, #44]	; 0x2c
    cf18:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    cf1a:	930c      	str	r3, [sp, #48]	; 0x30
    cf1c:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
    cf1e:	9302      	str	r3, [sp, #8]
    cf20:	930d      	str	r3, [sp, #52]	; 0x34
    cf22:	2700      	movs	r7, #0
		if (current_pinmux == PINMUX_DEFAULT) {
			current_pinmux = _sercom_get_default_pad(hw, pad);
		}

		if (current_pinmux != PINMUX_UNUSED) {
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    cf24:	ae0e      	add	r6, sp, #56	; 0x38
    cf26:	b2f9      	uxtb	r1, r7
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    cf28:	00bb      	lsls	r3, r7, #2
    cf2a:	aa0a      	add	r2, sp, #40	; 0x28
    cf2c:	5898      	ldr	r0, [r3, r2]

		if (current_pinmux == PINMUX_DEFAULT) {
    cf2e:	2800      	cmp	r0, #0
    cf30:	d102      	bne.n	cf38 <usart_init+0x288>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    cf32:	0020      	movs	r0, r4
    cf34:	4b32      	ldr	r3, [pc, #200]	; (d000 <usart_init+0x350>)
    cf36:	4798      	blx	r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
    cf38:	1c43      	adds	r3, r0, #1
    cf3a:	d005      	beq.n	cf48 <usart_init+0x298>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    cf3c:	7030      	strb	r0, [r6, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    cf3e:	0c00      	lsrs	r0, r0, #16
    cf40:	b2c0      	uxtb	r0, r0
    cf42:	0031      	movs	r1, r6
    cf44:	4b2f      	ldr	r3, [pc, #188]	; (d004 <usart_init+0x354>)
    cf46:	4798      	blx	r3
    cf48:	3701      	adds	r7, #1
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    cf4a:	2f04      	cmp	r7, #4
    cf4c:	d1eb      	bne.n	cf26 <usart_init+0x276>
	}

#if USART_CALLBACK_MODE == true
	/* Initialize parameters */
	for (uint32_t i = 0; i < USART_CALLBACK_N; i++) {
		module->callback[i]            = NULL;
    cf4e:	2300      	movs	r3, #0
    cf50:	60eb      	str	r3, [r5, #12]
    cf52:	612b      	str	r3, [r5, #16]
    cf54:	616b      	str	r3, [r5, #20]
    cf56:	61ab      	str	r3, [r5, #24]
    cf58:	61eb      	str	r3, [r5, #28]
    cf5a:	622b      	str	r3, [r5, #32]
	}

	module->tx_buffer_ptr              = NULL;
    cf5c:	62ab      	str	r3, [r5, #40]	; 0x28
	module->rx_buffer_ptr              = NULL;
    cf5e:	626b      	str	r3, [r5, #36]	; 0x24
	module->remaining_tx_buffer_length = 0x0000;
    cf60:	2200      	movs	r2, #0
    cf62:	85eb      	strh	r3, [r5, #46]	; 0x2e
	module->remaining_rx_buffer_length = 0x0000;
    cf64:	85ab      	strh	r3, [r5, #44]	; 0x2c
	module->callback_reg_mask          = 0x00;
    cf66:	3330      	adds	r3, #48	; 0x30
    cf68:	54ea      	strb	r2, [r5, r3]
	module->callback_enable_mask       = 0x00;
    cf6a:	3301      	adds	r3, #1
    cf6c:	54ea      	strb	r2, [r5, r3]
	module->rx_status                  = STATUS_OK;
    cf6e:	3301      	adds	r3, #1
    cf70:	54ea      	strb	r2, [r5, r3]
	module->tx_status                  = STATUS_OK;
    cf72:	3301      	adds	r3, #1
    cf74:	54ea      	strb	r2, [r5, r3]

	/* Set interrupt handler and register USART software module struct in
	 * look-up table */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
    cf76:	6828      	ldr	r0, [r5, #0]
    cf78:	4b18      	ldr	r3, [pc, #96]	; (cfdc <usart_init+0x32c>)
    cf7a:	4798      	blx	r3
    cf7c:	0004      	movs	r4, r0
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
    cf7e:	4922      	ldr	r1, [pc, #136]	; (d008 <usart_init+0x358>)
    cf80:	4b22      	ldr	r3, [pc, #136]	; (d00c <usart_init+0x35c>)
    cf82:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    cf84:	00a4      	lsls	r4, r4, #2
    cf86:	4b22      	ldr	r3, [pc, #136]	; (d010 <usart_init+0x360>)
    cf88:	50e5      	str	r5, [r4, r3]
#endif

	return status_code;
    cf8a:	2000      	movs	r0, #0
    cf8c:	e01e      	b.n	cfcc <usart_init+0x31c>
#endif
	uint16_t baud  = 0;
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    cf8e:	2310      	movs	r3, #16
    cf90:	9306      	str	r3, [sp, #24]
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    cf92:	2300      	movs	r3, #0
    cf94:	9307      	str	r3, [sp, #28]
    cf96:	e003      	b.n	cfa0 <usart_init+0x2f0>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
			break;
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
    cf98:	2303      	movs	r3, #3
    cf9a:	9306      	str	r3, [sp, #24]
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
			break;
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    cf9c:	2300      	movs	r3, #0
    cf9e:	9307      	str	r3, [sp, #28]
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
    cfa0:	6833      	ldr	r3, [r6, #0]
    cfa2:	9304      	str	r3, [sp, #16]
		(uint32_t)config->mux_setting |
    cfa4:	68f3      	ldr	r3, [r6, #12]
    cfa6:	469b      	mov	fp, r3
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
    cfa8:	6973      	ldr	r3, [r6, #20]
    cfaa:	9303      	str	r3, [sp, #12]
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    cfac:	7e33      	ldrb	r3, [r6, #24]
    cfae:	4698      	mov	r8, r3
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    cfb0:	2326      	movs	r3, #38	; 0x26
    cfb2:	5cf3      	ldrb	r3, [r6, r3]
    cfb4:	9305      	str	r3, [sp, #20]

	enum status_code status_code = STATUS_OK;

	transfer_mode = (uint32_t)config->transfer_mode;
    cfb6:	6873      	ldr	r3, [r6, #4]
    cfb8:	469a      	mov	sl, r3
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
    cfba:	2b00      	cmp	r3, #0
    cfbc:	d100      	bne.n	cfc0 <usart_init+0x310>
    cfbe:	e71d      	b.n	cdfc <usart_init+0x14c>
    cfc0:	2380      	movs	r3, #128	; 0x80
    cfc2:	055b      	lsls	r3, r3, #21
    cfc4:	459a      	cmp	sl, r3
    cfc6:	d100      	bne.n	cfca <usart_init+0x31a>
    cfc8:	e701      	b.n	cdce <usart_init+0x11e>
    cfca:	e73e      	b.n	ce4a <usart_init+0x19a>
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
	_sercom_instances[instance_index] = module;
#endif

	return status_code;
}
    cfcc:	b011      	add	sp, #68	; 0x44
    cfce:	bc3c      	pop	{r2, r3, r4, r5}
    cfd0:	4690      	mov	r8, r2
    cfd2:	4699      	mov	r9, r3
    cfd4:	46a2      	mov	sl, r4
    cfd6:	46ab      	mov	fp, r5
    cfd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cfda:	46c0      	nop			; (mov r8, r8)
    cfdc:	0000cba9 	.word	0x0000cba9
    cfe0:	40000400 	.word	0x40000400
    cfe4:	0000d959 	.word	0x0000d959
    cfe8:	0000d8e9 	.word	0x0000d8e9
    cfec:	0000c9d9 	.word	0x0000c9d9
    cff0:	0000d97d 	.word	0x0000d97d
    cff4:	0000c7e9 	.word	0x0000c7e9
    cff8:	0000c811 	.word	0x0000c811
    cffc:	41002000 	.word	0x41002000
    d000:	0000ca25 	.word	0x0000ca25
    d004:	0000da55 	.word	0x0000da55
    d008:	0000d0b9 	.word	0x0000d0b9
    d00c:	0000cbe9 	.word	0x0000cbe9
    d010:	20002850 	.word	0x20002850

0000d014 <usart_write_wait>:

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
    d014:	79c2      	ldrb	r2, [r0, #7]
		return STATUS_ERR_DENIED;
    d016:	231c      	movs	r3, #28

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
    d018:	2a00      	cmp	r2, #0
    d01a:	d00e      	beq.n	d03a <usart_write_wait+0x26>
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_tx_buffer_length > 0) {
    d01c:	8dc2      	ldrh	r2, [r0, #46]	; 0x2e
    d01e:	b292      	uxth	r2, r2
		return STATUS_BUSY;
    d020:	3b17      	subs	r3, #23
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_tx_buffer_length > 0) {
    d022:	2a00      	cmp	r2, #0
    d024:	d109      	bne.n	d03a <usart_write_wait+0x26>
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    d026:	6803      	ldr	r3, [r0, #0]
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    d028:	69da      	ldr	r2, [r3, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    d02a:	2a00      	cmp	r2, #0
    d02c:	d1fc      	bne.n	d028 <usart_write_wait+0x14>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write data to USART module */
	usart_hw->DATA.reg = tx_data;
    d02e:	8519      	strh	r1, [r3, #40]	; 0x28

	while (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_TXC)) {
    d030:	2102      	movs	r1, #2
    d032:	7e1a      	ldrb	r2, [r3, #24]
    d034:	420a      	tst	r2, r1
    d036:	d0fc      	beq.n	d032 <usart_write_wait+0x1e>
		/* Wait until data is sent */
	}

	return STATUS_OK;
    d038:	2300      	movs	r3, #0
}
    d03a:	0018      	movs	r0, r3
    d03c:	4770      	bx	lr
    d03e:	46c0      	nop			; (mov r8, r8)

0000d040 <usart_read_wait>:

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
    d040:	7982      	ldrb	r2, [r0, #6]
		return STATUS_ERR_DENIED;
    d042:	231c      	movs	r3, #28

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
    d044:	2a00      	cmp	r2, #0
    d046:	d034      	beq.n	d0b2 <usart_read_wait+0x72>
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_rx_buffer_length > 0) {
    d048:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
    d04a:	b292      	uxth	r2, r2
		return STATUS_BUSY;
    d04c:	3b17      	subs	r3, #23
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_rx_buffer_length > 0) {
    d04e:	2a00      	cmp	r2, #0
    d050:	d12f      	bne.n	d0b2 <usart_read_wait+0x72>

	/* Error variable */
	uint8_t error_code;

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    d052:	6802      	ldr	r2, [r0, #0]
		return STATUS_BUSY;
	}
#endif

	/* Check if USART has new data */
	if (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_RXC)) {
    d054:	7e10      	ldrb	r0, [r2, #24]
    d056:	0740      	lsls	r0, r0, #29
    d058:	d52b      	bpl.n	d0b2 <usart_read_wait+0x72>
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    d05a:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    d05c:	2b00      	cmp	r3, #0
    d05e:	d1fc      	bne.n	d05a <usart_read_wait+0x1a>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Read out the status code and mask away all but the 3 LSBs*/
	error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    d060:	8b53      	ldrh	r3, [r2, #26]
    d062:	b2db      	uxtb	r3, r3

	/* Check if an error has occurred during the receiving */
	if (error_code) {
    d064:	0698      	lsls	r0, r3, #26
    d066:	d021      	beq.n	d0ac <usart_read_wait+0x6c>
		/* Check which error occurred */
		if (error_code & SERCOM_USART_STATUS_FERR) {
    d068:	0798      	lsls	r0, r3, #30
    d06a:	d503      	bpl.n	d074 <usart_read_wait+0x34>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_FERR;
    d06c:	2302      	movs	r3, #2
    d06e:	8353      	strh	r3, [r2, #26]

			return STATUS_ERR_BAD_FORMAT;
    d070:	3318      	adds	r3, #24
    d072:	e01e      	b.n	d0b2 <usart_read_wait+0x72>
		} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
    d074:	0758      	lsls	r0, r3, #29
    d076:	d503      	bpl.n	d080 <usart_read_wait+0x40>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_BUFOVF;
    d078:	2304      	movs	r3, #4
    d07a:	8353      	strh	r3, [r2, #26]

			return STATUS_ERR_OVERFLOW;
    d07c:	331a      	adds	r3, #26
    d07e:	e018      	b.n	d0b2 <usart_read_wait+0x72>
		} else if (error_code & SERCOM_USART_STATUS_PERR) {
    d080:	07d8      	lsls	r0, r3, #31
    d082:	d503      	bpl.n	d08c <usart_read_wait+0x4c>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_PERR;
    d084:	2301      	movs	r3, #1
    d086:	8353      	strh	r3, [r2, #26]

			return STATUS_ERR_BAD_DATA;
    d088:	3312      	adds	r3, #18
    d08a:	e012      	b.n	d0b2 <usart_read_wait+0x72>
		}
#ifdef FEATURE_USART_LIN_SLAVE
		else if (error_code & SERCOM_USART_STATUS_ISF) {
    d08c:	06d8      	lsls	r0, r3, #27
    d08e:	d505      	bpl.n	d09c <usart_read_wait+0x5c>
			/* Clear flag by writing 1 to it  and
			 *  return with an error code */
			usart_hw->STATUS.reg |= SERCOM_USART_STATUS_ISF;
    d090:	8b51      	ldrh	r1, [r2, #26]
    d092:	2310      	movs	r3, #16
    d094:	430b      	orrs	r3, r1
    d096:	8353      	strh	r3, [r2, #26]

			return STATUS_ERR_PROTOCOL;
    d098:	2342      	movs	r3, #66	; 0x42
    d09a:	e00a      	b.n	d0b2 <usart_read_wait+0x72>
		}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
		else if (error_code & SERCOM_USART_STATUS_COLL) {
    d09c:	069b      	lsls	r3, r3, #26
    d09e:	d505      	bpl.n	d0ac <usart_read_wait+0x6c>
			/* Clear flag by writing 1 to it
			 *  return with an error code */
			usart_hw->STATUS.reg |= SERCOM_USART_STATUS_COLL;
    d0a0:	8b51      	ldrh	r1, [r2, #26]
    d0a2:	2320      	movs	r3, #32
    d0a4:	430b      	orrs	r3, r1
    d0a6:	8353      	strh	r3, [r2, #26]

			return STATUS_ERR_PACKET_COLLISION;
    d0a8:	2341      	movs	r3, #65	; 0x41
    d0aa:	e002      	b.n	d0b2 <usart_read_wait+0x72>
		}
#endif
	}

	/* Read data from USART module */
	*rx_data = usart_hw->DATA.reg;
    d0ac:	8d13      	ldrh	r3, [r2, #40]	; 0x28
    d0ae:	800b      	strh	r3, [r1, #0]

	return STATUS_OK;
    d0b0:	2300      	movs	r3, #0
}
    d0b2:	0018      	movs	r0, r3
    d0b4:	4770      	bx	lr
    d0b6:	46c0      	nop			; (mov r8, r8)

0000d0b8 <_usart_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _usart_interrupt_handler(
		uint8_t instance)
{
    d0b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint16_t callback_status;
	uint8_t error_code;


	/* Get device instance from the look-up table */
	struct usart_module *module
    d0ba:	0080      	lsls	r0, r0, #2
    d0bc:	4b65      	ldr	r3, [pc, #404]	; (d254 <_usart_interrupt_handler+0x19c>)
    d0be:	58c5      	ldr	r5, [r0, r3]
		= (struct usart_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomUsart *const usart_hw
		= &(module->hw->USART);
    d0c0:	682c      	ldr	r4, [r5, #0]
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    d0c2:	69e3      	ldr	r3, [r4, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    d0c4:	2b00      	cmp	r3, #0
    d0c6:	d1fc      	bne.n	d0c2 <_usart_interrupt_handler+0xa>

	/* Wait for the synchronization to complete */
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
    d0c8:	7e23      	ldrb	r3, [r4, #24]
	interrupt_status &= usart_hw->INTENSET.reg;
    d0ca:	7da6      	ldrb	r6, [r4, #22]
    d0cc:	401e      	ands	r6, r3
	callback_status = module->callback_reg_mask &
    d0ce:	2330      	movs	r3, #48	; 0x30
    d0d0:	5ceb      	ldrb	r3, [r5, r3]
    d0d2:	2231      	movs	r2, #49	; 0x31
    d0d4:	5caf      	ldrb	r7, [r5, r2]
    d0d6:	401f      	ands	r7, r3
			module->callback_enable_mask;

	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
    d0d8:	07f3      	lsls	r3, r6, #31
    d0da:	d522      	bpl.n	d122 <_usart_interrupt_handler+0x6a>
		if (module->remaining_tx_buffer_length) {
    d0dc:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
    d0de:	b29b      	uxth	r3, r3
    d0e0:	2b00      	cmp	r3, #0
    d0e2:	d01c      	beq.n	d11e <_usart_interrupt_handler+0x66>
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    d0e4:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    d0e6:	7813      	ldrb	r3, [r2, #0]
    d0e8:	b2db      	uxtb	r3, r3
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;
    d0ea:	1c51      	adds	r1, r2, #1
    d0ec:	62a9      	str	r1, [r5, #40]	; 0x28

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    d0ee:	7969      	ldrb	r1, [r5, #5]
    d0f0:	2901      	cmp	r1, #1
    d0f2:	d001      	beq.n	d0f8 <_usart_interrupt_handler+0x40>
	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
		if (module->remaining_tx_buffer_length) {
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    d0f4:	b29b      	uxth	r3, r3
    d0f6:	e004      	b.n	d102 <_usart_interrupt_handler+0x4a>
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
    d0f8:	7851      	ldrb	r1, [r2, #1]
    d0fa:	0209      	lsls	r1, r1, #8
    d0fc:	430b      	orrs	r3, r1
				/* Increment 8-bit pointer */
				(module->tx_buffer_ptr)++;
    d0fe:	3202      	adds	r2, #2
    d100:	62aa      	str	r2, [r5, #40]	; 0x28
			}
			/* Write the data to send */
			usart_hw->DATA.reg = (data_to_send & SERCOM_USART_DATA_MASK);
    d102:	05db      	lsls	r3, r3, #23
    d104:	0ddb      	lsrs	r3, r3, #23
    d106:	8523      	strh	r3, [r4, #40]	; 0x28

			if (--(module->remaining_tx_buffer_length) == 0) {
    d108:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
    d10a:	3b01      	subs	r3, #1
    d10c:	b29b      	uxth	r3, r3
    d10e:	85eb      	strh	r3, [r5, #46]	; 0x2e
    d110:	2b00      	cmp	r3, #0
    d112:	d106      	bne.n	d122 <_usart_interrupt_handler+0x6a>
				/* Disable the Data Register Empty Interrupt */
				usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    d114:	3301      	adds	r3, #1
    d116:	7523      	strb	r3, [r4, #20]
				/* Enable Transmission Complete interrupt */
				usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_TXC;
    d118:	3301      	adds	r3, #1
    d11a:	75a3      	strb	r3, [r4, #22]
    d11c:	e001      	b.n	d122 <_usart_interrupt_handler+0x6a>

			}
		} else {
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    d11e:	2301      	movs	r3, #1
    d120:	7523      	strb	r3, [r4, #20]

	/* Check if the Transmission Complete interrupt has occurred and
	 * that the transmit buffer is empty */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_TXC) {
    d122:	07b3      	lsls	r3, r6, #30
    d124:	d509      	bpl.n	d13a <_usart_interrupt_handler+0x82>

		/* Disable TX Complete Interrupt, and set STATUS_OK */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_TXC;
    d126:	2302      	movs	r3, #2
    d128:	7523      	strb	r3, [r4, #20]
		module->tx_status = STATUS_OK;
    d12a:	2200      	movs	r2, #0
    d12c:	3331      	adds	r3, #49	; 0x31
    d12e:	54ea      	strb	r2, [r5, r3]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BUFFER_TRANSMITTED)) {
    d130:	07fb      	lsls	r3, r7, #31
    d132:	d502      	bpl.n	d13a <_usart_interrupt_handler+0x82>
			(*(module->callback[USART_CALLBACK_BUFFER_TRANSMITTED]))(module);
    d134:	0028      	movs	r0, r5
    d136:	68eb      	ldr	r3, [r5, #12]
    d138:	4798      	blx	r3

	/* Check if the Receive Complete interrupt has occurred, and that
	 * there's more data to receive */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {
    d13a:	0773      	lsls	r3, r6, #29
    d13c:	d56a      	bpl.n	d214 <_usart_interrupt_handler+0x15c>

		if (module->remaining_rx_buffer_length) {
    d13e:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    d140:	b29b      	uxth	r3, r3
    d142:	2b00      	cmp	r3, #0
    d144:	d064      	beq.n	d210 <_usart_interrupt_handler+0x158>
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    d146:	8b63      	ldrh	r3, [r4, #26]
    d148:	b2db      	uxtb	r3, r3
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
    d14a:	071a      	lsls	r2, r3, #28
    d14c:	d402      	bmi.n	d154 <_usart_interrupt_handler+0x9c>

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {

		if (module->remaining_rx_buffer_length) {
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    d14e:	223f      	movs	r2, #63	; 0x3f
    d150:	4013      	ands	r3, r2
    d152:	e001      	b.n	d158 <_usart_interrupt_handler+0xa0>
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
				error_code &= ~SERCOM_USART_STATUS_CTS;
    d154:	2237      	movs	r2, #55	; 0x37
    d156:	4013      	ands	r3, r2
			if(error_code & SERCOM_USART_STATUS_TXE) {
				error_code &= ~SERCOM_USART_STATUS_TXE;
			}
#endif
			/* Check if an error has occurred during the receiving */
			if (error_code) {
    d158:	2b00      	cmp	r3, #0
    d15a:	d037      	beq.n	d1cc <_usart_interrupt_handler+0x114>
				/* Check which error occurred */
				if (error_code & SERCOM_USART_STATUS_FERR) {
    d15c:	079a      	lsls	r2, r3, #30
    d15e:	d507      	bpl.n	d170 <_usart_interrupt_handler+0xb8>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_FORMAT;
    d160:	221a      	movs	r2, #26
    d162:	2332      	movs	r3, #50	; 0x32
    d164:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_FERR;
    d166:	8b62      	ldrh	r2, [r4, #26]
    d168:	3b30      	subs	r3, #48	; 0x30
    d16a:	4313      	orrs	r3, r2
    d16c:	8363      	strh	r3, [r4, #26]
    d16e:	e027      	b.n	d1c0 <_usart_interrupt_handler+0x108>
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
    d170:	075a      	lsls	r2, r3, #29
    d172:	d507      	bpl.n	d184 <_usart_interrupt_handler+0xcc>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_OVERFLOW;
    d174:	221e      	movs	r2, #30
    d176:	2332      	movs	r3, #50	; 0x32
    d178:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_BUFOVF;
    d17a:	8b62      	ldrh	r2, [r4, #26]
    d17c:	3b2e      	subs	r3, #46	; 0x2e
    d17e:	4313      	orrs	r3, r2
    d180:	8363      	strh	r3, [r4, #26]
    d182:	e01d      	b.n	d1c0 <_usart_interrupt_handler+0x108>
				} else if (error_code & SERCOM_USART_STATUS_PERR) {
    d184:	07da      	lsls	r2, r3, #31
    d186:	d507      	bpl.n	d198 <_usart_interrupt_handler+0xe0>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_DATA;
    d188:	2213      	movs	r2, #19
    d18a:	2332      	movs	r3, #50	; 0x32
    d18c:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_PERR;
    d18e:	8b62      	ldrh	r2, [r4, #26]
    d190:	3b31      	subs	r3, #49	; 0x31
    d192:	4313      	orrs	r3, r2
    d194:	8363      	strh	r3, [r4, #26]
    d196:	e013      	b.n	d1c0 <_usart_interrupt_handler+0x108>
				}
#ifdef FEATURE_USART_LIN_SLAVE
				else if (error_code & SERCOM_USART_STATUS_ISF) {
    d198:	06da      	lsls	r2, r3, #27
    d19a:	d507      	bpl.n	d1ac <_usart_interrupt_handler+0xf4>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PROTOCOL;
    d19c:	2242      	movs	r2, #66	; 0x42
    d19e:	2332      	movs	r3, #50	; 0x32
    d1a0:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_ISF;
    d1a2:	8b62      	ldrh	r2, [r4, #26]
    d1a4:	3b22      	subs	r3, #34	; 0x22
    d1a6:	4313      	orrs	r3, r2
    d1a8:	8363      	strh	r3, [r4, #26]
    d1aa:	e009      	b.n	d1c0 <_usart_interrupt_handler+0x108>
				}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
				else if (error_code & SERCOM_USART_STATUS_COLL) {
    d1ac:	2220      	movs	r2, #32
    d1ae:	421a      	tst	r2, r3
    d1b0:	d006      	beq.n	d1c0 <_usart_interrupt_handler+0x108>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PACKET_COLLISION;
    d1b2:	3221      	adds	r2, #33	; 0x21
    d1b4:	2332      	movs	r3, #50	; 0x32
    d1b6:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_COLL;
    d1b8:	8b62      	ldrh	r2, [r4, #26]
    d1ba:	3b12      	subs	r3, #18
    d1bc:	4313      	orrs	r3, r2
    d1be:	8363      	strh	r3, [r4, #26]
				}
#endif

				/* Run callback if registered and enabled */
				if (callback_status
    d1c0:	077b      	lsls	r3, r7, #29
    d1c2:	d527      	bpl.n	d214 <_usart_interrupt_handler+0x15c>
						& (1 << USART_CALLBACK_ERROR)) {
					(*(module->callback[USART_CALLBACK_ERROR]))(module);
    d1c4:	0028      	movs	r0, r5
    d1c6:	696b      	ldr	r3, [r5, #20]
    d1c8:	4798      	blx	r3
    d1ca:	e023      	b.n	d214 <_usart_interrupt_handler+0x15c>

			} else {

				/* Read current packet from DATA register,
				 * increment buffer pointer and decrement buffer length */
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
    d1cc:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    d1ce:	05db      	lsls	r3, r3, #23
    d1d0:	0ddb      	lsrs	r3, r3, #23

				/* Read value will be at least 8-bits long */
				*(module->rx_buffer_ptr) = received_data;
    d1d2:	b2da      	uxtb	r2, r3
    d1d4:	6a69      	ldr	r1, [r5, #36]	; 0x24
    d1d6:	700a      	strb	r2, [r1, #0]
				/* Increment 8-bit pointer */
				module->rx_buffer_ptr += 1;
    d1d8:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    d1da:	1c51      	adds	r1, r2, #1
    d1dc:	6269      	str	r1, [r5, #36]	; 0x24

				if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    d1de:	7969      	ldrb	r1, [r5, #5]
    d1e0:	2901      	cmp	r1, #1
    d1e2:	d104      	bne.n	d1ee <_usart_interrupt_handler+0x136>
					/* 9-bit data, write next received byte to the buffer */
					*(module->rx_buffer_ptr) = (received_data >> 8);
    d1e4:	0a1b      	lsrs	r3, r3, #8
    d1e6:	7053      	strb	r3, [r2, #1]
					/* Increment 8-bit pointer */
					module->rx_buffer_ptr += 1;
    d1e8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d1ea:	3301      	adds	r3, #1
    d1ec:	626b      	str	r3, [r5, #36]	; 0x24
				}

				/* Check if the last character have been received */
				if(--(module->remaining_rx_buffer_length) == 0) {
    d1ee:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    d1f0:	3b01      	subs	r3, #1
    d1f2:	b29b      	uxth	r3, r3
    d1f4:	85ab      	strh	r3, [r5, #44]	; 0x2c
    d1f6:	2b00      	cmp	r3, #0
    d1f8:	d10c      	bne.n	d214 <_usart_interrupt_handler+0x15c>
					/* Disable RX Complete Interrupt,
					 * and set STATUS_OK */
					usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    d1fa:	3304      	adds	r3, #4
    d1fc:	7523      	strb	r3, [r4, #20]
					module->rx_status = STATUS_OK;
    d1fe:	2200      	movs	r2, #0
    d200:	332e      	adds	r3, #46	; 0x2e
    d202:	54ea      	strb	r2, [r5, r3]

					/* Run callback if registered and enabled */
					if (callback_status
    d204:	07bb      	lsls	r3, r7, #30
    d206:	d505      	bpl.n	d214 <_usart_interrupt_handler+0x15c>
							& (1 << USART_CALLBACK_BUFFER_RECEIVED)) {
						(*(module->callback[USART_CALLBACK_BUFFER_RECEIVED]))(module);
    d208:	0028      	movs	r0, r5
    d20a:	692b      	ldr	r3, [r5, #16]
    d20c:	4798      	blx	r3
    d20e:	e001      	b.n	d214 <_usart_interrupt_handler+0x15c>
					}
				}
			}
		} else {
			/* This should not happen. Disable Receive Complete interrupt. */
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    d210:	2304      	movs	r3, #4
    d212:	7523      	strb	r3, [r4, #20]
		}
	}

#ifdef FEATURE_USART_HARDWARE_FLOW_CONTROL
	if (interrupt_status & SERCOM_USART_INTFLAG_CTSIC) {
    d214:	06f3      	lsls	r3, r6, #27
    d216:	d507      	bpl.n	d228 <_usart_interrupt_handler+0x170>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_CTSIC;
    d218:	2310      	movs	r3, #16
    d21a:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_CTSIC;
    d21c:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_CTS_INPUT_CHANGE)) {
    d21e:	06fb      	lsls	r3, r7, #27
    d220:	d502      	bpl.n	d228 <_usart_interrupt_handler+0x170>
			(*(module->callback[USART_CALLBACK_CTS_INPUT_CHANGE]))(module);
    d222:	0028      	movs	r0, r5
    d224:	69eb      	ldr	r3, [r5, #28]
    d226:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_LIN_SLAVE
	if (interrupt_status & SERCOM_USART_INTFLAG_RXBRK) {
    d228:	06b3      	lsls	r3, r6, #26
    d22a:	d507      	bpl.n	d23c <_usart_interrupt_handler+0x184>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXBRK;
    d22c:	2320      	movs	r3, #32
    d22e:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXBRK;
    d230:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BREAK_RECEIVED)) {
    d232:	073b      	lsls	r3, r7, #28
    d234:	d502      	bpl.n	d23c <_usart_interrupt_handler+0x184>
			(*(module->callback[USART_CALLBACK_BREAK_RECEIVED]))(module);
    d236:	0028      	movs	r0, r5
    d238:	69ab      	ldr	r3, [r5, #24]
    d23a:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	if (interrupt_status & SERCOM_USART_INTFLAG_RXS) {
    d23c:	0733      	lsls	r3, r6, #28
    d23e:	d507      	bpl.n	d250 <_usart_interrupt_handler+0x198>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXS;
    d240:	2308      	movs	r3, #8
    d242:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;
    d244:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_START_RECEIVED)) {
    d246:	06bb      	lsls	r3, r7, #26
    d248:	d502      	bpl.n	d250 <_usart_interrupt_handler+0x198>
			(*(module->callback[USART_CALLBACK_START_RECEIVED]))(module);
    d24a:	6a2b      	ldr	r3, [r5, #32]
    d24c:	0028      	movs	r0, r5
    d24e:	4798      	blx	r3
		}
	}
#endif
}
    d250:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    d252:	46c0      	nop			; (mov r8, r8)
    d254:	20002850 	.word	0x20002850

0000d258 <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
    d258:	b510      	push	{r4, lr}
	switch (clock_source) {
    d25a:	2808      	cmp	r0, #8
    d25c:	d803      	bhi.n	d266 <system_clock_source_get_hz+0xe>
    d25e:	0080      	lsls	r0, r0, #2
    d260:	4b1c      	ldr	r3, [pc, #112]	; (d2d4 <system_clock_source_get_hz+0x7c>)
    d262:	581b      	ldr	r3, [r3, r0]
    d264:	469f      	mov	pc, r3
		}

		return _system_clock_inst.dpll.frequency;

	default:
		return 0;
    d266:	2000      	movs	r0, #0
    d268:	e032      	b.n	d2d0 <system_clock_source_get_hz+0x78>
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;
    d26a:	4b1b      	ldr	r3, [pc, #108]	; (d2d8 <system_clock_source_get_hz+0x80>)
    d26c:	6918      	ldr	r0, [r3, #16]
    d26e:	e02f      	b.n	d2d0 <system_clock_source_get_hz+0x78>

	case SYSTEM_CLOCK_SOURCE_OSC16M:
		return (OSCCTRL->OSC16MCTRL.bit.FSEL+1)*4000000UL;
    d270:	4b1a      	ldr	r3, [pc, #104]	; (d2dc <system_clock_source_get_hz+0x84>)
    d272:	7d18      	ldrb	r0, [r3, #20]
    d274:	0700      	lsls	r0, r0, #28
    d276:	0f80      	lsrs	r0, r0, #30
    d278:	3001      	adds	r0, #1
    d27a:	4b19      	ldr	r3, [pc, #100]	; (d2e0 <system_clock_source_get_hz+0x88>)
    d27c:	4358      	muls	r0, r3
    d27e:	e027      	b.n	d2d0 <system_clock_source_get_hz+0x78>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		return 32768UL;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		return _system_clock_inst.xosc32k.frequency;
    d280:	4b15      	ldr	r3, [pc, #84]	; (d2d8 <system_clock_source_get_hz+0x80>)
    d282:	6958      	ldr	r0, [r3, #20]
    d284:	e024      	b.n	d2d0 <system_clock_source_get_hz+0x78>

	case SYSTEM_CLOCK_SOURCE_DFLL:

		/* Check if the DFLL has been configured */
		if (!(_system_clock_inst.dfll.control & OSCCTRL_DFLLCTRL_ENABLE))
    d286:	4b14      	ldr	r3, [pc, #80]	; (d2d8 <system_clock_source_get_hz+0x80>)
    d288:	681b      	ldr	r3, [r3, #0]
    d28a:	2002      	movs	r0, #2
    d28c:	4018      	ands	r0, r3
    d28e:	d01f      	beq.n	d2d0 <system_clock_source_get_hz+0x78>
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(OSCCTRL->STATUS.reg & OSCCTRL_STATUS_DFLLRDY)) {
    d290:	4912      	ldr	r1, [pc, #72]	; (d2dc <system_clock_source_get_hz+0x84>)
    d292:	2280      	movs	r2, #128	; 0x80
    d294:	0052      	lsls	r2, r2, #1
    d296:	68cb      	ldr	r3, [r1, #12]
    d298:	4213      	tst	r3, r2
    d29a:	d0fc      	beq.n	d296 <system_clock_source_get_hz+0x3e>

		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & OSCCTRL_DFLLCTRL_MODE) {
    d29c:	4b0e      	ldr	r3, [pc, #56]	; (d2d8 <system_clock_source_get_hz+0x80>)
    d29e:	681b      	ldr	r3, [r3, #0]
    d2a0:	075b      	lsls	r3, r3, #29
    d2a2:	d514      	bpl.n	d2ce <system_clock_source_get_hz+0x76>
			return system_gclk_chan_get_hz(OSCCTRL_GCLK_ID_DFLL48) *
    d2a4:	2000      	movs	r0, #0
    d2a6:	4b0f      	ldr	r3, [pc, #60]	; (d2e4 <system_clock_source_get_hz+0x8c>)
    d2a8:	4798      	blx	r3
					(_system_clock_inst.dfll.mul & 0xffff);
    d2aa:	4b0b      	ldr	r3, [pc, #44]	; (d2d8 <system_clock_source_get_hz+0x80>)
    d2ac:	689b      	ldr	r3, [r3, #8]
		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & OSCCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(OSCCTRL_GCLK_ID_DFLL48) *
    d2ae:	041b      	lsls	r3, r3, #16
    d2b0:	0c1b      	lsrs	r3, r3, #16
    d2b2:	4358      	muls	r0, r3
    d2b4:	e00c      	b.n	d2d0 <system_clock_source_get_hz+0x78>
		}

		return 48000000UL;

	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(OSCCTRL->DPLLCTRLA.reg & OSCCTRL_DPLLCTRLA_ENABLE)) {
    d2b6:	2328      	movs	r3, #40	; 0x28
    d2b8:	4a08      	ldr	r2, [pc, #32]	; (d2dc <system_clock_source_get_hz+0x84>)
    d2ba:	5cd3      	ldrb	r3, [r2, r3]
			return 0;
    d2bc:	2000      	movs	r0, #0
		}

		return 48000000UL;

	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(OSCCTRL->DPLLCTRLA.reg & OSCCTRL_DPLLCTRLA_ENABLE)) {
    d2be:	079b      	lsls	r3, r3, #30
    d2c0:	d506      	bpl.n	d2d0 <system_clock_source_get_hz+0x78>
			return 0;
		}

		return _system_clock_inst.dpll.frequency;
    d2c2:	4b05      	ldr	r3, [pc, #20]	; (d2d8 <system_clock_source_get_hz+0x80>)
    d2c4:	68d8      	ldr	r0, [r3, #12]
    d2c6:	e003      	b.n	d2d0 <system_clock_source_get_hz+0x78>

	case SYSTEM_CLOCK_SOURCE_OSC16M:
		return (OSCCTRL->OSC16MCTRL.bit.FSEL+1)*4000000UL;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		return 32768UL;
    d2c8:	2080      	movs	r0, #128	; 0x80
    d2ca:	0200      	lsls	r0, r0, #8
    d2cc:	e000      	b.n	d2d0 <system_clock_source_get_hz+0x78>
		if (_system_clock_inst.dfll.control & OSCCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(OSCCTRL_GCLK_ID_DFLL48) *
					(_system_clock_inst.dfll.mul & 0xffff);
		}

		return 48000000UL;
    d2ce:	4806      	ldr	r0, [pc, #24]	; (d2e8 <system_clock_source_get_hz+0x90>)
		return _system_clock_inst.dpll.frequency;

	default:
		return 0;
	}
}
    d2d0:	bd10      	pop	{r4, pc}
    d2d2:	46c0      	nop			; (mov r8, r8)
    d2d4:	0001be50 	.word	0x0001be50
    d2d8:	20001964 	.word	0x20001964
    d2dc:	40000c00 	.word	0x40000c00
    d2e0:	003d0900 	.word	0x003d0900
    d2e4:	0000d97d 	.word	0x0000d97d
    d2e8:	02dc6c00 	.word	0x02dc6c00

0000d2ec <system_clock_source_osc16m_set_config>:
 *
 * \param[in] config  OSC16M configuration structure containing the new config
 */
void system_clock_source_osc16m_set_config(
		struct system_clock_source_osc16m_config *const config)
{
    d2ec:	b530      	push	{r4, r5, lr}
	OSCCTRL_OSC16MCTRL_Type temp = OSCCTRL->OSC16MCTRL;
    d2ee:	4c0c      	ldr	r4, [pc, #48]	; (d320 <system_clock_source_osc16m_set_config+0x34>)
    d2f0:	7d23      	ldrb	r3, [r4, #20]

	/* Use temporary struct to reduce register access */
	temp.bit.FSEL    = config->fsel;
	temp.bit.ONDEMAND = config->on_demand;
    d2f2:	7885      	ldrb	r5, [r0, #2]
	temp.bit.RUNSTDBY = config->run_in_standby;
    d2f4:	7841      	ldrb	r1, [r0, #1]

	OSCCTRL->OSC16MCTRL = temp;
    d2f6:	7800      	ldrb	r0, [r0, #0]
    d2f8:	2203      	movs	r2, #3
    d2fa:	4010      	ands	r0, r2
    d2fc:	0080      	lsls	r0, r0, #2
    d2fe:	3209      	adds	r2, #9
    d300:	4393      	bics	r3, r2
    d302:	4303      	orrs	r3, r0
    d304:	3a0b      	subs	r2, #11
    d306:	4011      	ands	r1, r2
    d308:	0189      	lsls	r1, r1, #6
    d30a:	323f      	adds	r2, #63	; 0x3f
    d30c:	4393      	bics	r3, r2
    d30e:	430b      	orrs	r3, r1
    d310:	001a      	movs	r2, r3
    d312:	01e9      	lsls	r1, r5, #7
    d314:	237f      	movs	r3, #127	; 0x7f
    d316:	4013      	ands	r3, r2
    d318:	430b      	orrs	r3, r1
    d31a:	7523      	strb	r3, [r4, #20]
}
    d31c:	bd30      	pop	{r4, r5, pc}
    d31e:	46c0      	nop			; (mov r8, r8)
    d320:	40000c00 	.word	0x40000c00

0000d324 <system_clock_source_xosc32k_set_config>:
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
    d324:	b5f0      	push	{r4, r5, r6, r7, lr}
    d326:	465f      	mov	r7, fp
    d328:	4656      	mov	r6, sl
    d32a:	464d      	mov	r5, r9
    d32c:	4644      	mov	r4, r8
    d32e:	b4f0      	push	{r4, r5, r6, r7}
	OSC32KCTRL_XOSC32K_Type temp = OSC32KCTRL->XOSC32K;
    d330:	4e25      	ldr	r6, [pc, #148]	; (d3c8 <system_clock_source_xosc32k_set_config+0xa4>)
    d332:	6973      	ldr	r3, [r6, #20]
    d334:	469c      	mov	ip, r3

	temp.bit.STARTUP = config->startup_time;
    d336:	7845      	ldrb	r5, [r0, #1]

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
    d338:	7803      	ldrb	r3, [r0, #0]
    d33a:	425a      	negs	r2, r3
    d33c:	415a      	adcs	r2, r3
    d33e:	4690      	mov	r8, r2
		temp.bit.XTALEN = 1;
	} else {
		temp.bit.XTALEN = 0;
	}

	temp.bit.EN1K = config->enable_1khz_output;
    d340:	7883      	ldrb	r3, [r0, #2]
    d342:	469a      	mov	sl, r3
	temp.bit.EN32K = config->enable_32khz_output;
    d344:	78c3      	ldrb	r3, [r0, #3]

	temp.bit.ONDEMAND = config->on_demand;
    d346:	7a47      	ldrb	r7, [r0, #9]
	temp.bit.RUNSTDBY = config->run_in_standby;
    d348:	7a02      	ldrb	r2, [r0, #8]
    d34a:	4693      	mov	fp, r2
	temp.bit.WRTLOCK  = config->write_once;
    d34c:	7a84      	ldrb	r4, [r0, #10]

	/* Cache the new frequency in case the user needs to check the current
	 * operating frequency later */
	_system_clock_inst.xosc32k.frequency = config->frequency;
    d34e:	6842      	ldr	r2, [r0, #4]
    d350:	481e      	ldr	r0, [pc, #120]	; (d3cc <system_clock_source_xosc32k_set_config+0xa8>)
    d352:	6142      	str	r2, [r0, #20]

	OSC32KCTRL->XOSC32K = temp;
    d354:	2001      	movs	r0, #1
    d356:	4642      	mov	r2, r8
    d358:	0092      	lsls	r2, r2, #2
    d35a:	4690      	mov	r8, r2
    d35c:	2204      	movs	r2, #4
    d35e:	4691      	mov	r9, r2
    d360:	4662      	mov	r2, ip
    d362:	4649      	mov	r1, r9
    d364:	438a      	bics	r2, r1
    d366:	4694      	mov	ip, r2
    d368:	4642      	mov	r2, r8
    d36a:	4661      	mov	r1, ip
    d36c:	430a      	orrs	r2, r1
    d36e:	4694      	mov	ip, r2
    d370:	4003      	ands	r3, r0
    d372:	00db      	lsls	r3, r3, #3
    d374:	2208      	movs	r2, #8
    d376:	4690      	mov	r8, r2
    d378:	4662      	mov	r2, ip
    d37a:	4641      	mov	r1, r8
    d37c:	438a      	bics	r2, r1
    d37e:	4313      	orrs	r3, r2
    d380:	4651      	mov	r1, sl
    d382:	4001      	ands	r1, r0
    d384:	0109      	lsls	r1, r1, #4
    d386:	2210      	movs	r2, #16
    d388:	4393      	bics	r3, r2
    d38a:	430b      	orrs	r3, r1
    d38c:	465a      	mov	r2, fp
    d38e:	4002      	ands	r2, r0
    d390:	0192      	lsls	r2, r2, #6
    d392:	2140      	movs	r1, #64	; 0x40
    d394:	438b      	bics	r3, r1
    d396:	4313      	orrs	r3, r2
    d398:	4007      	ands	r7, r0
    d39a:	01ff      	lsls	r7, r7, #7
    d39c:	2280      	movs	r2, #128	; 0x80
    d39e:	4393      	bics	r3, r2
    d3a0:	433b      	orrs	r3, r7
    d3a2:	3a79      	subs	r2, #121	; 0x79
    d3a4:	4015      	ands	r5, r2
    d3a6:	022d      	lsls	r5, r5, #8
    d3a8:	4f09      	ldr	r7, [pc, #36]	; (d3d0 <system_clock_source_xosc32k_set_config+0xac>)
    d3aa:	403b      	ands	r3, r7
    d3ac:	432b      	orrs	r3, r5
    d3ae:	4004      	ands	r4, r0
    d3b0:	0320      	lsls	r0, r4, #12
    d3b2:	4c08      	ldr	r4, [pc, #32]	; (d3d4 <system_clock_source_xosc32k_set_config+0xb0>)
    d3b4:	401c      	ands	r4, r3
    d3b6:	4304      	orrs	r4, r0
    d3b8:	6174      	str	r4, [r6, #20]
}
    d3ba:	bc3c      	pop	{r2, r3, r4, r5}
    d3bc:	4690      	mov	r8, r2
    d3be:	4699      	mov	r9, r3
    d3c0:	46a2      	mov	sl, r4
    d3c2:	46ab      	mov	fp, r5
    d3c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d3c6:	46c0      	nop			; (mov r8, r8)
    d3c8:	40001000 	.word	0x40001000
    d3cc:	20001964 	.word	0x20001964
    d3d0:	fffff8ff 	.word	0xfffff8ff
    d3d4:	ffffefff 	.word	0xffffefff

0000d3d8 <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
    d3d8:	b510      	push	{r4, lr}
	_system_clock_inst.dfll.val =
			OSCCTRL_DFLLVAL_COARSE(config->coarse_value) |
    d3da:	7a83      	ldrb	r3, [r0, #10]
    d3dc:	069b      	lsls	r3, r3, #26
    d3de:	0c1a      	lsrs	r2, r3, #16
    d3e0:	8983      	ldrh	r3, [r0, #12]
    d3e2:	059b      	lsls	r3, r3, #22
    d3e4:	0d9b      	lsrs	r3, r3, #22
    d3e6:	4313      	orrs	r3, r2
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
    d3e8:	4c1a      	ldr	r4, [pc, #104]	; (d454 <system_clock_source_dfll_set_config+0x7c>)
    d3ea:	6063      	str	r3, [r4, #4]
	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << OSCCTRL_DFLLCTRL_ONDEMAND_Pos) |
    d3ec:	7a01      	ldrb	r1, [r0, #8]
    d3ee:	7a43      	ldrb	r3, [r0, #9]
    d3f0:	4319      	orrs	r1, r3
    d3f2:	8883      	ldrh	r3, [r0, #4]
    d3f4:	88c2      	ldrh	r2, [r0, #6]
    d3f6:	4313      	orrs	r3, r2
    d3f8:	430b      	orrs	r3, r1
    d3fa:	7842      	ldrb	r2, [r0, #1]
    d3fc:	01d2      	lsls	r2, r2, #7
    d3fe:	4313      	orrs	r3, r2
    d400:	7882      	ldrb	r2, [r0, #2]
    d402:	0192      	lsls	r2, r2, #6
    d404:	4313      	orrs	r3, r2
{
	_system_clock_inst.dfll.val =
			OSCCTRL_DFLLVAL_COARSE(config->coarse_value) |
			OSCCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
    d406:	6023      	str	r3, [r4, #0]
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << OSCCTRL_DFLLCTRL_ONDEMAND_Pos) |
			((uint32_t)config->run_in_stanby << OSCCTRL_DFLLCTRL_RUNSTDBY_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
    d408:	7803      	ldrb	r3, [r0, #0]
    d40a:	2b04      	cmp	r3, #4
    d40c:	d10f      	bne.n	d42e <system_clock_source_dfll_set_config+0x56>

		_system_clock_inst.dfll.mul =
				OSCCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				OSCCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    d40e:	7b83      	ldrb	r3, [r0, #14]
    d410:	069b      	lsls	r3, r3, #26
    d412:	8a42      	ldrh	r2, [r0, #18]
    d414:	4313      	orrs	r3, r2
    d416:	0019      	movs	r1, r3
    d418:	8a03      	ldrh	r3, [r0, #16]
    d41a:	041b      	lsls	r3, r3, #16
    d41c:	4a0e      	ldr	r2, [pc, #56]	; (d458 <system_clock_source_dfll_set_config+0x80>)
    d41e:	4013      	ands	r3, r2
    d420:	430b      	orrs	r3, r1
			((uint32_t)config->on_demand << OSCCTRL_DFLLCTRL_ONDEMAND_Pos) |
			((uint32_t)config->run_in_stanby << OSCCTRL_DFLLCTRL_RUNSTDBY_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
    d422:	60a3      	str	r3, [r4, #8]
				OSCCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				OSCCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				OSCCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
    d424:	6821      	ldr	r1, [r4, #0]
    d426:	2304      	movs	r3, #4
    d428:	430b      	orrs	r3, r1
    d42a:	6023      	str	r3, [r4, #0]
    d42c:	e011      	b.n	d452 <system_clock_source_dfll_set_config+0x7a>
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
    d42e:	2b20      	cmp	r3, #32
    d430:	d10f      	bne.n	d452 <system_clock_source_dfll_set_config+0x7a>

		_system_clock_inst.dfll.mul =
				OSCCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				OSCCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    d432:	7b83      	ldrb	r3, [r0, #14]
    d434:	069b      	lsls	r3, r3, #26
    d436:	8a42      	ldrh	r2, [r0, #18]
    d438:	4313      	orrs	r3, r2
    d43a:	0019      	movs	r1, r3
    d43c:	8a03      	ldrh	r3, [r0, #16]
    d43e:	041b      	lsls	r3, r3, #16
    d440:	4a05      	ldr	r2, [pc, #20]	; (d458 <system_clock_source_dfll_set_config+0x80>)
    d442:	4013      	ands	r3, r2
    d444:	430b      	orrs	r3, r1
		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
    d446:	4a03      	ldr	r2, [pc, #12]	; (d454 <system_clock_source_dfll_set_config+0x7c>)
    d448:	6093      	str	r3, [r2, #8]
				OSCCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				OSCCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				OSCCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the USB recovery mode */
		_system_clock_inst.dfll.control |= config->loop_mode |
    d44a:	6813      	ldr	r3, [r2, #0]
    d44c:	4903      	ldr	r1, [pc, #12]	; (d45c <system_clock_source_dfll_set_config+0x84>)
    d44e:	430b      	orrs	r3, r1
    d450:	6013      	str	r3, [r2, #0]
				OSCCTRL_DFLLCTRL_MODE | OSCCTRL_DFLLCTRL_BPLCKC;
	}
}
    d452:	bd10      	pop	{r4, pc}
    d454:	20001964 	.word	0x20001964
    d458:	03ff0000 	.word	0x03ff0000
    d45c:	00000424 	.word	0x00000424

0000d460 <system_clock_source_enable>:
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
    d460:	2808      	cmp	r0, #8
    d462:	d803      	bhi.n	d46c <system_clock_source_enable+0xc>
    d464:	0080      	lsls	r0, r0, #2
    d466:	4b29      	ldr	r3, [pc, #164]	; (d50c <system_clock_source_enable+0xac>)
    d468:	581b      	ldr	r3, [r3, r0]
    d46a:	469f      	mov	pc, r3
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    d46c:	2017      	movs	r0, #23
    d46e:	e04b      	b.n	d508 <system_clock_source_enable+0xa8>
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC16M:
		OSCCTRL->OSC16MCTRL.reg |= OSCCTRL_OSC16MCTRL_ENABLE;
    d470:	4a27      	ldr	r2, [pc, #156]	; (d510 <system_clock_source_enable+0xb0>)
    d472:	7d11      	ldrb	r1, [r2, #20]
    d474:	2302      	movs	r3, #2
    d476:	430b      	orrs	r3, r1
    d478:	7513      	strb	r3, [r2, #20]
		return STATUS_OK;
    d47a:	2000      	movs	r0, #0
    d47c:	e044      	b.n	d508 <system_clock_source_enable+0xa8>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		OSC32KCTRL->OSC32K.reg |= OSC32KCTRL_OSC32K_ENABLE;
    d47e:	4a25      	ldr	r2, [pc, #148]	; (d514 <system_clock_source_enable+0xb4>)
    d480:	6991      	ldr	r1, [r2, #24]
    d482:	2302      	movs	r3, #2
    d484:	430b      	orrs	r3, r1
    d486:	6193      	str	r3, [r2, #24]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    d488:	2000      	movs	r0, #0
		OSCCTRL->OSC16MCTRL.reg |= OSCCTRL_OSC16MCTRL_ENABLE;
		return STATUS_OK;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		OSC32KCTRL->OSC32K.reg |= OSC32KCTRL_OSC32K_ENABLE;
		break;
    d48a:	e03d      	b.n	d508 <system_clock_source_enable+0xa8>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		OSCCTRL->XOSCCTRL.reg |= OSCCTRL_XOSCCTRL_ENABLE;
    d48c:	4a20      	ldr	r2, [pc, #128]	; (d510 <system_clock_source_enable+0xb0>)
    d48e:	8a11      	ldrh	r1, [r2, #16]
    d490:	2302      	movs	r3, #2
    d492:	430b      	orrs	r3, r1
    d494:	8213      	strh	r3, [r2, #16]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    d496:	2000      	movs	r0, #0
		OSC32KCTRL->OSC32K.reg |= OSC32KCTRL_OSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC:
		OSCCTRL->XOSCCTRL.reg |= OSCCTRL_XOSCCTRL_ENABLE;
		break;
    d498:	e036      	b.n	d508 <system_clock_source_enable+0xa8>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		OSC32KCTRL->XOSC32K.reg |= OSC32KCTRL_XOSC32K_ENABLE;
    d49a:	4a1e      	ldr	r2, [pc, #120]	; (d514 <system_clock_source_enable+0xb4>)
    d49c:	6951      	ldr	r1, [r2, #20]
    d49e:	2302      	movs	r3, #2
    d4a0:	430b      	orrs	r3, r1
    d4a2:	6153      	str	r3, [r2, #20]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    d4a4:	2000      	movs	r0, #0
		OSCCTRL->XOSCCTRL.reg |= OSCCTRL_XOSCCTRL_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		OSC32KCTRL->XOSC32K.reg |= OSC32KCTRL_XOSC32K_ENABLE;
		break;
    d4a6:	e02f      	b.n	d508 <system_clock_source_enable+0xa8>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= OSCCTRL_DFLLCTRL_ENABLE;
    d4a8:	491b      	ldr	r1, [pc, #108]	; (d518 <system_clock_source_enable+0xb8>)
    d4aa:	680b      	ldr	r3, [r1, #0]
    d4ac:	2202      	movs	r2, #2
    d4ae:	4313      	orrs	r3, r2
    d4b0:	600b      	str	r3, [r1, #0]

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{

	/* Disable ONDEMAND mode while writing configurations */
	OSCCTRL->DFLLCTRL.reg = OSCCTRL_DFLLCTRL_ENABLE;
    d4b2:	4b17      	ldr	r3, [pc, #92]	; (d510 <system_clock_source_enable+0xb0>)
    d4b4:	831a      	strh	r2, [r3, #24]
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(OSCCTRL->STATUS.reg & OSCCTRL_STATUS_DFLLRDY)) {
    d4b6:	0019      	movs	r1, r3
    d4b8:	32fe      	adds	r2, #254	; 0xfe
    d4ba:	68cb      	ldr	r3, [r1, #12]
    d4bc:	4213      	tst	r3, r2
    d4be:	d0fc      	beq.n	d4ba <system_clock_source_enable+0x5a>

	/* Disable ONDEMAND mode while writing configurations */
	OSCCTRL->DFLLCTRL.reg = OSCCTRL_DFLLCTRL_ENABLE;
	_system_dfll_wait_for_sync();

	OSCCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    d4c0:	4a15      	ldr	r2, [pc, #84]	; (d518 <system_clock_source_enable+0xb8>)
    d4c2:	6891      	ldr	r1, [r2, #8]
    d4c4:	4b12      	ldr	r3, [pc, #72]	; (d510 <system_clock_source_enable+0xb0>)
    d4c6:	6219      	str	r1, [r3, #32]
	OSCCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
    d4c8:	6852      	ldr	r2, [r2, #4]
    d4ca:	61da      	str	r2, [r3, #28]

	/* Write full configuration to DFLL control register */
	OSCCTRL->DFLLCTRL.reg = 0;
    d4cc:	2200      	movs	r2, #0
    d4ce:	831a      	strh	r2, [r3, #24]
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(OSCCTRL->STATUS.reg & OSCCTRL_STATUS_DFLLRDY)) {
    d4d0:	0019      	movs	r1, r3
    d4d2:	3201      	adds	r2, #1
    d4d4:	32ff      	adds	r2, #255	; 0xff
    d4d6:	68cb      	ldr	r3, [r1, #12]
    d4d8:	4213      	tst	r3, r2
    d4da:	d0fc      	beq.n	d4d6 <system_clock_source_enable+0x76>
	OSCCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;

	/* Write full configuration to DFLL control register */
	OSCCTRL->DFLLCTRL.reg = 0;
	_system_dfll_wait_for_sync();
	OSCCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    d4dc:	4b0e      	ldr	r3, [pc, #56]	; (d518 <system_clock_source_enable+0xb8>)
    d4de:	681b      	ldr	r3, [r3, #0]
    d4e0:	b29b      	uxth	r3, r3
    d4e2:	4a0b      	ldr	r2, [pc, #44]	; (d510 <system_clock_source_enable+0xb0>)
    d4e4:	8313      	strh	r3, [r2, #24]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    d4e6:	2000      	movs	r0, #0
    d4e8:	e00e      	b.n	d508 <system_clock_source_enable+0xa8>
		_system_clock_inst.dfll.control |= OSCCTRL_DFLLCTRL_ENABLE;
		_system_clock_source_dfll_set_config_errata_9905();
		break;

	case SYSTEM_CLOCK_SOURCE_DPLL:
		OSCCTRL->DPLLCTRLA.reg |= OSCCTRL_DPLLCTRLA_ENABLE;
    d4ea:	4909      	ldr	r1, [pc, #36]	; (d510 <system_clock_source_enable+0xb0>)
    d4ec:	2228      	movs	r2, #40	; 0x28
    d4ee:	5c88      	ldrb	r0, [r1, r2]
    d4f0:	2302      	movs	r3, #2
    d4f2:	4303      	orrs	r3, r0
    d4f4:	548b      	strb	r3, [r1, r2]
		while(OSCCTRL->DPLLSYNCBUSY.reg & OSCCTRL_DPLLSYNCBUSY_ENABLE){
    d4f6:	0008      	movs	r0, r1
    d4f8:	2138      	movs	r1, #56	; 0x38
    d4fa:	3a26      	subs	r2, #38	; 0x26
    d4fc:	5c43      	ldrb	r3, [r0, r1]
    d4fe:	4213      	tst	r3, r2
    d500:	d1fc      	bne.n	d4fc <system_clock_source_enable+0x9c>
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    d502:	2000      	movs	r0, #0
    d504:	e000      	b.n	d508 <system_clock_source_enable+0xa8>
		}
		break;

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
    d506:	2000      	movs	r0, #0
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
}
    d508:	4770      	bx	lr
    d50a:	46c0      	nop			; (mov r8, r8)
    d50c:	0001be74 	.word	0x0001be74
    d510:	40000c00 	.word	0x40000c00
    d514:	40001000 	.word	0x40001000
    d518:	20001964 	.word	0x20001964

0000d51c <system_clock_source_disable>:
 *                                 given
 */
enum status_code system_clock_source_disable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
    d51c:	2808      	cmp	r0, #8
    d51e:	d832      	bhi.n	d586 <system_clock_source_disable+0x6a>
    d520:	0080      	lsls	r0, r0, #2
    d522:	4b1a      	ldr	r3, [pc, #104]	; (d58c <system_clock_source_disable+0x70>)
    d524:	581b      	ldr	r3, [r3, r0]
    d526:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_OSC16M:
		OSCCTRL->OSC16MCTRL.reg &= ~OSCCTRL_OSC16MCTRL_ENABLE;
    d528:	4a19      	ldr	r2, [pc, #100]	; (d590 <system_clock_source_disable+0x74>)
    d52a:	7d13      	ldrb	r3, [r2, #20]
    d52c:	2102      	movs	r1, #2
    d52e:	438b      	bics	r3, r1
    d530:	7513      	strb	r3, [r2, #20]
		Assert(false);
		return STATUS_ERR_INVALID_ARG;

	}

	return STATUS_OK;
    d532:	2000      	movs	r0, #0
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC16M:
		OSCCTRL->OSC16MCTRL.reg &= ~OSCCTRL_OSC16MCTRL_ENABLE;
		break;
    d534:	e028      	b.n	d588 <system_clock_source_disable+0x6c>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		OSC32KCTRL->OSC32K.reg &= ~OSC32KCTRL_OSC32K_ENABLE;
    d536:	4a17      	ldr	r2, [pc, #92]	; (d594 <system_clock_source_disable+0x78>)
    d538:	6993      	ldr	r3, [r2, #24]
    d53a:	2102      	movs	r1, #2
    d53c:	438b      	bics	r3, r1
    d53e:	6193      	str	r3, [r2, #24]
		Assert(false);
		return STATUS_ERR_INVALID_ARG;

	}

	return STATUS_OK;
    d540:	2000      	movs	r0, #0
		OSCCTRL->OSC16MCTRL.reg &= ~OSCCTRL_OSC16MCTRL_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		OSC32KCTRL->OSC32K.reg &= ~OSC32KCTRL_OSC32K_ENABLE;
		break;
    d542:	e021      	b.n	d588 <system_clock_source_disable+0x6c>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		OSCCTRL->XOSCCTRL.reg &= ~OSCCTRL_XOSCCTRL_ENABLE;
    d544:	4a12      	ldr	r2, [pc, #72]	; (d590 <system_clock_source_disable+0x74>)
    d546:	8a13      	ldrh	r3, [r2, #16]
    d548:	2102      	movs	r1, #2
    d54a:	438b      	bics	r3, r1
    d54c:	8213      	strh	r3, [r2, #16]
		Assert(false);
		return STATUS_ERR_INVALID_ARG;

	}

	return STATUS_OK;
    d54e:	2000      	movs	r0, #0
		OSC32KCTRL->OSC32K.reg &= ~OSC32KCTRL_OSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC:
		OSCCTRL->XOSCCTRL.reg &= ~OSCCTRL_XOSCCTRL_ENABLE;
		break;
    d550:	e01a      	b.n	d588 <system_clock_source_disable+0x6c>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		OSC32KCTRL->XOSC32K.reg &= ~OSC32KCTRL_XOSC32K_ENABLE;
    d552:	4a10      	ldr	r2, [pc, #64]	; (d594 <system_clock_source_disable+0x78>)
    d554:	6953      	ldr	r3, [r2, #20]
    d556:	2102      	movs	r1, #2
    d558:	438b      	bics	r3, r1
    d55a:	6153      	str	r3, [r2, #20]
		Assert(false);
		return STATUS_ERR_INVALID_ARG;

	}

	return STATUS_OK;
    d55c:	2000      	movs	r0, #0
		OSCCTRL->XOSCCTRL.reg &= ~OSCCTRL_XOSCCTRL_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		OSC32KCTRL->XOSC32K.reg &= ~OSC32KCTRL_XOSC32K_ENABLE;
		break;
    d55e:	e013      	b.n	d588 <system_clock_source_disable+0x6c>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control &= ~OSCCTRL_DFLLCTRL_ENABLE;
    d560:	4b0d      	ldr	r3, [pc, #52]	; (d598 <system_clock_source_disable+0x7c>)
    d562:	681a      	ldr	r2, [r3, #0]
    d564:	2102      	movs	r1, #2
    d566:	438a      	bics	r2, r1
    d568:	601a      	str	r2, [r3, #0]
		OSCCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    d56a:	681b      	ldr	r3, [r3, #0]
    d56c:	b29b      	uxth	r3, r3
    d56e:	4a08      	ldr	r2, [pc, #32]	; (d590 <system_clock_source_disable+0x74>)
    d570:	8313      	strh	r3, [r2, #24]
		Assert(false);
		return STATUS_ERR_INVALID_ARG;

	}

	return STATUS_OK;
    d572:	2000      	movs	r0, #0
		break;

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control &= ~OSCCTRL_DFLLCTRL_ENABLE;
		OSCCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
		break;
    d574:	e008      	b.n	d588 <system_clock_source_disable+0x6c>
	case SYSTEM_CLOCK_SOURCE_DPLL:
		OSCCTRL->DPLLCTRLA.reg &= ~OSCCTRL_DPLLCTRLA_ENABLE;
    d576:	4906      	ldr	r1, [pc, #24]	; (d590 <system_clock_source_disable+0x74>)
    d578:	2228      	movs	r2, #40	; 0x28
    d57a:	5c8b      	ldrb	r3, [r1, r2]
    d57c:	2002      	movs	r0, #2
    d57e:	4383      	bics	r3, r0
    d580:	548b      	strb	r3, [r1, r2]
		Assert(false);
		return STATUS_ERR_INVALID_ARG;

	}

	return STATUS_OK;
    d582:	2000      	movs	r0, #0
		_system_clock_inst.dfll.control &= ~OSCCTRL_DFLLCTRL_ENABLE;
		OSCCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
		break;
	case SYSTEM_CLOCK_SOURCE_DPLL:
		OSCCTRL->DPLLCTRLA.reg &= ~OSCCTRL_DPLLCTRLA_ENABLE;
		break;
    d584:	e000      	b.n	d588 <system_clock_source_disable+0x6c>
	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Not possible to disable */

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    d586:	2017      	movs	r0, #23

	}

	return STATUS_OK;
}
    d588:	4770      	bx	lr
    d58a:	46c0      	nop			; (mov r8, r8)
    d58c:	0001be98 	.word	0x0001be98
    d590:	40000c00 	.word	0x40000c00
    d594:	40001000 	.word	0x40001000
    d598:	20001964 	.word	0x20001964

0000d59c <system_clock_init>:
 * \note OSC16M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC16M default enable can be disabled after system_clock_init. Make sure the
 * clock switches successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    d59c:	b530      	push	{r4, r5, lr}
    d59e:	b08d      	sub	sp, #52	; 0x34
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	OSCCTRL->INTFLAG.reg = OSCCTRL_INTFLAG_DFLLRDY;
    d5a0:	2280      	movs	r2, #128	; 0x80
    d5a2:	0052      	lsls	r2, r2, #1
    d5a4:	4b68      	ldr	r3, [pc, #416]	; (d748 <system_clock_init+0x1ac>)
    d5a6:	609a      	str	r2, [r3, #8]
	SUPC->INTFLAG.reg = SUPC_INTFLAG_BOD33RDY | SUPC_INTFLAG_BOD33DET;
    d5a8:	3afd      	subs	r2, #253	; 0xfd
    d5aa:	4b68      	ldr	r3, [pc, #416]	; (d74c <system_clock_init+0x1b0>)
    d5ac:	609a      	str	r2, [r3, #8]
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    d5ae:	4968      	ldr	r1, [pc, #416]	; (d750 <system_clock_init+0x1b4>)
    d5b0:	684b      	ldr	r3, [r1, #4]
    d5b2:	321b      	adds	r2, #27
    d5b4:	4393      	bics	r3, r2
    d5b6:	3a1a      	subs	r2, #26
    d5b8:	4313      	orrs	r3, r2
    d5ba:	604b      	str	r3, [r1, #4]
 */
static inline enum status_code system_switch_performance_level(
					const enum system_performance_level performance_level)
{

	if (performance_level == (enum system_performance_level)PM->PLCFG.reg) {
    d5bc:	2380      	movs	r3, #128	; 0x80
    d5be:	05db      	lsls	r3, r3, #23
    d5c0:	789b      	ldrb	r3, [r3, #2]
    d5c2:	2b02      	cmp	r3, #2
    d5c4:	d009      	beq.n	d5da <system_clock_init+0x3e>
		return STATUS_ERR_INVALID_ARG;
	}
#endif

	/* Clear performance level status */
	PM->INTFLAG.reg = PM_INTFLAG_PLRDY;
    d5c6:	2380      	movs	r3, #128	; 0x80
    d5c8:	05db      	lsls	r3, r3, #23
    d5ca:	3a03      	subs	r2, #3
    d5cc:	719a      	strb	r2, [r3, #6]

	/* Switch performance level */
	PM->PLCFG.reg = performance_level;
    d5ce:	3201      	adds	r2, #1
    d5d0:	709a      	strb	r2, [r3, #2]

	/* Waiting performance level ready */
	while (!PM->INTFLAG.reg) {
    d5d2:	001a      	movs	r2, r3
    d5d4:	7993      	ldrb	r3, [r2, #6]
    d5d6:	2b00      	cmp	r3, #0
    d5d8:	d0fc      	beq.n	d5d4 <system_clock_init+0x38>
static inline void system_clock_source_xosc32k_get_config_defaults(
		struct system_clock_source_xosc32k_config *const config)
{
	Assert(config);

	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
    d5da:	a809      	add	r0, sp, #36	; 0x24
    d5dc:	2300      	movs	r3, #0
    d5de:	7003      	strb	r3, [r0, #0]
	config->startup_time        = SYSTEM_XOSC32K_STARTUP_16384;
	config->frequency           = 32768UL;
    d5e0:	2280      	movs	r2, #128	; 0x80
    d5e2:	0212      	lsls	r2, r2, #8
    d5e4:	6042      	str	r2, [r0, #4]
	config->enable_1khz_output  = false;
    d5e6:	7083      	strb	r3, [r0, #2]
	config->enable_32khz_output = true;
    d5e8:	2201      	movs	r2, #1
    d5ea:	70c2      	strb	r2, [r0, #3]
	config->run_in_standby      = false;
    d5ec:	7203      	strb	r3, [r0, #8]
	config->on_demand           = true;
	config->write_once          = false;
    d5ee:	7283      	strb	r3, [r0, #10]
	struct system_clock_source_xosc32k_config xosc32k_conf;
	system_clock_source_xosc32k_get_config_defaults(&xosc32k_conf);

	xosc32k_conf.frequency           = 32768UL;
	xosc32k_conf.external_clock      = CONF_CLOCK_XOSC32K_EXTERNAL_CRYSTAL;
	xosc32k_conf.startup_time        = CONF_CLOCK_XOSC32K_STARTUP_TIME;
    d5f0:	7042      	strb	r2, [r0, #1]
	xosc32k_conf.enable_1khz_output  = CONF_CLOCK_XOSC32K_ENABLE_1KHZ_OUPUT;
	xosc32k_conf.enable_32khz_output = CONF_CLOCK_XOSC32K_ENABLE_32KHZ_OUTPUT;
	xosc32k_conf.on_demand           = false;
    d5f2:	7243      	strb	r3, [r0, #9]
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
    d5f4:	4b57      	ldr	r3, [pc, #348]	; (d754 <system_clock_init+0x1b8>)
    d5f6:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
    d5f8:	2005      	movs	r0, #5
    d5fa:	4b57      	ldr	r3, [pc, #348]	; (d758 <system_clock_init+0x1bc>)
    d5fc:	4798      	blx	r3
		mask = OSCCTRL_STATUS_XOSCRDY;
		return ((OSCCTRL->STATUS.reg & mask) == mask);

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		mask = OSC32KCTRL_STATUS_XOSC32KRDY;
		return ((OSC32KCTRL->STATUS.reg & mask) == mask);
    d5fe:	4957      	ldr	r1, [pc, #348]	; (d75c <system_clock_init+0x1c0>)
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K));
    d600:	2201      	movs	r2, #1
		mask = OSCCTRL_STATUS_XOSCRDY;
		return ((OSCCTRL->STATUS.reg & mask) == mask);

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		mask = OSC32KCTRL_STATUS_XOSC32KRDY;
		return ((OSC32KCTRL->STATUS.reg & mask) == mask);
    d602:	68cb      	ldr	r3, [r1, #12]
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K));
    d604:	421a      	tst	r2, r3
    d606:	d0fc      	beq.n	d602 <system_clock_init+0x66>
	if (CONF_CLOCK_XOSC32K_ON_DEMAND) {
		OSC32KCTRL->XOSC32K.bit.ONDEMAND = 1;
    d608:	4a54      	ldr	r2, [pc, #336]	; (d75c <system_clock_init+0x1c0>)
    d60a:	6951      	ldr	r1, [r2, #20]
    d60c:	2380      	movs	r3, #128	; 0x80
    d60e:	430b      	orrs	r3, r1
    d610:	6153      	str	r3, [r2, #20]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    d612:	a901      	add	r1, sp, #4
    d614:	2301      	movs	r3, #1
    d616:	604b      	str	r3, [r1, #4]
	config->high_when_disabled = false;
    d618:	2400      	movs	r4, #0
    d61a:	704c      	strb	r4, [r1, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    d61c:	720c      	strb	r4, [r1, #8]
	config->output_enable      = false;
    d61e:	724c      	strb	r4, [r1, #9]
	struct system_gclk_gen_config gclk_conf;
	struct system_clock_source_osc16m_config osc16m_conf;

	/* Select OSCULP32K as new clock source for mainclock temporarily */
	system_gclk_gen_get_config_defaults(&gclk_conf);
	gclk_conf.source_clock = SYSTEM_CLOCK_SOURCE_ULP32K;
    d620:	2503      	movs	r5, #3
    d622:	700d      	strb	r5, [r1, #0]
	system_gclk_gen_set_config(GCLK_GENERATOR_0, &gclk_conf);
    d624:	2000      	movs	r0, #0
    d626:	4b4e      	ldr	r3, [pc, #312]	; (d760 <system_clock_init+0x1c4>)
    d628:	4798      	blx	r3

	/* GCLK0 is enabled after POR */

	/* Disable OSC16M clock*/
	system_clock_source_disable(SYSTEM_CLOCK_SOURCE_OSC16M);
    d62a:	2006      	movs	r0, #6
    d62c:	4b4d      	ldr	r3, [pc, #308]	; (d764 <system_clock_init+0x1c8>)
    d62e:	4798      	blx	r3
		struct system_clock_source_osc16m_config *const config)
{
	Assert(config);

	config->fsel = SYSTEM_OSC16M_4M;
	config->run_in_standby  = false;
    d630:	466b      	mov	r3, sp
    d632:	705c      	strb	r4, [r3, #1]

	/* Switch to new frequency selection and enable OSC16M */
	system_clock_source_osc16m_get_config_defaults(&osc16m_conf);
	osc16m_conf.fsel      		= CONF_CLOCK_OSC16M_FREQ_SEL;
    d634:	701d      	strb	r5, [r3, #0]
	osc16m_conf.on_demand       = 0;
    d636:	709c      	strb	r4, [r3, #2]
	osc16m_conf.run_in_standby  = CONF_CLOCK_OSC16M_RUN_IN_STANDBY;
	system_clock_source_osc16m_set_config(&osc16m_conf);
    d638:	4668      	mov	r0, sp
    d63a:	4b4b      	ldr	r3, [pc, #300]	; (d768 <system_clock_init+0x1cc>)
    d63c:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC16M);
    d63e:	2006      	movs	r0, #6
    d640:	4b45      	ldr	r3, [pc, #276]	; (d758 <system_clock_init+0x1bc>)
    d642:	4798      	blx	r3
	uint32_t mask = 0;

	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC16M:
		mask = OSCCTRL_STATUS_OSC16MRDY;
		return ((OSCCTRL->STATUS.reg & mask) == mask);
    d644:	4940      	ldr	r1, [pc, #256]	; (d748 <system_clock_init+0x1ac>)
	osc16m_conf.fsel      		= CONF_CLOCK_OSC16M_FREQ_SEL;
	osc16m_conf.on_demand       = 0;
	osc16m_conf.run_in_standby  = CONF_CLOCK_OSC16M_RUN_IN_STANDBY;
	system_clock_source_osc16m_set_config(&osc16m_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC16M);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_OSC16M));
    d646:	2210      	movs	r2, #16
	uint32_t mask = 0;

	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC16M:
		mask = OSCCTRL_STATUS_OSC16MRDY;
		return ((OSCCTRL->STATUS.reg & mask) == mask);
    d648:	68cb      	ldr	r3, [r1, #12]
	osc16m_conf.fsel      		= CONF_CLOCK_OSC16M_FREQ_SEL;
	osc16m_conf.on_demand       = 0;
	osc16m_conf.run_in_standby  = CONF_CLOCK_OSC16M_RUN_IN_STANDBY;
	system_clock_source_osc16m_set_config(&osc16m_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC16M);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_OSC16M));
    d64a:	421a      	tst	r2, r3
    d64c:	d0fc      	beq.n	d648 <system_clock_init+0xac>
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    d64e:	a901      	add	r1, sp, #4
    d650:	2301      	movs	r3, #1
    d652:	604b      	str	r3, [r1, #4]
	config->high_when_disabled = false;
    d654:	2400      	movs	r4, #0
    d656:	704c      	strb	r4, [r1, #1]
#if SAML21 || SAML22
	config->source_clock       = GCLK_SOURCE_OSC16M;
    d658:	3305      	adds	r3, #5
    d65a:	700b      	strb	r3, [r1, #0]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    d65c:	720c      	strb	r4, [r1, #8]
	config->output_enable      = false;
    d65e:	724c      	strb	r4, [r1, #9]

	/* Select OSC16M for mainclock again */
	system_gclk_gen_get_config_defaults(&gclk_conf);
	gclk_conf.source_clock = SYSTEM_CLOCK_SOURCE_OSC16M;
	system_gclk_gen_set_config(GCLK_GENERATOR_0, &gclk_conf);
    d660:	2000      	movs	r0, #0
    d662:	4b3f      	ldr	r3, [pc, #252]	; (d760 <system_clock_init+0x1c4>)
    d664:	4798      	blx	r3
	if (CONF_CLOCK_OSC16M_ON_DEMAND){
		OSCCTRL->OSC16MCTRL.reg |= OSCCTRL_OSC16MCTRL_ONDEMAND;
    d666:	4a38      	ldr	r2, [pc, #224]	; (d748 <system_clock_init+0x1ac>)
    d668:	7d11      	ldrb	r1, [r2, #20]
    d66a:	2380      	movs	r3, #128	; 0x80
    d66c:	430b      	orrs	r3, r1
    d66e:	7513      	strb	r3, [r2, #20]
		struct system_clock_source_dfll_config *const config)
{
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
    d670:	ab04      	add	r3, sp, #16
    d672:	2200      	movs	r2, #0
    d674:	809c      	strh	r4, [r3, #4]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
    d676:	80dc      	strh	r4, [r3, #6]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
    d678:	721a      	strb	r2, [r3, #8]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
    d67a:	725a      	strb	r2, [r3, #9]
	config->on_demand       = true;
	config->run_in_stanby   = false;
    d67c:	709a      	strb	r2, [r3, #2]

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
	config->fine_value      = 0xff / 4; /* Midpoint */
    d67e:	213f      	movs	r1, #63	; 0x3f
    d680:	8199      	strh	r1, [r3, #12]
	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
    d682:	393b      	subs	r1, #59	; 0x3b
    d684:	7019      	strb	r1, [r3, #0]
	dfll_conf.on_demand      = false;
    d686:	705a      	strb	r2, [r3, #1]
	/* Using DFLL48M COARSE CAL value from NVM Software Calibration Area Mapping 
	   in DFLL.COARSE helps to output a frequency close to 48 MHz.*/
#define NVM_DFLL_COARSE_POS    26 /* DFLL48M Coarse calibration value bit position.*/
#define NVM_DFLL_COARSE_SIZE   6  /* DFLL48M Coarse calibration value bit size.*/

	uint32_t coarse =( *((uint32_t *)(NVMCTRL_OTP5)
    d688:	4b38      	ldr	r3, [pc, #224]	; (d76c <system_clock_init+0x1d0>)
    d68a:	681b      	ldr	r3, [r3, #0]
    d68c:	0e9b      	lsrs	r3, r3, #26
			+ (NVM_DFLL_COARSE_POS / 32))
		>> (NVM_DFLL_COARSE_POS % 32))
		& ((1 << NVM_DFLL_COARSE_SIZE) - 1);
	/* In some revision chip, the Calibration value is not correct */
	if (coarse == 0x3f) {
    d68e:	2b3f      	cmp	r3, #63	; 0x3f
    d690:	d100      	bne.n	d694 <system_clock_init+0xf8>
		coarse = 0x1f;
    d692:	3b20      	subs	r3, #32
	}

	dfll_conf.coarse_value = coarse;
    d694:	a804      	add	r0, sp, #16
    d696:	7283      	strb	r3, [r0, #10]
#  else
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
#  endif

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
    d698:	4b35      	ldr	r3, [pc, #212]	; (d770 <system_clock_init+0x1d4>)
    d69a:	8243      	strh	r3, [r0, #18]
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
    d69c:	2307      	movs	r3, #7
    d69e:	7383      	strb	r3, [r0, #14]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
    d6a0:	3338      	adds	r3, #56	; 0x38
    d6a2:	8203      	strh	r3, [r0, #16]
		dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;

		dfll_conf.multiply_factor = 48000;
	}

	system_clock_source_dfll_set_config(&dfll_conf);
    d6a4:	4b33      	ldr	r3, [pc, #204]	; (d774 <system_clock_init+0x1d8>)
    d6a6:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    d6a8:	ac01      	add	r4, sp, #4
    d6aa:	2501      	movs	r5, #1
    d6ac:	9502      	str	r5, [sp, #8]
	config->high_when_disabled = false;
    d6ae:	2300      	movs	r3, #0
    d6b0:	7063      	strb	r3, [r4, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    d6b2:	7223      	strb	r3, [r4, #8]
	config->output_enable      = false;
    d6b4:	7263      	strb	r3, [r4, #9]
#if CONF_CLOCK_CONFIGURE_GCLK == true
	//system_gclk_init();

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(GCLK_GEN_NUM, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
    d6b6:	3305      	adds	r3, #5
    d6b8:	7023      	strb	r3, [r4, #0]
    d6ba:	0021      	movs	r1, r4
    d6bc:	2001      	movs	r0, #1
    d6be:	4b28      	ldr	r3, [pc, #160]	; (d760 <system_clock_init+0x1c4>)
    d6c0:	4798      	blx	r3
    d6c2:	2001      	movs	r0, #1
    d6c4:	4b2c      	ldr	r3, [pc, #176]	; (d778 <system_clock_init+0x1dc>)
    d6c6:	4798      	blx	r3
	/* Enable DFLL reference clock if in closed loop mode */
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		struct system_gclk_chan_config dfll_gclk_chan_conf;

		system_gclk_chan_get_config_defaults(&dfll_gclk_chan_conf);
		dfll_gclk_chan_conf.source_generator = CONF_CLOCK_DFLL_SOURCE_GCLK_GENERATOR;
    d6c8:	7025      	strb	r5, [r4, #0]
		system_gclk_chan_set_config(OSCCTRL_GCLK_ID_DFLL48, &dfll_gclk_chan_conf);
    d6ca:	0021      	movs	r1, r4
    d6cc:	2000      	movs	r0, #0
    d6ce:	4b2b      	ldr	r3, [pc, #172]	; (d77c <system_clock_init+0x1e0>)
    d6d0:	4798      	blx	r3
		system_gclk_chan_enable(OSCCTRL_GCLK_ID_DFLL48);
    d6d2:	2000      	movs	r0, #0
    d6d4:	4b2a      	ldr	r3, [pc, #168]	; (d780 <system_clock_init+0x1e4>)
    d6d6:	4798      	blx	r3
#  endif
#endif

	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
    d6d8:	2007      	movs	r0, #7
    d6da:	4b1f      	ldr	r3, [pc, #124]	; (d758 <system_clock_init+0x1bc>)
    d6dc:	4798      	blx	r3
			mask = (OSCCTRL_STATUS_DFLLRDY |
			        OSCCTRL_STATUS_DFLLLCKF | OSCCTRL_STATUS_DFLLLCKC);
		} else {
			mask = OSCCTRL_STATUS_DFLLRDY;
		}
		return ((OSCCTRL->STATUS.reg & mask) == mask);
    d6de:	491a      	ldr	r1, [pc, #104]	; (d748 <system_clock_init+0x1ac>)
#endif

	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
    d6e0:	22d0      	movs	r2, #208	; 0xd0
    d6e2:	0112      	lsls	r2, r2, #4
			mask = (OSCCTRL_STATUS_DFLLRDY |
			        OSCCTRL_STATUS_DFLLLCKF | OSCCTRL_STATUS_DFLLLCKC);
		} else {
			mask = OSCCTRL_STATUS_DFLLRDY;
		}
		return ((OSCCTRL->STATUS.reg & mask) == mask);
    d6e4:	68cb      	ldr	r3, [r1, #12]
#endif

	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
    d6e6:	4013      	ands	r3, r2
    d6e8:	4293      	cmp	r3, r2
    d6ea:	d1fb      	bne.n	d6e4 <system_clock_init+0x148>
 * \param[in] divider  CPU clock divider to set
 */
static inline void system_backup_clock_set_divider(
		const enum system_main_clock_div divider)
{
	MCLK->BUPDIV.reg = MCLK_BUPDIV_BUPDIV(1 << divider);
    d6ec:	4c25      	ldr	r4, [pc, #148]	; (d784 <system_clock_init+0x1e8>)
    d6ee:	2301      	movs	r3, #1
    d6f0:	71a3      	strb	r3, [r4, #6]
 * \param[in] divider  CPU clock divider to set
 */
static inline void system_low_power_clock_set_divider(
		const enum system_main_clock_div divider)
{
	MCLK->LPDIV.reg = MCLK_LPDIV_LPDIV(1 << divider);
    d6f2:	7163      	strb	r3, [r4, #5]
 * \param[in] divider  CPU clock divider to set
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
	MCLK->CPUDIV.reg = MCLK_CPUDIV_CPUDIV(1 << divider);
    d6f4:	7123      	strb	r3, [r4, #4]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    d6f6:	a901      	add	r1, sp, #4
    d6f8:	604b      	str	r3, [r1, #4]
	config->high_when_disabled = false;
    d6fa:	2300      	movs	r3, #0
    d6fc:	704b      	strb	r3, [r1, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    d6fe:	720b      	strb	r3, [r1, #8]
	config->output_enable      = false;
    d700:	724b      	strb	r3, [r1, #9]
	system_main_clock_set_failure_detect(CONF_CLOCK_CPU_CLOCK_FAILURE_DETECT);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    d702:	3307      	adds	r3, #7
    d704:	700b      	strb	r3, [r1, #0]
    d706:	2000      	movs	r0, #0
    d708:	4b15      	ldr	r3, [pc, #84]	; (d760 <system_clock_init+0x1c4>)
    d70a:	4798      	blx	r3
    d70c:	2000      	movs	r0, #0
    d70e:	4b1a      	ldr	r3, [pc, #104]	; (d778 <system_clock_init+0x1dc>)
    d710:	4798      	blx	r3
 *
 * \return Current CPU frequency in Hz.
 */
static inline uint32_t system_cpu_clock_get_hz(void)
{
	return (system_gclk_gen_get_hz(GCLK_GENERATOR_0) >> (MCLK->CPUDIV.reg - 1));
    d712:	2000      	movs	r0, #0
    d714:	4b1c      	ldr	r3, [pc, #112]	; (d788 <system_clock_init+0x1ec>)
    d716:	4798      	blx	r3
    d718:	7923      	ldrb	r3, [r4, #4]
#endif

	/* If CPU frequency is less than 12MHz, scale down performance level to PL0 */
	uint32_t cpu_freq = system_cpu_clock_get_hz();
	if (cpu_freq <= 12000000) {
    d71a:	3b01      	subs	r3, #1
    d71c:	40d8      	lsrs	r0, r3
    d71e:	4b1b      	ldr	r3, [pc, #108]	; (d78c <system_clock_init+0x1f0>)
    d720:	4298      	cmp	r0, r3
    d722:	d80e      	bhi.n	d742 <system_clock_init+0x1a6>
 */
static inline enum status_code system_switch_performance_level(
					const enum system_performance_level performance_level)
{

	if (performance_level == (enum system_performance_level)PM->PLCFG.reg) {
    d724:	2380      	movs	r3, #128	; 0x80
    d726:	05db      	lsls	r3, r3, #23
    d728:	789b      	ldrb	r3, [r3, #2]
    d72a:	2b00      	cmp	r3, #0
    d72c:	d009      	beq.n	d742 <system_clock_init+0x1a6>
		return STATUS_ERR_INVALID_ARG;
	}
#endif

	/* Clear performance level status */
	PM->INTFLAG.reg = PM_INTFLAG_PLRDY;
    d72e:	2380      	movs	r3, #128	; 0x80
    d730:	05db      	lsls	r3, r3, #23
    d732:	2201      	movs	r2, #1
    d734:	719a      	strb	r2, [r3, #6]

	/* Switch performance level */
	PM->PLCFG.reg = performance_level;
    d736:	2200      	movs	r2, #0
    d738:	709a      	strb	r2, [r3, #2]

	/* Waiting performance level ready */
	while (!PM->INTFLAG.reg) {
    d73a:	001a      	movs	r2, r3
    d73c:	7993      	ldrb	r3, [r2, #6]
    d73e:	2b00      	cmp	r3, #0
    d740:	d0fc      	beq.n	d73c <system_clock_init+0x1a0>
		system_switch_performance_level(SYSTEM_PERFORMANCE_LEVEL_0);
	}
}
    d742:	b00d      	add	sp, #52	; 0x34
    d744:	bd30      	pop	{r4, r5, pc}
    d746:	46c0      	nop			; (mov r8, r8)
    d748:	40000c00 	.word	0x40000c00
    d74c:	40001400 	.word	0x40001400
    d750:	41004000 	.word	0x41004000
    d754:	0000d325 	.word	0x0000d325
    d758:	0000d461 	.word	0x0000d461
    d75c:	40001000 	.word	0x40001000
    d760:	0000d791 	.word	0x0000d791
    d764:	0000d51d 	.word	0x0000d51d
    d768:	0000d2ed 	.word	0x0000d2ed
    d76c:	00806020 	.word	0x00806020
    d770:	000005b9 	.word	0x000005b9
    d774:	0000d3d9 	.word	0x0000d3d9
    d778:	0000d83d 	.word	0x0000d83d
    d77c:	0000d959 	.word	0x0000d959
    d780:	0000d8e9 	.word	0x0000d8e9
    d784:	40000400 	.word	0x40000400
    d788:	0000d87d 	.word	0x0000d87d
    d78c:	00b71b00 	.word	0x00b71b00

0000d790 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    d790:	b570      	push	{r4, r5, r6, lr}
    d792:	0005      	movs	r5, r0
	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config ;


	/* Select the requested source clock for the generator */
	new_genctrl_config = config->source_clock << GCLK_GENCTRL_SRC_Pos;
    d794:	780c      	ldrb	r4, [r1, #0]

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    d796:	784b      	ldrb	r3, [r1, #1]
    d798:	2b00      	cmp	r3, #0
    d79a:	d002      	beq.n	d7a2 <system_gclk_gen_set_config+0x12>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    d79c:	2380      	movs	r3, #128	; 0x80
    d79e:	00db      	lsls	r3, r3, #3
    d7a0:	431c      	orrs	r4, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    d7a2:	7a4b      	ldrb	r3, [r1, #9]
    d7a4:	2b00      	cmp	r3, #0
    d7a6:	d002      	beq.n	d7ae <system_gclk_gen_set_config+0x1e>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    d7a8:	2380      	movs	r3, #128	; 0x80
    d7aa:	011b      	lsls	r3, r3, #4
    d7ac:	431c      	orrs	r4, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    d7ae:	684a      	ldr	r2, [r1, #4]
    d7b0:	2a01      	cmp	r2, #1
    d7b2:	d917      	bls.n	d7e4 <system_gclk_gen_set_config+0x54>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    d7b4:	1e53      	subs	r3, r2, #1
    d7b6:	421a      	tst	r2, r3
    d7b8:	d10f      	bne.n	d7da <system_gclk_gen_set_config+0x4a>
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    d7ba:	2a02      	cmp	r2, #2
    d7bc:	d906      	bls.n	d7cc <system_gclk_gen_set_config+0x3c>
    d7be:	2302      	movs	r3, #2
    d7c0:	2000      	movs	r0, #0
						mask <<= 1) {
				div2_count++;
    d7c2:	3001      	adds	r0, #1

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
    d7c4:	005b      	lsls	r3, r3, #1
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    d7c6:	429a      	cmp	r2, r3
    d7c8:	d8fb      	bhi.n	d7c2 <system_gclk_gen_set_config+0x32>
    d7ca:	e000      	b.n	d7ce <system_gclk_gen_set_config+0x3e>
    d7cc:	2000      	movs	r0, #0
    d7ce:	2380      	movs	r3, #128	; 0x80
    d7d0:	015b      	lsls	r3, r3, #5
    d7d2:	431c      	orrs	r4, r3
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_genctrl_config  |= div2_count << GCLK_GENCTRL_DIV_Pos;
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    d7d4:	0400      	lsls	r0, r0, #16
    d7d6:	4304      	orrs	r4, r0
    d7d8:	e004      	b.n	d7e4 <system_gclk_gen_set_config+0x54>

			new_genctrl_config  |=
					(config->division_factor) << GCLK_GENCTRL_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    d7da:	0412      	lsls	r2, r2, #16
    d7dc:	2380      	movs	r3, #128	; 0x80
    d7de:	009b      	lsls	r3, r3, #2
    d7e0:	431a      	orrs	r2, r3
    d7e2:	4314      	orrs	r4, r2
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    d7e4:	7a0b      	ldrb	r3, [r1, #8]
    d7e6:	2b00      	cmp	r3, #0
    d7e8:	d002      	beq.n	d7f0 <system_gclk_gen_set_config+0x60>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    d7ea:	2380      	movs	r3, #128	; 0x80
    d7ec:	019b      	lsls	r3, r3, #6
    d7ee:	431c      	orrs	r4, r3
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    d7f0:	2604      	movs	r6, #4
    d7f2:	40ae      	lsls	r6, r5
    d7f4:	490d      	ldr	r1, [pc, #52]	; (d82c <system_gclk_gen_set_config+0x9c>)
	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
	}

	while (system_gclk_is_syncing(generator)) {
    d7f6:	4a0e      	ldr	r2, [pc, #56]	; (d830 <system_gclk_gen_set_config+0xa0>)
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    d7f8:	684b      	ldr	r3, [r1, #4]
	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
	}

	while (system_gclk_is_syncing(generator)) {
    d7fa:	4013      	ands	r3, r2
    d7fc:	421e      	tst	r6, r3
    d7fe:	d1fb      	bne.n	d7f8 <system_gclk_gen_set_config+0x68>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    d800:	4b0c      	ldr	r3, [pc, #48]	; (d834 <system_gclk_gen_set_config+0xa4>)
    d802:	4798      	blx	r3
    d804:	00ad      	lsls	r5, r5, #2
    d806:	4b09      	ldr	r3, [pc, #36]	; (d82c <system_gclk_gen_set_config+0x9c>)
    d808:	469c      	mov	ip, r3
    d80a:	4465      	add	r5, ip
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();

	GCLK->GENCTRL[generator].reg = new_genctrl_config | (GCLK->GENCTRL[generator].reg & GCLK_GENCTRL_GENEN);
    d80c:	6a28      	ldr	r0, [r5, #32]
    d80e:	2380      	movs	r3, #128	; 0x80
    d810:	005b      	lsls	r3, r3, #1
    d812:	4018      	ands	r0, r3
    d814:	4320      	orrs	r0, r4
    d816:	6228      	str	r0, [r5, #32]
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    d818:	4661      	mov	r1, ip

	system_interrupt_enter_critical_section();

	GCLK->GENCTRL[generator].reg = new_genctrl_config | (GCLK->GENCTRL[generator].reg & GCLK_GENCTRL_GENEN);

	while (system_gclk_is_syncing(generator)) {
    d81a:	4a05      	ldr	r2, [pc, #20]	; (d830 <system_gclk_gen_set_config+0xa0>)
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    d81c:	684b      	ldr	r3, [r1, #4]

	system_interrupt_enter_critical_section();

	GCLK->GENCTRL[generator].reg = new_genctrl_config | (GCLK->GENCTRL[generator].reg & GCLK_GENCTRL_GENEN);

	while (system_gclk_is_syncing(generator)) {
    d81e:	4013      	ands	r3, r2
    d820:	421e      	tst	r6, r3
    d822:	d1fb      	bne.n	d81c <system_gclk_gen_set_config+0x8c>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    d824:	4b04      	ldr	r3, [pc, #16]	; (d838 <system_gclk_gen_set_config+0xa8>)
    d826:	4798      	blx	r3
		/* Wait for synchronization */
	};

	system_interrupt_leave_critical_section();
}
    d828:	bd70      	pop	{r4, r5, r6, pc}
    d82a:	46c0      	nop			; (mov r8, r8)
    d82c:	40001800 	.word	0x40001800
    d830:	000007fc 	.word	0x000007fc
    d834:	0000c521 	.word	0x0000c521
    d838:	0000c561 	.word	0x0000c561

0000d83c <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    d83c:	b510      	push	{r4, lr}
    d83e:	0004      	movs	r4, r0
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    d840:	2204      	movs	r2, #4
    d842:	4082      	lsls	r2, r0
    d844:	4809      	ldr	r0, [pc, #36]	; (d86c <system_gclk_gen_enable+0x30>)
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
	while (system_gclk_is_syncing(generator)) {
    d846:	490a      	ldr	r1, [pc, #40]	; (d870 <system_gclk_gen_enable+0x34>)
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    d848:	6843      	ldr	r3, [r0, #4]
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
	while (system_gclk_is_syncing(generator)) {
    d84a:	400b      	ands	r3, r1
    d84c:	421a      	tst	r2, r3
    d84e:	d1fb      	bne.n	d848 <system_gclk_gen_enable+0xc>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    d850:	4b08      	ldr	r3, [pc, #32]	; (d874 <system_gclk_gen_enable+0x38>)
    d852:	4798      	blx	r3
    d854:	00a4      	lsls	r4, r4, #2
    d856:	4b05      	ldr	r3, [pc, #20]	; (d86c <system_gclk_gen_enable+0x30>)
    d858:	469c      	mov	ip, r3
    d85a:	4464      	add	r4, ip
	};

	system_interrupt_enter_critical_section();

	/* Enable generator */
	GCLK->GENCTRL[generator].reg |= GCLK_GENCTRL_GENEN;
    d85c:	6a23      	ldr	r3, [r4, #32]
    d85e:	2280      	movs	r2, #128	; 0x80
    d860:	0052      	lsls	r2, r2, #1
    d862:	4313      	orrs	r3, r2
    d864:	6223      	str	r3, [r4, #32]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    d866:	4b04      	ldr	r3, [pc, #16]	; (d878 <system_gclk_gen_enable+0x3c>)
    d868:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    d86a:	bd10      	pop	{r4, pc}
    d86c:	40001800 	.word	0x40001800
    d870:	000007fc 	.word	0x000007fc
    d874:	0000c521 	.word	0x0000c521
    d878:	0000c561 	.word	0x0000c561

0000d87c <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
    d87c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d87e:	0004      	movs	r4, r0
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    d880:	2204      	movs	r2, #4
    d882:	4082      	lsls	r2, r0
    d884:	4812      	ldr	r0, [pc, #72]	; (d8d0 <system_gclk_gen_get_hz+0x54>)
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
	while (system_gclk_is_syncing(generator)) {
    d886:	4913      	ldr	r1, [pc, #76]	; (d8d4 <system_gclk_gen_get_hz+0x58>)
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    d888:	6843      	ldr	r3, [r0, #4]
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
	while (system_gclk_is_syncing(generator)) {
    d88a:	400b      	ands	r3, r1
    d88c:	421a      	tst	r2, r3
    d88e:	d1fb      	bne.n	d888 <system_gclk_gen_get_hz+0xc>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    d890:	4b11      	ldr	r3, [pc, #68]	; (d8d8 <system_gclk_gen_get_hz+0x5c>)
    d892:	4798      	blx	r3

	system_interrupt_enter_critical_section();

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL[generator].bit.SRC);
    d894:	4f0e      	ldr	r7, [pc, #56]	; (d8d0 <system_gclk_gen_get_hz+0x54>)
    d896:	3408      	adds	r4, #8
    d898:	00a4      	lsls	r4, r4, #2
    d89a:	59e0      	ldr	r0, [r4, r7]
    d89c:	0700      	lsls	r0, r0, #28
    d89e:	0f00      	lsrs	r0, r0, #28
	};

	system_interrupt_enter_critical_section();

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
    d8a0:	4b0e      	ldr	r3, [pc, #56]	; (d8dc <system_gclk_gen_get_hz+0x60>)
    d8a2:	4798      	blx	r3
    d8a4:	0006      	movs	r6, r0
			(enum system_clock_source)GCLK->GENCTRL[generator].bit.SRC);

	uint8_t divsel = GCLK->GENCTRL[generator].bit.DIVSEL;
    d8a6:	59e5      	ldr	r5, [r4, r7]
    d8a8:	04ed      	lsls	r5, r5, #19
    d8aa:	0fed      	lsrs	r5, r5, #31
	uint32_t divider = GCLK->GENCTRL[generator].bit.DIV;
    d8ac:	59e4      	ldr	r4, [r4, r7]
    d8ae:	0c24      	lsrs	r4, r4, #16
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    d8b0:	4b0b      	ldr	r3, [pc, #44]	; (d8e0 <system_gclk_gen_get_hz+0x64>)
    d8b2:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    d8b4:	2d00      	cmp	r5, #0
    d8b6:	d107      	bne.n	d8c8 <system_gclk_gen_get_hz+0x4c>
    d8b8:	2c01      	cmp	r4, #1
    d8ba:	d907      	bls.n	d8cc <system_gclk_gen_get_hz+0x50>
		gen_input_hz /= divider;
    d8bc:	0021      	movs	r1, r4
    d8be:	0030      	movs	r0, r6
    d8c0:	4b08      	ldr	r3, [pc, #32]	; (d8e4 <system_gclk_gen_get_hz+0x68>)
    d8c2:	4798      	blx	r3
    d8c4:	0006      	movs	r6, r0
    d8c6:	e001      	b.n	d8cc <system_gclk_gen_get_hz+0x50>
	} else if (divsel) {
		gen_input_hz >>= (divider+1);
    d8c8:	3401      	adds	r4, #1
    d8ca:	40e6      	lsrs	r6, r4
	}

	return gen_input_hz;
}
    d8cc:	0030      	movs	r0, r6
    d8ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    d8d0:	40001800 	.word	0x40001800
    d8d4:	000007fc 	.word	0x000007fc
    d8d8:	0000c521 	.word	0x0000c521
    d8dc:	0000d259 	.word	0x0000d259
    d8e0:	0000c561 	.word	0x0000c561
    d8e4:	0000f82d 	.word	0x0000f82d

0000d8e8 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    d8e8:	b510      	push	{r4, lr}
    d8ea:	0004      	movs	r4, r0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    d8ec:	4b09      	ldr	r3, [pc, #36]	; (d914 <system_gclk_chan_enable+0x2c>)
    d8ee:	4798      	blx	r3
    d8f0:	00a0      	lsls	r0, r4, #2
    d8f2:	4b09      	ldr	r3, [pc, #36]	; (d918 <system_gclk_chan_enable+0x30>)
    d8f4:	469c      	mov	ip, r3
    d8f6:	4460      	add	r0, ip
	system_interrupt_enter_critical_section();

	/* Enable the peripheral channel */
	GCLK->PCHCTRL[channel].reg |= GCLK_PCHCTRL_CHEN;
    d8f8:	2280      	movs	r2, #128	; 0x80
    d8fa:	5881      	ldr	r1, [r0, r2]
    d8fc:	2340      	movs	r3, #64	; 0x40
    d8fe:	430b      	orrs	r3, r1
    d900:	5083      	str	r3, [r0, r2]

	while (!(GCLK->PCHCTRL[channel].reg & GCLK_PCHCTRL_CHEN)) {
    d902:	2180      	movs	r1, #128	; 0x80
    d904:	3a40      	subs	r2, #64	; 0x40
    d906:	5843      	ldr	r3, [r0, r1]
    d908:	421a      	tst	r2, r3
    d90a:	d0fc      	beq.n	d906 <system_gclk_chan_enable+0x1e>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    d90c:	4b03      	ldr	r3, [pc, #12]	; (d91c <system_gclk_chan_enable+0x34>)
    d90e:	4798      	blx	r3
		/* Wait for clock synchronization */
	}

	system_interrupt_leave_critical_section();
}
    d910:	bd10      	pop	{r4, pc}
    d912:	46c0      	nop			; (mov r8, r8)
    d914:	0000c521 	.word	0x0000c521
    d918:	40001800 	.word	0x40001800
    d91c:	0000c561 	.word	0x0000c561

0000d920 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    d920:	b510      	push	{r4, lr}
    d922:	0004      	movs	r4, r0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    d924:	4b09      	ldr	r3, [pc, #36]	; (d94c <system_gclk_chan_disable+0x2c>)
    d926:	4798      	blx	r3
    d928:	00a0      	lsls	r0, r4, #2
    d92a:	4b09      	ldr	r3, [pc, #36]	; (d950 <system_gclk_chan_disable+0x30>)
    d92c:	469c      	mov	ip, r3
    d92e:	4460      	add	r0, ip

	/* Sanity check WRTLOCK */
	Assert(!GCLK->PCHCTRL[channel].bit.WRTLOCK);

	/* Disable the peripheral channel */
	GCLK->PCHCTRL[channel].reg &= ~GCLK_PCHCTRL_CHEN;
    d930:	2280      	movs	r2, #128	; 0x80
    d932:	5883      	ldr	r3, [r0, r2]
    d934:	2140      	movs	r1, #64	; 0x40
    d936:	438b      	bics	r3, r1
    d938:	5083      	str	r3, [r0, r2]

	while (GCLK->PCHCTRL[channel].reg & GCLK_PCHCTRL_CHEN) {
    d93a:	3140      	adds	r1, #64	; 0x40
    d93c:	3a40      	subs	r2, #64	; 0x40
    d93e:	5843      	ldr	r3, [r0, r1]
    d940:	421a      	tst	r2, r3
    d942:	d1fc      	bne.n	d93e <system_gclk_chan_disable+0x1e>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    d944:	4b03      	ldr	r3, [pc, #12]	; (d954 <system_gclk_chan_disable+0x34>)
    d946:	4798      	blx	r3
		/* Wait for clock synchronization */
	}

	system_interrupt_leave_critical_section();
}
    d948:	bd10      	pop	{r4, pc}
    d94a:	46c0      	nop			; (mov r8, r8)
    d94c:	0000c521 	.word	0x0000c521
    d950:	40001800 	.word	0x40001800
    d954:	0000c561 	.word	0x0000c561

0000d958 <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
    d958:	b570      	push	{r4, r5, r6, lr}
    d95a:	0004      	movs	r4, r0
    d95c:	000d      	movs	r5, r1
	/* Sanity check arguments */
	Assert(config);

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
    d95e:	4b05      	ldr	r3, [pc, #20]	; (d974 <system_gclk_chan_set_config+0x1c>)
    d960:	4798      	blx	r3

	/* Configure the peripheral channel */
	GCLK->PCHCTRL[channel].reg = GCLK_PCHCTRL_GEN(config->source_generator);
    d962:	782b      	ldrb	r3, [r5, #0]
    d964:	220f      	movs	r2, #15
    d966:	4013      	ands	r3, r2
    d968:	3420      	adds	r4, #32
    d96a:	00a4      	lsls	r4, r4, #2
    d96c:	4a02      	ldr	r2, [pc, #8]	; (d978 <system_gclk_chan_set_config+0x20>)
    d96e:	50a3      	str	r3, [r4, r2]


}
    d970:	bd70      	pop	{r4, r5, r6, pc}
    d972:	46c0      	nop			; (mov r8, r8)
    d974:	0000d921 	.word	0x0000d921
    d978:	40001800 	.word	0x40001800

0000d97c <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    d97c:	b510      	push	{r4, lr}
    d97e:	0004      	movs	r4, r0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    d980:	4b06      	ldr	r3, [pc, #24]	; (d99c <system_gclk_chan_get_hz+0x20>)
    d982:	4798      	blx	r3
	uint8_t gen_id;

	system_interrupt_enter_critical_section();
	/* Select the requested generic clock channel */
	gen_id = GCLK->PCHCTRL[channel].bit.GEN;
    d984:	3420      	adds	r4, #32
    d986:	00a4      	lsls	r4, r4, #2
    d988:	4b05      	ldr	r3, [pc, #20]	; (d9a0 <system_gclk_chan_get_hz+0x24>)
    d98a:	58e4      	ldr	r4, [r4, r3]
    d98c:	0724      	lsls	r4, r4, #28
    d98e:	0f24      	lsrs	r4, r4, #28
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    d990:	4b04      	ldr	r3, [pc, #16]	; (d9a4 <system_gclk_chan_get_hz+0x28>)
    d992:	4798      	blx	r3
	system_interrupt_leave_critical_section();

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
    d994:	0020      	movs	r0, r4
    d996:	4b04      	ldr	r3, [pc, #16]	; (d9a8 <system_gclk_chan_get_hz+0x2c>)
    d998:	4798      	blx	r3
}
    d99a:	bd10      	pop	{r4, pc}
    d99c:	0000c521 	.word	0x0000c521
    d9a0:	40001800 	.word	0x40001800
    d9a4:	0000c561 	.word	0x0000c561
    d9a8:	0000d87d 	.word	0x0000d87d

0000d9ac <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    d9ac:	b530      	push	{r4, r5, lr}

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    d9ae:	78d3      	ldrb	r3, [r2, #3]
    d9b0:	2b00      	cmp	r3, #0
    d9b2:	d11e      	bne.n	d9f2 <_system_pinmux_config+0x46>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    d9b4:	7813      	ldrb	r3, [r2, #0]
    d9b6:	2b80      	cmp	r3, #128	; 0x80
    d9b8:	d004      	beq.n	d9c4 <_system_pinmux_config+0x18>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    d9ba:	061b      	lsls	r3, r3, #24
    d9bc:	2480      	movs	r4, #128	; 0x80
    d9be:	0264      	lsls	r4, r4, #9
    d9c0:	4323      	orrs	r3, r4
    d9c2:	e000      	b.n	d9c6 <_system_pinmux_config+0x1a>
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    d9c4:	2300      	movs	r3, #0
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    d9c6:	7854      	ldrb	r4, [r2, #1]
    d9c8:	2502      	movs	r5, #2
    d9ca:	43ac      	bics	r4, r5
    d9cc:	d10a      	bne.n	d9e4 <_system_pinmux_config+0x38>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    d9ce:	7894      	ldrb	r4, [r2, #2]
    d9d0:	2c00      	cmp	r4, #0
    d9d2:	d103      	bne.n	d9dc <_system_pinmux_config+0x30>

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
    d9d4:	2480      	movs	r4, #128	; 0x80
    d9d6:	02a4      	lsls	r4, r4, #10
    d9d8:	4323      	orrs	r3, r4
    d9da:	e002      	b.n	d9e2 <_system_pinmux_config+0x36>

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    d9dc:	24c0      	movs	r4, #192	; 0xc0
    d9de:	02e4      	lsls	r4, r4, #11
    d9e0:	4323      	orrs	r3, r4
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    d9e2:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    d9e4:	7854      	ldrb	r4, [r2, #1]
    d9e6:	3c01      	subs	r4, #1
    d9e8:	2c01      	cmp	r4, #1
    d9ea:	d812      	bhi.n	da12 <_system_pinmux_config+0x66>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    d9ec:	4c18      	ldr	r4, [pc, #96]	; (da50 <_system_pinmux_config+0xa4>)
    d9ee:	4023      	ands	r3, r4
    d9f0:	e00f      	b.n	da12 <_system_pinmux_config+0x66>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
    d9f2:	6041      	str	r1, [r0, #4]

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    d9f4:	040b      	lsls	r3, r1, #16
    d9f6:	0c1b      	lsrs	r3, r3, #16
    d9f8:	24a0      	movs	r4, #160	; 0xa0
    d9fa:	05e4      	lsls	r4, r4, #23
    d9fc:	4323      	orrs	r3, r4
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    d9fe:	6283      	str	r3, [r0, #40]	; 0x28

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    da00:	0c0b      	lsrs	r3, r1, #16
    da02:	24d0      	movs	r4, #208	; 0xd0
    da04:	0624      	lsls	r4, r4, #24
    da06:	4323      	orrs	r3, r4
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    da08:	6283      	str	r3, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    da0a:	78d3      	ldrb	r3, [r2, #3]
    da0c:	2b00      	cmp	r3, #0
    da0e:	d018      	beq.n	da42 <_system_pinmux_config+0x96>
    da10:	e01c      	b.n	da4c <_system_pinmux_config+0xa0>

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    da12:	040c      	lsls	r4, r1, #16
    da14:	0c24      	lsrs	r4, r4, #16
    da16:	25a0      	movs	r5, #160	; 0xa0
    da18:	05ed      	lsls	r5, r5, #23
    da1a:	432c      	orrs	r4, r5
    da1c:	431c      	orrs	r4, r3
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    da1e:	6284      	str	r4, [r0, #40]	; 0x28

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    da20:	0c0c      	lsrs	r4, r1, #16
    da22:	25d0      	movs	r5, #208	; 0xd0
    da24:	062d      	lsls	r5, r5, #24
    da26:	432c      	orrs	r4, r5
    da28:	431c      	orrs	r4, r3
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    da2a:	6284      	str	r4, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    da2c:	78d4      	ldrb	r4, [r2, #3]
    da2e:	2c00      	cmp	r4, #0
    da30:	d10c      	bne.n	da4c <_system_pinmux_config+0xa0>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    da32:	035b      	lsls	r3, r3, #13
    da34:	d505      	bpl.n	da42 <_system_pinmux_config+0x96>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    da36:	7893      	ldrb	r3, [r2, #2]
    da38:	2b01      	cmp	r3, #1
    da3a:	d101      	bne.n	da40 <_system_pinmux_config+0x94>
				port->OUTSET.reg = pin_mask;
    da3c:	6181      	str	r1, [r0, #24]
    da3e:	e000      	b.n	da42 <_system_pinmux_config+0x96>
			} else {
				port->OUTCLR.reg = pin_mask;
    da40:	6141      	str	r1, [r0, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    da42:	7853      	ldrb	r3, [r2, #1]
    da44:	3b01      	subs	r3, #1
    da46:	2b01      	cmp	r3, #1
    da48:	d800      	bhi.n	da4c <_system_pinmux_config+0xa0>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    da4a:	6081      	str	r1, [r0, #8]
		}
	}
}
    da4c:	bd30      	pop	{r4, r5, pc}
    da4e:	46c0      	nop			; (mov r8, r8)
    da50:	fffbffff 	.word	0xfffbffff

0000da54 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    da54:	b510      	push	{r4, lr}
    da56:	0003      	movs	r3, r0
    da58:	000a      	movs	r2, r1
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    da5a:	09c1      	lsrs	r1, r0, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    da5c:	2000      	movs	r0, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    da5e:	2900      	cmp	r1, #0
    da60:	d104      	bne.n	da6c <system_pinmux_pin_set_config+0x18>
		return &(ports[port_index]->Group[group_index]);
    da62:	0958      	lsrs	r0, r3, #5
    da64:	01c0      	lsls	r0, r0, #7
    da66:	4905      	ldr	r1, [pc, #20]	; (da7c <system_pinmux_pin_set_config+0x28>)
    da68:	468c      	mov	ip, r1
    da6a:	4460      	add	r0, ip
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));

	_system_pinmux_config(port, pin_mask, config);
    da6c:	211f      	movs	r1, #31
    da6e:	400b      	ands	r3, r1
    da70:	391e      	subs	r1, #30
    da72:	4099      	lsls	r1, r3
    da74:	4b02      	ldr	r3, [pc, #8]	; (da80 <system_pinmux_pin_set_config+0x2c>)
    da76:	4798      	blx	r3
}
    da78:	bd10      	pop	{r4, pc}
    da7a:	46c0      	nop			; (mov r8, r8)
    da7c:	40002800 	.word	0x40002800
    da80:	0000d9ad 	.word	0x0000d9ad

0000da84 <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
    da84:	4770      	bx	lr
    da86:	46c0      	nop			; (mov r8, r8)

0000da88 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    da88:	b510      	push	{r4, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    da8a:	4b04      	ldr	r3, [pc, #16]	; (da9c <system_init+0x14>)
    da8c:	4798      	blx	r3

	/* Initialize board hardware */
	//system_board_init();

	/* Initialize EVSYS hardware */
	_system_events_init();
    da8e:	4b04      	ldr	r3, [pc, #16]	; (daa0 <system_init+0x18>)
    da90:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    da92:	4b04      	ldr	r3, [pc, #16]	; (daa4 <system_init+0x1c>)
    da94:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
    da96:	4b04      	ldr	r3, [pc, #16]	; (daa8 <system_init+0x20>)
    da98:	4798      	blx	r3
}
    da9a:	bd10      	pop	{r4, pc}
    da9c:	0000d59d 	.word	0x0000d59d
    daa0:	0000c1e9 	.word	0x0000c1e9
    daa4:	0000c6a5 	.word	0x0000c6a5
    daa8:	0000da85 	.word	0x0000da85

0000daac <tc_register_callback>:
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
    daac:	1c93      	adds	r3, r2, #2
    daae:	009b      	lsls	r3, r3, #2
    dab0:	5019      	str	r1, [r3, r0]

	/* Set the bit corresponding to the callback_type */
	if (callback_type == TC_CALLBACK_CC_CHANNEL0) {
    dab2:	2a02      	cmp	r2, #2
    dab4:	d104      	bne.n	dac0 <tc_register_callback+0x14>
		module->register_callback_mask |= TC_INTFLAG_MC(1);
    dab6:	7e02      	ldrb	r2, [r0, #24]
    dab8:	2310      	movs	r3, #16
    daba:	4313      	orrs	r3, r2
    dabc:	7603      	strb	r3, [r0, #24]
    dabe:	e00b      	b.n	dad8 <tc_register_callback+0x2c>
	}
	else if (callback_type == TC_CALLBACK_CC_CHANNEL1) {
    dac0:	2a03      	cmp	r2, #3
    dac2:	d104      	bne.n	dace <tc_register_callback+0x22>
		module->register_callback_mask |= TC_INTFLAG_MC(2);
    dac4:	7e02      	ldrb	r2, [r0, #24]
    dac6:	2320      	movs	r3, #32
    dac8:	4313      	orrs	r3, r2
    daca:	7603      	strb	r3, [r0, #24]
    dacc:	e004      	b.n	dad8 <tc_register_callback+0x2c>
	}
	else {
		module->register_callback_mask |= (1 << callback_type);
    dace:	2301      	movs	r3, #1
    dad0:	4093      	lsls	r3, r2
    dad2:	7e02      	ldrb	r2, [r0, #24]
    dad4:	4313      	orrs	r3, r2
    dad6:	7603      	strb	r3, [r0, #24]
	}
	return STATUS_OK;
}
    dad8:	2000      	movs	r0, #0
    dada:	4770      	bx	lr

0000dadc <_tc_interrupt_handler>:
 * \param[in]  instance  ID of the TC instance calling the interrupt
 *                       handler
 */
void _tc_interrupt_handler(
		uint8_t instance)
{
    dadc:	b570      	push	{r4, r5, r6, lr}
	/* Temporary variable */
	uint8_t interrupt_and_callback_status_mask;

	/* Get device instance from the look-up table */
	struct tc_module *module
    dade:	0080      	lsls	r0, r0, #2
    dae0:	4b14      	ldr	r3, [pc, #80]	; (db34 <_tc_interrupt_handler+0x58>)
    dae2:	58c5      	ldr	r5, [r0, r3]
			= (struct tc_module *)_tc_instances[instance];

	/* Read and mask interrupt flag register */
	interrupt_and_callback_status_mask = module->hw->COUNT8.INTFLAG.reg &
    dae4:	682b      	ldr	r3, [r5, #0]
    dae6:	7a9c      	ldrb	r4, [r3, #10]
    dae8:	7e2b      	ldrb	r3, [r5, #24]
    daea:	401c      	ands	r4, r3
    daec:	7e6b      	ldrb	r3, [r5, #25]
    daee:	401c      	ands	r4, r3
			module->register_callback_mask &
			module->enable_callback_mask;

	/* Check if an Overflow interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_OVF) {
    daf0:	07e3      	lsls	r3, r4, #31
    daf2:	d505      	bpl.n	db00 <_tc_interrupt_handler+0x24>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_OVERFLOW])(module);
    daf4:	0028      	movs	r0, r5
    daf6:	68ab      	ldr	r3, [r5, #8]
    daf8:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_OVF;
    dafa:	2301      	movs	r3, #1
    dafc:	682a      	ldr	r2, [r5, #0]
    dafe:	7293      	strb	r3, [r2, #10]
	}

	/* Check if an Error interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_ERR) {
    db00:	07a3      	lsls	r3, r4, #30
    db02:	d505      	bpl.n	db10 <_tc_interrupt_handler+0x34>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_ERROR])(module);
    db04:	0028      	movs	r0, r5
    db06:	68eb      	ldr	r3, [r5, #12]
    db08:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_ERR;
    db0a:	2302      	movs	r3, #2
    db0c:	682a      	ldr	r2, [r5, #0]
    db0e:	7293      	strb	r3, [r2, #10]
	}

	/* Check if an Match/Capture Channel 0 interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_MC(1)) {
    db10:	06e3      	lsls	r3, r4, #27
    db12:	d505      	bpl.n	db20 <_tc_interrupt_handler+0x44>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_CC_CHANNEL0])(module);
    db14:	0028      	movs	r0, r5
    db16:	692b      	ldr	r3, [r5, #16]
    db18:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_MC(1);
    db1a:	2310      	movs	r3, #16
    db1c:	682a      	ldr	r2, [r5, #0]
    db1e:	7293      	strb	r3, [r2, #10]
	}

	/* Check if an Match/Capture Channel 1 interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_MC(2)) {
    db20:	06a3      	lsls	r3, r4, #26
    db22:	d505      	bpl.n	db30 <_tc_interrupt_handler+0x54>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_CC_CHANNEL1])(module);
    db24:	0028      	movs	r0, r5
    db26:	696b      	ldr	r3, [r5, #20]
    db28:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_MC(2);
    db2a:	682b      	ldr	r3, [r5, #0]
    db2c:	2220      	movs	r2, #32
    db2e:	729a      	strb	r2, [r3, #10]
	}
}
    db30:	bd70      	pop	{r4, r5, r6, pc}
    db32:	46c0      	nop			; (mov r8, r8)
    db34:	20002868 	.word	0x20002868

0000db38 <TC0_Handler>:
		{ \
			_tc_interrupt_handler(m); \
		}

#if (SAML21E) || (SAML21G)
	_TC_INTERRUPT_HANDLER(0,0)
    db38:	b510      	push	{r4, lr}
    db3a:	2000      	movs	r0, #0
    db3c:	4b01      	ldr	r3, [pc, #4]	; (db44 <TC0_Handler+0xc>)
    db3e:	4798      	blx	r3
    db40:	bd10      	pop	{r4, pc}
    db42:	46c0      	nop			; (mov r8, r8)
    db44:	0000dadd 	.word	0x0000dadd

0000db48 <TC1_Handler>:
	_TC_INTERRUPT_HANDLER(1,1)
    db48:	b510      	push	{r4, lr}
    db4a:	2001      	movs	r0, #1
    db4c:	4b01      	ldr	r3, [pc, #4]	; (db54 <TC1_Handler+0xc>)
    db4e:	4798      	blx	r3
    db50:	bd10      	pop	{r4, pc}
    db52:	46c0      	nop			; (mov r8, r8)
    db54:	0000dadd 	.word	0x0000dadd

0000db58 <TC4_Handler>:
	_TC_INTERRUPT_HANDLER(4,2)
    db58:	b510      	push	{r4, lr}
    db5a:	2002      	movs	r0, #2
    db5c:	4b01      	ldr	r3, [pc, #4]	; (db64 <TC4_Handler+0xc>)
    db5e:	4798      	blx	r3
    db60:	bd10      	pop	{r4, pc}
    db62:	46c0      	nop			; (mov r8, r8)
    db64:	0000dadd 	.word	0x0000dadd

0000db68 <_tc_get_inst_index>:
 *
 * \return Index of the given TC module instance.
 */
uint8_t _tc_get_inst_index(
		Tc *const hw)
{
    db68:	b530      	push	{r4, r5, lr}
    db6a:	b085      	sub	sp, #20
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
    db6c:	aa01      	add	r2, sp, #4
    db6e:	4b0b      	ldr	r3, [pc, #44]	; (db9c <_tc_get_inst_index+0x34>)
    db70:	cb32      	ldmia	r3!, {r1, r4, r5}
    db72:	c232      	stmia	r2!, {r1, r4, r5}

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
		if (hw == tc_modules[i]) {
    db74:	9b01      	ldr	r3, [sp, #4]
    db76:	4298      	cmp	r0, r3
    db78:	d00a      	beq.n	db90 <_tc_get_inst_index+0x28>
    db7a:	9b02      	ldr	r3, [sp, #8]
    db7c:	4298      	cmp	r0, r3
    db7e:	d005      	beq.n	db8c <_tc_get_inst_index+0x24>
		}
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
    db80:	2300      	movs	r3, #0
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
		if (hw == tc_modules[i]) {
    db82:	9a03      	ldr	r2, [sp, #12]
    db84:	4282      	cmp	r2, r0
    db86:	d105      	bne.n	db94 <_tc_get_inst_index+0x2c>
{
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    db88:	3302      	adds	r3, #2
    db8a:	e002      	b.n	db92 <_tc_get_inst_index+0x2a>
    db8c:	2301      	movs	r3, #1
    db8e:	e000      	b.n	db92 <_tc_get_inst_index+0x2a>
    db90:	2300      	movs	r3, #0
		if (hw == tc_modules[i]) {
			return i;
    db92:	b2db      	uxtb	r3, r3
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
}
    db94:	0018      	movs	r0, r3
    db96:	b005      	add	sp, #20
    db98:	bd30      	pop	{r4, r5, pc}
    db9a:	46c0      	nop			; (mov r8, r8)
    db9c:	0001bee4 	.word	0x0001bee4

0000dba0 <tc_init>:
 */
enum status_code tc_init(
		struct tc_module *const module_inst,
		Tc *const hw,
		const struct tc_config *const config)
{
    dba0:	b5f0      	push	{r4, r5, r6, r7, lr}
    dba2:	4647      	mov	r7, r8
    dba4:	b480      	push	{r7}
    dba6:	b08a      	sub	sp, #40	; 0x28
    dba8:	0005      	movs	r5, r0
    dbaa:	000e      	movs	r6, r1
    dbac:	0017      	movs	r7, r2
	uint32_t ctrla_tmp = 0;
	/* Temporary variable to hold all updates to the CTRLBSET
	 * register before they are written to it */
	uint8_t ctrlbset_tmp = 0;
	/* Temporary variable to hold TC instance number */
	uint8_t instance = _tc_get_inst_index(hw);
    dbae:	0008      	movs	r0, r1
    dbb0:	4ba6      	ldr	r3, [pc, #664]	; (de4c <tc_init+0x2ac>)
    dbb2:	4798      	blx	r3
    dbb4:	4680      	mov	r8, r0
									SYSTEM_CLOCK_APB_APBC, MCLK_APBCMASK_TC1,
									SYSTEM_CLOCK_APB_APBC, MCLK_APBCMASK_TC2,
									SYSTEM_CLOCK_APB_APBC, MCLK_APBCMASK_TC3};
#else
	/* Array of GLCK ID for different TC instances */
	uint8_t inst_gclk_id[] = {TC0_GCLK_ID, TC1_GCLK_ID, TC4_GCLK_ID};
    dbb6:	4ca6      	ldr	r4, [pc, #664]	; (de50 <tc_init+0x2b0>)
    dbb8:	0021      	movs	r1, r4
    dbba:	310c      	adds	r1, #12
    dbbc:	2203      	movs	r2, #3
    dbbe:	a809      	add	r0, sp, #36	; 0x24
    dbc0:	4ba4      	ldr	r3, [pc, #656]	; (de54 <tc_init+0x2b4>)
    dbc2:	4798      	blx	r3
	/* Array of PM APB mask bit position for different TC instances */
	uint32_t inst_mclk_apbmask[] = {SYSTEM_CLOCK_APB_APBC, MCLK_APBCMASK_TC0,
    dbc4:	a903      	add	r1, sp, #12
    dbc6:	0023      	movs	r3, r4
    dbc8:	3310      	adds	r3, #16
    dbca:	000a      	movs	r2, r1
    dbcc:	cb13      	ldmia	r3!, {r0, r1, r4}
    dbce:	c213      	stmia	r2!, {r0, r1, r4}
    dbd0:	cb13      	ldmia	r3!, {r0, r1, r4}
    dbd2:	c213      	stmia	r2!, {r0, r1, r4}
	struct system_gclk_chan_config gclk_chan_config;

#if TC_ASYNC == true
	/* Initialize parameters */
	for (uint8_t i = 0; i < TC_CALLBACK_N; i++) {
		module_inst->callback[i]        = NULL;
    dbd4:	2300      	movs	r3, #0
    dbd6:	60ab      	str	r3, [r5, #8]
    dbd8:	60eb      	str	r3, [r5, #12]
    dbda:	612b      	str	r3, [r5, #16]
    dbdc:	616b      	str	r3, [r5, #20]
	}
	module_inst->register_callback_mask     = 0x00;
    dbde:	762b      	strb	r3, [r5, #24]
	module_inst->enable_callback_mask       = 0x00;
    dbe0:	766b      	strb	r3, [r5, #25]

	/* Register this instance for callbacks*/
	_tc_instances[instance] = module_inst;
    dbe2:	4643      	mov	r3, r8
    dbe4:	009a      	lsls	r2, r3, #2
    dbe6:	4b9c      	ldr	r3, [pc, #624]	; (de58 <tc_init+0x2b8>)
    dbe8:	50d5      	str	r5, [r2, r3]
#endif

	/* Associate the given device instance with the hardware module */
	module_inst->hw = hw;
    dbea:	602e      	str	r6, [r5, #0]

	module_inst->double_buffering_enabled = config->double_buffering_enabled;
    dbec:	2334      	movs	r3, #52	; 0x34
    dbee:	5cfb      	ldrb	r3, [r7, r3]
    dbf0:	76ab      	strb	r3, [r5, #26]

	/* Check if odd numbered TC modules are being configured in 32-bit
	 * counter size. Only even numbered counters are allowed to be
	 * configured in 32-bit counter size.
	 */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT) &&
    dbf2:	78fb      	ldrb	r3, [r7, #3]
    dbf4:	2b08      	cmp	r3, #8
    dbf6:	d104      	bne.n	dc02 <tc_init+0x62>
			((instance + TC_INSTANCE_OFFSET) & 0x01)) {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    dbf8:	2017      	movs	r0, #23

	/* Check if odd numbered TC modules are being configured in 32-bit
	 * counter size. Only even numbered counters are allowed to be
	 * configured in 32-bit counter size.
	 */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT) &&
    dbfa:	4642      	mov	r2, r8
    dbfc:	07d2      	lsls	r2, r2, #31
    dbfe:	d500      	bpl.n	dc02 <tc_init+0x62>
    dc00:	e11f      	b.n	de42 <tc_init+0x2a2>
	}

	/* Make the counter size variable in the module_inst struct reflect
	 * the counter size in the module
	 */
	module_inst->counter_size = config->counter_size;
    dc02:	712b      	strb	r3, [r5, #4]

	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_SWRST) {
    dc04:	6833      	ldr	r3, [r6, #0]
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
    dc06:	2005      	movs	r0, #5
	/* Make the counter size variable in the module_inst struct reflect
	 * the counter size in the module
	 */
	module_inst->counter_size = config->counter_size;

	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_SWRST) {
    dc08:	07db      	lsls	r3, r3, #31
    dc0a:	d500      	bpl.n	dc0e <tc_init+0x6e>
    dc0c:	e119      	b.n	de42 <tc_init+0x2a2>
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
	}

	if (hw->COUNT8.STATUS.reg & TC_STATUS_SLAVE) {
    dc0e:	7af3      	ldrb	r3, [r6, #11]
		/* Module is used as a slave */
		return STATUS_ERR_DENIED;
    dc10:	3017      	adds	r0, #23
	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_SWRST) {
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
	}

	if (hw->COUNT8.STATUS.reg & TC_STATUS_SLAVE) {
    dc12:	079b      	lsls	r3, r3, #30
    dc14:	d500      	bpl.n	dc18 <tc_init+0x78>
    dc16:	e114      	b.n	de42 <tc_init+0x2a2>
		/* Module is used as a slave */
		return STATUS_ERR_DENIED;
	}

	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_ENABLE) {
    dc18:	6833      	ldr	r3, [r6, #0]
    dc1a:	079b      	lsls	r3, r3, #30
    dc1c:	d500      	bpl.n	dc20 <tc_init+0x80>
    dc1e:	e110      	b.n	de42 <tc_init+0x2a2>
		/* Module must be disabled before initialization. Abort. */
		return STATUS_ERR_DENIED;
	}

	/* Set up the TC PWM out pin for channel 0 */
	if (config->pwm_channel[0].enabled) {
    dc20:	7c3b      	ldrb	r3, [r7, #16]
    dc22:	2b00      	cmp	r3, #0
    dc24:	d00a      	beq.n	dc3c <tc_init+0x9c>
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    dc26:	a902      	add	r1, sp, #8
    dc28:	2301      	movs	r3, #1
    dc2a:	708b      	strb	r3, [r1, #2]
	config->powersave    = false;
    dc2c:	2200      	movs	r2, #0
    dc2e:	70ca      	strb	r2, [r1, #3]
		system_pinmux_get_config_defaults(&pin_config);
		pin_config.mux_position = config->pwm_channel[0].pin_mux;
    dc30:	7e3a      	ldrb	r2, [r7, #24]
    dc32:	700a      	strb	r2, [r1, #0]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
    dc34:	704b      	strb	r3, [r1, #1]
		system_pinmux_pin_set_config(
    dc36:	7d38      	ldrb	r0, [r7, #20]
    dc38:	4b88      	ldr	r3, [pc, #544]	; (de5c <tc_init+0x2bc>)
    dc3a:	4798      	blx	r3
				config->pwm_channel[0].pin_out, &pin_config);
	}

	/* Set up the TC PWM out pin for channel 1 */
	if (config->pwm_channel[1].enabled) {
    dc3c:	7f3b      	ldrb	r3, [r7, #28]
    dc3e:	2b00      	cmp	r3, #0
    dc40:	d00b      	beq.n	dc5a <tc_init+0xba>
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    dc42:	a902      	add	r1, sp, #8
    dc44:	2301      	movs	r3, #1
    dc46:	708b      	strb	r3, [r1, #2]
	config->powersave    = false;
    dc48:	2200      	movs	r2, #0
    dc4a:	70ca      	strb	r2, [r1, #3]
		system_pinmux_get_config_defaults(&pin_config);
		pin_config.mux_position = config->pwm_channel[1].pin_mux;
    dc4c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    dc4e:	700a      	strb	r2, [r1, #0]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
    dc50:	704b      	strb	r3, [r1, #1]
		system_pinmux_pin_set_config(
    dc52:	6a3b      	ldr	r3, [r7, #32]
    dc54:	b2d8      	uxtb	r0, r3
    dc56:	4b81      	ldr	r3, [pc, #516]	; (de5c <tc_init+0x2bc>)
    dc58:	4798      	blx	r3
				config->pwm_channel[1].pin_out, &pin_config);
	}

	/* Enable the user interface clock in the MCLK */
	system_apb_clock_set_mask((enum system_clock_apb_bus)inst_mclk_apbmask[instance*2],
    dc5a:	4643      	mov	r3, r8
    dc5c:	005a      	lsls	r2, r3, #1
    dc5e:	a803      	add	r0, sp, #12
    dc60:	1c53      	adds	r3, r2, #1
    dc62:	009b      	lsls	r3, r3, #2
    dc64:	5819      	ldr	r1, [r3, r0]
    dc66:	4643      	mov	r3, r8
    dc68:	00db      	lsls	r3, r3, #3
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
    dc6a:	581b      	ldr	r3, [r3, r0]
    dc6c:	b2d8      	uxtb	r0, r3
    dc6e:	2804      	cmp	r0, #4
    dc70:	d81b      	bhi.n	dcaa <tc_init+0x10a>
    dc72:	0083      	lsls	r3, r0, #2
    dc74:	487a      	ldr	r0, [pc, #488]	; (de60 <tc_init+0x2c0>)
    dc76:	58c3      	ldr	r3, [r0, r3]
    dc78:	469f      	mov	pc, r3
		case SYSTEM_CLOCK_APB_APBA:
			MCLK->APBAMASK.reg |= mask;
    dc7a:	487a      	ldr	r0, [pc, #488]	; (de64 <tc_init+0x2c4>)
    dc7c:	6943      	ldr	r3, [r0, #20]
    dc7e:	430b      	orrs	r3, r1
    dc80:	6143      	str	r3, [r0, #20]
    dc82:	e012      	b.n	dcaa <tc_init+0x10a>
			break;

		case SYSTEM_CLOCK_APB_APBB:
			MCLK->APBBMASK.reg |= mask;
    dc84:	4877      	ldr	r0, [pc, #476]	; (de64 <tc_init+0x2c4>)
    dc86:	6983      	ldr	r3, [r0, #24]
    dc88:	430b      	orrs	r3, r1
    dc8a:	6183      	str	r3, [r0, #24]
    dc8c:	e00d      	b.n	dcaa <tc_init+0x10a>
			break;

		case SYSTEM_CLOCK_APB_APBC:
			MCLK->APBCMASK.reg |= mask;
    dc8e:	4875      	ldr	r0, [pc, #468]	; (de64 <tc_init+0x2c4>)
    dc90:	69c3      	ldr	r3, [r0, #28]
    dc92:	430b      	orrs	r3, r1
    dc94:	61c3      	str	r3, [r0, #28]
    dc96:	e008      	b.n	dcaa <tc_init+0x10a>
			break;
		case SYSTEM_CLOCK_APB_APBD:
			MCLK->APBDMASK.reg |= mask;
    dc98:	4872      	ldr	r0, [pc, #456]	; (de64 <tc_init+0x2c4>)
    dc9a:	6a03      	ldr	r3, [r0, #32]
    dc9c:	430b      	orrs	r3, r1
    dc9e:	6203      	str	r3, [r0, #32]
    dca0:	e003      	b.n	dcaa <tc_init+0x10a>
			break;
		case SYSTEM_CLOCK_APB_APBE:
			MCLK->APBEMASK.reg |= mask;
    dca2:	4870      	ldr	r0, [pc, #448]	; (de64 <tc_init+0x2c4>)
    dca4:	6a43      	ldr	r3, [r0, #36]	; 0x24
    dca6:	430b      	orrs	r3, r1
    dca8:	6243      	str	r3, [r0, #36]	; 0x24
			inst_mclk_apbmask[2*instance+1]);

	/* Enable the slave counter if counter_size is 32-bit */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT) && (instance+1 < TC_INST_NUM))
    dcaa:	78fb      	ldrb	r3, [r7, #3]
    dcac:	2b08      	cmp	r3, #8
    dcae:	d126      	bne.n	dcfe <tc_init+0x15e>
    dcb0:	4643      	mov	r3, r8
    dcb2:	3301      	adds	r3, #1
    dcb4:	2b02      	cmp	r3, #2
    dcb6:	dc22      	bgt.n	dcfe <tc_init+0x15e>
	{
		/* Enable the user interface clock in the MCLK */
		system_apb_clock_set_mask((enum system_clock_apb_bus)inst_mclk_apbmask[instance*2+1],
    dcb8:	3202      	adds	r2, #2
    dcba:	0092      	lsls	r2, r2, #2
    dcbc:	ab03      	add	r3, sp, #12
    dcbe:	58d2      	ldr	r2, [r2, r3]
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
    dcc0:	b2cb      	uxtb	r3, r1
    dcc2:	2b04      	cmp	r3, #4
    dcc4:	d81b      	bhi.n	dcfe <tc_init+0x15e>
    dcc6:	009b      	lsls	r3, r3, #2
    dcc8:	4967      	ldr	r1, [pc, #412]	; (de68 <tc_init+0x2c8>)
    dcca:	58cb      	ldr	r3, [r1, r3]
    dccc:	469f      	mov	pc, r3
		case SYSTEM_CLOCK_APB_APBA:
			MCLK->APBAMASK.reg |= mask;
    dcce:	4965      	ldr	r1, [pc, #404]	; (de64 <tc_init+0x2c4>)
    dcd0:	694b      	ldr	r3, [r1, #20]
    dcd2:	431a      	orrs	r2, r3
    dcd4:	614a      	str	r2, [r1, #20]
    dcd6:	e012      	b.n	dcfe <tc_init+0x15e>
			break;

		case SYSTEM_CLOCK_APB_APBB:
			MCLK->APBBMASK.reg |= mask;
    dcd8:	4962      	ldr	r1, [pc, #392]	; (de64 <tc_init+0x2c4>)
    dcda:	698b      	ldr	r3, [r1, #24]
    dcdc:	431a      	orrs	r2, r3
    dcde:	618a      	str	r2, [r1, #24]
    dce0:	e00d      	b.n	dcfe <tc_init+0x15e>
			break;

		case SYSTEM_CLOCK_APB_APBC:
			MCLK->APBCMASK.reg |= mask;
    dce2:	4960      	ldr	r1, [pc, #384]	; (de64 <tc_init+0x2c4>)
    dce4:	69cb      	ldr	r3, [r1, #28]
    dce6:	431a      	orrs	r2, r3
    dce8:	61ca      	str	r2, [r1, #28]
    dcea:	e008      	b.n	dcfe <tc_init+0x15e>
			break;
		case SYSTEM_CLOCK_APB_APBD:
			MCLK->APBDMASK.reg |= mask;
    dcec:	495d      	ldr	r1, [pc, #372]	; (de64 <tc_init+0x2c4>)
    dcee:	6a0b      	ldr	r3, [r1, #32]
    dcf0:	431a      	orrs	r2, r3
    dcf2:	620a      	str	r2, [r1, #32]
    dcf4:	e003      	b.n	dcfe <tc_init+0x15e>
			break;
		case SYSTEM_CLOCK_APB_APBE:
			MCLK->APBEMASK.reg |= mask;
    dcf6:	495b      	ldr	r1, [pc, #364]	; (de64 <tc_init+0x2c4>)
    dcf8:	6a4b      	ldr	r3, [r1, #36]	; 0x24
    dcfa:	431a      	orrs	r2, r3
    dcfc:	624a      	str	r2, [r1, #36]	; 0x24
	}


	/* Setup clock for module */
	system_gclk_chan_get_config_defaults(&gclk_chan_config);
	gclk_chan_config.source_generator = config->clock_source;
    dcfe:	a901      	add	r1, sp, #4
    dd00:	783b      	ldrb	r3, [r7, #0]
    dd02:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(inst_gclk_id[instance], &gclk_chan_config);
    dd04:	ab09      	add	r3, sp, #36	; 0x24
    dd06:	4642      	mov	r2, r8
    dd08:	5c9c      	ldrb	r4, [r3, r2]
    dd0a:	0020      	movs	r0, r4
    dd0c:	4b57      	ldr	r3, [pc, #348]	; (de6c <tc_init+0x2cc>)
    dd0e:	4798      	blx	r3
	system_gclk_chan_enable(inst_gclk_id[instance]);
    dd10:	0020      	movs	r0, r4
    dd12:	4b57      	ldr	r3, [pc, #348]	; (de70 <tc_init+0x2d0>)
    dd14:	4798      	blx	r3

	/* Set ctrla register */
	ctrla_tmp =
    dd16:	78fa      	ldrb	r2, [r7, #3]
    dd18:	79fb      	ldrb	r3, [r7, #7]
    dd1a:	4313      	orrs	r3, r2
    dd1c:	88ba      	ldrh	r2, [r7, #4]
    dd1e:	4313      	orrs	r3, r2
			(uint32_t)config->counter_size |
			(uint32_t)config->reload_action |
			(uint32_t)config->clock_prescaler;

	for (uint8_t i = 0; i < NUMBER_OF_COMPARE_CAPTURE_CHANNELS; i++) {
		if (config->enable_capture_on_channel[i] == true) {
    dd20:	7a7a      	ldrb	r2, [r7, #9]
    dd22:	2a00      	cmp	r2, #0
    dd24:	d002      	beq.n	dd2c <tc_init+0x18c>
			ctrla_tmp |= (TC_CTRLA_CAPTEN(1) << i);
    dd26:	2280      	movs	r2, #128	; 0x80
    dd28:	0252      	lsls	r2, r2, #9
    dd2a:	4313      	orrs	r3, r2
			(uint32_t)config->counter_size |
			(uint32_t)config->reload_action |
			(uint32_t)config->clock_prescaler;

	for (uint8_t i = 0; i < NUMBER_OF_COMPARE_CAPTURE_CHANNELS; i++) {
		if (config->enable_capture_on_channel[i] == true) {
    dd2c:	7aba      	ldrb	r2, [r7, #10]
    dd2e:	2a00      	cmp	r2, #0
    dd30:	d002      	beq.n	dd38 <tc_init+0x198>
			ctrla_tmp |= (TC_CTRLA_CAPTEN(1) << i);
    dd32:	2280      	movs	r2, #128	; 0x80
    dd34:	0292      	lsls	r2, r2, #10
    dd36:	4313      	orrs	r3, r2
		}
	}

	for (uint8_t i = 0; i < NUMBER_OF_COMPARE_CAPTURE_CHANNELS; i++) {
		if (config->enable_capture_on_IO[i] == true) {
    dd38:	7afa      	ldrb	r2, [r7, #11]
    dd3a:	2a00      	cmp	r2, #0
    dd3c:	d002      	beq.n	dd44 <tc_init+0x1a4>
			ctrla_tmp |= (TC_CTRLA_COPEN(1) << i);
    dd3e:	2280      	movs	r2, #128	; 0x80
    dd40:	0352      	lsls	r2, r2, #13
    dd42:	4313      	orrs	r3, r2
			ctrla_tmp |= (TC_CTRLA_CAPTEN(1) << i);
		}
	}

	for (uint8_t i = 0; i < NUMBER_OF_COMPARE_CAPTURE_CHANNELS; i++) {
		if (config->enable_capture_on_IO[i] == true) {
    dd44:	7b3a      	ldrb	r2, [r7, #12]
    dd46:	2a00      	cmp	r2, #0
    dd48:	d002      	beq.n	dd50 <tc_init+0x1b0>
			ctrla_tmp |= (TC_CTRLA_COPEN(1) << i);
    dd4a:	2280      	movs	r2, #128	; 0x80
    dd4c:	0392      	lsls	r2, r2, #14
    dd4e:	4313      	orrs	r3, r2
		}
	}

	ctrla_tmp |= (config->run_in_standby << TC_CTRLA_RUNSTDBY_Pos)
    dd50:	7879      	ldrb	r1, [r7, #1]
    dd52:	0189      	lsls	r1, r1, #6
    dd54:	78ba      	ldrb	r2, [r7, #2]
    dd56:	01d2      	lsls	r2, r2, #7
    dd58:	4311      	orrs	r1, r2
    dd5a:	4319      	orrs	r1, r3
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    dd5c:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    dd5e:	6913      	ldr	r3, [r2, #16]
				|(config->on_demand << TC_CTRLA_ONDEMAND_Pos);

	/* Write configuration to register */
	while (tc_is_syncing(module_inst)) {
    dd60:	2b00      	cmp	r3, #0
    dd62:	d1fc      	bne.n	dd5e <tc_init+0x1be>
		/* Wait for sync */
	}
	hw->COUNT8.CTRLA.reg = ctrla_tmp;
    dd64:	6031      	str	r1, [r6, #0]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    dd66:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    dd68:	6913      	ldr	r3, [r2, #16]

	/* Write configuration to register */
	while (tc_is_syncing(module_inst)) {
    dd6a:	2b00      	cmp	r3, #0
    dd6c:	d1fc      	bne.n	dd68 <tc_init+0x1c8>
		/* Wait for sync */
	}
	hw->COUNT8.WAVE.reg = config->wave_generation;
    dd6e:	79bb      	ldrb	r3, [r7, #6]
    dd70:	7333      	strb	r3, [r6, #12]

	/* Set ctrlb register */
	if (config->oneshot) {
    dd72:	7b79      	ldrb	r1, [r7, #13]
		ctrlbset_tmp = TC_CTRLBSET_ONESHOT;
    dd74:	1e4b      	subs	r3, r1, #1
    dd76:	4199      	sbcs	r1, r3
    dd78:	0089      	lsls	r1, r1, #2
	}

	if (config->count_direction) {
    dd7a:	7bbb      	ldrb	r3, [r7, #14]
    dd7c:	2b00      	cmp	r3, #0
    dd7e:	d001      	beq.n	dd84 <tc_init+0x1e4>
		ctrlbset_tmp |= TC_CTRLBSET_DIR;
    dd80:	2301      	movs	r3, #1
    dd82:	4319      	orrs	r1, r3
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    dd84:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    dd86:	6913      	ldr	r3, [r2, #16]
	}

	/* Clear old ctrlb configuration */
	while (tc_is_syncing(module_inst)) {
    dd88:	2b00      	cmp	r3, #0
    dd8a:	d1fc      	bne.n	dd86 <tc_init+0x1e6>
		/* Wait for sync */
	}
	hw->COUNT8.CTRLBCLR.reg = 0xFF;
    dd8c:	33ff      	adds	r3, #255	; 0xff
    dd8e:	7133      	strb	r3, [r6, #4]

	/* Check if we actually need to go into a wait state. */
	if (ctrlbset_tmp) {
    dd90:	2900      	cmp	r1, #0
    dd92:	d004      	beq.n	dd9e <tc_init+0x1fe>
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    dd94:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    dd96:	6913      	ldr	r3, [r2, #16]
		while (tc_is_syncing(module_inst)) {
    dd98:	2b00      	cmp	r3, #0
    dd9a:	d1fc      	bne.n	dd96 <tc_init+0x1f6>
			/* Wait for sync */
		}
		/* Write configuration to register */
		hw->COUNT8.CTRLBSET.reg = ctrlbset_tmp;
    dd9c:	7171      	strb	r1, [r6, #5]
	}

	/* Set drvvtrl register*/
	hw->COUNT8.DRVCTRL.reg = config->waveform_invert_output;
    dd9e:	7a3b      	ldrb	r3, [r7, #8]
    dda0:	7373      	strb	r3, [r6, #13]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    dda2:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    dda4:	6913      	ldr	r3, [r2, #16]

	/* Write configuration to register */
	while (tc_is_syncing(module_inst)) {
    dda6:	2b00      	cmp	r3, #0
    dda8:	d1fc      	bne.n	dda4 <tc_init+0x204>
		/* Wait for sync */
	}

	/* Switch for TC counter size  */
	switch (module_inst->counter_size) {
    ddaa:	792b      	ldrb	r3, [r5, #4]
    ddac:	2b04      	cmp	r3, #4
    ddae:	d005      	beq.n	ddbc <tc_init+0x21c>
    ddb0:	2b08      	cmp	r3, #8
    ddb2:	d033      	beq.n	de1c <tc_init+0x27c>

			return STATUS_OK;
	}

	Assert(false);
	return STATUS_ERR_INVALID_ARG;
    ddb4:	2017      	movs	r0, #23
	while (tc_is_syncing(module_inst)) {
		/* Wait for sync */
	}

	/* Switch for TC counter size  */
	switch (module_inst->counter_size) {
    ddb6:	2b00      	cmp	r3, #0
    ddb8:	d143      	bne.n	de42 <tc_init+0x2a2>
    ddba:	e01c      	b.n	ddf6 <tc_init+0x256>
    ddbc:	6913      	ldr	r3, [r2, #16]
		case TC_COUNTER_SIZE_8BIT:
			while (tc_is_syncing(module_inst)) {
    ddbe:	2b00      	cmp	r3, #0
    ddc0:	d1fc      	bne.n	ddbc <tc_init+0x21c>
				/* Wait for sync */
			}

			hw->COUNT8.COUNT.reg =
					config->counter_8_bit.value;
    ddc2:	3328      	adds	r3, #40	; 0x28
    ddc4:	5cfb      	ldrb	r3, [r7, r3]
		case TC_COUNTER_SIZE_8BIT:
			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.COUNT.reg =
    ddc6:	7533      	strb	r3, [r6, #20]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    ddc8:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    ddca:	6913      	ldr	r3, [r2, #16]
					config->counter_8_bit.value;


			while (tc_is_syncing(module_inst)) {
    ddcc:	2b00      	cmp	r3, #0
    ddce:	d1fc      	bne.n	ddca <tc_init+0x22a>
				/* Wait for sync */
			}

			hw->COUNT8.PER.reg =
					config->counter_8_bit.period;
    ddd0:	3329      	adds	r3, #41	; 0x29
    ddd2:	5cfb      	ldrb	r3, [r7, r3]

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.PER.reg =
    ddd4:	76f3      	strb	r3, [r6, #27]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    ddd6:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    ddd8:	6913      	ldr	r3, [r2, #16]
					config->counter_8_bit.period;

			while (tc_is_syncing(module_inst)) {
    ddda:	2b00      	cmp	r3, #0
    dddc:	d1fc      	bne.n	ddd8 <tc_init+0x238>
				/* Wait for sync */
			}

			hw->COUNT8.CC[0].reg =
					config->counter_8_bit.compare_capture_channel[0];
    ddde:	332a      	adds	r3, #42	; 0x2a
    dde0:	5cfb      	ldrb	r3, [r7, r3]

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.CC[0].reg =
    dde2:	7733      	strb	r3, [r6, #28]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    dde4:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    dde6:	6913      	ldr	r3, [r2, #16]
					config->counter_8_bit.compare_capture_channel[0];

			while (tc_is_syncing(module_inst)) {
    dde8:	2b00      	cmp	r3, #0
    ddea:	d1fc      	bne.n	dde6 <tc_init+0x246>
				/* Wait for sync */
			}

			hw->COUNT8.CC[1].reg =
					config->counter_8_bit.compare_capture_channel[1];
    ddec:	332b      	adds	r3, #43	; 0x2b
    ddee:	5cfb      	ldrb	r3, [r7, r3]

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.CC[1].reg =
    ddf0:	7773      	strb	r3, [r6, #29]
					config->counter_8_bit.compare_capture_channel[1];

			return STATUS_OK;
    ddf2:	2000      	movs	r0, #0
    ddf4:	e025      	b.n	de42 <tc_init+0x2a2>
    ddf6:	6913      	ldr	r3, [r2, #16]

		case TC_COUNTER_SIZE_16BIT:
			while (tc_is_syncing(module_inst)) {
    ddf8:	2b00      	cmp	r3, #0
    ddfa:	d1fc      	bne.n	ddf6 <tc_init+0x256>
				/* Wait for sync */
			}

			hw->COUNT16.COUNT.reg
				= config->counter_16_bit.value;
    ddfc:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
    ddfe:	82b3      	strh	r3, [r6, #20]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    de00:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    de02:	6913      	ldr	r3, [r2, #16]

			while (tc_is_syncing(module_inst)) {
    de04:	2b00      	cmp	r3, #0
    de06:	d1fc      	bne.n	de02 <tc_init+0x262>
				/* Wait for sync */
			}

			hw->COUNT16.CC[0].reg =
					config->counter_16_bit.compare_capture_channel[0];
    de08:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT16.CC[0].reg =
    de0a:	83b3      	strh	r3, [r6, #28]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    de0c:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    de0e:	6913      	ldr	r3, [r2, #16]
					config->counter_16_bit.compare_capture_channel[0];

			while (tc_is_syncing(module_inst)) {
    de10:	2b00      	cmp	r3, #0
    de12:	d1fc      	bne.n	de0e <tc_init+0x26e>
				/* Wait for sync */
			}

			hw->COUNT16.CC[1].reg =
					config->counter_16_bit.compare_capture_channel[1];
    de14:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT16.CC[1].reg =
    de16:	83f3      	strh	r3, [r6, #30]
					config->counter_16_bit.compare_capture_channel[1];

			return STATUS_OK;
    de18:	2000      	movs	r0, #0
    de1a:	e012      	b.n	de42 <tc_init+0x2a2>
    de1c:	6913      	ldr	r3, [r2, #16]

		case TC_COUNTER_SIZE_32BIT:
			while (tc_is_syncing(module_inst)) {
    de1e:	2b00      	cmp	r3, #0
    de20:	d1fc      	bne.n	de1c <tc_init+0x27c>
				/* Wait for sync */
			}

			hw->COUNT32.COUNT.reg
				= config->counter_32_bit.value;
    de22:	6abb      	ldr	r3, [r7, #40]	; 0x28
    de24:	6173      	str	r3, [r6, #20]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    de26:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    de28:	6913      	ldr	r3, [r2, #16]

			while (tc_is_syncing(module_inst)) {
    de2a:	2b00      	cmp	r3, #0
    de2c:	d1fc      	bne.n	de28 <tc_init+0x288>
				/* Wait for sync */
			}

			hw->COUNT32.CC[0].reg =
    de2e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    de30:	61f3      	str	r3, [r6, #28]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    de32:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    de34:	6913      	ldr	r3, [r2, #16]
					config->counter_32_bit.compare_capture_channel[0];

			while (tc_is_syncing(module_inst)) {
    de36:	2b00      	cmp	r3, #0
    de38:	d1fc      	bne.n	de34 <tc_init+0x294>
				/* Wait for sync */
			}

			hw->COUNT32.CC[1].reg =
					config->counter_32_bit.compare_capture_channel[1];
    de3a:	6b3b      	ldr	r3, [r7, #48]	; 0x30

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT32.CC[1].reg =
    de3c:	6233      	str	r3, [r6, #32]
					config->counter_32_bit.compare_capture_channel[1];

			return STATUS_OK;
    de3e:	2000      	movs	r0, #0
    de40:	e7ff      	b.n	de42 <tc_init+0x2a2>
	}

	Assert(false);
	return STATUS_ERR_INVALID_ARG;
}
    de42:	b00a      	add	sp, #40	; 0x28
    de44:	bc04      	pop	{r2}
    de46:	4690      	mov	r8, r2
    de48:	bdf0      	pop	{r4, r5, r6, r7, pc}
    de4a:	46c0      	nop			; (mov r8, r8)
    de4c:	0000db69 	.word	0x0000db69
    de50:	0001bee4 	.word	0x0001bee4
    de54:	00011833 	.word	0x00011833
    de58:	20002868 	.word	0x20002868
    de5c:	0000da55 	.word	0x0000da55
    de60:	0001bebc 	.word	0x0001bebc
    de64:	40000400 	.word	0x40000400
    de68:	0001bed0 	.word	0x0001bed0
    de6c:	0000d959 	.word	0x0000d959
    de70:	0000d8e9 	.word	0x0000d8e9

0000de74 <tc_set_count_value>:
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance*/
	Tc *const tc_module = module_inst->hw;
    de74:	6802      	ldr	r2, [r0, #0]
    de76:	6913      	ldr	r3, [r2, #16]

	while (tc_is_syncing(module_inst)) {
    de78:	2b00      	cmp	r3, #0
    de7a:	d1fc      	bne.n	de76 <tc_set_count_value+0x2>
		/* Wait for sync */
	}

	/* Write to based on the TC counter_size */
	switch (module_inst->counter_size) {
    de7c:	7903      	ldrb	r3, [r0, #4]
    de7e:	2b04      	cmp	r3, #4
    de80:	d005      	beq.n	de8e <tc_set_count_value+0x1a>
    de82:	2b08      	cmp	r3, #8
    de84:	d00b      	beq.n	de9e <tc_set_count_value+0x2a>
		case TC_COUNTER_SIZE_32BIT:
			tc_module->COUNT32.COUNT.reg = (uint32_t)count;
			return STATUS_OK;

		default:
			return STATUS_ERR_INVALID_ARG;
    de86:	2017      	movs	r0, #23
	while (tc_is_syncing(module_inst)) {
		/* Wait for sync */
	}

	/* Write to based on the TC counter_size */
	switch (module_inst->counter_size) {
    de88:	2b00      	cmp	r3, #0
    de8a:	d10b      	bne.n	dea4 <tc_set_count_value+0x30>
    de8c:	e003      	b.n	de96 <tc_set_count_value+0x22>
		case TC_COUNTER_SIZE_8BIT:
			tc_module->COUNT8.COUNT.reg  = (uint8_t)count;
    de8e:	b2c9      	uxtb	r1, r1
    de90:	7511      	strb	r1, [r2, #20]
			return STATUS_OK;
    de92:	2000      	movs	r0, #0
    de94:	e006      	b.n	dea4 <tc_set_count_value+0x30>

		case TC_COUNTER_SIZE_16BIT:
			tc_module->COUNT16.COUNT.reg = (uint16_t)count;
    de96:	b289      	uxth	r1, r1
    de98:	8291      	strh	r1, [r2, #20]
			return STATUS_OK;
    de9a:	2000      	movs	r0, #0
    de9c:	e002      	b.n	dea4 <tc_set_count_value+0x30>

		case TC_COUNTER_SIZE_32BIT:
			tc_module->COUNT32.COUNT.reg = (uint32_t)count;
    de9e:	6151      	str	r1, [r2, #20]
			return STATUS_OK;
    dea0:	2000      	movs	r0, #0
    dea2:	e7ff      	b.n	dea4 <tc_set_count_value+0x30>

		default:
			return STATUS_ERR_INVALID_ARG;
	}
}
    dea4:	4770      	bx	lr
    dea6:	46c0      	nop			; (mov r8, r8)

0000dea8 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    dea8:	e7fe      	b.n	dea8 <Dummy_Handler>
    deaa:	46c0      	nop			; (mov r8, r8)

0000deac <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    deac:	b510      	push	{r4, lr}

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
    deae:	4b1d      	ldr	r3, [pc, #116]	; (df24 <Reset_Handler+0x78>)
    deb0:	4a1d      	ldr	r2, [pc, #116]	; (df28 <Reset_Handler+0x7c>)
    deb2:	429a      	cmp	r2, r3
    deb4:	d003      	beq.n	debe <Reset_Handler+0x12>
                for (; pDest < &_erelocate;) {
    deb6:	4b1d      	ldr	r3, [pc, #116]	; (df2c <Reset_Handler+0x80>)
    deb8:	4a1a      	ldr	r2, [pc, #104]	; (df24 <Reset_Handler+0x78>)
    deba:	429a      	cmp	r2, r3
    debc:	d304      	bcc.n	dec8 <Reset_Handler+0x1c>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    debe:	4b1c      	ldr	r3, [pc, #112]	; (df30 <Reset_Handler+0x84>)
    dec0:	4a1c      	ldr	r2, [pc, #112]	; (df34 <Reset_Handler+0x88>)
    dec2:	429a      	cmp	r2, r3
    dec4:	d310      	bcc.n	dee8 <Reset_Handler+0x3c>
    dec6:	e01e      	b.n	df06 <Reset_Handler+0x5a>
    dec8:	4a1b      	ldr	r2, [pc, #108]	; (df38 <Reset_Handler+0x8c>)
    deca:	4b18      	ldr	r3, [pc, #96]	; (df2c <Reset_Handler+0x80>)
    decc:	3303      	adds	r3, #3
    dece:	1a9b      	subs	r3, r3, r2
    ded0:	089b      	lsrs	r3, r3, #2
    ded2:	3301      	adds	r3, #1
    ded4:	009b      	lsls	r3, r3, #2
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    ded6:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
    ded8:	4812      	ldr	r0, [pc, #72]	; (df24 <Reset_Handler+0x78>)
    deda:	4913      	ldr	r1, [pc, #76]	; (df28 <Reset_Handler+0x7c>)
    dedc:	588c      	ldr	r4, [r1, r2]
    dede:	5084      	str	r4, [r0, r2]
    dee0:	3204      	adds	r2, #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    dee2:	429a      	cmp	r2, r3
    dee4:	d1fa      	bne.n	dedc <Reset_Handler+0x30>
    dee6:	e7ea      	b.n	debe <Reset_Handler+0x12>
    dee8:	4a14      	ldr	r2, [pc, #80]	; (df3c <Reset_Handler+0x90>)
    deea:	4b11      	ldr	r3, [pc, #68]	; (df30 <Reset_Handler+0x84>)
    deec:	3303      	adds	r3, #3
    deee:	1a9b      	subs	r3, r3, r2
    def0:	089b      	lsrs	r3, r3, #2
    def2:	3301      	adds	r3, #1
    def4:	009b      	lsls	r3, r3, #2
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    def6:	2200      	movs	r2, #0
                *pDest++ = 0;
    def8:	480e      	ldr	r0, [pc, #56]	; (df34 <Reset_Handler+0x88>)
    defa:	2100      	movs	r1, #0
    defc:	1814      	adds	r4, r2, r0
    defe:	6021      	str	r1, [r4, #0]
    df00:	3204      	adds	r2, #4
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    df02:	429a      	cmp	r2, r3
    df04:	d1fa      	bne.n	defc <Reset_Handler+0x50>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    df06:	4a0e      	ldr	r2, [pc, #56]	; (df40 <Reset_Handler+0x94>)
    df08:	21ff      	movs	r1, #255	; 0xff
    df0a:	4b0e      	ldr	r3, [pc, #56]	; (df44 <Reset_Handler+0x98>)
    df0c:	438b      	bics	r3, r1
    df0e:	6093      	str	r3, [r2, #8]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
    df10:	4a0d      	ldr	r2, [pc, #52]	; (df48 <Reset_Handler+0x9c>)
    df12:	6851      	ldr	r1, [r2, #4]
    df14:	2380      	movs	r3, #128	; 0x80
    df16:	430b      	orrs	r3, r1
    df18:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
    df1a:	4b0c      	ldr	r3, [pc, #48]	; (df4c <Reset_Handler+0xa0>)
    df1c:	4798      	blx	r3

        /* Branch to main function */
        main();
    df1e:	4b0c      	ldr	r3, [pc, #48]	; (df50 <Reset_Handler+0xa4>)
    df20:	4798      	blx	r3
    df22:	e7fe      	b.n	df22 <Reset_Handler+0x76>
    df24:	20000000 	.word	0x20000000
    df28:	0001c1b4 	.word	0x0001c1b4
    df2c:	200001a4 	.word	0x200001a4
    df30:	200028d4 	.word	0x200028d4
    df34:	200001a4 	.word	0x200001a4
    df38:	20000004 	.word	0x20000004
    df3c:	200001a8 	.word	0x200001a8
    df40:	e000ed00 	.word	0xe000ed00
    df44:	00000000 	.word	0x00000000
    df48:	41004000 	.word	0x41004000
    df4c:	000117a1 	.word	0x000117a1
    df50:	0000e231 	.word	0x0000e231

0000df54 <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
    df54:	b5f0      	push	{r4, r5, r6, r7, lr}
    df56:	4647      	mov	r7, r8
    df58:	b480      	push	{r7}
    df5a:	000c      	movs	r4, r1
    df5c:	4690      	mov	r8, r2
	int nChars = 0;

	if (file != 0) {
    df5e:	2800      	cmp	r0, #0
    df60:	d10d      	bne.n	df7e <_read+0x2a>
		return -1;
	}

	for (; len > 0; --len) {
    df62:	2a00      	cmp	r2, #0
    df64:	dd0e      	ble.n	df84 <_read+0x30>
    df66:	188f      	adds	r7, r1, r2
		ptr_get(stdio_base, ptr);
    df68:	4e08      	ldr	r6, [pc, #32]	; (df8c <_read+0x38>)
    df6a:	4d09      	ldr	r5, [pc, #36]	; (df90 <_read+0x3c>)
    df6c:	6830      	ldr	r0, [r6, #0]
    df6e:	0021      	movs	r1, r4
    df70:	682b      	ldr	r3, [r5, #0]
    df72:	4798      	blx	r3
		ptr++;
    df74:	3401      	adds	r4, #1

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
    df76:	42a7      	cmp	r7, r4
    df78:	d1f8      	bne.n	df6c <_read+0x18>
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
    df7a:	4640      	mov	r0, r8
    df7c:	e003      	b.n	df86 <_read+0x32>
_read (int file, char * ptr, int len)
{
	int nChars = 0;

	if (file != 0) {
		return -1;
    df7e:	2001      	movs	r0, #1
    df80:	4240      	negs	r0, r0
    df82:	e000      	b.n	df86 <_read+0x32>
	}

	for (; len > 0; --len) {
    df84:	2000      	movs	r0, #0
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
}
    df86:	bc04      	pop	{r2}
    df88:	4690      	mov	r8, r2
    df8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    df8c:	2000287c 	.word	0x2000287c
    df90:	20002874 	.word	0x20002874

0000df94 <_write>:
int __attribute__((weak))
_write (int file, char * ptr, int len);

int __attribute__((weak))
_write (int file, char * ptr, int len)
{
    df94:	b5f0      	push	{r4, r5, r6, r7, lr}
    df96:	4647      	mov	r7, r8
    df98:	b480      	push	{r7}
    df9a:	000e      	movs	r6, r1
    df9c:	0015      	movs	r5, r2
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
    df9e:	3801      	subs	r0, #1
    dfa0:	2802      	cmp	r0, #2
    dfa2:	d811      	bhi.n	dfc8 <_write+0x34>
		return -1;
	}

	for (; len != 0; --len) {
    dfa4:	2a00      	cmp	r2, #0
    dfa6:	d012      	beq.n	dfce <_write+0x3a>
    dfa8:	2400      	movs	r4, #0
		if (ptr_put(stdio_base, *ptr++) < 0) {
    dfaa:	4b0c      	ldr	r3, [pc, #48]	; (dfdc <_write+0x48>)
    dfac:	4698      	mov	r8, r3
    dfae:	4f0c      	ldr	r7, [pc, #48]	; (dfe0 <_write+0x4c>)
    dfb0:	4643      	mov	r3, r8
    dfb2:	6818      	ldr	r0, [r3, #0]
    dfb4:	5d31      	ldrb	r1, [r6, r4]
    dfb6:	683b      	ldr	r3, [r7, #0]
    dfb8:	4798      	blx	r3
    dfba:	2800      	cmp	r0, #0
    dfbc:	db09      	blt.n	dfd2 <_write+0x3e>
			return -1;
		}
		++nChars;
    dfbe:	3401      	adds	r4, #1

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
    dfc0:	42a5      	cmp	r5, r4
    dfc2:	d1f5      	bne.n	dfb0 <_write+0x1c>
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
    dfc4:	0020      	movs	r0, r4
    dfc6:	e006      	b.n	dfd6 <_write+0x42>
_write (int file, char * ptr, int len)
{
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
    dfc8:	2001      	movs	r0, #1
    dfca:	4240      	negs	r0, r0
    dfcc:	e003      	b.n	dfd6 <_write+0x42>
	}

	for (; len != 0; --len) {
    dfce:	2000      	movs	r0, #0
    dfd0:	e001      	b.n	dfd6 <_write+0x42>
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
    dfd2:	2001      	movs	r0, #1
    dfd4:	4240      	negs	r0, r0
		}
		++nChars;
	}
	return nChars;
}
    dfd6:	bc04      	pop	{r2}
    dfd8:	4690      	mov	r8, r2
    dfda:	bdf0      	pop	{r4, r5, r6, r7, pc}
    dfdc:	2000287c 	.word	0x2000287c
    dfe0:	20002878 	.word	0x20002878

0000dfe4 <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
    dfe4:	0003      	movs	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
    dfe6:	4a06      	ldr	r2, [pc, #24]	; (e000 <_sbrk+0x1c>)
    dfe8:	6812      	ldr	r2, [r2, #0]
    dfea:	2a00      	cmp	r2, #0
    dfec:	d102      	bne.n	dff4 <_sbrk+0x10>
		heap = (unsigned char *)&_end;
    dfee:	4905      	ldr	r1, [pc, #20]	; (e004 <_sbrk+0x20>)
    dff0:	4a03      	ldr	r2, [pc, #12]	; (e000 <_sbrk+0x1c>)
    dff2:	6011      	str	r1, [r2, #0]
	}
	prev_heap = heap;
    dff4:	4a02      	ldr	r2, [pc, #8]	; (e000 <_sbrk+0x1c>)
    dff6:	6810      	ldr	r0, [r2, #0]

	heap += incr;
    dff8:	18c3      	adds	r3, r0, r3
    dffa:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap;
}
    dffc:	4770      	bx	lr
    dffe:	46c0      	nop			; (mov r8, r8)
    e000:	2000197c 	.word	0x2000197c
    e004:	200048d8 	.word	0x200048d8

0000e008 <_close>:
}

extern int _close(int file)
{
	return -1;
}
    e008:	2001      	movs	r0, #1
    e00a:	4240      	negs	r0, r0
    e00c:	4770      	bx	lr
    e00e:	46c0      	nop			; (mov r8, r8)

0000e010 <_fstat>:

extern int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
    e010:	2380      	movs	r3, #128	; 0x80
    e012:	019b      	lsls	r3, r3, #6
    e014:	604b      	str	r3, [r1, #4]

	return 0;
}
    e016:	2000      	movs	r0, #0
    e018:	4770      	bx	lr
    e01a:	46c0      	nop			; (mov r8, r8)

0000e01c <_isatty>:

extern int _isatty(int file)
{
	return 1;
}
    e01c:	2001      	movs	r0, #1
    e01e:	4770      	bx	lr

0000e020 <_lseek>:

extern int _lseek(int file, int ptr, int dir)
{
	return 0;
}
    e020:	2000      	movs	r0, #0
    e022:	4770      	bx	lr

0000e024 <usart_serial_getchar>:
 * \param[out]    c       Destination for the read character.
 */
static inline void usart_serial_getchar(
		struct usart_module *const module,
		uint8_t *c)
{
    e024:	b570      	push	{r4, r5, r6, lr}
    e026:	b082      	sub	sp, #8
    e028:	0005      	movs	r5, r0
    e02a:	000e      	movs	r6, r1
	uint16_t temp = 0;
    e02c:	2200      	movs	r2, #0
    e02e:	466b      	mov	r3, sp
    e030:	80da      	strh	r2, [r3, #6]

	while(STATUS_OK != usart_read_wait(module, &temp));
    e032:	4c06      	ldr	r4, [pc, #24]	; (e04c <usart_serial_getchar+0x28>)
    e034:	466b      	mov	r3, sp
    e036:	1d99      	adds	r1, r3, #6
    e038:	0028      	movs	r0, r5
    e03a:	47a0      	blx	r4
    e03c:	2800      	cmp	r0, #0
    e03e:	d1f9      	bne.n	e034 <usart_serial_getchar+0x10>

	*c = temp;
    e040:	466b      	mov	r3, sp
    e042:	3306      	adds	r3, #6
    e044:	881b      	ldrh	r3, [r3, #0]
    e046:	7033      	strb	r3, [r6, #0]
}
    e048:	b002      	add	sp, #8
    e04a:	bd70      	pop	{r4, r5, r6, pc}
    e04c:	0000d041 	.word	0x0000d041

0000e050 <usart_serial_putchar>:
 * \return Status code
 */
static inline enum status_code usart_serial_putchar(
		struct usart_module *const module,
		uint8_t c)
{
    e050:	b570      	push	{r4, r5, r6, lr}
    e052:	0005      	movs	r5, r0
	while(STATUS_OK !=usart_write_wait(module, c));
    e054:	b28c      	uxth	r4, r1
    e056:	4e03      	ldr	r6, [pc, #12]	; (e064 <usart_serial_putchar+0x14>)
    e058:	0021      	movs	r1, r4
    e05a:	0028      	movs	r0, r5
    e05c:	47b0      	blx	r6
    e05e:	2800      	cmp	r0, #0
    e060:	d1fa      	bne.n	e058 <usart_serial_putchar+0x8>

	return STATUS_OK;
}
    e062:	bd70      	pop	{r4, r5, r6, pc}
    e064:	0000d015 	.word	0x0000d015

0000e068 <serial_console_init>:

/**
 *  Configure console.
 */
void serial_console_init(void)
{
    e068:	b5f0      	push	{r4, r5, r6, r7, lr}
    e06a:	b091      	sub	sp, #68	; 0x44
{
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    e06c:	2380      	movs	r3, #128	; 0x80
    e06e:	05db      	lsls	r3, r3, #23
    e070:	9300      	str	r3, [sp, #0]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    e072:	2300      	movs	r3, #0
    e074:	9301      	str	r3, [sp, #4]
	config->parity           = USART_PARITY_NONE;
    e076:	22ff      	movs	r2, #255	; 0xff
    e078:	4669      	mov	r1, sp
    e07a:	810a      	strh	r2, [r1, #8]
	config->stopbits         = USART_STOPBITS_1;
    e07c:	2200      	movs	r2, #0
    e07e:	728b      	strb	r3, [r1, #10]
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
    e080:	72cb      	strb	r3, [r1, #11]
	config->baudrate         = 9600;
	config->receiver_enable  = true;
    e082:	2401      	movs	r4, #1
    e084:	2124      	movs	r1, #36	; 0x24
    e086:	4668      	mov	r0, sp
    e088:	5444      	strb	r4, [r0, r1]
	config->transmitter_enable = true;
    e08a:	3101      	adds	r1, #1
    e08c:	5444      	strb	r4, [r0, r1]
	config->clock_polarity_inverted = false;
    e08e:	3101      	adds	r1, #1
    e090:	5443      	strb	r3, [r0, r1]
	config->use_external_clock = false;
    e092:	3101      	adds	r1, #1
    e094:	5443      	strb	r3, [r0, r1]
	config->ext_clock_freq   = 0;
    e096:	930a      	str	r3, [sp, #40]	; 0x28
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
	config->run_in_standby   = false;
    e098:	3105      	adds	r1, #5
    e09a:	5443      	strb	r3, [r0, r1]
	config->generator_source = GCLK_GENERATOR_0;
    e09c:	3101      	adds	r1, #1
    e09e:	5443      	strb	r3, [r0, r1]
	config->pinmux_pad0      = PINMUX_DEFAULT;
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->pinmux_pad2      = PINMUX_DEFAULT;
	config->pinmux_pad3      = PINMUX_DEFAULT;
#ifdef FEATURE_USART_OVER_SAMPLE
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
    e0a0:	9305      	str	r3, [sp, #20]
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
    e0a2:	8203      	strh	r3, [r0, #16]
#endif
#ifdef FEATURE_USART_LIN_SLAVE
	config->lin_slave_enable      = false;
    e0a4:	76c3      	strb	r3, [r0, #27]
	config->lin_header_delay = LIN_MASTER_HEADER_DELAY_0;
	config->lin_break_length = LIN_MASTER_BREAK_LENGTH_13_BIT;
#endif

#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
	config->immediate_buffer_overflow_notification  = false;
    e0a6:	7602      	strb	r2, [r0, #24]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
    e0a8:	7702      	strb	r2, [r0, #28]
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
    e0aa:	7642      	strb	r2, [r0, #25]
	config->receive_pulse_length                    = 19;
    e0ac:	2313      	movs	r3, #19
    e0ae:	7683      	strb	r3, [r0, #26]
	config->iso7816_config.inhibit_nack             = ISO7816_INHIBIT_NACK_DISABLE;
	config->iso7816_config.successive_recv_nack     = ISO7816_SUCCESSIVE_RECV_NACK_DISABLE;
	config->iso7816_config.max_iterations           = 7;
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
	config->collision_detection_enable              = false;
    e0b0:	7742      	strb	r2, [r0, #29]
 	struct usart_config usart_conf;

	usart_get_config_defaults(&usart_conf);
	usart_conf.mux_setting = CONF_STDIO_MUX_SETTING;
    e0b2:	2380      	movs	r3, #128	; 0x80
    e0b4:	035b      	lsls	r3, r3, #13
    e0b6:	9303      	str	r3, [sp, #12]
	usart_conf.pinmux_pad0 = CONF_STDIO_PINMUX_PAD0;
    e0b8:	4b1a      	ldr	r3, [pc, #104]	; (e124 <serial_console_init+0xbc>)
    e0ba:	930c      	str	r3, [sp, #48]	; 0x30
	usart_conf.pinmux_pad1 = CONF_STDIO_PINMUX_PAD1;
    e0bc:	4b1a      	ldr	r3, [pc, #104]	; (e128 <serial_console_init+0xc0>)
    e0be:	930d      	str	r3, [sp, #52]	; 0x34
	usart_conf.pinmux_pad2 = CONF_STDIO_PINMUX_PAD2;
    e0c0:	2301      	movs	r3, #1
    e0c2:	425b      	negs	r3, r3
    e0c4:	930e      	str	r3, [sp, #56]	; 0x38
	usart_conf.pinmux_pad3 = CONF_STDIO_PINMUX_PAD3;
    e0c6:	930f      	str	r3, [sp, #60]	; 0x3c
	usart_conf.baudrate    = CONF_STDIO_BAUDRATE;
    e0c8:	23e1      	movs	r3, #225	; 0xe1
    e0ca:	025b      	lsls	r3, r3, #9
    e0cc:	9308      	str	r3, [sp, #32]
static inline void stdio_serial_init(
		struct usart_module *const module,
		usart_inst_t const hw,
		const struct usart_config *const config)
{
	stdio_base = (void *)module;
    e0ce:	4d17      	ldr	r5, [pc, #92]	; (e12c <serial_console_init+0xc4>)
    e0d0:	4b17      	ldr	r3, [pc, #92]	; (e130 <serial_console_init+0xc8>)
    e0d2:	601d      	str	r5, [r3, #0]
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
    e0d4:	4a17      	ldr	r2, [pc, #92]	; (e134 <serial_console_init+0xcc>)
    e0d6:	4b18      	ldr	r3, [pc, #96]	; (e138 <serial_console_init+0xd0>)
    e0d8:	601a      	str	r2, [r3, #0]
	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
    e0da:	4a18      	ldr	r2, [pc, #96]	; (e13c <serial_console_init+0xd4>)
    e0dc:	4b18      	ldr	r3, [pc, #96]	; (e140 <serial_console_init+0xd8>)
    e0de:	601a      	str	r2, [r3, #0]
static inline bool usart_serial_init(
		struct usart_module *const module,
		usart_inst_t const hw,
		const struct usart_config *const config)
{
	if (usart_init(module, hw, config) == STATUS_OK) {
    e0e0:	466a      	mov	r2, sp
    e0e2:	4918      	ldr	r1, [pc, #96]	; (e144 <serial_console_init+0xdc>)
    e0e4:	0028      	movs	r0, r5
    e0e6:	4b18      	ldr	r3, [pc, #96]	; (e148 <serial_console_init+0xe0>)
    e0e8:	4798      	blx	r3

	usart_serial_init(module, hw, config);
# if defined(__GNUC__)
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
    e0ea:	4f18      	ldr	r7, [pc, #96]	; (e14c <serial_console_init+0xe4>)
    e0ec:	683b      	ldr	r3, [r7, #0]
    e0ee:	6898      	ldr	r0, [r3, #8]
    e0f0:	2100      	movs	r1, #0
    e0f2:	4e17      	ldr	r6, [pc, #92]	; (e150 <serial_console_init+0xe8>)
    e0f4:	47b0      	blx	r6
	setbuf(stdin, NULL);
    e0f6:	683b      	ldr	r3, [r7, #0]
    e0f8:	6858      	ldr	r0, [r3, #4]
    e0fa:	2100      	movs	r1, #0
    e0fc:	47b0      	blx	r6
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    e0fe:	682e      	ldr	r6, [r5, #0]

#if USART_CALLBACK_MODE == true
	/* Enable Global interrupt for module */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    e100:	0030      	movs	r0, r6
    e102:	4b14      	ldr	r3, [pc, #80]	; (e154 <serial_console_init+0xec>)
    e104:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    e106:	231f      	movs	r3, #31
    e108:	4018      	ands	r0, r3
    e10a:	4084      	lsls	r4, r0
    e10c:	4b12      	ldr	r3, [pc, #72]	; (e158 <serial_console_init+0xf0>)
    e10e:	601c      	str	r4, [r3, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    e110:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    e112:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    e114:	2b00      	cmp	r3, #0
    e116:	d1fc      	bne.n	e112 <serial_console_init+0xaa>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Enable USART module */
	usart_hw->CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    e118:	6832      	ldr	r2, [r6, #0]
    e11a:	3302      	adds	r3, #2
    e11c:	4313      	orrs	r3, r2
    e11e:	6033      	str	r3, [r6, #0]

	stdio_serial_init(&cdc_uart_module, CONF_STDIO_USART_MODULE, &usart_conf);
	usart_enable(&cdc_uart_module);
}
    e120:	b011      	add	sp, #68	; 0x44
    e122:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e124:	00160002 	.word	0x00160002
    e128:	00170002 	.word	0x00170002
    e12c:	20001980 	.word	0x20001980
    e130:	2000287c 	.word	0x2000287c
    e134:	0000e051 	.word	0x0000e051
    e138:	20002878 	.word	0x20002878
    e13c:	0000e025 	.word	0x0000e025
    e140:	20002874 	.word	0x20002874
    e144:	42000c00 	.word	0x42000c00
    e148:	0000ccb1 	.word	0x0000ccb1
    e14c:	200001a0 	.word	0x200001a0
    e150:	00011ae5 	.word	0x00011ae5
    e154:	0000cc25 	.word	0x0000cc25
    e158:	e000e100 	.word	0xe000e100

0000e15c <tc_cc0_cb>:
{
	bus_timer_callback();
}

void tc_cc0_cb(struct tc_module *const module_inst)
{
    e15c:	b510      	push	{r4, lr}
	static uint16_t tc_count;
	tc_set_count_value(&tc_instance, 0);
    e15e:	2100      	movs	r1, #0
    e160:	480a      	ldr	r0, [pc, #40]	; (e18c <tc_cc0_cb+0x30>)
    e162:	4b0b      	ldr	r3, [pc, #44]	; (e190 <tc_cc0_cb+0x34>)
    e164:	4798      	blx	r3
	tc_count += 1;
    e166:	4a0b      	ldr	r2, [pc, #44]	; (e194 <tc_cc0_cb+0x38>)
    e168:	8813      	ldrh	r3, [r2, #0]
    e16a:	3301      	adds	r3, #1
    e16c:	b29b      	uxth	r3, r3
    e16e:	8013      	strh	r3, [r2, #0]
	if (tc_count >= timeout_count)
    e170:	4a09      	ldr	r2, [pc, #36]	; (e198 <tc_cc0_cb+0x3c>)
    e172:	6812      	ldr	r2, [r2, #0]
    e174:	4293      	cmp	r3, r2
    e176:	d307      	bcc.n	e188 <tc_cc0_cb+0x2c>
	{
		tc_count = 0;
    e178:	2200      	movs	r2, #0
    e17a:	4b06      	ldr	r3, [pc, #24]	; (e194 <tc_cc0_cb+0x38>)
    e17c:	801a      	strh	r2, [r3, #0]
		if (timer_callback != NULL)
    e17e:	4b07      	ldr	r3, [pc, #28]	; (e19c <tc_cc0_cb+0x40>)
    e180:	681b      	ldr	r3, [r3, #0]
    e182:	2b00      	cmp	r3, #0
    e184:	d000      	beq.n	e188 <tc_cc0_cb+0x2c>
		{
			timer_callback();
    e186:	4798      	blx	r3
		}
	}
}
    e188:	bd10      	pop	{r4, pc}
    e18a:	46c0      	nop			; (mov r8, r8)
    e18c:	20002890 	.word	0x20002890
    e190:	0000de75 	.word	0x0000de75
    e194:	200019b4 	.word	0x200019b4
    e198:	2000288c 	.word	0x2000288c
    e19c:	20002884 	.word	0x20002884

0000e1a0 <hw_timer_init>:

void tc_cc0_cb(struct tc_module *const module_inst);
void bus_tc_cc0_cb(struct tc_module *const module_inst);

void hw_timer_init(void)
{
    e1a0:	b510      	push	{r4, lr}
    e1a2:	b08e      	sub	sp, #56	; 0x38
{
	/* Sanity check arguments */
	Assert(config);

	/* Write default config to config struct */
	config->clock_source               = GCLK_GENERATOR_0;
    e1a4:	2300      	movs	r3, #0
    e1a6:	466a      	mov	r2, sp
    e1a8:	7013      	strb	r3, [r2, #0]
	config->counter_size               = TC_COUNTER_SIZE_16BIT;
    e1aa:	70d3      	strb	r3, [r2, #3]
	config->clock_prescaler            = TC_CLOCK_PRESCALER_DIV1;
	config->wave_generation            = TC_WAVE_GENERATION_NORMAL_FREQ;
    e1ac:	7193      	strb	r3, [r2, #6]
	config->reload_action              = TC_RELOAD_ACTION_GCLK;
    e1ae:	71d3      	strb	r3, [r2, #7]
	config->run_in_standby             = false;
    e1b0:	7053      	strb	r3, [r2, #1]
#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	config->on_demand                  = false;
    e1b2:	7093      	strb	r3, [r2, #2]
#endif
	config->waveform_invert_output     = TC_WAVEFORM_INVERT_OUTPUT_NONE;
    e1b4:	7213      	strb	r3, [r2, #8]
	config->enable_capture_on_channel[TC_COMPARE_CAPTURE_CHANNEL_0] = false;
    e1b6:	7253      	strb	r3, [r2, #9]
	config->enable_capture_on_channel[TC_COMPARE_CAPTURE_CHANNEL_1] = false;
    e1b8:	7293      	strb	r3, [r2, #10]
#ifdef 	FEATURE_TC_IO_CAPTURE
	config->enable_capture_on_IO[TC_COMPARE_CAPTURE_CHANNEL_0] = false;
    e1ba:	72d3      	strb	r3, [r2, #11]
	config->enable_capture_on_IO[TC_COMPARE_CAPTURE_CHANNEL_1] = false;
    e1bc:	7313      	strb	r3, [r2, #12]
#endif

	config->count_direction            = TC_COUNT_DIRECTION_UP;
    e1be:	7393      	strb	r3, [r2, #14]
	config->oneshot                    = false;
    e1c0:	7353      	strb	r3, [r2, #13]

	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].enabled = false;
    e1c2:	7413      	strb	r3, [r2, #16]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].pin_out = 0;
    e1c4:	9305      	str	r3, [sp, #20]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].pin_mux = 0;
    e1c6:	9306      	str	r3, [sp, #24]

	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].enabled = false;
    e1c8:	7713      	strb	r3, [r2, #28]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].pin_out = 0;
    e1ca:	9308      	str	r3, [sp, #32]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].pin_mux = 0;
    e1cc:	9309      	str	r3, [sp, #36]	; 0x24

	config->counter_16_bit.value                   = 0x0000;
    e1ce:	8513      	strh	r3, [r2, #40]	; 0x28
	config->counter_16_bit.compare_capture_channel\
		[TC_COMPARE_CAPTURE_CHANNEL_0]                        = 0x0000;
	config->counter_16_bit.compare_capture_channel\
		[TC_COMPARE_CAPTURE_CHANNEL_1]                        = 0x0000;
#ifdef FEATURE_TC_DOUBLE_BUFFERED
	config->double_buffering_enabled = false;
    e1d0:	3334      	adds	r3, #52	; 0x34
    e1d2:	2200      	movs	r2, #0
    e1d4:	4669      	mov	r1, sp
    e1d6:	54ca      	strb	r2, [r1, r3]

	tc_get_config_defaults(&config_tc);

	config_tc.counter_size = TC_COUNTER_SIZE_16BIT;
	config_tc.clock_source = GCLK_GENERATOR_0;
	config_tc.clock_prescaler = TC_CLOCK_PRESCALER_DIV1024;
    e1d8:	23e0      	movs	r3, #224	; 0xe0
    e1da:	00db      	lsls	r3, r3, #3
    e1dc:	808b      	strh	r3, [r1, #4]
	config_tc.counter_8_bit.period = 0;
    e1de:	2329      	movs	r3, #41	; 0x29
    e1e0:	2200      	movs	r2, #0
    e1e2:	54ca      	strb	r2, [r1, r3]
	config_tc.counter_16_bit.compare_capture_channel[0] = TC_COUNT_1SEC;
    e1e4:	4b0c      	ldr	r3, [pc, #48]	; (e218 <hw_timer_init+0x78>)
    e1e6:	466a      	mov	r2, sp
    e1e8:	854b      	strh	r3, [r1, #42]	; 0x2a
	config_tc.counter_16_bit.compare_capture_channel[1] = 0xFFFF;
    e1ea:	2301      	movs	r3, #1
    e1ec:	425b      	negs	r3, r3
    e1ee:	858b      	strh	r3, [r1, #44]	; 0x2c

	tc_init(&tc_instance, CONF_TC_MODULE, &config_tc);
    e1f0:	4c0a      	ldr	r4, [pc, #40]	; (e21c <hw_timer_init+0x7c>)
    e1f2:	490b      	ldr	r1, [pc, #44]	; (e220 <hw_timer_init+0x80>)
    e1f4:	0020      	movs	r0, r4
    e1f6:	4b0b      	ldr	r3, [pc, #44]	; (e224 <hw_timer_init+0x84>)
    e1f8:	4798      	blx	r3
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    e1fa:	6822      	ldr	r2, [r4, #0]

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    e1fc:	6913      	ldr	r3, [r2, #16]
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

	while (tc_is_syncing(module_inst)) {
    e1fe:	2b00      	cmp	r3, #0
    e200:	d1fc      	bne.n	e1fc <hw_timer_init+0x5c>
		/* Wait for sync */
	}

	/* Enable TC module */
	tc_module->CTRLA.reg |= TC_CTRLA_ENABLE;
    e202:	6811      	ldr	r1, [r2, #0]
    e204:	3302      	adds	r3, #2
    e206:	430b      	orrs	r3, r1
    e208:	6013      	str	r3, [r2, #0]

	tc_enable(&tc_instance);
	
	tc_register_callback(&tc_instance, tc_cc0_cb,
    e20a:	2202      	movs	r2, #2
    e20c:	4906      	ldr	r1, [pc, #24]	; (e228 <hw_timer_init+0x88>)
    e20e:	4803      	ldr	r0, [pc, #12]	; (e21c <hw_timer_init+0x7c>)
    e210:	4b06      	ldr	r3, [pc, #24]	; (e22c <hw_timer_init+0x8c>)
    e212:	4798      	blx	r3
						TC_CALLBACK_CC_CHANNEL0);
}
    e214:	b00e      	add	sp, #56	; 0x38
    e216:	bd10      	pop	{r4, pc}
    e218:	ffffb71b 	.word	0xffffb71b
    e21c:	20002890 	.word	0x20002890
    e220:	42002400 	.word	0x42002400
    e224:	0000dba1 	.word	0x0000dba1
    e228:	0000e15d 	.word	0x0000e15d
    e22c:	0000daad 	.word	0x0000daad

0000e230 <main>:
//	printf("DBG log1\r\n");
//}

/* main function */
int main(void)
{
    e230:	b570      	push	{r4, r5, r6, lr}

	/* Initialize RTC */
	rtc_init();
    e232:	4b32      	ldr	r3, [pc, #200]	; (e2fc <main+0xcc>)
    e234:	4798      	blx	r3
	
	/* initialize LED */
	initialise_led();
    e236:	4b32      	ldr	r3, [pc, #200]	; (e300 <main+0xd0>)
    e238:	4798      	blx	r3
	
	led_ctrl_set_color(LED_COLOR_BLUE, LED_MODE_BLINK_NORMAL);	
    e23a:	2103      	movs	r1, #3
    e23c:	2000      	movs	r0, #0
    e23e:	4b31      	ldr	r3, [pc, #196]	; (e304 <main+0xd4>)
    e240:	4798      	blx	r3
		
	/* system clock initialization */
	system_init();
    e242:	4b31      	ldr	r3, [pc, #196]	; (e308 <main+0xd8>)
    e244:	4798      	blx	r3

	//i2c configure
	configure_sensor_i2c();
    e246:	4b31      	ldr	r3, [pc, #196]	; (e30c <main+0xdc>)
    e248:	4798      	blx	r3
	//Initialize BHI160
	bhy_driver_init(_bhi_fw, _bhi_fw_len);
    e24a:	4b31      	ldr	r3, [pc, #196]	; (e310 <main+0xe0>)
    e24c:	6819      	ldr	r1, [r3, #0]
    e24e:	4831      	ldr	r0, [pc, #196]	; (e314 <main+0xe4>)
    e250:	4b31      	ldr	r3, [pc, #196]	; (e318 <main+0xe8>)
    e252:	4798      	blx	r3
	
	/* delay routine initialization */
	delay_init();
    e254:	4b31      	ldr	r3, [pc, #196]	; (e31c <main+0xec>)
    e256:	4798      	blx	r3

	/* configure adc for battery measurement */
	configure_adc();
    e258:	4b31      	ldr	r3, [pc, #196]	; (e320 <main+0xf0>)
    e25a:	4798      	blx	r3
 
#ifdef DEBUG_SUPPORT
	/* Initialize serial console for debugging */
	serial_console_init();
    e25c:	4b31      	ldr	r3, [pc, #196]	; (e324 <main+0xf4>)
    e25e:	4798      	blx	r3
#endif

	
	DBG_LOG("Initializing Wearable Demo Device");
    e260:	4e31      	ldr	r6, [pc, #196]	; (e328 <main+0xf8>)
    e262:	0030      	movs	r0, r6
    e264:	4d31      	ldr	r5, [pc, #196]	; (e32c <main+0xfc>)
    e266:	47a8      	blx	r5
    e268:	4831      	ldr	r0, [pc, #196]	; (e330 <main+0x100>)
    e26a:	4c32      	ldr	r4, [pc, #200]	; (e334 <main+0x104>)
    e26c:	47a0      	blx	r4
	DBG_LOG("cpu_freq=%d\n",(int)system_cpu_clock_get_hz());
    e26e:	0030      	movs	r0, r6
    e270:	47a8      	blx	r5
 *
 * \return Current CPU frequency in Hz.
 */
static inline uint32_t system_cpu_clock_get_hz(void)
{
	return (system_gclk_gen_get_hz(GCLK_GENERATOR_0) >> (MCLK->CPUDIV.reg - 1));
    e272:	2000      	movs	r0, #0
    e274:	4b30      	ldr	r3, [pc, #192]	; (e338 <main+0x108>)
    e276:	4798      	blx	r3
    e278:	4b30      	ldr	r3, [pc, #192]	; (e33c <main+0x10c>)
    e27a:	791b      	ldrb	r3, [r3, #4]
    e27c:	3b01      	subs	r3, #1
    e27e:	0001      	movs	r1, r0
    e280:	40d9      	lsrs	r1, r3
    e282:	482f      	ldr	r0, [pc, #188]	; (e340 <main+0x110>)
    e284:	47a0      	blx	r4
	DBG_LOG("Firmware version: %s.%s", FIRMWARE_MAJOR_VER, FIRMWARE_MINOR_VER);
    e286:	0030      	movs	r0, r6
    e288:	47a8      	blx	r5
    e28a:	4a2e      	ldr	r2, [pc, #184]	; (e344 <main+0x114>)
    e28c:	492e      	ldr	r1, [pc, #184]	; (e348 <main+0x118>)
    e28e:	482f      	ldr	r0, [pc, #188]	; (e34c <main+0x11c>)
    e290:	47a0      	blx	r4
	
	/* Initialize the BSP. */
	nm_bsp_init();
    e292:	4b2f      	ldr	r3, [pc, #188]	; (e350 <main+0x120>)
    e294:	4798      	blx	r3
	
	nvm_init();
    e296:	4b2f      	ldr	r3, [pc, #188]	; (e354 <main+0x124>)
    e298:	4798      	blx	r3
	
	initialise_button();
    e29a:	4b2f      	ldr	r3, [pc, #188]	; (e358 <main+0x128>)
    e29c:	4798      	blx	r3
	
	buttonInitCheck();
    e29e:	4b2f      	ldr	r3, [pc, #188]	; (e35c <main+0x12c>)
    e2a0:	4798      	blx	r3

	/* Hardware timer */
	hw_timer_init();
    e2a2:	4b2f      	ldr	r3, [pc, #188]	; (e360 <main+0x130>)
    e2a4:	4798      	blx	r3
	//Initialize bme280
	wearable_bme280_init();
    e2a6:	4b2f      	ldr	r3, [pc, #188]	; (e364 <main+0x134>)
    e2a8:	4798      	blx	r3
	//Initialize veml60xx
	veml60xx_init();	
    e2aa:	4b2f      	ldr	r3, [pc, #188]	; (e368 <main+0x138>)
    e2ac:	4798      	blx	r3

	wifiInit();
    e2ae:	4b2f      	ldr	r3, [pc, #188]	; (e36c <main+0x13c>)
    e2b0:	4798      	blx	r3
	
	env_sensor_data_init();
    e2b2:	4b2f      	ldr	r3, [pc, #188]	; (e370 <main+0x140>)
    e2b4:	4798      	blx	r3
	
	enable_rotation_vector();
    e2b6:	4b2f      	ldr	r3, [pc, #188]	; (e374 <main+0x144>)
    e2b8:	4798      	blx	r3
	
	while (1) {
		/* Handle pending events from network controller. */
		wifiTaskExecute();
    e2ba:	4d2f      	ldr	r5, [pc, #188]	; (e378 <main+0x148>)
		if(tick_rotation_data)
    e2bc:	4c2f      	ldr	r4, [pc, #188]	; (e37c <main+0x14c>)
		{
			tick_rotation_data = 0;
    e2be:	0026      	movs	r6, r4
	
	enable_rotation_vector();
	
	while (1) {
		/* Handle pending events from network controller. */
		wifiTaskExecute();
    e2c0:	47a8      	blx	r5
		if(tick_rotation_data)
    e2c2:	7823      	ldrb	r3, [r4, #0]
    e2c4:	2b00      	cmp	r3, #0
    e2c6:	d007      	beq.n	e2d8 <main+0xa8>
		{
			tick_rotation_data = 0;
    e2c8:	2300      	movs	r3, #0
    e2ca:	7033      	strb	r3, [r6, #0]
			if (getWiFiMode()==APP_STA)
    e2cc:	4b2c      	ldr	r3, [pc, #176]	; (e380 <main+0x150>)
    e2ce:	4798      	blx	r3
    e2d0:	2800      	cmp	r0, #0
    e2d2:	d101      	bne.n	e2d8 <main+0xa8>
				motion_sensor_execute();
    e2d4:	4b2b      	ldr	r3, [pc, #172]	; (e384 <main+0x154>)
    e2d6:	4798      	blx	r3
		}
		if(tick_2second == 1)
    e2d8:	4b2b      	ldr	r3, [pc, #172]	; (e388 <main+0x158>)
    e2da:	781b      	ldrb	r3, [r3, #0]
    e2dc:	2b01      	cmp	r3, #1
    e2de:	d1ef      	bne.n	e2c0 <main+0x90>
		{
			tick_2second = 0;
    e2e0:	2200      	movs	r2, #0
    e2e2:	4b29      	ldr	r3, [pc, #164]	; (e388 <main+0x158>)
    e2e4:	701a      	strb	r2, [r3, #0]
			if (getWiFiMode()==APP_STA && getWiFiStates() > WIFI_TASK_MQTT_SUBSCRIBE)
    e2e6:	4b26      	ldr	r3, [pc, #152]	; (e380 <main+0x150>)
    e2e8:	4798      	blx	r3
    e2ea:	2800      	cmp	r0, #0
    e2ec:	d1e8      	bne.n	e2c0 <main+0x90>
    e2ee:	4b27      	ldr	r3, [pc, #156]	; (e38c <main+0x15c>)
    e2f0:	4798      	blx	r3
    e2f2:	2803      	cmp	r0, #3
    e2f4:	d9e4      	bls.n	e2c0 <main+0x90>
				env_sensor_execute();
    e2f6:	4b26      	ldr	r3, [pc, #152]	; (e390 <main+0x160>)
    e2f8:	4798      	blx	r3
    e2fa:	e7e1      	b.n	e2c0 <main+0x90>
    e2fc:	0000c199 	.word	0x0000c199
    e300:	00002a71 	.word	0x00002a71
    e304:	00002b19 	.word	0x00002b19
    e308:	0000da89 	.word	0x0000da89
    e30c:	0000a7a5 	.word	0x0000a7a5
    e310:	0001b8f0 	.word	0x0001b8f0
    e314:	00015428 	.word	0x00015428
    e318:	0000a2e5 	.word	0x0000a2e5
    e31c:	0000c4b5 	.word	0x0000c4b5
    e320:	00009a81 	.word	0x00009a81
    e324:	0000e069 	.word	0x0000e069
    e328:	000140b0 	.word	0x000140b0
    e32c:	00011aad 	.word	0x00011aad
    e330:	0001bf0c 	.word	0x0001bf0c
    e334:	0001198d 	.word	0x0001198d
    e338:	0000d87d 	.word	0x0000d87d
    e33c:	40000400 	.word	0x40000400
    e340:	0001bf30 	.word	0x0001bf30
    e344:	0001bf40 	.word	0x0001bf40
    e348:	0001bf44 	.word	0x0001bf44
    e34c:	0001bf48 	.word	0x0001bf48
    e350:	00003ec5 	.word	0x00003ec5
    e354:	00002d75 	.word	0x00002d75
    e358:	00000481 	.word	0x00000481
    e35c:	000004ad 	.word	0x000004ad
    e360:	0000e1a1 	.word	0x0000e1a1
    e364:	0000bed9 	.word	0x0000bed9
    e368:	00002f59 	.word	0x00002f59
    e36c:	00003a05 	.word	0x00003a05
    e370:	00001fd1 	.word	0x00001fd1
    e374:	00009d15 	.word	0x00009d15
    e378:	00003b9d 	.word	0x00003b9d
    e37c:	20002542 	.word	0x20002542
    e380:	000039f9 	.word	0x000039f9
    e384:	00002ced 	.word	0x00002ced
    e388:	20002549 	.word	0x20002549
    e38c:	000039ed 	.word	0x000039ed
    e390:	0000200d 	.word	0x0000200d

0000e394 <floor>:
    e394:	4a45      	ldr	r2, [pc, #276]	; (e4ac <floor+0x118>)
    e396:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e398:	4656      	mov	r6, sl
    e39a:	4692      	mov	sl, r2
    e39c:	004b      	lsls	r3, r1, #1
    e39e:	0d5b      	lsrs	r3, r3, #21
    e3a0:	449a      	add	sl, r3
    e3a2:	464d      	mov	r5, r9
    e3a4:	465f      	mov	r7, fp
    e3a6:	4644      	mov	r4, r8
    e3a8:	4652      	mov	r2, sl
    e3aa:	b4f0      	push	{r4, r5, r6, r7}
    e3ac:	4689      	mov	r9, r1
    e3ae:	0005      	movs	r5, r0
    e3b0:	000c      	movs	r4, r1
    e3b2:	000e      	movs	r6, r1
    e3b4:	0007      	movs	r7, r0
    e3b6:	2a13      	cmp	r2, #19
    e3b8:	dc22      	bgt.n	e400 <floor+0x6c>
    e3ba:	2a00      	cmp	r2, #0
    e3bc:	db47      	blt.n	e44e <floor+0xba>
    e3be:	4652      	mov	r2, sl
    e3c0:	4b3b      	ldr	r3, [pc, #236]	; (e4b0 <floor+0x11c>)
    e3c2:	4113      	asrs	r3, r2
    e3c4:	4698      	mov	r8, r3
    e3c6:	000b      	movs	r3, r1
    e3c8:	4642      	mov	r2, r8
    e3ca:	4013      	ands	r3, r2
    e3cc:	4303      	orrs	r3, r0
    e3ce:	d011      	beq.n	e3f4 <floor+0x60>
    e3d0:	4a38      	ldr	r2, [pc, #224]	; (e4b4 <floor+0x120>)
    e3d2:	4b39      	ldr	r3, [pc, #228]	; (e4b8 <floor+0x124>)
    e3d4:	f001 fc0a 	bl	fbec <__aeabi_dadd>
    e3d8:	2200      	movs	r2, #0
    e3da:	2300      	movs	r3, #0
    e3dc:	f001 fbc6 	bl	fb6c <__aeabi_dcmpgt>
    e3e0:	2800      	cmp	r0, #0
    e3e2:	d005      	beq.n	e3f0 <floor+0x5c>
    e3e4:	2c00      	cmp	r4, #0
    e3e6:	db41      	blt.n	e46c <floor+0xd8>
    e3e8:	464e      	mov	r6, r9
    e3ea:	4643      	mov	r3, r8
    e3ec:	2700      	movs	r7, #0
    e3ee:	439e      	bics	r6, r3
    e3f0:	0038      	movs	r0, r7
    e3f2:	0031      	movs	r1, r6
    e3f4:	bc3c      	pop	{r2, r3, r4, r5}
    e3f6:	4690      	mov	r8, r2
    e3f8:	4699      	mov	r9, r3
    e3fa:	46a2      	mov	sl, r4
    e3fc:	46ab      	mov	fp, r5
    e3fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e400:	4652      	mov	r2, sl
    e402:	2a33      	cmp	r2, #51	; 0x33
    e404:	dd08      	ble.n	e418 <floor+0x84>
    e406:	2380      	movs	r3, #128	; 0x80
    e408:	00db      	lsls	r3, r3, #3
    e40a:	459a      	cmp	sl, r3
    e40c:	d1f2      	bne.n	e3f4 <floor+0x60>
    e40e:	0002      	movs	r2, r0
    e410:	000b      	movs	r3, r1
    e412:	f001 fbeb 	bl	fbec <__aeabi_dadd>
    e416:	e7ed      	b.n	e3f4 <floor+0x60>
    e418:	4a28      	ldr	r2, [pc, #160]	; (e4bc <floor+0x128>)
    e41a:	4694      	mov	ip, r2
    e41c:	2201      	movs	r2, #1
    e41e:	4463      	add	r3, ip
    e420:	4252      	negs	r2, r2
    e422:	40da      	lsrs	r2, r3
    e424:	4693      	mov	fp, r2
    e426:	4202      	tst	r2, r0
    e428:	d0e4      	beq.n	e3f4 <floor+0x60>
    e42a:	4a22      	ldr	r2, [pc, #136]	; (e4b4 <floor+0x120>)
    e42c:	4b22      	ldr	r3, [pc, #136]	; (e4b8 <floor+0x124>)
    e42e:	f001 fbdd 	bl	fbec <__aeabi_dadd>
    e432:	2200      	movs	r2, #0
    e434:	2300      	movs	r3, #0
    e436:	f001 fb99 	bl	fb6c <__aeabi_dcmpgt>
    e43a:	2800      	cmp	r0, #0
    e43c:	d0d8      	beq.n	e3f0 <floor+0x5c>
    e43e:	2c00      	cmp	r4, #0
    e440:	db1a      	blt.n	e478 <floor+0xe4>
    e442:	465b      	mov	r3, fp
    e444:	464e      	mov	r6, r9
    e446:	439f      	bics	r7, r3
    e448:	0038      	movs	r0, r7
    e44a:	0031      	movs	r1, r6
    e44c:	e7d2      	b.n	e3f4 <floor+0x60>
    e44e:	4a19      	ldr	r2, [pc, #100]	; (e4b4 <floor+0x120>)
    e450:	4b19      	ldr	r3, [pc, #100]	; (e4b8 <floor+0x124>)
    e452:	f001 fbcb 	bl	fbec <__aeabi_dadd>
    e456:	2200      	movs	r2, #0
    e458:	2300      	movs	r3, #0
    e45a:	f001 fb87 	bl	fb6c <__aeabi_dcmpgt>
    e45e:	2800      	cmp	r0, #0
    e460:	d0c6      	beq.n	e3f0 <floor+0x5c>
    e462:	2c00      	cmp	r4, #0
    e464:	db16      	blt.n	e494 <floor+0x100>
    e466:	2700      	movs	r7, #0
    e468:	2600      	movs	r6, #0
    e46a:	e7c1      	b.n	e3f0 <floor+0x5c>
    e46c:	2380      	movs	r3, #128	; 0x80
    e46e:	4652      	mov	r2, sl
    e470:	035b      	lsls	r3, r3, #13
    e472:	4113      	asrs	r3, r2
    e474:	4499      	add	r9, r3
    e476:	e7b7      	b.n	e3e8 <floor+0x54>
    e478:	4653      	mov	r3, sl
    e47a:	2b14      	cmp	r3, #20
    e47c:	d012      	beq.n	e4a4 <floor+0x110>
    e47e:	2334      	movs	r3, #52	; 0x34
    e480:	4652      	mov	r2, sl
    e482:	2701      	movs	r7, #1
    e484:	1a9b      	subs	r3, r3, r2
    e486:	409f      	lsls	r7, r3
    e488:	197f      	adds	r7, r7, r5
    e48a:	42af      	cmp	r7, r5
    e48c:	419b      	sbcs	r3, r3
    e48e:	425b      	negs	r3, r3
    e490:	4499      	add	r9, r3
    e492:	e7d6      	b.n	e442 <floor+0xae>
    e494:	0064      	lsls	r4, r4, #1
    e496:	0864      	lsrs	r4, r4, #1
    e498:	4325      	orrs	r5, r4
    e49a:	2700      	movs	r7, #0
    e49c:	2d00      	cmp	r5, #0
    e49e:	d0a7      	beq.n	e3f0 <floor+0x5c>
    e4a0:	4e07      	ldr	r6, [pc, #28]	; (e4c0 <floor+0x12c>)
    e4a2:	e7a5      	b.n	e3f0 <floor+0x5c>
    e4a4:	3b13      	subs	r3, #19
    e4a6:	469c      	mov	ip, r3
    e4a8:	44e1      	add	r9, ip
    e4aa:	e7ca      	b.n	e442 <floor+0xae>
    e4ac:	fffffc01 	.word	0xfffffc01
    e4b0:	000fffff 	.word	0x000fffff
    e4b4:	8800759c 	.word	0x8800759c
    e4b8:	7e37e43c 	.word	0x7e37e43c
    e4bc:	fffffbed 	.word	0xfffffbed
    e4c0:	bff00000 	.word	0xbff00000

0000e4c4 <pow>:
    e4c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    e4c6:	465f      	mov	r7, fp
    e4c8:	464d      	mov	r5, r9
    e4ca:	4656      	mov	r6, sl
    e4cc:	4644      	mov	r4, r8
    e4ce:	b4f0      	push	{r4, r5, r6, r7}
    e4d0:	b091      	sub	sp, #68	; 0x44
    e4d2:	001f      	movs	r7, r3
    e4d4:	0004      	movs	r4, r0
    e4d6:	000d      	movs	r5, r1
    e4d8:	0016      	movs	r6, r2
    e4da:	f000 f9af 	bl	e83c <__ieee754_pow>
    e4de:	4bcf      	ldr	r3, [pc, #828]	; (e81c <pow+0x358>)
    e4e0:	9002      	str	r0, [sp, #8]
    e4e2:	9103      	str	r1, [sp, #12]
    e4e4:	469b      	mov	fp, r3
    e4e6:	781b      	ldrb	r3, [r3, #0]
    e4e8:	b25b      	sxtb	r3, r3
    e4ea:	4699      	mov	r9, r3
    e4ec:	3301      	adds	r3, #1
    e4ee:	d04f      	beq.n	e590 <pow+0xcc>
    e4f0:	0032      	movs	r2, r6
    e4f2:	003b      	movs	r3, r7
    e4f4:	0030      	movs	r0, r6
    e4f6:	0039      	movs	r1, r7
    e4f8:	f003 f896 	bl	11628 <__aeabi_dcmpun>
    e4fc:	9000      	str	r0, [sp, #0]
    e4fe:	2800      	cmp	r0, #0
    e500:	d146      	bne.n	e590 <pow+0xcc>
    e502:	0022      	movs	r2, r4
    e504:	002b      	movs	r3, r5
    e506:	0020      	movs	r0, r4
    e508:	0029      	movs	r1, r5
    e50a:	f003 f88d 	bl	11628 <__aeabi_dcmpun>
    e50e:	2200      	movs	r2, #0
    e510:	4682      	mov	sl, r0
    e512:	2800      	cmp	r0, #0
    e514:	d134      	bne.n	e580 <pow+0xbc>
    e516:	2300      	movs	r3, #0
    e518:	0020      	movs	r0, r4
    e51a:	0029      	movs	r1, r5
    e51c:	f001 fb0c 	bl	fb38 <__aeabi_dcmpeq>
    e520:	2800      	cmp	r0, #0
    e522:	d03a      	beq.n	e59a <pow+0xd6>
    e524:	2200      	movs	r2, #0
    e526:	2300      	movs	r3, #0
    e528:	0030      	movs	r0, r6
    e52a:	0039      	movs	r1, r7
    e52c:	f001 fb04 	bl	fb38 <__aeabi_dcmpeq>
    e530:	9005      	str	r0, [sp, #20]
    e532:	2800      	cmp	r0, #0
    e534:	d100      	bne.n	e538 <pow+0x74>
    e536:	e074      	b.n	e622 <pow+0x15e>
    e538:	ab06      	add	r3, sp, #24
    e53a:	4698      	mov	r8, r3
    e53c:	2301      	movs	r3, #1
    e53e:	4642      	mov	r2, r8
    e540:	9306      	str	r3, [sp, #24]
    e542:	4bb7      	ldr	r3, [pc, #732]	; (e820 <pow+0x35c>)
    e544:	6053      	str	r3, [r2, #4]
    e546:	4643      	mov	r3, r8
    e548:	4652      	mov	r2, sl
    e54a:	609c      	str	r4, [r3, #8]
    e54c:	60dd      	str	r5, [r3, #12]
    e54e:	621a      	str	r2, [r3, #32]
    e550:	611e      	str	r6, [r3, #16]
    e552:	615f      	str	r7, [r3, #20]
    e554:	4642      	mov	r2, r8
    e556:	2300      	movs	r3, #0
    e558:	2400      	movs	r4, #0
    e55a:	6193      	str	r3, [r2, #24]
    e55c:	61d4      	str	r4, [r2, #28]
    e55e:	464b      	mov	r3, r9
    e560:	2b00      	cmp	r3, #0
    e562:	d100      	bne.n	e566 <pow+0xa2>
    e564:	e094      	b.n	e690 <pow+0x1cc>
    e566:	2300      	movs	r3, #0
    e568:	4cae      	ldr	r4, [pc, #696]	; (e824 <pow+0x360>)
    e56a:	9300      	str	r3, [sp, #0]
    e56c:	9401      	str	r4, [sp, #4]
    e56e:	9800      	ldr	r0, [sp, #0]
    e570:	9901      	ldr	r1, [sp, #4]
    e572:	b011      	add	sp, #68	; 0x44
    e574:	bc3c      	pop	{r2, r3, r4, r5}
    e576:	4690      	mov	r8, r2
    e578:	4699      	mov	r9, r3
    e57a:	46a2      	mov	sl, r4
    e57c:	46ab      	mov	fp, r5
    e57e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e580:	2300      	movs	r3, #0
    e582:	0030      	movs	r0, r6
    e584:	0039      	movs	r1, r7
    e586:	f001 fad7 	bl	fb38 <__aeabi_dcmpeq>
    e58a:	2800      	cmp	r0, #0
    e58c:	d000      	beq.n	e590 <pow+0xcc>
    e58e:	e0eb      	b.n	e768 <pow+0x2a4>
    e590:	9b02      	ldr	r3, [sp, #8]
    e592:	9c03      	ldr	r4, [sp, #12]
    e594:	9300      	str	r3, [sp, #0]
    e596:	9401      	str	r4, [sp, #4]
    e598:	e7e9      	b.n	e56e <pow+0xaa>
    e59a:	9802      	ldr	r0, [sp, #8]
    e59c:	9903      	ldr	r1, [sp, #12]
    e59e:	f000 ff7d 	bl	f49c <finite>
    e5a2:	4681      	mov	r9, r0
    e5a4:	2800      	cmp	r0, #0
    e5a6:	d100      	bne.n	e5aa <pow+0xe6>
    e5a8:	e086      	b.n	e6b8 <pow+0x1f4>
    e5aa:	9802      	ldr	r0, [sp, #8]
    e5ac:	9903      	ldr	r1, [sp, #12]
    e5ae:	2200      	movs	r2, #0
    e5b0:	2300      	movs	r3, #0
    e5b2:	f001 fac1 	bl	fb38 <__aeabi_dcmpeq>
    e5b6:	2800      	cmp	r0, #0
    e5b8:	d0ea      	beq.n	e590 <pow+0xcc>
    e5ba:	0020      	movs	r0, r4
    e5bc:	0029      	movs	r1, r5
    e5be:	f000 ff6d 	bl	f49c <finite>
    e5c2:	9a02      	ldr	r2, [sp, #8]
    e5c4:	9b03      	ldr	r3, [sp, #12]
    e5c6:	9200      	str	r2, [sp, #0]
    e5c8:	9301      	str	r3, [sp, #4]
    e5ca:	2800      	cmp	r0, #0
    e5cc:	d0cf      	beq.n	e56e <pow+0xaa>
    e5ce:	0030      	movs	r0, r6
    e5d0:	0039      	movs	r1, r7
    e5d2:	f000 ff63 	bl	f49c <finite>
    e5d6:	9a02      	ldr	r2, [sp, #8]
    e5d8:	9b03      	ldr	r3, [sp, #12]
    e5da:	9200      	str	r2, [sp, #0]
    e5dc:	9301      	str	r3, [sp, #4]
    e5de:	2800      	cmp	r0, #0
    e5e0:	d0c5      	beq.n	e56e <pow+0xaa>
    e5e2:	ab06      	add	r3, sp, #24
    e5e4:	4698      	mov	r8, r3
    e5e6:	2304      	movs	r3, #4
    e5e8:	4642      	mov	r2, r8
    e5ea:	9306      	str	r3, [sp, #24]
    e5ec:	4b8c      	ldr	r3, [pc, #560]	; (e820 <pow+0x35c>)
    e5ee:	6094      	str	r4, [r2, #8]
    e5f0:	60d5      	str	r5, [r2, #12]
    e5f2:	6053      	str	r3, [r2, #4]
    e5f4:	2300      	movs	r3, #0
    e5f6:	2400      	movs	r4, #0
    e5f8:	6213      	str	r3, [r2, #32]
    e5fa:	2300      	movs	r3, #0
    e5fc:	6193      	str	r3, [r2, #24]
    e5fe:	61d4      	str	r4, [r2, #28]
    e600:	465b      	mov	r3, fp
    e602:	781b      	ldrb	r3, [r3, #0]
    e604:	6116      	str	r6, [r2, #16]
    e606:	6157      	str	r7, [r2, #20]
    e608:	b25b      	sxtb	r3, r3
    e60a:	2b02      	cmp	r3, #2
    e60c:	d004      	beq.n	e618 <pow+0x154>
    e60e:	4640      	mov	r0, r8
    e610:	f000 ff4e 	bl	f4b0 <matherr>
    e614:	2800      	cmp	r0, #0
    e616:	d140      	bne.n	e69a <pow+0x1d6>
    e618:	f003 f8bc 	bl	11794 <__errno>
    e61c:	2322      	movs	r3, #34	; 0x22
    e61e:	6003      	str	r3, [r0, #0]
    e620:	e03b      	b.n	e69a <pow+0x1d6>
    e622:	0030      	movs	r0, r6
    e624:	0039      	movs	r1, r7
    e626:	f000 ff39 	bl	f49c <finite>
    e62a:	9a02      	ldr	r2, [sp, #8]
    e62c:	9b03      	ldr	r3, [sp, #12]
    e62e:	9200      	str	r2, [sp, #0]
    e630:	9301      	str	r3, [sp, #4]
    e632:	2800      	cmp	r0, #0
    e634:	d09b      	beq.n	e56e <pow+0xaa>
    e636:	2200      	movs	r2, #0
    e638:	2300      	movs	r3, #0
    e63a:	0030      	movs	r0, r6
    e63c:	0039      	movs	r1, r7
    e63e:	f001 fa81 	bl	fb44 <__aeabi_dcmplt>
    e642:	2800      	cmp	r0, #0
    e644:	d100      	bne.n	e648 <pow+0x184>
    e646:	e792      	b.n	e56e <pow+0xaa>
    e648:	ab06      	add	r3, sp, #24
    e64a:	4698      	mov	r8, r3
    e64c:	2301      	movs	r3, #1
    e64e:	4642      	mov	r2, r8
    e650:	9306      	str	r3, [sp, #24]
    e652:	4b73      	ldr	r3, [pc, #460]	; (e820 <pow+0x35c>)
    e654:	6053      	str	r3, [r2, #4]
    e656:	4643      	mov	r3, r8
    e658:	9a05      	ldr	r2, [sp, #20]
    e65a:	609c      	str	r4, [r3, #8]
    e65c:	60dd      	str	r5, [r3, #12]
    e65e:	621a      	str	r2, [r3, #32]
    e660:	611e      	str	r6, [r3, #16]
    e662:	615f      	str	r7, [r3, #20]
    e664:	465b      	mov	r3, fp
    e666:	781b      	ldrb	r3, [r3, #0]
    e668:	b25b      	sxtb	r3, r3
    e66a:	2b00      	cmp	r3, #0
    e66c:	d00b      	beq.n	e686 <pow+0x1c2>
    e66e:	2000      	movs	r0, #0
    e670:	4642      	mov	r2, r8
    e672:	496d      	ldr	r1, [pc, #436]	; (e828 <pow+0x364>)
    e674:	6190      	str	r0, [r2, #24]
    e676:	61d1      	str	r1, [r2, #28]
    e678:	2b02      	cmp	r3, #2
    e67a:	d109      	bne.n	e690 <pow+0x1cc>
    e67c:	f003 f88a 	bl	11794 <__errno>
    e680:	2321      	movs	r3, #33	; 0x21
    e682:	6003      	str	r3, [r0, #0]
    e684:	e009      	b.n	e69a <pow+0x1d6>
    e686:	4642      	mov	r2, r8
    e688:	2300      	movs	r3, #0
    e68a:	2400      	movs	r4, #0
    e68c:	6193      	str	r3, [r2, #24]
    e68e:	61d4      	str	r4, [r2, #28]
    e690:	4640      	mov	r0, r8
    e692:	f000 ff0d 	bl	f4b0 <matherr>
    e696:	2800      	cmp	r0, #0
    e698:	d0f0      	beq.n	e67c <pow+0x1b8>
    e69a:	4643      	mov	r3, r8
    e69c:	6a1b      	ldr	r3, [r3, #32]
    e69e:	2b00      	cmp	r3, #0
    e6a0:	d004      	beq.n	e6ac <pow+0x1e8>
    e6a2:	f003 f877 	bl	11794 <__errno>
    e6a6:	4643      	mov	r3, r8
    e6a8:	6a1b      	ldr	r3, [r3, #32]
    e6aa:	6003      	str	r3, [r0, #0]
    e6ac:	4643      	mov	r3, r8
    e6ae:	69dc      	ldr	r4, [r3, #28]
    e6b0:	699b      	ldr	r3, [r3, #24]
    e6b2:	9300      	str	r3, [sp, #0]
    e6b4:	9401      	str	r4, [sp, #4]
    e6b6:	e75a      	b.n	e56e <pow+0xaa>
    e6b8:	0020      	movs	r0, r4
    e6ba:	0029      	movs	r1, r5
    e6bc:	f000 feee 	bl	f49c <finite>
    e6c0:	2800      	cmp	r0, #0
    e6c2:	d100      	bne.n	e6c6 <pow+0x202>
    e6c4:	e771      	b.n	e5aa <pow+0xe6>
    e6c6:	0030      	movs	r0, r6
    e6c8:	0039      	movs	r1, r7
    e6ca:	f000 fee7 	bl	f49c <finite>
    e6ce:	2800      	cmp	r0, #0
    e6d0:	d100      	bne.n	e6d4 <pow+0x210>
    e6d2:	e76a      	b.n	e5aa <pow+0xe6>
    e6d4:	9802      	ldr	r0, [sp, #8]
    e6d6:	9903      	ldr	r1, [sp, #12]
    e6d8:	000b      	movs	r3, r1
    e6da:	0002      	movs	r2, r0
    e6dc:	f002 ffa4 	bl	11628 <__aeabi_dcmpun>
    e6e0:	ab06      	add	r3, sp, #24
    e6e2:	4698      	mov	r8, r3
    e6e4:	2800      	cmp	r0, #0
    e6e6:	d17a      	bne.n	e7de <pow+0x31a>
    e6e8:	2303      	movs	r3, #3
    e6ea:	4642      	mov	r2, r8
    e6ec:	9306      	str	r3, [sp, #24]
    e6ee:	4b4c      	ldr	r3, [pc, #304]	; (e820 <pow+0x35c>)
    e6f0:	6210      	str	r0, [r2, #32]
    e6f2:	6053      	str	r3, [r2, #4]
    e6f4:	465b      	mov	r3, fp
    e6f6:	781b      	ldrb	r3, [r3, #0]
    e6f8:	6094      	str	r4, [r2, #8]
    e6fa:	60d5      	str	r5, [r2, #12]
    e6fc:	b25b      	sxtb	r3, r3
    e6fe:	6116      	str	r6, [r2, #16]
    e700:	6157      	str	r7, [r2, #20]
    e702:	4699      	mov	r9, r3
    e704:	2b00      	cmp	r3, #0
    e706:	d148      	bne.n	e79a <pow+0x2d6>
    e708:	22e0      	movs	r2, #224	; 0xe0
    e70a:	4641      	mov	r1, r8
    e70c:	4b47      	ldr	r3, [pc, #284]	; (e82c <pow+0x368>)
    e70e:	0612      	lsls	r2, r2, #24
    e710:	618a      	str	r2, [r1, #24]
    e712:	61cb      	str	r3, [r1, #28]
    e714:	0020      	movs	r0, r4
    e716:	2200      	movs	r2, #0
    e718:	2300      	movs	r3, #0
    e71a:	0029      	movs	r1, r5
    e71c:	f001 fa12 	bl	fb44 <__aeabi_dcmplt>
    e720:	2800      	cmp	r0, #0
    e722:	d100      	bne.n	e726 <pow+0x262>
    e724:	e773      	b.n	e60e <pow+0x14a>
    e726:	2200      	movs	r2, #0
    e728:	4b41      	ldr	r3, [pc, #260]	; (e830 <pow+0x36c>)
    e72a:	0030      	movs	r0, r6
    e72c:	0039      	movs	r1, r7
    e72e:	f002 f9ad 	bl	10a8c <__aeabi_dmul>
    e732:	0004      	movs	r4, r0
    e734:	000d      	movs	r5, r1
    e736:	f000 fec3 	bl	f4c0 <rint>
    e73a:	0002      	movs	r2, r0
    e73c:	000b      	movs	r3, r1
    e73e:	0020      	movs	r0, r4
    e740:	0029      	movs	r1, r5
    e742:	f001 f9f9 	bl	fb38 <__aeabi_dcmpeq>
    e746:	2800      	cmp	r0, #0
    e748:	d105      	bne.n	e756 <pow+0x292>
    e74a:	22e0      	movs	r2, #224	; 0xe0
    e74c:	4b39      	ldr	r3, [pc, #228]	; (e834 <pow+0x370>)
    e74e:	0612      	lsls	r2, r2, #24
    e750:	4641      	mov	r1, r8
    e752:	618a      	str	r2, [r1, #24]
    e754:	61cb      	str	r3, [r1, #28]
    e756:	465b      	mov	r3, fp
    e758:	781b      	ldrb	r3, [r3, #0]
    e75a:	b25b      	sxtb	r3, r3
    e75c:	4699      	mov	r9, r3
    e75e:	464b      	mov	r3, r9
    e760:	2b02      	cmp	r3, #2
    e762:	d000      	beq.n	e766 <pow+0x2a2>
    e764:	e753      	b.n	e60e <pow+0x14a>
    e766:	e757      	b.n	e618 <pow+0x154>
    e768:	ab06      	add	r3, sp, #24
    e76a:	4698      	mov	r8, r3
    e76c:	2301      	movs	r3, #1
    e76e:	4642      	mov	r2, r8
    e770:	9306      	str	r3, [sp, #24]
    e772:	4b2b      	ldr	r3, [pc, #172]	; (e820 <pow+0x35c>)
    e774:	6053      	str	r3, [r2, #4]
    e776:	4643      	mov	r3, r8
    e778:	609c      	str	r4, [r3, #8]
    e77a:	60dd      	str	r5, [r3, #12]
    e77c:	2400      	movs	r4, #0
    e77e:	9a00      	ldr	r2, [sp, #0]
    e780:	4d28      	ldr	r5, [pc, #160]	; (e824 <pow+0x360>)
    e782:	621a      	str	r2, [r3, #32]
    e784:	611e      	str	r6, [r3, #16]
    e786:	615f      	str	r7, [r3, #20]
    e788:	619c      	str	r4, [r3, #24]
    e78a:	61dd      	str	r5, [r3, #28]
    e78c:	464b      	mov	r3, r9
    e78e:	9400      	str	r4, [sp, #0]
    e790:	9501      	str	r5, [sp, #4]
    e792:	2b02      	cmp	r3, #2
    e794:	d000      	beq.n	e798 <pow+0x2d4>
    e796:	e77b      	b.n	e690 <pow+0x1cc>
    e798:	e6e9      	b.n	e56e <pow+0xaa>
    e79a:	2200      	movs	r2, #0
    e79c:	4641      	mov	r1, r8
    e79e:	4b26      	ldr	r3, [pc, #152]	; (e838 <pow+0x374>)
    e7a0:	0020      	movs	r0, r4
    e7a2:	618a      	str	r2, [r1, #24]
    e7a4:	61cb      	str	r3, [r1, #28]
    e7a6:	2200      	movs	r2, #0
    e7a8:	2300      	movs	r3, #0
    e7aa:	0029      	movs	r1, r5
    e7ac:	f001 f9ca 	bl	fb44 <__aeabi_dcmplt>
    e7b0:	2800      	cmp	r0, #0
    e7b2:	d0d4      	beq.n	e75e <pow+0x29a>
    e7b4:	2200      	movs	r2, #0
    e7b6:	4b1e      	ldr	r3, [pc, #120]	; (e830 <pow+0x36c>)
    e7b8:	0030      	movs	r0, r6
    e7ba:	0039      	movs	r1, r7
    e7bc:	f002 f966 	bl	10a8c <__aeabi_dmul>
    e7c0:	0004      	movs	r4, r0
    e7c2:	000d      	movs	r5, r1
    e7c4:	f000 fe7c 	bl	f4c0 <rint>
    e7c8:	0002      	movs	r2, r0
    e7ca:	000b      	movs	r3, r1
    e7cc:	0020      	movs	r0, r4
    e7ce:	0029      	movs	r1, r5
    e7d0:	f001 f9b2 	bl	fb38 <__aeabi_dcmpeq>
    e7d4:	2800      	cmp	r0, #0
    e7d6:	d1be      	bne.n	e756 <pow+0x292>
    e7d8:	2200      	movs	r2, #0
    e7da:	4b13      	ldr	r3, [pc, #76]	; (e828 <pow+0x364>)
    e7dc:	e7b8      	b.n	e750 <pow+0x28c>
    e7de:	2301      	movs	r3, #1
    e7e0:	4642      	mov	r2, r8
    e7e2:	9306      	str	r3, [sp, #24]
    e7e4:	4b0e      	ldr	r3, [pc, #56]	; (e820 <pow+0x35c>)
    e7e6:	6053      	str	r3, [r2, #4]
    e7e8:	4643      	mov	r3, r8
    e7ea:	464a      	mov	r2, r9
    e7ec:	609c      	str	r4, [r3, #8]
    e7ee:	60dd      	str	r5, [r3, #12]
    e7f0:	621a      	str	r2, [r3, #32]
    e7f2:	611e      	str	r6, [r3, #16]
    e7f4:	615f      	str	r7, [r3, #20]
    e7f6:	2400      	movs	r4, #0
    e7f8:	465b      	mov	r3, fp
    e7fa:	571c      	ldrsb	r4, [r3, r4]
    e7fc:	2c00      	cmp	r4, #0
    e7fe:	d100      	bne.n	e802 <pow+0x33e>
    e800:	e741      	b.n	e686 <pow+0x1c2>
    e802:	2300      	movs	r3, #0
    e804:	2200      	movs	r2, #0
    e806:	0019      	movs	r1, r3
    e808:	0010      	movs	r0, r2
    e80a:	f001 fd1b 	bl	10244 <__aeabi_ddiv>
    e80e:	4643      	mov	r3, r8
    e810:	6198      	str	r0, [r3, #24]
    e812:	61d9      	str	r1, [r3, #28]
    e814:	2c02      	cmp	r4, #2
    e816:	d100      	bne.n	e81a <pow+0x356>
    e818:	e730      	b.n	e67c <pow+0x1b8>
    e81a:	e739      	b.n	e690 <pow+0x1cc>
    e81c:	20000139 	.word	0x20000139
    e820:	0001bf60 	.word	0x0001bf60
    e824:	3ff00000 	.word	0x3ff00000
    e828:	fff00000 	.word	0xfff00000
    e82c:	47efffff 	.word	0x47efffff
    e830:	3fe00000 	.word	0x3fe00000
    e834:	c7efffff 	.word	0xc7efffff
    e838:	7ff00000 	.word	0x7ff00000

0000e83c <__ieee754_pow>:
    e83c:	b5f0      	push	{r4, r5, r6, r7, lr}
    e83e:	4656      	mov	r6, sl
    e840:	464d      	mov	r5, r9
    e842:	4644      	mov	r4, r8
    e844:	465f      	mov	r7, fp
    e846:	b4f0      	push	{r4, r5, r6, r7}
    e848:	001c      	movs	r4, r3
    e84a:	0013      	movs	r3, r2
    e84c:	0067      	lsls	r7, r4, #1
    e84e:	b091      	sub	sp, #68	; 0x44
    e850:	087f      	lsrs	r7, r7, #1
    e852:	9300      	str	r3, [sp, #0]
    e854:	9401      	str	r4, [sp, #4]
    e856:	0006      	movs	r6, r0
    e858:	000d      	movs	r5, r1
    e85a:	4680      	mov	r8, r0
    e85c:	4689      	mov	r9, r1
    e85e:	46a2      	mov	sl, r4
    e860:	433b      	orrs	r3, r7
    e862:	d032      	beq.n	e8ca <__ieee754_pow+0x8e>
    e864:	4b6e      	ldr	r3, [pc, #440]	; (ea20 <__ieee754_pow+0x1e4>)
    e866:	006c      	lsls	r4, r5, #1
    e868:	0864      	lsrs	r4, r4, #1
    e86a:	429c      	cmp	r4, r3
    e86c:	dc29      	bgt.n	e8c2 <__ieee754_pow+0x86>
    e86e:	d026      	beq.n	e8be <__ieee754_pow+0x82>
    e870:	429f      	cmp	r7, r3
    e872:	dc26      	bgt.n	e8c2 <__ieee754_pow+0x86>
    e874:	4b6a      	ldr	r3, [pc, #424]	; (ea20 <__ieee754_pow+0x1e4>)
    e876:	429f      	cmp	r7, r3
    e878:	d100      	bne.n	e87c <__ieee754_pow+0x40>
    e87a:	e089      	b.n	e990 <__ieee754_pow+0x154>
    e87c:	2300      	movs	r3, #0
    e87e:	469b      	mov	fp, r3
    e880:	464b      	mov	r3, r9
    e882:	2b00      	cmp	r3, #0
    e884:	da00      	bge.n	e888 <__ieee754_pow+0x4c>
    e886:	e087      	b.n	e998 <__ieee754_pow+0x15c>
    e888:	2a00      	cmp	r2, #0
    e88a:	d12f      	bne.n	e8ec <__ieee754_pow+0xb0>
    e88c:	4b64      	ldr	r3, [pc, #400]	; (ea20 <__ieee754_pow+0x1e4>)
    e88e:	429f      	cmp	r7, r3
    e890:	d100      	bne.n	e894 <__ieee754_pow+0x58>
    e892:	e09f      	b.n	e9d4 <__ieee754_pow+0x198>
    e894:	4b63      	ldr	r3, [pc, #396]	; (ea24 <__ieee754_pow+0x1e8>)
    e896:	429f      	cmp	r7, r3
    e898:	d05d      	beq.n	e956 <__ieee754_pow+0x11a>
    e89a:	2380      	movs	r3, #128	; 0x80
    e89c:	05db      	lsls	r3, r3, #23
    e89e:	459a      	cmp	sl, r3
    e8a0:	d101      	bne.n	e8a6 <__ieee754_pow+0x6a>
    e8a2:	f000 fbc1 	bl	f028 <__ieee754_pow+0x7ec>
    e8a6:	4b60      	ldr	r3, [pc, #384]	; (ea28 <__ieee754_pow+0x1ec>)
    e8a8:	459a      	cmp	sl, r3
    e8aa:	d11f      	bne.n	e8ec <__ieee754_pow+0xb0>
    e8ac:	464b      	mov	r3, r9
    e8ae:	2b00      	cmp	r3, #0
    e8b0:	db1c      	blt.n	e8ec <__ieee754_pow+0xb0>
    e8b2:	0030      	movs	r0, r6
    e8b4:	0029      	movs	r1, r5
    e8b6:	f000 fcf7 	bl	f2a8 <__ieee754_sqrt>
    e8ba:	0006      	movs	r6, r0
    e8bc:	e007      	b.n	e8ce <__ieee754_pow+0x92>
    e8be:	2800      	cmp	r0, #0
    e8c0:	d00d      	beq.n	e8de <__ieee754_pow+0xa2>
    e8c2:	4b5a      	ldr	r3, [pc, #360]	; (ea2c <__ieee754_pow+0x1f0>)
    e8c4:	18e0      	adds	r0, r4, r3
    e8c6:	4330      	orrs	r0, r6
    e8c8:	d10b      	bne.n	e8e2 <__ieee754_pow+0xa6>
    e8ca:	2600      	movs	r6, #0
    e8cc:	4955      	ldr	r1, [pc, #340]	; (ea24 <__ieee754_pow+0x1e8>)
    e8ce:	0030      	movs	r0, r6
    e8d0:	b011      	add	sp, #68	; 0x44
    e8d2:	bc3c      	pop	{r2, r3, r4, r5}
    e8d4:	4690      	mov	r8, r2
    e8d6:	4699      	mov	r9, r3
    e8d8:	46a2      	mov	sl, r4
    e8da:	46ab      	mov	fp, r5
    e8dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e8de:	42a7      	cmp	r7, r4
    e8e0:	ddc8      	ble.n	e874 <__ieee754_pow+0x38>
    e8e2:	4853      	ldr	r0, [pc, #332]	; (ea30 <__ieee754_pow+0x1f4>)
    e8e4:	f000 fde6 	bl	f4b4 <nan>
    e8e8:	0006      	movs	r6, r0
    e8ea:	e7f0      	b.n	e8ce <__ieee754_pow+0x92>
    e8ec:	0030      	movs	r0, r6
    e8ee:	0029      	movs	r1, r5
    e8f0:	f000 fdd0 	bl	f494 <fabs>
    e8f4:	4643      	mov	r3, r8
    e8f6:	2b00      	cmp	r3, #0
    e8f8:	d01d      	beq.n	e936 <__ieee754_pow+0xfa>
    e8fa:	0feb      	lsrs	r3, r5, #31
    e8fc:	3b01      	subs	r3, #1
    e8fe:	4698      	mov	r8, r3
    e900:	465b      	mov	r3, fp
    e902:	4642      	mov	r2, r8
    e904:	4313      	orrs	r3, r2
    e906:	d079      	beq.n	e9fc <__ieee754_pow+0x1c0>
    e908:	4b4a      	ldr	r3, [pc, #296]	; (ea34 <__ieee754_pow+0x1f8>)
    e90a:	429f      	cmp	r7, r3
    e90c:	dc00      	bgt.n	e910 <__ieee754_pow+0xd4>
    e90e:	e09f      	b.n	ea50 <__ieee754_pow+0x214>
    e910:	4b49      	ldr	r3, [pc, #292]	; (ea38 <__ieee754_pow+0x1fc>)
    e912:	429f      	cmp	r7, r3
    e914:	dc01      	bgt.n	e91a <__ieee754_pow+0xde>
    e916:	f000 fbce 	bl	f0b6 <__ieee754_pow+0x87a>
    e91a:	4b48      	ldr	r3, [pc, #288]	; (ea3c <__ieee754_pow+0x200>)
    e91c:	429c      	cmp	r4, r3
    e91e:	dd79      	ble.n	ea14 <__ieee754_pow+0x1d8>
    e920:	4653      	mov	r3, sl
    e922:	2b00      	cmp	r3, #0
    e924:	dd79      	ble.n	ea1a <__ieee754_pow+0x1de>
    e926:	4a46      	ldr	r2, [pc, #280]	; (ea40 <__ieee754_pow+0x204>)
    e928:	4b46      	ldr	r3, [pc, #280]	; (ea44 <__ieee754_pow+0x208>)
    e92a:	0010      	movs	r0, r2
    e92c:	0019      	movs	r1, r3
    e92e:	f002 f8ad 	bl	10a8c <__aeabi_dmul>
    e932:	0006      	movs	r6, r0
    e934:	e7cb      	b.n	e8ce <__ieee754_pow+0x92>
    e936:	2c00      	cmp	r4, #0
    e938:	d004      	beq.n	e944 <__ieee754_pow+0x108>
    e93a:	4a3a      	ldr	r2, [pc, #232]	; (ea24 <__ieee754_pow+0x1e8>)
    e93c:	00ab      	lsls	r3, r5, #2
    e93e:	089b      	lsrs	r3, r3, #2
    e940:	4293      	cmp	r3, r2
    e942:	d1da      	bne.n	e8fa <__ieee754_pow+0xbe>
    e944:	4653      	mov	r3, sl
    e946:	2b00      	cmp	r3, #0
    e948:	da00      	bge.n	e94c <__ieee754_pow+0x110>
    e94a:	e3ad      	b.n	f0a8 <__ieee754_pow+0x86c>
    e94c:	464b      	mov	r3, r9
    e94e:	2b00      	cmp	r3, #0
    e950:	db0d      	blt.n	e96e <__ieee754_pow+0x132>
    e952:	0006      	movs	r6, r0
    e954:	e7bb      	b.n	e8ce <__ieee754_pow+0x92>
    e956:	4653      	mov	r3, sl
    e958:	0029      	movs	r1, r5
    e95a:	2b00      	cmp	r3, #0
    e95c:	dab7      	bge.n	e8ce <__ieee754_pow+0x92>
    e95e:	0032      	movs	r2, r6
    e960:	002b      	movs	r3, r5
    e962:	2000      	movs	r0, #0
    e964:	492f      	ldr	r1, [pc, #188]	; (ea24 <__ieee754_pow+0x1e8>)
    e966:	f001 fc6d 	bl	10244 <__aeabi_ddiv>
    e96a:	0006      	movs	r6, r0
    e96c:	e7af      	b.n	e8ce <__ieee754_pow+0x92>
    e96e:	4b2f      	ldr	r3, [pc, #188]	; (ea2c <__ieee754_pow+0x1f0>)
    e970:	469c      	mov	ip, r3
    e972:	465b      	mov	r3, fp
    e974:	4464      	add	r4, ip
    e976:	431c      	orrs	r4, r3
    e978:	d101      	bne.n	e97e <__ieee754_pow+0x142>
    e97a:	f000 fc2b 	bl	f1d4 <__ieee754_pow+0x998>
    e97e:	465b      	mov	r3, fp
    e980:	0006      	movs	r6, r0
    e982:	2b01      	cmp	r3, #1
    e984:	d1a3      	bne.n	e8ce <__ieee754_pow+0x92>
    e986:	2380      	movs	r3, #128	; 0x80
    e988:	061b      	lsls	r3, r3, #24
    e98a:	469c      	mov	ip, r3
    e98c:	4461      	add	r1, ip
    e98e:	e79e      	b.n	e8ce <__ieee754_pow+0x92>
    e990:	2a00      	cmp	r2, #0
    e992:	d100      	bne.n	e996 <__ieee754_pow+0x15a>
    e994:	e772      	b.n	e87c <__ieee754_pow+0x40>
    e996:	e794      	b.n	e8c2 <__ieee754_pow+0x86>
    e998:	4b2b      	ldr	r3, [pc, #172]	; (ea48 <__ieee754_pow+0x20c>)
    e99a:	429f      	cmp	r7, r3
    e99c:	dc2b      	bgt.n	e9f6 <__ieee754_pow+0x1ba>
    e99e:	4b27      	ldr	r3, [pc, #156]	; (ea3c <__ieee754_pow+0x200>)
    e9a0:	429f      	cmp	r7, r3
    e9a2:	dc00      	bgt.n	e9a6 <__ieee754_pow+0x16a>
    e9a4:	e770      	b.n	e888 <__ieee754_pow+0x4c>
    e9a6:	4929      	ldr	r1, [pc, #164]	; (ea4c <__ieee754_pow+0x210>)
    e9a8:	153b      	asrs	r3, r7, #20
    e9aa:	468c      	mov	ip, r1
    e9ac:	4463      	add	r3, ip
    e9ae:	2b14      	cmp	r3, #20
    e9b0:	dc01      	bgt.n	e9b6 <__ieee754_pow+0x17a>
    e9b2:	f000 fbf2 	bl	f19a <__ieee754_pow+0x95e>
    e9b6:	2134      	movs	r1, #52	; 0x34
    e9b8:	1acb      	subs	r3, r1, r3
    e9ba:	9900      	ldr	r1, [sp, #0]
    e9bc:	40d9      	lsrs	r1, r3
    e9be:	0008      	movs	r0, r1
    e9c0:	4098      	lsls	r0, r3
    e9c2:	4282      	cmp	r2, r0
    e9c4:	d000      	beq.n	e9c8 <__ieee754_pow+0x18c>
    e9c6:	e75f      	b.n	e888 <__ieee754_pow+0x4c>
    e9c8:	2301      	movs	r3, #1
    e9ca:	4019      	ands	r1, r3
    e9cc:	3301      	adds	r3, #1
    e9ce:	1a5b      	subs	r3, r3, r1
    e9d0:	469b      	mov	fp, r3
    e9d2:	e759      	b.n	e888 <__ieee754_pow+0x4c>
    e9d4:	4b15      	ldr	r3, [pc, #84]	; (ea2c <__ieee754_pow+0x1f0>)
    e9d6:	18e0      	adds	r0, r4, r3
    e9d8:	4306      	orrs	r6, r0
    e9da:	d100      	bne.n	e9de <__ieee754_pow+0x1a2>
    e9dc:	e775      	b.n	e8ca <__ieee754_pow+0x8e>
    e9de:	4b17      	ldr	r3, [pc, #92]	; (ea3c <__ieee754_pow+0x200>)
    e9e0:	429c      	cmp	r4, r3
    e9e2:	dc00      	bgt.n	e9e6 <__ieee754_pow+0x1aa>
    e9e4:	e351      	b.n	f08a <__ieee754_pow+0x84e>
    e9e6:	4653      	mov	r3, sl
    e9e8:	2b00      	cmp	r3, #0
    e9ea:	db16      	blt.n	ea1a <__ieee754_pow+0x1de>
    e9ec:	9b00      	ldr	r3, [sp, #0]
    e9ee:	9c01      	ldr	r4, [sp, #4]
    e9f0:	001e      	movs	r6, r3
    e9f2:	0021      	movs	r1, r4
    e9f4:	e76b      	b.n	e8ce <__ieee754_pow+0x92>
    e9f6:	2302      	movs	r3, #2
    e9f8:	469b      	mov	fp, r3
    e9fa:	e745      	b.n	e888 <__ieee754_pow+0x4c>
    e9fc:	0032      	movs	r2, r6
    e9fe:	002b      	movs	r3, r5
    ea00:	0030      	movs	r0, r6
    ea02:	0029      	movs	r1, r5
    ea04:	f002 fabc 	bl	10f80 <__aeabi_dsub>
    ea08:	0002      	movs	r2, r0
    ea0a:	000b      	movs	r3, r1
    ea0c:	f001 fc1a 	bl	10244 <__aeabi_ddiv>
    ea10:	0006      	movs	r6, r0
    ea12:	e75c      	b.n	e8ce <__ieee754_pow+0x92>
    ea14:	4653      	mov	r3, sl
    ea16:	2b00      	cmp	r3, #0
    ea18:	db85      	blt.n	e926 <__ieee754_pow+0xea>
    ea1a:	2600      	movs	r6, #0
    ea1c:	2100      	movs	r1, #0
    ea1e:	e756      	b.n	e8ce <__ieee754_pow+0x92>
    ea20:	7ff00000 	.word	0x7ff00000
    ea24:	3ff00000 	.word	0x3ff00000
    ea28:	3fe00000 	.word	0x3fe00000
    ea2c:	c0100000 	.word	0xc0100000
    ea30:	00013e6c 	.word	0x00013e6c
    ea34:	41e00000 	.word	0x41e00000
    ea38:	43f00000 	.word	0x43f00000
    ea3c:	3fefffff 	.word	0x3fefffff
    ea40:	8800759c 	.word	0x8800759c
    ea44:	7e37e43c 	.word	0x7e37e43c
    ea48:	433fffff 	.word	0x433fffff
    ea4c:	fffffc01 	.word	0xfffffc01
    ea50:	4be8      	ldr	r3, [pc, #928]	; (edf4 <__ieee754_pow+0x5b8>)
    ea52:	2200      	movs	r2, #0
    ea54:	429c      	cmp	r4, r3
    ea56:	dc06      	bgt.n	ea66 <__ieee754_pow+0x22a>
    ea58:	2200      	movs	r2, #0
    ea5a:	4be7      	ldr	r3, [pc, #924]	; (edf8 <__ieee754_pow+0x5bc>)
    ea5c:	f002 f816 	bl	10a8c <__aeabi_dmul>
    ea60:	2235      	movs	r2, #53	; 0x35
    ea62:	000c      	movs	r4, r1
    ea64:	4252      	negs	r2, r2
    ea66:	4de5      	ldr	r5, [pc, #916]	; (edfc <__ieee754_pow+0x5c0>)
    ea68:	1523      	asrs	r3, r4, #20
    ea6a:	46ac      	mov	ip, r5
    ea6c:	4463      	add	r3, ip
    ea6e:	4699      	mov	r9, r3
    ea70:	0324      	lsls	r4, r4, #12
    ea72:	4de3      	ldr	r5, [pc, #908]	; (ee00 <__ieee754_pow+0x5c4>)
    ea74:	4be3      	ldr	r3, [pc, #908]	; (ee04 <__ieee754_pow+0x5c8>)
    ea76:	0b24      	lsrs	r4, r4, #12
    ea78:	4491      	add	r9, r2
    ea7a:	4325      	orrs	r5, r4
    ea7c:	429c      	cmp	r4, r3
    ea7e:	dd09      	ble.n	ea94 <__ieee754_pow+0x258>
    ea80:	4be1      	ldr	r3, [pc, #900]	; (ee08 <__ieee754_pow+0x5cc>)
    ea82:	429c      	cmp	r4, r3
    ea84:	dc00      	bgt.n	ea88 <__ieee754_pow+0x24c>
    ea86:	e3a9      	b.n	f1dc <__ieee754_pow+0x9a0>
    ea88:	2301      	movs	r3, #1
    ea8a:	469c      	mov	ip, r3
    ea8c:	4bdf      	ldr	r3, [pc, #892]	; (ee0c <__ieee754_pow+0x5d0>)
    ea8e:	44e1      	add	r9, ip
    ea90:	469c      	mov	ip, r3
    ea92:	4465      	add	r5, ip
    ea94:	2300      	movs	r3, #0
    ea96:	2400      	movs	r4, #0
    ea98:	2200      	movs	r2, #0
    ea9a:	9308      	str	r3, [sp, #32]
    ea9c:	9409      	str	r4, [sp, #36]	; 0x24
    ea9e:	930c      	str	r3, [sp, #48]	; 0x30
    eaa0:	940d      	str	r4, [sp, #52]	; 0x34
    eaa2:	2400      	movs	r4, #0
    eaa4:	4bd6      	ldr	r3, [pc, #856]	; (ee00 <__ieee754_pow+0x5c4>)
    eaa6:	9206      	str	r2, [sp, #24]
    eaa8:	9307      	str	r3, [sp, #28]
    eaaa:	9a06      	ldr	r2, [sp, #24]
    eaac:	9b07      	ldr	r3, [sp, #28]
    eaae:	0029      	movs	r1, r5
    eab0:	900a      	str	r0, [sp, #40]	; 0x28
    eab2:	910b      	str	r1, [sp, #44]	; 0x2c
    eab4:	f002 fa64 	bl	10f80 <__aeabi_dsub>
    eab8:	9a06      	ldr	r2, [sp, #24]
    eaba:	9b07      	ldr	r3, [sp, #28]
    eabc:	0006      	movs	r6, r0
    eabe:	000f      	movs	r7, r1
    eac0:	980a      	ldr	r0, [sp, #40]	; 0x28
    eac2:	990b      	ldr	r1, [sp, #44]	; 0x2c
    eac4:	f001 f892 	bl	fbec <__aeabi_dadd>
    eac8:	0002      	movs	r2, r0
    eaca:	000b      	movs	r3, r1
    eacc:	2000      	movs	r0, #0
    eace:	49cc      	ldr	r1, [pc, #816]	; (ee00 <__ieee754_pow+0x5c4>)
    ead0:	f001 fbb8 	bl	10244 <__aeabi_ddiv>
    ead4:	000a      	movs	r2, r1
    ead6:	0001      	movs	r1, r0
    ead8:	0013      	movs	r3, r2
    eada:	910e      	str	r1, [sp, #56]	; 0x38
    eadc:	920f      	str	r2, [sp, #60]	; 0x3c
    eade:	0002      	movs	r2, r0
    eae0:	0039      	movs	r1, r7
    eae2:	0030      	movs	r0, r6
    eae4:	f001 ffd2 	bl	10a8c <__aeabi_dmul>
    eae8:	000a      	movs	r2, r1
    eaea:	0001      	movs	r1, r0
    eaec:	2080      	movs	r0, #128	; 0x80
    eaee:	9104      	str	r1, [sp, #16]
    eaf0:	9205      	str	r2, [sp, #20]
    eaf2:	0013      	movs	r3, r2
    eaf4:	2200      	movs	r2, #0
    eaf6:	2180      	movs	r1, #128	; 0x80
    eaf8:	0300      	lsls	r0, r0, #12
    eafa:	4684      	mov	ip, r0
    eafc:	9202      	str	r2, [sp, #8]
    eafe:	9303      	str	r3, [sp, #12]
    eb00:	2200      	movs	r2, #0
    eb02:	0589      	lsls	r1, r1, #22
    eb04:	106d      	asrs	r5, r5, #1
    eb06:	430d      	orrs	r5, r1
    eb08:	4465      	add	r5, ip
    eb0a:	192b      	adds	r3, r5, r4
    eb0c:	9802      	ldr	r0, [sp, #8]
    eb0e:	9903      	ldr	r1, [sp, #12]
    eb10:	0014      	movs	r4, r2
    eb12:	001d      	movs	r5, r3
    eb14:	f001 ffba 	bl	10a8c <__aeabi_dmul>
    eb18:	0002      	movs	r2, r0
    eb1a:	000b      	movs	r3, r1
    eb1c:	0030      	movs	r0, r6
    eb1e:	0039      	movs	r1, r7
    eb20:	f002 fa2e 	bl	10f80 <__aeabi_dsub>
    eb24:	9a06      	ldr	r2, [sp, #24]
    eb26:	9b07      	ldr	r3, [sp, #28]
    eb28:	0006      	movs	r6, r0
    eb2a:	000f      	movs	r7, r1
    eb2c:	0020      	movs	r0, r4
    eb2e:	0029      	movs	r1, r5
    eb30:	f002 fa26 	bl	10f80 <__aeabi_dsub>
    eb34:	0002      	movs	r2, r0
    eb36:	000b      	movs	r3, r1
    eb38:	980a      	ldr	r0, [sp, #40]	; 0x28
    eb3a:	990b      	ldr	r1, [sp, #44]	; 0x2c
    eb3c:	f002 fa20 	bl	10f80 <__aeabi_dsub>
    eb40:	9a02      	ldr	r2, [sp, #8]
    eb42:	9b03      	ldr	r3, [sp, #12]
    eb44:	f001 ffa2 	bl	10a8c <__aeabi_dmul>
    eb48:	0002      	movs	r2, r0
    eb4a:	000b      	movs	r3, r1
    eb4c:	0030      	movs	r0, r6
    eb4e:	0039      	movs	r1, r7
    eb50:	f002 fa16 	bl	10f80 <__aeabi_dsub>
    eb54:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    eb56:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    eb58:	f001 ff98 	bl	10a8c <__aeabi_dmul>
    eb5c:	9d04      	ldr	r5, [sp, #16]
    eb5e:	9e05      	ldr	r6, [sp, #20]
    eb60:	9006      	str	r0, [sp, #24]
    eb62:	9107      	str	r1, [sp, #28]
    eb64:	002a      	movs	r2, r5
    eb66:	0033      	movs	r3, r6
    eb68:	0028      	movs	r0, r5
    eb6a:	0031      	movs	r1, r6
    eb6c:	f001 ff8e 	bl	10a8c <__aeabi_dmul>
    eb70:	0006      	movs	r6, r0
    eb72:	000f      	movs	r7, r1
    eb74:	4aa6      	ldr	r2, [pc, #664]	; (ee10 <__ieee754_pow+0x5d4>)
    eb76:	4ba7      	ldr	r3, [pc, #668]	; (ee14 <__ieee754_pow+0x5d8>)
    eb78:	f001 ff88 	bl	10a8c <__aeabi_dmul>
    eb7c:	4aa6      	ldr	r2, [pc, #664]	; (ee18 <__ieee754_pow+0x5dc>)
    eb7e:	4ba7      	ldr	r3, [pc, #668]	; (ee1c <__ieee754_pow+0x5e0>)
    eb80:	f001 f834 	bl	fbec <__aeabi_dadd>
    eb84:	0032      	movs	r2, r6
    eb86:	003b      	movs	r3, r7
    eb88:	f001 ff80 	bl	10a8c <__aeabi_dmul>
    eb8c:	4aa4      	ldr	r2, [pc, #656]	; (ee20 <__ieee754_pow+0x5e4>)
    eb8e:	4ba5      	ldr	r3, [pc, #660]	; (ee24 <__ieee754_pow+0x5e8>)
    eb90:	f001 f82c 	bl	fbec <__aeabi_dadd>
    eb94:	0032      	movs	r2, r6
    eb96:	003b      	movs	r3, r7
    eb98:	f001 ff78 	bl	10a8c <__aeabi_dmul>
    eb9c:	4aa2      	ldr	r2, [pc, #648]	; (ee28 <__ieee754_pow+0x5ec>)
    eb9e:	4ba3      	ldr	r3, [pc, #652]	; (ee2c <__ieee754_pow+0x5f0>)
    eba0:	f001 f824 	bl	fbec <__aeabi_dadd>
    eba4:	0032      	movs	r2, r6
    eba6:	003b      	movs	r3, r7
    eba8:	f001 ff70 	bl	10a8c <__aeabi_dmul>
    ebac:	4aa0      	ldr	r2, [pc, #640]	; (ee30 <__ieee754_pow+0x5f4>)
    ebae:	4ba1      	ldr	r3, [pc, #644]	; (ee34 <__ieee754_pow+0x5f8>)
    ebb0:	f001 f81c 	bl	fbec <__aeabi_dadd>
    ebb4:	0032      	movs	r2, r6
    ebb6:	003b      	movs	r3, r7
    ebb8:	f001 ff68 	bl	10a8c <__aeabi_dmul>
    ebbc:	4a9e      	ldr	r2, [pc, #632]	; (ee38 <__ieee754_pow+0x5fc>)
    ebbe:	4b9f      	ldr	r3, [pc, #636]	; (ee3c <__ieee754_pow+0x600>)
    ebc0:	f001 f814 	bl	fbec <__aeabi_dadd>
    ebc4:	0032      	movs	r2, r6
    ebc6:	0004      	movs	r4, r0
    ebc8:	000d      	movs	r5, r1
    ebca:	003b      	movs	r3, r7
    ebcc:	0030      	movs	r0, r6
    ebce:	0039      	movs	r1, r7
    ebd0:	f001 ff5c 	bl	10a8c <__aeabi_dmul>
    ebd4:	0002      	movs	r2, r0
    ebd6:	000b      	movs	r3, r1
    ebd8:	0020      	movs	r0, r4
    ebda:	0029      	movs	r1, r5
    ebdc:	f001 ff56 	bl	10a8c <__aeabi_dmul>
    ebe0:	9e02      	ldr	r6, [sp, #8]
    ebe2:	9f03      	ldr	r7, [sp, #12]
    ebe4:	0004      	movs	r4, r0
    ebe6:	000d      	movs	r5, r1
    ebe8:	9804      	ldr	r0, [sp, #16]
    ebea:	9905      	ldr	r1, [sp, #20]
    ebec:	0032      	movs	r2, r6
    ebee:	003b      	movs	r3, r7
    ebf0:	f000 fffc 	bl	fbec <__aeabi_dadd>
    ebf4:	9a06      	ldr	r2, [sp, #24]
    ebf6:	9b07      	ldr	r3, [sp, #28]
    ebf8:	f001 ff48 	bl	10a8c <__aeabi_dmul>
    ebfc:	0022      	movs	r2, r4
    ebfe:	002b      	movs	r3, r5
    ec00:	f000 fff4 	bl	fbec <__aeabi_dadd>
    ec04:	0032      	movs	r2, r6
    ec06:	900a      	str	r0, [sp, #40]	; 0x28
    ec08:	910b      	str	r1, [sp, #44]	; 0x2c
    ec0a:	003b      	movs	r3, r7
    ec0c:	0030      	movs	r0, r6
    ec0e:	0039      	movs	r1, r7
    ec10:	9602      	str	r6, [sp, #8]
    ec12:	9703      	str	r7, [sp, #12]
    ec14:	f001 ff3a 	bl	10a8c <__aeabi_dmul>
    ec18:	2200      	movs	r2, #0
    ec1a:	4b89      	ldr	r3, [pc, #548]	; (ee40 <__ieee754_pow+0x604>)
    ec1c:	0004      	movs	r4, r0
    ec1e:	000d      	movs	r5, r1
    ec20:	f000 ffe4 	bl	fbec <__aeabi_dadd>
    ec24:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    ec26:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ec28:	f000 ffe0 	bl	fbec <__aeabi_dadd>
    ec2c:	2600      	movs	r6, #0
    ec2e:	000f      	movs	r7, r1
    ec30:	0032      	movs	r2, r6
    ec32:	000b      	movs	r3, r1
    ec34:	9802      	ldr	r0, [sp, #8]
    ec36:	9903      	ldr	r1, [sp, #12]
    ec38:	f001 ff28 	bl	10a8c <__aeabi_dmul>
    ec3c:	2200      	movs	r2, #0
    ec3e:	9002      	str	r0, [sp, #8]
    ec40:	9103      	str	r1, [sp, #12]
    ec42:	4b7f      	ldr	r3, [pc, #508]	; (ee40 <__ieee754_pow+0x604>)
    ec44:	0030      	movs	r0, r6
    ec46:	0039      	movs	r1, r7
    ec48:	f002 f99a 	bl	10f80 <__aeabi_dsub>
    ec4c:	0022      	movs	r2, r4
    ec4e:	002b      	movs	r3, r5
    ec50:	f002 f996 	bl	10f80 <__aeabi_dsub>
    ec54:	0002      	movs	r2, r0
    ec56:	000b      	movs	r3, r1
    ec58:	980a      	ldr	r0, [sp, #40]	; 0x28
    ec5a:	990b      	ldr	r1, [sp, #44]	; 0x2c
    ec5c:	f002 f990 	bl	10f80 <__aeabi_dsub>
    ec60:	9a04      	ldr	r2, [sp, #16]
    ec62:	9b05      	ldr	r3, [sp, #20]
    ec64:	f001 ff12 	bl	10a8c <__aeabi_dmul>
    ec68:	0032      	movs	r2, r6
    ec6a:	0004      	movs	r4, r0
    ec6c:	000d      	movs	r5, r1
    ec6e:	9806      	ldr	r0, [sp, #24]
    ec70:	9907      	ldr	r1, [sp, #28]
    ec72:	003b      	movs	r3, r7
    ec74:	f001 ff0a 	bl	10a8c <__aeabi_dmul>
    ec78:	0002      	movs	r2, r0
    ec7a:	000b      	movs	r3, r1
    ec7c:	0020      	movs	r0, r4
    ec7e:	0029      	movs	r1, r5
    ec80:	f000 ffb4 	bl	fbec <__aeabi_dadd>
    ec84:	0004      	movs	r4, r0
    ec86:	000d      	movs	r5, r1
    ec88:	0002      	movs	r2, r0
    ec8a:	000b      	movs	r3, r1
    ec8c:	9802      	ldr	r0, [sp, #8]
    ec8e:	9903      	ldr	r1, [sp, #12]
    ec90:	f000 ffac 	bl	fbec <__aeabi_dadd>
    ec94:	2600      	movs	r6, #0
    ec96:	22e0      	movs	r2, #224	; 0xe0
    ec98:	4b6a      	ldr	r3, [pc, #424]	; (ee44 <__ieee754_pow+0x608>)
    ec9a:	0612      	lsls	r2, r2, #24
    ec9c:	0030      	movs	r0, r6
    ec9e:	000f      	movs	r7, r1
    eca0:	f001 fef4 	bl	10a8c <__aeabi_dmul>
    eca4:	9a02      	ldr	r2, [sp, #8]
    eca6:	9b03      	ldr	r3, [sp, #12]
    eca8:	9004      	str	r0, [sp, #16]
    ecaa:	9105      	str	r1, [sp, #20]
    ecac:	0030      	movs	r0, r6
    ecae:	0039      	movs	r1, r7
    ecb0:	f002 f966 	bl	10f80 <__aeabi_dsub>
    ecb4:	0002      	movs	r2, r0
    ecb6:	000b      	movs	r3, r1
    ecb8:	0020      	movs	r0, r4
    ecba:	0029      	movs	r1, r5
    ecbc:	f002 f960 	bl	10f80 <__aeabi_dsub>
    ecc0:	4a61      	ldr	r2, [pc, #388]	; (ee48 <__ieee754_pow+0x60c>)
    ecc2:	4b60      	ldr	r3, [pc, #384]	; (ee44 <__ieee754_pow+0x608>)
    ecc4:	f001 fee2 	bl	10a8c <__aeabi_dmul>
    ecc8:	4a60      	ldr	r2, [pc, #384]	; (ee4c <__ieee754_pow+0x610>)
    ecca:	0004      	movs	r4, r0
    eccc:	000d      	movs	r5, r1
    ecce:	4b60      	ldr	r3, [pc, #384]	; (ee50 <__ieee754_pow+0x614>)
    ecd0:	0030      	movs	r0, r6
    ecd2:	0039      	movs	r1, r7
    ecd4:	f001 feda 	bl	10a8c <__aeabi_dmul>
    ecd8:	0002      	movs	r2, r0
    ecda:	000b      	movs	r3, r1
    ecdc:	0020      	movs	r0, r4
    ecde:	0029      	movs	r1, r5
    ece0:	f000 ff84 	bl	fbec <__aeabi_dadd>
    ece4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    ece6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    ece8:	f000 ff80 	bl	fbec <__aeabi_dadd>
    ecec:	0006      	movs	r6, r0
    ecee:	4648      	mov	r0, r9
    ecf0:	000f      	movs	r7, r1
    ecf2:	f002 fcef 	bl	116d4 <__aeabi_i2d>
    ecf6:	0004      	movs	r4, r0
    ecf8:	000d      	movs	r5, r1
    ecfa:	9804      	ldr	r0, [sp, #16]
    ecfc:	9905      	ldr	r1, [sp, #20]
    ecfe:	0032      	movs	r2, r6
    ed00:	003b      	movs	r3, r7
    ed02:	f000 ff73 	bl	fbec <__aeabi_dadd>
    ed06:	9a08      	ldr	r2, [sp, #32]
    ed08:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ed0a:	f000 ff6f 	bl	fbec <__aeabi_dadd>
    ed0e:	0022      	movs	r2, r4
    ed10:	002b      	movs	r3, r5
    ed12:	f000 ff6b 	bl	fbec <__aeabi_dadd>
    ed16:	2000      	movs	r0, #0
    ed18:	0022      	movs	r2, r4
    ed1a:	002b      	movs	r3, r5
    ed1c:	9002      	str	r0, [sp, #8]
    ed1e:	9103      	str	r1, [sp, #12]
    ed20:	f002 f92e 	bl	10f80 <__aeabi_dsub>
    ed24:	9a08      	ldr	r2, [sp, #32]
    ed26:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ed28:	f002 f92a 	bl	10f80 <__aeabi_dsub>
    ed2c:	9a04      	ldr	r2, [sp, #16]
    ed2e:	9b05      	ldr	r3, [sp, #20]
    ed30:	f002 f926 	bl	10f80 <__aeabi_dsub>
    ed34:	0002      	movs	r2, r0
    ed36:	000b      	movs	r3, r1
    ed38:	0030      	movs	r0, r6
    ed3a:	0039      	movs	r1, r7
    ed3c:	f002 f920 	bl	10f80 <__aeabi_dsub>
    ed40:	9004      	str	r0, [sp, #16]
    ed42:	9105      	str	r1, [sp, #20]
    ed44:	465b      	mov	r3, fp
    ed46:	4642      	mov	r2, r8
    ed48:	3b01      	subs	r3, #1
    ed4a:	4313      	orrs	r3, r2
    ed4c:	d100      	bne.n	ed50 <__ieee754_pow+0x514>
    ed4e:	e197      	b.n	f080 <__ieee754_pow+0x844>
    ed50:	2300      	movs	r3, #0
    ed52:	4c2b      	ldr	r4, [pc, #172]	; (ee00 <__ieee754_pow+0x5c4>)
    ed54:	9306      	str	r3, [sp, #24]
    ed56:	9407      	str	r4, [sp, #28]
    ed58:	9800      	ldr	r0, [sp, #0]
    ed5a:	9901      	ldr	r1, [sp, #4]
    ed5c:	2600      	movs	r6, #0
    ed5e:	000b      	movs	r3, r1
    ed60:	0032      	movs	r2, r6
    ed62:	000f      	movs	r7, r1
    ed64:	f002 f90c 	bl	10f80 <__aeabi_dsub>
    ed68:	9a02      	ldr	r2, [sp, #8]
    ed6a:	9b03      	ldr	r3, [sp, #12]
    ed6c:	f001 fe8e 	bl	10a8c <__aeabi_dmul>
    ed70:	9a00      	ldr	r2, [sp, #0]
    ed72:	9b01      	ldr	r3, [sp, #4]
    ed74:	0004      	movs	r4, r0
    ed76:	000d      	movs	r5, r1
    ed78:	9804      	ldr	r0, [sp, #16]
    ed7a:	9905      	ldr	r1, [sp, #20]
    ed7c:	f001 fe86 	bl	10a8c <__aeabi_dmul>
    ed80:	0002      	movs	r2, r0
    ed82:	000b      	movs	r3, r1
    ed84:	0020      	movs	r0, r4
    ed86:	0029      	movs	r1, r5
    ed88:	f000 ff30 	bl	fbec <__aeabi_dadd>
    ed8c:	0004      	movs	r4, r0
    ed8e:	000d      	movs	r5, r1
    ed90:	9802      	ldr	r0, [sp, #8]
    ed92:	9903      	ldr	r1, [sp, #12]
    ed94:	003b      	movs	r3, r7
    ed96:	0032      	movs	r2, r6
    ed98:	9404      	str	r4, [sp, #16]
    ed9a:	9505      	str	r5, [sp, #20]
    ed9c:	f001 fe76 	bl	10a8c <__aeabi_dmul>
    eda0:	9000      	str	r0, [sp, #0]
    eda2:	9101      	str	r1, [sp, #4]
    eda4:	000b      	movs	r3, r1
    eda6:	0002      	movs	r2, r0
    eda8:	0029      	movs	r1, r5
    edaa:	0020      	movs	r0, r4
    edac:	f000 ff1e 	bl	fbec <__aeabi_dadd>
    edb0:	4b28      	ldr	r3, [pc, #160]	; (ee54 <__ieee754_pow+0x618>)
    edb2:	4681      	mov	r9, r0
    edb4:	1e0f      	subs	r7, r1, #0
    edb6:	468a      	mov	sl, r1
    edb8:	429f      	cmp	r7, r3
    edba:	dc00      	bgt.n	edbe <__ieee754_pow+0x582>
    edbc:	e13c      	b.n	f038 <__ieee754_pow+0x7fc>
    edbe:	4b26      	ldr	r3, [pc, #152]	; (ee58 <__ieee754_pow+0x61c>)
    edc0:	18cb      	adds	r3, r1, r3
    edc2:	4303      	orrs	r3, r0
    edc4:	d000      	beq.n	edc8 <__ieee754_pow+0x58c>
    edc6:	e1db      	b.n	f180 <__ieee754_pow+0x944>
    edc8:	9804      	ldr	r0, [sp, #16]
    edca:	9905      	ldr	r1, [sp, #20]
    edcc:	4a23      	ldr	r2, [pc, #140]	; (ee5c <__ieee754_pow+0x620>)
    edce:	4b24      	ldr	r3, [pc, #144]	; (ee60 <__ieee754_pow+0x624>)
    edd0:	f000 ff0c 	bl	fbec <__aeabi_dadd>
    edd4:	9a00      	ldr	r2, [sp, #0]
    edd6:	9b01      	ldr	r3, [sp, #4]
    edd8:	0004      	movs	r4, r0
    edda:	000d      	movs	r5, r1
    eddc:	4648      	mov	r0, r9
    edde:	0039      	movs	r1, r7
    ede0:	f002 f8ce 	bl	10f80 <__aeabi_dsub>
    ede4:	0002      	movs	r2, r0
    ede6:	000b      	movs	r3, r1
    ede8:	0020      	movs	r0, r4
    edea:	0029      	movs	r1, r5
    edec:	f000 febe 	bl	fb6c <__aeabi_dcmpgt>
    edf0:	003e      	movs	r6, r7
    edf2:	e037      	b.n	ee64 <__ieee754_pow+0x628>
    edf4:	000fffff 	.word	0x000fffff
    edf8:	43400000 	.word	0x43400000
    edfc:	fffffc01 	.word	0xfffffc01
    ee00:	3ff00000 	.word	0x3ff00000
    ee04:	0003988e 	.word	0x0003988e
    ee08:	000bb679 	.word	0x000bb679
    ee0c:	fff00000 	.word	0xfff00000
    ee10:	4a454eef 	.word	0x4a454eef
    ee14:	3fca7e28 	.word	0x3fca7e28
    ee18:	93c9db65 	.word	0x93c9db65
    ee1c:	3fcd864a 	.word	0x3fcd864a
    ee20:	a91d4101 	.word	0xa91d4101
    ee24:	3fd17460 	.word	0x3fd17460
    ee28:	518f264d 	.word	0x518f264d
    ee2c:	3fd55555 	.word	0x3fd55555
    ee30:	db6fabff 	.word	0xdb6fabff
    ee34:	3fdb6db6 	.word	0x3fdb6db6
    ee38:	33333303 	.word	0x33333303
    ee3c:	3fe33333 	.word	0x3fe33333
    ee40:	40080000 	.word	0x40080000
    ee44:	3feec709 	.word	0x3feec709
    ee48:	dc3a03fd 	.word	0xdc3a03fd
    ee4c:	145b01f5 	.word	0x145b01f5
    ee50:	be3e2fe0 	.word	0xbe3e2fe0
    ee54:	408fffff 	.word	0x408fffff
    ee58:	bf700000 	.word	0xbf700000
    ee5c:	652b82fe 	.word	0x652b82fe
    ee60:	3c971547 	.word	0x3c971547
    ee64:	2800      	cmp	r0, #0
    ee66:	d000      	beq.n	ee6a <__ieee754_pow+0x62e>
    ee68:	e18a      	b.n	f180 <__ieee754_pow+0x944>
    ee6a:	2280      	movs	r2, #128	; 0x80
    ee6c:	4be7      	ldr	r3, [pc, #924]	; (f20c <__ieee754_pow+0x9d0>)
    ee6e:	0352      	lsls	r2, r2, #13
    ee70:	469c      	mov	ip, r3
    ee72:	0013      	movs	r3, r2
    ee74:	1536      	asrs	r6, r6, #20
    ee76:	4466      	add	r6, ip
    ee78:	4133      	asrs	r3, r6
    ee7a:	49e5      	ldr	r1, [pc, #916]	; (f210 <__ieee754_pow+0x9d4>)
    ee7c:	19db      	adds	r3, r3, r7
    ee7e:	005e      	lsls	r6, r3, #1
    ee80:	001c      	movs	r4, r3
    ee82:	031b      	lsls	r3, r3, #12
    ee84:	468c      	mov	ip, r1
    ee86:	0b1b      	lsrs	r3, r3, #12
    ee88:	4313      	orrs	r3, r2
    ee8a:	2214      	movs	r2, #20
    ee8c:	0d76      	lsrs	r6, r6, #21
    ee8e:	4fe1      	ldr	r7, [pc, #900]	; (f214 <__ieee754_pow+0x9d8>)
    ee90:	4466      	add	r6, ip
    ee92:	4137      	asrs	r7, r6
    ee94:	1b96      	subs	r6, r2, r6
    ee96:	4133      	asrs	r3, r6
    ee98:	4698      	mov	r8, r3
    ee9a:	4653      	mov	r3, sl
    ee9c:	43bc      	bics	r4, r7
    ee9e:	2000      	movs	r0, #0
    eea0:	0021      	movs	r1, r4
    eea2:	2b00      	cmp	r3, #0
    eea4:	da00      	bge.n	eea8 <__ieee754_pow+0x66c>
    eea6:	e1a9      	b.n	f1fc <__ieee754_pow+0x9c0>
    eea8:	0002      	movs	r2, r0
    eeaa:	000b      	movs	r3, r1
    eeac:	9800      	ldr	r0, [sp, #0]
    eeae:	9901      	ldr	r1, [sp, #4]
    eeb0:	f002 f866 	bl	10f80 <__aeabi_dsub>
    eeb4:	000b      	movs	r3, r1
    eeb6:	9000      	str	r0, [sp, #0]
    eeb8:	9101      	str	r1, [sp, #4]
    eeba:	0002      	movs	r2, r0
    eebc:	9804      	ldr	r0, [sp, #16]
    eebe:	9905      	ldr	r1, [sp, #20]
    eec0:	f000 fe94 	bl	fbec <__aeabi_dadd>
    eec4:	4643      	mov	r3, r8
    eec6:	051b      	lsls	r3, r3, #20
    eec8:	4699      	mov	r9, r3
    eeca:	2000      	movs	r0, #0
    eecc:	2200      	movs	r2, #0
    eece:	4bd2      	ldr	r3, [pc, #840]	; (f218 <__ieee754_pow+0x9dc>)
    eed0:	0006      	movs	r6, r0
    eed2:	000f      	movs	r7, r1
    eed4:	f001 fdda 	bl	10a8c <__aeabi_dmul>
    eed8:	9a00      	ldr	r2, [sp, #0]
    eeda:	9b01      	ldr	r3, [sp, #4]
    eedc:	9002      	str	r0, [sp, #8]
    eede:	9103      	str	r1, [sp, #12]
    eee0:	0030      	movs	r0, r6
    eee2:	0039      	movs	r1, r7
    eee4:	f002 f84c 	bl	10f80 <__aeabi_dsub>
    eee8:	0002      	movs	r2, r0
    eeea:	000b      	movs	r3, r1
    eeec:	9804      	ldr	r0, [sp, #16]
    eeee:	9905      	ldr	r1, [sp, #20]
    eef0:	f002 f846 	bl	10f80 <__aeabi_dsub>
    eef4:	4ac9      	ldr	r2, [pc, #804]	; (f21c <__ieee754_pow+0x9e0>)
    eef6:	4bca      	ldr	r3, [pc, #808]	; (f220 <__ieee754_pow+0x9e4>)
    eef8:	f001 fdc8 	bl	10a8c <__aeabi_dmul>
    eefc:	4ac9      	ldr	r2, [pc, #804]	; (f224 <__ieee754_pow+0x9e8>)
    eefe:	0004      	movs	r4, r0
    ef00:	000d      	movs	r5, r1
    ef02:	4bc9      	ldr	r3, [pc, #804]	; (f228 <__ieee754_pow+0x9ec>)
    ef04:	0030      	movs	r0, r6
    ef06:	0039      	movs	r1, r7
    ef08:	f001 fdc0 	bl	10a8c <__aeabi_dmul>
    ef0c:	0002      	movs	r2, r0
    ef0e:	000b      	movs	r3, r1
    ef10:	0020      	movs	r0, r4
    ef12:	0029      	movs	r1, r5
    ef14:	f000 fe6a 	bl	fbec <__aeabi_dadd>
    ef18:	0004      	movs	r4, r0
    ef1a:	000d      	movs	r5, r1
    ef1c:	0002      	movs	r2, r0
    ef1e:	000b      	movs	r3, r1
    ef20:	9802      	ldr	r0, [sp, #8]
    ef22:	9903      	ldr	r1, [sp, #12]
    ef24:	f000 fe62 	bl	fbec <__aeabi_dadd>
    ef28:	9a02      	ldr	r2, [sp, #8]
    ef2a:	9b03      	ldr	r3, [sp, #12]
    ef2c:	0006      	movs	r6, r0
    ef2e:	000f      	movs	r7, r1
    ef30:	f002 f826 	bl	10f80 <__aeabi_dsub>
    ef34:	0002      	movs	r2, r0
    ef36:	000b      	movs	r3, r1
    ef38:	0020      	movs	r0, r4
    ef3a:	0029      	movs	r1, r5
    ef3c:	f002 f820 	bl	10f80 <__aeabi_dsub>
    ef40:	0032      	movs	r2, r6
    ef42:	9000      	str	r0, [sp, #0]
    ef44:	9101      	str	r1, [sp, #4]
    ef46:	003b      	movs	r3, r7
    ef48:	0030      	movs	r0, r6
    ef4a:	0039      	movs	r1, r7
    ef4c:	f001 fd9e 	bl	10a8c <__aeabi_dmul>
    ef50:	0004      	movs	r4, r0
    ef52:	000d      	movs	r5, r1
    ef54:	4ab5      	ldr	r2, [pc, #724]	; (f22c <__ieee754_pow+0x9f0>)
    ef56:	4bb6      	ldr	r3, [pc, #728]	; (f230 <__ieee754_pow+0x9f4>)
    ef58:	f001 fd98 	bl	10a8c <__aeabi_dmul>
    ef5c:	4ab5      	ldr	r2, [pc, #724]	; (f234 <__ieee754_pow+0x9f8>)
    ef5e:	4bb6      	ldr	r3, [pc, #728]	; (f238 <__ieee754_pow+0x9fc>)
    ef60:	f002 f80e 	bl	10f80 <__aeabi_dsub>
    ef64:	0022      	movs	r2, r4
    ef66:	002b      	movs	r3, r5
    ef68:	f001 fd90 	bl	10a8c <__aeabi_dmul>
    ef6c:	4ab3      	ldr	r2, [pc, #716]	; (f23c <__ieee754_pow+0xa00>)
    ef6e:	4bb4      	ldr	r3, [pc, #720]	; (f240 <__ieee754_pow+0xa04>)
    ef70:	f000 fe3c 	bl	fbec <__aeabi_dadd>
    ef74:	0022      	movs	r2, r4
    ef76:	002b      	movs	r3, r5
    ef78:	f001 fd88 	bl	10a8c <__aeabi_dmul>
    ef7c:	4ab1      	ldr	r2, [pc, #708]	; (f244 <__ieee754_pow+0xa08>)
    ef7e:	4bb2      	ldr	r3, [pc, #712]	; (f248 <__ieee754_pow+0xa0c>)
    ef80:	f001 fffe 	bl	10f80 <__aeabi_dsub>
    ef84:	0022      	movs	r2, r4
    ef86:	002b      	movs	r3, r5
    ef88:	f001 fd80 	bl	10a8c <__aeabi_dmul>
    ef8c:	4aaf      	ldr	r2, [pc, #700]	; (f24c <__ieee754_pow+0xa10>)
    ef8e:	4bb0      	ldr	r3, [pc, #704]	; (f250 <__ieee754_pow+0xa14>)
    ef90:	f000 fe2c 	bl	fbec <__aeabi_dadd>
    ef94:	0022      	movs	r2, r4
    ef96:	002b      	movs	r3, r5
    ef98:	f001 fd78 	bl	10a8c <__aeabi_dmul>
    ef9c:	0002      	movs	r2, r0
    ef9e:	000b      	movs	r3, r1
    efa0:	0030      	movs	r0, r6
    efa2:	0039      	movs	r1, r7
    efa4:	f001 ffec 	bl	10f80 <__aeabi_dsub>
    efa8:	0004      	movs	r4, r0
    efaa:	000d      	movs	r5, r1
    efac:	0002      	movs	r2, r0
    efae:	000b      	movs	r3, r1
    efb0:	0030      	movs	r0, r6
    efb2:	0039      	movs	r1, r7
    efb4:	f001 fd6a 	bl	10a8c <__aeabi_dmul>
    efb8:	2380      	movs	r3, #128	; 0x80
    efba:	9002      	str	r0, [sp, #8]
    efbc:	9103      	str	r1, [sp, #12]
    efbe:	2200      	movs	r2, #0
    efc0:	05db      	lsls	r3, r3, #23
    efc2:	0020      	movs	r0, r4
    efc4:	0029      	movs	r1, r5
    efc6:	f001 ffdb 	bl	10f80 <__aeabi_dsub>
    efca:	0002      	movs	r2, r0
    efcc:	000b      	movs	r3, r1
    efce:	9802      	ldr	r0, [sp, #8]
    efd0:	9903      	ldr	r1, [sp, #12]
    efd2:	f001 f937 	bl	10244 <__aeabi_ddiv>
    efd6:	9a00      	ldr	r2, [sp, #0]
    efd8:	9b01      	ldr	r3, [sp, #4]
    efda:	0004      	movs	r4, r0
    efdc:	000d      	movs	r5, r1
    efde:	0030      	movs	r0, r6
    efe0:	0039      	movs	r1, r7
    efe2:	f001 fd53 	bl	10a8c <__aeabi_dmul>
    efe6:	9a00      	ldr	r2, [sp, #0]
    efe8:	9b01      	ldr	r3, [sp, #4]
    efea:	f000 fdff 	bl	fbec <__aeabi_dadd>
    efee:	0002      	movs	r2, r0
    eff0:	000b      	movs	r3, r1
    eff2:	0020      	movs	r0, r4
    eff4:	0029      	movs	r1, r5
    eff6:	f001 ffc3 	bl	10f80 <__aeabi_dsub>
    effa:	0032      	movs	r2, r6
    effc:	003b      	movs	r3, r7
    effe:	f001 ffbf 	bl	10f80 <__aeabi_dsub>
    f002:	0002      	movs	r2, r0
    f004:	000b      	movs	r3, r1
    f006:	2000      	movs	r0, #0
    f008:	4992      	ldr	r1, [pc, #584]	; (f254 <__ieee754_pow+0xa18>)
    f00a:	f001 ffb9 	bl	10f80 <__aeabi_dsub>
    f00e:	464b      	mov	r3, r9
    f010:	185b      	adds	r3, r3, r1
    f012:	151a      	asrs	r2, r3, #20
    f014:	2a00      	cmp	r2, #0
    f016:	dc00      	bgt.n	f01a <__ieee754_pow+0x7de>
    f018:	e0f4      	b.n	f204 <__ieee754_pow+0x9c8>
    f01a:	0019      	movs	r1, r3
    f01c:	9a06      	ldr	r2, [sp, #24]
    f01e:	9b07      	ldr	r3, [sp, #28]
    f020:	f001 fd34 	bl	10a8c <__aeabi_dmul>
    f024:	0006      	movs	r6, r0
    f026:	e452      	b.n	e8ce <__ieee754_pow+0x92>
    f028:	0032      	movs	r2, r6
    f02a:	0030      	movs	r0, r6
    f02c:	002b      	movs	r3, r5
    f02e:	0029      	movs	r1, r5
    f030:	f001 fd2c 	bl	10a8c <__aeabi_dmul>
    f034:	0006      	movs	r6, r0
    f036:	e44a      	b.n	e8ce <__ieee754_pow+0x92>
    f038:	4b87      	ldr	r3, [pc, #540]	; (f258 <__ieee754_pow+0xa1c>)
    f03a:	004e      	lsls	r6, r1, #1
    f03c:	0876      	lsrs	r6, r6, #1
    f03e:	429e      	cmp	r6, r3
    f040:	dc00      	bgt.n	f044 <__ieee754_pow+0x808>
    f042:	e0bf      	b.n	f1c4 <__ieee754_pow+0x988>
    f044:	4b85      	ldr	r3, [pc, #532]	; (f25c <__ieee754_pow+0xa20>)
    f046:	18cb      	adds	r3, r1, r3
    f048:	4303      	orrs	r3, r0
    f04a:	d10c      	bne.n	f066 <__ieee754_pow+0x82a>
    f04c:	9a00      	ldr	r2, [sp, #0]
    f04e:	9b01      	ldr	r3, [sp, #4]
    f050:	f001 ff96 	bl	10f80 <__aeabi_dsub>
    f054:	0002      	movs	r2, r0
    f056:	000b      	movs	r3, r1
    f058:	9804      	ldr	r0, [sp, #16]
    f05a:	9905      	ldr	r1, [sp, #20]
    f05c:	f000 fd7c 	bl	fb58 <__aeabi_dcmple>
    f060:	2800      	cmp	r0, #0
    f062:	d100      	bne.n	f066 <__ieee754_pow+0x82a>
    f064:	e701      	b.n	ee6a <__ieee754_pow+0x62e>
    f066:	9806      	ldr	r0, [sp, #24]
    f068:	9907      	ldr	r1, [sp, #28]
    f06a:	4a7d      	ldr	r2, [pc, #500]	; (f260 <__ieee754_pow+0xa24>)
    f06c:	4b7d      	ldr	r3, [pc, #500]	; (f264 <__ieee754_pow+0xa28>)
    f06e:	f001 fd0d 	bl	10a8c <__aeabi_dmul>
    f072:	4a7b      	ldr	r2, [pc, #492]	; (f260 <__ieee754_pow+0xa24>)
    f074:	4b7b      	ldr	r3, [pc, #492]	; (f264 <__ieee754_pow+0xa28>)
    f076:	f001 fd09 	bl	10a8c <__aeabi_dmul>
    f07a:	0006      	movs	r6, r0
    f07c:	f7ff fc27 	bl	e8ce <__ieee754_pow+0x92>
    f080:	2300      	movs	r3, #0
    f082:	4c79      	ldr	r4, [pc, #484]	; (f268 <__ieee754_pow+0xa2c>)
    f084:	9306      	str	r3, [sp, #24]
    f086:	9407      	str	r4, [sp, #28]
    f088:	e666      	b.n	ed58 <__ieee754_pow+0x51c>
    f08a:	4653      	mov	r3, sl
    f08c:	2b00      	cmp	r3, #0
    f08e:	db00      	blt.n	f092 <__ieee754_pow+0x856>
    f090:	e4c3      	b.n	ea1a <__ieee754_pow+0x1de>
    f092:	9b00      	ldr	r3, [sp, #0]
    f094:	9c01      	ldr	r4, [sp, #4]
    f096:	2280      	movs	r2, #128	; 0x80
    f098:	0612      	lsls	r2, r2, #24
    f09a:	001e      	movs	r6, r3
    f09c:	4694      	mov	ip, r2
    f09e:	0023      	movs	r3, r4
    f0a0:	4463      	add	r3, ip
    f0a2:	0019      	movs	r1, r3
    f0a4:	f7ff fc13 	bl	e8ce <__ieee754_pow+0x92>
    f0a8:	0002      	movs	r2, r0
    f0aa:	000b      	movs	r3, r1
    f0ac:	2000      	movs	r0, #0
    f0ae:	4969      	ldr	r1, [pc, #420]	; (f254 <__ieee754_pow+0xa18>)
    f0b0:	f001 f8c8 	bl	10244 <__aeabi_ddiv>
    f0b4:	e44a      	b.n	e94c <__ieee754_pow+0x110>
    f0b6:	4b6d      	ldr	r3, [pc, #436]	; (f26c <__ieee754_pow+0xa30>)
    f0b8:	429c      	cmp	r4, r3
    f0ba:	dc00      	bgt.n	f0be <__ieee754_pow+0x882>
    f0bc:	e4aa      	b.n	ea14 <__ieee754_pow+0x1d8>
    f0be:	4b65      	ldr	r3, [pc, #404]	; (f254 <__ieee754_pow+0xa18>)
    f0c0:	429c      	cmp	r4, r3
    f0c2:	dd01      	ble.n	f0c8 <__ieee754_pow+0x88c>
    f0c4:	f7ff fc2c 	bl	e920 <__ieee754_pow+0xe4>
    f0c8:	2200      	movs	r2, #0
    f0ca:	4b62      	ldr	r3, [pc, #392]	; (f254 <__ieee754_pow+0xa18>)
    f0cc:	f001 ff58 	bl	10f80 <__aeabi_dsub>
    f0d0:	22c0      	movs	r2, #192	; 0xc0
    f0d2:	4b67      	ldr	r3, [pc, #412]	; (f270 <__ieee754_pow+0xa34>)
    f0d4:	05d2      	lsls	r2, r2, #23
    f0d6:	0004      	movs	r4, r0
    f0d8:	000d      	movs	r5, r1
    f0da:	f001 fcd7 	bl	10a8c <__aeabi_dmul>
    f0de:	4a65      	ldr	r2, [pc, #404]	; (f274 <__ieee754_pow+0xa38>)
    f0e0:	0006      	movs	r6, r0
    f0e2:	000f      	movs	r7, r1
    f0e4:	4b64      	ldr	r3, [pc, #400]	; (f278 <__ieee754_pow+0xa3c>)
    f0e6:	0020      	movs	r0, r4
    f0e8:	0029      	movs	r1, r5
    f0ea:	f001 fccf 	bl	10a8c <__aeabi_dmul>
    f0ee:	2200      	movs	r2, #0
    f0f0:	9002      	str	r0, [sp, #8]
    f0f2:	9103      	str	r1, [sp, #12]
    f0f4:	4b61      	ldr	r3, [pc, #388]	; (f27c <__ieee754_pow+0xa40>)
    f0f6:	0020      	movs	r0, r4
    f0f8:	0029      	movs	r1, r5
    f0fa:	f001 fcc7 	bl	10a8c <__aeabi_dmul>
    f0fe:	0002      	movs	r2, r0
    f100:	000b      	movs	r3, r1
    f102:	485f      	ldr	r0, [pc, #380]	; (f280 <__ieee754_pow+0xa44>)
    f104:	495f      	ldr	r1, [pc, #380]	; (f284 <__ieee754_pow+0xa48>)
    f106:	f001 ff3b 	bl	10f80 <__aeabi_dsub>
    f10a:	0022      	movs	r2, r4
    f10c:	002b      	movs	r3, r5
    f10e:	f001 fcbd 	bl	10a8c <__aeabi_dmul>
    f112:	0002      	movs	r2, r0
    f114:	000b      	movs	r3, r1
    f116:	2000      	movs	r0, #0
    f118:	495b      	ldr	r1, [pc, #364]	; (f288 <__ieee754_pow+0xa4c>)
    f11a:	f001 ff31 	bl	10f80 <__aeabi_dsub>
    f11e:	0022      	movs	r2, r4
    f120:	9004      	str	r0, [sp, #16]
    f122:	9105      	str	r1, [sp, #20]
    f124:	002b      	movs	r3, r5
    f126:	0020      	movs	r0, r4
    f128:	0029      	movs	r1, r5
    f12a:	f001 fcaf 	bl	10a8c <__aeabi_dmul>
    f12e:	0002      	movs	r2, r0
    f130:	000b      	movs	r3, r1
    f132:	9804      	ldr	r0, [sp, #16]
    f134:	9905      	ldr	r1, [sp, #20]
    f136:	f001 fca9 	bl	10a8c <__aeabi_dmul>
    f13a:	4a54      	ldr	r2, [pc, #336]	; (f28c <__ieee754_pow+0xa50>)
    f13c:	4b4c      	ldr	r3, [pc, #304]	; (f270 <__ieee754_pow+0xa34>)
    f13e:	f001 fca5 	bl	10a8c <__aeabi_dmul>
    f142:	0002      	movs	r2, r0
    f144:	000b      	movs	r3, r1
    f146:	9802      	ldr	r0, [sp, #8]
    f148:	9903      	ldr	r1, [sp, #12]
    f14a:	f001 ff19 	bl	10f80 <__aeabi_dsub>
    f14e:	0002      	movs	r2, r0
    f150:	000b      	movs	r3, r1
    f152:	0004      	movs	r4, r0
    f154:	000d      	movs	r5, r1
    f156:	0030      	movs	r0, r6
    f158:	0039      	movs	r1, r7
    f15a:	f000 fd47 	bl	fbec <__aeabi_dadd>
    f15e:	2200      	movs	r2, #0
    f160:	0010      	movs	r0, r2
    f162:	003b      	movs	r3, r7
    f164:	0032      	movs	r2, r6
    f166:	9002      	str	r0, [sp, #8]
    f168:	9103      	str	r1, [sp, #12]
    f16a:	f001 ff09 	bl	10f80 <__aeabi_dsub>
    f16e:	0002      	movs	r2, r0
    f170:	000b      	movs	r3, r1
    f172:	0020      	movs	r0, r4
    f174:	0029      	movs	r1, r5
    f176:	f001 ff03 	bl	10f80 <__aeabi_dsub>
    f17a:	9004      	str	r0, [sp, #16]
    f17c:	9105      	str	r1, [sp, #20]
    f17e:	e5e1      	b.n	ed44 <__ieee754_pow+0x508>
    f180:	4a43      	ldr	r2, [pc, #268]	; (f290 <__ieee754_pow+0xa54>)
    f182:	4b44      	ldr	r3, [pc, #272]	; (f294 <__ieee754_pow+0xa58>)
    f184:	9806      	ldr	r0, [sp, #24]
    f186:	9907      	ldr	r1, [sp, #28]
    f188:	f001 fc80 	bl	10a8c <__aeabi_dmul>
    f18c:	4a40      	ldr	r2, [pc, #256]	; (f290 <__ieee754_pow+0xa54>)
    f18e:	4b41      	ldr	r3, [pc, #260]	; (f294 <__ieee754_pow+0xa58>)
    f190:	f001 fc7c 	bl	10a8c <__aeabi_dmul>
    f194:	0006      	movs	r6, r0
    f196:	f7ff fb9a 	bl	e8ce <__ieee754_pow+0x92>
    f19a:	2a00      	cmp	r2, #0
    f19c:	d001      	beq.n	f1a2 <__ieee754_pow+0x966>
    f19e:	f7ff fba5 	bl	e8ec <__ieee754_pow+0xb0>
    f1a2:	3214      	adds	r2, #20
    f1a4:	1ad3      	subs	r3, r2, r3
    f1a6:	003a      	movs	r2, r7
    f1a8:	411a      	asrs	r2, r3
    f1aa:	0011      	movs	r1, r2
    f1ac:	4099      	lsls	r1, r3
    f1ae:	428f      	cmp	r7, r1
    f1b0:	d001      	beq.n	f1b6 <__ieee754_pow+0x97a>
    f1b2:	f7ff fb6f 	bl	e894 <__ieee754_pow+0x58>
    f1b6:	2301      	movs	r3, #1
    f1b8:	4013      	ands	r3, r2
    f1ba:	2202      	movs	r2, #2
    f1bc:	1ad3      	subs	r3, r2, r3
    f1be:	469b      	mov	fp, r3
    f1c0:	f7ff fb68 	bl	e894 <__ieee754_pow+0x58>
    f1c4:	4b30      	ldr	r3, [pc, #192]	; (f288 <__ieee754_pow+0xa4c>)
    f1c6:	429e      	cmp	r6, r3
    f1c8:	dd00      	ble.n	f1cc <__ieee754_pow+0x990>
    f1ca:	e64e      	b.n	ee6a <__ieee754_pow+0x62e>
    f1cc:	2300      	movs	r3, #0
    f1ce:	4699      	mov	r9, r3
    f1d0:	4698      	mov	r8, r3
    f1d2:	e67a      	b.n	eeca <__ieee754_pow+0x68e>
    f1d4:	0002      	movs	r2, r0
    f1d6:	000b      	movs	r3, r1
    f1d8:	f7ff fc14 	bl	ea04 <__ieee754_pow+0x1c8>
    f1dc:	2380      	movs	r3, #128	; 0x80
    f1de:	4c2e      	ldr	r4, [pc, #184]	; (f298 <__ieee754_pow+0xa5c>)
    f1e0:	05db      	lsls	r3, r3, #23
    f1e2:	9308      	str	r3, [sp, #32]
    f1e4:	9409      	str	r4, [sp, #36]	; 0x24
    f1e6:	4b2d      	ldr	r3, [pc, #180]	; (f29c <__ieee754_pow+0xa60>)
    f1e8:	4c2d      	ldr	r4, [pc, #180]	; (f2a0 <__ieee754_pow+0xa64>)
    f1ea:	2200      	movs	r2, #0
    f1ec:	930c      	str	r3, [sp, #48]	; 0x30
    f1ee:	940d      	str	r4, [sp, #52]	; 0x34
    f1f0:	2480      	movs	r4, #128	; 0x80
    f1f2:	4b2c      	ldr	r3, [pc, #176]	; (f2a4 <__ieee754_pow+0xa68>)
    f1f4:	02e4      	lsls	r4, r4, #11
    f1f6:	9206      	str	r2, [sp, #24]
    f1f8:	9307      	str	r3, [sp, #28]
    f1fa:	e456      	b.n	eaaa <__ieee754_pow+0x26e>
    f1fc:	4643      	mov	r3, r8
    f1fe:	425b      	negs	r3, r3
    f200:	4698      	mov	r8, r3
    f202:	e651      	b.n	eea8 <__ieee754_pow+0x66c>
    f204:	4642      	mov	r2, r8
    f206:	f000 f9fd 	bl	f604 <scalbn>
    f20a:	e707      	b.n	f01c <__ieee754_pow+0x7e0>
    f20c:	fffffc02 	.word	0xfffffc02
    f210:	fffffc01 	.word	0xfffffc01
    f214:	000fffff 	.word	0x000fffff
    f218:	3fe62e43 	.word	0x3fe62e43
    f21c:	fefa39ef 	.word	0xfefa39ef
    f220:	3fe62e42 	.word	0x3fe62e42
    f224:	0ca86c39 	.word	0x0ca86c39
    f228:	be205c61 	.word	0xbe205c61
    f22c:	72bea4d0 	.word	0x72bea4d0
    f230:	3e663769 	.word	0x3e663769
    f234:	c5d26bf1 	.word	0xc5d26bf1
    f238:	3ebbbd41 	.word	0x3ebbbd41
    f23c:	af25de2c 	.word	0xaf25de2c
    f240:	3f11566a 	.word	0x3f11566a
    f244:	16bebd93 	.word	0x16bebd93
    f248:	3f66c16c 	.word	0x3f66c16c
    f24c:	5555553e 	.word	0x5555553e
    f250:	3fc55555 	.word	0x3fc55555
    f254:	3ff00000 	.word	0x3ff00000
    f258:	4090cbff 	.word	0x4090cbff
    f25c:	3f6f3400 	.word	0x3f6f3400
    f260:	c2f8f359 	.word	0xc2f8f359
    f264:	01a56e1f 	.word	0x01a56e1f
    f268:	bff00000 	.word	0xbff00000
    f26c:	3feffffe 	.word	0x3feffffe
    f270:	3ff71547 	.word	0x3ff71547
    f274:	f85ddf44 	.word	0xf85ddf44
    f278:	3e54ae0b 	.word	0x3e54ae0b
    f27c:	3fd00000 	.word	0x3fd00000
    f280:	55555555 	.word	0x55555555
    f284:	3fd55555 	.word	0x3fd55555
    f288:	3fe00000 	.word	0x3fe00000
    f28c:	652b82fe 	.word	0x652b82fe
    f290:	8800759c 	.word	0x8800759c
    f294:	7e37e43c 	.word	0x7e37e43c
    f298:	3fe2b803 	.word	0x3fe2b803
    f29c:	43cfd006 	.word	0x43cfd006
    f2a0:	3e4cfdeb 	.word	0x3e4cfdeb
    f2a4:	3ff80000 	.word	0x3ff80000

0000f2a8 <__ieee754_sqrt>:
    f2a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    f2aa:	4656      	mov	r6, sl
    f2ac:	464d      	mov	r5, r9
    f2ae:	4644      	mov	r4, r8
    f2b0:	465f      	mov	r7, fp
    f2b2:	4b75      	ldr	r3, [pc, #468]	; (f488 <__ieee754_sqrt+0x1e0>)
    f2b4:	b4f0      	push	{r4, r5, r6, r7}
    f2b6:	000a      	movs	r2, r1
    f2b8:	000d      	movs	r5, r1
    f2ba:	0019      	movs	r1, r3
    f2bc:	b083      	sub	sp, #12
    f2be:	0006      	movs	r6, r0
    f2c0:	0004      	movs	r4, r0
    f2c2:	4029      	ands	r1, r5
    f2c4:	4299      	cmp	r1, r3
    f2c6:	d100      	bne.n	f2ca <__ieee754_sqrt+0x22>
    f2c8:	e0ba      	b.n	f440 <__ieee754_sqrt+0x198>
    f2ca:	2d00      	cmp	r5, #0
    f2cc:	dc00      	bgt.n	f2d0 <__ieee754_sqrt+0x28>
    f2ce:	e094      	b.n	f3fa <__ieee754_sqrt+0x152>
    f2d0:	152d      	asrs	r5, r5, #20
    f2d2:	d100      	bne.n	f2d6 <__ieee754_sqrt+0x2e>
    f2d4:	e0a3      	b.n	f41e <__ieee754_sqrt+0x176>
    f2d6:	4b6d      	ldr	r3, [pc, #436]	; (f48c <__ieee754_sqrt+0x1e4>)
    f2d8:	0312      	lsls	r2, r2, #12
    f2da:	469c      	mov	ip, r3
    f2dc:	2380      	movs	r3, #128	; 0x80
    f2de:	0b12      	lsrs	r2, r2, #12
    f2e0:	035b      	lsls	r3, r3, #13
    f2e2:	4465      	add	r5, ip
    f2e4:	431a      	orrs	r2, r3
    f2e6:	07eb      	lsls	r3, r5, #31
    f2e8:	d500      	bpl.n	f2ec <__ieee754_sqrt+0x44>
    f2ea:	e081      	b.n	f3f0 <__ieee754_sqrt+0x148>
    f2ec:	106b      	asrs	r3, r5, #1
    f2ee:	4698      	mov	r8, r3
    f2f0:	0fe3      	lsrs	r3, r4, #31
    f2f2:	189b      	adds	r3, r3, r2
    f2f4:	189b      	adds	r3, r3, r2
    f2f6:	2280      	movs	r2, #128	; 0x80
    f2f8:	2116      	movs	r1, #22
    f2fa:	2600      	movs	r6, #0
    f2fc:	2700      	movs	r7, #0
    f2fe:	0064      	lsls	r4, r4, #1
    f300:	0392      	lsls	r2, r2, #14
    f302:	18b8      	adds	r0, r7, r2
    f304:	4298      	cmp	r0, r3
    f306:	dc02      	bgt.n	f30e <__ieee754_sqrt+0x66>
    f308:	1887      	adds	r7, r0, r2
    f30a:	1a1b      	subs	r3, r3, r0
    f30c:	18b6      	adds	r6, r6, r2
    f30e:	0fe0      	lsrs	r0, r4, #31
    f310:	005b      	lsls	r3, r3, #1
    f312:	3901      	subs	r1, #1
    f314:	181b      	adds	r3, r3, r0
    f316:	0064      	lsls	r4, r4, #1
    f318:	0852      	lsrs	r2, r2, #1
    f31a:	2900      	cmp	r1, #0
    f31c:	d1f1      	bne.n	f302 <__ieee754_sqrt+0x5a>
    f31e:	2200      	movs	r2, #0
    f320:	9201      	str	r2, [sp, #4]
    f322:	4694      	mov	ip, r2
    f324:	2280      	movs	r2, #128	; 0x80
    f326:	0612      	lsls	r2, r2, #24
    f328:	2020      	movs	r0, #32
    f32a:	4691      	mov	r9, r2
    f32c:	e009      	b.n	f342 <__ieee754_sqrt+0x9a>
    f32e:	429f      	cmp	r7, r3
    f330:	d041      	beq.n	f3b6 <__ieee754_sqrt+0x10e>
    f332:	0fe1      	lsrs	r1, r4, #31
    f334:	18c9      	adds	r1, r1, r3
    f336:	3801      	subs	r0, #1
    f338:	18cb      	adds	r3, r1, r3
    f33a:	0064      	lsls	r4, r4, #1
    f33c:	0852      	lsrs	r2, r2, #1
    f33e:	2800      	cmp	r0, #0
    f340:	d01e      	beq.n	f380 <__ieee754_sqrt+0xd8>
    f342:	4661      	mov	r1, ip
    f344:	1851      	adds	r1, r2, r1
    f346:	429f      	cmp	r7, r3
    f348:	daf1      	bge.n	f32e <__ieee754_sqrt+0x86>
    f34a:	188d      	adds	r5, r1, r2
    f34c:	46ac      	mov	ip, r5
    f34e:	0fcd      	lsrs	r5, r1, #31
    f350:	07ed      	lsls	r5, r5, #31
    f352:	46ba      	mov	sl, r7
    f354:	454d      	cmp	r5, r9
    f356:	d039      	beq.n	f3cc <__ieee754_sqrt+0x124>
    f358:	1bdb      	subs	r3, r3, r7
    f35a:	428c      	cmp	r4, r1
    f35c:	41bf      	sbcs	r7, r7
    f35e:	427f      	negs	r7, r7
    f360:	1bdb      	subs	r3, r3, r7
    f362:	1a64      	subs	r4, r4, r1
    f364:	9901      	ldr	r1, [sp, #4]
    f366:	3801      	subs	r0, #1
    f368:	468b      	mov	fp, r1
    f36a:	4493      	add	fp, r2
    f36c:	4659      	mov	r1, fp
    f36e:	9101      	str	r1, [sp, #4]
    f370:	0fe1      	lsrs	r1, r4, #31
    f372:	18c9      	adds	r1, r1, r3
    f374:	4657      	mov	r7, sl
    f376:	18cb      	adds	r3, r1, r3
    f378:	0064      	lsls	r4, r4, #1
    f37a:	0852      	lsrs	r2, r2, #1
    f37c:	2800      	cmp	r0, #0
    f37e:	d1e0      	bne.n	f342 <__ieee754_sqrt+0x9a>
    f380:	4323      	orrs	r3, r4
    f382:	d12b      	bne.n	f3dc <__ieee754_sqrt+0x134>
    f384:	9b01      	ldr	r3, [sp, #4]
    f386:	085b      	lsrs	r3, r3, #1
    f388:	4941      	ldr	r1, [pc, #260]	; (f490 <__ieee754_sqrt+0x1e8>)
    f38a:	1072      	asrs	r2, r6, #1
    f38c:	468c      	mov	ip, r1
    f38e:	4462      	add	r2, ip
    f390:	07f1      	lsls	r1, r6, #31
    f392:	d502      	bpl.n	f39a <__ieee754_sqrt+0xf2>
    f394:	2180      	movs	r1, #128	; 0x80
    f396:	0609      	lsls	r1, r1, #24
    f398:	430b      	orrs	r3, r1
    f39a:	4641      	mov	r1, r8
    f39c:	0509      	lsls	r1, r1, #20
    f39e:	188d      	adds	r5, r1, r2
    f3a0:	001e      	movs	r6, r3
    f3a2:	002f      	movs	r7, r5
    f3a4:	0030      	movs	r0, r6
    f3a6:	0039      	movs	r1, r7
    f3a8:	b003      	add	sp, #12
    f3aa:	bc3c      	pop	{r2, r3, r4, r5}
    f3ac:	4690      	mov	r8, r2
    f3ae:	4699      	mov	r9, r3
    f3b0:	46a2      	mov	sl, r4
    f3b2:	46ab      	mov	fp, r5
    f3b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f3b6:	42a1      	cmp	r1, r4
    f3b8:	d80e      	bhi.n	f3d8 <__ieee754_sqrt+0x130>
    f3ba:	188d      	adds	r5, r1, r2
    f3bc:	46ac      	mov	ip, r5
    f3be:	0fcd      	lsrs	r5, r1, #31
    f3c0:	07ed      	lsls	r5, r5, #31
    f3c2:	454d      	cmp	r5, r9
    f3c4:	d048      	beq.n	f458 <__ieee754_sqrt+0x1b0>
    f3c6:	469a      	mov	sl, r3
    f3c8:	2300      	movs	r3, #0
    f3ca:	e7ca      	b.n	f362 <__ieee754_sqrt+0xba>
    f3cc:	4665      	mov	r5, ip
    f3ce:	2d00      	cmp	r5, #0
    f3d0:	dbc2      	blt.n	f358 <__ieee754_sqrt+0xb0>
    f3d2:	1c7d      	adds	r5, r7, #1
    f3d4:	46aa      	mov	sl, r5
    f3d6:	e7bf      	b.n	f358 <__ieee754_sqrt+0xb0>
    f3d8:	003b      	movs	r3, r7
    f3da:	e7aa      	b.n	f332 <__ieee754_sqrt+0x8a>
    f3dc:	9b01      	ldr	r3, [sp, #4]
    f3de:	3301      	adds	r3, #1
    f3e0:	d03e      	beq.n	f460 <__ieee754_sqrt+0x1b8>
    f3e2:	9a01      	ldr	r2, [sp, #4]
    f3e4:	2301      	movs	r3, #1
    f3e6:	4694      	mov	ip, r2
    f3e8:	4013      	ands	r3, r2
    f3ea:	4463      	add	r3, ip
    f3ec:	085b      	lsrs	r3, r3, #1
    f3ee:	e7cb      	b.n	f388 <__ieee754_sqrt+0xe0>
    f3f0:	0fe3      	lsrs	r3, r4, #31
    f3f2:	0052      	lsls	r2, r2, #1
    f3f4:	189a      	adds	r2, r3, r2
    f3f6:	0064      	lsls	r4, r4, #1
    f3f8:	e778      	b.n	f2ec <__ieee754_sqrt+0x44>
    f3fa:	006b      	lsls	r3, r5, #1
    f3fc:	085b      	lsrs	r3, r3, #1
    f3fe:	4303      	orrs	r3, r0
    f400:	002f      	movs	r7, r5
    f402:	2b00      	cmp	r3, #0
    f404:	d0ce      	beq.n	f3a4 <__ieee754_sqrt+0xfc>
    f406:	2500      	movs	r5, #0
    f408:	2a00      	cmp	r2, #0
    f40a:	d131      	bne.n	f470 <__ieee754_sqrt+0x1c8>
    f40c:	0ae2      	lsrs	r2, r4, #11
    f40e:	3d15      	subs	r5, #21
    f410:	0564      	lsls	r4, r4, #21
    f412:	2a00      	cmp	r2, #0
    f414:	d0fa      	beq.n	f40c <__ieee754_sqrt+0x164>
    f416:	2380      	movs	r3, #128	; 0x80
    f418:	035b      	lsls	r3, r3, #13
    f41a:	421a      	tst	r2, r3
    f41c:	d123      	bne.n	f466 <__ieee754_sqrt+0x1be>
    f41e:	2080      	movs	r0, #128	; 0x80
    f420:	2300      	movs	r3, #0
    f422:	0340      	lsls	r0, r0, #13
    f424:	e000      	b.n	f428 <__ieee754_sqrt+0x180>
    f426:	000b      	movs	r3, r1
    f428:	0052      	lsls	r2, r2, #1
    f42a:	1c59      	adds	r1, r3, #1
    f42c:	4202      	tst	r2, r0
    f42e:	d0fa      	beq.n	f426 <__ieee754_sqrt+0x17e>
    f430:	2020      	movs	r0, #32
    f432:	1a40      	subs	r0, r0, r1
    f434:	1aed      	subs	r5, r5, r3
    f436:	0023      	movs	r3, r4
    f438:	40c3      	lsrs	r3, r0
    f43a:	408c      	lsls	r4, r1
    f43c:	431a      	orrs	r2, r3
    f43e:	e74a      	b.n	f2d6 <__ieee754_sqrt+0x2e>
    f440:	0002      	movs	r2, r0
    f442:	002b      	movs	r3, r5
    f444:	0029      	movs	r1, r5
    f446:	f001 fb21 	bl	10a8c <__aeabi_dmul>
    f44a:	0032      	movs	r2, r6
    f44c:	002b      	movs	r3, r5
    f44e:	f000 fbcd 	bl	fbec <__aeabi_dadd>
    f452:	0006      	movs	r6, r0
    f454:	000f      	movs	r7, r1
    f456:	e7a5      	b.n	f3a4 <__ieee754_sqrt+0xfc>
    f458:	4665      	mov	r5, ip
    f45a:	2d00      	cmp	r5, #0
    f45c:	dab9      	bge.n	f3d2 <__ieee754_sqrt+0x12a>
    f45e:	e7b2      	b.n	f3c6 <__ieee754_sqrt+0x11e>
    f460:	3601      	adds	r6, #1
    f462:	2300      	movs	r3, #0
    f464:	e790      	b.n	f388 <__ieee754_sqrt+0xe0>
    f466:	2301      	movs	r3, #1
    f468:	2020      	movs	r0, #32
    f46a:	425b      	negs	r3, r3
    f46c:	2100      	movs	r1, #0
    f46e:	e7e1      	b.n	f434 <__ieee754_sqrt+0x18c>
    f470:	003b      	movs	r3, r7
    f472:	0002      	movs	r2, r0
    f474:	0039      	movs	r1, r7
    f476:	f001 fd83 	bl	10f80 <__aeabi_dsub>
    f47a:	0002      	movs	r2, r0
    f47c:	000b      	movs	r3, r1
    f47e:	f000 fee1 	bl	10244 <__aeabi_ddiv>
    f482:	0006      	movs	r6, r0
    f484:	000f      	movs	r7, r1
    f486:	e78d      	b.n	f3a4 <__ieee754_sqrt+0xfc>
    f488:	7ff00000 	.word	0x7ff00000
    f48c:	fffffc01 	.word	0xfffffc01
    f490:	3fe00000 	.word	0x3fe00000

0000f494 <fabs>:
    f494:	0049      	lsls	r1, r1, #1
    f496:	084b      	lsrs	r3, r1, #1
    f498:	0019      	movs	r1, r3
    f49a:	4770      	bx	lr

0000f49c <finite>:
    f49c:	4b03      	ldr	r3, [pc, #12]	; (f4ac <finite+0x10>)
    f49e:	0048      	lsls	r0, r1, #1
    f4a0:	469c      	mov	ip, r3
    f4a2:	0840      	lsrs	r0, r0, #1
    f4a4:	4460      	add	r0, ip
    f4a6:	0fc0      	lsrs	r0, r0, #31
    f4a8:	4770      	bx	lr
    f4aa:	46c0      	nop			; (mov r8, r8)
    f4ac:	80100000 	.word	0x80100000

0000f4b0 <matherr>:
    f4b0:	2000      	movs	r0, #0
    f4b2:	4770      	bx	lr

0000f4b4 <nan>:
    f4b4:	2000      	movs	r0, #0
    f4b6:	4901      	ldr	r1, [pc, #4]	; (f4bc <nan+0x8>)
    f4b8:	4770      	bx	lr
    f4ba:	46c0      	nop			; (mov r8, r8)
    f4bc:	7ff80000 	.word	0x7ff80000

0000f4c0 <rint>:
    f4c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    f4c2:	4647      	mov	r7, r8
    f4c4:	b480      	push	{r7}
    f4c6:	0fcb      	lsrs	r3, r1, #31
    f4c8:	4698      	mov	r8, r3
    f4ca:	4c4a      	ldr	r4, [pc, #296]	; (f5f4 <rint+0x134>)
    f4cc:	004b      	lsls	r3, r1, #1
    f4ce:	0d5b      	lsrs	r3, r3, #21
    f4d0:	191e      	adds	r6, r3, r4
    f4d2:	b082      	sub	sp, #8
    f4d4:	0007      	movs	r7, r0
    f4d6:	000a      	movs	r2, r1
    f4d8:	2e13      	cmp	r6, #19
    f4da:	dc35      	bgt.n	f548 <rint+0x88>
    f4dc:	2e00      	cmp	r6, #0
    f4de:	db57      	blt.n	f590 <rint+0xd0>
    f4e0:	4b45      	ldr	r3, [pc, #276]	; (f5f8 <rint+0x138>)
    f4e2:	0004      	movs	r4, r0
    f4e4:	4133      	asrs	r3, r6
    f4e6:	001f      	movs	r7, r3
    f4e8:	400f      	ands	r7, r1
    f4ea:	4307      	orrs	r7, r0
    f4ec:	000d      	movs	r5, r1
    f4ee:	2f00      	cmp	r7, #0
    f4f0:	d024      	beq.n	f53c <rint+0x7c>
    f4f2:	085b      	lsrs	r3, r3, #1
    f4f4:	001c      	movs	r4, r3
    f4f6:	400c      	ands	r4, r1
    f4f8:	4320      	orrs	r0, r4
    f4fa:	2700      	movs	r7, #0
    f4fc:	2800      	cmp	r0, #0
    f4fe:	d007      	beq.n	f510 <rint+0x50>
    f500:	2e13      	cmp	r6, #19
    f502:	d100      	bne.n	f506 <rint+0x46>
    f504:	e072      	b.n	f5ec <rint+0x12c>
    f506:	2280      	movs	r2, #128	; 0x80
    f508:	02d2      	lsls	r2, r2, #11
    f50a:	4132      	asrs	r2, r6
    f50c:	4399      	bics	r1, r3
    f50e:	430a      	orrs	r2, r1
    f510:	4643      	mov	r3, r8
    f512:	00de      	lsls	r6, r3, #3
    f514:	4b39      	ldr	r3, [pc, #228]	; (f5fc <rint+0x13c>)
    f516:	0011      	movs	r1, r2
    f518:	199e      	adds	r6, r3, r6
    f51a:	6834      	ldr	r4, [r6, #0]
    f51c:	6875      	ldr	r5, [r6, #4]
    f51e:	0038      	movs	r0, r7
    f520:	0022      	movs	r2, r4
    f522:	002b      	movs	r3, r5
    f524:	f000 fb62 	bl	fbec <__aeabi_dadd>
    f528:	9000      	str	r0, [sp, #0]
    f52a:	9101      	str	r1, [sp, #4]
    f52c:	9800      	ldr	r0, [sp, #0]
    f52e:	9901      	ldr	r1, [sp, #4]
    f530:	0022      	movs	r2, r4
    f532:	002b      	movs	r3, r5
    f534:	f001 fd24 	bl	10f80 <__aeabi_dsub>
    f538:	0004      	movs	r4, r0
    f53a:	000d      	movs	r5, r1
    f53c:	0020      	movs	r0, r4
    f53e:	0029      	movs	r1, r5
    f540:	b002      	add	sp, #8
    f542:	bc04      	pop	{r2}
    f544:	4690      	mov	r8, r2
    f546:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f548:	2e33      	cmp	r6, #51	; 0x33
    f54a:	dd0c      	ble.n	f566 <rint+0xa6>
    f54c:	2380      	movs	r3, #128	; 0x80
    f54e:	0004      	movs	r4, r0
    f550:	000d      	movs	r5, r1
    f552:	00db      	lsls	r3, r3, #3
    f554:	429e      	cmp	r6, r3
    f556:	d1f1      	bne.n	f53c <rint+0x7c>
    f558:	0002      	movs	r2, r0
    f55a:	000b      	movs	r3, r1
    f55c:	f000 fb46 	bl	fbec <__aeabi_dadd>
    f560:	0004      	movs	r4, r0
    f562:	000d      	movs	r5, r1
    f564:	e7ea      	b.n	f53c <rint+0x7c>
    f566:	4c26      	ldr	r4, [pc, #152]	; (f600 <rint+0x140>)
    f568:	000d      	movs	r5, r1
    f56a:	46a4      	mov	ip, r4
    f56c:	2401      	movs	r4, #1
    f56e:	4463      	add	r3, ip
    f570:	4264      	negs	r4, r4
    f572:	40dc      	lsrs	r4, r3
    f574:	46a4      	mov	ip, r4
    f576:	4661      	mov	r1, ip
    f578:	0004      	movs	r4, r0
    f57a:	4201      	tst	r1, r0
    f57c:	d0de      	beq.n	f53c <rint+0x7c>
    f57e:	0849      	lsrs	r1, r1, #1
    f580:	4201      	tst	r1, r0
    f582:	d0c5      	beq.n	f510 <rint+0x50>
    f584:	2780      	movs	r7, #128	; 0x80
    f586:	05ff      	lsls	r7, r7, #23
    f588:	411f      	asrs	r7, r3
    f58a:	4388      	bics	r0, r1
    f58c:	4307      	orrs	r7, r0
    f58e:	e7bf      	b.n	f510 <rint+0x50>
    f590:	004b      	lsls	r3, r1, #1
    f592:	085b      	lsrs	r3, r3, #1
    f594:	4303      	orrs	r3, r0
    f596:	0004      	movs	r4, r0
    f598:	000d      	movs	r5, r1
    f59a:	2b00      	cmp	r3, #0
    f59c:	d0ce      	beq.n	f53c <rint+0x7c>
    f59e:	030b      	lsls	r3, r1, #12
    f5a0:	0b1b      	lsrs	r3, r3, #12
    f5a2:	4303      	orrs	r3, r0
    f5a4:	425a      	negs	r2, r3
    f5a6:	4313      	orrs	r3, r2
    f5a8:	2280      	movs	r2, #128	; 0x80
    f5aa:	0b1b      	lsrs	r3, r3, #12
    f5ac:	0312      	lsls	r2, r2, #12
    f5ae:	4013      	ands	r3, r2
    f5b0:	0c4a      	lsrs	r2, r1, #17
    f5b2:	0452      	lsls	r2, r2, #17
    f5b4:	4313      	orrs	r3, r2
    f5b6:	0019      	movs	r1, r3
    f5b8:	4643      	mov	r3, r8
    f5ba:	4a10      	ldr	r2, [pc, #64]	; (f5fc <rint+0x13c>)
    f5bc:	00db      	lsls	r3, r3, #3
    f5be:	18d3      	adds	r3, r2, r3
    f5c0:	681c      	ldr	r4, [r3, #0]
    f5c2:	685d      	ldr	r5, [r3, #4]
    f5c4:	0022      	movs	r2, r4
    f5c6:	002b      	movs	r3, r5
    f5c8:	f000 fb10 	bl	fbec <__aeabi_dadd>
    f5cc:	9000      	str	r0, [sp, #0]
    f5ce:	9101      	str	r1, [sp, #4]
    f5d0:	9800      	ldr	r0, [sp, #0]
    f5d2:	9901      	ldr	r1, [sp, #4]
    f5d4:	0022      	movs	r2, r4
    f5d6:	002b      	movs	r3, r5
    f5d8:	f001 fcd2 	bl	10f80 <__aeabi_dsub>
    f5dc:	4642      	mov	r2, r8
    f5de:	004b      	lsls	r3, r1, #1
    f5e0:	085b      	lsrs	r3, r3, #1
    f5e2:	07d6      	lsls	r6, r2, #31
    f5e4:	4333      	orrs	r3, r6
    f5e6:	0004      	movs	r4, r0
    f5e8:	001d      	movs	r5, r3
    f5ea:	e7a7      	b.n	f53c <rint+0x7c>
    f5ec:	2780      	movs	r7, #128	; 0x80
    f5ee:	063f      	lsls	r7, r7, #24
    f5f0:	e789      	b.n	f506 <rint+0x46>
    f5f2:	46c0      	nop			; (mov r8, r8)
    f5f4:	fffffc01 	.word	0xfffffc01
    f5f8:	000fffff 	.word	0x000fffff
    f5fc:	0001bf68 	.word	0x0001bf68
    f600:	fffffbed 	.word	0xfffffbed

0000f604 <scalbn>:
    f604:	004b      	lsls	r3, r1, #1
    f606:	b570      	push	{r4, r5, r6, lr}
    f608:	0d5b      	lsrs	r3, r3, #21
    f60a:	0014      	movs	r4, r2
    f60c:	000a      	movs	r2, r1
    f60e:	2b00      	cmp	r3, #0
    f610:	d11a      	bne.n	f648 <scalbn+0x44>
    f612:	004b      	lsls	r3, r1, #1
    f614:	085b      	lsrs	r3, r3, #1
    f616:	4303      	orrs	r3, r0
    f618:	d015      	beq.n	f646 <scalbn+0x42>
    f61a:	2200      	movs	r2, #0
    f61c:	4b22      	ldr	r3, [pc, #136]	; (f6a8 <scalbn+0xa4>)
    f61e:	f001 fa35 	bl	10a8c <__aeabi_dmul>
    f622:	4b22      	ldr	r3, [pc, #136]	; (f6ac <scalbn+0xa8>)
    f624:	000a      	movs	r2, r1
    f626:	429c      	cmp	r4, r3
    f628:	db22      	blt.n	f670 <scalbn+0x6c>
    f62a:	004b      	lsls	r3, r1, #1
    f62c:	0d5b      	lsrs	r3, r3, #21
    f62e:	3b36      	subs	r3, #54	; 0x36
    f630:	4d1f      	ldr	r5, [pc, #124]	; (f6b0 <scalbn+0xac>)
    f632:	18e3      	adds	r3, r4, r3
    f634:	42ab      	cmp	r3, r5
    f636:	dc20      	bgt.n	f67a <scalbn+0x76>
    f638:	2b00      	cmp	r3, #0
    f63a:	dd0d      	ble.n	f658 <scalbn+0x54>
    f63c:	4c1d      	ldr	r4, [pc, #116]	; (f6b4 <scalbn+0xb0>)
    f63e:	051b      	lsls	r3, r3, #20
    f640:	4022      	ands	r2, r4
    f642:	431a      	orrs	r2, r3
    f644:	0011      	movs	r1, r2
    f646:	bd70      	pop	{r4, r5, r6, pc}
    f648:	4d1b      	ldr	r5, [pc, #108]	; (f6b8 <scalbn+0xb4>)
    f64a:	42ab      	cmp	r3, r5
    f64c:	d1f0      	bne.n	f630 <scalbn+0x2c>
    f64e:	0002      	movs	r2, r0
    f650:	000b      	movs	r3, r1
    f652:	f000 facb 	bl	fbec <__aeabi_dadd>
    f656:	e7f6      	b.n	f646 <scalbn+0x42>
    f658:	001d      	movs	r5, r3
    f65a:	3535      	adds	r5, #53	; 0x35
    f65c:	da18      	bge.n	f690 <scalbn+0x8c>
    f65e:	4b17      	ldr	r3, [pc, #92]	; (f6bc <scalbn+0xb8>)
    f660:	0002      	movs	r2, r0
    f662:	429c      	cmp	r4, r3
    f664:	dc0a      	bgt.n	f67c <scalbn+0x78>
    f666:	000b      	movs	r3, r1
    f668:	4815      	ldr	r0, [pc, #84]	; (f6c0 <scalbn+0xbc>)
    f66a:	4916      	ldr	r1, [pc, #88]	; (f6c4 <scalbn+0xc0>)
    f66c:	f000 f832 	bl	f6d4 <copysign>
    f670:	4a13      	ldr	r2, [pc, #76]	; (f6c0 <scalbn+0xbc>)
    f672:	4b14      	ldr	r3, [pc, #80]	; (f6c4 <scalbn+0xc0>)
    f674:	f001 fa0a 	bl	10a8c <__aeabi_dmul>
    f678:	e7e5      	b.n	f646 <scalbn+0x42>
    f67a:	0002      	movs	r2, r0
    f67c:	000b      	movs	r3, r1
    f67e:	4812      	ldr	r0, [pc, #72]	; (f6c8 <scalbn+0xc4>)
    f680:	4912      	ldr	r1, [pc, #72]	; (f6cc <scalbn+0xc8>)
    f682:	f000 f827 	bl	f6d4 <copysign>
    f686:	4a10      	ldr	r2, [pc, #64]	; (f6c8 <scalbn+0xc4>)
    f688:	4b10      	ldr	r3, [pc, #64]	; (f6cc <scalbn+0xc8>)
    f68a:	f001 f9ff 	bl	10a8c <__aeabi_dmul>
    f68e:	e7da      	b.n	f646 <scalbn+0x42>
    f690:	4c08      	ldr	r4, [pc, #32]	; (f6b4 <scalbn+0xb0>)
    f692:	3336      	adds	r3, #54	; 0x36
    f694:	4022      	ands	r2, r4
    f696:	051b      	lsls	r3, r3, #20
    f698:	4313      	orrs	r3, r2
    f69a:	0019      	movs	r1, r3
    f69c:	2200      	movs	r2, #0
    f69e:	4b0c      	ldr	r3, [pc, #48]	; (f6d0 <scalbn+0xcc>)
    f6a0:	f001 f9f4 	bl	10a8c <__aeabi_dmul>
    f6a4:	e7cf      	b.n	f646 <scalbn+0x42>
    f6a6:	46c0      	nop			; (mov r8, r8)
    f6a8:	43500000 	.word	0x43500000
    f6ac:	ffff3cb0 	.word	0xffff3cb0
    f6b0:	000007fe 	.word	0x000007fe
    f6b4:	800fffff 	.word	0x800fffff
    f6b8:	000007ff 	.word	0x000007ff
    f6bc:	0000c350 	.word	0x0000c350
    f6c0:	c2f8f359 	.word	0xc2f8f359
    f6c4:	01a56e1f 	.word	0x01a56e1f
    f6c8:	8800759c 	.word	0x8800759c
    f6cc:	7e37e43c 	.word	0x7e37e43c
    f6d0:	3c900000 	.word	0x3c900000

0000f6d4 <copysign>:
    f6d4:	b530      	push	{r4, r5, lr}
    f6d6:	004a      	lsls	r2, r1, #1
    f6d8:	0fdb      	lsrs	r3, r3, #31
    f6da:	07db      	lsls	r3, r3, #31
    f6dc:	0852      	lsrs	r2, r2, #1
    f6de:	431a      	orrs	r2, r3
    f6e0:	0011      	movs	r1, r2
    f6e2:	bd30      	pop	{r4, r5, pc}

0000f6e4 <PTC_Handler>:
    f6e4:	b510      	push	{r4, lr}
    f6e6:	4b1f      	ldr	r3, [pc, #124]	; (f764 <PTC_Handler+0x80>)
    f6e8:	4798      	blx	r3
    f6ea:	4b1f      	ldr	r3, [pc, #124]	; (f768 <PTC_Handler+0x84>)
    f6ec:	4798      	blx	r3
    f6ee:	4b1f      	ldr	r3, [pc, #124]	; (f76c <PTC_Handler+0x88>)
    f6f0:	781b      	ldrb	r3, [r3, #0]
    f6f2:	2b01      	cmp	r3, #1
    f6f4:	d113      	bne.n	f71e <PTC_Handler+0x3a>
    f6f6:	4c1e      	ldr	r4, [pc, #120]	; (f770 <PTC_Handler+0x8c>)
    f6f8:	6823      	ldr	r3, [r4, #0]
    f6fa:	2b00      	cmp	r3, #0
    f6fc:	d031      	beq.n	f762 <PTC_Handler+0x7e>
    f6fe:	4b1d      	ldr	r3, [pc, #116]	; (f774 <PTC_Handler+0x90>)
    f700:	4798      	blx	r3
    f702:	4b1d      	ldr	r3, [pc, #116]	; (f778 <PTC_Handler+0x94>)
    f704:	2207      	movs	r2, #7
    f706:	7819      	ldrb	r1, [r3, #0]
    f708:	00c9      	lsls	r1, r1, #3
    f70a:	4311      	orrs	r1, r2
    f70c:	b2c9      	uxtb	r1, r1
    f70e:	7019      	strb	r1, [r3, #0]
    f710:	7859      	ldrb	r1, [r3, #1]
    f712:	00c9      	lsls	r1, r1, #3
    f714:	430a      	orrs	r2, r1
    f716:	b2d2      	uxtb	r2, r2
    f718:	705a      	strb	r2, [r3, #1]
    f71a:	6823      	ldr	r3, [r4, #0]
    f71c:	e020      	b.n	f760 <PTC_Handler+0x7c>
    f71e:	4b17      	ldr	r3, [pc, #92]	; (f77c <PTC_Handler+0x98>)
    f720:	2200      	movs	r2, #0
    f722:	7819      	ldrb	r1, [r3, #0]
    f724:	4c16      	ldr	r4, [pc, #88]	; (f780 <PTC_Handler+0x9c>)
    f726:	701a      	strb	r2, [r3, #0]
    f728:	2901      	cmp	r1, #1
    f72a:	d110      	bne.n	f74e <PTC_Handler+0x6a>
    f72c:	4b12      	ldr	r3, [pc, #72]	; (f778 <PTC_Handler+0x94>)
    f72e:	7122      	strb	r2, [r4, #4]
    f730:	785a      	ldrb	r2, [r3, #1]
    f732:	2a04      	cmp	r2, #4
    f734:	d102      	bne.n	f73c <PTC_Handler+0x58>
    f736:	2202      	movs	r2, #2
    f738:	705a      	strb	r2, [r3, #1]
    f73a:	e004      	b.n	f746 <PTC_Handler+0x62>
    f73c:	781a      	ldrb	r2, [r3, #0]
    f73e:	2a04      	cmp	r2, #4
    f740:	d101      	bne.n	f746 <PTC_Handler+0x62>
    f742:	2202      	movs	r2, #2
    f744:	701a      	strb	r2, [r3, #0]
    f746:	4b0f      	ldr	r3, [pc, #60]	; (f784 <PTC_Handler+0xa0>)
    f748:	2201      	movs	r2, #1
    f74a:	701a      	strb	r2, [r3, #0]
    f74c:	e009      	b.n	f762 <PTC_Handler+0x7e>
    f74e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    f750:	2b00      	cmp	r3, #0
    f752:	d000      	beq.n	f756 <PTC_Handler+0x72>
    f754:	4798      	blx	r3
    f756:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    f758:	4798      	blx	r3
    f75a:	6b23      	ldr	r3, [r4, #48]	; 0x30
    f75c:	2b00      	cmp	r3, #0
    f75e:	d000      	beq.n	f762 <PTC_Handler+0x7e>
    f760:	4798      	blx	r3
    f762:	bd10      	pop	{r4, pc}
    f764:	0000f80d 	.word	0x0000f80d
    f768:	0000f7ed 	.word	0x0000f7ed
    f76c:	200019d8 	.word	0x200019d8
    f770:	200019d4 	.word	0x200019d4
    f774:	0000f799 	.word	0x0000f799
    f778:	200019d0 	.word	0x200019d0
    f77c:	200028ca 	.word	0x200028ca
    f780:	200019e8 	.word	0x200019e8
    f784:	200019d9 	.word	0x200019d9

0000f788 <sync_config>:
    f788:	4a02      	ldr	r2, [pc, #8]	; (f794 <sync_config+0xc>)
    f78a:	7853      	ldrb	r3, [r2, #1]
    f78c:	09db      	lsrs	r3, r3, #7
    f78e:	d1fc      	bne.n	f78a <sync_config+0x2>
    f790:	4770      	bx	lr
    f792:	46c0      	nop			; (mov r8, r8)
    f794:	43001400 	.word	0x43001400

0000f798 <disable_ptc>:
    f798:	b510      	push	{r4, lr}
    f79a:	4c04      	ldr	r4, [pc, #16]	; (f7ac <disable_ptc+0x14>)
    f79c:	47a0      	blx	r4
    f79e:	4b04      	ldr	r3, [pc, #16]	; (f7b0 <disable_ptc+0x18>)
    f7a0:	2102      	movs	r1, #2
    f7a2:	781a      	ldrb	r2, [r3, #0]
    f7a4:	438a      	bics	r2, r1
    f7a6:	701a      	strb	r2, [r3, #0]
    f7a8:	47a0      	blx	r4
    f7aa:	bd10      	pop	{r4, pc}
    f7ac:	0000f789 	.word	0x0000f789
    f7b0:	43001400 	.word	0x43001400

0000f7b4 <clear_wco_int_flag>:
    f7b4:	b510      	push	{r4, lr}
    f7b6:	4c04      	ldr	r4, [pc, #16]	; (f7c8 <clear_wco_int_flag+0x14>)
    f7b8:	47a0      	blx	r4
    f7ba:	4b04      	ldr	r3, [pc, #16]	; (f7cc <clear_wco_int_flag+0x18>)
    f7bc:	2102      	movs	r1, #2
    f7be:	7a9a      	ldrb	r2, [r3, #10]
    f7c0:	430a      	orrs	r2, r1
    f7c2:	729a      	strb	r2, [r3, #10]
    f7c4:	47a0      	blx	r4
    f7c6:	bd10      	pop	{r4, pc}
    f7c8:	0000f789 	.word	0x0000f789
    f7cc:	43001400 	.word	0x43001400

0000f7d0 <clear_eoc_int_flag>:
    f7d0:	b510      	push	{r4, lr}
    f7d2:	4c04      	ldr	r4, [pc, #16]	; (f7e4 <clear_eoc_int_flag+0x14>)
    f7d4:	47a0      	blx	r4
    f7d6:	4b04      	ldr	r3, [pc, #16]	; (f7e8 <clear_eoc_int_flag+0x18>)
    f7d8:	2101      	movs	r1, #1
    f7da:	7a9a      	ldrb	r2, [r3, #10]
    f7dc:	430a      	orrs	r2, r1
    f7de:	729a      	strb	r2, [r3, #10]
    f7e0:	47a0      	blx	r4
    f7e2:	bd10      	pop	{r4, pc}
    f7e4:	0000f789 	.word	0x0000f789
    f7e8:	43001400 	.word	0x43001400

0000f7ec <check_n_clear_eoc_flag>:
    f7ec:	b508      	push	{r3, lr}
    f7ee:	4b04      	ldr	r3, [pc, #16]	; (f800 <check_n_clear_eoc_flag+0x14>)
    f7f0:	4798      	blx	r3
    f7f2:	4b04      	ldr	r3, [pc, #16]	; (f804 <check_n_clear_eoc_flag+0x18>)
    f7f4:	7a9b      	ldrb	r3, [r3, #10]
    f7f6:	07da      	lsls	r2, r3, #31
    f7f8:	d501      	bpl.n	f7fe <check_n_clear_eoc_flag+0x12>
    f7fa:	4b03      	ldr	r3, [pc, #12]	; (f808 <check_n_clear_eoc_flag+0x1c>)
    f7fc:	4798      	blx	r3
    f7fe:	bd08      	pop	{r3, pc}
    f800:	0000f789 	.word	0x0000f789
    f804:	43001400 	.word	0x43001400
    f808:	0000f7d1 	.word	0x0000f7d1

0000f80c <check_n_clear_wco_flag>:
    f80c:	b508      	push	{r3, lr}
    f80e:	4b04      	ldr	r3, [pc, #16]	; (f820 <check_n_clear_wco_flag+0x14>)
    f810:	4798      	blx	r3
    f812:	4b04      	ldr	r3, [pc, #16]	; (f824 <check_n_clear_wco_flag+0x18>)
    f814:	7a9b      	ldrb	r3, [r3, #10]
    f816:	079a      	lsls	r2, r3, #30
    f818:	d501      	bpl.n	f81e <check_n_clear_wco_flag+0x12>
    f81a:	4b03      	ldr	r3, [pc, #12]	; (f828 <check_n_clear_wco_flag+0x1c>)
    f81c:	4798      	blx	r3
    f81e:	bd08      	pop	{r3, pc}
    f820:	0000f789 	.word	0x0000f789
    f824:	43001400 	.word	0x43001400
    f828:	0000f7b5 	.word	0x0000f7b5

0000f82c <__aeabi_uidiv>:
    f82c:	2200      	movs	r2, #0
    f82e:	0843      	lsrs	r3, r0, #1
    f830:	428b      	cmp	r3, r1
    f832:	d374      	bcc.n	f91e <__aeabi_uidiv+0xf2>
    f834:	0903      	lsrs	r3, r0, #4
    f836:	428b      	cmp	r3, r1
    f838:	d35f      	bcc.n	f8fa <__aeabi_uidiv+0xce>
    f83a:	0a03      	lsrs	r3, r0, #8
    f83c:	428b      	cmp	r3, r1
    f83e:	d344      	bcc.n	f8ca <__aeabi_uidiv+0x9e>
    f840:	0b03      	lsrs	r3, r0, #12
    f842:	428b      	cmp	r3, r1
    f844:	d328      	bcc.n	f898 <__aeabi_uidiv+0x6c>
    f846:	0c03      	lsrs	r3, r0, #16
    f848:	428b      	cmp	r3, r1
    f84a:	d30d      	bcc.n	f868 <__aeabi_uidiv+0x3c>
    f84c:	22ff      	movs	r2, #255	; 0xff
    f84e:	0209      	lsls	r1, r1, #8
    f850:	ba12      	rev	r2, r2
    f852:	0c03      	lsrs	r3, r0, #16
    f854:	428b      	cmp	r3, r1
    f856:	d302      	bcc.n	f85e <__aeabi_uidiv+0x32>
    f858:	1212      	asrs	r2, r2, #8
    f85a:	0209      	lsls	r1, r1, #8
    f85c:	d065      	beq.n	f92a <__aeabi_uidiv+0xfe>
    f85e:	0b03      	lsrs	r3, r0, #12
    f860:	428b      	cmp	r3, r1
    f862:	d319      	bcc.n	f898 <__aeabi_uidiv+0x6c>
    f864:	e000      	b.n	f868 <__aeabi_uidiv+0x3c>
    f866:	0a09      	lsrs	r1, r1, #8
    f868:	0bc3      	lsrs	r3, r0, #15
    f86a:	428b      	cmp	r3, r1
    f86c:	d301      	bcc.n	f872 <__aeabi_uidiv+0x46>
    f86e:	03cb      	lsls	r3, r1, #15
    f870:	1ac0      	subs	r0, r0, r3
    f872:	4152      	adcs	r2, r2
    f874:	0b83      	lsrs	r3, r0, #14
    f876:	428b      	cmp	r3, r1
    f878:	d301      	bcc.n	f87e <__aeabi_uidiv+0x52>
    f87a:	038b      	lsls	r3, r1, #14
    f87c:	1ac0      	subs	r0, r0, r3
    f87e:	4152      	adcs	r2, r2
    f880:	0b43      	lsrs	r3, r0, #13
    f882:	428b      	cmp	r3, r1
    f884:	d301      	bcc.n	f88a <__aeabi_uidiv+0x5e>
    f886:	034b      	lsls	r3, r1, #13
    f888:	1ac0      	subs	r0, r0, r3
    f88a:	4152      	adcs	r2, r2
    f88c:	0b03      	lsrs	r3, r0, #12
    f88e:	428b      	cmp	r3, r1
    f890:	d301      	bcc.n	f896 <__aeabi_uidiv+0x6a>
    f892:	030b      	lsls	r3, r1, #12
    f894:	1ac0      	subs	r0, r0, r3
    f896:	4152      	adcs	r2, r2
    f898:	0ac3      	lsrs	r3, r0, #11
    f89a:	428b      	cmp	r3, r1
    f89c:	d301      	bcc.n	f8a2 <__aeabi_uidiv+0x76>
    f89e:	02cb      	lsls	r3, r1, #11
    f8a0:	1ac0      	subs	r0, r0, r3
    f8a2:	4152      	adcs	r2, r2
    f8a4:	0a83      	lsrs	r3, r0, #10
    f8a6:	428b      	cmp	r3, r1
    f8a8:	d301      	bcc.n	f8ae <__aeabi_uidiv+0x82>
    f8aa:	028b      	lsls	r3, r1, #10
    f8ac:	1ac0      	subs	r0, r0, r3
    f8ae:	4152      	adcs	r2, r2
    f8b0:	0a43      	lsrs	r3, r0, #9
    f8b2:	428b      	cmp	r3, r1
    f8b4:	d301      	bcc.n	f8ba <__aeabi_uidiv+0x8e>
    f8b6:	024b      	lsls	r3, r1, #9
    f8b8:	1ac0      	subs	r0, r0, r3
    f8ba:	4152      	adcs	r2, r2
    f8bc:	0a03      	lsrs	r3, r0, #8
    f8be:	428b      	cmp	r3, r1
    f8c0:	d301      	bcc.n	f8c6 <__aeabi_uidiv+0x9a>
    f8c2:	020b      	lsls	r3, r1, #8
    f8c4:	1ac0      	subs	r0, r0, r3
    f8c6:	4152      	adcs	r2, r2
    f8c8:	d2cd      	bcs.n	f866 <__aeabi_uidiv+0x3a>
    f8ca:	09c3      	lsrs	r3, r0, #7
    f8cc:	428b      	cmp	r3, r1
    f8ce:	d301      	bcc.n	f8d4 <__aeabi_uidiv+0xa8>
    f8d0:	01cb      	lsls	r3, r1, #7
    f8d2:	1ac0      	subs	r0, r0, r3
    f8d4:	4152      	adcs	r2, r2
    f8d6:	0983      	lsrs	r3, r0, #6
    f8d8:	428b      	cmp	r3, r1
    f8da:	d301      	bcc.n	f8e0 <__aeabi_uidiv+0xb4>
    f8dc:	018b      	lsls	r3, r1, #6
    f8de:	1ac0      	subs	r0, r0, r3
    f8e0:	4152      	adcs	r2, r2
    f8e2:	0943      	lsrs	r3, r0, #5
    f8e4:	428b      	cmp	r3, r1
    f8e6:	d301      	bcc.n	f8ec <__aeabi_uidiv+0xc0>
    f8e8:	014b      	lsls	r3, r1, #5
    f8ea:	1ac0      	subs	r0, r0, r3
    f8ec:	4152      	adcs	r2, r2
    f8ee:	0903      	lsrs	r3, r0, #4
    f8f0:	428b      	cmp	r3, r1
    f8f2:	d301      	bcc.n	f8f8 <__aeabi_uidiv+0xcc>
    f8f4:	010b      	lsls	r3, r1, #4
    f8f6:	1ac0      	subs	r0, r0, r3
    f8f8:	4152      	adcs	r2, r2
    f8fa:	08c3      	lsrs	r3, r0, #3
    f8fc:	428b      	cmp	r3, r1
    f8fe:	d301      	bcc.n	f904 <__aeabi_uidiv+0xd8>
    f900:	00cb      	lsls	r3, r1, #3
    f902:	1ac0      	subs	r0, r0, r3
    f904:	4152      	adcs	r2, r2
    f906:	0883      	lsrs	r3, r0, #2
    f908:	428b      	cmp	r3, r1
    f90a:	d301      	bcc.n	f910 <__aeabi_uidiv+0xe4>
    f90c:	008b      	lsls	r3, r1, #2
    f90e:	1ac0      	subs	r0, r0, r3
    f910:	4152      	adcs	r2, r2
    f912:	0843      	lsrs	r3, r0, #1
    f914:	428b      	cmp	r3, r1
    f916:	d301      	bcc.n	f91c <__aeabi_uidiv+0xf0>
    f918:	004b      	lsls	r3, r1, #1
    f91a:	1ac0      	subs	r0, r0, r3
    f91c:	4152      	adcs	r2, r2
    f91e:	1a41      	subs	r1, r0, r1
    f920:	d200      	bcs.n	f924 <__aeabi_uidiv+0xf8>
    f922:	4601      	mov	r1, r0
    f924:	4152      	adcs	r2, r2
    f926:	4610      	mov	r0, r2
    f928:	4770      	bx	lr
    f92a:	e7ff      	b.n	f92c <__aeabi_uidiv+0x100>
    f92c:	b501      	push	{r0, lr}
    f92e:	2000      	movs	r0, #0
    f930:	f000 f8f0 	bl	fb14 <__aeabi_idiv0>
    f934:	bd02      	pop	{r1, pc}
    f936:	46c0      	nop			; (mov r8, r8)

0000f938 <__aeabi_uidivmod>:
    f938:	2900      	cmp	r1, #0
    f93a:	d0f7      	beq.n	f92c <__aeabi_uidiv+0x100>
    f93c:	e776      	b.n	f82c <__aeabi_uidiv>
    f93e:	4770      	bx	lr

0000f940 <__aeabi_idiv>:
    f940:	4603      	mov	r3, r0
    f942:	430b      	orrs	r3, r1
    f944:	d47f      	bmi.n	fa46 <__aeabi_idiv+0x106>
    f946:	2200      	movs	r2, #0
    f948:	0843      	lsrs	r3, r0, #1
    f94a:	428b      	cmp	r3, r1
    f94c:	d374      	bcc.n	fa38 <__aeabi_idiv+0xf8>
    f94e:	0903      	lsrs	r3, r0, #4
    f950:	428b      	cmp	r3, r1
    f952:	d35f      	bcc.n	fa14 <__aeabi_idiv+0xd4>
    f954:	0a03      	lsrs	r3, r0, #8
    f956:	428b      	cmp	r3, r1
    f958:	d344      	bcc.n	f9e4 <__aeabi_idiv+0xa4>
    f95a:	0b03      	lsrs	r3, r0, #12
    f95c:	428b      	cmp	r3, r1
    f95e:	d328      	bcc.n	f9b2 <__aeabi_idiv+0x72>
    f960:	0c03      	lsrs	r3, r0, #16
    f962:	428b      	cmp	r3, r1
    f964:	d30d      	bcc.n	f982 <__aeabi_idiv+0x42>
    f966:	22ff      	movs	r2, #255	; 0xff
    f968:	0209      	lsls	r1, r1, #8
    f96a:	ba12      	rev	r2, r2
    f96c:	0c03      	lsrs	r3, r0, #16
    f96e:	428b      	cmp	r3, r1
    f970:	d302      	bcc.n	f978 <__aeabi_idiv+0x38>
    f972:	1212      	asrs	r2, r2, #8
    f974:	0209      	lsls	r1, r1, #8
    f976:	d065      	beq.n	fa44 <__aeabi_idiv+0x104>
    f978:	0b03      	lsrs	r3, r0, #12
    f97a:	428b      	cmp	r3, r1
    f97c:	d319      	bcc.n	f9b2 <__aeabi_idiv+0x72>
    f97e:	e000      	b.n	f982 <__aeabi_idiv+0x42>
    f980:	0a09      	lsrs	r1, r1, #8
    f982:	0bc3      	lsrs	r3, r0, #15
    f984:	428b      	cmp	r3, r1
    f986:	d301      	bcc.n	f98c <__aeabi_idiv+0x4c>
    f988:	03cb      	lsls	r3, r1, #15
    f98a:	1ac0      	subs	r0, r0, r3
    f98c:	4152      	adcs	r2, r2
    f98e:	0b83      	lsrs	r3, r0, #14
    f990:	428b      	cmp	r3, r1
    f992:	d301      	bcc.n	f998 <__aeabi_idiv+0x58>
    f994:	038b      	lsls	r3, r1, #14
    f996:	1ac0      	subs	r0, r0, r3
    f998:	4152      	adcs	r2, r2
    f99a:	0b43      	lsrs	r3, r0, #13
    f99c:	428b      	cmp	r3, r1
    f99e:	d301      	bcc.n	f9a4 <__aeabi_idiv+0x64>
    f9a0:	034b      	lsls	r3, r1, #13
    f9a2:	1ac0      	subs	r0, r0, r3
    f9a4:	4152      	adcs	r2, r2
    f9a6:	0b03      	lsrs	r3, r0, #12
    f9a8:	428b      	cmp	r3, r1
    f9aa:	d301      	bcc.n	f9b0 <__aeabi_idiv+0x70>
    f9ac:	030b      	lsls	r3, r1, #12
    f9ae:	1ac0      	subs	r0, r0, r3
    f9b0:	4152      	adcs	r2, r2
    f9b2:	0ac3      	lsrs	r3, r0, #11
    f9b4:	428b      	cmp	r3, r1
    f9b6:	d301      	bcc.n	f9bc <__aeabi_idiv+0x7c>
    f9b8:	02cb      	lsls	r3, r1, #11
    f9ba:	1ac0      	subs	r0, r0, r3
    f9bc:	4152      	adcs	r2, r2
    f9be:	0a83      	lsrs	r3, r0, #10
    f9c0:	428b      	cmp	r3, r1
    f9c2:	d301      	bcc.n	f9c8 <__aeabi_idiv+0x88>
    f9c4:	028b      	lsls	r3, r1, #10
    f9c6:	1ac0      	subs	r0, r0, r3
    f9c8:	4152      	adcs	r2, r2
    f9ca:	0a43      	lsrs	r3, r0, #9
    f9cc:	428b      	cmp	r3, r1
    f9ce:	d301      	bcc.n	f9d4 <__aeabi_idiv+0x94>
    f9d0:	024b      	lsls	r3, r1, #9
    f9d2:	1ac0      	subs	r0, r0, r3
    f9d4:	4152      	adcs	r2, r2
    f9d6:	0a03      	lsrs	r3, r0, #8
    f9d8:	428b      	cmp	r3, r1
    f9da:	d301      	bcc.n	f9e0 <__aeabi_idiv+0xa0>
    f9dc:	020b      	lsls	r3, r1, #8
    f9de:	1ac0      	subs	r0, r0, r3
    f9e0:	4152      	adcs	r2, r2
    f9e2:	d2cd      	bcs.n	f980 <__aeabi_idiv+0x40>
    f9e4:	09c3      	lsrs	r3, r0, #7
    f9e6:	428b      	cmp	r3, r1
    f9e8:	d301      	bcc.n	f9ee <__aeabi_idiv+0xae>
    f9ea:	01cb      	lsls	r3, r1, #7
    f9ec:	1ac0      	subs	r0, r0, r3
    f9ee:	4152      	adcs	r2, r2
    f9f0:	0983      	lsrs	r3, r0, #6
    f9f2:	428b      	cmp	r3, r1
    f9f4:	d301      	bcc.n	f9fa <__aeabi_idiv+0xba>
    f9f6:	018b      	lsls	r3, r1, #6
    f9f8:	1ac0      	subs	r0, r0, r3
    f9fa:	4152      	adcs	r2, r2
    f9fc:	0943      	lsrs	r3, r0, #5
    f9fe:	428b      	cmp	r3, r1
    fa00:	d301      	bcc.n	fa06 <__aeabi_idiv+0xc6>
    fa02:	014b      	lsls	r3, r1, #5
    fa04:	1ac0      	subs	r0, r0, r3
    fa06:	4152      	adcs	r2, r2
    fa08:	0903      	lsrs	r3, r0, #4
    fa0a:	428b      	cmp	r3, r1
    fa0c:	d301      	bcc.n	fa12 <__aeabi_idiv+0xd2>
    fa0e:	010b      	lsls	r3, r1, #4
    fa10:	1ac0      	subs	r0, r0, r3
    fa12:	4152      	adcs	r2, r2
    fa14:	08c3      	lsrs	r3, r0, #3
    fa16:	428b      	cmp	r3, r1
    fa18:	d301      	bcc.n	fa1e <__aeabi_idiv+0xde>
    fa1a:	00cb      	lsls	r3, r1, #3
    fa1c:	1ac0      	subs	r0, r0, r3
    fa1e:	4152      	adcs	r2, r2
    fa20:	0883      	lsrs	r3, r0, #2
    fa22:	428b      	cmp	r3, r1
    fa24:	d301      	bcc.n	fa2a <__aeabi_idiv+0xea>
    fa26:	008b      	lsls	r3, r1, #2
    fa28:	1ac0      	subs	r0, r0, r3
    fa2a:	4152      	adcs	r2, r2
    fa2c:	0843      	lsrs	r3, r0, #1
    fa2e:	428b      	cmp	r3, r1
    fa30:	d301      	bcc.n	fa36 <__aeabi_idiv+0xf6>
    fa32:	004b      	lsls	r3, r1, #1
    fa34:	1ac0      	subs	r0, r0, r3
    fa36:	4152      	adcs	r2, r2
    fa38:	1a41      	subs	r1, r0, r1
    fa3a:	d200      	bcs.n	fa3e <__aeabi_idiv+0xfe>
    fa3c:	4601      	mov	r1, r0
    fa3e:	4152      	adcs	r2, r2
    fa40:	4610      	mov	r0, r2
    fa42:	4770      	bx	lr
    fa44:	e05d      	b.n	fb02 <__aeabi_idiv+0x1c2>
    fa46:	0fca      	lsrs	r2, r1, #31
    fa48:	d000      	beq.n	fa4c <__aeabi_idiv+0x10c>
    fa4a:	4249      	negs	r1, r1
    fa4c:	1003      	asrs	r3, r0, #32
    fa4e:	d300      	bcc.n	fa52 <__aeabi_idiv+0x112>
    fa50:	4240      	negs	r0, r0
    fa52:	4053      	eors	r3, r2
    fa54:	2200      	movs	r2, #0
    fa56:	469c      	mov	ip, r3
    fa58:	0903      	lsrs	r3, r0, #4
    fa5a:	428b      	cmp	r3, r1
    fa5c:	d32d      	bcc.n	faba <__aeabi_idiv+0x17a>
    fa5e:	0a03      	lsrs	r3, r0, #8
    fa60:	428b      	cmp	r3, r1
    fa62:	d312      	bcc.n	fa8a <__aeabi_idiv+0x14a>
    fa64:	22fc      	movs	r2, #252	; 0xfc
    fa66:	0189      	lsls	r1, r1, #6
    fa68:	ba12      	rev	r2, r2
    fa6a:	0a03      	lsrs	r3, r0, #8
    fa6c:	428b      	cmp	r3, r1
    fa6e:	d30c      	bcc.n	fa8a <__aeabi_idiv+0x14a>
    fa70:	0189      	lsls	r1, r1, #6
    fa72:	1192      	asrs	r2, r2, #6
    fa74:	428b      	cmp	r3, r1
    fa76:	d308      	bcc.n	fa8a <__aeabi_idiv+0x14a>
    fa78:	0189      	lsls	r1, r1, #6
    fa7a:	1192      	asrs	r2, r2, #6
    fa7c:	428b      	cmp	r3, r1
    fa7e:	d304      	bcc.n	fa8a <__aeabi_idiv+0x14a>
    fa80:	0189      	lsls	r1, r1, #6
    fa82:	d03a      	beq.n	fafa <__aeabi_idiv+0x1ba>
    fa84:	1192      	asrs	r2, r2, #6
    fa86:	e000      	b.n	fa8a <__aeabi_idiv+0x14a>
    fa88:	0989      	lsrs	r1, r1, #6
    fa8a:	09c3      	lsrs	r3, r0, #7
    fa8c:	428b      	cmp	r3, r1
    fa8e:	d301      	bcc.n	fa94 <__aeabi_idiv+0x154>
    fa90:	01cb      	lsls	r3, r1, #7
    fa92:	1ac0      	subs	r0, r0, r3
    fa94:	4152      	adcs	r2, r2
    fa96:	0983      	lsrs	r3, r0, #6
    fa98:	428b      	cmp	r3, r1
    fa9a:	d301      	bcc.n	faa0 <__aeabi_idiv+0x160>
    fa9c:	018b      	lsls	r3, r1, #6
    fa9e:	1ac0      	subs	r0, r0, r3
    faa0:	4152      	adcs	r2, r2
    faa2:	0943      	lsrs	r3, r0, #5
    faa4:	428b      	cmp	r3, r1
    faa6:	d301      	bcc.n	faac <__aeabi_idiv+0x16c>
    faa8:	014b      	lsls	r3, r1, #5
    faaa:	1ac0      	subs	r0, r0, r3
    faac:	4152      	adcs	r2, r2
    faae:	0903      	lsrs	r3, r0, #4
    fab0:	428b      	cmp	r3, r1
    fab2:	d301      	bcc.n	fab8 <__aeabi_idiv+0x178>
    fab4:	010b      	lsls	r3, r1, #4
    fab6:	1ac0      	subs	r0, r0, r3
    fab8:	4152      	adcs	r2, r2
    faba:	08c3      	lsrs	r3, r0, #3
    fabc:	428b      	cmp	r3, r1
    fabe:	d301      	bcc.n	fac4 <__aeabi_idiv+0x184>
    fac0:	00cb      	lsls	r3, r1, #3
    fac2:	1ac0      	subs	r0, r0, r3
    fac4:	4152      	adcs	r2, r2
    fac6:	0883      	lsrs	r3, r0, #2
    fac8:	428b      	cmp	r3, r1
    faca:	d301      	bcc.n	fad0 <__aeabi_idiv+0x190>
    facc:	008b      	lsls	r3, r1, #2
    face:	1ac0      	subs	r0, r0, r3
    fad0:	4152      	adcs	r2, r2
    fad2:	d2d9      	bcs.n	fa88 <__aeabi_idiv+0x148>
    fad4:	0843      	lsrs	r3, r0, #1
    fad6:	428b      	cmp	r3, r1
    fad8:	d301      	bcc.n	fade <__aeabi_idiv+0x19e>
    fada:	004b      	lsls	r3, r1, #1
    fadc:	1ac0      	subs	r0, r0, r3
    fade:	4152      	adcs	r2, r2
    fae0:	1a41      	subs	r1, r0, r1
    fae2:	d200      	bcs.n	fae6 <__aeabi_idiv+0x1a6>
    fae4:	4601      	mov	r1, r0
    fae6:	4663      	mov	r3, ip
    fae8:	4152      	adcs	r2, r2
    faea:	105b      	asrs	r3, r3, #1
    faec:	4610      	mov	r0, r2
    faee:	d301      	bcc.n	faf4 <__aeabi_idiv+0x1b4>
    faf0:	4240      	negs	r0, r0
    faf2:	2b00      	cmp	r3, #0
    faf4:	d500      	bpl.n	faf8 <__aeabi_idiv+0x1b8>
    faf6:	4249      	negs	r1, r1
    faf8:	4770      	bx	lr
    fafa:	4663      	mov	r3, ip
    fafc:	105b      	asrs	r3, r3, #1
    fafe:	d300      	bcc.n	fb02 <__aeabi_idiv+0x1c2>
    fb00:	4240      	negs	r0, r0
    fb02:	b501      	push	{r0, lr}
    fb04:	2000      	movs	r0, #0
    fb06:	f000 f805 	bl	fb14 <__aeabi_idiv0>
    fb0a:	bd02      	pop	{r1, pc}

0000fb0c <__aeabi_idivmod>:
    fb0c:	2900      	cmp	r1, #0
    fb0e:	d0f8      	beq.n	fb02 <__aeabi_idiv+0x1c2>
    fb10:	e716      	b.n	f940 <__aeabi_idiv>
    fb12:	4770      	bx	lr

0000fb14 <__aeabi_idiv0>:
    fb14:	4770      	bx	lr
    fb16:	46c0      	nop			; (mov r8, r8)

0000fb18 <__aeabi_cdrcmple>:
    fb18:	4684      	mov	ip, r0
    fb1a:	1c10      	adds	r0, r2, #0
    fb1c:	4662      	mov	r2, ip
    fb1e:	468c      	mov	ip, r1
    fb20:	1c19      	adds	r1, r3, #0
    fb22:	4663      	mov	r3, ip
    fb24:	e000      	b.n	fb28 <__aeabi_cdcmpeq>
    fb26:	46c0      	nop			; (mov r8, r8)

0000fb28 <__aeabi_cdcmpeq>:
    fb28:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    fb2a:	f000 ff45 	bl	109b8 <__ledf2>
    fb2e:	2800      	cmp	r0, #0
    fb30:	d401      	bmi.n	fb36 <__aeabi_cdcmpeq+0xe>
    fb32:	2100      	movs	r1, #0
    fb34:	42c8      	cmn	r0, r1
    fb36:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

0000fb38 <__aeabi_dcmpeq>:
    fb38:	b510      	push	{r4, lr}
    fb3a:	f000 fe99 	bl	10870 <__eqdf2>
    fb3e:	4240      	negs	r0, r0
    fb40:	3001      	adds	r0, #1
    fb42:	bd10      	pop	{r4, pc}

0000fb44 <__aeabi_dcmplt>:
    fb44:	b510      	push	{r4, lr}
    fb46:	f000 ff37 	bl	109b8 <__ledf2>
    fb4a:	2800      	cmp	r0, #0
    fb4c:	db01      	blt.n	fb52 <__aeabi_dcmplt+0xe>
    fb4e:	2000      	movs	r0, #0
    fb50:	bd10      	pop	{r4, pc}
    fb52:	2001      	movs	r0, #1
    fb54:	bd10      	pop	{r4, pc}
    fb56:	46c0      	nop			; (mov r8, r8)

0000fb58 <__aeabi_dcmple>:
    fb58:	b510      	push	{r4, lr}
    fb5a:	f000 ff2d 	bl	109b8 <__ledf2>
    fb5e:	2800      	cmp	r0, #0
    fb60:	dd01      	ble.n	fb66 <__aeabi_dcmple+0xe>
    fb62:	2000      	movs	r0, #0
    fb64:	bd10      	pop	{r4, pc}
    fb66:	2001      	movs	r0, #1
    fb68:	bd10      	pop	{r4, pc}
    fb6a:	46c0      	nop			; (mov r8, r8)

0000fb6c <__aeabi_dcmpgt>:
    fb6c:	b510      	push	{r4, lr}
    fb6e:	f000 febf 	bl	108f0 <__gedf2>
    fb72:	2800      	cmp	r0, #0
    fb74:	dc01      	bgt.n	fb7a <__aeabi_dcmpgt+0xe>
    fb76:	2000      	movs	r0, #0
    fb78:	bd10      	pop	{r4, pc}
    fb7a:	2001      	movs	r0, #1
    fb7c:	bd10      	pop	{r4, pc}
    fb7e:	46c0      	nop			; (mov r8, r8)

0000fb80 <__aeabi_dcmpge>:
    fb80:	b510      	push	{r4, lr}
    fb82:	f000 feb5 	bl	108f0 <__gedf2>
    fb86:	2800      	cmp	r0, #0
    fb88:	da01      	bge.n	fb8e <__aeabi_dcmpge+0xe>
    fb8a:	2000      	movs	r0, #0
    fb8c:	bd10      	pop	{r4, pc}
    fb8e:	2001      	movs	r0, #1
    fb90:	bd10      	pop	{r4, pc}
    fb92:	46c0      	nop			; (mov r8, r8)

0000fb94 <__aeabi_lmul>:
    fb94:	b5f0      	push	{r4, r5, r6, r7, lr}
    fb96:	464f      	mov	r7, r9
    fb98:	4646      	mov	r6, r8
    fb9a:	b4c0      	push	{r6, r7}
    fb9c:	0416      	lsls	r6, r2, #16
    fb9e:	0c36      	lsrs	r6, r6, #16
    fba0:	4699      	mov	r9, r3
    fba2:	0033      	movs	r3, r6
    fba4:	0405      	lsls	r5, r0, #16
    fba6:	0c2c      	lsrs	r4, r5, #16
    fba8:	0c07      	lsrs	r7, r0, #16
    fbaa:	0c15      	lsrs	r5, r2, #16
    fbac:	4363      	muls	r3, r4
    fbae:	437e      	muls	r6, r7
    fbb0:	436f      	muls	r7, r5
    fbb2:	4365      	muls	r5, r4
    fbb4:	0c1c      	lsrs	r4, r3, #16
    fbb6:	19ad      	adds	r5, r5, r6
    fbb8:	1964      	adds	r4, r4, r5
    fbba:	469c      	mov	ip, r3
    fbbc:	42a6      	cmp	r6, r4
    fbbe:	d903      	bls.n	fbc8 <__aeabi_lmul+0x34>
    fbc0:	2380      	movs	r3, #128	; 0x80
    fbc2:	025b      	lsls	r3, r3, #9
    fbc4:	4698      	mov	r8, r3
    fbc6:	4447      	add	r7, r8
    fbc8:	4663      	mov	r3, ip
    fbca:	0c25      	lsrs	r5, r4, #16
    fbcc:	19ef      	adds	r7, r5, r7
    fbce:	041d      	lsls	r5, r3, #16
    fbd0:	464b      	mov	r3, r9
    fbd2:	434a      	muls	r2, r1
    fbd4:	4343      	muls	r3, r0
    fbd6:	0c2d      	lsrs	r5, r5, #16
    fbd8:	0424      	lsls	r4, r4, #16
    fbda:	1964      	adds	r4, r4, r5
    fbdc:	1899      	adds	r1, r3, r2
    fbde:	19c9      	adds	r1, r1, r7
    fbe0:	0020      	movs	r0, r4
    fbe2:	bc0c      	pop	{r2, r3}
    fbe4:	4690      	mov	r8, r2
    fbe6:	4699      	mov	r9, r3
    fbe8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    fbea:	46c0      	nop			; (mov r8, r8)

0000fbec <__aeabi_dadd>:
    fbec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    fbee:	4656      	mov	r6, sl
    fbf0:	465f      	mov	r7, fp
    fbf2:	464d      	mov	r5, r9
    fbf4:	4644      	mov	r4, r8
    fbf6:	b4f0      	push	{r4, r5, r6, r7}
    fbf8:	000f      	movs	r7, r1
    fbfa:	0ffd      	lsrs	r5, r7, #31
    fbfc:	46aa      	mov	sl, r5
    fbfe:	0309      	lsls	r1, r1, #12
    fc00:	007c      	lsls	r4, r7, #1
    fc02:	002e      	movs	r6, r5
    fc04:	005f      	lsls	r7, r3, #1
    fc06:	0f45      	lsrs	r5, r0, #29
    fc08:	0a49      	lsrs	r1, r1, #9
    fc0a:	0d7f      	lsrs	r7, r7, #21
    fc0c:	4329      	orrs	r1, r5
    fc0e:	00c5      	lsls	r5, r0, #3
    fc10:	0318      	lsls	r0, r3, #12
    fc12:	46bc      	mov	ip, r7
    fc14:	0a40      	lsrs	r0, r0, #9
    fc16:	0f57      	lsrs	r7, r2, #29
    fc18:	0d64      	lsrs	r4, r4, #21
    fc1a:	0fdb      	lsrs	r3, r3, #31
    fc1c:	4338      	orrs	r0, r7
    fc1e:	00d2      	lsls	r2, r2, #3
    fc20:	459a      	cmp	sl, r3
    fc22:	d100      	bne.n	fc26 <__aeabi_dadd+0x3a>
    fc24:	e0aa      	b.n	fd7c <__aeabi_dadd+0x190>
    fc26:	4666      	mov	r6, ip
    fc28:	1ba6      	subs	r6, r4, r6
    fc2a:	2e00      	cmp	r6, #0
    fc2c:	dc00      	bgt.n	fc30 <__aeabi_dadd+0x44>
    fc2e:	e0ff      	b.n	fe30 <__aeabi_dadd+0x244>
    fc30:	4663      	mov	r3, ip
    fc32:	2b00      	cmp	r3, #0
    fc34:	d139      	bne.n	fcaa <__aeabi_dadd+0xbe>
    fc36:	0003      	movs	r3, r0
    fc38:	4313      	orrs	r3, r2
    fc3a:	d000      	beq.n	fc3e <__aeabi_dadd+0x52>
    fc3c:	e0d9      	b.n	fdf2 <__aeabi_dadd+0x206>
    fc3e:	076b      	lsls	r3, r5, #29
    fc40:	d009      	beq.n	fc56 <__aeabi_dadd+0x6a>
    fc42:	230f      	movs	r3, #15
    fc44:	402b      	ands	r3, r5
    fc46:	2b04      	cmp	r3, #4
    fc48:	d005      	beq.n	fc56 <__aeabi_dadd+0x6a>
    fc4a:	1d2b      	adds	r3, r5, #4
    fc4c:	42ab      	cmp	r3, r5
    fc4e:	41ad      	sbcs	r5, r5
    fc50:	426d      	negs	r5, r5
    fc52:	1949      	adds	r1, r1, r5
    fc54:	001d      	movs	r5, r3
    fc56:	020b      	lsls	r3, r1, #8
    fc58:	d400      	bmi.n	fc5c <__aeabi_dadd+0x70>
    fc5a:	e082      	b.n	fd62 <__aeabi_dadd+0x176>
    fc5c:	4bca      	ldr	r3, [pc, #808]	; (ff88 <__aeabi_dadd+0x39c>)
    fc5e:	3401      	adds	r4, #1
    fc60:	429c      	cmp	r4, r3
    fc62:	d100      	bne.n	fc66 <__aeabi_dadd+0x7a>
    fc64:	e0fe      	b.n	fe64 <__aeabi_dadd+0x278>
    fc66:	000a      	movs	r2, r1
    fc68:	4656      	mov	r6, sl
    fc6a:	4bc8      	ldr	r3, [pc, #800]	; (ff8c <__aeabi_dadd+0x3a0>)
    fc6c:	08ed      	lsrs	r5, r5, #3
    fc6e:	401a      	ands	r2, r3
    fc70:	0750      	lsls	r0, r2, #29
    fc72:	0564      	lsls	r4, r4, #21
    fc74:	0252      	lsls	r2, r2, #9
    fc76:	4305      	orrs	r5, r0
    fc78:	0b12      	lsrs	r2, r2, #12
    fc7a:	0d64      	lsrs	r4, r4, #21
    fc7c:	2100      	movs	r1, #0
    fc7e:	0312      	lsls	r2, r2, #12
    fc80:	0d0b      	lsrs	r3, r1, #20
    fc82:	051b      	lsls	r3, r3, #20
    fc84:	0564      	lsls	r4, r4, #21
    fc86:	0b12      	lsrs	r2, r2, #12
    fc88:	431a      	orrs	r2, r3
    fc8a:	0863      	lsrs	r3, r4, #1
    fc8c:	4cc0      	ldr	r4, [pc, #768]	; (ff90 <__aeabi_dadd+0x3a4>)
    fc8e:	07f6      	lsls	r6, r6, #31
    fc90:	4014      	ands	r4, r2
    fc92:	431c      	orrs	r4, r3
    fc94:	0064      	lsls	r4, r4, #1
    fc96:	0864      	lsrs	r4, r4, #1
    fc98:	4334      	orrs	r4, r6
    fc9a:	0028      	movs	r0, r5
    fc9c:	0021      	movs	r1, r4
    fc9e:	bc3c      	pop	{r2, r3, r4, r5}
    fca0:	4690      	mov	r8, r2
    fca2:	4699      	mov	r9, r3
    fca4:	46a2      	mov	sl, r4
    fca6:	46ab      	mov	fp, r5
    fca8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    fcaa:	4bb7      	ldr	r3, [pc, #732]	; (ff88 <__aeabi_dadd+0x39c>)
    fcac:	429c      	cmp	r4, r3
    fcae:	d0c6      	beq.n	fc3e <__aeabi_dadd+0x52>
    fcb0:	2380      	movs	r3, #128	; 0x80
    fcb2:	041b      	lsls	r3, r3, #16
    fcb4:	4318      	orrs	r0, r3
    fcb6:	2e38      	cmp	r6, #56	; 0x38
    fcb8:	dd00      	ble.n	fcbc <__aeabi_dadd+0xd0>
    fcba:	e0eb      	b.n	fe94 <__aeabi_dadd+0x2a8>
    fcbc:	2e1f      	cmp	r6, #31
    fcbe:	dd00      	ble.n	fcc2 <__aeabi_dadd+0xd6>
    fcc0:	e11e      	b.n	ff00 <__aeabi_dadd+0x314>
    fcc2:	2320      	movs	r3, #32
    fcc4:	1b9b      	subs	r3, r3, r6
    fcc6:	469c      	mov	ip, r3
    fcc8:	0003      	movs	r3, r0
    fcca:	4667      	mov	r7, ip
    fccc:	40bb      	lsls	r3, r7
    fcce:	4698      	mov	r8, r3
    fcd0:	0013      	movs	r3, r2
    fcd2:	4647      	mov	r7, r8
    fcd4:	40f3      	lsrs	r3, r6
    fcd6:	433b      	orrs	r3, r7
    fcd8:	4667      	mov	r7, ip
    fcda:	40ba      	lsls	r2, r7
    fcdc:	1e57      	subs	r7, r2, #1
    fcde:	41ba      	sbcs	r2, r7
    fce0:	4313      	orrs	r3, r2
    fce2:	0002      	movs	r2, r0
    fce4:	40f2      	lsrs	r2, r6
    fce6:	1aeb      	subs	r3, r5, r3
    fce8:	429d      	cmp	r5, r3
    fcea:	41b6      	sbcs	r6, r6
    fcec:	001d      	movs	r5, r3
    fcee:	1a8a      	subs	r2, r1, r2
    fcf0:	4276      	negs	r6, r6
    fcf2:	1b91      	subs	r1, r2, r6
    fcf4:	020b      	lsls	r3, r1, #8
    fcf6:	d531      	bpl.n	fd5c <__aeabi_dadd+0x170>
    fcf8:	024a      	lsls	r2, r1, #9
    fcfa:	0a56      	lsrs	r6, r2, #9
    fcfc:	2e00      	cmp	r6, #0
    fcfe:	d100      	bne.n	fd02 <__aeabi_dadd+0x116>
    fd00:	e0b4      	b.n	fe6c <__aeabi_dadd+0x280>
    fd02:	0030      	movs	r0, r6
    fd04:	f001 fd28 	bl	11758 <__clzsi2>
    fd08:	0003      	movs	r3, r0
    fd0a:	3b08      	subs	r3, #8
    fd0c:	2b1f      	cmp	r3, #31
    fd0e:	dd00      	ble.n	fd12 <__aeabi_dadd+0x126>
    fd10:	e0b5      	b.n	fe7e <__aeabi_dadd+0x292>
    fd12:	2220      	movs	r2, #32
    fd14:	0029      	movs	r1, r5
    fd16:	1ad2      	subs	r2, r2, r3
    fd18:	40d1      	lsrs	r1, r2
    fd1a:	409e      	lsls	r6, r3
    fd1c:	000a      	movs	r2, r1
    fd1e:	409d      	lsls	r5, r3
    fd20:	4332      	orrs	r2, r6
    fd22:	429c      	cmp	r4, r3
    fd24:	dd00      	ble.n	fd28 <__aeabi_dadd+0x13c>
    fd26:	e0b1      	b.n	fe8c <__aeabi_dadd+0x2a0>
    fd28:	1b1c      	subs	r4, r3, r4
    fd2a:	1c63      	adds	r3, r4, #1
    fd2c:	2b1f      	cmp	r3, #31
    fd2e:	dd00      	ble.n	fd32 <__aeabi_dadd+0x146>
    fd30:	e0d5      	b.n	fede <__aeabi_dadd+0x2f2>
    fd32:	2120      	movs	r1, #32
    fd34:	0014      	movs	r4, r2
    fd36:	0028      	movs	r0, r5
    fd38:	1ac9      	subs	r1, r1, r3
    fd3a:	408c      	lsls	r4, r1
    fd3c:	40d8      	lsrs	r0, r3
    fd3e:	408d      	lsls	r5, r1
    fd40:	4304      	orrs	r4, r0
    fd42:	40da      	lsrs	r2, r3
    fd44:	1e68      	subs	r0, r5, #1
    fd46:	4185      	sbcs	r5, r0
    fd48:	0011      	movs	r1, r2
    fd4a:	4325      	orrs	r5, r4
    fd4c:	2400      	movs	r4, #0
    fd4e:	e776      	b.n	fc3e <__aeabi_dadd+0x52>
    fd50:	4641      	mov	r1, r8
    fd52:	4331      	orrs	r1, r6
    fd54:	d100      	bne.n	fd58 <__aeabi_dadd+0x16c>
    fd56:	e234      	b.n	101c2 <__aeabi_dadd+0x5d6>
    fd58:	0031      	movs	r1, r6
    fd5a:	4645      	mov	r5, r8
    fd5c:	076b      	lsls	r3, r5, #29
    fd5e:	d000      	beq.n	fd62 <__aeabi_dadd+0x176>
    fd60:	e76f      	b.n	fc42 <__aeabi_dadd+0x56>
    fd62:	4656      	mov	r6, sl
    fd64:	0748      	lsls	r0, r1, #29
    fd66:	08ed      	lsrs	r5, r5, #3
    fd68:	08c9      	lsrs	r1, r1, #3
    fd6a:	4305      	orrs	r5, r0
    fd6c:	4b86      	ldr	r3, [pc, #536]	; (ff88 <__aeabi_dadd+0x39c>)
    fd6e:	429c      	cmp	r4, r3
    fd70:	d035      	beq.n	fdde <__aeabi_dadd+0x1f2>
    fd72:	030a      	lsls	r2, r1, #12
    fd74:	0564      	lsls	r4, r4, #21
    fd76:	0b12      	lsrs	r2, r2, #12
    fd78:	0d64      	lsrs	r4, r4, #21
    fd7a:	e77f      	b.n	fc7c <__aeabi_dadd+0x90>
    fd7c:	4663      	mov	r3, ip
    fd7e:	1ae3      	subs	r3, r4, r3
    fd80:	469b      	mov	fp, r3
    fd82:	2b00      	cmp	r3, #0
    fd84:	dc00      	bgt.n	fd88 <__aeabi_dadd+0x19c>
    fd86:	e08b      	b.n	fea0 <__aeabi_dadd+0x2b4>
    fd88:	4667      	mov	r7, ip
    fd8a:	2f00      	cmp	r7, #0
    fd8c:	d03c      	beq.n	fe08 <__aeabi_dadd+0x21c>
    fd8e:	4f7e      	ldr	r7, [pc, #504]	; (ff88 <__aeabi_dadd+0x39c>)
    fd90:	42bc      	cmp	r4, r7
    fd92:	d100      	bne.n	fd96 <__aeabi_dadd+0x1aa>
    fd94:	e753      	b.n	fc3e <__aeabi_dadd+0x52>
    fd96:	2780      	movs	r7, #128	; 0x80
    fd98:	043f      	lsls	r7, r7, #16
    fd9a:	4338      	orrs	r0, r7
    fd9c:	465b      	mov	r3, fp
    fd9e:	2b38      	cmp	r3, #56	; 0x38
    fda0:	dc00      	bgt.n	fda4 <__aeabi_dadd+0x1b8>
    fda2:	e0f7      	b.n	ff94 <__aeabi_dadd+0x3a8>
    fda4:	4302      	orrs	r2, r0
    fda6:	1e50      	subs	r0, r2, #1
    fda8:	4182      	sbcs	r2, r0
    fdaa:	2000      	movs	r0, #0
    fdac:	b2d2      	uxtb	r2, r2
    fdae:	1953      	adds	r3, r2, r5
    fdb0:	1842      	adds	r2, r0, r1
    fdb2:	42ab      	cmp	r3, r5
    fdb4:	4189      	sbcs	r1, r1
    fdb6:	001d      	movs	r5, r3
    fdb8:	4249      	negs	r1, r1
    fdba:	1889      	adds	r1, r1, r2
    fdbc:	020b      	lsls	r3, r1, #8
    fdbe:	d5cd      	bpl.n	fd5c <__aeabi_dadd+0x170>
    fdc0:	4b71      	ldr	r3, [pc, #452]	; (ff88 <__aeabi_dadd+0x39c>)
    fdc2:	3401      	adds	r4, #1
    fdc4:	429c      	cmp	r4, r3
    fdc6:	d100      	bne.n	fdca <__aeabi_dadd+0x1de>
    fdc8:	e13d      	b.n	10046 <__aeabi_dadd+0x45a>
    fdca:	2001      	movs	r0, #1
    fdcc:	4a6f      	ldr	r2, [pc, #444]	; (ff8c <__aeabi_dadd+0x3a0>)
    fdce:	086b      	lsrs	r3, r5, #1
    fdd0:	400a      	ands	r2, r1
    fdd2:	4028      	ands	r0, r5
    fdd4:	4318      	orrs	r0, r3
    fdd6:	07d5      	lsls	r5, r2, #31
    fdd8:	4305      	orrs	r5, r0
    fdda:	0851      	lsrs	r1, r2, #1
    fddc:	e72f      	b.n	fc3e <__aeabi_dadd+0x52>
    fdde:	002b      	movs	r3, r5
    fde0:	430b      	orrs	r3, r1
    fde2:	d100      	bne.n	fde6 <__aeabi_dadd+0x1fa>
    fde4:	e1cb      	b.n	1017e <__aeabi_dadd+0x592>
    fde6:	2380      	movs	r3, #128	; 0x80
    fde8:	031b      	lsls	r3, r3, #12
    fdea:	430b      	orrs	r3, r1
    fdec:	031a      	lsls	r2, r3, #12
    fdee:	0b12      	lsrs	r2, r2, #12
    fdf0:	e744      	b.n	fc7c <__aeabi_dadd+0x90>
    fdf2:	3e01      	subs	r6, #1
    fdf4:	2e00      	cmp	r6, #0
    fdf6:	d16d      	bne.n	fed4 <__aeabi_dadd+0x2e8>
    fdf8:	1aae      	subs	r6, r5, r2
    fdfa:	42b5      	cmp	r5, r6
    fdfc:	419b      	sbcs	r3, r3
    fdfe:	1a09      	subs	r1, r1, r0
    fe00:	425b      	negs	r3, r3
    fe02:	1ac9      	subs	r1, r1, r3
    fe04:	0035      	movs	r5, r6
    fe06:	e775      	b.n	fcf4 <__aeabi_dadd+0x108>
    fe08:	0007      	movs	r7, r0
    fe0a:	4317      	orrs	r7, r2
    fe0c:	d100      	bne.n	fe10 <__aeabi_dadd+0x224>
    fe0e:	e716      	b.n	fc3e <__aeabi_dadd+0x52>
    fe10:	2301      	movs	r3, #1
    fe12:	425b      	negs	r3, r3
    fe14:	469c      	mov	ip, r3
    fe16:	44e3      	add	fp, ip
    fe18:	465b      	mov	r3, fp
    fe1a:	2b00      	cmp	r3, #0
    fe1c:	d000      	beq.n	fe20 <__aeabi_dadd+0x234>
    fe1e:	e0e0      	b.n	ffe2 <__aeabi_dadd+0x3f6>
    fe20:	18aa      	adds	r2, r5, r2
    fe22:	42aa      	cmp	r2, r5
    fe24:	419b      	sbcs	r3, r3
    fe26:	1809      	adds	r1, r1, r0
    fe28:	425b      	negs	r3, r3
    fe2a:	1859      	adds	r1, r3, r1
    fe2c:	0015      	movs	r5, r2
    fe2e:	e7c5      	b.n	fdbc <__aeabi_dadd+0x1d0>
    fe30:	2e00      	cmp	r6, #0
    fe32:	d175      	bne.n	ff20 <__aeabi_dadd+0x334>
    fe34:	1c66      	adds	r6, r4, #1
    fe36:	0576      	lsls	r6, r6, #21
    fe38:	0d76      	lsrs	r6, r6, #21
    fe3a:	2e01      	cmp	r6, #1
    fe3c:	dc00      	bgt.n	fe40 <__aeabi_dadd+0x254>
    fe3e:	e0f3      	b.n	10028 <__aeabi_dadd+0x43c>
    fe40:	1aae      	subs	r6, r5, r2
    fe42:	46b0      	mov	r8, r6
    fe44:	4545      	cmp	r5, r8
    fe46:	41bf      	sbcs	r7, r7
    fe48:	1a0e      	subs	r6, r1, r0
    fe4a:	427f      	negs	r7, r7
    fe4c:	1bf6      	subs	r6, r6, r7
    fe4e:	0237      	lsls	r7, r6, #8
    fe50:	d400      	bmi.n	fe54 <__aeabi_dadd+0x268>
    fe52:	e08f      	b.n	ff74 <__aeabi_dadd+0x388>
    fe54:	1b55      	subs	r5, r2, r5
    fe56:	42aa      	cmp	r2, r5
    fe58:	41b6      	sbcs	r6, r6
    fe5a:	1a41      	subs	r1, r0, r1
    fe5c:	4276      	negs	r6, r6
    fe5e:	1b8e      	subs	r6, r1, r6
    fe60:	469a      	mov	sl, r3
    fe62:	e74b      	b.n	fcfc <__aeabi_dadd+0x110>
    fe64:	4656      	mov	r6, sl
    fe66:	2200      	movs	r2, #0
    fe68:	2500      	movs	r5, #0
    fe6a:	e707      	b.n	fc7c <__aeabi_dadd+0x90>
    fe6c:	0028      	movs	r0, r5
    fe6e:	f001 fc73 	bl	11758 <__clzsi2>
    fe72:	3020      	adds	r0, #32
    fe74:	0003      	movs	r3, r0
    fe76:	3b08      	subs	r3, #8
    fe78:	2b1f      	cmp	r3, #31
    fe7a:	dc00      	bgt.n	fe7e <__aeabi_dadd+0x292>
    fe7c:	e749      	b.n	fd12 <__aeabi_dadd+0x126>
    fe7e:	002a      	movs	r2, r5
    fe80:	3828      	subs	r0, #40	; 0x28
    fe82:	4082      	lsls	r2, r0
    fe84:	2500      	movs	r5, #0
    fe86:	429c      	cmp	r4, r3
    fe88:	dc00      	bgt.n	fe8c <__aeabi_dadd+0x2a0>
    fe8a:	e74d      	b.n	fd28 <__aeabi_dadd+0x13c>
    fe8c:	493f      	ldr	r1, [pc, #252]	; (ff8c <__aeabi_dadd+0x3a0>)
    fe8e:	1ae4      	subs	r4, r4, r3
    fe90:	4011      	ands	r1, r2
    fe92:	e6d4      	b.n	fc3e <__aeabi_dadd+0x52>
    fe94:	4302      	orrs	r2, r0
    fe96:	1e50      	subs	r0, r2, #1
    fe98:	4182      	sbcs	r2, r0
    fe9a:	b2d3      	uxtb	r3, r2
    fe9c:	2200      	movs	r2, #0
    fe9e:	e722      	b.n	fce6 <__aeabi_dadd+0xfa>
    fea0:	2b00      	cmp	r3, #0
    fea2:	d000      	beq.n	fea6 <__aeabi_dadd+0x2ba>
    fea4:	e0f3      	b.n	1008e <__aeabi_dadd+0x4a2>
    fea6:	1c63      	adds	r3, r4, #1
    fea8:	469c      	mov	ip, r3
    feaa:	055b      	lsls	r3, r3, #21
    feac:	0d5b      	lsrs	r3, r3, #21
    feae:	2b01      	cmp	r3, #1
    feb0:	dc00      	bgt.n	feb4 <__aeabi_dadd+0x2c8>
    feb2:	e09f      	b.n	fff4 <__aeabi_dadd+0x408>
    feb4:	4b34      	ldr	r3, [pc, #208]	; (ff88 <__aeabi_dadd+0x39c>)
    feb6:	459c      	cmp	ip, r3
    feb8:	d100      	bne.n	febc <__aeabi_dadd+0x2d0>
    feba:	e0c3      	b.n	10044 <__aeabi_dadd+0x458>
    febc:	18aa      	adds	r2, r5, r2
    febe:	1809      	adds	r1, r1, r0
    fec0:	42aa      	cmp	r2, r5
    fec2:	4180      	sbcs	r0, r0
    fec4:	4240      	negs	r0, r0
    fec6:	1841      	adds	r1, r0, r1
    fec8:	07cd      	lsls	r5, r1, #31
    feca:	0852      	lsrs	r2, r2, #1
    fecc:	4315      	orrs	r5, r2
    fece:	0849      	lsrs	r1, r1, #1
    fed0:	4664      	mov	r4, ip
    fed2:	e6b4      	b.n	fc3e <__aeabi_dadd+0x52>
    fed4:	4b2c      	ldr	r3, [pc, #176]	; (ff88 <__aeabi_dadd+0x39c>)
    fed6:	429c      	cmp	r4, r3
    fed8:	d000      	beq.n	fedc <__aeabi_dadd+0x2f0>
    feda:	e6ec      	b.n	fcb6 <__aeabi_dadd+0xca>
    fedc:	e6af      	b.n	fc3e <__aeabi_dadd+0x52>
    fede:	0011      	movs	r1, r2
    fee0:	3c1f      	subs	r4, #31
    fee2:	40e1      	lsrs	r1, r4
    fee4:	000c      	movs	r4, r1
    fee6:	2b20      	cmp	r3, #32
    fee8:	d100      	bne.n	feec <__aeabi_dadd+0x300>
    feea:	e07f      	b.n	ffec <__aeabi_dadd+0x400>
    feec:	2140      	movs	r1, #64	; 0x40
    feee:	1acb      	subs	r3, r1, r3
    fef0:	409a      	lsls	r2, r3
    fef2:	4315      	orrs	r5, r2
    fef4:	1e6a      	subs	r2, r5, #1
    fef6:	4195      	sbcs	r5, r2
    fef8:	2100      	movs	r1, #0
    fefa:	4325      	orrs	r5, r4
    fefc:	2400      	movs	r4, #0
    fefe:	e72d      	b.n	fd5c <__aeabi_dadd+0x170>
    ff00:	0033      	movs	r3, r6
    ff02:	0007      	movs	r7, r0
    ff04:	3b20      	subs	r3, #32
    ff06:	40df      	lsrs	r7, r3
    ff08:	003b      	movs	r3, r7
    ff0a:	2e20      	cmp	r6, #32
    ff0c:	d070      	beq.n	fff0 <__aeabi_dadd+0x404>
    ff0e:	2740      	movs	r7, #64	; 0x40
    ff10:	1bbe      	subs	r6, r7, r6
    ff12:	40b0      	lsls	r0, r6
    ff14:	4302      	orrs	r2, r0
    ff16:	1e50      	subs	r0, r2, #1
    ff18:	4182      	sbcs	r2, r0
    ff1a:	4313      	orrs	r3, r2
    ff1c:	2200      	movs	r2, #0
    ff1e:	e6e2      	b.n	fce6 <__aeabi_dadd+0xfa>
    ff20:	2c00      	cmp	r4, #0
    ff22:	d04f      	beq.n	ffc4 <__aeabi_dadd+0x3d8>
    ff24:	4c18      	ldr	r4, [pc, #96]	; (ff88 <__aeabi_dadd+0x39c>)
    ff26:	45a4      	cmp	ip, r4
    ff28:	d100      	bne.n	ff2c <__aeabi_dadd+0x340>
    ff2a:	e0ab      	b.n	10084 <__aeabi_dadd+0x498>
    ff2c:	2480      	movs	r4, #128	; 0x80
    ff2e:	0424      	lsls	r4, r4, #16
    ff30:	4276      	negs	r6, r6
    ff32:	4321      	orrs	r1, r4
    ff34:	2e38      	cmp	r6, #56	; 0x38
    ff36:	dd00      	ble.n	ff3a <__aeabi_dadd+0x34e>
    ff38:	e0df      	b.n	100fa <__aeabi_dadd+0x50e>
    ff3a:	2e1f      	cmp	r6, #31
    ff3c:	dd00      	ble.n	ff40 <__aeabi_dadd+0x354>
    ff3e:	e143      	b.n	101c8 <__aeabi_dadd+0x5dc>
    ff40:	2720      	movs	r7, #32
    ff42:	1bbc      	subs	r4, r7, r6
    ff44:	46a1      	mov	r9, r4
    ff46:	000c      	movs	r4, r1
    ff48:	464f      	mov	r7, r9
    ff4a:	40bc      	lsls	r4, r7
    ff4c:	46a0      	mov	r8, r4
    ff4e:	002c      	movs	r4, r5
    ff50:	4647      	mov	r7, r8
    ff52:	40f4      	lsrs	r4, r6
    ff54:	433c      	orrs	r4, r7
    ff56:	464f      	mov	r7, r9
    ff58:	40bd      	lsls	r5, r7
    ff5a:	1e6f      	subs	r7, r5, #1
    ff5c:	41bd      	sbcs	r5, r7
    ff5e:	40f1      	lsrs	r1, r6
    ff60:	432c      	orrs	r4, r5
    ff62:	1b15      	subs	r5, r2, r4
    ff64:	42aa      	cmp	r2, r5
    ff66:	4192      	sbcs	r2, r2
    ff68:	1a41      	subs	r1, r0, r1
    ff6a:	4252      	negs	r2, r2
    ff6c:	1a89      	subs	r1, r1, r2
    ff6e:	4664      	mov	r4, ip
    ff70:	469a      	mov	sl, r3
    ff72:	e6bf      	b.n	fcf4 <__aeabi_dadd+0x108>
    ff74:	4641      	mov	r1, r8
    ff76:	4645      	mov	r5, r8
    ff78:	4331      	orrs	r1, r6
    ff7a:	d000      	beq.n	ff7e <__aeabi_dadd+0x392>
    ff7c:	e6be      	b.n	fcfc <__aeabi_dadd+0x110>
    ff7e:	2600      	movs	r6, #0
    ff80:	2400      	movs	r4, #0
    ff82:	2500      	movs	r5, #0
    ff84:	e6f2      	b.n	fd6c <__aeabi_dadd+0x180>
    ff86:	46c0      	nop			; (mov r8, r8)
    ff88:	000007ff 	.word	0x000007ff
    ff8c:	ff7fffff 	.word	0xff7fffff
    ff90:	800fffff 	.word	0x800fffff
    ff94:	2b1f      	cmp	r3, #31
    ff96:	dc59      	bgt.n	1004c <__aeabi_dadd+0x460>
    ff98:	2720      	movs	r7, #32
    ff9a:	1aff      	subs	r7, r7, r3
    ff9c:	46bc      	mov	ip, r7
    ff9e:	0007      	movs	r7, r0
    ffa0:	4663      	mov	r3, ip
    ffa2:	409f      	lsls	r7, r3
    ffa4:	465b      	mov	r3, fp
    ffa6:	46b9      	mov	r9, r7
    ffa8:	0017      	movs	r7, r2
    ffaa:	40df      	lsrs	r7, r3
    ffac:	46b8      	mov	r8, r7
    ffae:	464f      	mov	r7, r9
    ffb0:	4643      	mov	r3, r8
    ffb2:	431f      	orrs	r7, r3
    ffb4:	4663      	mov	r3, ip
    ffb6:	409a      	lsls	r2, r3
    ffb8:	1e53      	subs	r3, r2, #1
    ffba:	419a      	sbcs	r2, r3
    ffbc:	465b      	mov	r3, fp
    ffbe:	433a      	orrs	r2, r7
    ffc0:	40d8      	lsrs	r0, r3
    ffc2:	e6f4      	b.n	fdae <__aeabi_dadd+0x1c2>
    ffc4:	000c      	movs	r4, r1
    ffc6:	432c      	orrs	r4, r5
    ffc8:	d05c      	beq.n	10084 <__aeabi_dadd+0x498>
    ffca:	43f6      	mvns	r6, r6
    ffcc:	2e00      	cmp	r6, #0
    ffce:	d155      	bne.n	1007c <__aeabi_dadd+0x490>
    ffd0:	1b55      	subs	r5, r2, r5
    ffd2:	42aa      	cmp	r2, r5
    ffd4:	41a4      	sbcs	r4, r4
    ffd6:	1a41      	subs	r1, r0, r1
    ffd8:	4264      	negs	r4, r4
    ffda:	1b09      	subs	r1, r1, r4
    ffdc:	469a      	mov	sl, r3
    ffde:	4664      	mov	r4, ip
    ffe0:	e688      	b.n	fcf4 <__aeabi_dadd+0x108>
    ffe2:	4f96      	ldr	r7, [pc, #600]	; (1023c <__aeabi_dadd+0x650>)
    ffe4:	42bc      	cmp	r4, r7
    ffe6:	d000      	beq.n	ffea <__aeabi_dadd+0x3fe>
    ffe8:	e6d8      	b.n	fd9c <__aeabi_dadd+0x1b0>
    ffea:	e628      	b.n	fc3e <__aeabi_dadd+0x52>
    ffec:	2200      	movs	r2, #0
    ffee:	e780      	b.n	fef2 <__aeabi_dadd+0x306>
    fff0:	2000      	movs	r0, #0
    fff2:	e78f      	b.n	ff14 <__aeabi_dadd+0x328>
    fff4:	000b      	movs	r3, r1
    fff6:	432b      	orrs	r3, r5
    fff8:	2c00      	cmp	r4, #0
    fffa:	d000      	beq.n	fffe <__aeabi_dadd+0x412>
    fffc:	e0c2      	b.n	10184 <__aeabi_dadd+0x598>
    fffe:	2b00      	cmp	r3, #0
   10000:	d100      	bne.n	10004 <__aeabi_dadd+0x418>
   10002:	e101      	b.n	10208 <__aeabi_dadd+0x61c>
   10004:	0003      	movs	r3, r0
   10006:	4313      	orrs	r3, r2
   10008:	d100      	bne.n	1000c <__aeabi_dadd+0x420>
   1000a:	e618      	b.n	fc3e <__aeabi_dadd+0x52>
   1000c:	18ab      	adds	r3, r5, r2
   1000e:	42ab      	cmp	r3, r5
   10010:	41b6      	sbcs	r6, r6
   10012:	1809      	adds	r1, r1, r0
   10014:	4276      	negs	r6, r6
   10016:	1871      	adds	r1, r6, r1
   10018:	020a      	lsls	r2, r1, #8
   1001a:	d400      	bmi.n	1001e <__aeabi_dadd+0x432>
   1001c:	e109      	b.n	10232 <__aeabi_dadd+0x646>
   1001e:	4a88      	ldr	r2, [pc, #544]	; (10240 <__aeabi_dadd+0x654>)
   10020:	001d      	movs	r5, r3
   10022:	4011      	ands	r1, r2
   10024:	4664      	mov	r4, ip
   10026:	e60a      	b.n	fc3e <__aeabi_dadd+0x52>
   10028:	2c00      	cmp	r4, #0
   1002a:	d15b      	bne.n	100e4 <__aeabi_dadd+0x4f8>
   1002c:	000e      	movs	r6, r1
   1002e:	432e      	orrs	r6, r5
   10030:	d000      	beq.n	10034 <__aeabi_dadd+0x448>
   10032:	e08a      	b.n	1014a <__aeabi_dadd+0x55e>
   10034:	0001      	movs	r1, r0
   10036:	4311      	orrs	r1, r2
   10038:	d100      	bne.n	1003c <__aeabi_dadd+0x450>
   1003a:	e0c2      	b.n	101c2 <__aeabi_dadd+0x5d6>
   1003c:	0001      	movs	r1, r0
   1003e:	0015      	movs	r5, r2
   10040:	469a      	mov	sl, r3
   10042:	e5fc      	b.n	fc3e <__aeabi_dadd+0x52>
   10044:	4664      	mov	r4, ip
   10046:	2100      	movs	r1, #0
   10048:	2500      	movs	r5, #0
   1004a:	e68f      	b.n	fd6c <__aeabi_dadd+0x180>
   1004c:	2320      	movs	r3, #32
   1004e:	425b      	negs	r3, r3
   10050:	469c      	mov	ip, r3
   10052:	44dc      	add	ip, fp
   10054:	4663      	mov	r3, ip
   10056:	0007      	movs	r7, r0
   10058:	40df      	lsrs	r7, r3
   1005a:	465b      	mov	r3, fp
   1005c:	46bc      	mov	ip, r7
   1005e:	2b20      	cmp	r3, #32
   10060:	d100      	bne.n	10064 <__aeabi_dadd+0x478>
   10062:	e0ac      	b.n	101be <__aeabi_dadd+0x5d2>
   10064:	2340      	movs	r3, #64	; 0x40
   10066:	465f      	mov	r7, fp
   10068:	1bdb      	subs	r3, r3, r7
   1006a:	4098      	lsls	r0, r3
   1006c:	4302      	orrs	r2, r0
   1006e:	1e50      	subs	r0, r2, #1
   10070:	4182      	sbcs	r2, r0
   10072:	4663      	mov	r3, ip
   10074:	4313      	orrs	r3, r2
   10076:	001a      	movs	r2, r3
   10078:	2000      	movs	r0, #0
   1007a:	e698      	b.n	fdae <__aeabi_dadd+0x1c2>
   1007c:	4c6f      	ldr	r4, [pc, #444]	; (1023c <__aeabi_dadd+0x650>)
   1007e:	45a4      	cmp	ip, r4
   10080:	d000      	beq.n	10084 <__aeabi_dadd+0x498>
   10082:	e757      	b.n	ff34 <__aeabi_dadd+0x348>
   10084:	0001      	movs	r1, r0
   10086:	0015      	movs	r5, r2
   10088:	4664      	mov	r4, ip
   1008a:	469a      	mov	sl, r3
   1008c:	e5d7      	b.n	fc3e <__aeabi_dadd+0x52>
   1008e:	2c00      	cmp	r4, #0
   10090:	d139      	bne.n	10106 <__aeabi_dadd+0x51a>
   10092:	000c      	movs	r4, r1
   10094:	432c      	orrs	r4, r5
   10096:	d06e      	beq.n	10176 <__aeabi_dadd+0x58a>
   10098:	43db      	mvns	r3, r3
   1009a:	2b00      	cmp	r3, #0
   1009c:	d01a      	beq.n	100d4 <__aeabi_dadd+0x4e8>
   1009e:	4c67      	ldr	r4, [pc, #412]	; (1023c <__aeabi_dadd+0x650>)
   100a0:	45a4      	cmp	ip, r4
   100a2:	d068      	beq.n	10176 <__aeabi_dadd+0x58a>
   100a4:	2b38      	cmp	r3, #56	; 0x38
   100a6:	dd00      	ble.n	100aa <__aeabi_dadd+0x4be>
   100a8:	e0a4      	b.n	101f4 <__aeabi_dadd+0x608>
   100aa:	2b1f      	cmp	r3, #31
   100ac:	dd00      	ble.n	100b0 <__aeabi_dadd+0x4c4>
   100ae:	e0ae      	b.n	1020e <__aeabi_dadd+0x622>
   100b0:	2420      	movs	r4, #32
   100b2:	000f      	movs	r7, r1
   100b4:	1ae4      	subs	r4, r4, r3
   100b6:	40a7      	lsls	r7, r4
   100b8:	46b9      	mov	r9, r7
   100ba:	002f      	movs	r7, r5
   100bc:	40df      	lsrs	r7, r3
   100be:	46b8      	mov	r8, r7
   100c0:	46a3      	mov	fp, r4
   100c2:	464f      	mov	r7, r9
   100c4:	4644      	mov	r4, r8
   100c6:	4327      	orrs	r7, r4
   100c8:	465c      	mov	r4, fp
   100ca:	40a5      	lsls	r5, r4
   100cc:	1e6c      	subs	r4, r5, #1
   100ce:	41a5      	sbcs	r5, r4
   100d0:	40d9      	lsrs	r1, r3
   100d2:	433d      	orrs	r5, r7
   100d4:	18ad      	adds	r5, r5, r2
   100d6:	4295      	cmp	r5, r2
   100d8:	419b      	sbcs	r3, r3
   100da:	1809      	adds	r1, r1, r0
   100dc:	425b      	negs	r3, r3
   100de:	1859      	adds	r1, r3, r1
   100e0:	4664      	mov	r4, ip
   100e2:	e66b      	b.n	fdbc <__aeabi_dadd+0x1d0>
   100e4:	000c      	movs	r4, r1
   100e6:	432c      	orrs	r4, r5
   100e8:	d115      	bne.n	10116 <__aeabi_dadd+0x52a>
   100ea:	0001      	movs	r1, r0
   100ec:	4311      	orrs	r1, r2
   100ee:	d07b      	beq.n	101e8 <__aeabi_dadd+0x5fc>
   100f0:	0001      	movs	r1, r0
   100f2:	0015      	movs	r5, r2
   100f4:	469a      	mov	sl, r3
   100f6:	4c51      	ldr	r4, [pc, #324]	; (1023c <__aeabi_dadd+0x650>)
   100f8:	e5a1      	b.n	fc3e <__aeabi_dadd+0x52>
   100fa:	430d      	orrs	r5, r1
   100fc:	1e69      	subs	r1, r5, #1
   100fe:	418d      	sbcs	r5, r1
   10100:	2100      	movs	r1, #0
   10102:	b2ec      	uxtb	r4, r5
   10104:	e72d      	b.n	ff62 <__aeabi_dadd+0x376>
   10106:	4c4d      	ldr	r4, [pc, #308]	; (1023c <__aeabi_dadd+0x650>)
   10108:	45a4      	cmp	ip, r4
   1010a:	d034      	beq.n	10176 <__aeabi_dadd+0x58a>
   1010c:	2480      	movs	r4, #128	; 0x80
   1010e:	0424      	lsls	r4, r4, #16
   10110:	425b      	negs	r3, r3
   10112:	4321      	orrs	r1, r4
   10114:	e7c6      	b.n	100a4 <__aeabi_dadd+0x4b8>
   10116:	0004      	movs	r4, r0
   10118:	4314      	orrs	r4, r2
   1011a:	d04e      	beq.n	101ba <__aeabi_dadd+0x5ce>
   1011c:	08ed      	lsrs	r5, r5, #3
   1011e:	074c      	lsls	r4, r1, #29
   10120:	432c      	orrs	r4, r5
   10122:	2580      	movs	r5, #128	; 0x80
   10124:	08c9      	lsrs	r1, r1, #3
   10126:	032d      	lsls	r5, r5, #12
   10128:	4229      	tst	r1, r5
   1012a:	d008      	beq.n	1013e <__aeabi_dadd+0x552>
   1012c:	08c6      	lsrs	r6, r0, #3
   1012e:	422e      	tst	r6, r5
   10130:	d105      	bne.n	1013e <__aeabi_dadd+0x552>
   10132:	08d2      	lsrs	r2, r2, #3
   10134:	0741      	lsls	r1, r0, #29
   10136:	4311      	orrs	r1, r2
   10138:	000c      	movs	r4, r1
   1013a:	469a      	mov	sl, r3
   1013c:	0031      	movs	r1, r6
   1013e:	0f62      	lsrs	r2, r4, #29
   10140:	00c9      	lsls	r1, r1, #3
   10142:	00e5      	lsls	r5, r4, #3
   10144:	4311      	orrs	r1, r2
   10146:	4c3d      	ldr	r4, [pc, #244]	; (1023c <__aeabi_dadd+0x650>)
   10148:	e579      	b.n	fc3e <__aeabi_dadd+0x52>
   1014a:	0006      	movs	r6, r0
   1014c:	4316      	orrs	r6, r2
   1014e:	d100      	bne.n	10152 <__aeabi_dadd+0x566>
   10150:	e575      	b.n	fc3e <__aeabi_dadd+0x52>
   10152:	1aae      	subs	r6, r5, r2
   10154:	46b0      	mov	r8, r6
   10156:	4545      	cmp	r5, r8
   10158:	41bf      	sbcs	r7, r7
   1015a:	1a0e      	subs	r6, r1, r0
   1015c:	427f      	negs	r7, r7
   1015e:	1bf6      	subs	r6, r6, r7
   10160:	0237      	lsls	r7, r6, #8
   10162:	d400      	bmi.n	10166 <__aeabi_dadd+0x57a>
   10164:	e5f4      	b.n	fd50 <__aeabi_dadd+0x164>
   10166:	1b55      	subs	r5, r2, r5
   10168:	42aa      	cmp	r2, r5
   1016a:	41b6      	sbcs	r6, r6
   1016c:	1a41      	subs	r1, r0, r1
   1016e:	4276      	negs	r6, r6
   10170:	1b89      	subs	r1, r1, r6
   10172:	469a      	mov	sl, r3
   10174:	e563      	b.n	fc3e <__aeabi_dadd+0x52>
   10176:	0001      	movs	r1, r0
   10178:	0015      	movs	r5, r2
   1017a:	4664      	mov	r4, ip
   1017c:	e55f      	b.n	fc3e <__aeabi_dadd+0x52>
   1017e:	2200      	movs	r2, #0
   10180:	2500      	movs	r5, #0
   10182:	e57b      	b.n	fc7c <__aeabi_dadd+0x90>
   10184:	2b00      	cmp	r3, #0
   10186:	d03b      	beq.n	10200 <__aeabi_dadd+0x614>
   10188:	0003      	movs	r3, r0
   1018a:	4313      	orrs	r3, r2
   1018c:	d015      	beq.n	101ba <__aeabi_dadd+0x5ce>
   1018e:	08ed      	lsrs	r5, r5, #3
   10190:	074b      	lsls	r3, r1, #29
   10192:	432b      	orrs	r3, r5
   10194:	2580      	movs	r5, #128	; 0x80
   10196:	08c9      	lsrs	r1, r1, #3
   10198:	032d      	lsls	r5, r5, #12
   1019a:	4229      	tst	r1, r5
   1019c:	d007      	beq.n	101ae <__aeabi_dadd+0x5c2>
   1019e:	08c4      	lsrs	r4, r0, #3
   101a0:	422c      	tst	r4, r5
   101a2:	d104      	bne.n	101ae <__aeabi_dadd+0x5c2>
   101a4:	0741      	lsls	r1, r0, #29
   101a6:	000b      	movs	r3, r1
   101a8:	0021      	movs	r1, r4
   101aa:	08d2      	lsrs	r2, r2, #3
   101ac:	4313      	orrs	r3, r2
   101ae:	00c9      	lsls	r1, r1, #3
   101b0:	0f5a      	lsrs	r2, r3, #29
   101b2:	4311      	orrs	r1, r2
   101b4:	00dd      	lsls	r5, r3, #3
   101b6:	4c21      	ldr	r4, [pc, #132]	; (1023c <__aeabi_dadd+0x650>)
   101b8:	e541      	b.n	fc3e <__aeabi_dadd+0x52>
   101ba:	4c20      	ldr	r4, [pc, #128]	; (1023c <__aeabi_dadd+0x650>)
   101bc:	e53f      	b.n	fc3e <__aeabi_dadd+0x52>
   101be:	2000      	movs	r0, #0
   101c0:	e754      	b.n	1006c <__aeabi_dadd+0x480>
   101c2:	2600      	movs	r6, #0
   101c4:	2500      	movs	r5, #0
   101c6:	e5d1      	b.n	fd6c <__aeabi_dadd+0x180>
   101c8:	0034      	movs	r4, r6
   101ca:	000f      	movs	r7, r1
   101cc:	3c20      	subs	r4, #32
   101ce:	40e7      	lsrs	r7, r4
   101d0:	003c      	movs	r4, r7
   101d2:	2e20      	cmp	r6, #32
   101d4:	d02b      	beq.n	1022e <__aeabi_dadd+0x642>
   101d6:	2740      	movs	r7, #64	; 0x40
   101d8:	1bbe      	subs	r6, r7, r6
   101da:	40b1      	lsls	r1, r6
   101dc:	430d      	orrs	r5, r1
   101de:	1e69      	subs	r1, r5, #1
   101e0:	418d      	sbcs	r5, r1
   101e2:	2100      	movs	r1, #0
   101e4:	432c      	orrs	r4, r5
   101e6:	e6bc      	b.n	ff62 <__aeabi_dadd+0x376>
   101e8:	2180      	movs	r1, #128	; 0x80
   101ea:	2600      	movs	r6, #0
   101ec:	0309      	lsls	r1, r1, #12
   101ee:	4c13      	ldr	r4, [pc, #76]	; (1023c <__aeabi_dadd+0x650>)
   101f0:	2500      	movs	r5, #0
   101f2:	e5bb      	b.n	fd6c <__aeabi_dadd+0x180>
   101f4:	430d      	orrs	r5, r1
   101f6:	1e69      	subs	r1, r5, #1
   101f8:	418d      	sbcs	r5, r1
   101fa:	2100      	movs	r1, #0
   101fc:	b2ed      	uxtb	r5, r5
   101fe:	e769      	b.n	100d4 <__aeabi_dadd+0x4e8>
   10200:	0001      	movs	r1, r0
   10202:	0015      	movs	r5, r2
   10204:	4c0d      	ldr	r4, [pc, #52]	; (1023c <__aeabi_dadd+0x650>)
   10206:	e51a      	b.n	fc3e <__aeabi_dadd+0x52>
   10208:	0001      	movs	r1, r0
   1020a:	0015      	movs	r5, r2
   1020c:	e517      	b.n	fc3e <__aeabi_dadd+0x52>
   1020e:	001c      	movs	r4, r3
   10210:	000f      	movs	r7, r1
   10212:	3c20      	subs	r4, #32
   10214:	40e7      	lsrs	r7, r4
   10216:	003c      	movs	r4, r7
   10218:	2b20      	cmp	r3, #32
   1021a:	d00c      	beq.n	10236 <__aeabi_dadd+0x64a>
   1021c:	2740      	movs	r7, #64	; 0x40
   1021e:	1afb      	subs	r3, r7, r3
   10220:	4099      	lsls	r1, r3
   10222:	430d      	orrs	r5, r1
   10224:	1e69      	subs	r1, r5, #1
   10226:	418d      	sbcs	r5, r1
   10228:	2100      	movs	r1, #0
   1022a:	4325      	orrs	r5, r4
   1022c:	e752      	b.n	100d4 <__aeabi_dadd+0x4e8>
   1022e:	2100      	movs	r1, #0
   10230:	e7d4      	b.n	101dc <__aeabi_dadd+0x5f0>
   10232:	001d      	movs	r5, r3
   10234:	e592      	b.n	fd5c <__aeabi_dadd+0x170>
   10236:	2100      	movs	r1, #0
   10238:	e7f3      	b.n	10222 <__aeabi_dadd+0x636>
   1023a:	46c0      	nop			; (mov r8, r8)
   1023c:	000007ff 	.word	0x000007ff
   10240:	ff7fffff 	.word	0xff7fffff

00010244 <__aeabi_ddiv>:
   10244:	b5f0      	push	{r4, r5, r6, r7, lr}
   10246:	4656      	mov	r6, sl
   10248:	464d      	mov	r5, r9
   1024a:	4644      	mov	r4, r8
   1024c:	465f      	mov	r7, fp
   1024e:	b4f0      	push	{r4, r5, r6, r7}
   10250:	001d      	movs	r5, r3
   10252:	030e      	lsls	r6, r1, #12
   10254:	004c      	lsls	r4, r1, #1
   10256:	0fcb      	lsrs	r3, r1, #31
   10258:	b087      	sub	sp, #28
   1025a:	0007      	movs	r7, r0
   1025c:	4692      	mov	sl, r2
   1025e:	4681      	mov	r9, r0
   10260:	0b36      	lsrs	r6, r6, #12
   10262:	0d64      	lsrs	r4, r4, #21
   10264:	4698      	mov	r8, r3
   10266:	d06a      	beq.n	1033e <__aeabi_ddiv+0xfa>
   10268:	4b6d      	ldr	r3, [pc, #436]	; (10420 <__aeabi_ddiv+0x1dc>)
   1026a:	429c      	cmp	r4, r3
   1026c:	d035      	beq.n	102da <__aeabi_ddiv+0x96>
   1026e:	2280      	movs	r2, #128	; 0x80
   10270:	0f43      	lsrs	r3, r0, #29
   10272:	0412      	lsls	r2, r2, #16
   10274:	4313      	orrs	r3, r2
   10276:	00f6      	lsls	r6, r6, #3
   10278:	431e      	orrs	r6, r3
   1027a:	00c3      	lsls	r3, r0, #3
   1027c:	4699      	mov	r9, r3
   1027e:	4b69      	ldr	r3, [pc, #420]	; (10424 <__aeabi_ddiv+0x1e0>)
   10280:	2700      	movs	r7, #0
   10282:	469c      	mov	ip, r3
   10284:	2300      	movs	r3, #0
   10286:	4464      	add	r4, ip
   10288:	9302      	str	r3, [sp, #8]
   1028a:	032b      	lsls	r3, r5, #12
   1028c:	0068      	lsls	r0, r5, #1
   1028e:	0b1b      	lsrs	r3, r3, #12
   10290:	0fed      	lsrs	r5, r5, #31
   10292:	4651      	mov	r1, sl
   10294:	469b      	mov	fp, r3
   10296:	0d40      	lsrs	r0, r0, #21
   10298:	9500      	str	r5, [sp, #0]
   1029a:	d100      	bne.n	1029e <__aeabi_ddiv+0x5a>
   1029c:	e078      	b.n	10390 <__aeabi_ddiv+0x14c>
   1029e:	4b60      	ldr	r3, [pc, #384]	; (10420 <__aeabi_ddiv+0x1dc>)
   102a0:	4298      	cmp	r0, r3
   102a2:	d06c      	beq.n	1037e <__aeabi_ddiv+0x13a>
   102a4:	465b      	mov	r3, fp
   102a6:	00da      	lsls	r2, r3, #3
   102a8:	0f4b      	lsrs	r3, r1, #29
   102aa:	2180      	movs	r1, #128	; 0x80
   102ac:	0409      	lsls	r1, r1, #16
   102ae:	430b      	orrs	r3, r1
   102b0:	4313      	orrs	r3, r2
   102b2:	469b      	mov	fp, r3
   102b4:	4653      	mov	r3, sl
   102b6:	00d9      	lsls	r1, r3, #3
   102b8:	4b5a      	ldr	r3, [pc, #360]	; (10424 <__aeabi_ddiv+0x1e0>)
   102ba:	469c      	mov	ip, r3
   102bc:	2300      	movs	r3, #0
   102be:	4460      	add	r0, ip
   102c0:	4642      	mov	r2, r8
   102c2:	1a20      	subs	r0, r4, r0
   102c4:	406a      	eors	r2, r5
   102c6:	4692      	mov	sl, r2
   102c8:	9001      	str	r0, [sp, #4]
   102ca:	431f      	orrs	r7, r3
   102cc:	2f0f      	cmp	r7, #15
   102ce:	d900      	bls.n	102d2 <__aeabi_ddiv+0x8e>
   102d0:	e0b0      	b.n	10434 <__aeabi_ddiv+0x1f0>
   102d2:	4855      	ldr	r0, [pc, #340]	; (10428 <__aeabi_ddiv+0x1e4>)
   102d4:	00bf      	lsls	r7, r7, #2
   102d6:	59c0      	ldr	r0, [r0, r7]
   102d8:	4687      	mov	pc, r0
   102da:	4337      	orrs	r7, r6
   102dc:	d000      	beq.n	102e0 <__aeabi_ddiv+0x9c>
   102de:	e088      	b.n	103f2 <__aeabi_ddiv+0x1ae>
   102e0:	2300      	movs	r3, #0
   102e2:	4699      	mov	r9, r3
   102e4:	3302      	adds	r3, #2
   102e6:	2708      	movs	r7, #8
   102e8:	2600      	movs	r6, #0
   102ea:	9302      	str	r3, [sp, #8]
   102ec:	e7cd      	b.n	1028a <__aeabi_ddiv+0x46>
   102ee:	4643      	mov	r3, r8
   102f0:	46b3      	mov	fp, r6
   102f2:	4649      	mov	r1, r9
   102f4:	9300      	str	r3, [sp, #0]
   102f6:	9b02      	ldr	r3, [sp, #8]
   102f8:	9a00      	ldr	r2, [sp, #0]
   102fa:	4692      	mov	sl, r2
   102fc:	2b02      	cmp	r3, #2
   102fe:	d000      	beq.n	10302 <__aeabi_ddiv+0xbe>
   10300:	e1bf      	b.n	10682 <__aeabi_ddiv+0x43e>
   10302:	2100      	movs	r1, #0
   10304:	4653      	mov	r3, sl
   10306:	2201      	movs	r2, #1
   10308:	2600      	movs	r6, #0
   1030a:	4689      	mov	r9, r1
   1030c:	401a      	ands	r2, r3
   1030e:	4b44      	ldr	r3, [pc, #272]	; (10420 <__aeabi_ddiv+0x1dc>)
   10310:	2100      	movs	r1, #0
   10312:	0336      	lsls	r6, r6, #12
   10314:	0d0c      	lsrs	r4, r1, #20
   10316:	0524      	lsls	r4, r4, #20
   10318:	0b36      	lsrs	r6, r6, #12
   1031a:	4326      	orrs	r6, r4
   1031c:	4c43      	ldr	r4, [pc, #268]	; (1042c <__aeabi_ddiv+0x1e8>)
   1031e:	051b      	lsls	r3, r3, #20
   10320:	4026      	ands	r6, r4
   10322:	431e      	orrs	r6, r3
   10324:	0076      	lsls	r6, r6, #1
   10326:	07d2      	lsls	r2, r2, #31
   10328:	0876      	lsrs	r6, r6, #1
   1032a:	4316      	orrs	r6, r2
   1032c:	4648      	mov	r0, r9
   1032e:	0031      	movs	r1, r6
   10330:	b007      	add	sp, #28
   10332:	bc3c      	pop	{r2, r3, r4, r5}
   10334:	4690      	mov	r8, r2
   10336:	4699      	mov	r9, r3
   10338:	46a2      	mov	sl, r4
   1033a:	46ab      	mov	fp, r5
   1033c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1033e:	0033      	movs	r3, r6
   10340:	4303      	orrs	r3, r0
   10342:	d04f      	beq.n	103e4 <__aeabi_ddiv+0x1a0>
   10344:	2e00      	cmp	r6, #0
   10346:	d100      	bne.n	1034a <__aeabi_ddiv+0x106>
   10348:	e1bc      	b.n	106c4 <__aeabi_ddiv+0x480>
   1034a:	0030      	movs	r0, r6
   1034c:	f001 fa04 	bl	11758 <__clzsi2>
   10350:	0003      	movs	r3, r0
   10352:	3b0b      	subs	r3, #11
   10354:	2b1c      	cmp	r3, #28
   10356:	dd00      	ble.n	1035a <__aeabi_ddiv+0x116>
   10358:	e1ad      	b.n	106b6 <__aeabi_ddiv+0x472>
   1035a:	221d      	movs	r2, #29
   1035c:	0001      	movs	r1, r0
   1035e:	1ad3      	subs	r3, r2, r3
   10360:	3908      	subs	r1, #8
   10362:	003a      	movs	r2, r7
   10364:	408f      	lsls	r7, r1
   10366:	408e      	lsls	r6, r1
   10368:	40da      	lsrs	r2, r3
   1036a:	46b9      	mov	r9, r7
   1036c:	4316      	orrs	r6, r2
   1036e:	4b30      	ldr	r3, [pc, #192]	; (10430 <__aeabi_ddiv+0x1ec>)
   10370:	2700      	movs	r7, #0
   10372:	469c      	mov	ip, r3
   10374:	2300      	movs	r3, #0
   10376:	4460      	add	r0, ip
   10378:	4244      	negs	r4, r0
   1037a:	9302      	str	r3, [sp, #8]
   1037c:	e785      	b.n	1028a <__aeabi_ddiv+0x46>
   1037e:	4653      	mov	r3, sl
   10380:	465a      	mov	r2, fp
   10382:	4313      	orrs	r3, r2
   10384:	d12c      	bne.n	103e0 <__aeabi_ddiv+0x19c>
   10386:	2300      	movs	r3, #0
   10388:	2100      	movs	r1, #0
   1038a:	469b      	mov	fp, r3
   1038c:	3302      	adds	r3, #2
   1038e:	e797      	b.n	102c0 <__aeabi_ddiv+0x7c>
   10390:	430b      	orrs	r3, r1
   10392:	d020      	beq.n	103d6 <__aeabi_ddiv+0x192>
   10394:	465b      	mov	r3, fp
   10396:	2b00      	cmp	r3, #0
   10398:	d100      	bne.n	1039c <__aeabi_ddiv+0x158>
   1039a:	e19e      	b.n	106da <__aeabi_ddiv+0x496>
   1039c:	4658      	mov	r0, fp
   1039e:	f001 f9db 	bl	11758 <__clzsi2>
   103a2:	0003      	movs	r3, r0
   103a4:	3b0b      	subs	r3, #11
   103a6:	2b1c      	cmp	r3, #28
   103a8:	dd00      	ble.n	103ac <__aeabi_ddiv+0x168>
   103aa:	e18f      	b.n	106cc <__aeabi_ddiv+0x488>
   103ac:	0002      	movs	r2, r0
   103ae:	4659      	mov	r1, fp
   103b0:	3a08      	subs	r2, #8
   103b2:	4091      	lsls	r1, r2
   103b4:	468b      	mov	fp, r1
   103b6:	211d      	movs	r1, #29
   103b8:	1acb      	subs	r3, r1, r3
   103ba:	4651      	mov	r1, sl
   103bc:	40d9      	lsrs	r1, r3
   103be:	000b      	movs	r3, r1
   103c0:	4659      	mov	r1, fp
   103c2:	430b      	orrs	r3, r1
   103c4:	4651      	mov	r1, sl
   103c6:	469b      	mov	fp, r3
   103c8:	4091      	lsls	r1, r2
   103ca:	4b19      	ldr	r3, [pc, #100]	; (10430 <__aeabi_ddiv+0x1ec>)
   103cc:	469c      	mov	ip, r3
   103ce:	4460      	add	r0, ip
   103d0:	4240      	negs	r0, r0
   103d2:	2300      	movs	r3, #0
   103d4:	e774      	b.n	102c0 <__aeabi_ddiv+0x7c>
   103d6:	2300      	movs	r3, #0
   103d8:	2100      	movs	r1, #0
   103da:	469b      	mov	fp, r3
   103dc:	3301      	adds	r3, #1
   103de:	e76f      	b.n	102c0 <__aeabi_ddiv+0x7c>
   103e0:	2303      	movs	r3, #3
   103e2:	e76d      	b.n	102c0 <__aeabi_ddiv+0x7c>
   103e4:	2300      	movs	r3, #0
   103e6:	4699      	mov	r9, r3
   103e8:	3301      	adds	r3, #1
   103ea:	2704      	movs	r7, #4
   103ec:	2600      	movs	r6, #0
   103ee:	9302      	str	r3, [sp, #8]
   103f0:	e74b      	b.n	1028a <__aeabi_ddiv+0x46>
   103f2:	2303      	movs	r3, #3
   103f4:	270c      	movs	r7, #12
   103f6:	9302      	str	r3, [sp, #8]
   103f8:	e747      	b.n	1028a <__aeabi_ddiv+0x46>
   103fa:	2201      	movs	r2, #1
   103fc:	1ad5      	subs	r5, r2, r3
   103fe:	2d38      	cmp	r5, #56	; 0x38
   10400:	dc00      	bgt.n	10404 <__aeabi_ddiv+0x1c0>
   10402:	e1b0      	b.n	10766 <__aeabi_ddiv+0x522>
   10404:	4653      	mov	r3, sl
   10406:	401a      	ands	r2, r3
   10408:	2100      	movs	r1, #0
   1040a:	2300      	movs	r3, #0
   1040c:	2600      	movs	r6, #0
   1040e:	4689      	mov	r9, r1
   10410:	e77e      	b.n	10310 <__aeabi_ddiv+0xcc>
   10412:	2300      	movs	r3, #0
   10414:	2680      	movs	r6, #128	; 0x80
   10416:	4699      	mov	r9, r3
   10418:	2200      	movs	r2, #0
   1041a:	0336      	lsls	r6, r6, #12
   1041c:	4b00      	ldr	r3, [pc, #0]	; (10420 <__aeabi_ddiv+0x1dc>)
   1041e:	e777      	b.n	10310 <__aeabi_ddiv+0xcc>
   10420:	000007ff 	.word	0x000007ff
   10424:	fffffc01 	.word	0xfffffc01
   10428:	0001bf78 	.word	0x0001bf78
   1042c:	800fffff 	.word	0x800fffff
   10430:	000003f3 	.word	0x000003f3
   10434:	455e      	cmp	r6, fp
   10436:	d900      	bls.n	1043a <__aeabi_ddiv+0x1f6>
   10438:	e172      	b.n	10720 <__aeabi_ddiv+0x4dc>
   1043a:	d100      	bne.n	1043e <__aeabi_ddiv+0x1fa>
   1043c:	e16d      	b.n	1071a <__aeabi_ddiv+0x4d6>
   1043e:	9b01      	ldr	r3, [sp, #4]
   10440:	464d      	mov	r5, r9
   10442:	3b01      	subs	r3, #1
   10444:	9301      	str	r3, [sp, #4]
   10446:	2300      	movs	r3, #0
   10448:	0034      	movs	r4, r6
   1044a:	9302      	str	r3, [sp, #8]
   1044c:	465b      	mov	r3, fp
   1044e:	021e      	lsls	r6, r3, #8
   10450:	0e0b      	lsrs	r3, r1, #24
   10452:	431e      	orrs	r6, r3
   10454:	020b      	lsls	r3, r1, #8
   10456:	9303      	str	r3, [sp, #12]
   10458:	0c33      	lsrs	r3, r6, #16
   1045a:	4699      	mov	r9, r3
   1045c:	0433      	lsls	r3, r6, #16
   1045e:	0c1b      	lsrs	r3, r3, #16
   10460:	4649      	mov	r1, r9
   10462:	0020      	movs	r0, r4
   10464:	9300      	str	r3, [sp, #0]
   10466:	f7ff f9e1 	bl	f82c <__aeabi_uidiv>
   1046a:	9b00      	ldr	r3, [sp, #0]
   1046c:	0037      	movs	r7, r6
   1046e:	4343      	muls	r3, r0
   10470:	0006      	movs	r6, r0
   10472:	4649      	mov	r1, r9
   10474:	0020      	movs	r0, r4
   10476:	4698      	mov	r8, r3
   10478:	f7ff fa5e 	bl	f938 <__aeabi_uidivmod>
   1047c:	0c2c      	lsrs	r4, r5, #16
   1047e:	0409      	lsls	r1, r1, #16
   10480:	430c      	orrs	r4, r1
   10482:	45a0      	cmp	r8, r4
   10484:	d909      	bls.n	1049a <__aeabi_ddiv+0x256>
   10486:	19e4      	adds	r4, r4, r7
   10488:	1e73      	subs	r3, r6, #1
   1048a:	42a7      	cmp	r7, r4
   1048c:	d900      	bls.n	10490 <__aeabi_ddiv+0x24c>
   1048e:	e15c      	b.n	1074a <__aeabi_ddiv+0x506>
   10490:	45a0      	cmp	r8, r4
   10492:	d800      	bhi.n	10496 <__aeabi_ddiv+0x252>
   10494:	e159      	b.n	1074a <__aeabi_ddiv+0x506>
   10496:	3e02      	subs	r6, #2
   10498:	19e4      	adds	r4, r4, r7
   1049a:	4643      	mov	r3, r8
   1049c:	1ae4      	subs	r4, r4, r3
   1049e:	4649      	mov	r1, r9
   104a0:	0020      	movs	r0, r4
   104a2:	f7ff f9c3 	bl	f82c <__aeabi_uidiv>
   104a6:	0003      	movs	r3, r0
   104a8:	9a00      	ldr	r2, [sp, #0]
   104aa:	4680      	mov	r8, r0
   104ac:	4353      	muls	r3, r2
   104ae:	4649      	mov	r1, r9
   104b0:	0020      	movs	r0, r4
   104b2:	469b      	mov	fp, r3
   104b4:	f7ff fa40 	bl	f938 <__aeabi_uidivmod>
   104b8:	042a      	lsls	r2, r5, #16
   104ba:	0409      	lsls	r1, r1, #16
   104bc:	0c12      	lsrs	r2, r2, #16
   104be:	430a      	orrs	r2, r1
   104c0:	4593      	cmp	fp, r2
   104c2:	d90d      	bls.n	104e0 <__aeabi_ddiv+0x29c>
   104c4:	4643      	mov	r3, r8
   104c6:	19d2      	adds	r2, r2, r7
   104c8:	3b01      	subs	r3, #1
   104ca:	4297      	cmp	r7, r2
   104cc:	d900      	bls.n	104d0 <__aeabi_ddiv+0x28c>
   104ce:	e13a      	b.n	10746 <__aeabi_ddiv+0x502>
   104d0:	4593      	cmp	fp, r2
   104d2:	d800      	bhi.n	104d6 <__aeabi_ddiv+0x292>
   104d4:	e137      	b.n	10746 <__aeabi_ddiv+0x502>
   104d6:	2302      	movs	r3, #2
   104d8:	425b      	negs	r3, r3
   104da:	469c      	mov	ip, r3
   104dc:	19d2      	adds	r2, r2, r7
   104de:	44e0      	add	r8, ip
   104e0:	465b      	mov	r3, fp
   104e2:	1ad2      	subs	r2, r2, r3
   104e4:	4643      	mov	r3, r8
   104e6:	0436      	lsls	r6, r6, #16
   104e8:	4333      	orrs	r3, r6
   104ea:	469b      	mov	fp, r3
   104ec:	9903      	ldr	r1, [sp, #12]
   104ee:	0c18      	lsrs	r0, r3, #16
   104f0:	0c0b      	lsrs	r3, r1, #16
   104f2:	001d      	movs	r5, r3
   104f4:	9305      	str	r3, [sp, #20]
   104f6:	0409      	lsls	r1, r1, #16
   104f8:	465b      	mov	r3, fp
   104fa:	0c09      	lsrs	r1, r1, #16
   104fc:	000c      	movs	r4, r1
   104fe:	041b      	lsls	r3, r3, #16
   10500:	0c1b      	lsrs	r3, r3, #16
   10502:	4344      	muls	r4, r0
   10504:	9104      	str	r1, [sp, #16]
   10506:	4359      	muls	r1, r3
   10508:	436b      	muls	r3, r5
   1050a:	4368      	muls	r0, r5
   1050c:	191b      	adds	r3, r3, r4
   1050e:	0c0d      	lsrs	r5, r1, #16
   10510:	18eb      	adds	r3, r5, r3
   10512:	429c      	cmp	r4, r3
   10514:	d903      	bls.n	1051e <__aeabi_ddiv+0x2da>
   10516:	2480      	movs	r4, #128	; 0x80
   10518:	0264      	lsls	r4, r4, #9
   1051a:	46a4      	mov	ip, r4
   1051c:	4460      	add	r0, ip
   1051e:	0c1c      	lsrs	r4, r3, #16
   10520:	0409      	lsls	r1, r1, #16
   10522:	041b      	lsls	r3, r3, #16
   10524:	0c09      	lsrs	r1, r1, #16
   10526:	1820      	adds	r0, r4, r0
   10528:	185d      	adds	r5, r3, r1
   1052a:	4282      	cmp	r2, r0
   1052c:	d200      	bcs.n	10530 <__aeabi_ddiv+0x2ec>
   1052e:	e0de      	b.n	106ee <__aeabi_ddiv+0x4aa>
   10530:	d100      	bne.n	10534 <__aeabi_ddiv+0x2f0>
   10532:	e0d7      	b.n	106e4 <__aeabi_ddiv+0x4a0>
   10534:	1a16      	subs	r6, r2, r0
   10536:	9b02      	ldr	r3, [sp, #8]
   10538:	469c      	mov	ip, r3
   1053a:	1b5d      	subs	r5, r3, r5
   1053c:	45ac      	cmp	ip, r5
   1053e:	419b      	sbcs	r3, r3
   10540:	425b      	negs	r3, r3
   10542:	1af6      	subs	r6, r6, r3
   10544:	42b7      	cmp	r7, r6
   10546:	d100      	bne.n	1054a <__aeabi_ddiv+0x306>
   10548:	e106      	b.n	10758 <__aeabi_ddiv+0x514>
   1054a:	4649      	mov	r1, r9
   1054c:	0030      	movs	r0, r6
   1054e:	f7ff f96d 	bl	f82c <__aeabi_uidiv>
   10552:	9b00      	ldr	r3, [sp, #0]
   10554:	0004      	movs	r4, r0
   10556:	4343      	muls	r3, r0
   10558:	4649      	mov	r1, r9
   1055a:	0030      	movs	r0, r6
   1055c:	4698      	mov	r8, r3
   1055e:	f7ff f9eb 	bl	f938 <__aeabi_uidivmod>
   10562:	0c2e      	lsrs	r6, r5, #16
   10564:	0409      	lsls	r1, r1, #16
   10566:	430e      	orrs	r6, r1
   10568:	45b0      	cmp	r8, r6
   1056a:	d909      	bls.n	10580 <__aeabi_ddiv+0x33c>
   1056c:	19f6      	adds	r6, r6, r7
   1056e:	1e63      	subs	r3, r4, #1
   10570:	42b7      	cmp	r7, r6
   10572:	d900      	bls.n	10576 <__aeabi_ddiv+0x332>
   10574:	e0f3      	b.n	1075e <__aeabi_ddiv+0x51a>
   10576:	45b0      	cmp	r8, r6
   10578:	d800      	bhi.n	1057c <__aeabi_ddiv+0x338>
   1057a:	e0f0      	b.n	1075e <__aeabi_ddiv+0x51a>
   1057c:	3c02      	subs	r4, #2
   1057e:	19f6      	adds	r6, r6, r7
   10580:	4643      	mov	r3, r8
   10582:	1af3      	subs	r3, r6, r3
   10584:	4649      	mov	r1, r9
   10586:	0018      	movs	r0, r3
   10588:	9302      	str	r3, [sp, #8]
   1058a:	f7ff f94f 	bl	f82c <__aeabi_uidiv>
   1058e:	9b00      	ldr	r3, [sp, #0]
   10590:	0006      	movs	r6, r0
   10592:	4343      	muls	r3, r0
   10594:	4649      	mov	r1, r9
   10596:	9802      	ldr	r0, [sp, #8]
   10598:	4698      	mov	r8, r3
   1059a:	f7ff f9cd 	bl	f938 <__aeabi_uidivmod>
   1059e:	042d      	lsls	r5, r5, #16
   105a0:	0409      	lsls	r1, r1, #16
   105a2:	0c2d      	lsrs	r5, r5, #16
   105a4:	430d      	orrs	r5, r1
   105a6:	45a8      	cmp	r8, r5
   105a8:	d909      	bls.n	105be <__aeabi_ddiv+0x37a>
   105aa:	19ed      	adds	r5, r5, r7
   105ac:	1e73      	subs	r3, r6, #1
   105ae:	42af      	cmp	r7, r5
   105b0:	d900      	bls.n	105b4 <__aeabi_ddiv+0x370>
   105b2:	e0d6      	b.n	10762 <__aeabi_ddiv+0x51e>
   105b4:	45a8      	cmp	r8, r5
   105b6:	d800      	bhi.n	105ba <__aeabi_ddiv+0x376>
   105b8:	e0d3      	b.n	10762 <__aeabi_ddiv+0x51e>
   105ba:	3e02      	subs	r6, #2
   105bc:	19ed      	adds	r5, r5, r7
   105be:	0424      	lsls	r4, r4, #16
   105c0:	0021      	movs	r1, r4
   105c2:	4643      	mov	r3, r8
   105c4:	4331      	orrs	r1, r6
   105c6:	9e04      	ldr	r6, [sp, #16]
   105c8:	9a05      	ldr	r2, [sp, #20]
   105ca:	0030      	movs	r0, r6
   105cc:	1aed      	subs	r5, r5, r3
   105ce:	040b      	lsls	r3, r1, #16
   105d0:	0c0c      	lsrs	r4, r1, #16
   105d2:	0c1b      	lsrs	r3, r3, #16
   105d4:	4358      	muls	r0, r3
   105d6:	4366      	muls	r6, r4
   105d8:	4353      	muls	r3, r2
   105da:	4354      	muls	r4, r2
   105dc:	199a      	adds	r2, r3, r6
   105de:	0c03      	lsrs	r3, r0, #16
   105e0:	189b      	adds	r3, r3, r2
   105e2:	429e      	cmp	r6, r3
   105e4:	d903      	bls.n	105ee <__aeabi_ddiv+0x3aa>
   105e6:	2280      	movs	r2, #128	; 0x80
   105e8:	0252      	lsls	r2, r2, #9
   105ea:	4694      	mov	ip, r2
   105ec:	4464      	add	r4, ip
   105ee:	0c1a      	lsrs	r2, r3, #16
   105f0:	0400      	lsls	r0, r0, #16
   105f2:	041b      	lsls	r3, r3, #16
   105f4:	0c00      	lsrs	r0, r0, #16
   105f6:	1914      	adds	r4, r2, r4
   105f8:	181b      	adds	r3, r3, r0
   105fa:	42a5      	cmp	r5, r4
   105fc:	d350      	bcc.n	106a0 <__aeabi_ddiv+0x45c>
   105fe:	d04d      	beq.n	1069c <__aeabi_ddiv+0x458>
   10600:	2301      	movs	r3, #1
   10602:	4319      	orrs	r1, r3
   10604:	4a96      	ldr	r2, [pc, #600]	; (10860 <__aeabi_ddiv+0x61c>)
   10606:	9b01      	ldr	r3, [sp, #4]
   10608:	4694      	mov	ip, r2
   1060a:	4463      	add	r3, ip
   1060c:	2b00      	cmp	r3, #0
   1060e:	dc00      	bgt.n	10612 <__aeabi_ddiv+0x3ce>
   10610:	e6f3      	b.n	103fa <__aeabi_ddiv+0x1b6>
   10612:	074a      	lsls	r2, r1, #29
   10614:	d009      	beq.n	1062a <__aeabi_ddiv+0x3e6>
   10616:	220f      	movs	r2, #15
   10618:	400a      	ands	r2, r1
   1061a:	2a04      	cmp	r2, #4
   1061c:	d005      	beq.n	1062a <__aeabi_ddiv+0x3e6>
   1061e:	1d0a      	adds	r2, r1, #4
   10620:	428a      	cmp	r2, r1
   10622:	4189      	sbcs	r1, r1
   10624:	4249      	negs	r1, r1
   10626:	448b      	add	fp, r1
   10628:	0011      	movs	r1, r2
   1062a:	465a      	mov	r2, fp
   1062c:	01d2      	lsls	r2, r2, #7
   1062e:	d508      	bpl.n	10642 <__aeabi_ddiv+0x3fe>
   10630:	465a      	mov	r2, fp
   10632:	4b8c      	ldr	r3, [pc, #560]	; (10864 <__aeabi_ddiv+0x620>)
   10634:	401a      	ands	r2, r3
   10636:	4693      	mov	fp, r2
   10638:	2280      	movs	r2, #128	; 0x80
   1063a:	00d2      	lsls	r2, r2, #3
   1063c:	4694      	mov	ip, r2
   1063e:	9b01      	ldr	r3, [sp, #4]
   10640:	4463      	add	r3, ip
   10642:	4a89      	ldr	r2, [pc, #548]	; (10868 <__aeabi_ddiv+0x624>)
   10644:	4293      	cmp	r3, r2
   10646:	dd00      	ble.n	1064a <__aeabi_ddiv+0x406>
   10648:	e65b      	b.n	10302 <__aeabi_ddiv+0xbe>
   1064a:	465a      	mov	r2, fp
   1064c:	08c9      	lsrs	r1, r1, #3
   1064e:	0750      	lsls	r0, r2, #29
   10650:	4308      	orrs	r0, r1
   10652:	0256      	lsls	r6, r2, #9
   10654:	4651      	mov	r1, sl
   10656:	2201      	movs	r2, #1
   10658:	055b      	lsls	r3, r3, #21
   1065a:	4681      	mov	r9, r0
   1065c:	0b36      	lsrs	r6, r6, #12
   1065e:	0d5b      	lsrs	r3, r3, #21
   10660:	400a      	ands	r2, r1
   10662:	e655      	b.n	10310 <__aeabi_ddiv+0xcc>
   10664:	2380      	movs	r3, #128	; 0x80
   10666:	031b      	lsls	r3, r3, #12
   10668:	421e      	tst	r6, r3
   1066a:	d011      	beq.n	10690 <__aeabi_ddiv+0x44c>
   1066c:	465a      	mov	r2, fp
   1066e:	421a      	tst	r2, r3
   10670:	d10e      	bne.n	10690 <__aeabi_ddiv+0x44c>
   10672:	465e      	mov	r6, fp
   10674:	431e      	orrs	r6, r3
   10676:	0336      	lsls	r6, r6, #12
   10678:	0b36      	lsrs	r6, r6, #12
   1067a:	002a      	movs	r2, r5
   1067c:	4689      	mov	r9, r1
   1067e:	4b7b      	ldr	r3, [pc, #492]	; (1086c <__aeabi_ddiv+0x628>)
   10680:	e646      	b.n	10310 <__aeabi_ddiv+0xcc>
   10682:	2b03      	cmp	r3, #3
   10684:	d100      	bne.n	10688 <__aeabi_ddiv+0x444>
   10686:	e0e1      	b.n	1084c <__aeabi_ddiv+0x608>
   10688:	2b01      	cmp	r3, #1
   1068a:	d1bb      	bne.n	10604 <__aeabi_ddiv+0x3c0>
   1068c:	401a      	ands	r2, r3
   1068e:	e6bb      	b.n	10408 <__aeabi_ddiv+0x1c4>
   10690:	431e      	orrs	r6, r3
   10692:	0336      	lsls	r6, r6, #12
   10694:	0b36      	lsrs	r6, r6, #12
   10696:	4642      	mov	r2, r8
   10698:	4b74      	ldr	r3, [pc, #464]	; (1086c <__aeabi_ddiv+0x628>)
   1069a:	e639      	b.n	10310 <__aeabi_ddiv+0xcc>
   1069c:	2b00      	cmp	r3, #0
   1069e:	d0b1      	beq.n	10604 <__aeabi_ddiv+0x3c0>
   106a0:	197d      	adds	r5, r7, r5
   106a2:	1e4a      	subs	r2, r1, #1
   106a4:	42af      	cmp	r7, r5
   106a6:	d952      	bls.n	1074e <__aeabi_ddiv+0x50a>
   106a8:	0011      	movs	r1, r2
   106aa:	42a5      	cmp	r5, r4
   106ac:	d1a8      	bne.n	10600 <__aeabi_ddiv+0x3bc>
   106ae:	9a03      	ldr	r2, [sp, #12]
   106b0:	429a      	cmp	r2, r3
   106b2:	d1a5      	bne.n	10600 <__aeabi_ddiv+0x3bc>
   106b4:	e7a6      	b.n	10604 <__aeabi_ddiv+0x3c0>
   106b6:	0003      	movs	r3, r0
   106b8:	003e      	movs	r6, r7
   106ba:	3b28      	subs	r3, #40	; 0x28
   106bc:	409e      	lsls	r6, r3
   106be:	2300      	movs	r3, #0
   106c0:	4699      	mov	r9, r3
   106c2:	e654      	b.n	1036e <__aeabi_ddiv+0x12a>
   106c4:	f001 f848 	bl	11758 <__clzsi2>
   106c8:	3020      	adds	r0, #32
   106ca:	e641      	b.n	10350 <__aeabi_ddiv+0x10c>
   106cc:	0003      	movs	r3, r0
   106ce:	4652      	mov	r2, sl
   106d0:	3b28      	subs	r3, #40	; 0x28
   106d2:	409a      	lsls	r2, r3
   106d4:	2100      	movs	r1, #0
   106d6:	4693      	mov	fp, r2
   106d8:	e677      	b.n	103ca <__aeabi_ddiv+0x186>
   106da:	4650      	mov	r0, sl
   106dc:	f001 f83c 	bl	11758 <__clzsi2>
   106e0:	3020      	adds	r0, #32
   106e2:	e65e      	b.n	103a2 <__aeabi_ddiv+0x15e>
   106e4:	9b02      	ldr	r3, [sp, #8]
   106e6:	2600      	movs	r6, #0
   106e8:	42ab      	cmp	r3, r5
   106ea:	d300      	bcc.n	106ee <__aeabi_ddiv+0x4aa>
   106ec:	e723      	b.n	10536 <__aeabi_ddiv+0x2f2>
   106ee:	9e03      	ldr	r6, [sp, #12]
   106f0:	9902      	ldr	r1, [sp, #8]
   106f2:	46b4      	mov	ip, r6
   106f4:	4461      	add	r1, ip
   106f6:	4688      	mov	r8, r1
   106f8:	45b0      	cmp	r8, r6
   106fa:	41b6      	sbcs	r6, r6
   106fc:	465b      	mov	r3, fp
   106fe:	4276      	negs	r6, r6
   10700:	19f6      	adds	r6, r6, r7
   10702:	18b2      	adds	r2, r6, r2
   10704:	3b01      	subs	r3, #1
   10706:	9102      	str	r1, [sp, #8]
   10708:	4297      	cmp	r7, r2
   1070a:	d213      	bcs.n	10734 <__aeabi_ddiv+0x4f0>
   1070c:	4290      	cmp	r0, r2
   1070e:	d84f      	bhi.n	107b0 <__aeabi_ddiv+0x56c>
   10710:	d100      	bne.n	10714 <__aeabi_ddiv+0x4d0>
   10712:	e08e      	b.n	10832 <__aeabi_ddiv+0x5ee>
   10714:	1a16      	subs	r6, r2, r0
   10716:	469b      	mov	fp, r3
   10718:	e70d      	b.n	10536 <__aeabi_ddiv+0x2f2>
   1071a:	4589      	cmp	r9, r1
   1071c:	d200      	bcs.n	10720 <__aeabi_ddiv+0x4dc>
   1071e:	e68e      	b.n	1043e <__aeabi_ddiv+0x1fa>
   10720:	0874      	lsrs	r4, r6, #1
   10722:	464b      	mov	r3, r9
   10724:	07f6      	lsls	r6, r6, #31
   10726:	0035      	movs	r5, r6
   10728:	085b      	lsrs	r3, r3, #1
   1072a:	431d      	orrs	r5, r3
   1072c:	464b      	mov	r3, r9
   1072e:	07db      	lsls	r3, r3, #31
   10730:	9302      	str	r3, [sp, #8]
   10732:	e68b      	b.n	1044c <__aeabi_ddiv+0x208>
   10734:	4297      	cmp	r7, r2
   10736:	d1ed      	bne.n	10714 <__aeabi_ddiv+0x4d0>
   10738:	9903      	ldr	r1, [sp, #12]
   1073a:	9c02      	ldr	r4, [sp, #8]
   1073c:	42a1      	cmp	r1, r4
   1073e:	d9e5      	bls.n	1070c <__aeabi_ddiv+0x4c8>
   10740:	1a3e      	subs	r6, r7, r0
   10742:	469b      	mov	fp, r3
   10744:	e6f7      	b.n	10536 <__aeabi_ddiv+0x2f2>
   10746:	4698      	mov	r8, r3
   10748:	e6ca      	b.n	104e0 <__aeabi_ddiv+0x29c>
   1074a:	001e      	movs	r6, r3
   1074c:	e6a5      	b.n	1049a <__aeabi_ddiv+0x256>
   1074e:	42ac      	cmp	r4, r5
   10750:	d83e      	bhi.n	107d0 <__aeabi_ddiv+0x58c>
   10752:	d074      	beq.n	1083e <__aeabi_ddiv+0x5fa>
   10754:	0011      	movs	r1, r2
   10756:	e753      	b.n	10600 <__aeabi_ddiv+0x3bc>
   10758:	2101      	movs	r1, #1
   1075a:	4249      	negs	r1, r1
   1075c:	e752      	b.n	10604 <__aeabi_ddiv+0x3c0>
   1075e:	001c      	movs	r4, r3
   10760:	e70e      	b.n	10580 <__aeabi_ddiv+0x33c>
   10762:	001e      	movs	r6, r3
   10764:	e72b      	b.n	105be <__aeabi_ddiv+0x37a>
   10766:	2d1f      	cmp	r5, #31
   10768:	dc3c      	bgt.n	107e4 <__aeabi_ddiv+0x5a0>
   1076a:	2320      	movs	r3, #32
   1076c:	000a      	movs	r2, r1
   1076e:	4658      	mov	r0, fp
   10770:	1b5b      	subs	r3, r3, r5
   10772:	4098      	lsls	r0, r3
   10774:	40ea      	lsrs	r2, r5
   10776:	4099      	lsls	r1, r3
   10778:	4302      	orrs	r2, r0
   1077a:	1e48      	subs	r0, r1, #1
   1077c:	4181      	sbcs	r1, r0
   1077e:	465e      	mov	r6, fp
   10780:	4311      	orrs	r1, r2
   10782:	40ee      	lsrs	r6, r5
   10784:	074b      	lsls	r3, r1, #29
   10786:	d009      	beq.n	1079c <__aeabi_ddiv+0x558>
   10788:	230f      	movs	r3, #15
   1078a:	400b      	ands	r3, r1
   1078c:	2b04      	cmp	r3, #4
   1078e:	d005      	beq.n	1079c <__aeabi_ddiv+0x558>
   10790:	000b      	movs	r3, r1
   10792:	1d19      	adds	r1, r3, #4
   10794:	4299      	cmp	r1, r3
   10796:	419b      	sbcs	r3, r3
   10798:	425b      	negs	r3, r3
   1079a:	18f6      	adds	r6, r6, r3
   1079c:	0233      	lsls	r3, r6, #8
   1079e:	d53c      	bpl.n	1081a <__aeabi_ddiv+0x5d6>
   107a0:	4653      	mov	r3, sl
   107a2:	2201      	movs	r2, #1
   107a4:	2100      	movs	r1, #0
   107a6:	401a      	ands	r2, r3
   107a8:	2600      	movs	r6, #0
   107aa:	2301      	movs	r3, #1
   107ac:	4689      	mov	r9, r1
   107ae:	e5af      	b.n	10310 <__aeabi_ddiv+0xcc>
   107b0:	2302      	movs	r3, #2
   107b2:	425b      	negs	r3, r3
   107b4:	469c      	mov	ip, r3
   107b6:	9c03      	ldr	r4, [sp, #12]
   107b8:	44e3      	add	fp, ip
   107ba:	46a4      	mov	ip, r4
   107bc:	9b02      	ldr	r3, [sp, #8]
   107be:	4463      	add	r3, ip
   107c0:	4698      	mov	r8, r3
   107c2:	45a0      	cmp	r8, r4
   107c4:	41b6      	sbcs	r6, r6
   107c6:	4276      	negs	r6, r6
   107c8:	19f6      	adds	r6, r6, r7
   107ca:	9302      	str	r3, [sp, #8]
   107cc:	18b2      	adds	r2, r6, r2
   107ce:	e6b1      	b.n	10534 <__aeabi_ddiv+0x2f0>
   107d0:	9803      	ldr	r0, [sp, #12]
   107d2:	1e8a      	subs	r2, r1, #2
   107d4:	0041      	lsls	r1, r0, #1
   107d6:	4281      	cmp	r1, r0
   107d8:	41b6      	sbcs	r6, r6
   107da:	4276      	negs	r6, r6
   107dc:	19f6      	adds	r6, r6, r7
   107de:	19ad      	adds	r5, r5, r6
   107e0:	9103      	str	r1, [sp, #12]
   107e2:	e761      	b.n	106a8 <__aeabi_ddiv+0x464>
   107e4:	221f      	movs	r2, #31
   107e6:	4252      	negs	r2, r2
   107e8:	1ad3      	subs	r3, r2, r3
   107ea:	465a      	mov	r2, fp
   107ec:	40da      	lsrs	r2, r3
   107ee:	0013      	movs	r3, r2
   107f0:	2d20      	cmp	r5, #32
   107f2:	d029      	beq.n	10848 <__aeabi_ddiv+0x604>
   107f4:	2240      	movs	r2, #64	; 0x40
   107f6:	4658      	mov	r0, fp
   107f8:	1b55      	subs	r5, r2, r5
   107fa:	40a8      	lsls	r0, r5
   107fc:	4301      	orrs	r1, r0
   107fe:	1e48      	subs	r0, r1, #1
   10800:	4181      	sbcs	r1, r0
   10802:	2007      	movs	r0, #7
   10804:	430b      	orrs	r3, r1
   10806:	4018      	ands	r0, r3
   10808:	2600      	movs	r6, #0
   1080a:	2800      	cmp	r0, #0
   1080c:	d009      	beq.n	10822 <__aeabi_ddiv+0x5de>
   1080e:	220f      	movs	r2, #15
   10810:	2600      	movs	r6, #0
   10812:	401a      	ands	r2, r3
   10814:	0019      	movs	r1, r3
   10816:	2a04      	cmp	r2, #4
   10818:	d1bb      	bne.n	10792 <__aeabi_ddiv+0x54e>
   1081a:	000b      	movs	r3, r1
   1081c:	0770      	lsls	r0, r6, #29
   1081e:	0276      	lsls	r6, r6, #9
   10820:	0b36      	lsrs	r6, r6, #12
   10822:	08db      	lsrs	r3, r3, #3
   10824:	4303      	orrs	r3, r0
   10826:	4699      	mov	r9, r3
   10828:	2201      	movs	r2, #1
   1082a:	4653      	mov	r3, sl
   1082c:	401a      	ands	r2, r3
   1082e:	2300      	movs	r3, #0
   10830:	e56e      	b.n	10310 <__aeabi_ddiv+0xcc>
   10832:	9902      	ldr	r1, [sp, #8]
   10834:	428d      	cmp	r5, r1
   10836:	d8bb      	bhi.n	107b0 <__aeabi_ddiv+0x56c>
   10838:	469b      	mov	fp, r3
   1083a:	2600      	movs	r6, #0
   1083c:	e67b      	b.n	10536 <__aeabi_ddiv+0x2f2>
   1083e:	9803      	ldr	r0, [sp, #12]
   10840:	4298      	cmp	r0, r3
   10842:	d3c5      	bcc.n	107d0 <__aeabi_ddiv+0x58c>
   10844:	0011      	movs	r1, r2
   10846:	e732      	b.n	106ae <__aeabi_ddiv+0x46a>
   10848:	2000      	movs	r0, #0
   1084a:	e7d7      	b.n	107fc <__aeabi_ddiv+0x5b8>
   1084c:	2680      	movs	r6, #128	; 0x80
   1084e:	465b      	mov	r3, fp
   10850:	0336      	lsls	r6, r6, #12
   10852:	431e      	orrs	r6, r3
   10854:	0336      	lsls	r6, r6, #12
   10856:	0b36      	lsrs	r6, r6, #12
   10858:	9a00      	ldr	r2, [sp, #0]
   1085a:	4689      	mov	r9, r1
   1085c:	4b03      	ldr	r3, [pc, #12]	; (1086c <__aeabi_ddiv+0x628>)
   1085e:	e557      	b.n	10310 <__aeabi_ddiv+0xcc>
   10860:	000003ff 	.word	0x000003ff
   10864:	feffffff 	.word	0xfeffffff
   10868:	000007fe 	.word	0x000007fe
   1086c:	000007ff 	.word	0x000007ff

00010870 <__eqdf2>:
   10870:	b5f0      	push	{r4, r5, r6, r7, lr}
   10872:	465f      	mov	r7, fp
   10874:	4656      	mov	r6, sl
   10876:	464d      	mov	r5, r9
   10878:	4644      	mov	r4, r8
   1087a:	b4f0      	push	{r4, r5, r6, r7}
   1087c:	031f      	lsls	r7, r3, #12
   1087e:	005c      	lsls	r4, r3, #1
   10880:	0fdb      	lsrs	r3, r3, #31
   10882:	469a      	mov	sl, r3
   10884:	4b19      	ldr	r3, [pc, #100]	; (108ec <__eqdf2+0x7c>)
   10886:	030e      	lsls	r6, r1, #12
   10888:	004d      	lsls	r5, r1, #1
   1088a:	0fc9      	lsrs	r1, r1, #31
   1088c:	4680      	mov	r8, r0
   1088e:	0b36      	lsrs	r6, r6, #12
   10890:	0d6d      	lsrs	r5, r5, #21
   10892:	468b      	mov	fp, r1
   10894:	4691      	mov	r9, r2
   10896:	0b3f      	lsrs	r7, r7, #12
   10898:	0d64      	lsrs	r4, r4, #21
   1089a:	429d      	cmp	r5, r3
   1089c:	d019      	beq.n	108d2 <__eqdf2+0x62>
   1089e:	4b13      	ldr	r3, [pc, #76]	; (108ec <__eqdf2+0x7c>)
   108a0:	429c      	cmp	r4, r3
   108a2:	d01b      	beq.n	108dc <__eqdf2+0x6c>
   108a4:	2301      	movs	r3, #1
   108a6:	42a5      	cmp	r5, r4
   108a8:	d006      	beq.n	108b8 <__eqdf2+0x48>
   108aa:	0018      	movs	r0, r3
   108ac:	bc3c      	pop	{r2, r3, r4, r5}
   108ae:	4690      	mov	r8, r2
   108b0:	4699      	mov	r9, r3
   108b2:	46a2      	mov	sl, r4
   108b4:	46ab      	mov	fp, r5
   108b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   108b8:	42be      	cmp	r6, r7
   108ba:	d1f6      	bne.n	108aa <__eqdf2+0x3a>
   108bc:	45c8      	cmp	r8, r9
   108be:	d1f4      	bne.n	108aa <__eqdf2+0x3a>
   108c0:	45d3      	cmp	fp, sl
   108c2:	d010      	beq.n	108e6 <__eqdf2+0x76>
   108c4:	2d00      	cmp	r5, #0
   108c6:	d1f0      	bne.n	108aa <__eqdf2+0x3a>
   108c8:	4330      	orrs	r0, r6
   108ca:	0003      	movs	r3, r0
   108cc:	1e5a      	subs	r2, r3, #1
   108ce:	4193      	sbcs	r3, r2
   108d0:	e7eb      	b.n	108aa <__eqdf2+0x3a>
   108d2:	0031      	movs	r1, r6
   108d4:	2301      	movs	r3, #1
   108d6:	4301      	orrs	r1, r0
   108d8:	d1e7      	bne.n	108aa <__eqdf2+0x3a>
   108da:	e7e0      	b.n	1089e <__eqdf2+0x2e>
   108dc:	433a      	orrs	r2, r7
   108de:	2301      	movs	r3, #1
   108e0:	2a00      	cmp	r2, #0
   108e2:	d1e2      	bne.n	108aa <__eqdf2+0x3a>
   108e4:	e7de      	b.n	108a4 <__eqdf2+0x34>
   108e6:	2300      	movs	r3, #0
   108e8:	e7df      	b.n	108aa <__eqdf2+0x3a>
   108ea:	46c0      	nop			; (mov r8, r8)
   108ec:	000007ff 	.word	0x000007ff

000108f0 <__gedf2>:
   108f0:	b5f0      	push	{r4, r5, r6, r7, lr}
   108f2:	465f      	mov	r7, fp
   108f4:	4644      	mov	r4, r8
   108f6:	4656      	mov	r6, sl
   108f8:	464d      	mov	r5, r9
   108fa:	b4f0      	push	{r4, r5, r6, r7}
   108fc:	031f      	lsls	r7, r3, #12
   108fe:	0b3c      	lsrs	r4, r7, #12
   10900:	4f2c      	ldr	r7, [pc, #176]	; (109b4 <__gedf2+0xc4>)
   10902:	030e      	lsls	r6, r1, #12
   10904:	004d      	lsls	r5, r1, #1
   10906:	46a3      	mov	fp, r4
   10908:	005c      	lsls	r4, r3, #1
   1090a:	4684      	mov	ip, r0
   1090c:	0b36      	lsrs	r6, r6, #12
   1090e:	0d6d      	lsrs	r5, r5, #21
   10910:	0fc9      	lsrs	r1, r1, #31
   10912:	4690      	mov	r8, r2
   10914:	0d64      	lsrs	r4, r4, #21
   10916:	0fdb      	lsrs	r3, r3, #31
   10918:	42bd      	cmp	r5, r7
   1091a:	d02b      	beq.n	10974 <__gedf2+0x84>
   1091c:	4f25      	ldr	r7, [pc, #148]	; (109b4 <__gedf2+0xc4>)
   1091e:	42bc      	cmp	r4, r7
   10920:	d02e      	beq.n	10980 <__gedf2+0x90>
   10922:	2d00      	cmp	r5, #0
   10924:	d10e      	bne.n	10944 <__gedf2+0x54>
   10926:	4330      	orrs	r0, r6
   10928:	0007      	movs	r7, r0
   1092a:	4681      	mov	r9, r0
   1092c:	4278      	negs	r0, r7
   1092e:	4178      	adcs	r0, r7
   10930:	2c00      	cmp	r4, #0
   10932:	d117      	bne.n	10964 <__gedf2+0x74>
   10934:	465f      	mov	r7, fp
   10936:	433a      	orrs	r2, r7
   10938:	d114      	bne.n	10964 <__gedf2+0x74>
   1093a:	464b      	mov	r3, r9
   1093c:	2000      	movs	r0, #0
   1093e:	2b00      	cmp	r3, #0
   10940:	d00a      	beq.n	10958 <__gedf2+0x68>
   10942:	e006      	b.n	10952 <__gedf2+0x62>
   10944:	2c00      	cmp	r4, #0
   10946:	d102      	bne.n	1094e <__gedf2+0x5e>
   10948:	4658      	mov	r0, fp
   1094a:	4302      	orrs	r2, r0
   1094c:	d001      	beq.n	10952 <__gedf2+0x62>
   1094e:	4299      	cmp	r1, r3
   10950:	d01a      	beq.n	10988 <__gedf2+0x98>
   10952:	2301      	movs	r3, #1
   10954:	4248      	negs	r0, r1
   10956:	4318      	orrs	r0, r3
   10958:	bc3c      	pop	{r2, r3, r4, r5}
   1095a:	4690      	mov	r8, r2
   1095c:	4699      	mov	r9, r3
   1095e:	46a2      	mov	sl, r4
   10960:	46ab      	mov	fp, r5
   10962:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10964:	2800      	cmp	r0, #0
   10966:	d0f2      	beq.n	1094e <__gedf2+0x5e>
   10968:	4258      	negs	r0, r3
   1096a:	4158      	adcs	r0, r3
   1096c:	2201      	movs	r2, #1
   1096e:	4240      	negs	r0, r0
   10970:	4310      	orrs	r0, r2
   10972:	e7f1      	b.n	10958 <__gedf2+0x68>
   10974:	0037      	movs	r7, r6
   10976:	4307      	orrs	r7, r0
   10978:	d0d0      	beq.n	1091c <__gedf2+0x2c>
   1097a:	2002      	movs	r0, #2
   1097c:	4240      	negs	r0, r0
   1097e:	e7eb      	b.n	10958 <__gedf2+0x68>
   10980:	465f      	mov	r7, fp
   10982:	4317      	orrs	r7, r2
   10984:	d0cd      	beq.n	10922 <__gedf2+0x32>
   10986:	e7f8      	b.n	1097a <__gedf2+0x8a>
   10988:	42a5      	cmp	r5, r4
   1098a:	dce2      	bgt.n	10952 <__gedf2+0x62>
   1098c:	db05      	blt.n	1099a <__gedf2+0xaa>
   1098e:	455e      	cmp	r6, fp
   10990:	d8df      	bhi.n	10952 <__gedf2+0x62>
   10992:	d008      	beq.n	109a6 <__gedf2+0xb6>
   10994:	2000      	movs	r0, #0
   10996:	455e      	cmp	r6, fp
   10998:	d2de      	bcs.n	10958 <__gedf2+0x68>
   1099a:	4248      	negs	r0, r1
   1099c:	4148      	adcs	r0, r1
   1099e:	2301      	movs	r3, #1
   109a0:	4240      	negs	r0, r0
   109a2:	4318      	orrs	r0, r3
   109a4:	e7d8      	b.n	10958 <__gedf2+0x68>
   109a6:	45c4      	cmp	ip, r8
   109a8:	d8d3      	bhi.n	10952 <__gedf2+0x62>
   109aa:	2000      	movs	r0, #0
   109ac:	45c4      	cmp	ip, r8
   109ae:	d3f4      	bcc.n	1099a <__gedf2+0xaa>
   109b0:	e7d2      	b.n	10958 <__gedf2+0x68>
   109b2:	46c0      	nop			; (mov r8, r8)
   109b4:	000007ff 	.word	0x000007ff

000109b8 <__ledf2>:
   109b8:	b5f0      	push	{r4, r5, r6, r7, lr}
   109ba:	465f      	mov	r7, fp
   109bc:	464d      	mov	r5, r9
   109be:	4644      	mov	r4, r8
   109c0:	4656      	mov	r6, sl
   109c2:	b4f0      	push	{r4, r5, r6, r7}
   109c4:	031c      	lsls	r4, r3, #12
   109c6:	0b24      	lsrs	r4, r4, #12
   109c8:	46a4      	mov	ip, r4
   109ca:	4c2f      	ldr	r4, [pc, #188]	; (10a88 <__ledf2+0xd0>)
   109cc:	030f      	lsls	r7, r1, #12
   109ce:	004d      	lsls	r5, r1, #1
   109d0:	005e      	lsls	r6, r3, #1
   109d2:	0fc9      	lsrs	r1, r1, #31
   109d4:	4680      	mov	r8, r0
   109d6:	0b3f      	lsrs	r7, r7, #12
   109d8:	0d6d      	lsrs	r5, r5, #21
   109da:	468b      	mov	fp, r1
   109dc:	4691      	mov	r9, r2
   109de:	0d76      	lsrs	r6, r6, #21
   109e0:	0fdb      	lsrs	r3, r3, #31
   109e2:	42a5      	cmp	r5, r4
   109e4:	d020      	beq.n	10a28 <__ledf2+0x70>
   109e6:	4c28      	ldr	r4, [pc, #160]	; (10a88 <__ledf2+0xd0>)
   109e8:	42a6      	cmp	r6, r4
   109ea:	d022      	beq.n	10a32 <__ledf2+0x7a>
   109ec:	2d00      	cmp	r5, #0
   109ee:	d112      	bne.n	10a16 <__ledf2+0x5e>
   109f0:	4338      	orrs	r0, r7
   109f2:	4244      	negs	r4, r0
   109f4:	4144      	adcs	r4, r0
   109f6:	2e00      	cmp	r6, #0
   109f8:	d020      	beq.n	10a3c <__ledf2+0x84>
   109fa:	2c00      	cmp	r4, #0
   109fc:	d00d      	beq.n	10a1a <__ledf2+0x62>
   109fe:	425c      	negs	r4, r3
   10a00:	4163      	adcs	r3, r4
   10a02:	2401      	movs	r4, #1
   10a04:	425b      	negs	r3, r3
   10a06:	431c      	orrs	r4, r3
   10a08:	0020      	movs	r0, r4
   10a0a:	bc3c      	pop	{r2, r3, r4, r5}
   10a0c:	4690      	mov	r8, r2
   10a0e:	4699      	mov	r9, r3
   10a10:	46a2      	mov	sl, r4
   10a12:	46ab      	mov	fp, r5
   10a14:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10a16:	2e00      	cmp	r6, #0
   10a18:	d017      	beq.n	10a4a <__ledf2+0x92>
   10a1a:	455b      	cmp	r3, fp
   10a1c:	d019      	beq.n	10a52 <__ledf2+0x9a>
   10a1e:	465b      	mov	r3, fp
   10a20:	425c      	negs	r4, r3
   10a22:	2301      	movs	r3, #1
   10a24:	431c      	orrs	r4, r3
   10a26:	e7ef      	b.n	10a08 <__ledf2+0x50>
   10a28:	0039      	movs	r1, r7
   10a2a:	2402      	movs	r4, #2
   10a2c:	4301      	orrs	r1, r0
   10a2e:	d1eb      	bne.n	10a08 <__ledf2+0x50>
   10a30:	e7d9      	b.n	109e6 <__ledf2+0x2e>
   10a32:	4661      	mov	r1, ip
   10a34:	2402      	movs	r4, #2
   10a36:	4311      	orrs	r1, r2
   10a38:	d1e6      	bne.n	10a08 <__ledf2+0x50>
   10a3a:	e7d7      	b.n	109ec <__ledf2+0x34>
   10a3c:	4661      	mov	r1, ip
   10a3e:	430a      	orrs	r2, r1
   10a40:	d1db      	bne.n	109fa <__ledf2+0x42>
   10a42:	2400      	movs	r4, #0
   10a44:	2800      	cmp	r0, #0
   10a46:	d0df      	beq.n	10a08 <__ledf2+0x50>
   10a48:	e7e9      	b.n	10a1e <__ledf2+0x66>
   10a4a:	4661      	mov	r1, ip
   10a4c:	430a      	orrs	r2, r1
   10a4e:	d1e4      	bne.n	10a1a <__ledf2+0x62>
   10a50:	e7e5      	b.n	10a1e <__ledf2+0x66>
   10a52:	42b5      	cmp	r5, r6
   10a54:	dd03      	ble.n	10a5e <__ledf2+0xa6>
   10a56:	2201      	movs	r2, #1
   10a58:	425c      	negs	r4, r3
   10a5a:	4314      	orrs	r4, r2
   10a5c:	e7d4      	b.n	10a08 <__ledf2+0x50>
   10a5e:	42b5      	cmp	r5, r6
   10a60:	dbcd      	blt.n	109fe <__ledf2+0x46>
   10a62:	4567      	cmp	r7, ip
   10a64:	d8db      	bhi.n	10a1e <__ledf2+0x66>
   10a66:	d009      	beq.n	10a7c <__ledf2+0xc4>
   10a68:	2400      	movs	r4, #0
   10a6a:	4567      	cmp	r7, ip
   10a6c:	d2cc      	bcs.n	10a08 <__ledf2+0x50>
   10a6e:	4659      	mov	r1, fp
   10a70:	424c      	negs	r4, r1
   10a72:	4161      	adcs	r1, r4
   10a74:	2401      	movs	r4, #1
   10a76:	4249      	negs	r1, r1
   10a78:	430c      	orrs	r4, r1
   10a7a:	e7c5      	b.n	10a08 <__ledf2+0x50>
   10a7c:	45c8      	cmp	r8, r9
   10a7e:	d8ce      	bhi.n	10a1e <__ledf2+0x66>
   10a80:	2400      	movs	r4, #0
   10a82:	45c8      	cmp	r8, r9
   10a84:	d3f3      	bcc.n	10a6e <__ledf2+0xb6>
   10a86:	e7bf      	b.n	10a08 <__ledf2+0x50>
   10a88:	000007ff 	.word	0x000007ff

00010a8c <__aeabi_dmul>:
   10a8c:	b5f0      	push	{r4, r5, r6, r7, lr}
   10a8e:	465f      	mov	r7, fp
   10a90:	4656      	mov	r6, sl
   10a92:	464d      	mov	r5, r9
   10a94:	4644      	mov	r4, r8
   10a96:	b4f0      	push	{r4, r5, r6, r7}
   10a98:	030d      	lsls	r5, r1, #12
   10a9a:	4699      	mov	r9, r3
   10a9c:	004e      	lsls	r6, r1, #1
   10a9e:	0b2b      	lsrs	r3, r5, #12
   10aa0:	b087      	sub	sp, #28
   10aa2:	0007      	movs	r7, r0
   10aa4:	4692      	mov	sl, r2
   10aa6:	4680      	mov	r8, r0
   10aa8:	469b      	mov	fp, r3
   10aaa:	0d76      	lsrs	r6, r6, #21
   10aac:	0fcc      	lsrs	r4, r1, #31
   10aae:	2e00      	cmp	r6, #0
   10ab0:	d069      	beq.n	10b86 <__aeabi_dmul+0xfa>
   10ab2:	4b6d      	ldr	r3, [pc, #436]	; (10c68 <__aeabi_dmul+0x1dc>)
   10ab4:	429e      	cmp	r6, r3
   10ab6:	d035      	beq.n	10b24 <__aeabi_dmul+0x98>
   10ab8:	465b      	mov	r3, fp
   10aba:	2280      	movs	r2, #128	; 0x80
   10abc:	00dd      	lsls	r5, r3, #3
   10abe:	0412      	lsls	r2, r2, #16
   10ac0:	0f43      	lsrs	r3, r0, #29
   10ac2:	4313      	orrs	r3, r2
   10ac4:	432b      	orrs	r3, r5
   10ac6:	469b      	mov	fp, r3
   10ac8:	00c3      	lsls	r3, r0, #3
   10aca:	4698      	mov	r8, r3
   10acc:	4b67      	ldr	r3, [pc, #412]	; (10c6c <__aeabi_dmul+0x1e0>)
   10ace:	2700      	movs	r7, #0
   10ad0:	469c      	mov	ip, r3
   10ad2:	2300      	movs	r3, #0
   10ad4:	4466      	add	r6, ip
   10ad6:	9301      	str	r3, [sp, #4]
   10ad8:	464a      	mov	r2, r9
   10ada:	0315      	lsls	r5, r2, #12
   10adc:	0050      	lsls	r0, r2, #1
   10ade:	0fd2      	lsrs	r2, r2, #31
   10ae0:	4653      	mov	r3, sl
   10ae2:	0b2d      	lsrs	r5, r5, #12
   10ae4:	0d40      	lsrs	r0, r0, #21
   10ae6:	4691      	mov	r9, r2
   10ae8:	d100      	bne.n	10aec <__aeabi_dmul+0x60>
   10aea:	e076      	b.n	10bda <__aeabi_dmul+0x14e>
   10aec:	4a5e      	ldr	r2, [pc, #376]	; (10c68 <__aeabi_dmul+0x1dc>)
   10aee:	4290      	cmp	r0, r2
   10af0:	d06c      	beq.n	10bcc <__aeabi_dmul+0x140>
   10af2:	2280      	movs	r2, #128	; 0x80
   10af4:	0f5b      	lsrs	r3, r3, #29
   10af6:	0412      	lsls	r2, r2, #16
   10af8:	4313      	orrs	r3, r2
   10afa:	4a5c      	ldr	r2, [pc, #368]	; (10c6c <__aeabi_dmul+0x1e0>)
   10afc:	00ed      	lsls	r5, r5, #3
   10afe:	4694      	mov	ip, r2
   10b00:	431d      	orrs	r5, r3
   10b02:	4653      	mov	r3, sl
   10b04:	2200      	movs	r2, #0
   10b06:	00db      	lsls	r3, r3, #3
   10b08:	4460      	add	r0, ip
   10b0a:	4649      	mov	r1, r9
   10b0c:	1836      	adds	r6, r6, r0
   10b0e:	1c70      	adds	r0, r6, #1
   10b10:	4061      	eors	r1, r4
   10b12:	9002      	str	r0, [sp, #8]
   10b14:	4317      	orrs	r7, r2
   10b16:	2f0f      	cmp	r7, #15
   10b18:	d900      	bls.n	10b1c <__aeabi_dmul+0x90>
   10b1a:	e0af      	b.n	10c7c <__aeabi_dmul+0x1f0>
   10b1c:	4854      	ldr	r0, [pc, #336]	; (10c70 <__aeabi_dmul+0x1e4>)
   10b1e:	00bf      	lsls	r7, r7, #2
   10b20:	59c7      	ldr	r7, [r0, r7]
   10b22:	46bf      	mov	pc, r7
   10b24:	465b      	mov	r3, fp
   10b26:	431f      	orrs	r7, r3
   10b28:	d000      	beq.n	10b2c <__aeabi_dmul+0xa0>
   10b2a:	e088      	b.n	10c3e <__aeabi_dmul+0x1b2>
   10b2c:	2300      	movs	r3, #0
   10b2e:	469b      	mov	fp, r3
   10b30:	4698      	mov	r8, r3
   10b32:	3302      	adds	r3, #2
   10b34:	2708      	movs	r7, #8
   10b36:	9301      	str	r3, [sp, #4]
   10b38:	e7ce      	b.n	10ad8 <__aeabi_dmul+0x4c>
   10b3a:	4649      	mov	r1, r9
   10b3c:	2a02      	cmp	r2, #2
   10b3e:	d06a      	beq.n	10c16 <__aeabi_dmul+0x18a>
   10b40:	2a03      	cmp	r2, #3
   10b42:	d100      	bne.n	10b46 <__aeabi_dmul+0xba>
   10b44:	e209      	b.n	10f5a <__aeabi_dmul+0x4ce>
   10b46:	2a01      	cmp	r2, #1
   10b48:	d000      	beq.n	10b4c <__aeabi_dmul+0xc0>
   10b4a:	e1bb      	b.n	10ec4 <__aeabi_dmul+0x438>
   10b4c:	4011      	ands	r1, r2
   10b4e:	2200      	movs	r2, #0
   10b50:	2300      	movs	r3, #0
   10b52:	2500      	movs	r5, #0
   10b54:	4690      	mov	r8, r2
   10b56:	b2cc      	uxtb	r4, r1
   10b58:	2100      	movs	r1, #0
   10b5a:	032d      	lsls	r5, r5, #12
   10b5c:	0d0a      	lsrs	r2, r1, #20
   10b5e:	0512      	lsls	r2, r2, #20
   10b60:	0b2d      	lsrs	r5, r5, #12
   10b62:	4315      	orrs	r5, r2
   10b64:	4a43      	ldr	r2, [pc, #268]	; (10c74 <__aeabi_dmul+0x1e8>)
   10b66:	051b      	lsls	r3, r3, #20
   10b68:	4015      	ands	r5, r2
   10b6a:	431d      	orrs	r5, r3
   10b6c:	006d      	lsls	r5, r5, #1
   10b6e:	07e4      	lsls	r4, r4, #31
   10b70:	086d      	lsrs	r5, r5, #1
   10b72:	4325      	orrs	r5, r4
   10b74:	4640      	mov	r0, r8
   10b76:	0029      	movs	r1, r5
   10b78:	b007      	add	sp, #28
   10b7a:	bc3c      	pop	{r2, r3, r4, r5}
   10b7c:	4690      	mov	r8, r2
   10b7e:	4699      	mov	r9, r3
   10b80:	46a2      	mov	sl, r4
   10b82:	46ab      	mov	fp, r5
   10b84:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10b86:	4303      	orrs	r3, r0
   10b88:	d052      	beq.n	10c30 <__aeabi_dmul+0x1a4>
   10b8a:	465b      	mov	r3, fp
   10b8c:	2b00      	cmp	r3, #0
   10b8e:	d100      	bne.n	10b92 <__aeabi_dmul+0x106>
   10b90:	e18a      	b.n	10ea8 <__aeabi_dmul+0x41c>
   10b92:	4658      	mov	r0, fp
   10b94:	f000 fde0 	bl	11758 <__clzsi2>
   10b98:	0003      	movs	r3, r0
   10b9a:	3b0b      	subs	r3, #11
   10b9c:	2b1c      	cmp	r3, #28
   10b9e:	dd00      	ble.n	10ba2 <__aeabi_dmul+0x116>
   10ba0:	e17b      	b.n	10e9a <__aeabi_dmul+0x40e>
   10ba2:	221d      	movs	r2, #29
   10ba4:	1ad3      	subs	r3, r2, r3
   10ba6:	003a      	movs	r2, r7
   10ba8:	0001      	movs	r1, r0
   10baa:	465d      	mov	r5, fp
   10bac:	40da      	lsrs	r2, r3
   10bae:	3908      	subs	r1, #8
   10bb0:	408d      	lsls	r5, r1
   10bb2:	0013      	movs	r3, r2
   10bb4:	408f      	lsls	r7, r1
   10bb6:	432b      	orrs	r3, r5
   10bb8:	469b      	mov	fp, r3
   10bba:	46b8      	mov	r8, r7
   10bbc:	4b2e      	ldr	r3, [pc, #184]	; (10c78 <__aeabi_dmul+0x1ec>)
   10bbe:	2700      	movs	r7, #0
   10bc0:	469c      	mov	ip, r3
   10bc2:	2300      	movs	r3, #0
   10bc4:	4460      	add	r0, ip
   10bc6:	4246      	negs	r6, r0
   10bc8:	9301      	str	r3, [sp, #4]
   10bca:	e785      	b.n	10ad8 <__aeabi_dmul+0x4c>
   10bcc:	4652      	mov	r2, sl
   10bce:	432a      	orrs	r2, r5
   10bd0:	d12c      	bne.n	10c2c <__aeabi_dmul+0x1a0>
   10bd2:	2500      	movs	r5, #0
   10bd4:	2300      	movs	r3, #0
   10bd6:	2202      	movs	r2, #2
   10bd8:	e797      	b.n	10b0a <__aeabi_dmul+0x7e>
   10bda:	4652      	mov	r2, sl
   10bdc:	432a      	orrs	r2, r5
   10bde:	d021      	beq.n	10c24 <__aeabi_dmul+0x198>
   10be0:	2d00      	cmp	r5, #0
   10be2:	d100      	bne.n	10be6 <__aeabi_dmul+0x15a>
   10be4:	e154      	b.n	10e90 <__aeabi_dmul+0x404>
   10be6:	0028      	movs	r0, r5
   10be8:	f000 fdb6 	bl	11758 <__clzsi2>
   10bec:	0003      	movs	r3, r0
   10bee:	3b0b      	subs	r3, #11
   10bf0:	2b1c      	cmp	r3, #28
   10bf2:	dd00      	ble.n	10bf6 <__aeabi_dmul+0x16a>
   10bf4:	e146      	b.n	10e84 <__aeabi_dmul+0x3f8>
   10bf6:	211d      	movs	r1, #29
   10bf8:	1acb      	subs	r3, r1, r3
   10bfa:	4651      	mov	r1, sl
   10bfc:	0002      	movs	r2, r0
   10bfe:	40d9      	lsrs	r1, r3
   10c00:	4653      	mov	r3, sl
   10c02:	3a08      	subs	r2, #8
   10c04:	4095      	lsls	r5, r2
   10c06:	4093      	lsls	r3, r2
   10c08:	430d      	orrs	r5, r1
   10c0a:	4a1b      	ldr	r2, [pc, #108]	; (10c78 <__aeabi_dmul+0x1ec>)
   10c0c:	4694      	mov	ip, r2
   10c0e:	4460      	add	r0, ip
   10c10:	4240      	negs	r0, r0
   10c12:	2200      	movs	r2, #0
   10c14:	e779      	b.n	10b0a <__aeabi_dmul+0x7e>
   10c16:	2401      	movs	r4, #1
   10c18:	2200      	movs	r2, #0
   10c1a:	400c      	ands	r4, r1
   10c1c:	4b12      	ldr	r3, [pc, #72]	; (10c68 <__aeabi_dmul+0x1dc>)
   10c1e:	2500      	movs	r5, #0
   10c20:	4690      	mov	r8, r2
   10c22:	e799      	b.n	10b58 <__aeabi_dmul+0xcc>
   10c24:	2500      	movs	r5, #0
   10c26:	2300      	movs	r3, #0
   10c28:	2201      	movs	r2, #1
   10c2a:	e76e      	b.n	10b0a <__aeabi_dmul+0x7e>
   10c2c:	2203      	movs	r2, #3
   10c2e:	e76c      	b.n	10b0a <__aeabi_dmul+0x7e>
   10c30:	2300      	movs	r3, #0
   10c32:	469b      	mov	fp, r3
   10c34:	4698      	mov	r8, r3
   10c36:	3301      	adds	r3, #1
   10c38:	2704      	movs	r7, #4
   10c3a:	9301      	str	r3, [sp, #4]
   10c3c:	e74c      	b.n	10ad8 <__aeabi_dmul+0x4c>
   10c3e:	2303      	movs	r3, #3
   10c40:	270c      	movs	r7, #12
   10c42:	9301      	str	r3, [sp, #4]
   10c44:	e748      	b.n	10ad8 <__aeabi_dmul+0x4c>
   10c46:	2300      	movs	r3, #0
   10c48:	2580      	movs	r5, #128	; 0x80
   10c4a:	4698      	mov	r8, r3
   10c4c:	2400      	movs	r4, #0
   10c4e:	032d      	lsls	r5, r5, #12
   10c50:	4b05      	ldr	r3, [pc, #20]	; (10c68 <__aeabi_dmul+0x1dc>)
   10c52:	e781      	b.n	10b58 <__aeabi_dmul+0xcc>
   10c54:	465d      	mov	r5, fp
   10c56:	4643      	mov	r3, r8
   10c58:	9a01      	ldr	r2, [sp, #4]
   10c5a:	e76f      	b.n	10b3c <__aeabi_dmul+0xb0>
   10c5c:	465d      	mov	r5, fp
   10c5e:	4643      	mov	r3, r8
   10c60:	0021      	movs	r1, r4
   10c62:	9a01      	ldr	r2, [sp, #4]
   10c64:	e76a      	b.n	10b3c <__aeabi_dmul+0xb0>
   10c66:	46c0      	nop			; (mov r8, r8)
   10c68:	000007ff 	.word	0x000007ff
   10c6c:	fffffc01 	.word	0xfffffc01
   10c70:	0001bfb8 	.word	0x0001bfb8
   10c74:	800fffff 	.word	0x800fffff
   10c78:	000003f3 	.word	0x000003f3
   10c7c:	4642      	mov	r2, r8
   10c7e:	0c12      	lsrs	r2, r2, #16
   10c80:	4691      	mov	r9, r2
   10c82:	0c1a      	lsrs	r2, r3, #16
   10c84:	4694      	mov	ip, r2
   10c86:	4642      	mov	r2, r8
   10c88:	0417      	lsls	r7, r2, #16
   10c8a:	464a      	mov	r2, r9
   10c8c:	041b      	lsls	r3, r3, #16
   10c8e:	0c1b      	lsrs	r3, r3, #16
   10c90:	435a      	muls	r2, r3
   10c92:	4660      	mov	r0, ip
   10c94:	4690      	mov	r8, r2
   10c96:	464a      	mov	r2, r9
   10c98:	4342      	muls	r2, r0
   10c9a:	0010      	movs	r0, r2
   10c9c:	9203      	str	r2, [sp, #12]
   10c9e:	4662      	mov	r2, ip
   10ca0:	001c      	movs	r4, r3
   10ca2:	0c3f      	lsrs	r7, r7, #16
   10ca4:	437a      	muls	r2, r7
   10ca6:	437c      	muls	r4, r7
   10ca8:	4442      	add	r2, r8
   10caa:	9201      	str	r2, [sp, #4]
   10cac:	0c22      	lsrs	r2, r4, #16
   10cae:	4692      	mov	sl, r2
   10cb0:	9a01      	ldr	r2, [sp, #4]
   10cb2:	4452      	add	r2, sl
   10cb4:	4590      	cmp	r8, r2
   10cb6:	d906      	bls.n	10cc6 <__aeabi_dmul+0x23a>
   10cb8:	4682      	mov	sl, r0
   10cba:	2080      	movs	r0, #128	; 0x80
   10cbc:	0240      	lsls	r0, r0, #9
   10cbe:	4680      	mov	r8, r0
   10cc0:	44c2      	add	sl, r8
   10cc2:	4650      	mov	r0, sl
   10cc4:	9003      	str	r0, [sp, #12]
   10cc6:	0c10      	lsrs	r0, r2, #16
   10cc8:	9004      	str	r0, [sp, #16]
   10cca:	4648      	mov	r0, r9
   10ccc:	0424      	lsls	r4, r4, #16
   10cce:	0c24      	lsrs	r4, r4, #16
   10cd0:	0412      	lsls	r2, r2, #16
   10cd2:	1912      	adds	r2, r2, r4
   10cd4:	9205      	str	r2, [sp, #20]
   10cd6:	0c2a      	lsrs	r2, r5, #16
   10cd8:	042d      	lsls	r5, r5, #16
   10cda:	0c2d      	lsrs	r5, r5, #16
   10cdc:	4368      	muls	r0, r5
   10cde:	002c      	movs	r4, r5
   10ce0:	4682      	mov	sl, r0
   10ce2:	4648      	mov	r0, r9
   10ce4:	437c      	muls	r4, r7
   10ce6:	4350      	muls	r0, r2
   10ce8:	4681      	mov	r9, r0
   10cea:	0c20      	lsrs	r0, r4, #16
   10cec:	4680      	mov	r8, r0
   10cee:	4357      	muls	r7, r2
   10cf0:	4457      	add	r7, sl
   10cf2:	4447      	add	r7, r8
   10cf4:	45ba      	cmp	sl, r7
   10cf6:	d903      	bls.n	10d00 <__aeabi_dmul+0x274>
   10cf8:	2080      	movs	r0, #128	; 0x80
   10cfa:	0240      	lsls	r0, r0, #9
   10cfc:	4680      	mov	r8, r0
   10cfe:	44c1      	add	r9, r8
   10d00:	0c38      	lsrs	r0, r7, #16
   10d02:	043f      	lsls	r7, r7, #16
   10d04:	46b8      	mov	r8, r7
   10d06:	4448      	add	r0, r9
   10d08:	0424      	lsls	r4, r4, #16
   10d0a:	0c24      	lsrs	r4, r4, #16
   10d0c:	9001      	str	r0, [sp, #4]
   10d0e:	9804      	ldr	r0, [sp, #16]
   10d10:	44a0      	add	r8, r4
   10d12:	4440      	add	r0, r8
   10d14:	9004      	str	r0, [sp, #16]
   10d16:	4658      	mov	r0, fp
   10d18:	0c00      	lsrs	r0, r0, #16
   10d1a:	4681      	mov	r9, r0
   10d1c:	4658      	mov	r0, fp
   10d1e:	0404      	lsls	r4, r0, #16
   10d20:	0c20      	lsrs	r0, r4, #16
   10d22:	4682      	mov	sl, r0
   10d24:	0007      	movs	r7, r0
   10d26:	4648      	mov	r0, r9
   10d28:	435f      	muls	r7, r3
   10d2a:	464c      	mov	r4, r9
   10d2c:	4343      	muls	r3, r0
   10d2e:	4660      	mov	r0, ip
   10d30:	4360      	muls	r0, r4
   10d32:	4664      	mov	r4, ip
   10d34:	4683      	mov	fp, r0
   10d36:	4650      	mov	r0, sl
   10d38:	4344      	muls	r4, r0
   10d3a:	0c38      	lsrs	r0, r7, #16
   10d3c:	4684      	mov	ip, r0
   10d3e:	18e4      	adds	r4, r4, r3
   10d40:	4464      	add	r4, ip
   10d42:	42a3      	cmp	r3, r4
   10d44:	d903      	bls.n	10d4e <__aeabi_dmul+0x2c2>
   10d46:	2380      	movs	r3, #128	; 0x80
   10d48:	025b      	lsls	r3, r3, #9
   10d4a:	469c      	mov	ip, r3
   10d4c:	44e3      	add	fp, ip
   10d4e:	4648      	mov	r0, r9
   10d50:	043f      	lsls	r7, r7, #16
   10d52:	0c23      	lsrs	r3, r4, #16
   10d54:	0c3f      	lsrs	r7, r7, #16
   10d56:	0424      	lsls	r4, r4, #16
   10d58:	19e4      	adds	r4, r4, r7
   10d5a:	4657      	mov	r7, sl
   10d5c:	4368      	muls	r0, r5
   10d5e:	436f      	muls	r7, r5
   10d60:	4684      	mov	ip, r0
   10d62:	464d      	mov	r5, r9
   10d64:	4650      	mov	r0, sl
   10d66:	4355      	muls	r5, r2
   10d68:	4342      	muls	r2, r0
   10d6a:	0c38      	lsrs	r0, r7, #16
   10d6c:	4681      	mov	r9, r0
   10d6e:	4462      	add	r2, ip
   10d70:	444a      	add	r2, r9
   10d72:	445b      	add	r3, fp
   10d74:	4594      	cmp	ip, r2
   10d76:	d903      	bls.n	10d80 <__aeabi_dmul+0x2f4>
   10d78:	2080      	movs	r0, #128	; 0x80
   10d7a:	0240      	lsls	r0, r0, #9
   10d7c:	4684      	mov	ip, r0
   10d7e:	4465      	add	r5, ip
   10d80:	9803      	ldr	r0, [sp, #12]
   10d82:	043f      	lsls	r7, r7, #16
   10d84:	4683      	mov	fp, r0
   10d86:	9804      	ldr	r0, [sp, #16]
   10d88:	0c3f      	lsrs	r7, r7, #16
   10d8a:	4684      	mov	ip, r0
   10d8c:	44e3      	add	fp, ip
   10d8e:	45c3      	cmp	fp, r8
   10d90:	4180      	sbcs	r0, r0
   10d92:	4240      	negs	r0, r0
   10d94:	4682      	mov	sl, r0
   10d96:	0410      	lsls	r0, r2, #16
   10d98:	4684      	mov	ip, r0
   10d9a:	9801      	ldr	r0, [sp, #4]
   10d9c:	4467      	add	r7, ip
   10d9e:	4684      	mov	ip, r0
   10da0:	4467      	add	r7, ip
   10da2:	44a3      	add	fp, r4
   10da4:	46bc      	mov	ip, r7
   10da6:	45a3      	cmp	fp, r4
   10da8:	41a4      	sbcs	r4, r4
   10daa:	4699      	mov	r9, r3
   10dac:	44d4      	add	ip, sl
   10dae:	4264      	negs	r4, r4
   10db0:	4287      	cmp	r7, r0
   10db2:	41bf      	sbcs	r7, r7
   10db4:	45d4      	cmp	ip, sl
   10db6:	4180      	sbcs	r0, r0
   10db8:	44e1      	add	r9, ip
   10dba:	46a0      	mov	r8, r4
   10dbc:	4599      	cmp	r9, r3
   10dbe:	419b      	sbcs	r3, r3
   10dc0:	427f      	negs	r7, r7
   10dc2:	4240      	negs	r0, r0
   10dc4:	44c8      	add	r8, r9
   10dc6:	4307      	orrs	r7, r0
   10dc8:	0c12      	lsrs	r2, r2, #16
   10dca:	18ba      	adds	r2, r7, r2
   10dcc:	45a0      	cmp	r8, r4
   10dce:	41a4      	sbcs	r4, r4
   10dd0:	425f      	negs	r7, r3
   10dd2:	003b      	movs	r3, r7
   10dd4:	4264      	negs	r4, r4
   10dd6:	4323      	orrs	r3, r4
   10dd8:	18d7      	adds	r7, r2, r3
   10dda:	4643      	mov	r3, r8
   10ddc:	197d      	adds	r5, r7, r5
   10dde:	0ddb      	lsrs	r3, r3, #23
   10de0:	026d      	lsls	r5, r5, #9
   10de2:	431d      	orrs	r5, r3
   10de4:	465b      	mov	r3, fp
   10de6:	025a      	lsls	r2, r3, #9
   10de8:	9b05      	ldr	r3, [sp, #20]
   10dea:	431a      	orrs	r2, r3
   10dec:	1e53      	subs	r3, r2, #1
   10dee:	419a      	sbcs	r2, r3
   10df0:	465b      	mov	r3, fp
   10df2:	0ddb      	lsrs	r3, r3, #23
   10df4:	431a      	orrs	r2, r3
   10df6:	4643      	mov	r3, r8
   10df8:	025b      	lsls	r3, r3, #9
   10dfa:	4313      	orrs	r3, r2
   10dfc:	01ea      	lsls	r2, r5, #7
   10dfe:	d507      	bpl.n	10e10 <__aeabi_dmul+0x384>
   10e00:	2201      	movs	r2, #1
   10e02:	085c      	lsrs	r4, r3, #1
   10e04:	4013      	ands	r3, r2
   10e06:	4323      	orrs	r3, r4
   10e08:	07ea      	lsls	r2, r5, #31
   10e0a:	9e02      	ldr	r6, [sp, #8]
   10e0c:	4313      	orrs	r3, r2
   10e0e:	086d      	lsrs	r5, r5, #1
   10e10:	4a57      	ldr	r2, [pc, #348]	; (10f70 <__aeabi_dmul+0x4e4>)
   10e12:	18b2      	adds	r2, r6, r2
   10e14:	2a00      	cmp	r2, #0
   10e16:	dd4b      	ble.n	10eb0 <__aeabi_dmul+0x424>
   10e18:	0758      	lsls	r0, r3, #29
   10e1a:	d009      	beq.n	10e30 <__aeabi_dmul+0x3a4>
   10e1c:	200f      	movs	r0, #15
   10e1e:	4018      	ands	r0, r3
   10e20:	2804      	cmp	r0, #4
   10e22:	d005      	beq.n	10e30 <__aeabi_dmul+0x3a4>
   10e24:	1d18      	adds	r0, r3, #4
   10e26:	4298      	cmp	r0, r3
   10e28:	419b      	sbcs	r3, r3
   10e2a:	425b      	negs	r3, r3
   10e2c:	18ed      	adds	r5, r5, r3
   10e2e:	0003      	movs	r3, r0
   10e30:	01e8      	lsls	r0, r5, #7
   10e32:	d504      	bpl.n	10e3e <__aeabi_dmul+0x3b2>
   10e34:	4a4f      	ldr	r2, [pc, #316]	; (10f74 <__aeabi_dmul+0x4e8>)
   10e36:	4015      	ands	r5, r2
   10e38:	2280      	movs	r2, #128	; 0x80
   10e3a:	00d2      	lsls	r2, r2, #3
   10e3c:	18b2      	adds	r2, r6, r2
   10e3e:	484e      	ldr	r0, [pc, #312]	; (10f78 <__aeabi_dmul+0x4ec>)
   10e40:	4282      	cmp	r2, r0
   10e42:	dd00      	ble.n	10e46 <__aeabi_dmul+0x3ba>
   10e44:	e6e7      	b.n	10c16 <__aeabi_dmul+0x18a>
   10e46:	2401      	movs	r4, #1
   10e48:	08db      	lsrs	r3, r3, #3
   10e4a:	0768      	lsls	r0, r5, #29
   10e4c:	4318      	orrs	r0, r3
   10e4e:	026d      	lsls	r5, r5, #9
   10e50:	0553      	lsls	r3, r2, #21
   10e52:	4680      	mov	r8, r0
   10e54:	0b2d      	lsrs	r5, r5, #12
   10e56:	0d5b      	lsrs	r3, r3, #21
   10e58:	400c      	ands	r4, r1
   10e5a:	e67d      	b.n	10b58 <__aeabi_dmul+0xcc>
   10e5c:	2280      	movs	r2, #128	; 0x80
   10e5e:	4659      	mov	r1, fp
   10e60:	0312      	lsls	r2, r2, #12
   10e62:	4211      	tst	r1, r2
   10e64:	d008      	beq.n	10e78 <__aeabi_dmul+0x3ec>
   10e66:	4215      	tst	r5, r2
   10e68:	d106      	bne.n	10e78 <__aeabi_dmul+0x3ec>
   10e6a:	4315      	orrs	r5, r2
   10e6c:	032d      	lsls	r5, r5, #12
   10e6e:	4698      	mov	r8, r3
   10e70:	0b2d      	lsrs	r5, r5, #12
   10e72:	464c      	mov	r4, r9
   10e74:	4b41      	ldr	r3, [pc, #260]	; (10f7c <__aeabi_dmul+0x4f0>)
   10e76:	e66f      	b.n	10b58 <__aeabi_dmul+0xcc>
   10e78:	465d      	mov	r5, fp
   10e7a:	4315      	orrs	r5, r2
   10e7c:	032d      	lsls	r5, r5, #12
   10e7e:	0b2d      	lsrs	r5, r5, #12
   10e80:	4b3e      	ldr	r3, [pc, #248]	; (10f7c <__aeabi_dmul+0x4f0>)
   10e82:	e669      	b.n	10b58 <__aeabi_dmul+0xcc>
   10e84:	0003      	movs	r3, r0
   10e86:	4655      	mov	r5, sl
   10e88:	3b28      	subs	r3, #40	; 0x28
   10e8a:	409d      	lsls	r5, r3
   10e8c:	2300      	movs	r3, #0
   10e8e:	e6bc      	b.n	10c0a <__aeabi_dmul+0x17e>
   10e90:	4650      	mov	r0, sl
   10e92:	f000 fc61 	bl	11758 <__clzsi2>
   10e96:	3020      	adds	r0, #32
   10e98:	e6a8      	b.n	10bec <__aeabi_dmul+0x160>
   10e9a:	0003      	movs	r3, r0
   10e9c:	3b28      	subs	r3, #40	; 0x28
   10e9e:	409f      	lsls	r7, r3
   10ea0:	2300      	movs	r3, #0
   10ea2:	46bb      	mov	fp, r7
   10ea4:	4698      	mov	r8, r3
   10ea6:	e689      	b.n	10bbc <__aeabi_dmul+0x130>
   10ea8:	f000 fc56 	bl	11758 <__clzsi2>
   10eac:	3020      	adds	r0, #32
   10eae:	e673      	b.n	10b98 <__aeabi_dmul+0x10c>
   10eb0:	2401      	movs	r4, #1
   10eb2:	1aa6      	subs	r6, r4, r2
   10eb4:	2e38      	cmp	r6, #56	; 0x38
   10eb6:	dd07      	ble.n	10ec8 <__aeabi_dmul+0x43c>
   10eb8:	2200      	movs	r2, #0
   10eba:	400c      	ands	r4, r1
   10ebc:	2300      	movs	r3, #0
   10ebe:	2500      	movs	r5, #0
   10ec0:	4690      	mov	r8, r2
   10ec2:	e649      	b.n	10b58 <__aeabi_dmul+0xcc>
   10ec4:	9e02      	ldr	r6, [sp, #8]
   10ec6:	e7a3      	b.n	10e10 <__aeabi_dmul+0x384>
   10ec8:	2e1f      	cmp	r6, #31
   10eca:	dc20      	bgt.n	10f0e <__aeabi_dmul+0x482>
   10ecc:	2220      	movs	r2, #32
   10ece:	002c      	movs	r4, r5
   10ed0:	0018      	movs	r0, r3
   10ed2:	1b92      	subs	r2, r2, r6
   10ed4:	40f0      	lsrs	r0, r6
   10ed6:	4094      	lsls	r4, r2
   10ed8:	4093      	lsls	r3, r2
   10eda:	4304      	orrs	r4, r0
   10edc:	1e58      	subs	r0, r3, #1
   10ede:	4183      	sbcs	r3, r0
   10ee0:	431c      	orrs	r4, r3
   10ee2:	40f5      	lsrs	r5, r6
   10ee4:	0763      	lsls	r3, r4, #29
   10ee6:	d009      	beq.n	10efc <__aeabi_dmul+0x470>
   10ee8:	230f      	movs	r3, #15
   10eea:	4023      	ands	r3, r4
   10eec:	2b04      	cmp	r3, #4
   10eee:	d005      	beq.n	10efc <__aeabi_dmul+0x470>
   10ef0:	0023      	movs	r3, r4
   10ef2:	1d1c      	adds	r4, r3, #4
   10ef4:	429c      	cmp	r4, r3
   10ef6:	4192      	sbcs	r2, r2
   10ef8:	4252      	negs	r2, r2
   10efa:	18ad      	adds	r5, r5, r2
   10efc:	022b      	lsls	r3, r5, #8
   10efe:	d51f      	bpl.n	10f40 <__aeabi_dmul+0x4b4>
   10f00:	2401      	movs	r4, #1
   10f02:	2200      	movs	r2, #0
   10f04:	400c      	ands	r4, r1
   10f06:	2301      	movs	r3, #1
   10f08:	2500      	movs	r5, #0
   10f0a:	4690      	mov	r8, r2
   10f0c:	e624      	b.n	10b58 <__aeabi_dmul+0xcc>
   10f0e:	201f      	movs	r0, #31
   10f10:	002c      	movs	r4, r5
   10f12:	4240      	negs	r0, r0
   10f14:	1a82      	subs	r2, r0, r2
   10f16:	40d4      	lsrs	r4, r2
   10f18:	2e20      	cmp	r6, #32
   10f1a:	d01c      	beq.n	10f56 <__aeabi_dmul+0x4ca>
   10f1c:	2240      	movs	r2, #64	; 0x40
   10f1e:	1b96      	subs	r6, r2, r6
   10f20:	40b5      	lsls	r5, r6
   10f22:	432b      	orrs	r3, r5
   10f24:	1e58      	subs	r0, r3, #1
   10f26:	4183      	sbcs	r3, r0
   10f28:	2007      	movs	r0, #7
   10f2a:	4323      	orrs	r3, r4
   10f2c:	4018      	ands	r0, r3
   10f2e:	2500      	movs	r5, #0
   10f30:	2800      	cmp	r0, #0
   10f32:	d009      	beq.n	10f48 <__aeabi_dmul+0x4bc>
   10f34:	220f      	movs	r2, #15
   10f36:	2500      	movs	r5, #0
   10f38:	401a      	ands	r2, r3
   10f3a:	001c      	movs	r4, r3
   10f3c:	2a04      	cmp	r2, #4
   10f3e:	d1d8      	bne.n	10ef2 <__aeabi_dmul+0x466>
   10f40:	0023      	movs	r3, r4
   10f42:	0768      	lsls	r0, r5, #29
   10f44:	026d      	lsls	r5, r5, #9
   10f46:	0b2d      	lsrs	r5, r5, #12
   10f48:	2401      	movs	r4, #1
   10f4a:	08db      	lsrs	r3, r3, #3
   10f4c:	4303      	orrs	r3, r0
   10f4e:	4698      	mov	r8, r3
   10f50:	400c      	ands	r4, r1
   10f52:	2300      	movs	r3, #0
   10f54:	e600      	b.n	10b58 <__aeabi_dmul+0xcc>
   10f56:	2500      	movs	r5, #0
   10f58:	e7e3      	b.n	10f22 <__aeabi_dmul+0x496>
   10f5a:	2280      	movs	r2, #128	; 0x80
   10f5c:	2401      	movs	r4, #1
   10f5e:	0312      	lsls	r2, r2, #12
   10f60:	4315      	orrs	r5, r2
   10f62:	032d      	lsls	r5, r5, #12
   10f64:	4698      	mov	r8, r3
   10f66:	0b2d      	lsrs	r5, r5, #12
   10f68:	400c      	ands	r4, r1
   10f6a:	4b04      	ldr	r3, [pc, #16]	; (10f7c <__aeabi_dmul+0x4f0>)
   10f6c:	e5f4      	b.n	10b58 <__aeabi_dmul+0xcc>
   10f6e:	46c0      	nop			; (mov r8, r8)
   10f70:	000003ff 	.word	0x000003ff
   10f74:	feffffff 	.word	0xfeffffff
   10f78:	000007fe 	.word	0x000007fe
   10f7c:	000007ff 	.word	0x000007ff

00010f80 <__aeabi_dsub>:
   10f80:	b5f0      	push	{r4, r5, r6, r7, lr}
   10f82:	4657      	mov	r7, sl
   10f84:	464e      	mov	r6, r9
   10f86:	4645      	mov	r5, r8
   10f88:	b4e0      	push	{r5, r6, r7}
   10f8a:	000e      	movs	r6, r1
   10f8c:	0011      	movs	r1, r2
   10f8e:	0ff2      	lsrs	r2, r6, #31
   10f90:	4692      	mov	sl, r2
   10f92:	00c5      	lsls	r5, r0, #3
   10f94:	0f42      	lsrs	r2, r0, #29
   10f96:	0318      	lsls	r0, r3, #12
   10f98:	0337      	lsls	r7, r6, #12
   10f9a:	0074      	lsls	r4, r6, #1
   10f9c:	0a40      	lsrs	r0, r0, #9
   10f9e:	0f4e      	lsrs	r6, r1, #29
   10fa0:	0a7f      	lsrs	r7, r7, #9
   10fa2:	4330      	orrs	r0, r6
   10fa4:	4ecf      	ldr	r6, [pc, #828]	; (112e4 <__aeabi_dsub+0x364>)
   10fa6:	4317      	orrs	r7, r2
   10fa8:	005a      	lsls	r2, r3, #1
   10faa:	0d64      	lsrs	r4, r4, #21
   10fac:	0d52      	lsrs	r2, r2, #21
   10fae:	0fdb      	lsrs	r3, r3, #31
   10fb0:	00c9      	lsls	r1, r1, #3
   10fb2:	42b2      	cmp	r2, r6
   10fb4:	d100      	bne.n	10fb8 <__aeabi_dsub+0x38>
   10fb6:	e0e5      	b.n	11184 <__aeabi_dsub+0x204>
   10fb8:	2601      	movs	r6, #1
   10fba:	4073      	eors	r3, r6
   10fbc:	1aa6      	subs	r6, r4, r2
   10fbe:	46b4      	mov	ip, r6
   10fc0:	4553      	cmp	r3, sl
   10fc2:	d100      	bne.n	10fc6 <__aeabi_dsub+0x46>
   10fc4:	e0af      	b.n	11126 <__aeabi_dsub+0x1a6>
   10fc6:	2e00      	cmp	r6, #0
   10fc8:	dc00      	bgt.n	10fcc <__aeabi_dsub+0x4c>
   10fca:	e10d      	b.n	111e8 <__aeabi_dsub+0x268>
   10fcc:	2a00      	cmp	r2, #0
   10fce:	d13a      	bne.n	11046 <__aeabi_dsub+0xc6>
   10fd0:	0003      	movs	r3, r0
   10fd2:	430b      	orrs	r3, r1
   10fd4:	d000      	beq.n	10fd8 <__aeabi_dsub+0x58>
   10fd6:	e0e4      	b.n	111a2 <__aeabi_dsub+0x222>
   10fd8:	076b      	lsls	r3, r5, #29
   10fda:	d009      	beq.n	10ff0 <__aeabi_dsub+0x70>
   10fdc:	230f      	movs	r3, #15
   10fde:	402b      	ands	r3, r5
   10fe0:	2b04      	cmp	r3, #4
   10fe2:	d005      	beq.n	10ff0 <__aeabi_dsub+0x70>
   10fe4:	1d2b      	adds	r3, r5, #4
   10fe6:	42ab      	cmp	r3, r5
   10fe8:	41ad      	sbcs	r5, r5
   10fea:	426d      	negs	r5, r5
   10fec:	197f      	adds	r7, r7, r5
   10fee:	001d      	movs	r5, r3
   10ff0:	023b      	lsls	r3, r7, #8
   10ff2:	d400      	bmi.n	10ff6 <__aeabi_dsub+0x76>
   10ff4:	e088      	b.n	11108 <__aeabi_dsub+0x188>
   10ff6:	4bbb      	ldr	r3, [pc, #748]	; (112e4 <__aeabi_dsub+0x364>)
   10ff8:	3401      	adds	r4, #1
   10ffa:	429c      	cmp	r4, r3
   10ffc:	d100      	bne.n	11000 <__aeabi_dsub+0x80>
   10ffe:	e110      	b.n	11222 <__aeabi_dsub+0x2a2>
   11000:	003a      	movs	r2, r7
   11002:	4bb9      	ldr	r3, [pc, #740]	; (112e8 <__aeabi_dsub+0x368>)
   11004:	4651      	mov	r1, sl
   11006:	401a      	ands	r2, r3
   11008:	2301      	movs	r3, #1
   1100a:	0750      	lsls	r0, r2, #29
   1100c:	08ed      	lsrs	r5, r5, #3
   1100e:	0252      	lsls	r2, r2, #9
   11010:	0564      	lsls	r4, r4, #21
   11012:	4305      	orrs	r5, r0
   11014:	0b12      	lsrs	r2, r2, #12
   11016:	0d64      	lsrs	r4, r4, #21
   11018:	400b      	ands	r3, r1
   1101a:	2100      	movs	r1, #0
   1101c:	0028      	movs	r0, r5
   1101e:	0312      	lsls	r2, r2, #12
   11020:	0d0d      	lsrs	r5, r1, #20
   11022:	0b12      	lsrs	r2, r2, #12
   11024:	0564      	lsls	r4, r4, #21
   11026:	052d      	lsls	r5, r5, #20
   11028:	4315      	orrs	r5, r2
   1102a:	0862      	lsrs	r2, r4, #1
   1102c:	4caf      	ldr	r4, [pc, #700]	; (112ec <__aeabi_dsub+0x36c>)
   1102e:	07db      	lsls	r3, r3, #31
   11030:	402c      	ands	r4, r5
   11032:	4314      	orrs	r4, r2
   11034:	0064      	lsls	r4, r4, #1
   11036:	0864      	lsrs	r4, r4, #1
   11038:	431c      	orrs	r4, r3
   1103a:	0021      	movs	r1, r4
   1103c:	bc1c      	pop	{r2, r3, r4}
   1103e:	4690      	mov	r8, r2
   11040:	4699      	mov	r9, r3
   11042:	46a2      	mov	sl, r4
   11044:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11046:	4ba7      	ldr	r3, [pc, #668]	; (112e4 <__aeabi_dsub+0x364>)
   11048:	429c      	cmp	r4, r3
   1104a:	d0c5      	beq.n	10fd8 <__aeabi_dsub+0x58>
   1104c:	2380      	movs	r3, #128	; 0x80
   1104e:	041b      	lsls	r3, r3, #16
   11050:	4318      	orrs	r0, r3
   11052:	4663      	mov	r3, ip
   11054:	2b38      	cmp	r3, #56	; 0x38
   11056:	dd00      	ble.n	1105a <__aeabi_dsub+0xda>
   11058:	e0fd      	b.n	11256 <__aeabi_dsub+0x2d6>
   1105a:	2b1f      	cmp	r3, #31
   1105c:	dd00      	ble.n	11060 <__aeabi_dsub+0xe0>
   1105e:	e130      	b.n	112c2 <__aeabi_dsub+0x342>
   11060:	4662      	mov	r2, ip
   11062:	2320      	movs	r3, #32
   11064:	1a9b      	subs	r3, r3, r2
   11066:	0002      	movs	r2, r0
   11068:	409a      	lsls	r2, r3
   1106a:	4666      	mov	r6, ip
   1106c:	4690      	mov	r8, r2
   1106e:	000a      	movs	r2, r1
   11070:	4099      	lsls	r1, r3
   11072:	40f2      	lsrs	r2, r6
   11074:	4646      	mov	r6, r8
   11076:	1e4b      	subs	r3, r1, #1
   11078:	4199      	sbcs	r1, r3
   1107a:	4332      	orrs	r2, r6
   1107c:	4311      	orrs	r1, r2
   1107e:	4663      	mov	r3, ip
   11080:	0002      	movs	r2, r0
   11082:	40da      	lsrs	r2, r3
   11084:	1a69      	subs	r1, r5, r1
   11086:	428d      	cmp	r5, r1
   11088:	419b      	sbcs	r3, r3
   1108a:	000d      	movs	r5, r1
   1108c:	1aba      	subs	r2, r7, r2
   1108e:	425b      	negs	r3, r3
   11090:	1ad7      	subs	r7, r2, r3
   11092:	023b      	lsls	r3, r7, #8
   11094:	d535      	bpl.n	11102 <__aeabi_dsub+0x182>
   11096:	027a      	lsls	r2, r7, #9
   11098:	0a53      	lsrs	r3, r2, #9
   1109a:	4698      	mov	r8, r3
   1109c:	4643      	mov	r3, r8
   1109e:	2b00      	cmp	r3, #0
   110a0:	d100      	bne.n	110a4 <__aeabi_dsub+0x124>
   110a2:	e0c4      	b.n	1122e <__aeabi_dsub+0x2ae>
   110a4:	4640      	mov	r0, r8
   110a6:	f000 fb57 	bl	11758 <__clzsi2>
   110aa:	0003      	movs	r3, r0
   110ac:	3b08      	subs	r3, #8
   110ae:	2b1f      	cmp	r3, #31
   110b0:	dd00      	ble.n	110b4 <__aeabi_dsub+0x134>
   110b2:	e0c5      	b.n	11240 <__aeabi_dsub+0x2c0>
   110b4:	2220      	movs	r2, #32
   110b6:	0029      	movs	r1, r5
   110b8:	1ad2      	subs	r2, r2, r3
   110ba:	4647      	mov	r7, r8
   110bc:	40d1      	lsrs	r1, r2
   110be:	409f      	lsls	r7, r3
   110c0:	000a      	movs	r2, r1
   110c2:	409d      	lsls	r5, r3
   110c4:	433a      	orrs	r2, r7
   110c6:	429c      	cmp	r4, r3
   110c8:	dd00      	ble.n	110cc <__aeabi_dsub+0x14c>
   110ca:	e0c0      	b.n	1124e <__aeabi_dsub+0x2ce>
   110cc:	1b1c      	subs	r4, r3, r4
   110ce:	1c63      	adds	r3, r4, #1
   110d0:	2b1f      	cmp	r3, #31
   110d2:	dd00      	ble.n	110d6 <__aeabi_dsub+0x156>
   110d4:	e0e4      	b.n	112a0 <__aeabi_dsub+0x320>
   110d6:	2120      	movs	r1, #32
   110d8:	0014      	movs	r4, r2
   110da:	0028      	movs	r0, r5
   110dc:	1ac9      	subs	r1, r1, r3
   110de:	40d8      	lsrs	r0, r3
   110e0:	408c      	lsls	r4, r1
   110e2:	408d      	lsls	r5, r1
   110e4:	4304      	orrs	r4, r0
   110e6:	40da      	lsrs	r2, r3
   110e8:	1e68      	subs	r0, r5, #1
   110ea:	4185      	sbcs	r5, r0
   110ec:	0017      	movs	r7, r2
   110ee:	4325      	orrs	r5, r4
   110f0:	2400      	movs	r4, #0
   110f2:	e771      	b.n	10fd8 <__aeabi_dsub+0x58>
   110f4:	4642      	mov	r2, r8
   110f6:	4663      	mov	r3, ip
   110f8:	431a      	orrs	r2, r3
   110fa:	d100      	bne.n	110fe <__aeabi_dsub+0x17e>
   110fc:	e24c      	b.n	11598 <__aeabi_dsub+0x618>
   110fe:	4667      	mov	r7, ip
   11100:	4645      	mov	r5, r8
   11102:	076b      	lsls	r3, r5, #29
   11104:	d000      	beq.n	11108 <__aeabi_dsub+0x188>
   11106:	e769      	b.n	10fdc <__aeabi_dsub+0x5c>
   11108:	2301      	movs	r3, #1
   1110a:	4651      	mov	r1, sl
   1110c:	0778      	lsls	r0, r7, #29
   1110e:	08ed      	lsrs	r5, r5, #3
   11110:	08fa      	lsrs	r2, r7, #3
   11112:	400b      	ands	r3, r1
   11114:	4305      	orrs	r5, r0
   11116:	4973      	ldr	r1, [pc, #460]	; (112e4 <__aeabi_dsub+0x364>)
   11118:	428c      	cmp	r4, r1
   1111a:	d038      	beq.n	1118e <__aeabi_dsub+0x20e>
   1111c:	0312      	lsls	r2, r2, #12
   1111e:	0564      	lsls	r4, r4, #21
   11120:	0b12      	lsrs	r2, r2, #12
   11122:	0d64      	lsrs	r4, r4, #21
   11124:	e779      	b.n	1101a <__aeabi_dsub+0x9a>
   11126:	2e00      	cmp	r6, #0
   11128:	dc00      	bgt.n	1112c <__aeabi_dsub+0x1ac>
   1112a:	e09a      	b.n	11262 <__aeabi_dsub+0x2e2>
   1112c:	2a00      	cmp	r2, #0
   1112e:	d047      	beq.n	111c0 <__aeabi_dsub+0x240>
   11130:	4a6c      	ldr	r2, [pc, #432]	; (112e4 <__aeabi_dsub+0x364>)
   11132:	4294      	cmp	r4, r2
   11134:	d100      	bne.n	11138 <__aeabi_dsub+0x1b8>
   11136:	e74f      	b.n	10fd8 <__aeabi_dsub+0x58>
   11138:	2280      	movs	r2, #128	; 0x80
   1113a:	0412      	lsls	r2, r2, #16
   1113c:	4310      	orrs	r0, r2
   1113e:	4662      	mov	r2, ip
   11140:	2a38      	cmp	r2, #56	; 0x38
   11142:	dc00      	bgt.n	11146 <__aeabi_dsub+0x1c6>
   11144:	e108      	b.n	11358 <__aeabi_dsub+0x3d8>
   11146:	4301      	orrs	r1, r0
   11148:	1e48      	subs	r0, r1, #1
   1114a:	4181      	sbcs	r1, r0
   1114c:	2200      	movs	r2, #0
   1114e:	b2c9      	uxtb	r1, r1
   11150:	1949      	adds	r1, r1, r5
   11152:	19d2      	adds	r2, r2, r7
   11154:	42a9      	cmp	r1, r5
   11156:	41bf      	sbcs	r7, r7
   11158:	000d      	movs	r5, r1
   1115a:	427f      	negs	r7, r7
   1115c:	18bf      	adds	r7, r7, r2
   1115e:	023a      	lsls	r2, r7, #8
   11160:	d400      	bmi.n	11164 <__aeabi_dsub+0x1e4>
   11162:	e142      	b.n	113ea <__aeabi_dsub+0x46a>
   11164:	4a5f      	ldr	r2, [pc, #380]	; (112e4 <__aeabi_dsub+0x364>)
   11166:	3401      	adds	r4, #1
   11168:	4294      	cmp	r4, r2
   1116a:	d100      	bne.n	1116e <__aeabi_dsub+0x1ee>
   1116c:	e14e      	b.n	1140c <__aeabi_dsub+0x48c>
   1116e:	2001      	movs	r0, #1
   11170:	4a5d      	ldr	r2, [pc, #372]	; (112e8 <__aeabi_dsub+0x368>)
   11172:	0869      	lsrs	r1, r5, #1
   11174:	403a      	ands	r2, r7
   11176:	4028      	ands	r0, r5
   11178:	4308      	orrs	r0, r1
   1117a:	07d5      	lsls	r5, r2, #31
   1117c:	4305      	orrs	r5, r0
   1117e:	0857      	lsrs	r7, r2, #1
   11180:	469a      	mov	sl, r3
   11182:	e729      	b.n	10fd8 <__aeabi_dsub+0x58>
   11184:	0006      	movs	r6, r0
   11186:	430e      	orrs	r6, r1
   11188:	d000      	beq.n	1118c <__aeabi_dsub+0x20c>
   1118a:	e717      	b.n	10fbc <__aeabi_dsub+0x3c>
   1118c:	e714      	b.n	10fb8 <__aeabi_dsub+0x38>
   1118e:	0029      	movs	r1, r5
   11190:	4311      	orrs	r1, r2
   11192:	d100      	bne.n	11196 <__aeabi_dsub+0x216>
   11194:	e1f9      	b.n	1158a <__aeabi_dsub+0x60a>
   11196:	2180      	movs	r1, #128	; 0x80
   11198:	0309      	lsls	r1, r1, #12
   1119a:	430a      	orrs	r2, r1
   1119c:	0312      	lsls	r2, r2, #12
   1119e:	0b12      	lsrs	r2, r2, #12
   111a0:	e73b      	b.n	1101a <__aeabi_dsub+0x9a>
   111a2:	2301      	movs	r3, #1
   111a4:	425b      	negs	r3, r3
   111a6:	4698      	mov	r8, r3
   111a8:	44c4      	add	ip, r8
   111aa:	4663      	mov	r3, ip
   111ac:	2b00      	cmp	r3, #0
   111ae:	d172      	bne.n	11296 <__aeabi_dsub+0x316>
   111b0:	1a69      	subs	r1, r5, r1
   111b2:	428d      	cmp	r5, r1
   111b4:	419b      	sbcs	r3, r3
   111b6:	1a3f      	subs	r7, r7, r0
   111b8:	425b      	negs	r3, r3
   111ba:	1aff      	subs	r7, r7, r3
   111bc:	000d      	movs	r5, r1
   111be:	e768      	b.n	11092 <__aeabi_dsub+0x112>
   111c0:	0002      	movs	r2, r0
   111c2:	430a      	orrs	r2, r1
   111c4:	d100      	bne.n	111c8 <__aeabi_dsub+0x248>
   111c6:	e707      	b.n	10fd8 <__aeabi_dsub+0x58>
   111c8:	2201      	movs	r2, #1
   111ca:	4252      	negs	r2, r2
   111cc:	4690      	mov	r8, r2
   111ce:	44c4      	add	ip, r8
   111d0:	4662      	mov	r2, ip
   111d2:	2a00      	cmp	r2, #0
   111d4:	d000      	beq.n	111d8 <__aeabi_dsub+0x258>
   111d6:	e0e6      	b.n	113a6 <__aeabi_dsub+0x426>
   111d8:	1869      	adds	r1, r5, r1
   111da:	42a9      	cmp	r1, r5
   111dc:	41b6      	sbcs	r6, r6
   111de:	183f      	adds	r7, r7, r0
   111e0:	4276      	negs	r6, r6
   111e2:	19f7      	adds	r7, r6, r7
   111e4:	000d      	movs	r5, r1
   111e6:	e7ba      	b.n	1115e <__aeabi_dsub+0x1de>
   111e8:	2e00      	cmp	r6, #0
   111ea:	d000      	beq.n	111ee <__aeabi_dsub+0x26e>
   111ec:	e080      	b.n	112f0 <__aeabi_dsub+0x370>
   111ee:	1c62      	adds	r2, r4, #1
   111f0:	0552      	lsls	r2, r2, #21
   111f2:	0d52      	lsrs	r2, r2, #21
   111f4:	2a01      	cmp	r2, #1
   111f6:	dc00      	bgt.n	111fa <__aeabi_dsub+0x27a>
   111f8:	e0f9      	b.n	113ee <__aeabi_dsub+0x46e>
   111fa:	1a6a      	subs	r2, r5, r1
   111fc:	4691      	mov	r9, r2
   111fe:	454d      	cmp	r5, r9
   11200:	41b6      	sbcs	r6, r6
   11202:	1a3a      	subs	r2, r7, r0
   11204:	4276      	negs	r6, r6
   11206:	1b92      	subs	r2, r2, r6
   11208:	4690      	mov	r8, r2
   1120a:	0212      	lsls	r2, r2, #8
   1120c:	d400      	bmi.n	11210 <__aeabi_dsub+0x290>
   1120e:	e099      	b.n	11344 <__aeabi_dsub+0x3c4>
   11210:	1b4d      	subs	r5, r1, r5
   11212:	42a9      	cmp	r1, r5
   11214:	4189      	sbcs	r1, r1
   11216:	1bc7      	subs	r7, r0, r7
   11218:	4249      	negs	r1, r1
   1121a:	1a7a      	subs	r2, r7, r1
   1121c:	4690      	mov	r8, r2
   1121e:	469a      	mov	sl, r3
   11220:	e73c      	b.n	1109c <__aeabi_dsub+0x11c>
   11222:	4652      	mov	r2, sl
   11224:	2301      	movs	r3, #1
   11226:	2500      	movs	r5, #0
   11228:	4013      	ands	r3, r2
   1122a:	2200      	movs	r2, #0
   1122c:	e6f5      	b.n	1101a <__aeabi_dsub+0x9a>
   1122e:	0028      	movs	r0, r5
   11230:	f000 fa92 	bl	11758 <__clzsi2>
   11234:	3020      	adds	r0, #32
   11236:	0003      	movs	r3, r0
   11238:	3b08      	subs	r3, #8
   1123a:	2b1f      	cmp	r3, #31
   1123c:	dc00      	bgt.n	11240 <__aeabi_dsub+0x2c0>
   1123e:	e739      	b.n	110b4 <__aeabi_dsub+0x134>
   11240:	002a      	movs	r2, r5
   11242:	3828      	subs	r0, #40	; 0x28
   11244:	4082      	lsls	r2, r0
   11246:	2500      	movs	r5, #0
   11248:	429c      	cmp	r4, r3
   1124a:	dc00      	bgt.n	1124e <__aeabi_dsub+0x2ce>
   1124c:	e73e      	b.n	110cc <__aeabi_dsub+0x14c>
   1124e:	4f26      	ldr	r7, [pc, #152]	; (112e8 <__aeabi_dsub+0x368>)
   11250:	1ae4      	subs	r4, r4, r3
   11252:	4017      	ands	r7, r2
   11254:	e6c0      	b.n	10fd8 <__aeabi_dsub+0x58>
   11256:	4301      	orrs	r1, r0
   11258:	1e48      	subs	r0, r1, #1
   1125a:	4181      	sbcs	r1, r0
   1125c:	2200      	movs	r2, #0
   1125e:	b2c9      	uxtb	r1, r1
   11260:	e710      	b.n	11084 <__aeabi_dsub+0x104>
   11262:	2e00      	cmp	r6, #0
   11264:	d000      	beq.n	11268 <__aeabi_dsub+0x2e8>
   11266:	e0f1      	b.n	1144c <__aeabi_dsub+0x4cc>
   11268:	1c62      	adds	r2, r4, #1
   1126a:	4694      	mov	ip, r2
   1126c:	0552      	lsls	r2, r2, #21
   1126e:	0d52      	lsrs	r2, r2, #21
   11270:	2a01      	cmp	r2, #1
   11272:	dc00      	bgt.n	11276 <__aeabi_dsub+0x2f6>
   11274:	e0a0      	b.n	113b8 <__aeabi_dsub+0x438>
   11276:	4a1b      	ldr	r2, [pc, #108]	; (112e4 <__aeabi_dsub+0x364>)
   11278:	4594      	cmp	ip, r2
   1127a:	d100      	bne.n	1127e <__aeabi_dsub+0x2fe>
   1127c:	e0c5      	b.n	1140a <__aeabi_dsub+0x48a>
   1127e:	1869      	adds	r1, r5, r1
   11280:	42a9      	cmp	r1, r5
   11282:	4192      	sbcs	r2, r2
   11284:	183f      	adds	r7, r7, r0
   11286:	4252      	negs	r2, r2
   11288:	19d2      	adds	r2, r2, r7
   1128a:	0849      	lsrs	r1, r1, #1
   1128c:	07d5      	lsls	r5, r2, #31
   1128e:	430d      	orrs	r5, r1
   11290:	0857      	lsrs	r7, r2, #1
   11292:	4664      	mov	r4, ip
   11294:	e6a0      	b.n	10fd8 <__aeabi_dsub+0x58>
   11296:	4b13      	ldr	r3, [pc, #76]	; (112e4 <__aeabi_dsub+0x364>)
   11298:	429c      	cmp	r4, r3
   1129a:	d000      	beq.n	1129e <__aeabi_dsub+0x31e>
   1129c:	e6d9      	b.n	11052 <__aeabi_dsub+0xd2>
   1129e:	e69b      	b.n	10fd8 <__aeabi_dsub+0x58>
   112a0:	0011      	movs	r1, r2
   112a2:	3c1f      	subs	r4, #31
   112a4:	40e1      	lsrs	r1, r4
   112a6:	000c      	movs	r4, r1
   112a8:	2b20      	cmp	r3, #32
   112aa:	d100      	bne.n	112ae <__aeabi_dsub+0x32e>
   112ac:	e080      	b.n	113b0 <__aeabi_dsub+0x430>
   112ae:	2140      	movs	r1, #64	; 0x40
   112b0:	1acb      	subs	r3, r1, r3
   112b2:	409a      	lsls	r2, r3
   112b4:	4315      	orrs	r5, r2
   112b6:	1e6a      	subs	r2, r5, #1
   112b8:	4195      	sbcs	r5, r2
   112ba:	2700      	movs	r7, #0
   112bc:	4325      	orrs	r5, r4
   112be:	2400      	movs	r4, #0
   112c0:	e71f      	b.n	11102 <__aeabi_dsub+0x182>
   112c2:	4663      	mov	r3, ip
   112c4:	0002      	movs	r2, r0
   112c6:	3b20      	subs	r3, #32
   112c8:	40da      	lsrs	r2, r3
   112ca:	4663      	mov	r3, ip
   112cc:	2b20      	cmp	r3, #32
   112ce:	d071      	beq.n	113b4 <__aeabi_dsub+0x434>
   112d0:	2340      	movs	r3, #64	; 0x40
   112d2:	4666      	mov	r6, ip
   112d4:	1b9b      	subs	r3, r3, r6
   112d6:	4098      	lsls	r0, r3
   112d8:	4301      	orrs	r1, r0
   112da:	1e48      	subs	r0, r1, #1
   112dc:	4181      	sbcs	r1, r0
   112de:	4311      	orrs	r1, r2
   112e0:	2200      	movs	r2, #0
   112e2:	e6cf      	b.n	11084 <__aeabi_dsub+0x104>
   112e4:	000007ff 	.word	0x000007ff
   112e8:	ff7fffff 	.word	0xff7fffff
   112ec:	800fffff 	.word	0x800fffff
   112f0:	2c00      	cmp	r4, #0
   112f2:	d048      	beq.n	11386 <__aeabi_dsub+0x406>
   112f4:	4cca      	ldr	r4, [pc, #808]	; (11620 <__aeabi_dsub+0x6a0>)
   112f6:	42a2      	cmp	r2, r4
   112f8:	d100      	bne.n	112fc <__aeabi_dsub+0x37c>
   112fa:	e0a2      	b.n	11442 <__aeabi_dsub+0x4c2>
   112fc:	4274      	negs	r4, r6
   112fe:	46a1      	mov	r9, r4
   11300:	2480      	movs	r4, #128	; 0x80
   11302:	0424      	lsls	r4, r4, #16
   11304:	4327      	orrs	r7, r4
   11306:	464c      	mov	r4, r9
   11308:	2c38      	cmp	r4, #56	; 0x38
   1130a:	dd00      	ble.n	1130e <__aeabi_dsub+0x38e>
   1130c:	e0db      	b.n	114c6 <__aeabi_dsub+0x546>
   1130e:	2c1f      	cmp	r4, #31
   11310:	dd00      	ble.n	11314 <__aeabi_dsub+0x394>
   11312:	e144      	b.n	1159e <__aeabi_dsub+0x61e>
   11314:	464e      	mov	r6, r9
   11316:	2420      	movs	r4, #32
   11318:	1ba4      	subs	r4, r4, r6
   1131a:	003e      	movs	r6, r7
   1131c:	40a6      	lsls	r6, r4
   1131e:	46a2      	mov	sl, r4
   11320:	46b0      	mov	r8, r6
   11322:	464c      	mov	r4, r9
   11324:	002e      	movs	r6, r5
   11326:	40e6      	lsrs	r6, r4
   11328:	46b4      	mov	ip, r6
   1132a:	4646      	mov	r6, r8
   1132c:	4664      	mov	r4, ip
   1132e:	4326      	orrs	r6, r4
   11330:	4654      	mov	r4, sl
   11332:	40a5      	lsls	r5, r4
   11334:	1e6c      	subs	r4, r5, #1
   11336:	41a5      	sbcs	r5, r4
   11338:	0034      	movs	r4, r6
   1133a:	432c      	orrs	r4, r5
   1133c:	464d      	mov	r5, r9
   1133e:	40ef      	lsrs	r7, r5
   11340:	1b0d      	subs	r5, r1, r4
   11342:	e028      	b.n	11396 <__aeabi_dsub+0x416>
   11344:	464a      	mov	r2, r9
   11346:	4643      	mov	r3, r8
   11348:	464d      	mov	r5, r9
   1134a:	431a      	orrs	r2, r3
   1134c:	d000      	beq.n	11350 <__aeabi_dsub+0x3d0>
   1134e:	e6a5      	b.n	1109c <__aeabi_dsub+0x11c>
   11350:	2300      	movs	r3, #0
   11352:	2400      	movs	r4, #0
   11354:	2500      	movs	r5, #0
   11356:	e6de      	b.n	11116 <__aeabi_dsub+0x196>
   11358:	2a1f      	cmp	r2, #31
   1135a:	dc5a      	bgt.n	11412 <__aeabi_dsub+0x492>
   1135c:	4666      	mov	r6, ip
   1135e:	2220      	movs	r2, #32
   11360:	1b92      	subs	r2, r2, r6
   11362:	0006      	movs	r6, r0
   11364:	4096      	lsls	r6, r2
   11366:	4691      	mov	r9, r2
   11368:	46b0      	mov	r8, r6
   1136a:	4662      	mov	r2, ip
   1136c:	000e      	movs	r6, r1
   1136e:	40d6      	lsrs	r6, r2
   11370:	4642      	mov	r2, r8
   11372:	4316      	orrs	r6, r2
   11374:	464a      	mov	r2, r9
   11376:	4091      	lsls	r1, r2
   11378:	1e4a      	subs	r2, r1, #1
   1137a:	4191      	sbcs	r1, r2
   1137c:	0002      	movs	r2, r0
   1137e:	4660      	mov	r0, ip
   11380:	4331      	orrs	r1, r6
   11382:	40c2      	lsrs	r2, r0
   11384:	e6e4      	b.n	11150 <__aeabi_dsub+0x1d0>
   11386:	003c      	movs	r4, r7
   11388:	432c      	orrs	r4, r5
   1138a:	d05a      	beq.n	11442 <__aeabi_dsub+0x4c2>
   1138c:	43f4      	mvns	r4, r6
   1138e:	46a1      	mov	r9, r4
   11390:	2c00      	cmp	r4, #0
   11392:	d152      	bne.n	1143a <__aeabi_dsub+0x4ba>
   11394:	1b4d      	subs	r5, r1, r5
   11396:	42a9      	cmp	r1, r5
   11398:	4189      	sbcs	r1, r1
   1139a:	1bc7      	subs	r7, r0, r7
   1139c:	4249      	negs	r1, r1
   1139e:	1a7f      	subs	r7, r7, r1
   113a0:	0014      	movs	r4, r2
   113a2:	469a      	mov	sl, r3
   113a4:	e675      	b.n	11092 <__aeabi_dsub+0x112>
   113a6:	4a9e      	ldr	r2, [pc, #632]	; (11620 <__aeabi_dsub+0x6a0>)
   113a8:	4294      	cmp	r4, r2
   113aa:	d000      	beq.n	113ae <__aeabi_dsub+0x42e>
   113ac:	e6c7      	b.n	1113e <__aeabi_dsub+0x1be>
   113ae:	e613      	b.n	10fd8 <__aeabi_dsub+0x58>
   113b0:	2200      	movs	r2, #0
   113b2:	e77f      	b.n	112b4 <__aeabi_dsub+0x334>
   113b4:	2000      	movs	r0, #0
   113b6:	e78f      	b.n	112d8 <__aeabi_dsub+0x358>
   113b8:	2c00      	cmp	r4, #0
   113ba:	d000      	beq.n	113be <__aeabi_dsub+0x43e>
   113bc:	e0c8      	b.n	11550 <__aeabi_dsub+0x5d0>
   113be:	003b      	movs	r3, r7
   113c0:	432b      	orrs	r3, r5
   113c2:	d100      	bne.n	113c6 <__aeabi_dsub+0x446>
   113c4:	e10f      	b.n	115e6 <__aeabi_dsub+0x666>
   113c6:	0003      	movs	r3, r0
   113c8:	430b      	orrs	r3, r1
   113ca:	d100      	bne.n	113ce <__aeabi_dsub+0x44e>
   113cc:	e604      	b.n	10fd8 <__aeabi_dsub+0x58>
   113ce:	1869      	adds	r1, r5, r1
   113d0:	42a9      	cmp	r1, r5
   113d2:	419b      	sbcs	r3, r3
   113d4:	183f      	adds	r7, r7, r0
   113d6:	425b      	negs	r3, r3
   113d8:	19df      	adds	r7, r3, r7
   113da:	023b      	lsls	r3, r7, #8
   113dc:	d400      	bmi.n	113e0 <__aeabi_dsub+0x460>
   113de:	e11a      	b.n	11616 <__aeabi_dsub+0x696>
   113e0:	4b90      	ldr	r3, [pc, #576]	; (11624 <__aeabi_dsub+0x6a4>)
   113e2:	000d      	movs	r5, r1
   113e4:	401f      	ands	r7, r3
   113e6:	4664      	mov	r4, ip
   113e8:	e5f6      	b.n	10fd8 <__aeabi_dsub+0x58>
   113ea:	469a      	mov	sl, r3
   113ec:	e689      	b.n	11102 <__aeabi_dsub+0x182>
   113ee:	003a      	movs	r2, r7
   113f0:	432a      	orrs	r2, r5
   113f2:	2c00      	cmp	r4, #0
   113f4:	d15c      	bne.n	114b0 <__aeabi_dsub+0x530>
   113f6:	2a00      	cmp	r2, #0
   113f8:	d175      	bne.n	114e6 <__aeabi_dsub+0x566>
   113fa:	0002      	movs	r2, r0
   113fc:	430a      	orrs	r2, r1
   113fe:	d100      	bne.n	11402 <__aeabi_dsub+0x482>
   11400:	e0ca      	b.n	11598 <__aeabi_dsub+0x618>
   11402:	0007      	movs	r7, r0
   11404:	000d      	movs	r5, r1
   11406:	469a      	mov	sl, r3
   11408:	e5e6      	b.n	10fd8 <__aeabi_dsub+0x58>
   1140a:	4664      	mov	r4, ip
   1140c:	2200      	movs	r2, #0
   1140e:	2500      	movs	r5, #0
   11410:	e681      	b.n	11116 <__aeabi_dsub+0x196>
   11412:	4662      	mov	r2, ip
   11414:	0006      	movs	r6, r0
   11416:	3a20      	subs	r2, #32
   11418:	40d6      	lsrs	r6, r2
   1141a:	4662      	mov	r2, ip
   1141c:	46b0      	mov	r8, r6
   1141e:	2a20      	cmp	r2, #32
   11420:	d100      	bne.n	11424 <__aeabi_dsub+0x4a4>
   11422:	e0b7      	b.n	11594 <__aeabi_dsub+0x614>
   11424:	2240      	movs	r2, #64	; 0x40
   11426:	4666      	mov	r6, ip
   11428:	1b92      	subs	r2, r2, r6
   1142a:	4090      	lsls	r0, r2
   1142c:	4301      	orrs	r1, r0
   1142e:	4642      	mov	r2, r8
   11430:	1e48      	subs	r0, r1, #1
   11432:	4181      	sbcs	r1, r0
   11434:	4311      	orrs	r1, r2
   11436:	2200      	movs	r2, #0
   11438:	e68a      	b.n	11150 <__aeabi_dsub+0x1d0>
   1143a:	4c79      	ldr	r4, [pc, #484]	; (11620 <__aeabi_dsub+0x6a0>)
   1143c:	42a2      	cmp	r2, r4
   1143e:	d000      	beq.n	11442 <__aeabi_dsub+0x4c2>
   11440:	e761      	b.n	11306 <__aeabi_dsub+0x386>
   11442:	0007      	movs	r7, r0
   11444:	000d      	movs	r5, r1
   11446:	0014      	movs	r4, r2
   11448:	469a      	mov	sl, r3
   1144a:	e5c5      	b.n	10fd8 <__aeabi_dsub+0x58>
   1144c:	2c00      	cmp	r4, #0
   1144e:	d141      	bne.n	114d4 <__aeabi_dsub+0x554>
   11450:	003c      	movs	r4, r7
   11452:	432c      	orrs	r4, r5
   11454:	d078      	beq.n	11548 <__aeabi_dsub+0x5c8>
   11456:	43f4      	mvns	r4, r6
   11458:	46a1      	mov	r9, r4
   1145a:	2c00      	cmp	r4, #0
   1145c:	d020      	beq.n	114a0 <__aeabi_dsub+0x520>
   1145e:	4c70      	ldr	r4, [pc, #448]	; (11620 <__aeabi_dsub+0x6a0>)
   11460:	42a2      	cmp	r2, r4
   11462:	d071      	beq.n	11548 <__aeabi_dsub+0x5c8>
   11464:	464c      	mov	r4, r9
   11466:	2c38      	cmp	r4, #56	; 0x38
   11468:	dd00      	ble.n	1146c <__aeabi_dsub+0x4ec>
   1146a:	e0b2      	b.n	115d2 <__aeabi_dsub+0x652>
   1146c:	2c1f      	cmp	r4, #31
   1146e:	dd00      	ble.n	11472 <__aeabi_dsub+0x4f2>
   11470:	e0bc      	b.n	115ec <__aeabi_dsub+0x66c>
   11472:	2620      	movs	r6, #32
   11474:	1b34      	subs	r4, r6, r4
   11476:	46a2      	mov	sl, r4
   11478:	003c      	movs	r4, r7
   1147a:	4656      	mov	r6, sl
   1147c:	40b4      	lsls	r4, r6
   1147e:	464e      	mov	r6, r9
   11480:	46a0      	mov	r8, r4
   11482:	002c      	movs	r4, r5
   11484:	40f4      	lsrs	r4, r6
   11486:	46a4      	mov	ip, r4
   11488:	4644      	mov	r4, r8
   1148a:	4666      	mov	r6, ip
   1148c:	4334      	orrs	r4, r6
   1148e:	46a4      	mov	ip, r4
   11490:	4654      	mov	r4, sl
   11492:	40a5      	lsls	r5, r4
   11494:	4664      	mov	r4, ip
   11496:	1e6e      	subs	r6, r5, #1
   11498:	41b5      	sbcs	r5, r6
   1149a:	4325      	orrs	r5, r4
   1149c:	464c      	mov	r4, r9
   1149e:	40e7      	lsrs	r7, r4
   114a0:	186d      	adds	r5, r5, r1
   114a2:	428d      	cmp	r5, r1
   114a4:	4189      	sbcs	r1, r1
   114a6:	183f      	adds	r7, r7, r0
   114a8:	4249      	negs	r1, r1
   114aa:	19cf      	adds	r7, r1, r7
   114ac:	0014      	movs	r4, r2
   114ae:	e656      	b.n	1115e <__aeabi_dsub+0x1de>
   114b0:	2a00      	cmp	r2, #0
   114b2:	d12f      	bne.n	11514 <__aeabi_dsub+0x594>
   114b4:	0002      	movs	r2, r0
   114b6:	430a      	orrs	r2, r1
   114b8:	d100      	bne.n	114bc <__aeabi_dsub+0x53c>
   114ba:	e084      	b.n	115c6 <__aeabi_dsub+0x646>
   114bc:	0007      	movs	r7, r0
   114be:	000d      	movs	r5, r1
   114c0:	469a      	mov	sl, r3
   114c2:	4c57      	ldr	r4, [pc, #348]	; (11620 <__aeabi_dsub+0x6a0>)
   114c4:	e588      	b.n	10fd8 <__aeabi_dsub+0x58>
   114c6:	433d      	orrs	r5, r7
   114c8:	1e6f      	subs	r7, r5, #1
   114ca:	41bd      	sbcs	r5, r7
   114cc:	b2ec      	uxtb	r4, r5
   114ce:	2700      	movs	r7, #0
   114d0:	1b0d      	subs	r5, r1, r4
   114d2:	e760      	b.n	11396 <__aeabi_dsub+0x416>
   114d4:	4c52      	ldr	r4, [pc, #328]	; (11620 <__aeabi_dsub+0x6a0>)
   114d6:	42a2      	cmp	r2, r4
   114d8:	d036      	beq.n	11548 <__aeabi_dsub+0x5c8>
   114da:	4274      	negs	r4, r6
   114dc:	2680      	movs	r6, #128	; 0x80
   114de:	0436      	lsls	r6, r6, #16
   114e0:	46a1      	mov	r9, r4
   114e2:	4337      	orrs	r7, r6
   114e4:	e7be      	b.n	11464 <__aeabi_dsub+0x4e4>
   114e6:	0002      	movs	r2, r0
   114e8:	430a      	orrs	r2, r1
   114ea:	d100      	bne.n	114ee <__aeabi_dsub+0x56e>
   114ec:	e574      	b.n	10fd8 <__aeabi_dsub+0x58>
   114ee:	1a6a      	subs	r2, r5, r1
   114f0:	4690      	mov	r8, r2
   114f2:	4545      	cmp	r5, r8
   114f4:	41b6      	sbcs	r6, r6
   114f6:	1a3a      	subs	r2, r7, r0
   114f8:	4276      	negs	r6, r6
   114fa:	1b92      	subs	r2, r2, r6
   114fc:	4694      	mov	ip, r2
   114fe:	0212      	lsls	r2, r2, #8
   11500:	d400      	bmi.n	11504 <__aeabi_dsub+0x584>
   11502:	e5f7      	b.n	110f4 <__aeabi_dsub+0x174>
   11504:	1b4d      	subs	r5, r1, r5
   11506:	42a9      	cmp	r1, r5
   11508:	4189      	sbcs	r1, r1
   1150a:	1bc7      	subs	r7, r0, r7
   1150c:	4249      	negs	r1, r1
   1150e:	1a7f      	subs	r7, r7, r1
   11510:	469a      	mov	sl, r3
   11512:	e561      	b.n	10fd8 <__aeabi_dsub+0x58>
   11514:	0002      	movs	r2, r0
   11516:	430a      	orrs	r2, r1
   11518:	d03a      	beq.n	11590 <__aeabi_dsub+0x610>
   1151a:	08ed      	lsrs	r5, r5, #3
   1151c:	077c      	lsls	r4, r7, #29
   1151e:	432c      	orrs	r4, r5
   11520:	2580      	movs	r5, #128	; 0x80
   11522:	08fa      	lsrs	r2, r7, #3
   11524:	032d      	lsls	r5, r5, #12
   11526:	422a      	tst	r2, r5
   11528:	d008      	beq.n	1153c <__aeabi_dsub+0x5bc>
   1152a:	08c7      	lsrs	r7, r0, #3
   1152c:	422f      	tst	r7, r5
   1152e:	d105      	bne.n	1153c <__aeabi_dsub+0x5bc>
   11530:	0745      	lsls	r5, r0, #29
   11532:	002c      	movs	r4, r5
   11534:	003a      	movs	r2, r7
   11536:	469a      	mov	sl, r3
   11538:	08c9      	lsrs	r1, r1, #3
   1153a:	430c      	orrs	r4, r1
   1153c:	0f67      	lsrs	r7, r4, #29
   1153e:	00d2      	lsls	r2, r2, #3
   11540:	00e5      	lsls	r5, r4, #3
   11542:	4317      	orrs	r7, r2
   11544:	4c36      	ldr	r4, [pc, #216]	; (11620 <__aeabi_dsub+0x6a0>)
   11546:	e547      	b.n	10fd8 <__aeabi_dsub+0x58>
   11548:	0007      	movs	r7, r0
   1154a:	000d      	movs	r5, r1
   1154c:	0014      	movs	r4, r2
   1154e:	e543      	b.n	10fd8 <__aeabi_dsub+0x58>
   11550:	003a      	movs	r2, r7
   11552:	432a      	orrs	r2, r5
   11554:	d043      	beq.n	115de <__aeabi_dsub+0x65e>
   11556:	0002      	movs	r2, r0
   11558:	430a      	orrs	r2, r1
   1155a:	d019      	beq.n	11590 <__aeabi_dsub+0x610>
   1155c:	08ed      	lsrs	r5, r5, #3
   1155e:	077c      	lsls	r4, r7, #29
   11560:	432c      	orrs	r4, r5
   11562:	2580      	movs	r5, #128	; 0x80
   11564:	08fa      	lsrs	r2, r7, #3
   11566:	032d      	lsls	r5, r5, #12
   11568:	422a      	tst	r2, r5
   1156a:	d007      	beq.n	1157c <__aeabi_dsub+0x5fc>
   1156c:	08c6      	lsrs	r6, r0, #3
   1156e:	422e      	tst	r6, r5
   11570:	d104      	bne.n	1157c <__aeabi_dsub+0x5fc>
   11572:	0747      	lsls	r7, r0, #29
   11574:	003c      	movs	r4, r7
   11576:	0032      	movs	r2, r6
   11578:	08c9      	lsrs	r1, r1, #3
   1157a:	430c      	orrs	r4, r1
   1157c:	00d7      	lsls	r7, r2, #3
   1157e:	0f62      	lsrs	r2, r4, #29
   11580:	00e5      	lsls	r5, r4, #3
   11582:	4317      	orrs	r7, r2
   11584:	469a      	mov	sl, r3
   11586:	4c26      	ldr	r4, [pc, #152]	; (11620 <__aeabi_dsub+0x6a0>)
   11588:	e526      	b.n	10fd8 <__aeabi_dsub+0x58>
   1158a:	2200      	movs	r2, #0
   1158c:	2500      	movs	r5, #0
   1158e:	e544      	b.n	1101a <__aeabi_dsub+0x9a>
   11590:	4c23      	ldr	r4, [pc, #140]	; (11620 <__aeabi_dsub+0x6a0>)
   11592:	e521      	b.n	10fd8 <__aeabi_dsub+0x58>
   11594:	2000      	movs	r0, #0
   11596:	e749      	b.n	1142c <__aeabi_dsub+0x4ac>
   11598:	2300      	movs	r3, #0
   1159a:	2500      	movs	r5, #0
   1159c:	e5bb      	b.n	11116 <__aeabi_dsub+0x196>
   1159e:	464c      	mov	r4, r9
   115a0:	003e      	movs	r6, r7
   115a2:	3c20      	subs	r4, #32
   115a4:	40e6      	lsrs	r6, r4
   115a6:	464c      	mov	r4, r9
   115a8:	46b4      	mov	ip, r6
   115aa:	2c20      	cmp	r4, #32
   115ac:	d031      	beq.n	11612 <__aeabi_dsub+0x692>
   115ae:	2440      	movs	r4, #64	; 0x40
   115b0:	464e      	mov	r6, r9
   115b2:	1ba6      	subs	r6, r4, r6
   115b4:	40b7      	lsls	r7, r6
   115b6:	433d      	orrs	r5, r7
   115b8:	1e6c      	subs	r4, r5, #1
   115ba:	41a5      	sbcs	r5, r4
   115bc:	4664      	mov	r4, ip
   115be:	432c      	orrs	r4, r5
   115c0:	2700      	movs	r7, #0
   115c2:	1b0d      	subs	r5, r1, r4
   115c4:	e6e7      	b.n	11396 <__aeabi_dsub+0x416>
   115c6:	2280      	movs	r2, #128	; 0x80
   115c8:	2300      	movs	r3, #0
   115ca:	0312      	lsls	r2, r2, #12
   115cc:	4c14      	ldr	r4, [pc, #80]	; (11620 <__aeabi_dsub+0x6a0>)
   115ce:	2500      	movs	r5, #0
   115d0:	e5a1      	b.n	11116 <__aeabi_dsub+0x196>
   115d2:	433d      	orrs	r5, r7
   115d4:	1e6f      	subs	r7, r5, #1
   115d6:	41bd      	sbcs	r5, r7
   115d8:	2700      	movs	r7, #0
   115da:	b2ed      	uxtb	r5, r5
   115dc:	e760      	b.n	114a0 <__aeabi_dsub+0x520>
   115de:	0007      	movs	r7, r0
   115e0:	000d      	movs	r5, r1
   115e2:	4c0f      	ldr	r4, [pc, #60]	; (11620 <__aeabi_dsub+0x6a0>)
   115e4:	e4f8      	b.n	10fd8 <__aeabi_dsub+0x58>
   115e6:	0007      	movs	r7, r0
   115e8:	000d      	movs	r5, r1
   115ea:	e4f5      	b.n	10fd8 <__aeabi_dsub+0x58>
   115ec:	464e      	mov	r6, r9
   115ee:	003c      	movs	r4, r7
   115f0:	3e20      	subs	r6, #32
   115f2:	40f4      	lsrs	r4, r6
   115f4:	46a0      	mov	r8, r4
   115f6:	464c      	mov	r4, r9
   115f8:	2c20      	cmp	r4, #32
   115fa:	d00e      	beq.n	1161a <__aeabi_dsub+0x69a>
   115fc:	2440      	movs	r4, #64	; 0x40
   115fe:	464e      	mov	r6, r9
   11600:	1ba4      	subs	r4, r4, r6
   11602:	40a7      	lsls	r7, r4
   11604:	433d      	orrs	r5, r7
   11606:	1e6f      	subs	r7, r5, #1
   11608:	41bd      	sbcs	r5, r7
   1160a:	4644      	mov	r4, r8
   1160c:	2700      	movs	r7, #0
   1160e:	4325      	orrs	r5, r4
   11610:	e746      	b.n	114a0 <__aeabi_dsub+0x520>
   11612:	2700      	movs	r7, #0
   11614:	e7cf      	b.n	115b6 <__aeabi_dsub+0x636>
   11616:	000d      	movs	r5, r1
   11618:	e573      	b.n	11102 <__aeabi_dsub+0x182>
   1161a:	2700      	movs	r7, #0
   1161c:	e7f2      	b.n	11604 <__aeabi_dsub+0x684>
   1161e:	46c0      	nop			; (mov r8, r8)
   11620:	000007ff 	.word	0x000007ff
   11624:	ff7fffff 	.word	0xff7fffff

00011628 <__aeabi_dcmpun>:
   11628:	b570      	push	{r4, r5, r6, lr}
   1162a:	4e0e      	ldr	r6, [pc, #56]	; (11664 <__aeabi_dcmpun+0x3c>)
   1162c:	030c      	lsls	r4, r1, #12
   1162e:	031d      	lsls	r5, r3, #12
   11630:	0049      	lsls	r1, r1, #1
   11632:	005b      	lsls	r3, r3, #1
   11634:	0b24      	lsrs	r4, r4, #12
   11636:	0d49      	lsrs	r1, r1, #21
   11638:	0b2d      	lsrs	r5, r5, #12
   1163a:	0d5b      	lsrs	r3, r3, #21
   1163c:	42b1      	cmp	r1, r6
   1163e:	d004      	beq.n	1164a <__aeabi_dcmpun+0x22>
   11640:	4908      	ldr	r1, [pc, #32]	; (11664 <__aeabi_dcmpun+0x3c>)
   11642:	2000      	movs	r0, #0
   11644:	428b      	cmp	r3, r1
   11646:	d008      	beq.n	1165a <__aeabi_dcmpun+0x32>
   11648:	bd70      	pop	{r4, r5, r6, pc}
   1164a:	4304      	orrs	r4, r0
   1164c:	2001      	movs	r0, #1
   1164e:	2c00      	cmp	r4, #0
   11650:	d1fa      	bne.n	11648 <__aeabi_dcmpun+0x20>
   11652:	4904      	ldr	r1, [pc, #16]	; (11664 <__aeabi_dcmpun+0x3c>)
   11654:	2000      	movs	r0, #0
   11656:	428b      	cmp	r3, r1
   11658:	d1f6      	bne.n	11648 <__aeabi_dcmpun+0x20>
   1165a:	4315      	orrs	r5, r2
   1165c:	0028      	movs	r0, r5
   1165e:	1e45      	subs	r5, r0, #1
   11660:	41a8      	sbcs	r0, r5
   11662:	e7f1      	b.n	11648 <__aeabi_dcmpun+0x20>
   11664:	000007ff 	.word	0x000007ff

00011668 <__aeabi_d2iz>:
   11668:	030b      	lsls	r3, r1, #12
   1166a:	b530      	push	{r4, r5, lr}
   1166c:	4d13      	ldr	r5, [pc, #76]	; (116bc <__aeabi_d2iz+0x54>)
   1166e:	0b1a      	lsrs	r2, r3, #12
   11670:	004b      	lsls	r3, r1, #1
   11672:	0d5b      	lsrs	r3, r3, #21
   11674:	0fc9      	lsrs	r1, r1, #31
   11676:	2400      	movs	r4, #0
   11678:	42ab      	cmp	r3, r5
   1167a:	dd11      	ble.n	116a0 <__aeabi_d2iz+0x38>
   1167c:	4c10      	ldr	r4, [pc, #64]	; (116c0 <__aeabi_d2iz+0x58>)
   1167e:	42a3      	cmp	r3, r4
   11680:	dc10      	bgt.n	116a4 <__aeabi_d2iz+0x3c>
   11682:	2480      	movs	r4, #128	; 0x80
   11684:	0364      	lsls	r4, r4, #13
   11686:	4322      	orrs	r2, r4
   11688:	4c0e      	ldr	r4, [pc, #56]	; (116c4 <__aeabi_d2iz+0x5c>)
   1168a:	1ae4      	subs	r4, r4, r3
   1168c:	2c1f      	cmp	r4, #31
   1168e:	dd0c      	ble.n	116aa <__aeabi_d2iz+0x42>
   11690:	480d      	ldr	r0, [pc, #52]	; (116c8 <__aeabi_d2iz+0x60>)
   11692:	1ac3      	subs	r3, r0, r3
   11694:	40da      	lsrs	r2, r3
   11696:	0013      	movs	r3, r2
   11698:	425c      	negs	r4, r3
   1169a:	2900      	cmp	r1, #0
   1169c:	d100      	bne.n	116a0 <__aeabi_d2iz+0x38>
   1169e:	001c      	movs	r4, r3
   116a0:	0020      	movs	r0, r4
   116a2:	bd30      	pop	{r4, r5, pc}
   116a4:	4b09      	ldr	r3, [pc, #36]	; (116cc <__aeabi_d2iz+0x64>)
   116a6:	18cc      	adds	r4, r1, r3
   116a8:	e7fa      	b.n	116a0 <__aeabi_d2iz+0x38>
   116aa:	40e0      	lsrs	r0, r4
   116ac:	4c08      	ldr	r4, [pc, #32]	; (116d0 <__aeabi_d2iz+0x68>)
   116ae:	46a4      	mov	ip, r4
   116b0:	4463      	add	r3, ip
   116b2:	409a      	lsls	r2, r3
   116b4:	0013      	movs	r3, r2
   116b6:	4303      	orrs	r3, r0
   116b8:	e7ee      	b.n	11698 <__aeabi_d2iz+0x30>
   116ba:	46c0      	nop			; (mov r8, r8)
   116bc:	000003fe 	.word	0x000003fe
   116c0:	0000041d 	.word	0x0000041d
   116c4:	00000433 	.word	0x00000433
   116c8:	00000413 	.word	0x00000413
   116cc:	7fffffff 	.word	0x7fffffff
   116d0:	fffffbed 	.word	0xfffffbed

000116d4 <__aeabi_i2d>:
   116d4:	b570      	push	{r4, r5, r6, lr}
   116d6:	2800      	cmp	r0, #0
   116d8:	d030      	beq.n	1173c <__aeabi_i2d+0x68>
   116da:	17c3      	asrs	r3, r0, #31
   116dc:	18c4      	adds	r4, r0, r3
   116de:	405c      	eors	r4, r3
   116e0:	0fc5      	lsrs	r5, r0, #31
   116e2:	0020      	movs	r0, r4
   116e4:	f000 f838 	bl	11758 <__clzsi2>
   116e8:	4b17      	ldr	r3, [pc, #92]	; (11748 <__aeabi_i2d+0x74>)
   116ea:	4a18      	ldr	r2, [pc, #96]	; (1174c <__aeabi_i2d+0x78>)
   116ec:	1a1b      	subs	r3, r3, r0
   116ee:	1ad2      	subs	r2, r2, r3
   116f0:	2a1f      	cmp	r2, #31
   116f2:	dd18      	ble.n	11726 <__aeabi_i2d+0x52>
   116f4:	4a16      	ldr	r2, [pc, #88]	; (11750 <__aeabi_i2d+0x7c>)
   116f6:	1ad2      	subs	r2, r2, r3
   116f8:	4094      	lsls	r4, r2
   116fa:	2200      	movs	r2, #0
   116fc:	0324      	lsls	r4, r4, #12
   116fe:	055b      	lsls	r3, r3, #21
   11700:	0b24      	lsrs	r4, r4, #12
   11702:	0d5b      	lsrs	r3, r3, #21
   11704:	2100      	movs	r1, #0
   11706:	0010      	movs	r0, r2
   11708:	0324      	lsls	r4, r4, #12
   1170a:	0d0a      	lsrs	r2, r1, #20
   1170c:	0512      	lsls	r2, r2, #20
   1170e:	0b24      	lsrs	r4, r4, #12
   11710:	4314      	orrs	r4, r2
   11712:	4a10      	ldr	r2, [pc, #64]	; (11754 <__aeabi_i2d+0x80>)
   11714:	051b      	lsls	r3, r3, #20
   11716:	4014      	ands	r4, r2
   11718:	431c      	orrs	r4, r3
   1171a:	0064      	lsls	r4, r4, #1
   1171c:	07ed      	lsls	r5, r5, #31
   1171e:	0864      	lsrs	r4, r4, #1
   11720:	432c      	orrs	r4, r5
   11722:	0021      	movs	r1, r4
   11724:	bd70      	pop	{r4, r5, r6, pc}
   11726:	0021      	movs	r1, r4
   11728:	4091      	lsls	r1, r2
   1172a:	000a      	movs	r2, r1
   1172c:	210b      	movs	r1, #11
   1172e:	1a08      	subs	r0, r1, r0
   11730:	40c4      	lsrs	r4, r0
   11732:	055b      	lsls	r3, r3, #21
   11734:	0324      	lsls	r4, r4, #12
   11736:	0b24      	lsrs	r4, r4, #12
   11738:	0d5b      	lsrs	r3, r3, #21
   1173a:	e7e3      	b.n	11704 <__aeabi_i2d+0x30>
   1173c:	2500      	movs	r5, #0
   1173e:	2300      	movs	r3, #0
   11740:	2400      	movs	r4, #0
   11742:	2200      	movs	r2, #0
   11744:	e7de      	b.n	11704 <__aeabi_i2d+0x30>
   11746:	46c0      	nop			; (mov r8, r8)
   11748:	0000041e 	.word	0x0000041e
   1174c:	00000433 	.word	0x00000433
   11750:	00000413 	.word	0x00000413
   11754:	800fffff 	.word	0x800fffff

00011758 <__clzsi2>:
   11758:	211c      	movs	r1, #28
   1175a:	2301      	movs	r3, #1
   1175c:	041b      	lsls	r3, r3, #16
   1175e:	4298      	cmp	r0, r3
   11760:	d301      	bcc.n	11766 <__clzsi2+0xe>
   11762:	0c00      	lsrs	r0, r0, #16
   11764:	3910      	subs	r1, #16
   11766:	0a1b      	lsrs	r3, r3, #8
   11768:	4298      	cmp	r0, r3
   1176a:	d301      	bcc.n	11770 <__clzsi2+0x18>
   1176c:	0a00      	lsrs	r0, r0, #8
   1176e:	3908      	subs	r1, #8
   11770:	091b      	lsrs	r3, r3, #4
   11772:	4298      	cmp	r0, r3
   11774:	d301      	bcc.n	1177a <__clzsi2+0x22>
   11776:	0900      	lsrs	r0, r0, #4
   11778:	3904      	subs	r1, #4
   1177a:	a202      	add	r2, pc, #8	; (adr r2, 11784 <__clzsi2+0x2c>)
   1177c:	5c10      	ldrb	r0, [r2, r0]
   1177e:	1840      	adds	r0, r0, r1
   11780:	4770      	bx	lr
   11782:	46c0      	nop			; (mov r8, r8)
   11784:	02020304 	.word	0x02020304
   11788:	01010101 	.word	0x01010101
	...

00011794 <__errno>:
   11794:	4b01      	ldr	r3, [pc, #4]	; (1179c <__errno+0x8>)
   11796:	6818      	ldr	r0, [r3, #0]
   11798:	4770      	bx	lr
   1179a:	46c0      	nop			; (mov r8, r8)
   1179c:	200001a0 	.word	0x200001a0

000117a0 <__libc_init_array>:
   117a0:	4b0e      	ldr	r3, [pc, #56]	; (117dc <__libc_init_array+0x3c>)
   117a2:	b570      	push	{r4, r5, r6, lr}
   117a4:	2500      	movs	r5, #0
   117a6:	001e      	movs	r6, r3
   117a8:	4c0d      	ldr	r4, [pc, #52]	; (117e0 <__libc_init_array+0x40>)
   117aa:	1ae4      	subs	r4, r4, r3
   117ac:	10a4      	asrs	r4, r4, #2
   117ae:	42a5      	cmp	r5, r4
   117b0:	d004      	beq.n	117bc <__libc_init_array+0x1c>
   117b2:	00ab      	lsls	r3, r5, #2
   117b4:	58f3      	ldr	r3, [r6, r3]
   117b6:	4798      	blx	r3
   117b8:	3501      	adds	r5, #1
   117ba:	e7f8      	b.n	117ae <__libc_init_array+0xe>
   117bc:	f00a fcea 	bl	1c194 <_init>
   117c0:	4b08      	ldr	r3, [pc, #32]	; (117e4 <__libc_init_array+0x44>)
   117c2:	2500      	movs	r5, #0
   117c4:	001e      	movs	r6, r3
   117c6:	4c08      	ldr	r4, [pc, #32]	; (117e8 <__libc_init_array+0x48>)
   117c8:	1ae4      	subs	r4, r4, r3
   117ca:	10a4      	asrs	r4, r4, #2
   117cc:	42a5      	cmp	r5, r4
   117ce:	d004      	beq.n	117da <__libc_init_array+0x3a>
   117d0:	00ab      	lsls	r3, r5, #2
   117d2:	58f3      	ldr	r3, [r6, r3]
   117d4:	4798      	blx	r3
   117d6:	3501      	adds	r5, #1
   117d8:	e7f8      	b.n	117cc <__libc_init_array+0x2c>
   117da:	bd70      	pop	{r4, r5, r6, pc}
   117dc:	0001c1a0 	.word	0x0001c1a0
   117e0:	0001c1a0 	.word	0x0001c1a0
   117e4:	0001c1a0 	.word	0x0001c1a0
   117e8:	0001c1a4 	.word	0x0001c1a4

000117ec <malloc>:
   117ec:	b510      	push	{r4, lr}
   117ee:	4b03      	ldr	r3, [pc, #12]	; (117fc <malloc+0x10>)
   117f0:	0001      	movs	r1, r0
   117f2:	6818      	ldr	r0, [r3, #0]
   117f4:	f000 f874 	bl	118e0 <_malloc_r>
   117f8:	bd10      	pop	{r4, pc}
   117fa:	46c0      	nop			; (mov r8, r8)
   117fc:	200001a0 	.word	0x200001a0

00011800 <free>:
   11800:	b510      	push	{r4, lr}
   11802:	4b03      	ldr	r3, [pc, #12]	; (11810 <free+0x10>)
   11804:	0001      	movs	r1, r0
   11806:	6818      	ldr	r0, [r3, #0]
   11808:	f000 f824 	bl	11854 <_free_r>
   1180c:	bd10      	pop	{r4, pc}
   1180e:	46c0      	nop			; (mov r8, r8)
   11810:	200001a0 	.word	0x200001a0

00011814 <memcmp>:
   11814:	b530      	push	{r4, r5, lr}
   11816:	2400      	movs	r4, #0
   11818:	42a2      	cmp	r2, r4
   1181a:	d008      	beq.n	1182e <memcmp+0x1a>
   1181c:	5d03      	ldrb	r3, [r0, r4]
   1181e:	1c65      	adds	r5, r4, #1
   11820:	5d0c      	ldrb	r4, [r1, r4]
   11822:	42a3      	cmp	r3, r4
   11824:	d001      	beq.n	1182a <memcmp+0x16>
   11826:	1b18      	subs	r0, r3, r4
   11828:	e002      	b.n	11830 <memcmp+0x1c>
   1182a:	002c      	movs	r4, r5
   1182c:	e7f4      	b.n	11818 <memcmp+0x4>
   1182e:	2000      	movs	r0, #0
   11830:	bd30      	pop	{r4, r5, pc}

00011832 <memcpy>:
   11832:	2300      	movs	r3, #0
   11834:	b510      	push	{r4, lr}
   11836:	429a      	cmp	r2, r3
   11838:	d003      	beq.n	11842 <memcpy+0x10>
   1183a:	5ccc      	ldrb	r4, [r1, r3]
   1183c:	54c4      	strb	r4, [r0, r3]
   1183e:	3301      	adds	r3, #1
   11840:	e7f9      	b.n	11836 <memcpy+0x4>
   11842:	bd10      	pop	{r4, pc}

00011844 <memset>:
   11844:	0003      	movs	r3, r0
   11846:	1882      	adds	r2, r0, r2
   11848:	4293      	cmp	r3, r2
   1184a:	d002      	beq.n	11852 <memset+0xe>
   1184c:	7019      	strb	r1, [r3, #0]
   1184e:	3301      	adds	r3, #1
   11850:	e7fa      	b.n	11848 <memset+0x4>
   11852:	4770      	bx	lr

00011854 <_free_r>:
   11854:	b530      	push	{r4, r5, lr}
   11856:	2900      	cmp	r1, #0
   11858:	d03e      	beq.n	118d8 <_free_r+0x84>
   1185a:	3904      	subs	r1, #4
   1185c:	680b      	ldr	r3, [r1, #0]
   1185e:	2b00      	cmp	r3, #0
   11860:	da00      	bge.n	11864 <_free_r+0x10>
   11862:	18c9      	adds	r1, r1, r3
   11864:	4a1d      	ldr	r2, [pc, #116]	; (118dc <_free_r+0x88>)
   11866:	6813      	ldr	r3, [r2, #0]
   11868:	0014      	movs	r4, r2
   1186a:	2b00      	cmp	r3, #0
   1186c:	d102      	bne.n	11874 <_free_r+0x20>
   1186e:	604b      	str	r3, [r1, #4]
   11870:	6011      	str	r1, [r2, #0]
   11872:	e031      	b.n	118d8 <_free_r+0x84>
   11874:	428b      	cmp	r3, r1
   11876:	d90d      	bls.n	11894 <_free_r+0x40>
   11878:	680a      	ldr	r2, [r1, #0]
   1187a:	1888      	adds	r0, r1, r2
   1187c:	4283      	cmp	r3, r0
   1187e:	d103      	bne.n	11888 <_free_r+0x34>
   11880:	6818      	ldr	r0, [r3, #0]
   11882:	685b      	ldr	r3, [r3, #4]
   11884:	1882      	adds	r2, r0, r2
   11886:	600a      	str	r2, [r1, #0]
   11888:	604b      	str	r3, [r1, #4]
   1188a:	6021      	str	r1, [r4, #0]
   1188c:	e024      	b.n	118d8 <_free_r+0x84>
   1188e:	428a      	cmp	r2, r1
   11890:	d803      	bhi.n	1189a <_free_r+0x46>
   11892:	0013      	movs	r3, r2
   11894:	685a      	ldr	r2, [r3, #4]
   11896:	2a00      	cmp	r2, #0
   11898:	d1f9      	bne.n	1188e <_free_r+0x3a>
   1189a:	681d      	ldr	r5, [r3, #0]
   1189c:	195c      	adds	r4, r3, r5
   1189e:	428c      	cmp	r4, r1
   118a0:	d10b      	bne.n	118ba <_free_r+0x66>
   118a2:	6809      	ldr	r1, [r1, #0]
   118a4:	1869      	adds	r1, r5, r1
   118a6:	1858      	adds	r0, r3, r1
   118a8:	6019      	str	r1, [r3, #0]
   118aa:	4282      	cmp	r2, r0
   118ac:	d114      	bne.n	118d8 <_free_r+0x84>
   118ae:	6810      	ldr	r0, [r2, #0]
   118b0:	6852      	ldr	r2, [r2, #4]
   118b2:	1841      	adds	r1, r0, r1
   118b4:	6019      	str	r1, [r3, #0]
   118b6:	605a      	str	r2, [r3, #4]
   118b8:	e00e      	b.n	118d8 <_free_r+0x84>
   118ba:	428c      	cmp	r4, r1
   118bc:	d902      	bls.n	118c4 <_free_r+0x70>
   118be:	230c      	movs	r3, #12
   118c0:	6003      	str	r3, [r0, #0]
   118c2:	e009      	b.n	118d8 <_free_r+0x84>
   118c4:	6808      	ldr	r0, [r1, #0]
   118c6:	180c      	adds	r4, r1, r0
   118c8:	42a2      	cmp	r2, r4
   118ca:	d103      	bne.n	118d4 <_free_r+0x80>
   118cc:	6814      	ldr	r4, [r2, #0]
   118ce:	6852      	ldr	r2, [r2, #4]
   118d0:	1820      	adds	r0, r4, r0
   118d2:	6008      	str	r0, [r1, #0]
   118d4:	604a      	str	r2, [r1, #4]
   118d6:	6059      	str	r1, [r3, #4]
   118d8:	bd30      	pop	{r4, r5, pc}
   118da:	46c0      	nop			; (mov r8, r8)
   118dc:	20001a40 	.word	0x20001a40

000118e0 <_malloc_r>:
   118e0:	2303      	movs	r3, #3
   118e2:	b570      	push	{r4, r5, r6, lr}
   118e4:	1ccd      	adds	r5, r1, #3
   118e6:	439d      	bics	r5, r3
   118e8:	3508      	adds	r5, #8
   118ea:	0006      	movs	r6, r0
   118ec:	2d0c      	cmp	r5, #12
   118ee:	d201      	bcs.n	118f4 <_malloc_r+0x14>
   118f0:	250c      	movs	r5, #12
   118f2:	e005      	b.n	11900 <_malloc_r+0x20>
   118f4:	2d00      	cmp	r5, #0
   118f6:	da03      	bge.n	11900 <_malloc_r+0x20>
   118f8:	230c      	movs	r3, #12
   118fa:	2000      	movs	r0, #0
   118fc:	6033      	str	r3, [r6, #0]
   118fe:	e040      	b.n	11982 <_malloc_r+0xa2>
   11900:	42a9      	cmp	r1, r5
   11902:	d8f9      	bhi.n	118f8 <_malloc_r+0x18>
   11904:	4b1f      	ldr	r3, [pc, #124]	; (11984 <_malloc_r+0xa4>)
   11906:	681c      	ldr	r4, [r3, #0]
   11908:	001a      	movs	r2, r3
   1190a:	0021      	movs	r1, r4
   1190c:	2900      	cmp	r1, #0
   1190e:	d013      	beq.n	11938 <_malloc_r+0x58>
   11910:	680b      	ldr	r3, [r1, #0]
   11912:	1b5b      	subs	r3, r3, r5
   11914:	d40d      	bmi.n	11932 <_malloc_r+0x52>
   11916:	2b0b      	cmp	r3, #11
   11918:	d902      	bls.n	11920 <_malloc_r+0x40>
   1191a:	600b      	str	r3, [r1, #0]
   1191c:	18cc      	adds	r4, r1, r3
   1191e:	e01e      	b.n	1195e <_malloc_r+0x7e>
   11920:	428c      	cmp	r4, r1
   11922:	d102      	bne.n	1192a <_malloc_r+0x4a>
   11924:	6863      	ldr	r3, [r4, #4]
   11926:	6013      	str	r3, [r2, #0]
   11928:	e01a      	b.n	11960 <_malloc_r+0x80>
   1192a:	684b      	ldr	r3, [r1, #4]
   1192c:	6063      	str	r3, [r4, #4]
   1192e:	000c      	movs	r4, r1
   11930:	e016      	b.n	11960 <_malloc_r+0x80>
   11932:	000c      	movs	r4, r1
   11934:	6849      	ldr	r1, [r1, #4]
   11936:	e7e9      	b.n	1190c <_malloc_r+0x2c>
   11938:	4c13      	ldr	r4, [pc, #76]	; (11988 <_malloc_r+0xa8>)
   1193a:	6823      	ldr	r3, [r4, #0]
   1193c:	2b00      	cmp	r3, #0
   1193e:	d103      	bne.n	11948 <_malloc_r+0x68>
   11940:	0030      	movs	r0, r6
   11942:	f000 f8bd 	bl	11ac0 <_sbrk_r>
   11946:	6020      	str	r0, [r4, #0]
   11948:	0029      	movs	r1, r5
   1194a:	0030      	movs	r0, r6
   1194c:	f000 f8b8 	bl	11ac0 <_sbrk_r>
   11950:	1c43      	adds	r3, r0, #1
   11952:	d0d1      	beq.n	118f8 <_malloc_r+0x18>
   11954:	2303      	movs	r3, #3
   11956:	1cc4      	adds	r4, r0, #3
   11958:	439c      	bics	r4, r3
   1195a:	42a0      	cmp	r0, r4
   1195c:	d10a      	bne.n	11974 <_malloc_r+0x94>
   1195e:	6025      	str	r5, [r4, #0]
   11960:	0020      	movs	r0, r4
   11962:	2207      	movs	r2, #7
   11964:	300b      	adds	r0, #11
   11966:	1d23      	adds	r3, r4, #4
   11968:	4390      	bics	r0, r2
   1196a:	1ac3      	subs	r3, r0, r3
   1196c:	d009      	beq.n	11982 <_malloc_r+0xa2>
   1196e:	425a      	negs	r2, r3
   11970:	50e2      	str	r2, [r4, r3]
   11972:	e006      	b.n	11982 <_malloc_r+0xa2>
   11974:	1a21      	subs	r1, r4, r0
   11976:	0030      	movs	r0, r6
   11978:	f000 f8a2 	bl	11ac0 <_sbrk_r>
   1197c:	1c43      	adds	r3, r0, #1
   1197e:	d1ee      	bne.n	1195e <_malloc_r+0x7e>
   11980:	e7ba      	b.n	118f8 <_malloc_r+0x18>
   11982:	bd70      	pop	{r4, r5, r6, pc}
   11984:	20001a40 	.word	0x20001a40
   11988:	20001a3c 	.word	0x20001a3c

0001198c <iprintf>:
   1198c:	b40f      	push	{r0, r1, r2, r3}
   1198e:	4b0b      	ldr	r3, [pc, #44]	; (119bc <iprintf+0x30>)
   11990:	b513      	push	{r0, r1, r4, lr}
   11992:	681c      	ldr	r4, [r3, #0]
   11994:	2c00      	cmp	r4, #0
   11996:	d005      	beq.n	119a4 <iprintf+0x18>
   11998:	69a3      	ldr	r3, [r4, #24]
   1199a:	2b00      	cmp	r3, #0
   1199c:	d102      	bne.n	119a4 <iprintf+0x18>
   1199e:	0020      	movs	r0, r4
   119a0:	f000 fbea 	bl	12178 <__sinit>
   119a4:	ab05      	add	r3, sp, #20
   119a6:	9a04      	ldr	r2, [sp, #16]
   119a8:	68a1      	ldr	r1, [r4, #8]
   119aa:	0020      	movs	r0, r4
   119ac:	9301      	str	r3, [sp, #4]
   119ae:	f000 fe77 	bl	126a0 <_vfiprintf_r>
   119b2:	bc16      	pop	{r1, r2, r4}
   119b4:	bc08      	pop	{r3}
   119b6:	b004      	add	sp, #16
   119b8:	4718      	bx	r3
   119ba:	46c0      	nop			; (mov r8, r8)
   119bc:	200001a0 	.word	0x200001a0

000119c0 <putchar>:
   119c0:	4b08      	ldr	r3, [pc, #32]	; (119e4 <putchar+0x24>)
   119c2:	b570      	push	{r4, r5, r6, lr}
   119c4:	681c      	ldr	r4, [r3, #0]
   119c6:	0005      	movs	r5, r0
   119c8:	2c00      	cmp	r4, #0
   119ca:	d005      	beq.n	119d8 <putchar+0x18>
   119cc:	69a3      	ldr	r3, [r4, #24]
   119ce:	2b00      	cmp	r3, #0
   119d0:	d102      	bne.n	119d8 <putchar+0x18>
   119d2:	0020      	movs	r0, r4
   119d4:	f000 fbd0 	bl	12178 <__sinit>
   119d8:	0029      	movs	r1, r5
   119da:	68a2      	ldr	r2, [r4, #8]
   119dc:	0020      	movs	r0, r4
   119de:	f001 f90b 	bl	12bf8 <_putc_r>
   119e2:	bd70      	pop	{r4, r5, r6, pc}
   119e4:	200001a0 	.word	0x200001a0

000119e8 <_puts_r>:
   119e8:	b570      	push	{r4, r5, r6, lr}
   119ea:	0005      	movs	r5, r0
   119ec:	000e      	movs	r6, r1
   119ee:	2800      	cmp	r0, #0
   119f0:	d004      	beq.n	119fc <_puts_r+0x14>
   119f2:	6983      	ldr	r3, [r0, #24]
   119f4:	2b00      	cmp	r3, #0
   119f6:	d101      	bne.n	119fc <_puts_r+0x14>
   119f8:	f000 fbbe 	bl	12178 <__sinit>
   119fc:	69ab      	ldr	r3, [r5, #24]
   119fe:	68ac      	ldr	r4, [r5, #8]
   11a00:	2b00      	cmp	r3, #0
   11a02:	d102      	bne.n	11a0a <_puts_r+0x22>
   11a04:	0028      	movs	r0, r5
   11a06:	f000 fbb7 	bl	12178 <__sinit>
   11a0a:	4b25      	ldr	r3, [pc, #148]	; (11aa0 <_puts_r+0xb8>)
   11a0c:	429c      	cmp	r4, r3
   11a0e:	d101      	bne.n	11a14 <_puts_r+0x2c>
   11a10:	686c      	ldr	r4, [r5, #4]
   11a12:	e008      	b.n	11a26 <_puts_r+0x3e>
   11a14:	4b23      	ldr	r3, [pc, #140]	; (11aa4 <_puts_r+0xbc>)
   11a16:	429c      	cmp	r4, r3
   11a18:	d101      	bne.n	11a1e <_puts_r+0x36>
   11a1a:	68ac      	ldr	r4, [r5, #8]
   11a1c:	e003      	b.n	11a26 <_puts_r+0x3e>
   11a1e:	4b22      	ldr	r3, [pc, #136]	; (11aa8 <_puts_r+0xc0>)
   11a20:	429c      	cmp	r4, r3
   11a22:	d100      	bne.n	11a26 <_puts_r+0x3e>
   11a24:	68ec      	ldr	r4, [r5, #12]
   11a26:	89a3      	ldrh	r3, [r4, #12]
   11a28:	071b      	lsls	r3, r3, #28
   11a2a:	d502      	bpl.n	11a32 <_puts_r+0x4a>
   11a2c:	6923      	ldr	r3, [r4, #16]
   11a2e:	2b00      	cmp	r3, #0
   11a30:	d111      	bne.n	11a56 <_puts_r+0x6e>
   11a32:	0021      	movs	r1, r4
   11a34:	0028      	movs	r0, r5
   11a36:	f000 fa23 	bl	11e80 <__swsetup_r>
   11a3a:	2800      	cmp	r0, #0
   11a3c:	d00b      	beq.n	11a56 <_puts_r+0x6e>
   11a3e:	2001      	movs	r0, #1
   11a40:	4240      	negs	r0, r0
   11a42:	e02b      	b.n	11a9c <_puts_r+0xb4>
   11a44:	3b01      	subs	r3, #1
   11a46:	3601      	adds	r6, #1
   11a48:	60a3      	str	r3, [r4, #8]
   11a4a:	2b00      	cmp	r3, #0
   11a4c:	db08      	blt.n	11a60 <_puts_r+0x78>
   11a4e:	6823      	ldr	r3, [r4, #0]
   11a50:	1c5a      	adds	r2, r3, #1
   11a52:	6022      	str	r2, [r4, #0]
   11a54:	7019      	strb	r1, [r3, #0]
   11a56:	7831      	ldrb	r1, [r6, #0]
   11a58:	68a3      	ldr	r3, [r4, #8]
   11a5a:	2900      	cmp	r1, #0
   11a5c:	d1f2      	bne.n	11a44 <_puts_r+0x5c>
   11a5e:	e00b      	b.n	11a78 <_puts_r+0x90>
   11a60:	69a2      	ldr	r2, [r4, #24]
   11a62:	4293      	cmp	r3, r2
   11a64:	db01      	blt.n	11a6a <_puts_r+0x82>
   11a66:	290a      	cmp	r1, #10
   11a68:	d1f1      	bne.n	11a4e <_puts_r+0x66>
   11a6a:	0022      	movs	r2, r4
   11a6c:	0028      	movs	r0, r5
   11a6e:	f000 f99b 	bl	11da8 <__swbuf_r>
   11a72:	1c43      	adds	r3, r0, #1
   11a74:	d1ef      	bne.n	11a56 <_puts_r+0x6e>
   11a76:	e7e2      	b.n	11a3e <_puts_r+0x56>
   11a78:	3b01      	subs	r3, #1
   11a7a:	60a3      	str	r3, [r4, #8]
   11a7c:	2b00      	cmp	r3, #0
   11a7e:	da08      	bge.n	11a92 <_puts_r+0xaa>
   11a80:	0022      	movs	r2, r4
   11a82:	310a      	adds	r1, #10
   11a84:	0028      	movs	r0, r5
   11a86:	f000 f98f 	bl	11da8 <__swbuf_r>
   11a8a:	1c43      	adds	r3, r0, #1
   11a8c:	d0d7      	beq.n	11a3e <_puts_r+0x56>
   11a8e:	200a      	movs	r0, #10
   11a90:	e004      	b.n	11a9c <_puts_r+0xb4>
   11a92:	200a      	movs	r0, #10
   11a94:	6823      	ldr	r3, [r4, #0]
   11a96:	1c5a      	adds	r2, r3, #1
   11a98:	6022      	str	r2, [r4, #0]
   11a9a:	7018      	strb	r0, [r3, #0]
   11a9c:	bd70      	pop	{r4, r5, r6, pc}
   11a9e:	46c0      	nop			; (mov r8, r8)
   11aa0:	0001c100 	.word	0x0001c100
   11aa4:	0001c120 	.word	0x0001c120
   11aa8:	0001c140 	.word	0x0001c140

00011aac <puts>:
   11aac:	b510      	push	{r4, lr}
   11aae:	4b03      	ldr	r3, [pc, #12]	; (11abc <puts+0x10>)
   11ab0:	0001      	movs	r1, r0
   11ab2:	6818      	ldr	r0, [r3, #0]
   11ab4:	f7ff ff98 	bl	119e8 <_puts_r>
   11ab8:	bd10      	pop	{r4, pc}
   11aba:	46c0      	nop			; (mov r8, r8)
   11abc:	200001a0 	.word	0x200001a0

00011ac0 <_sbrk_r>:
   11ac0:	2300      	movs	r3, #0
   11ac2:	b570      	push	{r4, r5, r6, lr}
   11ac4:	4c06      	ldr	r4, [pc, #24]	; (11ae0 <_sbrk_r+0x20>)
   11ac6:	0005      	movs	r5, r0
   11ac8:	0008      	movs	r0, r1
   11aca:	6023      	str	r3, [r4, #0]
   11acc:	f7fc fa8a 	bl	dfe4 <_sbrk>
   11ad0:	1c43      	adds	r3, r0, #1
   11ad2:	d103      	bne.n	11adc <_sbrk_r+0x1c>
   11ad4:	6823      	ldr	r3, [r4, #0]
   11ad6:	2b00      	cmp	r3, #0
   11ad8:	d000      	beq.n	11adc <_sbrk_r+0x1c>
   11ada:	602b      	str	r3, [r5, #0]
   11adc:	bd70      	pop	{r4, r5, r6, pc}
   11ade:	46c0      	nop			; (mov r8, r8)
   11ae0:	200028d0 	.word	0x200028d0

00011ae4 <setbuf>:
   11ae4:	424a      	negs	r2, r1
   11ae6:	414a      	adcs	r2, r1
   11ae8:	2380      	movs	r3, #128	; 0x80
   11aea:	b510      	push	{r4, lr}
   11aec:	0052      	lsls	r2, r2, #1
   11aee:	00db      	lsls	r3, r3, #3
   11af0:	f000 f802 	bl	11af8 <setvbuf>
   11af4:	bd10      	pop	{r4, pc}
	...

00011af8 <setvbuf>:
   11af8:	b5f0      	push	{r4, r5, r6, r7, lr}
   11afa:	001d      	movs	r5, r3
   11afc:	4b51      	ldr	r3, [pc, #324]	; (11c44 <setvbuf+0x14c>)
   11afe:	b085      	sub	sp, #20
   11b00:	681e      	ldr	r6, [r3, #0]
   11b02:	0004      	movs	r4, r0
   11b04:	000f      	movs	r7, r1
   11b06:	9200      	str	r2, [sp, #0]
   11b08:	2e00      	cmp	r6, #0
   11b0a:	d005      	beq.n	11b18 <setvbuf+0x20>
   11b0c:	69b3      	ldr	r3, [r6, #24]
   11b0e:	2b00      	cmp	r3, #0
   11b10:	d102      	bne.n	11b18 <setvbuf+0x20>
   11b12:	0030      	movs	r0, r6
   11b14:	f000 fb30 	bl	12178 <__sinit>
   11b18:	4b4b      	ldr	r3, [pc, #300]	; (11c48 <setvbuf+0x150>)
   11b1a:	429c      	cmp	r4, r3
   11b1c:	d101      	bne.n	11b22 <setvbuf+0x2a>
   11b1e:	6874      	ldr	r4, [r6, #4]
   11b20:	e008      	b.n	11b34 <setvbuf+0x3c>
   11b22:	4b4a      	ldr	r3, [pc, #296]	; (11c4c <setvbuf+0x154>)
   11b24:	429c      	cmp	r4, r3
   11b26:	d101      	bne.n	11b2c <setvbuf+0x34>
   11b28:	68b4      	ldr	r4, [r6, #8]
   11b2a:	e003      	b.n	11b34 <setvbuf+0x3c>
   11b2c:	4b48      	ldr	r3, [pc, #288]	; (11c50 <setvbuf+0x158>)
   11b2e:	429c      	cmp	r4, r3
   11b30:	d100      	bne.n	11b34 <setvbuf+0x3c>
   11b32:	68f4      	ldr	r4, [r6, #12]
   11b34:	9b00      	ldr	r3, [sp, #0]
   11b36:	2b02      	cmp	r3, #2
   11b38:	d005      	beq.n	11b46 <setvbuf+0x4e>
   11b3a:	2b01      	cmp	r3, #1
   11b3c:	d900      	bls.n	11b40 <setvbuf+0x48>
   11b3e:	e07c      	b.n	11c3a <setvbuf+0x142>
   11b40:	2d00      	cmp	r5, #0
   11b42:	da00      	bge.n	11b46 <setvbuf+0x4e>
   11b44:	e079      	b.n	11c3a <setvbuf+0x142>
   11b46:	0021      	movs	r1, r4
   11b48:	0030      	movs	r0, r6
   11b4a:	f000 faa7 	bl	1209c <_fflush_r>
   11b4e:	6b61      	ldr	r1, [r4, #52]	; 0x34
   11b50:	2900      	cmp	r1, #0
   11b52:	d008      	beq.n	11b66 <setvbuf+0x6e>
   11b54:	0023      	movs	r3, r4
   11b56:	3344      	adds	r3, #68	; 0x44
   11b58:	4299      	cmp	r1, r3
   11b5a:	d002      	beq.n	11b62 <setvbuf+0x6a>
   11b5c:	0030      	movs	r0, r6
   11b5e:	f7ff fe79 	bl	11854 <_free_r>
   11b62:	2300      	movs	r3, #0
   11b64:	6363      	str	r3, [r4, #52]	; 0x34
   11b66:	2300      	movs	r3, #0
   11b68:	61a3      	str	r3, [r4, #24]
   11b6a:	6063      	str	r3, [r4, #4]
   11b6c:	89a3      	ldrh	r3, [r4, #12]
   11b6e:	061b      	lsls	r3, r3, #24
   11b70:	d503      	bpl.n	11b7a <setvbuf+0x82>
   11b72:	6921      	ldr	r1, [r4, #16]
   11b74:	0030      	movs	r0, r6
   11b76:	f7ff fe6d 	bl	11854 <_free_r>
   11b7a:	89a2      	ldrh	r2, [r4, #12]
   11b7c:	4b35      	ldr	r3, [pc, #212]	; (11c54 <setvbuf+0x15c>)
   11b7e:	4013      	ands	r3, r2
   11b80:	81a3      	strh	r3, [r4, #12]
   11b82:	9b00      	ldr	r3, [sp, #0]
   11b84:	2b02      	cmp	r3, #2
   11b86:	d021      	beq.n	11bcc <setvbuf+0xd4>
   11b88:	ab03      	add	r3, sp, #12
   11b8a:	aa02      	add	r2, sp, #8
   11b8c:	0021      	movs	r1, r4
   11b8e:	0030      	movs	r0, r6
   11b90:	f000 fb9a 	bl	122c8 <__swhatbuf_r>
   11b94:	89a3      	ldrh	r3, [r4, #12]
   11b96:	4318      	orrs	r0, r3
   11b98:	81a0      	strh	r0, [r4, #12]
   11b9a:	2d00      	cmp	r5, #0
   11b9c:	d101      	bne.n	11ba2 <setvbuf+0xaa>
   11b9e:	9d02      	ldr	r5, [sp, #8]
   11ba0:	e001      	b.n	11ba6 <setvbuf+0xae>
   11ba2:	2f00      	cmp	r7, #0
   11ba4:	d125      	bne.n	11bf2 <setvbuf+0xfa>
   11ba6:	0028      	movs	r0, r5
   11ba8:	f7ff fe20 	bl	117ec <malloc>
   11bac:	9501      	str	r5, [sp, #4]
   11bae:	1e07      	subs	r7, r0, #0
   11bb0:	d11a      	bne.n	11be8 <setvbuf+0xf0>
   11bb2:	9b02      	ldr	r3, [sp, #8]
   11bb4:	9301      	str	r3, [sp, #4]
   11bb6:	42ab      	cmp	r3, r5
   11bb8:	d102      	bne.n	11bc0 <setvbuf+0xc8>
   11bba:	2001      	movs	r0, #1
   11bbc:	4240      	negs	r0, r0
   11bbe:	e006      	b.n	11bce <setvbuf+0xd6>
   11bc0:	9801      	ldr	r0, [sp, #4]
   11bc2:	f7ff fe13 	bl	117ec <malloc>
   11bc6:	1e07      	subs	r7, r0, #0
   11bc8:	d10e      	bne.n	11be8 <setvbuf+0xf0>
   11bca:	e7f6      	b.n	11bba <setvbuf+0xc2>
   11bcc:	2000      	movs	r0, #0
   11bce:	2202      	movs	r2, #2
   11bd0:	89a3      	ldrh	r3, [r4, #12]
   11bd2:	4313      	orrs	r3, r2
   11bd4:	81a3      	strh	r3, [r4, #12]
   11bd6:	2300      	movs	r3, #0
   11bd8:	60a3      	str	r3, [r4, #8]
   11bda:	0023      	movs	r3, r4
   11bdc:	3347      	adds	r3, #71	; 0x47
   11bde:	6023      	str	r3, [r4, #0]
   11be0:	6123      	str	r3, [r4, #16]
   11be2:	2301      	movs	r3, #1
   11be4:	6163      	str	r3, [r4, #20]
   11be6:	e02a      	b.n	11c3e <setvbuf+0x146>
   11be8:	2280      	movs	r2, #128	; 0x80
   11bea:	89a3      	ldrh	r3, [r4, #12]
   11bec:	9d01      	ldr	r5, [sp, #4]
   11bee:	4313      	orrs	r3, r2
   11bf0:	81a3      	strh	r3, [r4, #12]
   11bf2:	69b3      	ldr	r3, [r6, #24]
   11bf4:	2b00      	cmp	r3, #0
   11bf6:	d102      	bne.n	11bfe <setvbuf+0x106>
   11bf8:	0030      	movs	r0, r6
   11bfa:	f000 fabd 	bl	12178 <__sinit>
   11bfe:	9b00      	ldr	r3, [sp, #0]
   11c00:	2b01      	cmp	r3, #1
   11c02:	d103      	bne.n	11c0c <setvbuf+0x114>
   11c04:	89a3      	ldrh	r3, [r4, #12]
   11c06:	9a00      	ldr	r2, [sp, #0]
   11c08:	431a      	orrs	r2, r3
   11c0a:	81a2      	strh	r2, [r4, #12]
   11c0c:	2308      	movs	r3, #8
   11c0e:	89a2      	ldrh	r2, [r4, #12]
   11c10:	6027      	str	r7, [r4, #0]
   11c12:	4013      	ands	r3, r2
   11c14:	6127      	str	r7, [r4, #16]
   11c16:	6165      	str	r5, [r4, #20]
   11c18:	1e18      	subs	r0, r3, #0
   11c1a:	d00c      	beq.n	11c36 <setvbuf+0x13e>
   11c1c:	2301      	movs	r3, #1
   11c1e:	401a      	ands	r2, r3
   11c20:	2300      	movs	r3, #0
   11c22:	1e10      	subs	r0, r2, #0
   11c24:	4298      	cmp	r0, r3
   11c26:	d004      	beq.n	11c32 <setvbuf+0x13a>
   11c28:	426d      	negs	r5, r5
   11c2a:	60a3      	str	r3, [r4, #8]
   11c2c:	61a5      	str	r5, [r4, #24]
   11c2e:	0018      	movs	r0, r3
   11c30:	e005      	b.n	11c3e <setvbuf+0x146>
   11c32:	60a5      	str	r5, [r4, #8]
   11c34:	e003      	b.n	11c3e <setvbuf+0x146>
   11c36:	60a3      	str	r3, [r4, #8]
   11c38:	e001      	b.n	11c3e <setvbuf+0x146>
   11c3a:	2001      	movs	r0, #1
   11c3c:	4240      	negs	r0, r0
   11c3e:	b005      	add	sp, #20
   11c40:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11c42:	46c0      	nop			; (mov r8, r8)
   11c44:	200001a0 	.word	0x200001a0
   11c48:	0001c100 	.word	0x0001c100
   11c4c:	0001c120 	.word	0x0001c120
   11c50:	0001c140 	.word	0x0001c140
   11c54:	fffff35c 	.word	0xfffff35c

00011c58 <siprintf>:
   11c58:	b40e      	push	{r1, r2, r3}
   11c5a:	b510      	push	{r4, lr}
   11c5c:	b09d      	sub	sp, #116	; 0x74
   11c5e:	a902      	add	r1, sp, #8
   11c60:	9002      	str	r0, [sp, #8]
   11c62:	6108      	str	r0, [r1, #16]
   11c64:	480b      	ldr	r0, [pc, #44]	; (11c94 <siprintf+0x3c>)
   11c66:	2482      	movs	r4, #130	; 0x82
   11c68:	6088      	str	r0, [r1, #8]
   11c6a:	6148      	str	r0, [r1, #20]
   11c6c:	2001      	movs	r0, #1
   11c6e:	4240      	negs	r0, r0
   11c70:	ab1f      	add	r3, sp, #124	; 0x7c
   11c72:	81c8      	strh	r0, [r1, #14]
   11c74:	4808      	ldr	r0, [pc, #32]	; (11c98 <siprintf+0x40>)
   11c76:	cb04      	ldmia	r3!, {r2}
   11c78:	00a4      	lsls	r4, r4, #2
   11c7a:	6800      	ldr	r0, [r0, #0]
   11c7c:	9301      	str	r3, [sp, #4]
   11c7e:	818c      	strh	r4, [r1, #12]
   11c80:	f000 fbe8 	bl	12454 <_svfiprintf_r>
   11c84:	2300      	movs	r3, #0
   11c86:	9a02      	ldr	r2, [sp, #8]
   11c88:	7013      	strb	r3, [r2, #0]
   11c8a:	b01d      	add	sp, #116	; 0x74
   11c8c:	bc10      	pop	{r4}
   11c8e:	bc08      	pop	{r3}
   11c90:	b003      	add	sp, #12
   11c92:	4718      	bx	r3
   11c94:	7fffffff 	.word	0x7fffffff
   11c98:	200001a0 	.word	0x200001a0

00011c9c <__sread>:
   11c9c:	b570      	push	{r4, r5, r6, lr}
   11c9e:	000c      	movs	r4, r1
   11ca0:	250e      	movs	r5, #14
   11ca2:	5f49      	ldrsh	r1, [r1, r5]
   11ca4:	f000 ffde 	bl	12c64 <_read_r>
   11ca8:	2800      	cmp	r0, #0
   11caa:	db03      	blt.n	11cb4 <__sread+0x18>
   11cac:	6d63      	ldr	r3, [r4, #84]	; 0x54
   11cae:	181b      	adds	r3, r3, r0
   11cb0:	6563      	str	r3, [r4, #84]	; 0x54
   11cb2:	e003      	b.n	11cbc <__sread+0x20>
   11cb4:	89a2      	ldrh	r2, [r4, #12]
   11cb6:	4b02      	ldr	r3, [pc, #8]	; (11cc0 <__sread+0x24>)
   11cb8:	4013      	ands	r3, r2
   11cba:	81a3      	strh	r3, [r4, #12]
   11cbc:	bd70      	pop	{r4, r5, r6, pc}
   11cbe:	46c0      	nop			; (mov r8, r8)
   11cc0:	ffffefff 	.word	0xffffefff

00011cc4 <__swrite>:
   11cc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   11cc6:	001f      	movs	r7, r3
   11cc8:	898b      	ldrh	r3, [r1, #12]
   11cca:	0005      	movs	r5, r0
   11ccc:	000c      	movs	r4, r1
   11cce:	0016      	movs	r6, r2
   11cd0:	05db      	lsls	r3, r3, #23
   11cd2:	d505      	bpl.n	11ce0 <__swrite+0x1c>
   11cd4:	230e      	movs	r3, #14
   11cd6:	5ec9      	ldrsh	r1, [r1, r3]
   11cd8:	2200      	movs	r2, #0
   11cda:	2302      	movs	r3, #2
   11cdc:	f000 fae0 	bl	122a0 <_lseek_r>
   11ce0:	89a2      	ldrh	r2, [r4, #12]
   11ce2:	4b05      	ldr	r3, [pc, #20]	; (11cf8 <__swrite+0x34>)
   11ce4:	0028      	movs	r0, r5
   11ce6:	4013      	ands	r3, r2
   11ce8:	81a3      	strh	r3, [r4, #12]
   11cea:	0032      	movs	r2, r6
   11cec:	230e      	movs	r3, #14
   11cee:	5ee1      	ldrsh	r1, [r4, r3]
   11cf0:	003b      	movs	r3, r7
   11cf2:	f000 f8b1 	bl	11e58 <_write_r>
   11cf6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   11cf8:	ffffefff 	.word	0xffffefff

00011cfc <__sseek>:
   11cfc:	b570      	push	{r4, r5, r6, lr}
   11cfe:	000c      	movs	r4, r1
   11d00:	250e      	movs	r5, #14
   11d02:	5f49      	ldrsh	r1, [r1, r5]
   11d04:	f000 facc 	bl	122a0 <_lseek_r>
   11d08:	89a3      	ldrh	r3, [r4, #12]
   11d0a:	1c42      	adds	r2, r0, #1
   11d0c:	d103      	bne.n	11d16 <__sseek+0x1a>
   11d0e:	4a05      	ldr	r2, [pc, #20]	; (11d24 <__sseek+0x28>)
   11d10:	4013      	ands	r3, r2
   11d12:	81a3      	strh	r3, [r4, #12]
   11d14:	e004      	b.n	11d20 <__sseek+0x24>
   11d16:	2280      	movs	r2, #128	; 0x80
   11d18:	0152      	lsls	r2, r2, #5
   11d1a:	4313      	orrs	r3, r2
   11d1c:	81a3      	strh	r3, [r4, #12]
   11d1e:	6560      	str	r0, [r4, #84]	; 0x54
   11d20:	bd70      	pop	{r4, r5, r6, pc}
   11d22:	46c0      	nop			; (mov r8, r8)
   11d24:	ffffefff 	.word	0xffffefff

00011d28 <__sclose>:
   11d28:	b510      	push	{r4, lr}
   11d2a:	230e      	movs	r3, #14
   11d2c:	5ec9      	ldrsh	r1, [r1, r3]
   11d2e:	f000 f91d 	bl	11f6c <_close_r>
   11d32:	bd10      	pop	{r4, pc}

00011d34 <strchr>:
   11d34:	0002      	movs	r2, r0
   11d36:	b2c9      	uxtb	r1, r1
   11d38:	7813      	ldrb	r3, [r2, #0]
   11d3a:	2b00      	cmp	r3, #0
   11d3c:	d003      	beq.n	11d46 <strchr+0x12>
   11d3e:	4299      	cmp	r1, r3
   11d40:	d004      	beq.n	11d4c <strchr+0x18>
   11d42:	3201      	adds	r2, #1
   11d44:	e7f8      	b.n	11d38 <strchr+0x4>
   11d46:	0018      	movs	r0, r3
   11d48:	2900      	cmp	r1, #0
   11d4a:	d100      	bne.n	11d4e <strchr+0x1a>
   11d4c:	0010      	movs	r0, r2
   11d4e:	4770      	bx	lr

00011d50 <strcmp>:
   11d50:	7802      	ldrb	r2, [r0, #0]
   11d52:	780b      	ldrb	r3, [r1, #0]
   11d54:	2a00      	cmp	r2, #0
   11d56:	d003      	beq.n	11d60 <strcmp+0x10>
   11d58:	3001      	adds	r0, #1
   11d5a:	3101      	adds	r1, #1
   11d5c:	429a      	cmp	r2, r3
   11d5e:	d0f7      	beq.n	11d50 <strcmp>
   11d60:	1ad0      	subs	r0, r2, r3
   11d62:	4770      	bx	lr

00011d64 <strcpy>:
   11d64:	1c03      	adds	r3, r0, #0
   11d66:	780a      	ldrb	r2, [r1, #0]
   11d68:	3101      	adds	r1, #1
   11d6a:	701a      	strb	r2, [r3, #0]
   11d6c:	3301      	adds	r3, #1
   11d6e:	2a00      	cmp	r2, #0
   11d70:	d1f9      	bne.n	11d66 <strcpy+0x2>
   11d72:	4770      	bx	lr

00011d74 <strlen>:
   11d74:	2300      	movs	r3, #0
   11d76:	5cc2      	ldrb	r2, [r0, r3]
   11d78:	3301      	adds	r3, #1
   11d7a:	2a00      	cmp	r2, #0
   11d7c:	d1fb      	bne.n	11d76 <strlen+0x2>
   11d7e:	1e58      	subs	r0, r3, #1
   11d80:	4770      	bx	lr

00011d82 <strncmp>:
   11d82:	2300      	movs	r3, #0
   11d84:	b530      	push	{r4, r5, lr}
   11d86:	429a      	cmp	r2, r3
   11d88:	d00b      	beq.n	11da2 <strncmp+0x20>
   11d8a:	3a01      	subs	r2, #1
   11d8c:	5cc4      	ldrb	r4, [r0, r3]
   11d8e:	5ccd      	ldrb	r5, [r1, r3]
   11d90:	42ac      	cmp	r4, r5
   11d92:	d105      	bne.n	11da0 <strncmp+0x1e>
   11d94:	429a      	cmp	r2, r3
   11d96:	d002      	beq.n	11d9e <strncmp+0x1c>
   11d98:	3301      	adds	r3, #1
   11d9a:	2c00      	cmp	r4, #0
   11d9c:	d1f6      	bne.n	11d8c <strncmp+0xa>
   11d9e:	0025      	movs	r5, r4
   11da0:	1b63      	subs	r3, r4, r5
   11da2:	0018      	movs	r0, r3
   11da4:	bd30      	pop	{r4, r5, pc}
	...

00011da8 <__swbuf_r>:
   11da8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   11daa:	0005      	movs	r5, r0
   11dac:	000f      	movs	r7, r1
   11dae:	0014      	movs	r4, r2
   11db0:	2800      	cmp	r0, #0
   11db2:	d004      	beq.n	11dbe <__swbuf_r+0x16>
   11db4:	6983      	ldr	r3, [r0, #24]
   11db6:	2b00      	cmp	r3, #0
   11db8:	d101      	bne.n	11dbe <__swbuf_r+0x16>
   11dba:	f000 f9dd 	bl	12178 <__sinit>
   11dbe:	4b23      	ldr	r3, [pc, #140]	; (11e4c <__swbuf_r+0xa4>)
   11dc0:	429c      	cmp	r4, r3
   11dc2:	d101      	bne.n	11dc8 <__swbuf_r+0x20>
   11dc4:	686c      	ldr	r4, [r5, #4]
   11dc6:	e008      	b.n	11dda <__swbuf_r+0x32>
   11dc8:	4b21      	ldr	r3, [pc, #132]	; (11e50 <__swbuf_r+0xa8>)
   11dca:	429c      	cmp	r4, r3
   11dcc:	d101      	bne.n	11dd2 <__swbuf_r+0x2a>
   11dce:	68ac      	ldr	r4, [r5, #8]
   11dd0:	e003      	b.n	11dda <__swbuf_r+0x32>
   11dd2:	4b20      	ldr	r3, [pc, #128]	; (11e54 <__swbuf_r+0xac>)
   11dd4:	429c      	cmp	r4, r3
   11dd6:	d100      	bne.n	11dda <__swbuf_r+0x32>
   11dd8:	68ec      	ldr	r4, [r5, #12]
   11dda:	69a3      	ldr	r3, [r4, #24]
   11ddc:	60a3      	str	r3, [r4, #8]
   11dde:	89a3      	ldrh	r3, [r4, #12]
   11de0:	071b      	lsls	r3, r3, #28
   11de2:	d50a      	bpl.n	11dfa <__swbuf_r+0x52>
   11de4:	6923      	ldr	r3, [r4, #16]
   11de6:	2b00      	cmp	r3, #0
   11de8:	d007      	beq.n	11dfa <__swbuf_r+0x52>
   11dea:	6823      	ldr	r3, [r4, #0]
   11dec:	6922      	ldr	r2, [r4, #16]
   11dee:	b2fe      	uxtb	r6, r7
   11df0:	1a98      	subs	r0, r3, r2
   11df2:	6963      	ldr	r3, [r4, #20]
   11df4:	4298      	cmp	r0, r3
   11df6:	db0f      	blt.n	11e18 <__swbuf_r+0x70>
   11df8:	e008      	b.n	11e0c <__swbuf_r+0x64>
   11dfa:	0021      	movs	r1, r4
   11dfc:	0028      	movs	r0, r5
   11dfe:	f000 f83f 	bl	11e80 <__swsetup_r>
   11e02:	2800      	cmp	r0, #0
   11e04:	d0f1      	beq.n	11dea <__swbuf_r+0x42>
   11e06:	2001      	movs	r0, #1
   11e08:	4240      	negs	r0, r0
   11e0a:	e01d      	b.n	11e48 <__swbuf_r+0xa0>
   11e0c:	0021      	movs	r1, r4
   11e0e:	0028      	movs	r0, r5
   11e10:	f000 f944 	bl	1209c <_fflush_r>
   11e14:	2800      	cmp	r0, #0
   11e16:	d1f6      	bne.n	11e06 <__swbuf_r+0x5e>
   11e18:	68a3      	ldr	r3, [r4, #8]
   11e1a:	3001      	adds	r0, #1
   11e1c:	3b01      	subs	r3, #1
   11e1e:	60a3      	str	r3, [r4, #8]
   11e20:	6823      	ldr	r3, [r4, #0]
   11e22:	1c5a      	adds	r2, r3, #1
   11e24:	6022      	str	r2, [r4, #0]
   11e26:	701f      	strb	r7, [r3, #0]
   11e28:	6963      	ldr	r3, [r4, #20]
   11e2a:	4298      	cmp	r0, r3
   11e2c:	d005      	beq.n	11e3a <__swbuf_r+0x92>
   11e2e:	89a3      	ldrh	r3, [r4, #12]
   11e30:	0030      	movs	r0, r6
   11e32:	07db      	lsls	r3, r3, #31
   11e34:	d508      	bpl.n	11e48 <__swbuf_r+0xa0>
   11e36:	2e0a      	cmp	r6, #10
   11e38:	d106      	bne.n	11e48 <__swbuf_r+0xa0>
   11e3a:	0021      	movs	r1, r4
   11e3c:	0028      	movs	r0, r5
   11e3e:	f000 f92d 	bl	1209c <_fflush_r>
   11e42:	2800      	cmp	r0, #0
   11e44:	d1df      	bne.n	11e06 <__swbuf_r+0x5e>
   11e46:	0030      	movs	r0, r6
   11e48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   11e4a:	46c0      	nop			; (mov r8, r8)
   11e4c:	0001c100 	.word	0x0001c100
   11e50:	0001c120 	.word	0x0001c120
   11e54:	0001c140 	.word	0x0001c140

00011e58 <_write_r>:
   11e58:	b570      	push	{r4, r5, r6, lr}
   11e5a:	0005      	movs	r5, r0
   11e5c:	0008      	movs	r0, r1
   11e5e:	0011      	movs	r1, r2
   11e60:	2200      	movs	r2, #0
   11e62:	4c06      	ldr	r4, [pc, #24]	; (11e7c <_write_r+0x24>)
   11e64:	6022      	str	r2, [r4, #0]
   11e66:	001a      	movs	r2, r3
   11e68:	f7fc f894 	bl	df94 <_write>
   11e6c:	1c43      	adds	r3, r0, #1
   11e6e:	d103      	bne.n	11e78 <_write_r+0x20>
   11e70:	6823      	ldr	r3, [r4, #0]
   11e72:	2b00      	cmp	r3, #0
   11e74:	d000      	beq.n	11e78 <_write_r+0x20>
   11e76:	602b      	str	r3, [r5, #0]
   11e78:	bd70      	pop	{r4, r5, r6, pc}
   11e7a:	46c0      	nop			; (mov r8, r8)
   11e7c:	200028d0 	.word	0x200028d0

00011e80 <__swsetup_r>:
   11e80:	4b36      	ldr	r3, [pc, #216]	; (11f5c <__swsetup_r+0xdc>)
   11e82:	b570      	push	{r4, r5, r6, lr}
   11e84:	681d      	ldr	r5, [r3, #0]
   11e86:	0006      	movs	r6, r0
   11e88:	000c      	movs	r4, r1
   11e8a:	2d00      	cmp	r5, #0
   11e8c:	d005      	beq.n	11e9a <__swsetup_r+0x1a>
   11e8e:	69ab      	ldr	r3, [r5, #24]
   11e90:	2b00      	cmp	r3, #0
   11e92:	d102      	bne.n	11e9a <__swsetup_r+0x1a>
   11e94:	0028      	movs	r0, r5
   11e96:	f000 f96f 	bl	12178 <__sinit>
   11e9a:	4b31      	ldr	r3, [pc, #196]	; (11f60 <__swsetup_r+0xe0>)
   11e9c:	429c      	cmp	r4, r3
   11e9e:	d101      	bne.n	11ea4 <__swsetup_r+0x24>
   11ea0:	686c      	ldr	r4, [r5, #4]
   11ea2:	e008      	b.n	11eb6 <__swsetup_r+0x36>
   11ea4:	4b2f      	ldr	r3, [pc, #188]	; (11f64 <__swsetup_r+0xe4>)
   11ea6:	429c      	cmp	r4, r3
   11ea8:	d101      	bne.n	11eae <__swsetup_r+0x2e>
   11eaa:	68ac      	ldr	r4, [r5, #8]
   11eac:	e003      	b.n	11eb6 <__swsetup_r+0x36>
   11eae:	4b2e      	ldr	r3, [pc, #184]	; (11f68 <__swsetup_r+0xe8>)
   11eb0:	429c      	cmp	r4, r3
   11eb2:	d100      	bne.n	11eb6 <__swsetup_r+0x36>
   11eb4:	68ec      	ldr	r4, [r5, #12]
   11eb6:	220c      	movs	r2, #12
   11eb8:	5ea3      	ldrsh	r3, [r4, r2]
   11eba:	b29a      	uxth	r2, r3
   11ebc:	0711      	lsls	r1, r2, #28
   11ebe:	d423      	bmi.n	11f08 <__swsetup_r+0x88>
   11ec0:	06d1      	lsls	r1, r2, #27
   11ec2:	d407      	bmi.n	11ed4 <__swsetup_r+0x54>
   11ec4:	2209      	movs	r2, #9
   11ec6:	2001      	movs	r0, #1
   11ec8:	6032      	str	r2, [r6, #0]
   11eca:	3237      	adds	r2, #55	; 0x37
   11ecc:	4313      	orrs	r3, r2
   11ece:	81a3      	strh	r3, [r4, #12]
   11ed0:	4240      	negs	r0, r0
   11ed2:	e042      	b.n	11f5a <__swsetup_r+0xda>
   11ed4:	0753      	lsls	r3, r2, #29
   11ed6:	d513      	bpl.n	11f00 <__swsetup_r+0x80>
   11ed8:	6b61      	ldr	r1, [r4, #52]	; 0x34
   11eda:	2900      	cmp	r1, #0
   11edc:	d008      	beq.n	11ef0 <__swsetup_r+0x70>
   11ede:	0023      	movs	r3, r4
   11ee0:	3344      	adds	r3, #68	; 0x44
   11ee2:	4299      	cmp	r1, r3
   11ee4:	d002      	beq.n	11eec <__swsetup_r+0x6c>
   11ee6:	0030      	movs	r0, r6
   11ee8:	f7ff fcb4 	bl	11854 <_free_r>
   11eec:	2300      	movs	r3, #0
   11eee:	6363      	str	r3, [r4, #52]	; 0x34
   11ef0:	2224      	movs	r2, #36	; 0x24
   11ef2:	89a3      	ldrh	r3, [r4, #12]
   11ef4:	4393      	bics	r3, r2
   11ef6:	81a3      	strh	r3, [r4, #12]
   11ef8:	2300      	movs	r3, #0
   11efa:	6063      	str	r3, [r4, #4]
   11efc:	6923      	ldr	r3, [r4, #16]
   11efe:	6023      	str	r3, [r4, #0]
   11f00:	2208      	movs	r2, #8
   11f02:	89a3      	ldrh	r3, [r4, #12]
   11f04:	4313      	orrs	r3, r2
   11f06:	81a3      	strh	r3, [r4, #12]
   11f08:	6923      	ldr	r3, [r4, #16]
   11f0a:	2b00      	cmp	r3, #0
   11f0c:	d10b      	bne.n	11f26 <__swsetup_r+0xa6>
   11f0e:	23a0      	movs	r3, #160	; 0xa0
   11f10:	89a2      	ldrh	r2, [r4, #12]
   11f12:	009b      	lsls	r3, r3, #2
   11f14:	4013      	ands	r3, r2
   11f16:	2280      	movs	r2, #128	; 0x80
   11f18:	0092      	lsls	r2, r2, #2
   11f1a:	4293      	cmp	r3, r2
   11f1c:	d003      	beq.n	11f26 <__swsetup_r+0xa6>
   11f1e:	0021      	movs	r1, r4
   11f20:	0030      	movs	r0, r6
   11f22:	f000 f9f7 	bl	12314 <__smakebuf_r>
   11f26:	2301      	movs	r3, #1
   11f28:	89a2      	ldrh	r2, [r4, #12]
   11f2a:	4013      	ands	r3, r2
   11f2c:	d005      	beq.n	11f3a <__swsetup_r+0xba>
   11f2e:	2300      	movs	r3, #0
   11f30:	60a3      	str	r3, [r4, #8]
   11f32:	6963      	ldr	r3, [r4, #20]
   11f34:	425b      	negs	r3, r3
   11f36:	61a3      	str	r3, [r4, #24]
   11f38:	e003      	b.n	11f42 <__swsetup_r+0xc2>
   11f3a:	0792      	lsls	r2, r2, #30
   11f3c:	d400      	bmi.n	11f40 <__swsetup_r+0xc0>
   11f3e:	6963      	ldr	r3, [r4, #20]
   11f40:	60a3      	str	r3, [r4, #8]
   11f42:	2000      	movs	r0, #0
   11f44:	6923      	ldr	r3, [r4, #16]
   11f46:	4283      	cmp	r3, r0
   11f48:	d107      	bne.n	11f5a <__swsetup_r+0xda>
   11f4a:	220c      	movs	r2, #12
   11f4c:	5ea3      	ldrsh	r3, [r4, r2]
   11f4e:	061a      	lsls	r2, r3, #24
   11f50:	d503      	bpl.n	11f5a <__swsetup_r+0xda>
   11f52:	2240      	movs	r2, #64	; 0x40
   11f54:	4313      	orrs	r3, r2
   11f56:	81a3      	strh	r3, [r4, #12]
   11f58:	3801      	subs	r0, #1
   11f5a:	bd70      	pop	{r4, r5, r6, pc}
   11f5c:	200001a0 	.word	0x200001a0
   11f60:	0001c100 	.word	0x0001c100
   11f64:	0001c120 	.word	0x0001c120
   11f68:	0001c140 	.word	0x0001c140

00011f6c <_close_r>:
   11f6c:	2300      	movs	r3, #0
   11f6e:	b570      	push	{r4, r5, r6, lr}
   11f70:	4c06      	ldr	r4, [pc, #24]	; (11f8c <_close_r+0x20>)
   11f72:	0005      	movs	r5, r0
   11f74:	0008      	movs	r0, r1
   11f76:	6023      	str	r3, [r4, #0]
   11f78:	f7fc f846 	bl	e008 <_close>
   11f7c:	1c43      	adds	r3, r0, #1
   11f7e:	d103      	bne.n	11f88 <_close_r+0x1c>
   11f80:	6823      	ldr	r3, [r4, #0]
   11f82:	2b00      	cmp	r3, #0
   11f84:	d000      	beq.n	11f88 <_close_r+0x1c>
   11f86:	602b      	str	r3, [r5, #0]
   11f88:	bd70      	pop	{r4, r5, r6, pc}
   11f8a:	46c0      	nop			; (mov r8, r8)
   11f8c:	200028d0 	.word	0x200028d0

00011f90 <__sflush_r>:
   11f90:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   11f92:	898a      	ldrh	r2, [r1, #12]
   11f94:	0005      	movs	r5, r0
   11f96:	000c      	movs	r4, r1
   11f98:	0713      	lsls	r3, r2, #28
   11f9a:	d45a      	bmi.n	12052 <__sflush_r+0xc2>
   11f9c:	684b      	ldr	r3, [r1, #4]
   11f9e:	2b00      	cmp	r3, #0
   11fa0:	dc02      	bgt.n	11fa8 <__sflush_r+0x18>
   11fa2:	6c0b      	ldr	r3, [r1, #64]	; 0x40
   11fa4:	2b00      	cmp	r3, #0
   11fa6:	dd19      	ble.n	11fdc <__sflush_r+0x4c>
   11fa8:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
   11faa:	2f00      	cmp	r7, #0
   11fac:	d016      	beq.n	11fdc <__sflush_r+0x4c>
   11fae:	2300      	movs	r3, #0
   11fb0:	682e      	ldr	r6, [r5, #0]
   11fb2:	602b      	str	r3, [r5, #0]
   11fb4:	2380      	movs	r3, #128	; 0x80
   11fb6:	015b      	lsls	r3, r3, #5
   11fb8:	401a      	ands	r2, r3
   11fba:	d001      	beq.n	11fc0 <__sflush_r+0x30>
   11fbc:	6d60      	ldr	r0, [r4, #84]	; 0x54
   11fbe:	e014      	b.n	11fea <__sflush_r+0x5a>
   11fc0:	2301      	movs	r3, #1
   11fc2:	6a21      	ldr	r1, [r4, #32]
   11fc4:	0028      	movs	r0, r5
   11fc6:	47b8      	blx	r7
   11fc8:	1c43      	adds	r3, r0, #1
   11fca:	d10e      	bne.n	11fea <__sflush_r+0x5a>
   11fcc:	682b      	ldr	r3, [r5, #0]
   11fce:	2b00      	cmp	r3, #0
   11fd0:	d00b      	beq.n	11fea <__sflush_r+0x5a>
   11fd2:	2b1d      	cmp	r3, #29
   11fd4:	d001      	beq.n	11fda <__sflush_r+0x4a>
   11fd6:	2b16      	cmp	r3, #22
   11fd8:	d102      	bne.n	11fe0 <__sflush_r+0x50>
   11fda:	602e      	str	r6, [r5, #0]
   11fdc:	2000      	movs	r0, #0
   11fde:	e05a      	b.n	12096 <__sflush_r+0x106>
   11fe0:	2240      	movs	r2, #64	; 0x40
   11fe2:	89a3      	ldrh	r3, [r4, #12]
   11fe4:	4313      	orrs	r3, r2
   11fe6:	81a3      	strh	r3, [r4, #12]
   11fe8:	e055      	b.n	12096 <__sflush_r+0x106>
   11fea:	89a3      	ldrh	r3, [r4, #12]
   11fec:	075b      	lsls	r3, r3, #29
   11fee:	d506      	bpl.n	11ffe <__sflush_r+0x6e>
   11ff0:	6863      	ldr	r3, [r4, #4]
   11ff2:	1ac0      	subs	r0, r0, r3
   11ff4:	6b63      	ldr	r3, [r4, #52]	; 0x34
   11ff6:	2b00      	cmp	r3, #0
   11ff8:	d001      	beq.n	11ffe <__sflush_r+0x6e>
   11ffa:	6c23      	ldr	r3, [r4, #64]	; 0x40
   11ffc:	1ac0      	subs	r0, r0, r3
   11ffe:	2300      	movs	r3, #0
   12000:	0002      	movs	r2, r0
   12002:	6a21      	ldr	r1, [r4, #32]
   12004:	0028      	movs	r0, r5
   12006:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
   12008:	47b8      	blx	r7
   1200a:	89a3      	ldrh	r3, [r4, #12]
   1200c:	1c42      	adds	r2, r0, #1
   1200e:	d106      	bne.n	1201e <__sflush_r+0x8e>
   12010:	6829      	ldr	r1, [r5, #0]
   12012:	291d      	cmp	r1, #29
   12014:	d83a      	bhi.n	1208c <__sflush_r+0xfc>
   12016:	4a20      	ldr	r2, [pc, #128]	; (12098 <__sflush_r+0x108>)
   12018:	40ca      	lsrs	r2, r1
   1201a:	07d2      	lsls	r2, r2, #31
   1201c:	d536      	bpl.n	1208c <__sflush_r+0xfc>
   1201e:	2200      	movs	r2, #0
   12020:	6062      	str	r2, [r4, #4]
   12022:	6922      	ldr	r2, [r4, #16]
   12024:	6022      	str	r2, [r4, #0]
   12026:	04db      	lsls	r3, r3, #19
   12028:	d505      	bpl.n	12036 <__sflush_r+0xa6>
   1202a:	1c43      	adds	r3, r0, #1
   1202c:	d102      	bne.n	12034 <__sflush_r+0xa4>
   1202e:	682b      	ldr	r3, [r5, #0]
   12030:	2b00      	cmp	r3, #0
   12032:	d100      	bne.n	12036 <__sflush_r+0xa6>
   12034:	6560      	str	r0, [r4, #84]	; 0x54
   12036:	6b61      	ldr	r1, [r4, #52]	; 0x34
   12038:	602e      	str	r6, [r5, #0]
   1203a:	2900      	cmp	r1, #0
   1203c:	d0ce      	beq.n	11fdc <__sflush_r+0x4c>
   1203e:	0023      	movs	r3, r4
   12040:	3344      	adds	r3, #68	; 0x44
   12042:	4299      	cmp	r1, r3
   12044:	d002      	beq.n	1204c <__sflush_r+0xbc>
   12046:	0028      	movs	r0, r5
   12048:	f7ff fc04 	bl	11854 <_free_r>
   1204c:	2000      	movs	r0, #0
   1204e:	6360      	str	r0, [r4, #52]	; 0x34
   12050:	e021      	b.n	12096 <__sflush_r+0x106>
   12052:	690f      	ldr	r7, [r1, #16]
   12054:	2f00      	cmp	r7, #0
   12056:	d0c1      	beq.n	11fdc <__sflush_r+0x4c>
   12058:	680b      	ldr	r3, [r1, #0]
   1205a:	600f      	str	r7, [r1, #0]
   1205c:	1bdb      	subs	r3, r3, r7
   1205e:	9301      	str	r3, [sp, #4]
   12060:	2300      	movs	r3, #0
   12062:	0792      	lsls	r2, r2, #30
   12064:	d100      	bne.n	12068 <__sflush_r+0xd8>
   12066:	694b      	ldr	r3, [r1, #20]
   12068:	60a3      	str	r3, [r4, #8]
   1206a:	e003      	b.n	12074 <__sflush_r+0xe4>
   1206c:	9b01      	ldr	r3, [sp, #4]
   1206e:	183f      	adds	r7, r7, r0
   12070:	1a1b      	subs	r3, r3, r0
   12072:	9301      	str	r3, [sp, #4]
   12074:	9b01      	ldr	r3, [sp, #4]
   12076:	2b00      	cmp	r3, #0
   12078:	ddb0      	ble.n	11fdc <__sflush_r+0x4c>
   1207a:	9b01      	ldr	r3, [sp, #4]
   1207c:	003a      	movs	r2, r7
   1207e:	6a21      	ldr	r1, [r4, #32]
   12080:	0028      	movs	r0, r5
   12082:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   12084:	47b0      	blx	r6
   12086:	2800      	cmp	r0, #0
   12088:	dcf0      	bgt.n	1206c <__sflush_r+0xdc>
   1208a:	89a3      	ldrh	r3, [r4, #12]
   1208c:	2240      	movs	r2, #64	; 0x40
   1208e:	2001      	movs	r0, #1
   12090:	4313      	orrs	r3, r2
   12092:	81a3      	strh	r3, [r4, #12]
   12094:	4240      	negs	r0, r0
   12096:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   12098:	20400001 	.word	0x20400001

0001209c <_fflush_r>:
   1209c:	690b      	ldr	r3, [r1, #16]
   1209e:	b570      	push	{r4, r5, r6, lr}
   120a0:	0005      	movs	r5, r0
   120a2:	000c      	movs	r4, r1
   120a4:	2b00      	cmp	r3, #0
   120a6:	d101      	bne.n	120ac <_fflush_r+0x10>
   120a8:	2000      	movs	r0, #0
   120aa:	e01c      	b.n	120e6 <_fflush_r+0x4a>
   120ac:	2800      	cmp	r0, #0
   120ae:	d004      	beq.n	120ba <_fflush_r+0x1e>
   120b0:	6983      	ldr	r3, [r0, #24]
   120b2:	2b00      	cmp	r3, #0
   120b4:	d101      	bne.n	120ba <_fflush_r+0x1e>
   120b6:	f000 f85f 	bl	12178 <__sinit>
   120ba:	4b0b      	ldr	r3, [pc, #44]	; (120e8 <_fflush_r+0x4c>)
   120bc:	429c      	cmp	r4, r3
   120be:	d101      	bne.n	120c4 <_fflush_r+0x28>
   120c0:	686c      	ldr	r4, [r5, #4]
   120c2:	e008      	b.n	120d6 <_fflush_r+0x3a>
   120c4:	4b09      	ldr	r3, [pc, #36]	; (120ec <_fflush_r+0x50>)
   120c6:	429c      	cmp	r4, r3
   120c8:	d101      	bne.n	120ce <_fflush_r+0x32>
   120ca:	68ac      	ldr	r4, [r5, #8]
   120cc:	e003      	b.n	120d6 <_fflush_r+0x3a>
   120ce:	4b08      	ldr	r3, [pc, #32]	; (120f0 <_fflush_r+0x54>)
   120d0:	429c      	cmp	r4, r3
   120d2:	d100      	bne.n	120d6 <_fflush_r+0x3a>
   120d4:	68ec      	ldr	r4, [r5, #12]
   120d6:	220c      	movs	r2, #12
   120d8:	5ea3      	ldrsh	r3, [r4, r2]
   120da:	2b00      	cmp	r3, #0
   120dc:	d0e4      	beq.n	120a8 <_fflush_r+0xc>
   120de:	0021      	movs	r1, r4
   120e0:	0028      	movs	r0, r5
   120e2:	f7ff ff55 	bl	11f90 <__sflush_r>
   120e6:	bd70      	pop	{r4, r5, r6, pc}
   120e8:	0001c100 	.word	0x0001c100
   120ec:	0001c120 	.word	0x0001c120
   120f0:	0001c140 	.word	0x0001c140

000120f4 <_cleanup_r>:
   120f4:	b510      	push	{r4, lr}
   120f6:	4902      	ldr	r1, [pc, #8]	; (12100 <_cleanup_r+0xc>)
   120f8:	f000 f8b0 	bl	1225c <_fwalk_reent>
   120fc:	bd10      	pop	{r4, pc}
   120fe:	46c0      	nop			; (mov r8, r8)
   12100:	0001209d 	.word	0x0001209d

00012104 <std.isra.0>:
   12104:	2300      	movs	r3, #0
   12106:	b510      	push	{r4, lr}
   12108:	0004      	movs	r4, r0
   1210a:	6003      	str	r3, [r0, #0]
   1210c:	6043      	str	r3, [r0, #4]
   1210e:	6083      	str	r3, [r0, #8]
   12110:	8181      	strh	r1, [r0, #12]
   12112:	6643      	str	r3, [r0, #100]	; 0x64
   12114:	81c2      	strh	r2, [r0, #14]
   12116:	6103      	str	r3, [r0, #16]
   12118:	6143      	str	r3, [r0, #20]
   1211a:	6183      	str	r3, [r0, #24]
   1211c:	0019      	movs	r1, r3
   1211e:	2208      	movs	r2, #8
   12120:	305c      	adds	r0, #92	; 0x5c
   12122:	f7ff fb8f 	bl	11844 <memset>
   12126:	4b05      	ldr	r3, [pc, #20]	; (1213c <std.isra.0+0x38>)
   12128:	6224      	str	r4, [r4, #32]
   1212a:	6263      	str	r3, [r4, #36]	; 0x24
   1212c:	4b04      	ldr	r3, [pc, #16]	; (12140 <std.isra.0+0x3c>)
   1212e:	62a3      	str	r3, [r4, #40]	; 0x28
   12130:	4b04      	ldr	r3, [pc, #16]	; (12144 <std.isra.0+0x40>)
   12132:	62e3      	str	r3, [r4, #44]	; 0x2c
   12134:	4b04      	ldr	r3, [pc, #16]	; (12148 <std.isra.0+0x44>)
   12136:	6323      	str	r3, [r4, #48]	; 0x30
   12138:	bd10      	pop	{r4, pc}
   1213a:	46c0      	nop			; (mov r8, r8)
   1213c:	00011c9d 	.word	0x00011c9d
   12140:	00011cc5 	.word	0x00011cc5
   12144:	00011cfd 	.word	0x00011cfd
   12148:	00011d29 	.word	0x00011d29

0001214c <__sfmoreglue>:
   1214c:	b570      	push	{r4, r5, r6, lr}
   1214e:	2568      	movs	r5, #104	; 0x68
   12150:	1e4b      	subs	r3, r1, #1
   12152:	435d      	muls	r5, r3
   12154:	000e      	movs	r6, r1
   12156:	0029      	movs	r1, r5
   12158:	3174      	adds	r1, #116	; 0x74
   1215a:	f7ff fbc1 	bl	118e0 <_malloc_r>
   1215e:	1e04      	subs	r4, r0, #0
   12160:	d008      	beq.n	12174 <__sfmoreglue+0x28>
   12162:	2100      	movs	r1, #0
   12164:	002a      	movs	r2, r5
   12166:	6001      	str	r1, [r0, #0]
   12168:	6046      	str	r6, [r0, #4]
   1216a:	300c      	adds	r0, #12
   1216c:	60a0      	str	r0, [r4, #8]
   1216e:	3268      	adds	r2, #104	; 0x68
   12170:	f7ff fb68 	bl	11844 <memset>
   12174:	0020      	movs	r0, r4
   12176:	bd70      	pop	{r4, r5, r6, pc}

00012178 <__sinit>:
   12178:	6983      	ldr	r3, [r0, #24]
   1217a:	b513      	push	{r0, r1, r4, lr}
   1217c:	0004      	movs	r4, r0
   1217e:	2b00      	cmp	r3, #0
   12180:	d128      	bne.n	121d4 <__sinit+0x5c>
   12182:	6483      	str	r3, [r0, #72]	; 0x48
   12184:	64c3      	str	r3, [r0, #76]	; 0x4c
   12186:	6503      	str	r3, [r0, #80]	; 0x50
   12188:	4b13      	ldr	r3, [pc, #76]	; (121d8 <__sinit+0x60>)
   1218a:	4a14      	ldr	r2, [pc, #80]	; (121dc <__sinit+0x64>)
   1218c:	681b      	ldr	r3, [r3, #0]
   1218e:	6282      	str	r2, [r0, #40]	; 0x28
   12190:	9301      	str	r3, [sp, #4]
   12192:	4298      	cmp	r0, r3
   12194:	d101      	bne.n	1219a <__sinit+0x22>
   12196:	2301      	movs	r3, #1
   12198:	6183      	str	r3, [r0, #24]
   1219a:	0020      	movs	r0, r4
   1219c:	f000 f820 	bl	121e0 <__sfp>
   121a0:	6060      	str	r0, [r4, #4]
   121a2:	0020      	movs	r0, r4
   121a4:	f000 f81c 	bl	121e0 <__sfp>
   121a8:	60a0      	str	r0, [r4, #8]
   121aa:	0020      	movs	r0, r4
   121ac:	f000 f818 	bl	121e0 <__sfp>
   121b0:	2200      	movs	r2, #0
   121b2:	60e0      	str	r0, [r4, #12]
   121b4:	2104      	movs	r1, #4
   121b6:	6860      	ldr	r0, [r4, #4]
   121b8:	f7ff ffa4 	bl	12104 <std.isra.0>
   121bc:	2201      	movs	r2, #1
   121be:	2109      	movs	r1, #9
   121c0:	68a0      	ldr	r0, [r4, #8]
   121c2:	f7ff ff9f 	bl	12104 <std.isra.0>
   121c6:	2202      	movs	r2, #2
   121c8:	2112      	movs	r1, #18
   121ca:	68e0      	ldr	r0, [r4, #12]
   121cc:	f7ff ff9a 	bl	12104 <std.isra.0>
   121d0:	2301      	movs	r3, #1
   121d2:	61a3      	str	r3, [r4, #24]
   121d4:	bd13      	pop	{r0, r1, r4, pc}
   121d6:	46c0      	nop			; (mov r8, r8)
   121d8:	0001c0fc 	.word	0x0001c0fc
   121dc:	000120f5 	.word	0x000120f5

000121e0 <__sfp>:
   121e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   121e2:	4b1d      	ldr	r3, [pc, #116]	; (12258 <__sfp+0x78>)
   121e4:	0006      	movs	r6, r0
   121e6:	681d      	ldr	r5, [r3, #0]
   121e8:	69ab      	ldr	r3, [r5, #24]
   121ea:	2b00      	cmp	r3, #0
   121ec:	d102      	bne.n	121f4 <__sfp+0x14>
   121ee:	0028      	movs	r0, r5
   121f0:	f7ff ffc2 	bl	12178 <__sinit>
   121f4:	3548      	adds	r5, #72	; 0x48
   121f6:	68ac      	ldr	r4, [r5, #8]
   121f8:	686b      	ldr	r3, [r5, #4]
   121fa:	3b01      	subs	r3, #1
   121fc:	d405      	bmi.n	1220a <__sfp+0x2a>
   121fe:	220c      	movs	r2, #12
   12200:	5ea7      	ldrsh	r7, [r4, r2]
   12202:	2f00      	cmp	r7, #0
   12204:	d010      	beq.n	12228 <__sfp+0x48>
   12206:	3468      	adds	r4, #104	; 0x68
   12208:	e7f7      	b.n	121fa <__sfp+0x1a>
   1220a:	682b      	ldr	r3, [r5, #0]
   1220c:	2b00      	cmp	r3, #0
   1220e:	d001      	beq.n	12214 <__sfp+0x34>
   12210:	682d      	ldr	r5, [r5, #0]
   12212:	e7f0      	b.n	121f6 <__sfp+0x16>
   12214:	2104      	movs	r1, #4
   12216:	0030      	movs	r0, r6
   12218:	f7ff ff98 	bl	1214c <__sfmoreglue>
   1221c:	6028      	str	r0, [r5, #0]
   1221e:	2800      	cmp	r0, #0
   12220:	d1f6      	bne.n	12210 <__sfp+0x30>
   12222:	230c      	movs	r3, #12
   12224:	6033      	str	r3, [r6, #0]
   12226:	e016      	b.n	12256 <__sfp+0x76>
   12228:	2301      	movs	r3, #1
   1222a:	0020      	movs	r0, r4
   1222c:	425b      	negs	r3, r3
   1222e:	81e3      	strh	r3, [r4, #14]
   12230:	3302      	adds	r3, #2
   12232:	81a3      	strh	r3, [r4, #12]
   12234:	6667      	str	r7, [r4, #100]	; 0x64
   12236:	6027      	str	r7, [r4, #0]
   12238:	60a7      	str	r7, [r4, #8]
   1223a:	6067      	str	r7, [r4, #4]
   1223c:	6127      	str	r7, [r4, #16]
   1223e:	6167      	str	r7, [r4, #20]
   12240:	61a7      	str	r7, [r4, #24]
   12242:	305c      	adds	r0, #92	; 0x5c
   12244:	2208      	movs	r2, #8
   12246:	0039      	movs	r1, r7
   12248:	f7ff fafc 	bl	11844 <memset>
   1224c:	0020      	movs	r0, r4
   1224e:	6367      	str	r7, [r4, #52]	; 0x34
   12250:	63a7      	str	r7, [r4, #56]	; 0x38
   12252:	64a7      	str	r7, [r4, #72]	; 0x48
   12254:	64e7      	str	r7, [r4, #76]	; 0x4c
   12256:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   12258:	0001c0fc 	.word	0x0001c0fc

0001225c <_fwalk_reent>:
   1225c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1225e:	0004      	movs	r4, r0
   12260:	0007      	movs	r7, r0
   12262:	2600      	movs	r6, #0
   12264:	9101      	str	r1, [sp, #4]
   12266:	3448      	adds	r4, #72	; 0x48
   12268:	2c00      	cmp	r4, #0
   1226a:	d016      	beq.n	1229a <_fwalk_reent+0x3e>
   1226c:	6863      	ldr	r3, [r4, #4]
   1226e:	68a5      	ldr	r5, [r4, #8]
   12270:	9300      	str	r3, [sp, #0]
   12272:	9b00      	ldr	r3, [sp, #0]
   12274:	3b01      	subs	r3, #1
   12276:	9300      	str	r3, [sp, #0]
   12278:	d40d      	bmi.n	12296 <_fwalk_reent+0x3a>
   1227a:	89ab      	ldrh	r3, [r5, #12]
   1227c:	2b01      	cmp	r3, #1
   1227e:	d908      	bls.n	12292 <_fwalk_reent+0x36>
   12280:	220e      	movs	r2, #14
   12282:	5eab      	ldrsh	r3, [r5, r2]
   12284:	3301      	adds	r3, #1
   12286:	d004      	beq.n	12292 <_fwalk_reent+0x36>
   12288:	0029      	movs	r1, r5
   1228a:	0038      	movs	r0, r7
   1228c:	9b01      	ldr	r3, [sp, #4]
   1228e:	4798      	blx	r3
   12290:	4306      	orrs	r6, r0
   12292:	3568      	adds	r5, #104	; 0x68
   12294:	e7ed      	b.n	12272 <_fwalk_reent+0x16>
   12296:	6824      	ldr	r4, [r4, #0]
   12298:	e7e6      	b.n	12268 <_fwalk_reent+0xc>
   1229a:	0030      	movs	r0, r6
   1229c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

000122a0 <_lseek_r>:
   122a0:	b570      	push	{r4, r5, r6, lr}
   122a2:	0005      	movs	r5, r0
   122a4:	0008      	movs	r0, r1
   122a6:	0011      	movs	r1, r2
   122a8:	2200      	movs	r2, #0
   122aa:	4c06      	ldr	r4, [pc, #24]	; (122c4 <_lseek_r+0x24>)
   122ac:	6022      	str	r2, [r4, #0]
   122ae:	001a      	movs	r2, r3
   122b0:	f7fb feb6 	bl	e020 <_lseek>
   122b4:	1c43      	adds	r3, r0, #1
   122b6:	d103      	bne.n	122c0 <_lseek_r+0x20>
   122b8:	6823      	ldr	r3, [r4, #0]
   122ba:	2b00      	cmp	r3, #0
   122bc:	d000      	beq.n	122c0 <_lseek_r+0x20>
   122be:	602b      	str	r3, [r5, #0]
   122c0:	bd70      	pop	{r4, r5, r6, pc}
   122c2:	46c0      	nop			; (mov r8, r8)
   122c4:	200028d0 	.word	0x200028d0

000122c8 <__swhatbuf_r>:
   122c8:	b570      	push	{r4, r5, r6, lr}
   122ca:	000e      	movs	r6, r1
   122cc:	001d      	movs	r5, r3
   122ce:	230e      	movs	r3, #14
   122d0:	5ec9      	ldrsh	r1, [r1, r3]
   122d2:	b090      	sub	sp, #64	; 0x40
   122d4:	0014      	movs	r4, r2
   122d6:	2900      	cmp	r1, #0
   122d8:	da06      	bge.n	122e8 <__swhatbuf_r+0x20>
   122da:	2300      	movs	r3, #0
   122dc:	602b      	str	r3, [r5, #0]
   122de:	89b3      	ldrh	r3, [r6, #12]
   122e0:	061b      	lsls	r3, r3, #24
   122e2:	d50f      	bpl.n	12304 <__swhatbuf_r+0x3c>
   122e4:	2340      	movs	r3, #64	; 0x40
   122e6:	e00f      	b.n	12308 <__swhatbuf_r+0x40>
   122e8:	aa01      	add	r2, sp, #4
   122ea:	f000 fccf 	bl	12c8c <_fstat_r>
   122ee:	2800      	cmp	r0, #0
   122f0:	dbf3      	blt.n	122da <__swhatbuf_r+0x12>
   122f2:	23f0      	movs	r3, #240	; 0xf0
   122f4:	9a02      	ldr	r2, [sp, #8]
   122f6:	021b      	lsls	r3, r3, #8
   122f8:	4013      	ands	r3, r2
   122fa:	4a05      	ldr	r2, [pc, #20]	; (12310 <__swhatbuf_r+0x48>)
   122fc:	189b      	adds	r3, r3, r2
   122fe:	425a      	negs	r2, r3
   12300:	4153      	adcs	r3, r2
   12302:	602b      	str	r3, [r5, #0]
   12304:	2380      	movs	r3, #128	; 0x80
   12306:	00db      	lsls	r3, r3, #3
   12308:	2000      	movs	r0, #0
   1230a:	6023      	str	r3, [r4, #0]
   1230c:	b010      	add	sp, #64	; 0x40
   1230e:	bd70      	pop	{r4, r5, r6, pc}
   12310:	ffffe000 	.word	0xffffe000

00012314 <__smakebuf_r>:
   12314:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   12316:	2602      	movs	r6, #2
   12318:	898b      	ldrh	r3, [r1, #12]
   1231a:	0005      	movs	r5, r0
   1231c:	000c      	movs	r4, r1
   1231e:	4233      	tst	r3, r6
   12320:	d110      	bne.n	12344 <__smakebuf_r+0x30>
   12322:	ab01      	add	r3, sp, #4
   12324:	466a      	mov	r2, sp
   12326:	f7ff ffcf 	bl	122c8 <__swhatbuf_r>
   1232a:	9900      	ldr	r1, [sp, #0]
   1232c:	0007      	movs	r7, r0
   1232e:	0028      	movs	r0, r5
   12330:	f7ff fad6 	bl	118e0 <_malloc_r>
   12334:	2800      	cmp	r0, #0
   12336:	d10c      	bne.n	12352 <__smakebuf_r+0x3e>
   12338:	220c      	movs	r2, #12
   1233a:	5ea3      	ldrsh	r3, [r4, r2]
   1233c:	059a      	lsls	r2, r3, #22
   1233e:	d423      	bmi.n	12388 <__smakebuf_r+0x74>
   12340:	4333      	orrs	r3, r6
   12342:	81a3      	strh	r3, [r4, #12]
   12344:	0023      	movs	r3, r4
   12346:	3347      	adds	r3, #71	; 0x47
   12348:	6023      	str	r3, [r4, #0]
   1234a:	6123      	str	r3, [r4, #16]
   1234c:	2301      	movs	r3, #1
   1234e:	6163      	str	r3, [r4, #20]
   12350:	e01a      	b.n	12388 <__smakebuf_r+0x74>
   12352:	2280      	movs	r2, #128	; 0x80
   12354:	4b0d      	ldr	r3, [pc, #52]	; (1238c <__smakebuf_r+0x78>)
   12356:	62ab      	str	r3, [r5, #40]	; 0x28
   12358:	89a3      	ldrh	r3, [r4, #12]
   1235a:	6020      	str	r0, [r4, #0]
   1235c:	4313      	orrs	r3, r2
   1235e:	81a3      	strh	r3, [r4, #12]
   12360:	9b00      	ldr	r3, [sp, #0]
   12362:	6120      	str	r0, [r4, #16]
   12364:	6163      	str	r3, [r4, #20]
   12366:	9b01      	ldr	r3, [sp, #4]
   12368:	2b00      	cmp	r3, #0
   1236a:	d00a      	beq.n	12382 <__smakebuf_r+0x6e>
   1236c:	230e      	movs	r3, #14
   1236e:	5ee1      	ldrsh	r1, [r4, r3]
   12370:	0028      	movs	r0, r5
   12372:	f000 fc9d 	bl	12cb0 <_isatty_r>
   12376:	2800      	cmp	r0, #0
   12378:	d003      	beq.n	12382 <__smakebuf_r+0x6e>
   1237a:	2201      	movs	r2, #1
   1237c:	89a3      	ldrh	r3, [r4, #12]
   1237e:	4313      	orrs	r3, r2
   12380:	81a3      	strh	r3, [r4, #12]
   12382:	89a3      	ldrh	r3, [r4, #12]
   12384:	431f      	orrs	r7, r3
   12386:	81a7      	strh	r7, [r4, #12]
   12388:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   1238a:	46c0      	nop			; (mov r8, r8)
   1238c:	000120f5 	.word	0x000120f5

00012390 <__ssputs_r>:
   12390:	b5f0      	push	{r4, r5, r6, r7, lr}
   12392:	688e      	ldr	r6, [r1, #8]
   12394:	b085      	sub	sp, #20
   12396:	0007      	movs	r7, r0
   12398:	000c      	movs	r4, r1
   1239a:	9203      	str	r2, [sp, #12]
   1239c:	9301      	str	r3, [sp, #4]
   1239e:	429e      	cmp	r6, r3
   123a0:	d843      	bhi.n	1242a <__ssputs_r+0x9a>
   123a2:	2390      	movs	r3, #144	; 0x90
   123a4:	898a      	ldrh	r2, [r1, #12]
   123a6:	00db      	lsls	r3, r3, #3
   123a8:	421a      	tst	r2, r3
   123aa:	d03e      	beq.n	1242a <__ssputs_r+0x9a>
   123ac:	2503      	movs	r5, #3
   123ae:	6909      	ldr	r1, [r1, #16]
   123b0:	6823      	ldr	r3, [r4, #0]
   123b2:	9801      	ldr	r0, [sp, #4]
   123b4:	1a5b      	subs	r3, r3, r1
   123b6:	9302      	str	r3, [sp, #8]
   123b8:	6963      	ldr	r3, [r4, #20]
   123ba:	435d      	muls	r5, r3
   123bc:	0feb      	lsrs	r3, r5, #31
   123be:	195d      	adds	r5, r3, r5
   123c0:	9b02      	ldr	r3, [sp, #8]
   123c2:	106d      	asrs	r5, r5, #1
   123c4:	3301      	adds	r3, #1
   123c6:	181b      	adds	r3, r3, r0
   123c8:	42ab      	cmp	r3, r5
   123ca:	d900      	bls.n	123ce <__ssputs_r+0x3e>
   123cc:	001d      	movs	r5, r3
   123ce:	0553      	lsls	r3, r2, #21
   123d0:	d510      	bpl.n	123f4 <__ssputs_r+0x64>
   123d2:	0029      	movs	r1, r5
   123d4:	0038      	movs	r0, r7
   123d6:	f7ff fa83 	bl	118e0 <_malloc_r>
   123da:	1e06      	subs	r6, r0, #0
   123dc:	d014      	beq.n	12408 <__ssputs_r+0x78>
   123de:	9a02      	ldr	r2, [sp, #8]
   123e0:	6921      	ldr	r1, [r4, #16]
   123e2:	f7ff fa26 	bl	11832 <memcpy>
   123e6:	89a2      	ldrh	r2, [r4, #12]
   123e8:	4b19      	ldr	r3, [pc, #100]	; (12450 <__ssputs_r+0xc0>)
   123ea:	4013      	ands	r3, r2
   123ec:	2280      	movs	r2, #128	; 0x80
   123ee:	4313      	orrs	r3, r2
   123f0:	81a3      	strh	r3, [r4, #12]
   123f2:	e012      	b.n	1241a <__ssputs_r+0x8a>
   123f4:	002a      	movs	r2, r5
   123f6:	0038      	movs	r0, r7
   123f8:	f000 fc8c 	bl	12d14 <_realloc_r>
   123fc:	1e06      	subs	r6, r0, #0
   123fe:	d10c      	bne.n	1241a <__ssputs_r+0x8a>
   12400:	6921      	ldr	r1, [r4, #16]
   12402:	0038      	movs	r0, r7
   12404:	f7ff fa26 	bl	11854 <_free_r>
   12408:	230c      	movs	r3, #12
   1240a:	2240      	movs	r2, #64	; 0x40
   1240c:	2001      	movs	r0, #1
   1240e:	603b      	str	r3, [r7, #0]
   12410:	89a3      	ldrh	r3, [r4, #12]
   12412:	4240      	negs	r0, r0
   12414:	4313      	orrs	r3, r2
   12416:	81a3      	strh	r3, [r4, #12]
   12418:	e017      	b.n	1244a <__ssputs_r+0xba>
   1241a:	9b02      	ldr	r3, [sp, #8]
   1241c:	6126      	str	r6, [r4, #16]
   1241e:	18f6      	adds	r6, r6, r3
   12420:	6026      	str	r6, [r4, #0]
   12422:	6165      	str	r5, [r4, #20]
   12424:	9e01      	ldr	r6, [sp, #4]
   12426:	1aed      	subs	r5, r5, r3
   12428:	60a5      	str	r5, [r4, #8]
   1242a:	9b01      	ldr	r3, [sp, #4]
   1242c:	42b3      	cmp	r3, r6
   1242e:	d200      	bcs.n	12432 <__ssputs_r+0xa2>
   12430:	001e      	movs	r6, r3
   12432:	0032      	movs	r2, r6
   12434:	9903      	ldr	r1, [sp, #12]
   12436:	6820      	ldr	r0, [r4, #0]
   12438:	f000 fc57 	bl	12cea <memmove>
   1243c:	2000      	movs	r0, #0
   1243e:	68a3      	ldr	r3, [r4, #8]
   12440:	1b9b      	subs	r3, r3, r6
   12442:	60a3      	str	r3, [r4, #8]
   12444:	6823      	ldr	r3, [r4, #0]
   12446:	199e      	adds	r6, r3, r6
   12448:	6026      	str	r6, [r4, #0]
   1244a:	b005      	add	sp, #20
   1244c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1244e:	46c0      	nop			; (mov r8, r8)
   12450:	fffffb7f 	.word	0xfffffb7f

00012454 <_svfiprintf_r>:
   12454:	b5f0      	push	{r4, r5, r6, r7, lr}
   12456:	b09f      	sub	sp, #124	; 0x7c
   12458:	9002      	str	r0, [sp, #8]
   1245a:	9305      	str	r3, [sp, #20]
   1245c:	898b      	ldrh	r3, [r1, #12]
   1245e:	000f      	movs	r7, r1
   12460:	0016      	movs	r6, r2
   12462:	061b      	lsls	r3, r3, #24
   12464:	d510      	bpl.n	12488 <_svfiprintf_r+0x34>
   12466:	690b      	ldr	r3, [r1, #16]
   12468:	2b00      	cmp	r3, #0
   1246a:	d10d      	bne.n	12488 <_svfiprintf_r+0x34>
   1246c:	2140      	movs	r1, #64	; 0x40
   1246e:	f7ff fa37 	bl	118e0 <_malloc_r>
   12472:	6038      	str	r0, [r7, #0]
   12474:	6138      	str	r0, [r7, #16]
   12476:	2800      	cmp	r0, #0
   12478:	d104      	bne.n	12484 <_svfiprintf_r+0x30>
   1247a:	230c      	movs	r3, #12
   1247c:	9a02      	ldr	r2, [sp, #8]
   1247e:	3801      	subs	r0, #1
   12480:	6013      	str	r3, [r2, #0]
   12482:	e0d8      	b.n	12636 <_svfiprintf_r+0x1e2>
   12484:	2340      	movs	r3, #64	; 0x40
   12486:	617b      	str	r3, [r7, #20]
   12488:	2300      	movs	r3, #0
   1248a:	ad06      	add	r5, sp, #24
   1248c:	616b      	str	r3, [r5, #20]
   1248e:	3320      	adds	r3, #32
   12490:	766b      	strb	r3, [r5, #25]
   12492:	3310      	adds	r3, #16
   12494:	76ab      	strb	r3, [r5, #26]
   12496:	0034      	movs	r4, r6
   12498:	7823      	ldrb	r3, [r4, #0]
   1249a:	2b00      	cmp	r3, #0
   1249c:	d103      	bne.n	124a6 <_svfiprintf_r+0x52>
   1249e:	1ba3      	subs	r3, r4, r6
   124a0:	9304      	str	r3, [sp, #16]
   124a2:	d012      	beq.n	124ca <_svfiprintf_r+0x76>
   124a4:	e003      	b.n	124ae <_svfiprintf_r+0x5a>
   124a6:	2b25      	cmp	r3, #37	; 0x25
   124a8:	d0f9      	beq.n	1249e <_svfiprintf_r+0x4a>
   124aa:	3401      	adds	r4, #1
   124ac:	e7f4      	b.n	12498 <_svfiprintf_r+0x44>
   124ae:	1ba3      	subs	r3, r4, r6
   124b0:	0032      	movs	r2, r6
   124b2:	0039      	movs	r1, r7
   124b4:	9802      	ldr	r0, [sp, #8]
   124b6:	f7ff ff6b 	bl	12390 <__ssputs_r>
   124ba:	1c43      	adds	r3, r0, #1
   124bc:	d100      	bne.n	124c0 <_svfiprintf_r+0x6c>
   124be:	e0b4      	b.n	1262a <_svfiprintf_r+0x1d6>
   124c0:	696a      	ldr	r2, [r5, #20]
   124c2:	9b04      	ldr	r3, [sp, #16]
   124c4:	4694      	mov	ip, r2
   124c6:	4463      	add	r3, ip
   124c8:	616b      	str	r3, [r5, #20]
   124ca:	7823      	ldrb	r3, [r4, #0]
   124cc:	2b00      	cmp	r3, #0
   124ce:	d100      	bne.n	124d2 <_svfiprintf_r+0x7e>
   124d0:	e0ab      	b.n	1262a <_svfiprintf_r+0x1d6>
   124d2:	2201      	movs	r2, #1
   124d4:	2300      	movs	r3, #0
   124d6:	4252      	negs	r2, r2
   124d8:	606a      	str	r2, [r5, #4]
   124da:	a902      	add	r1, sp, #8
   124dc:	3254      	adds	r2, #84	; 0x54
   124de:	1852      	adds	r2, r2, r1
   124e0:	3401      	adds	r4, #1
   124e2:	602b      	str	r3, [r5, #0]
   124e4:	60eb      	str	r3, [r5, #12]
   124e6:	60ab      	str	r3, [r5, #8]
   124e8:	7013      	strb	r3, [r2, #0]
   124ea:	65ab      	str	r3, [r5, #88]	; 0x58
   124ec:	4e53      	ldr	r6, [pc, #332]	; (1263c <_svfiprintf_r+0x1e8>)
   124ee:	7821      	ldrb	r1, [r4, #0]
   124f0:	2205      	movs	r2, #5
   124f2:	0030      	movs	r0, r6
   124f4:	f000 fbee 	bl	12cd4 <memchr>
   124f8:	2800      	cmp	r0, #0
   124fa:	d007      	beq.n	1250c <_svfiprintf_r+0xb8>
   124fc:	2301      	movs	r3, #1
   124fe:	1b80      	subs	r0, r0, r6
   12500:	4083      	lsls	r3, r0
   12502:	682a      	ldr	r2, [r5, #0]
   12504:	3401      	adds	r4, #1
   12506:	4313      	orrs	r3, r2
   12508:	602b      	str	r3, [r5, #0]
   1250a:	e7ef      	b.n	124ec <_svfiprintf_r+0x98>
   1250c:	682b      	ldr	r3, [r5, #0]
   1250e:	06da      	lsls	r2, r3, #27
   12510:	d504      	bpl.n	1251c <_svfiprintf_r+0xc8>
   12512:	2253      	movs	r2, #83	; 0x53
   12514:	2120      	movs	r1, #32
   12516:	a802      	add	r0, sp, #8
   12518:	1812      	adds	r2, r2, r0
   1251a:	7011      	strb	r1, [r2, #0]
   1251c:	071a      	lsls	r2, r3, #28
   1251e:	d504      	bpl.n	1252a <_svfiprintf_r+0xd6>
   12520:	2253      	movs	r2, #83	; 0x53
   12522:	212b      	movs	r1, #43	; 0x2b
   12524:	a802      	add	r0, sp, #8
   12526:	1812      	adds	r2, r2, r0
   12528:	7011      	strb	r1, [r2, #0]
   1252a:	7822      	ldrb	r2, [r4, #0]
   1252c:	2a2a      	cmp	r2, #42	; 0x2a
   1252e:	d003      	beq.n	12538 <_svfiprintf_r+0xe4>
   12530:	9b09      	ldr	r3, [sp, #36]	; 0x24
   12532:	2000      	movs	r0, #0
   12534:	210a      	movs	r1, #10
   12536:	e00e      	b.n	12556 <_svfiprintf_r+0x102>
   12538:	9a05      	ldr	r2, [sp, #20]
   1253a:	1d11      	adds	r1, r2, #4
   1253c:	6812      	ldr	r2, [r2, #0]
   1253e:	9105      	str	r1, [sp, #20]
   12540:	2a00      	cmp	r2, #0
   12542:	db01      	blt.n	12548 <_svfiprintf_r+0xf4>
   12544:	9209      	str	r2, [sp, #36]	; 0x24
   12546:	e004      	b.n	12552 <_svfiprintf_r+0xfe>
   12548:	4252      	negs	r2, r2
   1254a:	60ea      	str	r2, [r5, #12]
   1254c:	2202      	movs	r2, #2
   1254e:	4313      	orrs	r3, r2
   12550:	602b      	str	r3, [r5, #0]
   12552:	3401      	adds	r4, #1
   12554:	e00b      	b.n	1256e <_svfiprintf_r+0x11a>
   12556:	7822      	ldrb	r2, [r4, #0]
   12558:	3a30      	subs	r2, #48	; 0x30
   1255a:	2a09      	cmp	r2, #9
   1255c:	d804      	bhi.n	12568 <_svfiprintf_r+0x114>
   1255e:	434b      	muls	r3, r1
   12560:	3401      	adds	r4, #1
   12562:	189b      	adds	r3, r3, r2
   12564:	2001      	movs	r0, #1
   12566:	e7f6      	b.n	12556 <_svfiprintf_r+0x102>
   12568:	2800      	cmp	r0, #0
   1256a:	d000      	beq.n	1256e <_svfiprintf_r+0x11a>
   1256c:	9309      	str	r3, [sp, #36]	; 0x24
   1256e:	7823      	ldrb	r3, [r4, #0]
   12570:	2b2e      	cmp	r3, #46	; 0x2e
   12572:	d11e      	bne.n	125b2 <_svfiprintf_r+0x15e>
   12574:	7863      	ldrb	r3, [r4, #1]
   12576:	2b2a      	cmp	r3, #42	; 0x2a
   12578:	d10a      	bne.n	12590 <_svfiprintf_r+0x13c>
   1257a:	9b05      	ldr	r3, [sp, #20]
   1257c:	3402      	adds	r4, #2
   1257e:	1d1a      	adds	r2, r3, #4
   12580:	681b      	ldr	r3, [r3, #0]
   12582:	9205      	str	r2, [sp, #20]
   12584:	2b00      	cmp	r3, #0
   12586:	da01      	bge.n	1258c <_svfiprintf_r+0x138>
   12588:	2301      	movs	r3, #1
   1258a:	425b      	negs	r3, r3
   1258c:	9307      	str	r3, [sp, #28]
   1258e:	e010      	b.n	125b2 <_svfiprintf_r+0x15e>
   12590:	2300      	movs	r3, #0
   12592:	200a      	movs	r0, #10
   12594:	001a      	movs	r2, r3
   12596:	3401      	adds	r4, #1
   12598:	606b      	str	r3, [r5, #4]
   1259a:	7821      	ldrb	r1, [r4, #0]
   1259c:	3930      	subs	r1, #48	; 0x30
   1259e:	2909      	cmp	r1, #9
   125a0:	d804      	bhi.n	125ac <_svfiprintf_r+0x158>
   125a2:	4342      	muls	r2, r0
   125a4:	3401      	adds	r4, #1
   125a6:	1852      	adds	r2, r2, r1
   125a8:	2301      	movs	r3, #1
   125aa:	e7f6      	b.n	1259a <_svfiprintf_r+0x146>
   125ac:	2b00      	cmp	r3, #0
   125ae:	d000      	beq.n	125b2 <_svfiprintf_r+0x15e>
   125b0:	9207      	str	r2, [sp, #28]
   125b2:	4e23      	ldr	r6, [pc, #140]	; (12640 <_svfiprintf_r+0x1ec>)
   125b4:	7821      	ldrb	r1, [r4, #0]
   125b6:	2203      	movs	r2, #3
   125b8:	0030      	movs	r0, r6
   125ba:	f000 fb8b 	bl	12cd4 <memchr>
   125be:	2800      	cmp	r0, #0
   125c0:	d006      	beq.n	125d0 <_svfiprintf_r+0x17c>
   125c2:	2340      	movs	r3, #64	; 0x40
   125c4:	1b80      	subs	r0, r0, r6
   125c6:	4083      	lsls	r3, r0
   125c8:	682a      	ldr	r2, [r5, #0]
   125ca:	3401      	adds	r4, #1
   125cc:	4313      	orrs	r3, r2
   125ce:	602b      	str	r3, [r5, #0]
   125d0:	7821      	ldrb	r1, [r4, #0]
   125d2:	2206      	movs	r2, #6
   125d4:	481b      	ldr	r0, [pc, #108]	; (12644 <_svfiprintf_r+0x1f0>)
   125d6:	1c66      	adds	r6, r4, #1
   125d8:	7629      	strb	r1, [r5, #24]
   125da:	f000 fb7b 	bl	12cd4 <memchr>
   125de:	2800      	cmp	r0, #0
   125e0:	d012      	beq.n	12608 <_svfiprintf_r+0x1b4>
   125e2:	4b19      	ldr	r3, [pc, #100]	; (12648 <_svfiprintf_r+0x1f4>)
   125e4:	2b00      	cmp	r3, #0
   125e6:	d106      	bne.n	125f6 <_svfiprintf_r+0x1a2>
   125e8:	2207      	movs	r2, #7
   125ea:	9b05      	ldr	r3, [sp, #20]
   125ec:	3307      	adds	r3, #7
   125ee:	4393      	bics	r3, r2
   125f0:	3308      	adds	r3, #8
   125f2:	9305      	str	r3, [sp, #20]
   125f4:	e014      	b.n	12620 <_svfiprintf_r+0x1cc>
   125f6:	ab05      	add	r3, sp, #20
   125f8:	9300      	str	r3, [sp, #0]
   125fa:	003a      	movs	r2, r7
   125fc:	4b13      	ldr	r3, [pc, #76]	; (1264c <_svfiprintf_r+0x1f8>)
   125fe:	0029      	movs	r1, r5
   12600:	9802      	ldr	r0, [sp, #8]
   12602:	e000      	b.n	12606 <_svfiprintf_r+0x1b2>
   12604:	bf00      	nop
   12606:	e007      	b.n	12618 <_svfiprintf_r+0x1c4>
   12608:	ab05      	add	r3, sp, #20
   1260a:	9300      	str	r3, [sp, #0]
   1260c:	003a      	movs	r2, r7
   1260e:	4b0f      	ldr	r3, [pc, #60]	; (1264c <_svfiprintf_r+0x1f8>)
   12610:	0029      	movs	r1, r5
   12612:	9802      	ldr	r0, [sp, #8]
   12614:	f000 f9ce 	bl	129b4 <_printf_i>
   12618:	9003      	str	r0, [sp, #12]
   1261a:	9b03      	ldr	r3, [sp, #12]
   1261c:	3301      	adds	r3, #1
   1261e:	d004      	beq.n	1262a <_svfiprintf_r+0x1d6>
   12620:	696b      	ldr	r3, [r5, #20]
   12622:	9a03      	ldr	r2, [sp, #12]
   12624:	189b      	adds	r3, r3, r2
   12626:	616b      	str	r3, [r5, #20]
   12628:	e735      	b.n	12496 <_svfiprintf_r+0x42>
   1262a:	89bb      	ldrh	r3, [r7, #12]
   1262c:	980b      	ldr	r0, [sp, #44]	; 0x2c
   1262e:	065b      	lsls	r3, r3, #25
   12630:	d501      	bpl.n	12636 <_svfiprintf_r+0x1e2>
   12632:	2001      	movs	r0, #1
   12634:	4240      	negs	r0, r0
   12636:	b01f      	add	sp, #124	; 0x7c
   12638:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1263a:	46c0      	nop			; (mov r8, r8)
   1263c:	0001c160 	.word	0x0001c160
   12640:	0001c166 	.word	0x0001c166
   12644:	0001c16a 	.word	0x0001c16a
   12648:	00000000 	.word	0x00000000
   1264c:	00012391 	.word	0x00012391

00012650 <__sfputc_r>:
   12650:	6893      	ldr	r3, [r2, #8]
   12652:	b510      	push	{r4, lr}
   12654:	3b01      	subs	r3, #1
   12656:	6093      	str	r3, [r2, #8]
   12658:	2b00      	cmp	r3, #0
   1265a:	da05      	bge.n	12668 <__sfputc_r+0x18>
   1265c:	6994      	ldr	r4, [r2, #24]
   1265e:	42a3      	cmp	r3, r4
   12660:	db08      	blt.n	12674 <__sfputc_r+0x24>
   12662:	b2cb      	uxtb	r3, r1
   12664:	2b0a      	cmp	r3, #10
   12666:	d005      	beq.n	12674 <__sfputc_r+0x24>
   12668:	6813      	ldr	r3, [r2, #0]
   1266a:	1c58      	adds	r0, r3, #1
   1266c:	6010      	str	r0, [r2, #0]
   1266e:	7019      	strb	r1, [r3, #0]
   12670:	b2c8      	uxtb	r0, r1
   12672:	e001      	b.n	12678 <__sfputc_r+0x28>
   12674:	f7ff fb98 	bl	11da8 <__swbuf_r>
   12678:	bd10      	pop	{r4, pc}

0001267a <__sfputs_r>:
   1267a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1267c:	0006      	movs	r6, r0
   1267e:	000f      	movs	r7, r1
   12680:	0014      	movs	r4, r2
   12682:	18d5      	adds	r5, r2, r3
   12684:	42ac      	cmp	r4, r5
   12686:	d008      	beq.n	1269a <__sfputs_r+0x20>
   12688:	7821      	ldrb	r1, [r4, #0]
   1268a:	003a      	movs	r2, r7
   1268c:	0030      	movs	r0, r6
   1268e:	f7ff ffdf 	bl	12650 <__sfputc_r>
   12692:	3401      	adds	r4, #1
   12694:	1c43      	adds	r3, r0, #1
   12696:	d1f5      	bne.n	12684 <__sfputs_r+0xa>
   12698:	e000      	b.n	1269c <__sfputs_r+0x22>
   1269a:	2000      	movs	r0, #0
   1269c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

000126a0 <_vfiprintf_r>:
   126a0:	b5f0      	push	{r4, r5, r6, r7, lr}
   126a2:	b09f      	sub	sp, #124	; 0x7c
   126a4:	0006      	movs	r6, r0
   126a6:	000f      	movs	r7, r1
   126a8:	9202      	str	r2, [sp, #8]
   126aa:	9305      	str	r3, [sp, #20]
   126ac:	2800      	cmp	r0, #0
   126ae:	d004      	beq.n	126ba <_vfiprintf_r+0x1a>
   126b0:	6983      	ldr	r3, [r0, #24]
   126b2:	2b00      	cmp	r3, #0
   126b4:	d101      	bne.n	126ba <_vfiprintf_r+0x1a>
   126b6:	f7ff fd5f 	bl	12178 <__sinit>
   126ba:	4b7f      	ldr	r3, [pc, #508]	; (128b8 <_vfiprintf_r+0x218>)
   126bc:	429f      	cmp	r7, r3
   126be:	d101      	bne.n	126c4 <_vfiprintf_r+0x24>
   126c0:	6877      	ldr	r7, [r6, #4]
   126c2:	e008      	b.n	126d6 <_vfiprintf_r+0x36>
   126c4:	4b7d      	ldr	r3, [pc, #500]	; (128bc <_vfiprintf_r+0x21c>)
   126c6:	429f      	cmp	r7, r3
   126c8:	d101      	bne.n	126ce <_vfiprintf_r+0x2e>
   126ca:	68b7      	ldr	r7, [r6, #8]
   126cc:	e003      	b.n	126d6 <_vfiprintf_r+0x36>
   126ce:	4b7c      	ldr	r3, [pc, #496]	; (128c0 <_vfiprintf_r+0x220>)
   126d0:	429f      	cmp	r7, r3
   126d2:	d100      	bne.n	126d6 <_vfiprintf_r+0x36>
   126d4:	68f7      	ldr	r7, [r6, #12]
   126d6:	89bb      	ldrh	r3, [r7, #12]
   126d8:	071b      	lsls	r3, r3, #28
   126da:	d50a      	bpl.n	126f2 <_vfiprintf_r+0x52>
   126dc:	693b      	ldr	r3, [r7, #16]
   126de:	2b00      	cmp	r3, #0
   126e0:	d007      	beq.n	126f2 <_vfiprintf_r+0x52>
   126e2:	2300      	movs	r3, #0
   126e4:	ad06      	add	r5, sp, #24
   126e6:	616b      	str	r3, [r5, #20]
   126e8:	3320      	adds	r3, #32
   126ea:	766b      	strb	r3, [r5, #25]
   126ec:	3310      	adds	r3, #16
   126ee:	76ab      	strb	r3, [r5, #26]
   126f0:	e03d      	b.n	1276e <_vfiprintf_r+0xce>
   126f2:	0039      	movs	r1, r7
   126f4:	0030      	movs	r0, r6
   126f6:	f7ff fbc3 	bl	11e80 <__swsetup_r>
   126fa:	2800      	cmp	r0, #0
   126fc:	d0f1      	beq.n	126e2 <_vfiprintf_r+0x42>
   126fe:	2001      	movs	r0, #1
   12700:	4240      	negs	r0, r0
   12702:	e0d6      	b.n	128b2 <_vfiprintf_r+0x212>
   12704:	9a05      	ldr	r2, [sp, #20]
   12706:	1d11      	adds	r1, r2, #4
   12708:	6812      	ldr	r2, [r2, #0]
   1270a:	9105      	str	r1, [sp, #20]
   1270c:	2a00      	cmp	r2, #0
   1270e:	da00      	bge.n	12712 <_vfiprintf_r+0x72>
   12710:	e07f      	b.n	12812 <_vfiprintf_r+0x172>
   12712:	9209      	str	r2, [sp, #36]	; 0x24
   12714:	3401      	adds	r4, #1
   12716:	7823      	ldrb	r3, [r4, #0]
   12718:	2b2e      	cmp	r3, #46	; 0x2e
   1271a:	d100      	bne.n	1271e <_vfiprintf_r+0x7e>
   1271c:	e08d      	b.n	1283a <_vfiprintf_r+0x19a>
   1271e:	7821      	ldrb	r1, [r4, #0]
   12720:	2203      	movs	r2, #3
   12722:	4868      	ldr	r0, [pc, #416]	; (128c4 <_vfiprintf_r+0x224>)
   12724:	f000 fad6 	bl	12cd4 <memchr>
   12728:	2800      	cmp	r0, #0
   1272a:	d007      	beq.n	1273c <_vfiprintf_r+0x9c>
   1272c:	4b65      	ldr	r3, [pc, #404]	; (128c4 <_vfiprintf_r+0x224>)
   1272e:	682a      	ldr	r2, [r5, #0]
   12730:	1ac0      	subs	r0, r0, r3
   12732:	2340      	movs	r3, #64	; 0x40
   12734:	4083      	lsls	r3, r0
   12736:	4313      	orrs	r3, r2
   12738:	602b      	str	r3, [r5, #0]
   1273a:	3401      	adds	r4, #1
   1273c:	7821      	ldrb	r1, [r4, #0]
   1273e:	1c63      	adds	r3, r4, #1
   12740:	2206      	movs	r2, #6
   12742:	4861      	ldr	r0, [pc, #388]	; (128c8 <_vfiprintf_r+0x228>)
   12744:	9302      	str	r3, [sp, #8]
   12746:	7629      	strb	r1, [r5, #24]
   12748:	f000 fac4 	bl	12cd4 <memchr>
   1274c:	2800      	cmp	r0, #0
   1274e:	d100      	bne.n	12752 <_vfiprintf_r+0xb2>
   12750:	e09d      	b.n	1288e <_vfiprintf_r+0x1ee>
   12752:	4b5e      	ldr	r3, [pc, #376]	; (128cc <_vfiprintf_r+0x22c>)
   12754:	2b00      	cmp	r3, #0
   12756:	d000      	beq.n	1275a <_vfiprintf_r+0xba>
   12758:	e090      	b.n	1287c <_vfiprintf_r+0x1dc>
   1275a:	2207      	movs	r2, #7
   1275c:	9b05      	ldr	r3, [sp, #20]
   1275e:	3307      	adds	r3, #7
   12760:	4393      	bics	r3, r2
   12762:	3308      	adds	r3, #8
   12764:	9305      	str	r3, [sp, #20]
   12766:	696b      	ldr	r3, [r5, #20]
   12768:	9a03      	ldr	r2, [sp, #12]
   1276a:	189b      	adds	r3, r3, r2
   1276c:	616b      	str	r3, [r5, #20]
   1276e:	9c02      	ldr	r4, [sp, #8]
   12770:	7823      	ldrb	r3, [r4, #0]
   12772:	2b00      	cmp	r3, #0
   12774:	d104      	bne.n	12780 <_vfiprintf_r+0xe0>
   12776:	9b02      	ldr	r3, [sp, #8]
   12778:	1ae3      	subs	r3, r4, r3
   1277a:	9304      	str	r3, [sp, #16]
   1277c:	d012      	beq.n	127a4 <_vfiprintf_r+0x104>
   1277e:	e003      	b.n	12788 <_vfiprintf_r+0xe8>
   12780:	2b25      	cmp	r3, #37	; 0x25
   12782:	d0f8      	beq.n	12776 <_vfiprintf_r+0xd6>
   12784:	3401      	adds	r4, #1
   12786:	e7f3      	b.n	12770 <_vfiprintf_r+0xd0>
   12788:	9b04      	ldr	r3, [sp, #16]
   1278a:	9a02      	ldr	r2, [sp, #8]
   1278c:	0039      	movs	r1, r7
   1278e:	0030      	movs	r0, r6
   12790:	f7ff ff73 	bl	1267a <__sfputs_r>
   12794:	1c43      	adds	r3, r0, #1
   12796:	d100      	bne.n	1279a <_vfiprintf_r+0xfa>
   12798:	e086      	b.n	128a8 <_vfiprintf_r+0x208>
   1279a:	696a      	ldr	r2, [r5, #20]
   1279c:	9b04      	ldr	r3, [sp, #16]
   1279e:	4694      	mov	ip, r2
   127a0:	4463      	add	r3, ip
   127a2:	616b      	str	r3, [r5, #20]
   127a4:	7823      	ldrb	r3, [r4, #0]
   127a6:	2b00      	cmp	r3, #0
   127a8:	d07e      	beq.n	128a8 <_vfiprintf_r+0x208>
   127aa:	2201      	movs	r2, #1
   127ac:	2300      	movs	r3, #0
   127ae:	4252      	negs	r2, r2
   127b0:	606a      	str	r2, [r5, #4]
   127b2:	a902      	add	r1, sp, #8
   127b4:	3254      	adds	r2, #84	; 0x54
   127b6:	1852      	adds	r2, r2, r1
   127b8:	3401      	adds	r4, #1
   127ba:	602b      	str	r3, [r5, #0]
   127bc:	60eb      	str	r3, [r5, #12]
   127be:	60ab      	str	r3, [r5, #8]
   127c0:	7013      	strb	r3, [r2, #0]
   127c2:	65ab      	str	r3, [r5, #88]	; 0x58
   127c4:	7821      	ldrb	r1, [r4, #0]
   127c6:	2205      	movs	r2, #5
   127c8:	4841      	ldr	r0, [pc, #260]	; (128d0 <_vfiprintf_r+0x230>)
   127ca:	f000 fa83 	bl	12cd4 <memchr>
   127ce:	2800      	cmp	r0, #0
   127d0:	d008      	beq.n	127e4 <_vfiprintf_r+0x144>
   127d2:	4b3f      	ldr	r3, [pc, #252]	; (128d0 <_vfiprintf_r+0x230>)
   127d4:	682a      	ldr	r2, [r5, #0]
   127d6:	1ac0      	subs	r0, r0, r3
   127d8:	2301      	movs	r3, #1
   127da:	4083      	lsls	r3, r0
   127dc:	4313      	orrs	r3, r2
   127de:	602b      	str	r3, [r5, #0]
   127e0:	3401      	adds	r4, #1
   127e2:	e7ef      	b.n	127c4 <_vfiprintf_r+0x124>
   127e4:	682b      	ldr	r3, [r5, #0]
   127e6:	06da      	lsls	r2, r3, #27
   127e8:	d504      	bpl.n	127f4 <_vfiprintf_r+0x154>
   127ea:	2253      	movs	r2, #83	; 0x53
   127ec:	2120      	movs	r1, #32
   127ee:	a802      	add	r0, sp, #8
   127f0:	1812      	adds	r2, r2, r0
   127f2:	7011      	strb	r1, [r2, #0]
   127f4:	071a      	lsls	r2, r3, #28
   127f6:	d504      	bpl.n	12802 <_vfiprintf_r+0x162>
   127f8:	2253      	movs	r2, #83	; 0x53
   127fa:	212b      	movs	r1, #43	; 0x2b
   127fc:	a802      	add	r0, sp, #8
   127fe:	1812      	adds	r2, r2, r0
   12800:	7011      	strb	r1, [r2, #0]
   12802:	7822      	ldrb	r2, [r4, #0]
   12804:	2a2a      	cmp	r2, #42	; 0x2a
   12806:	d100      	bne.n	1280a <_vfiprintf_r+0x16a>
   12808:	e77c      	b.n	12704 <_vfiprintf_r+0x64>
   1280a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1280c:	2000      	movs	r0, #0
   1280e:	210a      	movs	r1, #10
   12810:	e005      	b.n	1281e <_vfiprintf_r+0x17e>
   12812:	4252      	negs	r2, r2
   12814:	60ea      	str	r2, [r5, #12]
   12816:	2202      	movs	r2, #2
   12818:	4313      	orrs	r3, r2
   1281a:	602b      	str	r3, [r5, #0]
   1281c:	e77a      	b.n	12714 <_vfiprintf_r+0x74>
   1281e:	7822      	ldrb	r2, [r4, #0]
   12820:	3a30      	subs	r2, #48	; 0x30
   12822:	2a09      	cmp	r2, #9
   12824:	d804      	bhi.n	12830 <_vfiprintf_r+0x190>
   12826:	434b      	muls	r3, r1
   12828:	3401      	adds	r4, #1
   1282a:	189b      	adds	r3, r3, r2
   1282c:	2001      	movs	r0, #1
   1282e:	e7f6      	b.n	1281e <_vfiprintf_r+0x17e>
   12830:	2800      	cmp	r0, #0
   12832:	d100      	bne.n	12836 <_vfiprintf_r+0x196>
   12834:	e76f      	b.n	12716 <_vfiprintf_r+0x76>
   12836:	9309      	str	r3, [sp, #36]	; 0x24
   12838:	e76d      	b.n	12716 <_vfiprintf_r+0x76>
   1283a:	7863      	ldrb	r3, [r4, #1]
   1283c:	2b2a      	cmp	r3, #42	; 0x2a
   1283e:	d10a      	bne.n	12856 <_vfiprintf_r+0x1b6>
   12840:	9b05      	ldr	r3, [sp, #20]
   12842:	3402      	adds	r4, #2
   12844:	1d1a      	adds	r2, r3, #4
   12846:	681b      	ldr	r3, [r3, #0]
   12848:	9205      	str	r2, [sp, #20]
   1284a:	2b00      	cmp	r3, #0
   1284c:	da01      	bge.n	12852 <_vfiprintf_r+0x1b2>
   1284e:	2301      	movs	r3, #1
   12850:	425b      	negs	r3, r3
   12852:	9307      	str	r3, [sp, #28]
   12854:	e763      	b.n	1271e <_vfiprintf_r+0x7e>
   12856:	2300      	movs	r3, #0
   12858:	200a      	movs	r0, #10
   1285a:	001a      	movs	r2, r3
   1285c:	3401      	adds	r4, #1
   1285e:	606b      	str	r3, [r5, #4]
   12860:	7821      	ldrb	r1, [r4, #0]
   12862:	3930      	subs	r1, #48	; 0x30
   12864:	2909      	cmp	r1, #9
   12866:	d804      	bhi.n	12872 <_vfiprintf_r+0x1d2>
   12868:	4342      	muls	r2, r0
   1286a:	3401      	adds	r4, #1
   1286c:	1852      	adds	r2, r2, r1
   1286e:	2301      	movs	r3, #1
   12870:	e7f6      	b.n	12860 <_vfiprintf_r+0x1c0>
   12872:	2b00      	cmp	r3, #0
   12874:	d100      	bne.n	12878 <_vfiprintf_r+0x1d8>
   12876:	e752      	b.n	1271e <_vfiprintf_r+0x7e>
   12878:	9207      	str	r2, [sp, #28]
   1287a:	e750      	b.n	1271e <_vfiprintf_r+0x7e>
   1287c:	ab05      	add	r3, sp, #20
   1287e:	9300      	str	r3, [sp, #0]
   12880:	003a      	movs	r2, r7
   12882:	4b14      	ldr	r3, [pc, #80]	; (128d4 <_vfiprintf_r+0x234>)
   12884:	0029      	movs	r1, r5
   12886:	0030      	movs	r0, r6
   12888:	e000      	b.n	1288c <_vfiprintf_r+0x1ec>
   1288a:	bf00      	nop
   1288c:	e007      	b.n	1289e <_vfiprintf_r+0x1fe>
   1288e:	ab05      	add	r3, sp, #20
   12890:	9300      	str	r3, [sp, #0]
   12892:	003a      	movs	r2, r7
   12894:	4b0f      	ldr	r3, [pc, #60]	; (128d4 <_vfiprintf_r+0x234>)
   12896:	0029      	movs	r1, r5
   12898:	0030      	movs	r0, r6
   1289a:	f000 f88b 	bl	129b4 <_printf_i>
   1289e:	9003      	str	r0, [sp, #12]
   128a0:	9b03      	ldr	r3, [sp, #12]
   128a2:	3301      	adds	r3, #1
   128a4:	d000      	beq.n	128a8 <_vfiprintf_r+0x208>
   128a6:	e75e      	b.n	12766 <_vfiprintf_r+0xc6>
   128a8:	89bb      	ldrh	r3, [r7, #12]
   128aa:	065b      	lsls	r3, r3, #25
   128ac:	d500      	bpl.n	128b0 <_vfiprintf_r+0x210>
   128ae:	e726      	b.n	126fe <_vfiprintf_r+0x5e>
   128b0:	980b      	ldr	r0, [sp, #44]	; 0x2c
   128b2:	b01f      	add	sp, #124	; 0x7c
   128b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   128b6:	46c0      	nop			; (mov r8, r8)
   128b8:	0001c100 	.word	0x0001c100
   128bc:	0001c120 	.word	0x0001c120
   128c0:	0001c140 	.word	0x0001c140
   128c4:	0001c166 	.word	0x0001c166
   128c8:	0001c16a 	.word	0x0001c16a
   128cc:	00000000 	.word	0x00000000
   128d0:	0001c160 	.word	0x0001c160
   128d4:	0001267b 	.word	0x0001267b

000128d8 <_printf_common>:
   128d8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   128da:	0017      	movs	r7, r2
   128dc:	9301      	str	r3, [sp, #4]
   128de:	688a      	ldr	r2, [r1, #8]
   128e0:	690b      	ldr	r3, [r1, #16]
   128e2:	9000      	str	r0, [sp, #0]
   128e4:	000c      	movs	r4, r1
   128e6:	4293      	cmp	r3, r2
   128e8:	da00      	bge.n	128ec <_printf_common+0x14>
   128ea:	0013      	movs	r3, r2
   128ec:	0022      	movs	r2, r4
   128ee:	603b      	str	r3, [r7, #0]
   128f0:	3243      	adds	r2, #67	; 0x43
   128f2:	7812      	ldrb	r2, [r2, #0]
   128f4:	2a00      	cmp	r2, #0
   128f6:	d001      	beq.n	128fc <_printf_common+0x24>
   128f8:	3301      	adds	r3, #1
   128fa:	603b      	str	r3, [r7, #0]
   128fc:	6823      	ldr	r3, [r4, #0]
   128fe:	069b      	lsls	r3, r3, #26
   12900:	d502      	bpl.n	12908 <_printf_common+0x30>
   12902:	683b      	ldr	r3, [r7, #0]
   12904:	3302      	adds	r3, #2
   12906:	603b      	str	r3, [r7, #0]
   12908:	2506      	movs	r5, #6
   1290a:	6823      	ldr	r3, [r4, #0]
   1290c:	401d      	ands	r5, r3
   1290e:	d01e      	beq.n	1294e <_printf_common+0x76>
   12910:	0023      	movs	r3, r4
   12912:	3343      	adds	r3, #67	; 0x43
   12914:	781b      	ldrb	r3, [r3, #0]
   12916:	1e5a      	subs	r2, r3, #1
   12918:	4193      	sbcs	r3, r2
   1291a:	6822      	ldr	r2, [r4, #0]
   1291c:	0692      	lsls	r2, r2, #26
   1291e:	d51c      	bpl.n	1295a <_printf_common+0x82>
   12920:	2030      	movs	r0, #48	; 0x30
   12922:	18e1      	adds	r1, r4, r3
   12924:	3143      	adds	r1, #67	; 0x43
   12926:	7008      	strb	r0, [r1, #0]
   12928:	0021      	movs	r1, r4
   1292a:	1c5a      	adds	r2, r3, #1
   1292c:	3145      	adds	r1, #69	; 0x45
   1292e:	7809      	ldrb	r1, [r1, #0]
   12930:	18a2      	adds	r2, r4, r2
   12932:	3243      	adds	r2, #67	; 0x43
   12934:	3302      	adds	r3, #2
   12936:	7011      	strb	r1, [r2, #0]
   12938:	e00f      	b.n	1295a <_printf_common+0x82>
   1293a:	0022      	movs	r2, r4
   1293c:	2301      	movs	r3, #1
   1293e:	3219      	adds	r2, #25
   12940:	9901      	ldr	r1, [sp, #4]
   12942:	9800      	ldr	r0, [sp, #0]
   12944:	9e08      	ldr	r6, [sp, #32]
   12946:	47b0      	blx	r6
   12948:	1c43      	adds	r3, r0, #1
   1294a:	d00e      	beq.n	1296a <_printf_common+0x92>
   1294c:	3501      	adds	r5, #1
   1294e:	68e3      	ldr	r3, [r4, #12]
   12950:	683a      	ldr	r2, [r7, #0]
   12952:	1a9b      	subs	r3, r3, r2
   12954:	429d      	cmp	r5, r3
   12956:	dbf0      	blt.n	1293a <_printf_common+0x62>
   12958:	e7da      	b.n	12910 <_printf_common+0x38>
   1295a:	0022      	movs	r2, r4
   1295c:	9901      	ldr	r1, [sp, #4]
   1295e:	3243      	adds	r2, #67	; 0x43
   12960:	9800      	ldr	r0, [sp, #0]
   12962:	9d08      	ldr	r5, [sp, #32]
   12964:	47a8      	blx	r5
   12966:	1c43      	adds	r3, r0, #1
   12968:	d102      	bne.n	12970 <_printf_common+0x98>
   1296a:	2001      	movs	r0, #1
   1296c:	4240      	negs	r0, r0
   1296e:	e020      	b.n	129b2 <_printf_common+0xda>
   12970:	2306      	movs	r3, #6
   12972:	6820      	ldr	r0, [r4, #0]
   12974:	68e1      	ldr	r1, [r4, #12]
   12976:	683a      	ldr	r2, [r7, #0]
   12978:	4003      	ands	r3, r0
   1297a:	2500      	movs	r5, #0
   1297c:	2b04      	cmp	r3, #4
   1297e:	d103      	bne.n	12988 <_printf_common+0xb0>
   12980:	1a8d      	subs	r5, r1, r2
   12982:	43eb      	mvns	r3, r5
   12984:	17db      	asrs	r3, r3, #31
   12986:	401d      	ands	r5, r3
   12988:	68a3      	ldr	r3, [r4, #8]
   1298a:	6922      	ldr	r2, [r4, #16]
   1298c:	4293      	cmp	r3, r2
   1298e:	dd01      	ble.n	12994 <_printf_common+0xbc>
   12990:	1a9b      	subs	r3, r3, r2
   12992:	18ed      	adds	r5, r5, r3
   12994:	2700      	movs	r7, #0
   12996:	42bd      	cmp	r5, r7
   12998:	d00a      	beq.n	129b0 <_printf_common+0xd8>
   1299a:	0022      	movs	r2, r4
   1299c:	2301      	movs	r3, #1
   1299e:	321a      	adds	r2, #26
   129a0:	9901      	ldr	r1, [sp, #4]
   129a2:	9800      	ldr	r0, [sp, #0]
   129a4:	9e08      	ldr	r6, [sp, #32]
   129a6:	47b0      	blx	r6
   129a8:	1c43      	adds	r3, r0, #1
   129aa:	d0de      	beq.n	1296a <_printf_common+0x92>
   129ac:	3701      	adds	r7, #1
   129ae:	e7f2      	b.n	12996 <_printf_common+0xbe>
   129b0:	2000      	movs	r0, #0
   129b2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

000129b4 <_printf_i>:
   129b4:	b5f0      	push	{r4, r5, r6, r7, lr}
   129b6:	b08b      	sub	sp, #44	; 0x2c
   129b8:	9206      	str	r2, [sp, #24]
   129ba:	000a      	movs	r2, r1
   129bc:	3243      	adds	r2, #67	; 0x43
   129be:	9307      	str	r3, [sp, #28]
   129c0:	9005      	str	r0, [sp, #20]
   129c2:	9204      	str	r2, [sp, #16]
   129c4:	7e0a      	ldrb	r2, [r1, #24]
   129c6:	000c      	movs	r4, r1
   129c8:	9b10      	ldr	r3, [sp, #64]	; 0x40
   129ca:	2a6e      	cmp	r2, #110	; 0x6e
   129cc:	d100      	bne.n	129d0 <_printf_i+0x1c>
   129ce:	e0ab      	b.n	12b28 <_printf_i+0x174>
   129d0:	d811      	bhi.n	129f6 <_printf_i+0x42>
   129d2:	2a63      	cmp	r2, #99	; 0x63
   129d4:	d022      	beq.n	12a1c <_printf_i+0x68>
   129d6:	d809      	bhi.n	129ec <_printf_i+0x38>
   129d8:	2a00      	cmp	r2, #0
   129da:	d100      	bne.n	129de <_printf_i+0x2a>
   129dc:	e0b5      	b.n	12b4a <_printf_i+0x196>
   129de:	2a58      	cmp	r2, #88	; 0x58
   129e0:	d000      	beq.n	129e4 <_printf_i+0x30>
   129e2:	e0c5      	b.n	12b70 <_printf_i+0x1bc>
   129e4:	3145      	adds	r1, #69	; 0x45
   129e6:	700a      	strb	r2, [r1, #0]
   129e8:	4a81      	ldr	r2, [pc, #516]	; (12bf0 <_printf_i+0x23c>)
   129ea:	e04f      	b.n	12a8c <_printf_i+0xd8>
   129ec:	2a64      	cmp	r2, #100	; 0x64
   129ee:	d01d      	beq.n	12a2c <_printf_i+0x78>
   129f0:	2a69      	cmp	r2, #105	; 0x69
   129f2:	d01b      	beq.n	12a2c <_printf_i+0x78>
   129f4:	e0bc      	b.n	12b70 <_printf_i+0x1bc>
   129f6:	2a73      	cmp	r2, #115	; 0x73
   129f8:	d100      	bne.n	129fc <_printf_i+0x48>
   129fa:	e0aa      	b.n	12b52 <_printf_i+0x19e>
   129fc:	d809      	bhi.n	12a12 <_printf_i+0x5e>
   129fe:	2a6f      	cmp	r2, #111	; 0x6f
   12a00:	d029      	beq.n	12a56 <_printf_i+0xa2>
   12a02:	2a70      	cmp	r2, #112	; 0x70
   12a04:	d000      	beq.n	12a08 <_printf_i+0x54>
   12a06:	e0b3      	b.n	12b70 <_printf_i+0x1bc>
   12a08:	2220      	movs	r2, #32
   12a0a:	6809      	ldr	r1, [r1, #0]
   12a0c:	430a      	orrs	r2, r1
   12a0e:	6022      	str	r2, [r4, #0]
   12a10:	e037      	b.n	12a82 <_printf_i+0xce>
   12a12:	2a75      	cmp	r2, #117	; 0x75
   12a14:	d01f      	beq.n	12a56 <_printf_i+0xa2>
   12a16:	2a78      	cmp	r2, #120	; 0x78
   12a18:	d033      	beq.n	12a82 <_printf_i+0xce>
   12a1a:	e0a9      	b.n	12b70 <_printf_i+0x1bc>
   12a1c:	000e      	movs	r6, r1
   12a1e:	681a      	ldr	r2, [r3, #0]
   12a20:	3642      	adds	r6, #66	; 0x42
   12a22:	1d11      	adds	r1, r2, #4
   12a24:	6019      	str	r1, [r3, #0]
   12a26:	6813      	ldr	r3, [r2, #0]
   12a28:	7033      	strb	r3, [r6, #0]
   12a2a:	e0a4      	b.n	12b76 <_printf_i+0x1c2>
   12a2c:	6821      	ldr	r1, [r4, #0]
   12a2e:	681a      	ldr	r2, [r3, #0]
   12a30:	0608      	lsls	r0, r1, #24
   12a32:	d406      	bmi.n	12a42 <_printf_i+0x8e>
   12a34:	0649      	lsls	r1, r1, #25
   12a36:	d504      	bpl.n	12a42 <_printf_i+0x8e>
   12a38:	1d11      	adds	r1, r2, #4
   12a3a:	6019      	str	r1, [r3, #0]
   12a3c:	2300      	movs	r3, #0
   12a3e:	5ed5      	ldrsh	r5, [r2, r3]
   12a40:	e002      	b.n	12a48 <_printf_i+0x94>
   12a42:	1d11      	adds	r1, r2, #4
   12a44:	6019      	str	r1, [r3, #0]
   12a46:	6815      	ldr	r5, [r2, #0]
   12a48:	2d00      	cmp	r5, #0
   12a4a:	da3b      	bge.n	12ac4 <_printf_i+0x110>
   12a4c:	232d      	movs	r3, #45	; 0x2d
   12a4e:	9a04      	ldr	r2, [sp, #16]
   12a50:	426d      	negs	r5, r5
   12a52:	7013      	strb	r3, [r2, #0]
   12a54:	e036      	b.n	12ac4 <_printf_i+0x110>
   12a56:	6821      	ldr	r1, [r4, #0]
   12a58:	681a      	ldr	r2, [r3, #0]
   12a5a:	0608      	lsls	r0, r1, #24
   12a5c:	d406      	bmi.n	12a6c <_printf_i+0xb8>
   12a5e:	0649      	lsls	r1, r1, #25
   12a60:	d504      	bpl.n	12a6c <_printf_i+0xb8>
   12a62:	6815      	ldr	r5, [r2, #0]
   12a64:	1d11      	adds	r1, r2, #4
   12a66:	6019      	str	r1, [r3, #0]
   12a68:	b2ad      	uxth	r5, r5
   12a6a:	e002      	b.n	12a72 <_printf_i+0xbe>
   12a6c:	1d11      	adds	r1, r2, #4
   12a6e:	6019      	str	r1, [r3, #0]
   12a70:	6815      	ldr	r5, [r2, #0]
   12a72:	4b5f      	ldr	r3, [pc, #380]	; (12bf0 <_printf_i+0x23c>)
   12a74:	7e22      	ldrb	r2, [r4, #24]
   12a76:	9303      	str	r3, [sp, #12]
   12a78:	2708      	movs	r7, #8
   12a7a:	2a6f      	cmp	r2, #111	; 0x6f
   12a7c:	d01d      	beq.n	12aba <_printf_i+0x106>
   12a7e:	270a      	movs	r7, #10
   12a80:	e01b      	b.n	12aba <_printf_i+0x106>
   12a82:	0022      	movs	r2, r4
   12a84:	2178      	movs	r1, #120	; 0x78
   12a86:	3245      	adds	r2, #69	; 0x45
   12a88:	7011      	strb	r1, [r2, #0]
   12a8a:	4a5a      	ldr	r2, [pc, #360]	; (12bf4 <_printf_i+0x240>)
   12a8c:	6819      	ldr	r1, [r3, #0]
   12a8e:	9203      	str	r2, [sp, #12]
   12a90:	1d08      	adds	r0, r1, #4
   12a92:	6822      	ldr	r2, [r4, #0]
   12a94:	6018      	str	r0, [r3, #0]
   12a96:	680d      	ldr	r5, [r1, #0]
   12a98:	0610      	lsls	r0, r2, #24
   12a9a:	d402      	bmi.n	12aa2 <_printf_i+0xee>
   12a9c:	0650      	lsls	r0, r2, #25
   12a9e:	d500      	bpl.n	12aa2 <_printf_i+0xee>
   12aa0:	b2ad      	uxth	r5, r5
   12aa2:	07d3      	lsls	r3, r2, #31
   12aa4:	d502      	bpl.n	12aac <_printf_i+0xf8>
   12aa6:	2320      	movs	r3, #32
   12aa8:	431a      	orrs	r2, r3
   12aaa:	6022      	str	r2, [r4, #0]
   12aac:	2710      	movs	r7, #16
   12aae:	2d00      	cmp	r5, #0
   12ab0:	d103      	bne.n	12aba <_printf_i+0x106>
   12ab2:	2320      	movs	r3, #32
   12ab4:	6822      	ldr	r2, [r4, #0]
   12ab6:	439a      	bics	r2, r3
   12ab8:	6022      	str	r2, [r4, #0]
   12aba:	0023      	movs	r3, r4
   12abc:	2200      	movs	r2, #0
   12abe:	3343      	adds	r3, #67	; 0x43
   12ac0:	701a      	strb	r2, [r3, #0]
   12ac2:	e002      	b.n	12aca <_printf_i+0x116>
   12ac4:	270a      	movs	r7, #10
   12ac6:	4b4a      	ldr	r3, [pc, #296]	; (12bf0 <_printf_i+0x23c>)
   12ac8:	9303      	str	r3, [sp, #12]
   12aca:	6863      	ldr	r3, [r4, #4]
   12acc:	60a3      	str	r3, [r4, #8]
   12ace:	2b00      	cmp	r3, #0
   12ad0:	db09      	blt.n	12ae6 <_printf_i+0x132>
   12ad2:	2204      	movs	r2, #4
   12ad4:	6821      	ldr	r1, [r4, #0]
   12ad6:	4391      	bics	r1, r2
   12ad8:	6021      	str	r1, [r4, #0]
   12ada:	2d00      	cmp	r5, #0
   12adc:	d105      	bne.n	12aea <_printf_i+0x136>
   12ade:	9e04      	ldr	r6, [sp, #16]
   12ae0:	2b00      	cmp	r3, #0
   12ae2:	d011      	beq.n	12b08 <_printf_i+0x154>
   12ae4:	e07b      	b.n	12bde <_printf_i+0x22a>
   12ae6:	2d00      	cmp	r5, #0
   12ae8:	d079      	beq.n	12bde <_printf_i+0x22a>
   12aea:	9e04      	ldr	r6, [sp, #16]
   12aec:	0028      	movs	r0, r5
   12aee:	0039      	movs	r1, r7
   12af0:	f7fc ff22 	bl	f938 <__aeabi_uidivmod>
   12af4:	9b03      	ldr	r3, [sp, #12]
   12af6:	3e01      	subs	r6, #1
   12af8:	5c5b      	ldrb	r3, [r3, r1]
   12afa:	0028      	movs	r0, r5
   12afc:	7033      	strb	r3, [r6, #0]
   12afe:	0039      	movs	r1, r7
   12b00:	f7fc fe94 	bl	f82c <__aeabi_uidiv>
   12b04:	1e05      	subs	r5, r0, #0
   12b06:	d1f1      	bne.n	12aec <_printf_i+0x138>
   12b08:	2f08      	cmp	r7, #8
   12b0a:	d109      	bne.n	12b20 <_printf_i+0x16c>
   12b0c:	6823      	ldr	r3, [r4, #0]
   12b0e:	07db      	lsls	r3, r3, #31
   12b10:	d506      	bpl.n	12b20 <_printf_i+0x16c>
   12b12:	6863      	ldr	r3, [r4, #4]
   12b14:	6922      	ldr	r2, [r4, #16]
   12b16:	4293      	cmp	r3, r2
   12b18:	dc02      	bgt.n	12b20 <_printf_i+0x16c>
   12b1a:	2330      	movs	r3, #48	; 0x30
   12b1c:	3e01      	subs	r6, #1
   12b1e:	7033      	strb	r3, [r6, #0]
   12b20:	9b04      	ldr	r3, [sp, #16]
   12b22:	1b9b      	subs	r3, r3, r6
   12b24:	6123      	str	r3, [r4, #16]
   12b26:	e02b      	b.n	12b80 <_printf_i+0x1cc>
   12b28:	6809      	ldr	r1, [r1, #0]
   12b2a:	681a      	ldr	r2, [r3, #0]
   12b2c:	0608      	lsls	r0, r1, #24
   12b2e:	d407      	bmi.n	12b40 <_printf_i+0x18c>
   12b30:	0649      	lsls	r1, r1, #25
   12b32:	d505      	bpl.n	12b40 <_printf_i+0x18c>
   12b34:	1d11      	adds	r1, r2, #4
   12b36:	6019      	str	r1, [r3, #0]
   12b38:	6813      	ldr	r3, [r2, #0]
   12b3a:	8aa2      	ldrh	r2, [r4, #20]
   12b3c:	801a      	strh	r2, [r3, #0]
   12b3e:	e004      	b.n	12b4a <_printf_i+0x196>
   12b40:	1d11      	adds	r1, r2, #4
   12b42:	6019      	str	r1, [r3, #0]
   12b44:	6813      	ldr	r3, [r2, #0]
   12b46:	6962      	ldr	r2, [r4, #20]
   12b48:	601a      	str	r2, [r3, #0]
   12b4a:	2300      	movs	r3, #0
   12b4c:	9e04      	ldr	r6, [sp, #16]
   12b4e:	6123      	str	r3, [r4, #16]
   12b50:	e016      	b.n	12b80 <_printf_i+0x1cc>
   12b52:	681a      	ldr	r2, [r3, #0]
   12b54:	1d11      	adds	r1, r2, #4
   12b56:	6019      	str	r1, [r3, #0]
   12b58:	6816      	ldr	r6, [r2, #0]
   12b5a:	2100      	movs	r1, #0
   12b5c:	6862      	ldr	r2, [r4, #4]
   12b5e:	0030      	movs	r0, r6
   12b60:	f000 f8b8 	bl	12cd4 <memchr>
   12b64:	2800      	cmp	r0, #0
   12b66:	d001      	beq.n	12b6c <_printf_i+0x1b8>
   12b68:	1b80      	subs	r0, r0, r6
   12b6a:	6060      	str	r0, [r4, #4]
   12b6c:	6863      	ldr	r3, [r4, #4]
   12b6e:	e003      	b.n	12b78 <_printf_i+0x1c4>
   12b70:	0026      	movs	r6, r4
   12b72:	3642      	adds	r6, #66	; 0x42
   12b74:	7032      	strb	r2, [r6, #0]
   12b76:	2301      	movs	r3, #1
   12b78:	6123      	str	r3, [r4, #16]
   12b7a:	2300      	movs	r3, #0
   12b7c:	9a04      	ldr	r2, [sp, #16]
   12b7e:	7013      	strb	r3, [r2, #0]
   12b80:	9b07      	ldr	r3, [sp, #28]
   12b82:	aa09      	add	r2, sp, #36	; 0x24
   12b84:	9300      	str	r3, [sp, #0]
   12b86:	0021      	movs	r1, r4
   12b88:	9b06      	ldr	r3, [sp, #24]
   12b8a:	9805      	ldr	r0, [sp, #20]
   12b8c:	f7ff fea4 	bl	128d8 <_printf_common>
   12b90:	1c43      	adds	r3, r0, #1
   12b92:	d102      	bne.n	12b9a <_printf_i+0x1e6>
   12b94:	2001      	movs	r0, #1
   12b96:	4240      	negs	r0, r0
   12b98:	e027      	b.n	12bea <_printf_i+0x236>
   12b9a:	6923      	ldr	r3, [r4, #16]
   12b9c:	0032      	movs	r2, r6
   12b9e:	9906      	ldr	r1, [sp, #24]
   12ba0:	9805      	ldr	r0, [sp, #20]
   12ba2:	9d07      	ldr	r5, [sp, #28]
   12ba4:	47a8      	blx	r5
   12ba6:	1c43      	adds	r3, r0, #1
   12ba8:	d0f4      	beq.n	12b94 <_printf_i+0x1e0>
   12baa:	6823      	ldr	r3, [r4, #0]
   12bac:	2500      	movs	r5, #0
   12bae:	079b      	lsls	r3, r3, #30
   12bb0:	d40f      	bmi.n	12bd2 <_printf_i+0x21e>
   12bb2:	9b09      	ldr	r3, [sp, #36]	; 0x24
   12bb4:	68e0      	ldr	r0, [r4, #12]
   12bb6:	4298      	cmp	r0, r3
   12bb8:	da17      	bge.n	12bea <_printf_i+0x236>
   12bba:	0018      	movs	r0, r3
   12bbc:	e015      	b.n	12bea <_printf_i+0x236>
   12bbe:	0022      	movs	r2, r4
   12bc0:	2301      	movs	r3, #1
   12bc2:	3219      	adds	r2, #25
   12bc4:	9906      	ldr	r1, [sp, #24]
   12bc6:	9805      	ldr	r0, [sp, #20]
   12bc8:	9e07      	ldr	r6, [sp, #28]
   12bca:	47b0      	blx	r6
   12bcc:	1c43      	adds	r3, r0, #1
   12bce:	d0e1      	beq.n	12b94 <_printf_i+0x1e0>
   12bd0:	3501      	adds	r5, #1
   12bd2:	68e3      	ldr	r3, [r4, #12]
   12bd4:	9a09      	ldr	r2, [sp, #36]	; 0x24
   12bd6:	1a9b      	subs	r3, r3, r2
   12bd8:	429d      	cmp	r5, r3
   12bda:	dbf0      	blt.n	12bbe <_printf_i+0x20a>
   12bdc:	e7e9      	b.n	12bb2 <_printf_i+0x1fe>
   12bde:	0026      	movs	r6, r4
   12be0:	9b03      	ldr	r3, [sp, #12]
   12be2:	3642      	adds	r6, #66	; 0x42
   12be4:	781b      	ldrb	r3, [r3, #0]
   12be6:	7033      	strb	r3, [r6, #0]
   12be8:	e78e      	b.n	12b08 <_printf_i+0x154>
   12bea:	b00b      	add	sp, #44	; 0x2c
   12bec:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12bee:	46c0      	nop			; (mov r8, r8)
   12bf0:	0001c171 	.word	0x0001c171
   12bf4:	0001c182 	.word	0x0001c182

00012bf8 <_putc_r>:
   12bf8:	b570      	push	{r4, r5, r6, lr}
   12bfa:	0006      	movs	r6, r0
   12bfc:	000d      	movs	r5, r1
   12bfe:	0014      	movs	r4, r2
   12c00:	2800      	cmp	r0, #0
   12c02:	d004      	beq.n	12c0e <_putc_r+0x16>
   12c04:	6983      	ldr	r3, [r0, #24]
   12c06:	2b00      	cmp	r3, #0
   12c08:	d101      	bne.n	12c0e <_putc_r+0x16>
   12c0a:	f7ff fab5 	bl	12178 <__sinit>
   12c0e:	4b12      	ldr	r3, [pc, #72]	; (12c58 <_putc_r+0x60>)
   12c10:	429c      	cmp	r4, r3
   12c12:	d101      	bne.n	12c18 <_putc_r+0x20>
   12c14:	6874      	ldr	r4, [r6, #4]
   12c16:	e008      	b.n	12c2a <_putc_r+0x32>
   12c18:	4b10      	ldr	r3, [pc, #64]	; (12c5c <_putc_r+0x64>)
   12c1a:	429c      	cmp	r4, r3
   12c1c:	d101      	bne.n	12c22 <_putc_r+0x2a>
   12c1e:	68b4      	ldr	r4, [r6, #8]
   12c20:	e003      	b.n	12c2a <_putc_r+0x32>
   12c22:	4b0f      	ldr	r3, [pc, #60]	; (12c60 <_putc_r+0x68>)
   12c24:	429c      	cmp	r4, r3
   12c26:	d100      	bne.n	12c2a <_putc_r+0x32>
   12c28:	68f4      	ldr	r4, [r6, #12]
   12c2a:	68a3      	ldr	r3, [r4, #8]
   12c2c:	3b01      	subs	r3, #1
   12c2e:	60a3      	str	r3, [r4, #8]
   12c30:	2b00      	cmp	r3, #0
   12c32:	da05      	bge.n	12c40 <_putc_r+0x48>
   12c34:	69a2      	ldr	r2, [r4, #24]
   12c36:	4293      	cmp	r3, r2
   12c38:	db08      	blt.n	12c4c <_putc_r+0x54>
   12c3a:	b2eb      	uxtb	r3, r5
   12c3c:	2b0a      	cmp	r3, #10
   12c3e:	d005      	beq.n	12c4c <_putc_r+0x54>
   12c40:	6823      	ldr	r3, [r4, #0]
   12c42:	b2e8      	uxtb	r0, r5
   12c44:	1c5a      	adds	r2, r3, #1
   12c46:	6022      	str	r2, [r4, #0]
   12c48:	701d      	strb	r5, [r3, #0]
   12c4a:	e004      	b.n	12c56 <_putc_r+0x5e>
   12c4c:	0022      	movs	r2, r4
   12c4e:	0029      	movs	r1, r5
   12c50:	0030      	movs	r0, r6
   12c52:	f7ff f8a9 	bl	11da8 <__swbuf_r>
   12c56:	bd70      	pop	{r4, r5, r6, pc}
   12c58:	0001c100 	.word	0x0001c100
   12c5c:	0001c120 	.word	0x0001c120
   12c60:	0001c140 	.word	0x0001c140

00012c64 <_read_r>:
   12c64:	b570      	push	{r4, r5, r6, lr}
   12c66:	0005      	movs	r5, r0
   12c68:	0008      	movs	r0, r1
   12c6a:	0011      	movs	r1, r2
   12c6c:	2200      	movs	r2, #0
   12c6e:	4c06      	ldr	r4, [pc, #24]	; (12c88 <_read_r+0x24>)
   12c70:	6022      	str	r2, [r4, #0]
   12c72:	001a      	movs	r2, r3
   12c74:	f7fb f96e 	bl	df54 <_read>
   12c78:	1c43      	adds	r3, r0, #1
   12c7a:	d103      	bne.n	12c84 <_read_r+0x20>
   12c7c:	6823      	ldr	r3, [r4, #0]
   12c7e:	2b00      	cmp	r3, #0
   12c80:	d000      	beq.n	12c84 <_read_r+0x20>
   12c82:	602b      	str	r3, [r5, #0]
   12c84:	bd70      	pop	{r4, r5, r6, pc}
   12c86:	46c0      	nop			; (mov r8, r8)
   12c88:	200028d0 	.word	0x200028d0

00012c8c <_fstat_r>:
   12c8c:	2300      	movs	r3, #0
   12c8e:	b570      	push	{r4, r5, r6, lr}
   12c90:	4c06      	ldr	r4, [pc, #24]	; (12cac <_fstat_r+0x20>)
   12c92:	0005      	movs	r5, r0
   12c94:	0008      	movs	r0, r1
   12c96:	0011      	movs	r1, r2
   12c98:	6023      	str	r3, [r4, #0]
   12c9a:	f7fb f9b9 	bl	e010 <_fstat>
   12c9e:	1c43      	adds	r3, r0, #1
   12ca0:	d103      	bne.n	12caa <_fstat_r+0x1e>
   12ca2:	6823      	ldr	r3, [r4, #0]
   12ca4:	2b00      	cmp	r3, #0
   12ca6:	d000      	beq.n	12caa <_fstat_r+0x1e>
   12ca8:	602b      	str	r3, [r5, #0]
   12caa:	bd70      	pop	{r4, r5, r6, pc}
   12cac:	200028d0 	.word	0x200028d0

00012cb0 <_isatty_r>:
   12cb0:	2300      	movs	r3, #0
   12cb2:	b570      	push	{r4, r5, r6, lr}
   12cb4:	4c06      	ldr	r4, [pc, #24]	; (12cd0 <_isatty_r+0x20>)
   12cb6:	0005      	movs	r5, r0
   12cb8:	0008      	movs	r0, r1
   12cba:	6023      	str	r3, [r4, #0]
   12cbc:	f7fb f9ae 	bl	e01c <_isatty>
   12cc0:	1c43      	adds	r3, r0, #1
   12cc2:	d103      	bne.n	12ccc <_isatty_r+0x1c>
   12cc4:	6823      	ldr	r3, [r4, #0]
   12cc6:	2b00      	cmp	r3, #0
   12cc8:	d000      	beq.n	12ccc <_isatty_r+0x1c>
   12cca:	602b      	str	r3, [r5, #0]
   12ccc:	bd70      	pop	{r4, r5, r6, pc}
   12cce:	46c0      	nop			; (mov r8, r8)
   12cd0:	200028d0 	.word	0x200028d0

00012cd4 <memchr>:
   12cd4:	b2c9      	uxtb	r1, r1
   12cd6:	1882      	adds	r2, r0, r2
   12cd8:	4290      	cmp	r0, r2
   12cda:	d004      	beq.n	12ce6 <memchr+0x12>
   12cdc:	7803      	ldrb	r3, [r0, #0]
   12cde:	428b      	cmp	r3, r1
   12ce0:	d002      	beq.n	12ce8 <memchr+0x14>
   12ce2:	3001      	adds	r0, #1
   12ce4:	e7f8      	b.n	12cd8 <memchr+0x4>
   12ce6:	2000      	movs	r0, #0
   12ce8:	4770      	bx	lr

00012cea <memmove>:
   12cea:	b510      	push	{r4, lr}
   12cec:	4288      	cmp	r0, r1
   12cee:	d902      	bls.n	12cf6 <memmove+0xc>
   12cf0:	188b      	adds	r3, r1, r2
   12cf2:	4298      	cmp	r0, r3
   12cf4:	d301      	bcc.n	12cfa <memmove+0x10>
   12cf6:	2300      	movs	r3, #0
   12cf8:	e005      	b.n	12d06 <memmove+0x1c>
   12cfa:	1a9b      	subs	r3, r3, r2
   12cfc:	3a01      	subs	r2, #1
   12cfe:	d308      	bcc.n	12d12 <memmove+0x28>
   12d00:	5c99      	ldrb	r1, [r3, r2]
   12d02:	5481      	strb	r1, [r0, r2]
   12d04:	e7fa      	b.n	12cfc <memmove+0x12>
   12d06:	4293      	cmp	r3, r2
   12d08:	d003      	beq.n	12d12 <memmove+0x28>
   12d0a:	5ccc      	ldrb	r4, [r1, r3]
   12d0c:	54c4      	strb	r4, [r0, r3]
   12d0e:	3301      	adds	r3, #1
   12d10:	e7f9      	b.n	12d06 <memmove+0x1c>
   12d12:	bd10      	pop	{r4, pc}

00012d14 <_realloc_r>:
   12d14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12d16:	0006      	movs	r6, r0
   12d18:	000c      	movs	r4, r1
   12d1a:	0015      	movs	r5, r2
   12d1c:	2900      	cmp	r1, #0
   12d1e:	d104      	bne.n	12d2a <_realloc_r+0x16>
   12d20:	0011      	movs	r1, r2
   12d22:	f7fe fddd 	bl	118e0 <_malloc_r>
   12d26:	0004      	movs	r4, r0
   12d28:	e018      	b.n	12d5c <_realloc_r+0x48>
   12d2a:	2a00      	cmp	r2, #0
   12d2c:	d103      	bne.n	12d36 <_realloc_r+0x22>
   12d2e:	f7fe fd91 	bl	11854 <_free_r>
   12d32:	002c      	movs	r4, r5
   12d34:	e012      	b.n	12d5c <_realloc_r+0x48>
   12d36:	f000 f813 	bl	12d60 <_malloc_usable_size_r>
   12d3a:	4285      	cmp	r5, r0
   12d3c:	d90e      	bls.n	12d5c <_realloc_r+0x48>
   12d3e:	0029      	movs	r1, r5
   12d40:	0030      	movs	r0, r6
   12d42:	f7fe fdcd 	bl	118e0 <_malloc_r>
   12d46:	1e07      	subs	r7, r0, #0
   12d48:	d007      	beq.n	12d5a <_realloc_r+0x46>
   12d4a:	0021      	movs	r1, r4
   12d4c:	002a      	movs	r2, r5
   12d4e:	f7fe fd70 	bl	11832 <memcpy>
   12d52:	0021      	movs	r1, r4
   12d54:	0030      	movs	r0, r6
   12d56:	f7fe fd7d 	bl	11854 <_free_r>
   12d5a:	003c      	movs	r4, r7
   12d5c:	0020      	movs	r0, r4
   12d5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00012d60 <_malloc_usable_size_r>:
   12d60:	1f0b      	subs	r3, r1, #4
   12d62:	681a      	ldr	r2, [r3, #0]
   12d64:	1f10      	subs	r0, r2, #4
   12d66:	2a00      	cmp	r2, #0
   12d68:	da04      	bge.n	12d74 <_malloc_usable_size_r+0x14>
   12d6a:	1889      	adds	r1, r1, r2
   12d6c:	3904      	subs	r1, #4
   12d6e:	680b      	ldr	r3, [r1, #0]
   12d70:	18d0      	adds	r0, r2, r3
   12d72:	3804      	subs	r0, #4
   12d74:	4770      	bx	lr
   12d76:	0000      	movs	r0, r0
   12d78:	0000022a 	.word	0x0000022a
   12d7c:	0000022a 	.word	0x0000022a
   12d80:	00000206 	.word	0x00000206
   12d84:	0000022a 	.word	0x0000022a
   12d88:	00000206 	.word	0x00000206
   12d8c:	000001f2 	.word	0x000001f2
   12d90:	000001f2 	.word	0x000001f2
   12d94:	0000022a 	.word	0x0000022a
   12d98:	0000022a 	.word	0x0000022a
   12d9c:	0000022a 	.word	0x0000022a
   12da0:	0000022a 	.word	0x0000022a
   12da4:	0000022a 	.word	0x0000022a
   12da8:	0000022a 	.word	0x0000022a
   12dac:	0000022a 	.word	0x0000022a
   12db0:	0000022a 	.word	0x0000022a
   12db4:	0000022a 	.word	0x0000022a
   12db8:	0000022a 	.word	0x0000022a
   12dbc:	0000022a 	.word	0x0000022a
   12dc0:	0000022a 	.word	0x0000022a
   12dc4:	0000022a 	.word	0x0000022a
   12dc8:	0000022a 	.word	0x0000022a
   12dcc:	0000022a 	.word	0x0000022a
   12dd0:	0000022a 	.word	0x0000022a
   12dd4:	0000022a 	.word	0x0000022a
   12dd8:	0000022a 	.word	0x0000022a
   12ddc:	0000022a 	.word	0x0000022a
   12de0:	00000206 	.word	0x00000206
   12de4:	0000022a 	.word	0x0000022a
   12de8:	00000206 	.word	0x00000206
   12dec:	0000022a 	.word	0x0000022a
   12df0:	0000022a 	.word	0x0000022a
   12df4:	0000022a 	.word	0x0000022a
   12df8:	0000022a 	.word	0x0000022a
   12dfc:	0000022a 	.word	0x0000022a
   12e00:	0000022a 	.word	0x0000022a
   12e04:	0000022a 	.word	0x0000022a
   12e08:	0000022a 	.word	0x0000022a
   12e0c:	0000022a 	.word	0x0000022a
   12e10:	0000022a 	.word	0x0000022a
   12e14:	0000022a 	.word	0x0000022a
   12e18:	0000022a 	.word	0x0000022a
   12e1c:	0000022a 	.word	0x0000022a
   12e20:	0000022a 	.word	0x0000022a
   12e24:	0000022a 	.word	0x0000022a
   12e28:	0000022a 	.word	0x0000022a
   12e2c:	0000022a 	.word	0x0000022a
   12e30:	0000022a 	.word	0x0000022a
   12e34:	0000022a 	.word	0x0000022a
   12e38:	0000022a 	.word	0x0000022a
   12e3c:	0000022a 	.word	0x0000022a
   12e40:	0000022a 	.word	0x0000022a
   12e44:	0000022a 	.word	0x0000022a
   12e48:	0000022a 	.word	0x0000022a
   12e4c:	0000022a 	.word	0x0000022a
   12e50:	0000022a 	.word	0x0000022a
   12e54:	0000022a 	.word	0x0000022a
   12e58:	0000022a 	.word	0x0000022a
   12e5c:	0000022a 	.word	0x0000022a
   12e60:	0000022a 	.word	0x0000022a
   12e64:	0000022a 	.word	0x0000022a
   12e68:	0000022a 	.word	0x0000022a
   12e6c:	0000022a 	.word	0x0000022a
   12e70:	0000022a 	.word	0x0000022a
   12e74:	0000022a 	.word	0x0000022a
   12e78:	00000206 	.word	0x00000206
   12e7c:	00000206 	.word	0x00000206
   12e80:	0000020e 	.word	0x0000020e
   12e84:	0000020e 	.word	0x0000020e
   12e88:	0000020e 	.word	0x0000020e
   12e8c:	0000020e 	.word	0x0000020e
   12e90:	20746553 	.word	0x20746553
   12e94:	41207361 	.word	0x41207361
   12e98:	6f6d2050 	.word	0x6f6d2050
   12e9c:	000d6564 	.word	0x000d6564
   12ea0:	64616552 	.word	0x64616552
   12ea4:	6e6f6320 	.word	0x6e6f6320
   12ea8:	20676966 	.word	0x20676966
   12eac:	65676170 	.word	0x65676170
   12eb0:	0000000d 	.word	0x0000000d
   12eb4:	64697373 	.word	0x64697373
   12eb8:	2c73253d 	.word	0x2c73253d
   12ebc:	69737320 	.word	0x69737320
   12ec0:	6e656c64 	.word	0x6e656c64
   12ec4:	0d64253d 	.word	0x0d64253d
   12ec8:	0000000a 	.word	0x0000000a
   12ecc:	3d79656b 	.word	0x3d79656b
   12ed0:	202c7325 	.word	0x202c7325
   12ed4:	6c79656b 	.word	0x6c79656b
   12ed8:	253d6e65 	.word	0x253d6e65
   12edc:	000a0d64 	.word	0x000a0d64
   12ee0:	74754167 	.word	0x74754167
   12ee4:	70795468 	.word	0x70795468
   12ee8:	64253d65 	.word	0x64253d65
   12eec:	00000a0d 	.word	0x00000a0d
   12ef0:	69755567 	.word	0x69755567
   12ef4:	73253d64 	.word	0x73253d64
   12ef8:	656c202c 	.word	0x656c202c
   12efc:	64253d6e 	.word	0x64253d6e
   12f00:	00000a0d 	.word	0x00000a0d
   12f04:	5d73255b 	.word	0x5d73255b
   12f08:	206f4e20 	.word	0x206f4e20
   12f0c:	746f7571 	.word	0x746f7571
   12f10:	2e2e2e61 	.word	0x2e2e2e61
   12f14:	0000000a 	.word	0x0000000a
   12f18:	5d73255b 	.word	0x5d73255b
   12f1c:	6e614320 	.word	0x6e614320
   12f20:	20746f6e 	.word	0x20746f6e
   12f24:	646e6966 	.word	0x646e6966
   12f28:	65687420 	.word	0x65687420
   12f2c:	6c657220 	.word	0x6c657220
   12f30:	64657461 	.word	0x64657461
   12f34:	2e626320 	.word	0x2e626320
   12f38:	00000a2e 	.word	0x00000a2e
   12f3c:	0000074a 	.word	0x0000074a
   12f40:	00000816 	.word	0x00000816
   12f44:	00000816 	.word	0x00000816
   12f48:	00000816 	.word	0x00000816
   12f4c:	00000752 	.word	0x00000752
   12f50:	00000816 	.word	0x00000816
   12f54:	00000816 	.word	0x00000816
   12f58:	00000816 	.word	0x00000816
   12f5c:	00000816 	.word	0x00000816
   12f60:	00000816 	.word	0x00000816
   12f64:	00000816 	.word	0x00000816
   12f68:	00000816 	.word	0x00000816
   12f6c:	0000075a 	.word	0x0000075a
   12f70:	00000816 	.word	0x00000816
   12f74:	00000816 	.word	0x00000816
   12f78:	00000816 	.word	0x00000816
   12f7c:	00000762 	.word	0x00000762
   12f80:	00000816 	.word	0x00000816
   12f84:	0000076a 	.word	0x0000076a
   12f88:	00000772 	.word	0x00000772
   12f8c:	00001154 	.word	0x00001154
   12f90:	0000116c 	.word	0x0000116c
   12f94:	0000113c 	.word	0x0000113c
   12f98:	00001184 	.word	0x00001184
   12f9c:	0000118c 	.word	0x0000118c
   12fa0:	00001196 	.word	0x00001196
   12fa4:	0000119c 	.word	0x0000119c
   12fa8:	000011b8 	.word	0x000011b8
   12fac:	000011c0 	.word	0x000011c0
   12fb0:	000011b0 	.word	0x000011b0
   12fb4:	000011c8 	.word	0x000011c8
   12fb8:	000011d0 	.word	0x000011d0
   12fbc:	000011da 	.word	0x000011da
   12fc0:	000011e2 	.word	0x000011e2

00012fc4 <firstByteMark>:
   12fc4:	e0c00000 00fcf8f0                       ........

00012fcc <escapable>:
   12fcc:	00000001 00000001 00000001 00000001     ................
   12fdc:	00000001 00000001 00000001 00000001     ................
   12fec:	00000001 00000001 00000001 00000001     ................
   12ffc:	00000001 00000001 00000001 00000001     ................
   1300c:	00000001 00000001 00000001 00000001     ................
   1301c:	00000001 00000001 00000001 00000001     ................
   1302c:	00000001 00000001 00000001 00000001     ................
   1303c:	00000001 00000001 00000001 00000001     ................
	...
   13054:	00000001 00000000 00000000 00000000     ................
	...
   1313c:	00000001 00000000 00000000 00000000     ................
	...
   133cc:	6c6c756e 00000000 736c6166 00000065     null....false...
   133dc:	65757274 00000000 00000030 00006425     true....0...%d..
   133ec:	66302e25 00000000 00006525 00006625     %.0f....%e..%f..
   133fc:	00002222 0c085c22 00090d0a 34302575     "".."\......u%04
   1340c:	00000078 00005d5b 636e6977 30303531     x...[]..winc1500
   1341c:	2f746f49 252f7325 73252f73 00000000     Iot/%s/%s/%s....
   1342c:	636e6977 30303531 2f746f49 252f7325     winc1500Iot/%s/%
   1343c:	00000073 73627553 62697263 61632065     s...Subscribe ca
   1344c:	61626c6c 00006b63 732a2e25 2a2e2509     llback..%.*s.%.*
   1345c:	00000073 00000d0a 5454514d 73694420     s.......MQTT Dis
   1346c:	6e6e6f63 00746365 6f747541 63655220     connect.Auto Rec
   1347c:	656e6e6f 69207463 6e652073 656c6261     onnect is enable
   1348c:	52202c64 6e6f6365 7463656e 20676e69     d, Reconnecting 
   1349c:	65747461 2074706d 6c6c6977 61747320     attempt will sta
   134ac:	6e207472 0000776f 6f747541 63655220     rt now..Auto Rec
   134bc:	656e6e6f 6e207463 6520746f 6c62616e     onnect not enabl
   134cc:	202e6465 72617453 676e6974 6e616d20     ed. Starting man
   134dc:	206c6175 6f636572 63656e6e 2e2e2e74     ual reconnect...
   134ec:	00000000 756e614d 52206c61 6e6f6365     ....Manual Recon
   134fc:	7463656e 63755320 73736563 006c7566     nect Successful.
   1350c:	756e614d 52206c61 6e6f6365 7463656e     Manual Reconnect
   1351c:	69614620 2064656c 6425202d 00000000      Failed - %d....
   1352c:	6e6e6f43 69746365 2e2e676e 0000002e     Connecting......
   1353c:	6f727245 64252872 6f632029 63656e6e     Error(%d) connec
   1354c:	676e6974 206f7420 253a7325 00000064     ting to %s:%d...
   1355c:	62616e55 7420656c 6573206f 75412074     Unable to set Au
   1356c:	52206f74 6e6f6365 7463656e 206f7420     to Reconnect to 
   1357c:	65757274 25202d20 00000064 5f737761     true - %d...aws_
   1358c:	5f746f69 7474716d 6275705f 6873696c     iot_mqtt_publish
   1359c:	65202928 726f7272 6372202c 25203d20     () error, rc = %
   135ac:	00000a64 73627553 62697263 2e676e69     d...Subscribing.
   135bc:	00002e2e 6f727245 75732072 72637362     ....Error subscr
   135cc:	6e696269 00000d67 73627553 70697263     ibing...Subscrip
   135dc:	6e6f6974 63757320 73736563 0000000d     tion success....
   135ec:	64616552 20676e69 32454d42 68203038     Reading BME280 h
   135fc:	66207361 656c6961 00000064 64616552     as failed...Read
   1360c:	20676e69 4c4d4556 78783036 73616820     ing VEML60xx has
   1361c:	69616620 0064656c 32474244 6574203a      failed.DBG2: te
   1362c:	7265706d 72757461 203d2065 202c6425     mperature = %d, 
   1363c:	696d7568 79746964 25203d20 75202c64     humidity = %d, u
   1364c:	203d2076 2c756c25 65727020 72757373     v = %lu, pressur
   1365c:	203d2065 0a0d6425 00000000 49464957     e = %d......WIFI
   1366c:	444f4e5f 49445f45 564f4353 72205245     _NODE_DISCOVER r
   1367c:	69656365 000d6576 656d7441 69575f6c     eceive..Atmel_Wi
   1368c:	445f6946 6f637369 79726576 00000000     Fi_Discovery....
   1369c:	49464957 444f4e5f 49445f45 564f4353     WIFI_NODE_DISCOV
   136ac:	44205245 20435349 41524150 6572204d     ER DISC PARAM re
   136bc:	76696563 00000d65 49464957 444f4e5f     ceive...WIFI_NOD
   136cc:	49445f45 564f4353 44205245 20435349     E_DISCOVER DISC 
   136dc:	41524150 6f6c204d 000d3267 464e4f43     PARAM log2..CONF
   136ec:	003d4749 49464957 444f4e5f 49445f45     IG=.WIFI_NODE_DI
   136fc:	564f4353 20595245 564f5250 464e4f43     SCOVERY PROVCONF
   1370c:	52415020 72204d41 69656365 000d6576      PARAM receive..
   1371c:	66654467 746c7561 44495353 0d73253d     gDefaultSSID=%s.
   1372c:	0000000a 66654467 746c7561 3d79654b     ....gDefaultKey=
   1373c:	0a0d7325 00000000 68747561 65707974     %s......authtype
   1374c:	0d64253d 0000000a 69755567 73253d64     =%d.....gUuid=%s
   1375c:	00000a0d 69666977 6f72705f 69736976     ....wifi_provisi
   1376c:	725f6e6f 0d707365 00000000 0d6b6f2b     on_resp.....+ok.
   1377c:	000a0d0a 444e4f43 00454e4f 766f7270     ....CONDONE.prov
   1378c:	6174735f 3d206574 4f525020 4f445f56     _state = PROV_DO
   1379c:	000d454e 6f727245 68772072 64206e65     NE..Error when d
   137ac:	646f6365 736a2065 203a6e6f 5d73255b     ecode json: [%s]
   137bc:	0000000a 6d6d6f63 00646e61 20474244     ....command.DBG 
   137cc:	6d6d6f63 20646e61 7325203d 0000000a     command = %s....
   137dc:	61647075 00006574 6f666e69 00000000     update..info....
   137ec:	61746164 65707954 00000000 756c6176     dataType....valu
   137fc:	00000065 20474244 706d6574 25203d20     e...DBG temp = %
   1380c:	000a0d64 4163616d 00726464 20646441     d...macAddr.Add 
   1381c:	65646f4e 73255b20 00000a5d 78323025     Node [%s]...%02x
   1382c:	78323025 78323025 78323025 78323025     %02x%02x%02x%02x
   1383c:	78323025 00000000 72616573 00006863     %02x....search..
   1384c:	00746567 72616573 65526863 00007073     get.searchResp..
   1385c:	6f706572 6c417472 666e496c 0000006f     reportAllInfo...
   1386c:	6f706572 6e497472 00006f66 6f706572     reportInfo..repo
   1387c:	69447472 6e6f6373 7463656e 00000000     rtDisconnect....
   1388c:	746e6f63 006c6f72 63627573 616d6d6f     control.subcomma
   1389c:	0000646e 4e646461 0065646f 33746567     nd..addNode.get3
   138ac:	6f6c5064 74614474 00000061 6f636564     dPlotData...deco
   138bc:	2d2d6564 2d2d2d2d 73250a2d 0000000a     de-------.%s....
   138cc:	25203d6a 00000a64 20474244 20646d63     j= %d...DBG cmd 
   138dc:	7325203d 616d202c 203d2063 202c7325     = %s, mac = %s, 
   138ec:	6f666e69 25203d20 00000a73 6e6f736a     info = %s...json
   138fc:	6f6c4332 61446475 6d206174 6f6c6c61     2CloudData mallo
   1390c:	61662063 00006c69 6976696c 7220676e     c fail..living r
   1391c:	006d6f6f 4e766564 00656d61 54766564     oom.devName.devT
   1392c:	00657079 706d6574 00000000 00007675     ype.temp....uv..
   1393c:	64697575 00000000 49207325 00000a6e     uuid....%s In...
   1394c:	4e646e65 4965646f 006f666e 00002b24     endNodeInfo.$+..
   1395c:	00002b3a 00002b50 00002b68 00002b80     :+..P+..h+...+..
   1396c:	00002b98 00002bb0 72700a0d 7365636f     .+...+....proces
   1397c:	6f6d2073 6e6f6974 0000000d 61746f72     s motion....rota
   1398c:	6e6f6974 74616420 203d2061 202c6425     tion data = %d, 
   1399c:	202c6425 202c6425 0a0d6425 00000000     %d, %d, %d......
   139ac:	74617473 3d207375 00642520 7364766e     status = %d.nvds
   139bc:	6172655f 73206573 74726174 0000000d     _erase start....
   139cc:	7364766e 6165725f 74732064 0d747261     nvds_read start.
   139dc:	00000000 206d766e 65676170 7a69735f     ....nvm page_siz
   139ec:	203d2065 000a6425 206d766e 6f5f6f6e     e = %d..nvm no_o
   139fc:	61705f66 3d206567 0a642520 00000000     f_page = %d.....
   13a0c:	7364766e 74616420 656c2061 64253a6e     nvds data len:%d
   13a1c:	00000000 64697373 25203d20 00000073     ....ssid = %s...
   13a2c:	0000394c 000037cc 0000383a 0000394c     L9...7..:8..L9..
   13a3c:	00003890 0000394c 000038dc 00003976     .8..L9...8..v9..
   13a4c:	00003976 00003976 00003da4 00003ce4     v9..v9...=...<..
   13a5c:	00003d1c 00003d3a 00003d8e 00003da4     .=..:=...=...=..
   13a6c:	00003bb8                                .;..

00013a70 <__func__.18986>:
   13a70:	69666977 74696e49 00000000              wifiInit....

00013a7c <__func__.18936>:
   13a7c:	5f6d326d 69666977 636f735f 5f74656b     m2m_wifi_socket_
   13a8c:	646e6168 0072656c                       handler.

00013a94 <__func__.18969>:
   13a94:	69666977 74697753 6f746863 00005041     wifiSwitchtoAP..

00013aa4 <__func__.18878>:
   13aa4:	5454514d 73627553 62697263 43424365     MQTTSubscribeCBC
   13ab4:	626c6c61 486b6361 6c646e61 00007265     allbackHandler..
   13ac4:	5f775f72 00726f63 5f785f72 00726f63     r_w_cor.r_x_cor.
   13ad4:	5f795f72 00726f63 5f7a5f72 00726f63     r_y_cor.r_z_cor.
   13ae4:	69666977 736e6553 6f42726f 00647261     wifiSensorBoard.
   13af4:	73657270 65727573 00000000 5d50415b     pressure....[AP]
   13b04:	50435420 72657320 20726576 6b636f73      TCP server sock
   13b14:	25207465 6c632064 6465736f 21642520     et %d closed %d!
   13b24:	00000a0d 6e69616d 326d203a 69775f6d     ....main: m2m_wi
   13b34:	645f6966 62617369 615f656c 61632070     fi_disable_ap ca
   13b44:	65206c6c 726f7272 00000d21 6e69616d     ll error!...main
   13b54:	326d203a 69775f6d 645f6966 62617369     : m2m_wifi_disab
   13b64:	615f656c 61632070 73206c6c 65636375     le_ap call succe
   13b74:	0d217373 00000000 6e69616d 4957203a     ss!.....main: WI
   13b84:	545f4946 5f4b5341 54495753 4e494843     FI_TASK_SWITCHIN
   13b94:	4f545f47 4154535f 0000000d 6e69616d     G_TO_STA....main
   13ba4:	326d203a 69775f6d 635f6966 656e6e6f     : m2m_wifi_conne
   13bb4:	0d207463 00000000 6e69616d 326d203a     ct .....main: m2
   13bc4:	69775f6d 635f6966 656e6e6f 63207463     m_wifi_connect c
   13bd4:	206c6c61 6f727265 000d2172 69666977     all error!..wifi
   13be4:	3a62635f 4d324d20 4649575f 45525f49     _cb: M2M_WIFI_RE
   13bf4:	435f5053 535f4e4f 45544154 4148435f     SP_CON_STATE_CHA
   13c04:	4445474e 4f43203a 43454e4e 0d444554     NGED: CONNECTED.
   13c14:	00000000 69666977 3a62635f 4d324d20     ....wifi_cb: M2M
   13c24:	4649575f 45525f49 435f5053 535f4e4f     _WIFI_RESP_CON_S
   13c34:	45544154 4148435f 4445474e 4944203a     TATE_CHANGED: DI
   13c44:	4e4f4353 5443454e 000d4445 74697753     SCONNECTED..Swit
   13c54:	6e696863 6f742067 41545320 646f6d20     ching to STA mod
   13c64:	000d2165 69666977 3a62635f 4d324d20     e!..wifi_cb: M2M
   13c74:	4649575f 45525f49 48445f51 435f5043     _WIFI_REQ_DHCP_C
   13c84:	3a464e4f 20504920 25207369 75252e75     ONF: IP is %u.%u
   13c94:	2e75252e 0a0d7525 00000000 50504128     .%u.%u......(APP
   13ca4:	4e492829 00294f46 5d50415b 50435420     )(INFO).[AP] TCP
   13cb4:	636f7320 2074656b 646e6962 63757320      socket bind suc
   13cc4:	73736563 00000d21 5d50415b 6e694220     cess!...[AP] Bin
   13cd4:	61462064 64656c69 7245202e 20726f72     d Failed. Error 
   13ce4:	65646f63 25203d20 000a0d64 5d50415b     code = %d...[AP]
   13cf4:	50435420 72657320 20726576 6b636f73      TCP server sock
   13d04:	25207465 6c632064 6465736f 000a0d21     et %d closed!...
   13d14:	5d50415b 50435420 72655320 20726576     [AP] TCP Server 
   13d24:	6b636f53 43207465 74616572 206e6f69     Socket Creation 
   13d34:	6c696146 000d6465 65636552 64657669     Failed..Received
   13d44:	6d697420 00000d65 6f666e69 2d2d2d20      time...info ---
   13d54:	74616420 70795461 25203a65 76202c73      dataType: %s, v
   13d64:	203a6c61 000a6425 3a474244 6d657420     al: %d..DBG: tem
   13d74:	61726570 65727574 25203d20 68202c64     perature = %d, h
   13d84:	64696d75 20797469 6425203d 7675202c     umidity = %d, uv
   13d94:	25203d20 70202c64 73736572 20657275      = %d, pressure 
   13da4:	6425203d 00000a0d 3164656c 00000000     = %d....led1....
   13db4:	646e6573 74616420 6c202c61 3d206e65     send data, len =
   13dc4:	0d642520 0000000a 646e6573 0d212120      %d.....send !!.
   13dd4:	00000000 44495353 6e656c20 0d64253d     ....SSID len=%d.
   13de4:	0000000a 44495353 73253d20 00000a0d     ....SSID =%s....
   13df4:	74697257 6f632065 6769666e 67617020     Write config pag
   13e04:	00000d65 20474244 44495353 0d73253d     e...DBG SSID=%s.
   13e14:	0000000a 20732520 000a6e49 7473694c     .... %s In..List
   13e24:	66206e65 756c6961 20216572 6f727245     en failure! Erro
   13e34:	203d2072 0a0d6425 00000000 20504354     r = %d......TCP 
   13e44:	6b636f73 25207465 696c2064 6e657473     socket %d listen
   13e54:	000a0d21 20504354 646e6962 72726520     !...TCP bind err
   13e64:	2520726f 0a0d2164 00000000 20504354     or %d!......TCP 
   13e74:	6b636f73 25207465 63612064 74706563     socket %d accept
   13e84:	000a0d21 20504354 7473696c 65206e65     !...TCP listen e
   13e94:	726f7272 21642520 00000a0d 65636361     rror %d!....acce
   13ea4:	73207470 206b636f 6f727265 00000d72     pt sock error...
   13eb4:	65636361 65207470 726f7272 0000000d     accept error....
   13ec4:	7373656d 20656761 7325203d 00000a0d     message = %s....
   13ed4:	20504354 6b636f53 25207465 72652064     TCP Socket %d er
   13ee4:	3a726f72 21642520 00000a0d 74706d45     ror: %d!....Empt
   13ef4:	74732079 6d616572 00000d21 6e6b6e55     y stream!...Unkn
   13f04:	206e776f 74617473 64252065 00000a0d     own state %d....
   13f14:	20746f4e 646e6168 2064656c 74617473     Not handled stat
   13f24:	64252065 00000a0d 5d73255b 0a6e4920     e %d....[%s] In.
   13f34:	00000000 6e69616d 326d203a 69775f6d     ....main: m2m_wi
   13f44:	695f6966 2074696e 6c6c6163 72726520     fi_init call err
   13f54:	2821726f 0d296425 0000000a 2043414d     or!(%d).....MAC 
   13f64:	72646441 3a737365 32302520 30253a58     Address: %02X:%0
   13f74:	253a5832 3a583230 58323025 3230253a     2X:%02X:%02X:%02
   13f84:	30253a58 0a0d5832 00000000 73774167     X:%02X......gAws
   13f94:	7474714d 65696c43 6449746e 64644120     MqttClientId Add
   13fa4:	73736572 7325203a 00000a0d 61746164     ress: %s....data
   13fb4:	746e6f43 006c6f72 61746164 6f706552     Control.dataRepo
   13fc4:	00007472 62755367 69726373 435f6562     rt..gSubscribe_C
   13fd4:	6e6e6168 203a6c65 0a0d7325 00000000     hannel: %s......
   13fe4:	62755067 6873696c 6168435f 6c656e6e     gPublish_Channel
   13ff4:	7325203a 00000a0d 20657375 61666564     : %s....use defa
   14004:	20746c75 44495353 0000000d 7263696d     ult SSID....micr
   14014:	6968636f 00000070 7068636d 38373635     ochip...mchp5678
   14024:	00000000 66654467 746c7561 44495353     ....gDefaultSSID
   14034:	2c73253d 3d777020 202c7325 68747561     =%s, pw=%s, auth
   14044:	2c64253d 69737320 6e656c64 2c64253d     =%d, ssidlen=%d,
   14054:	6c737020 253d6e65 00000a64 74614769      pslen=%d...iGat
   14064:	79617765 30463846 33463530 42393536     ewayF8F005F3659B
   14074:	00000000 5d73255b 69726220 7520676e     ....[%s] bring u
   14084:	50412070 000a0d21 6e69616d 326d203a     p AP!...main: m2
   14094:	69775f6d 655f6966 6c62616e 70615f65     m_wifi_enable_ap
   140a4:	6c616320 7265206c 21726f72 0000000d      call error!....
   140b4:	6e6e6f63 69746365 4120676e 73202c50     connecting AP, s
   140c4:	20646973 7325203d 70202c20 203d6477     sid = %s , pwd= 
   140d4:	000a7325 756f6c43 6f632064 63656e6e     %s..Cloud connec
   140e4:	61662074 2e2e6c69 00000d2e 73627573     t fail......subs
   140f4:	62697263 65732065 68637261 61686320     cribe search cha
   14104:	6c656e6e 7325203a 0000000a 6c627550     nnel: %s....Publ
   14114:	20687369 5454514d 61686320 6c656e6e     ish MQTT channel
   14124:	69616620 2e2e2e6c 0000000d 733e2d2d      fail.......-->s
   14134:	7065656c 63657220 656e6e6f 000d7463     leep reconnect..
   14144:	50504128 52452829 255b2952 255b5d73     (APP)(ERR)[%s][%
   14154:	00005d64 61766e69 6564696c 636f6920     d]..invalide ioc
   14164:	6320746c 0000646d                       lt cmd..

0001416c <__FUNCTION__.15733>:
   1416c:	625f6d6e 695f7375 6c74636f 00000000     nm_bus_ioctl....
   1417c:	00004ac4 00004a94 00004a8c 00004aa4     .J...J...J...J..
   1418c:	00004a9c 00004abc 00004aac 00004ab4     .J...J...J...J..

0001419c <__FUNCTION__.13753>:
   1419c:	5f666968 646e6168 695f656c 00007273     hif_handle_isr..

000141ac <__FUNCTION__.13765>:
   141ac:	5f666968 65636572 00657669              hif_receive.

000141b8 <__FUNCTION__.13781>:
   141b8:	5f666968 69676572 72657473 0062635f     hif_register_cb.
   141c8:	776f6c53 20676e69 6e776f64 002e2e2e     Slowing down....
   141d8:	46494828 69614629 6f74206c 6b617720     (HIF)Fail to wak
   141e8:	74207075 63206568 00706968 66696828     up the chip.(hif
   141f8:	49572029 485f4946 5f54534f 5f564352     ) WIFI_HOST_RCV_
   14208:	4c525443 6220315f 66207375 006c6961     CTRL_1 bus fail.
   14218:	66696828 64612029 73657264 75622073     (hif) address bu
   14228:	61662073 00006c69 66696828 6f432029     s fail..(hif) Co
   14238:	70757272 20646574 6b636170 53207465     rrupted packet S
   14248:	20657a69 7525203d 204c3c20 7525203d     ize = %u <L = %u
   14258:	2047202c 7525203d 504f202c 25203d20     , G = %u, OP = %
   14268:	3e583230 0000000a 49464957 6c616320     02X>....WIFI cal
   14278:	6361626c 7369206b 746f6e20 67657220     lback is not reg
   14288:	65747369 00646572 6b6f6353 63207465     istered.Scoket c
   14298:	626c6c61 206b6361 6e207369 7220746f     allback is not r
   142a8:	73696765 65726574 00000064 2061744f     egistered...Ota 
   142b8:	6c6c6163 6b636162 20736920 20746f6e     callback is not 
   142c8:	69676572 72657473 00006465 70797243     registered..Cryp
   142d8:	63206f74 626c6c61 206b6361 6e207369     to callback is n
   142e8:	7220746f 73696765 65726574 00000064     ot registered...
   142f8:	6d676953 61632061 61626c6c 69206b63     Sigma callback i
   14308:	6f6e2073 65722074 74736967 64657265     s not registered
   14318:	00000000 66696828 6e692029 696c6176     ....(hif) invali
   14328:	72672064 2070756f 00004449 66696828     d group ID..(hif
   14338:	6f682029 61207473 64207070 276e6469     ) host app didn'
   14348:	65732074 58522074 6e6f4420 253c2065     t set RX Done <%
   14358:	253c3e75 000a3e58 66696828 72572029     u><%X>..(hif) Wr
   14368:	20676e6f 657a6953 00000000 66696828     ong Size....(hif
   14378:	61462029 2065736c 65746e69 70757272     ) False interrup
   14388:	6c252074 00000078 66696828 61462029     t %lx...(hif) Fa
   14398:	74206c69 6552206f 69206461 7265746e     il to Read inter
   143a8:	74707572 67657220 00000000 46494828     rupt reg....(HIF
   143b8:	61462029 74206c69 6168206f 656c646e     ) Fail to handle
   143c8:	746e6920 75727265 25207470 72742064      interrupt %d tr
   143d8:	67412079 2e6e6961 00000a2e 66696820     y Again..... hif
   143e8:	6365725f 65766965 6e49203a 696c6176     _receive: Invali
   143f8:	72612064 656d7567 0000746e 20505041     d argument..APP 
   14408:	75716552 65747365 69532064 6920657a     Requested Size i
   14418:	616c2073 72656772 61687420 6874206e     s larger than th
   14428:	65722065 65766963 75622064 72656666     e recived buffer
   14438:	7a697320 253c2065 253c3e75 0a3e756c      size <%u><%lu>.
   14448:	00000000 20505041 75716552 65747365     ....APP Requeste
   14458:	64412064 73657264 65622073 646e6f79     d Address beyond
   14468:	65687420 63657220 64657669 66756220      the recived buf
   14478:	20726566 72646461 20737365 20646e61     fer address and 
   14488:	676e656c 00006874 20705247 6425203f     length..GRp ? %d
   14498:	0000000a                                ....

0001449c <__FUNCTION__.13737>:
   1449c:	5f666968 646e6573 00000000              hif_send....

000144a8 <__FUNCTION__.13747>:
   144a8:	5f666968 00727369                       hif_isr.

000144b0 <__FUNCTION__.13773>:
   144b0:	5f6d326d 69666977 6e6f635f 7463656e     m2m_wifi_connect
   144c0:	0063735f                                _sc.

000144c4 <__FUNCTION__.13716>:
   144c4:	5f6d326d 69666977 0062635f 666e6f43     m2m_wifi_cb.Conf
   144d4:	7463696c 49206465 20222050 252e7525     licted IP " %u.%
   144e4:	75252e75 2075252e 000a2022 20514552     u.%u.%u " ..REQ 
   144f4:	20746f4e 69666564 2064656e 000a6425     Not defined %d..
   14504:	41564e49 2044494c 4e494f50 00524554     INVALID POINTER.
   14514:	41564e49 2044494c 44495353 00000000     INVALID SSID....
   14524:	41564e49 2044494c 00004843 41564e49     INVALID CH..INVA
   14534:	2044494c 50434844 52455320 20524556     LID DHCP SERVER 
   14544:	00005049 41564e49 2044494c 2059454b     IP..INVALID KEY 
   14554:	45444e49 00000058 41564e49 2044494c     INDEX...INVALID 
   14564:	2059454b 49525453 5320474e 00455a49     KEY STRING SIZE.
   14574:	41564e49 2044494c 2059454b 455a4953     INVALID KEY SIZE
   14584:	00000000 41564e49 2044494c 20415057     ....INVALID WPA 
   14594:	2059454b 455a4953 00000000 41564e49     KEY SIZE....INVA
   145a4:	2044494c 48545541 49544e45 49544143     LID AUTHENTICATI
   145b4:	4d204e4f 0045444f 6d726946 65726177     ON MODE.Firmware
   145c4:	72657620 3a202020 2e752520 252e7525      ver   : %u.%u.%
   145d4:	76532075 7665726e 0a752520 00000000     u Svnrev %u.....
   145e4:	6d726946 65726177 69754220 2520646c     Firmware Build %
   145f4:	69542073 2520656d 00000a73 6d726946     s Time %s...Firm
   14604:	65726177 6e694d20 69726420 20726576     ware Min driver 
   14614:	20726576 7525203a 2e75252e 000a7525     ver : %u.%u.%u..
   14624:	76697244 76207265 203a7265 252e7525     Driver ver: %u.%
   14634:	75252e75 0000000a 343a3631 30343a32     u.%u....16:42:40
   14644:	00000000 206e614a 32203432 00383130     ....Jan 24 2018.
   14654:	76697244 62207265 746c6975 20746120     Driver built at 
   14664:	25097325 00000a73 6d73694d 68637461     %s.%s...Mismatch
   14674:	72694620 7277616d 65562065 6f697372      Firmawre Versio
   14684:	0000006e 2079654b 6e207369 7620746f     n...Key is not v
   14694:	64696c61 00000000 61766e49 2064696c     alid....Invalid 
   146a4:	0079654b 44495353 4e454c20 564e4920     Key.SSID LEN INV
   146b4:	44494c41 00000000 49204843 4c41564e     ALID....CH INVAL
   146c4:	00004449 61766e49 2064696c 20706557     ID..Invalid Wep 
   146d4:	2079656b 65646e69 64252078 0000000a     key index %d....
   146e4:	61766e49 2064696c 20706557 2079656b     Invalid Wep key 
   146f4:	676e656c 25206874 00000a64 6f636e49     length %d...Inco
   14704:	63657272 53502074 656b204b 656c2079     rrect PSK key le
   14714:	6874676e 00000000 65646e75 656e6966     ngth....undefine
   14724:	65732064 79742063 00006570 41564e49     d sec type..INVA
   14734:	2044494c 6f206f4e 63732066 73206e61     LID No of scan s
   14744:	73746f6c 64252021 0000000a 41564e49     lots! %d....INVA
   14754:	2044494c 6e616373 6f6c7320 69742074     LID scan slot ti
   14764:	2021656d 000a6425 41564e49 2044494c     me! %d..INVALID 
   14774:	6f206f4e 72702066 2065626f 75716572     No of probe requ
   14784:	73747365 72657020 61637320 6c73206e     ests per scan sl
   14794:	2520746f 00000a64 41564e49 2044494c     ot %d...INVALID 
   147a4:	49535352 72687420 6f687365 2520646c     RSSI threshold %
   147b4:	000a2064 5f53505f 56524553 205f5245     d .._PS_SERVER_ 
   147c4:	6e207369 6420746f 6e696665 00006465     is not defined..
   147d4:	7473694c 63206e65 6e6e6168 73206c65     Listen channel s
   147e4:	6c756f68 6e6f2064 6220796c 324d2065     hould only be M2
   147f4:	49575f4d 435f4946 2f315f48 31312f36     M_WIFI_CH_1/6/11
   14804:	00000020 45574f50 41532052 25204556      ...POWER SAVE %
   14814:	00000a64 41564e49 2044494c 414d4f44     d...INVALID DOMA
   14824:	4e204e49 00454d41 474e5250 66754220     IN NAME.PRNG Buf
   14834:	20726566 65637865 64656465 78616d20     fer exceeded max
   14844:	6d756d69 7a697320 64252065 20726f20     imum size %d or 
   14854:	4c4c554e 66754220 0a726566 00000000     NULL Buffer.....

00014864 <__FUNCTION__.13725>:
   14864:	5f6d326d 696c6176 65746164 5f70615f     m2m_validate_ap_
   14874:	61726170 6574656d 00007372              parameters..

00014880 <__FUNCTION__.13745>:
   14880:	5f6d326d 69666977 696e695f 00000074     m2m_wifi_init...
   14890:	20737542 6f727265 35282072 64252e29     Bus error (5).%d
   148a0:	786c2520 0000000a 6c696146 74206465      %lx....Failed t
   148b0:	6177206f 2070756b 20656874 70696863     o wakup the chip
   148c0:	00000000 76697244 65567265 666e4972     ....DriverVerInf
   148d0:	30203a6f 38302578 000a786c 6c696166     o: 0x%08lx..fail
   148e0:	74206465 6564206f 696e692d 6c616974     ed to de-initial
   148f0:	00657a69                                ize.

000148f4 <__FUNCTION__.13628>:
   148f4:	70696863 6965645f 0074696e              chip_deinit.

00014900 <__FUNCTION__.13579>:
   14900:	70696863 6b61775f 00000065 696d6e5b     chip_wake...[nmi
   14910:	61747320 3a5d7472 69616620 6e69206c      start]: fail in
   14920:	62207469 00007375 70696843 20444920     it bus..Chip ID 
   14930:	0a786c25 00000000 6c696166 74206465     %lx.....failed t
   14940:	6e65206f 656c6261 746e6920 75727265     o enable interru
   14950:	2e737470 0000002e 696d6e5b 6f747320     pts.....[nmi sto
   14960:	203a5d70 70696863 6965645f 2074696e     p]: chip_deinit 
   14970:	6c696166 00000000 696d6e5b 6f747320     fail....[nmi sto
   14980:	203a5d70 20495053 73616c66 69642068     p]: SPI flash di
   14990:	6c626173 61662065 00006c69 696d6e5b     sable fail..[nmi
   149a0:	6f747320 203a5d70 6c696166 696e6920      stop]: fail ini
   149b0:	75622074 00000073                       t bus...

000149b8 <__FUNCTION__.13626>:
   149b8:	645f6d6e 695f7672 0074696e              nm_drv_init.

000149c4 <__FUNCTION__.13633>:
   149c4:	645f6d6e 645f7672 696e6965 00000074     nm_drv_deinit...
   149d4:	00005d44 00005d44 00005d74 00005cf6     D]..D]..t]...\..
   149e4:	00005d1a 00005d28 00005d5a 00005d5a     .]..(]..Z]..Z]..
   149f4:	00005da2 00005ce6 00005e04 00005e04     .]...\...^...^..
   14a04:	00005e04 00005e04 00005d36 cac4c9c3     .^...^..6]......

00014a14 <__FUNCTION__.13027>:
   14a14:	735f6d6e 725f6970 00646165              nm_spi_read.

00014a20 <__FUNCTION__.12979>:
   14a20:	5f697073 61746164 6972775f 00006574     spi_data_write..

00014a30 <__FUNCTION__.12991>:
   14a30:	5f697073 74697277 65725f65 00000067     spi_write_reg...

00014a40 <__FUNCTION__.12932>:
   14a40:	5f697073 00646d63                       spi_cmd.

00014a48 <__FUNCTION__.12939>:
   14a48:	5f697073 61746164 7073725f 00000000     spi_data_rsp....

00014a58 <__FUNCTION__.13002>:
   14a58:	735f6d6e 775f6970 65746972 00000000     nm_spi_write....
   14a68:	696d6e5b 69707320 46203a5d 656c6961     [nmi spi]: Faile
   14a78:	6d632064 72772064 2c657469 73756220     d cmd write, bus
   14a88:	72726520 2e2e726f 0000002e 696d6e5b      error......[nmi
   14a98:	69707320 46203a5d 656c6961 6d632064      spi]: Failed cm
   14aa8:	65722064 6e6f7073 72206573 2c646165     d response read,
   14ab8:	73756220 72726520 2e2e726f 0000002e      bus error......
   14ac8:	696d6e5b 69707320 46203a5d 656c6961     [nmi spi]: Faile
   14ad8:	61642064 72206174 6f707365 2065736e     d data response 
   14ae8:	64616572 7562202c 72652073 2e726f72     read, bus error.
   14af8:	00002e2e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
   14b08:	656c6961 61642064 72206174 6f707365     ailed data respo
   14b18:	2065736e 64616572 282e2e2e 78323025     nse read...(%02x
   14b28:	00000a29 696d6e5b 69707320 46203a5d     )...[nmi spi]: F
   14b38:	656c6961 61642064 62206174 6b636f6c     ailed data block
   14b48:	61657220 62202c64 65207375 726f7272      read, bus error
   14b58:	002e2e2e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
   14b68:	656c6961 61642064 62206174 6b636f6c     ailed data block
   14b78:	63726320 61657220 62202c64 65207375      crc read, bus e
   14b88:	726f7272 002e2e2e 696d6e5b 69707320     rror....[nmi spi
   14b98:	46203a5d 656c6961 6d632064 77202c64     ]: Failed cmd, w
   14ba8:	65746972 67657220 30252820 2e297838     rite reg (%08x).
   14bb8:	000a2e2e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
   14bc8:	656c6961 6d632064 65722064 6e6f7073     ailed cmd respon
   14bd8:	202c6573 74697277 65722065 25282067     se, write reg (%
   14be8:	29783830 0a2e2e2e 00000000 65736552     08x)........Rese
   14bf8:	6e612074 65722064 20797274 25206425     t and retry %d %
   14c08:	2520786c 000a786c 696d6e5b 69707320     lx %lx..[nmi spi
   14c18:	46203a5d 656c6961 6d632064 72202c64     ]: Failed cmd, r
   14c28:	20646165 20676572 38302528 2e2e2978     ead reg (%08x)..
   14c38:	00000a2e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
   14c48:	656c6961 6d632064 65722064 6e6f7073     ailed cmd respon
   14c58:	202c6573 64616572 67657220 30252820     se, read reg (%0
   14c68:	2e297838 000a2e2e 696d6e5b 69707320     8x).....[nmi spi
   14c78:	46203a5d 656c6961 61642064 72206174     ]: Failed data r
   14c88:	2e646165 00002e2e 65736552 6e612074     ead.....Reset an
   14c98:	65722064 20797274 25206425 000a786c     d retry %d %lx..
   14ca8:	696d6e5b 69707320 46203a5d 656c6961     [nmi spi]: Faile
   14cb8:	6e692064 6e726574 72206c61 20646165     d internal read 
   14cc8:	746f7270 6c6f636f 74697720 52432068     protocol with CR
   14cd8:	6e6f2043 6572202c 69727974 7720676e     C on, retyring w
   14ce8:	20687469 20435243 2e66666f 00002e2e     ith CRC off.....
   14cf8:	696d6e5b 69707320 46203a5d 656c6961     [nmi spi]: Faile
   14d08:	6e692064 6e726574 72206c61 20646165     d internal read 
   14d18:	746f7270 6c6f636f 002e2e2e 696d6e5b     protocol....[nmi
   14d28:	69707320 46203a5d 656c6961 6e692064      spi]: Failed in
   14d38:	6e726574 77206c61 65746972 6f727020     ternal write pro
   14d48:	6f636f74 6572206c 2e2e2e67 00000000     tocol reg.......
   14d58:	696d6e5b 69707320 46203a5d 206c6961     [nmi spi]: Fail 
   14d68:	20646d63 64616572 69686320 64692070     cmd read chip id
   14d78:	002e2e2e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
   14d88:	656c6961 6d632064 72202c64 20646165     ailed cmd, read 
   14d98:	636f6c62 2528206b 29783830 0a2e2e2e     block (%08x)....
   14da8:	00000000 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
   14db8:	656c6961 6d632064 65722064 6e6f7073     ailed cmd respon
   14dc8:	202c6573 64616572 6f6c6220 28206b63     se, read block (
   14dd8:	78383025 2e2e2e29 0000000a 696d6e5b     %08x).......[nmi
   14de8:	69707320 46203a5d 656c6961 6c622064      spi]: Failed bl
   14df8:	206b636f 61746164 61657220 2e2e2e64     ock data read...
   14e08:	00000000 65736552 6e612074 65722064     ....Reset and re
   14e18:	20797274 25206425 2520786c 00000a64     try %d %lx %d...
   14e28:	696d6e5b 69707320 46203a5d 656c6961     [nmi spi]: Faile
   14e38:	6d632064 77202c64 65746972 6f6c6220     d cmd, write blo
   14e48:	28206b63 78383025 2e2e2e29 0000000a     ck (%08x).......
   14e58:	696d6e5b 69707320 203a5d20 6c696146     [nmi spi ]: Fail
   14e68:	63206465 7220646d 6f707365 2c65736e     ed cmd response,
   14e78:	69727720 62206574 6b636f6c 30252820      write block (%0
   14e88:	2e297838 000a2e2e 696d6e5b 69707320     8x).....[nmi spi
   14e98:	46203a5d 656c6961 61642064 62206174     ]: Failed data b
   14ea8:	6b636f6c 646d6320 69727720 202c6574     lock cmd write, 
   14eb8:	20737562 6f727265 2e2e2e72 00000000     bus error.......
   14ec8:	696d6e5b 69707320 46203a5d 656c6961     [nmi spi]: Faile
   14ed8:	61642064 62206174 6b636f6c 69727720     d data block wri
   14ee8:	202c6574 20737562 6f727265 2e2e2e72     te, bus error...
   14ef8:	00000000 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
   14f08:	656c6961 61642064 62206174 6b636f6c     ailed data block
   14f18:	63726320 69727720 202c6574 20737562      crc write, bus 
   14f28:	6f727265 2e2e2e72 00000000 696d6e5b     error.......[nmi
   14f38:	69707320 46203a5d 656c6961 75622064      spi]: Failed bu
   14f48:	72652073 2e726f72 00002e2e 696d6e5b     s error.....[nmi
   14f58:	69707320 46203a5d 656c6961 61642064      spi]: Failed da
   14f68:	72206174 6f707365 2065736e 64616572     ta response read
   14f78:	7825202c 20782520 000a7825 696d6e5b     , %x %x %x..[nmi
   14f88:	69707320 46203a5d 656c6961 6c622064      spi]: Failed bl
   14f98:	206b636f 61746164 69727720 2e2e6574     ock data write..
   14fa8:	0000002e                                ....

00014fac <__FUNCTION__.12948>:
   14fac:	5f697073 5f646d63 00707372              spi_cmd_rsp.

00014fb8 <__FUNCTION__.13014>:
   14fb8:	5f697073 64616572 6765725f 00000000     spi_read_reg....

00014fc8 <__FUNCTION__.12964>:
   14fc8:	5f697073 61746164 6165725f 00000064     spi_data_read...

00014fd8 <crc7_syndrome_table>:
   14fd8:	1b120900 3f362d24 535a4148 777e656c     ....$-6?HAZSle~w
   14fe8:	020b1019 262f343d 4a435851 6e677c75     ....=4/&QXCJu|gn
   14ff8:	29203b32 0d041f16 6168737a 454c575e     2; )....zsha^WLE
   15008:	3039222b 141d060f 78716a63 5c554e47     +"90....cjqxGNU\
   15018:	7f766d64 5b524940 373e252c 131a0108     dmv.@IR[,%>7....
   15028:	666f747d 424b5059 2e273c35 0a031811     }tofYPKB5<'.....
   15038:	4d445f56 69607b72 050c171e 2128333a     V_DMr{`i....:3(!
   15048:	545d464f 7079626b 1c150e07 38312a23     OF]Tkbyp....#*18
   15058:	5a534841 7e776c65 121b0009 363f242d     AHSZelw~....-$?6
   15068:	434a5158 676e757c 0b021910 2f263d34     XQJC|ung....4=&/
   15078:	68617a73 4c455e57 2029323b 040d161f     szahW^EL;2) ....
   15088:	7178636a 555c474e 39302b22 1d140f06     jcxqNG\U"+09....
   15098:	3e372c25 1a130801 767f646d 525b4049     %,7>....md.vI@[R
   150a8:	272e353c 030a1118 6f667d74 4b425950     <5.'....t}foPYBK
   150b8:	0c051e17 28213a33 444d565f 6069727b     ....3:!(_VMD{ri`
   150c8:	151c070e 3138232a 5d544f46 79706b62     ....*#81FOT]bkpy

000150d8 <__FUNCTION__.13048>:
   150d8:	735f6d6e 695f6970 0074696e 52524528     nm_spi_init.(ERR
   150e8:	75432952 6e657272 253c2074 000a3e64     R)Current <%d>..
   150f8:	6b636f53 25207465 65732064 6f697373     Socket %d sessio
   15108:	4449206e 25203d20 000a0d64 6b636f53     n ID = %d...Sock
   15118:	206f7420 656c6564 3c206574 0a3e6425      to delete <%d>.
   15128:	00000000 20494e53 65637845 20736465     ....SNI Exceeds 
   15138:	2078614d 676e654c 00006874 6e6b6e55     Max Length..Unkn
   15148:	206e776f 204c5353 6b636f53 4f207465     own SSL Socket O
   15158:	6f697470 6425206e 0000000a 20746f4e     ption %d....Not 
   15168:	204c5353 6b636f53 00007465 4354514d     SSL Socket..MQTC
   15178:	00000400 00000000 00000000 00000000     ................
   15188:	0001003c 5754514d 00000000 00000000     <...MQTW........
	...

000151c8 <MQTTPublishParamsDefault>:
	...

000151dc <MQTTMessageParamsDefault>:
	...
   151ec:	6f653361 676c7779 68646273 692e3873     a3eoywlgsbdhs8.i
   151fc:	752e746f 61652d73 312d7473 616d612e     ot.us-east-1.ama
   1520c:	616e6f7a 632e7377 00006d6f              zonaws.com..

00015218 <MQTTSubscribeParamsDefault>:
	...

00015224 <MQTTConnectParamsDefault>:
   15224:	00000000 000151ec 000022b3 00000000     .....Q..."......
	...
   15248:	000a0004 00000001 00000000 00000000     ................
   15258:	00000000 000003e8 000007d0 00000001     ................
   15268:	00000000 74736f48 20504920 25207369     ....Host IP is %
   15278:	64252e64 2e64252e 0a0d6425 00000000     d.%d.%d.%d......
   15288:	74736f48 6d614e20 73692065 0d732520     Host Name is %s.
   15298:	0000000a 63637553 66737365 796c6c75     ....Successfully
   152a8:	6e6f6320 7463656e 0d2e6465 00000000      connected......
   152b8:	6e6e6f43 20746365 6f727265 63202172     Connect error! c
   152c8:	2865646f 0d296425 0000000a 6b636f53     ode(%d).....Sock
   152d8:	73207465 20646e65 6f727265 64253a72     et send error:%d
   152e8:	00000a0d 0000857c 0000857c 00008542     ....|...|...B...
   152f8:	00008546 00008542 00008550 0000857c     F...B...P...|...
   15308:	00008542 0000857c 00008542 0000857c     B...|...B...|...
   15318:	00008542 0000857c 0000855a 4354514d     B...|...Z...MQTC
   15328:	00000400 00000000 00000000 00000000     ................
   15338:	0001003c 5754514d 00000000 00000000     <...MQTW........
	...
   15378:	00009050 00009058 00009060 00009068     P...X...`...h...
   15388:	00009070 00009078 5454514d 00000000     p...x...MQTT....
   15398:	7349514d 00007064 000096be 00009594     MQIsdp..........
   153a8:	000095a2 000095b0 000095be 000095cc     ................
   153b8:	000095da 000095e8 000095f6 00009604     ................
   153c8:	00009612 00009620 0000962e 0000963c     .... .......<...
   153d8:	0000964a 00009c0a 00009b46 00009c0a     J.......F.......
   153e8:	00009c0a 00009b56 00009c0a 00009c0a     ....V...........
   153f8:	00009c0a 00009c0a 00009b8e 00009c0a     ................
   15408:	00009c0a 00009c0a 00009c0a 00009c0a     ................
   15418:	00009b32 00009c0a 00009c0a 00009b86     2...............

00015428 <_bhi_fw>:
   15428:	0a00652a 4edccf94 00000000 000064b8     *e.....N.....d..
   15438:	007f8c5c 007f8c1c 007f8c34 7000264a     \.......4...J&.p
   15448:	7000264a 7000264a 7000264a 7000264a     J&.pJ&.pJ&.pJ&.p
   15458:	7000264a 7000264a 7000264a 7000264a     J&.pJ&.pJ&.pJ&.p
   15468:	7000264a 7000264a 7000264a 7000264a     J&.pJ&.pJ&.pJ&.p
   15478:	0060967c 0060967c 0060967c 0060967c     |.`.|.`.|.`.|.`.
   15488:	0060967c 0060967c 0060967c 0060967c     |.`.|.`.|.`.|.`.
   15498:	00605ba8 006071a4 0060750c 006061ac     .[`..q`..u`..a`.
   154a8:	007f8c28 007f8c28 007f8c28 007f8c28     (...(...(...(...
   154b8:	00606c78 00606c78 00606c78 00606c78     xl`.xl`.xl`.xl`.
   154c8:	00606c78 00606c78 0d8f01d5 0d4f0409     xl`.xl`.......O.
   154d8:	0d4f03b1 0d4f03cd 0d4f0399 0d4f03b5     ..O...O...O...O.
   154e8:	0d4f034d 0d8f00e9 0d4f04c1 0d8f01e5     M.O.......O.....
   154f8:	0d8f007d 0d8f003d 0d8f0021 0d4f067d     }...=...!...}.O.
   15508:	0d4f03e5 0d4f06c9 0d4f035d 0d4f04e1     ..O...O.].O...O.
   15518:	0d4f0539 0d4f0335 0d4f0325 0d4f03fd     9.O.5.O.%.O...O.
   15528:	0e0f0701 0e0f0639 0e0f078d 0e0f07a1     ....9...........
   15538:	0e0f0699 0e0f069d 0e0f06a1 0e0f0615     ................
   15548:	0e0f0665 0e0f0671 0e0f0665 0e0f0671     e...q...e...q...
   15558:	0e0f073d 0bcf06b5 0bcf06bd 0bcf06c5     =...............
   15568:	0bcf06e1 0bcf0611 0bcf0731 0bcf05d9     ........1.......
   15578:	0bcf05e5 0bcf0621 0bcf05ed 0bcf05f1     ....!...........
   15588:	0bcf060d 0f8f0631 0f8f0621 0f8f0611     ....1...!.......
   15598:	0f8f0431 0f8f044d 0c0f07f1 0c0f0415     1...M...........
   155a8:	0c0f0369 0c0f050d 0c0f048d 0c0f0331     i...........1...
   155b8:	0c0f06e5 0c0f0235 0c0f02f9 0c0f00e5     ....5...........
   155c8:	0c0f0399 0c0f00fd 0c0f0241 0c0f02b9     ........A.......
   155d8:	0c0f07a5 0c0f00a9 0c0f0251 0c0f0521     ........Q...!...
   155e8:	0c0f0179 0c0f00fd 0c0f010d 0c0f0115     y...............
   155f8:	0c0f068d 0d8f02b9 0d8f026d 0d8f023d     ........m...=...
   15608:	0d8f0301 0d8f0241 0d8f05b5 0d8f05c5     ....A...........
   15618:	0d8f0429 0d8f03fd 0d8f045d 0d8f038d     ).......].......
   15628:	0d8f0429 0d8f037d 0d8f0435 0e8f056d     )...}...5...m...
   15638:	0e8f0491 00c002c1 0e8f0389 0e8f0649     ............I...
   15648:	0e8f03ad 0e8f02d9 0ecf01b5 0e8f06ad     ................
   15658:	0e8f0355 0e8f0419 0e8f0379 0e8f0661     U.......y...a...
   15668:	0e8f06c9 0e8f0351 0e8f03bd 0ecf00e1     ....Q...........
   15678:	00c003ad 00c003b9 00c003c5 0ecf025d     ............]...
   15688:	0ecf0249 0ecf04a5 0ecf0231 00c003c9     I.......1.......
   15698:	0ecf04f1 00c0050d 00c00535 0ecf031d     ........5.......
   156a8:	0f0f01d5 0f0f0069 0f0f0329 0f0f0345     ....i...)...E...
   156b8:	0f0f0085 00c00735 00c00741 01000015     ....5...A.......
   156c8:	0f0f0391 0f0f0359 0f0f007d 0acf0765     ....Y...}...e...
   156d8:	0acf06f1 0acf0721 0acf06a1 0acf06cd     ....!...........
   156e8:	0acf0661 0acf06ad 0acf0679 0b0f0205     a.......y.......
   156f8:	0b0f0121 0b0f00f5 0b0f00c9 0b0f0101     !...............
   15708:	0b0f032d 0b0f01ad 0b0f011d 0acf07ed     -...............
   15718:	0b0f0011 0b0f001d 0b0f0301 0b0f002d     ............-...
   15728:	0b0f0041 0b0f0055 0acf07e1 0b0f006d     A...U.......m...
   15738:	0b0f051d 0b0f04ed 0b0f059d 0b0f05f9     ................
   15748:	0b0f0529 0b0f0541 0e8f00a9 0e8f0031     )...A.......1...
   15758:	0e4f06b9 0e4f06e1 0e4f0705 0e4f075d     ..O...O...O.].O.
   15768:	0e4f07c9 0e4f07f5 0e4f0679 0e4f0701     ..O...O.y.O...O.
   15778:	0e4f068d 0e4f06d9 0e8f0145 0e4f0701     ..O...O.E.....O.
   15788:	0e4f0711 0e4f0695 0e4f06a1 0e4f0719     ..O...O...O...O.
   15798:	0e4f073d 0e0f05f9 0e4f00cd 0e0f0679     =.O.......O.y...
   157a8:	0e0f0659 0e0f0585 0e0f0629 0e0f0659     Y.......)...Y...
   157b8:	0e0f065d 0e0f0635 0f8f03b5 0c4f0169     ]...5.......i.O.
   157c8:	0c4f0151 0c4f0085 0c4f028d 0c4f0175     Q.O...O...O.u.O.
   157d8:	0c4f01cd 0c4f02b9 0c4f019d 0c4f00e5     ..O...O...O...O.
   157e8:	0c4f00d1 0c4f00ed 0c4f00d1 0c4f00dd     ..O...O...O...O.
   157f8:	0c4f00f9 0c4f00e5 0c4f00e9 0c4f00f5     ..O...O...O...O.
   15808:	0c4f0101 0c4f00f5 0c4f0031 0c4f0099     ..O...O.1.O...O.
   15818:	0e0f0185 0d8f0651 0d8f0699 0d8f06b1     ....Q...........
   15828:	0d8f0761 0d8f076d 0d8f0749 0d8f0735     a...m...I...5...
   15838:	0d8f0671 0dcf0451 0e0f0089 0dcf0179     q...Q.......y...
   15848:	0dcf0369 0dcf029d 0dcf01e5 0dcf0279     i...........y...
   15858:	0dcf0199 0d8f0411 0d8f053d 0d8f0681     ........=.......
   15868:	0d8f0689 0dcf073d 0dcf0431 0d8f06d9     ....=...1.......
   15878:	0d8f0625 0dcf03fd 0d8f05d9 0d8f0765     %...........e...
   15888:	0d8f0389 0d8f05f1 0e4f003d 0e4f00a5     ........=.O...O.
   15898:	0e4f001d 0e0f07e1 0e4f0005 0e4f0009     ..O.......O...O.
   158a8:	0e4f02e9 0e4f03c5 0e4f04ed 0e4f0245     ..O...O...O.E.O.
   158b8:	0e4f02bd 0e4f0335 0e4f0345 0e4f0325     ..O.5.O.E.O.%.O.
   158c8:	0e4f0315 0e4f0341 0b0f05e1 0b0f0571     ..O.A.O.....q...
   158d8:	0b0f0605 0b0f0595 0b0f06a9 0b0f06d9     ................
   158e8:	0b0f07f9 0b4f0055 0b0f0685 0b0f066d     ....U.O.....m...
   158f8:	0b0f0611 0b0f0639 0b0f06e5 0b4f0005     ....9.........O.
   15908:	0b4f0109 0b4f0199 0b4f01b1 0b4f0289     ..O...O...O...O.
   15918:	0b4f02f5 0b4f031d 0b4f0141 0b4f01e1     ..O...O.A.O...O.
   15928:	0b4f01f9 0b4f0211 0b4f0229 0b4f0069     ..O...O.).O.i.O.
   15938:	0b4f0101 0b4f0021 0b0f06ed 0c4f05d9     ..O.!.O.......O.
   15948:	0c8f0431 0c4f061d 0c4f0175 0c4f04b1     1.....O.u.O...O.
   15958:	0c4f0525 0c4f02d5 0c8f0119 0c4f07c9     %.O...O.......O.
   15968:	0c4f078d 0c4f0289 0c4f0295 00c00639     ..O...O...O.9...
   15978:	0c4f06ed 0c4f022d 0c4f0265 0c4f07c5     ..O.-.O.e.O...O.
   15988:	0c4f0565 0c4f0125 0c4f0449 0c4f0455     e.O.%.O.I.O.U.O.
   15998:	0c4f056d 0c4f0389 0c4f035d 0c4f03a9     m.O...O.].O...O.
   159a8:	0c4f0369 0c4f038d 0c4f015d 0c4f062d     i.O...O.].O.-.O.
   159b8:	0c4f01e5 0c4f01d5 0c4f03c9 0c4f039d     ..O...O...O...O.
   159c8:	0c4f03e9 0c4f03f9 0c4f03a5 0c4f03c9     ..O...O...O...O.
   159d8:	0c4f02dd 0c4f05f1 0c4f02f1 0c4f0301     ..O...O...O...O.
   159e8:	0c8f07a1 0c4f0649 0c4f0101 0c4f0191     ....I.O...O...O.
   159f8:	0c4f0609 0c4f0219 0c4f0251 0c4f0165     ..O...O.Q.O.e.O.
   15a08:	0c4f0145 0c8f0515 0ccf0391 0ccf0519     E.O.............
   15a18:	0ccf0555 0ccf06a1 0ccf05dd 0ccf01dd     U...............
   15a28:	0ccf02e5 0ccf01ed 0ccf0601 00400605     ..............@.
   15a38:	0bcf0439 0bcf03d9 0bcf03e1 0bcf03c9     9...............
   15a48:	07cf04dd 0d0f0345 0f4f01a1 0f4f0255     ....E.....O.U.O.
   15a58:	00c00675 0f0f074d 0f0f07fd 0bcf0141     u...M.......A...
   15a68:	07cf01b9 0f4f0179 08cf02d5 00c006b1     ....y.O.........
   15a78:	08cf03e1 00c00739 088f0491 08cf01bd     ....9...........
   15a88:	08cf0219 088f0759 088f0779 088f0799     ....Y...y.......
   15a98:	08cf00f5 08cf0119 08cf013d 08cf043d     ........=...=...
   15aa8:	08cf015d 08cf0215 088f07a1 088f07dd     ]...............
   15ab8:	08cf0015 08cf01a9 088f0481 08cf0049     ............I...
   15ac8:	08cf0319 01000121 0100016d 098f07a9     ....!...m.......
   15ad8:	0acf00b5 0acf00c9 0a4f04e5 0a4f0431     ..........O.1.O.
   15ae8:	0a4f0609 098f060d 09cf0531 09cf05e5     ..O.....1.......
   15af8:	09cf04b9 09cf04a5 0a0f02e9 0a0f028d     ................
   15b08:	0a0f0481 0a0f0165 0a0f006d 0acf0009     ....e...m.......
   15b18:	0a0f00e9 0a0f0009 0acf0029 0a0f012d     ........)...-...
   15b28:	0a8f07c9 0a0f0085 0a0f0409 0a0f03dd     ................
   15b38:	098f02e9 0a0f02f1 0a0f0499 010002d1     ................
   15b48:	098f07b5 098f07a9 098f07b9 09cf0681     ................
   15b58:	098f0715 09cf06a1 09cf0739 0acf001d     ........9.......
   15b68:	0a0f02dd 09cf004d 098f0775 09cf060d     ....M...u.......
   15b78:	010002f9 0a0f05a9 0a0f0699 0a0f0171     ............q...
   15b88:	0a0f0771 0a0f06f5 0a0f0181 0a0f07f1     q...............
   15b98:	0a0f06d5 098f0419 098f0635 098f044d     ........5...M...
   15ba8:	0a4f07b5 098f04b5 098f0479 098f04e5     ..O.....y.......
   15bb8:	098f0235 098f04f5 098f0595 098f061d     5...............
   15bc8:	098f05f1 098f0535 098f0579 098f05ad     ....5...y.......
   15bd8:	098f06b9 098f06d9 0a8f0025 0a0f0199     ........%.......
   15be8:	09cf012d 0a8f00a5 09cf0371 0a8f04e1     -.......q.......
   15bf8:	0a8f0365 09cf06d5 0a8f01b5 09cf04fd     e...............
   15c08:	0a8f05f5 0a8f0045 09cf03b1 09cf0109     ....E...........
   15c18:	09cf0009 09cf0355 0a0f03e9 0a0f0489     ....U...........
   15c28:	09cf0079 09cf009d 09cf00d9 09cf0701     y...............
   15c38:	09cf0261 09cf003d 09cf06a1 09cf00b9     a...=...........
   15c48:	09cf00ad 09cf010d 098f01c5 0a8f0641     ............A...
   15c58:	098f07f5 09cf005d 098f016d 09cf02c1     ....]...m.......
   15c68:	010003fd 09cf04e5 098f0131 010003f5     ........1.......
   15c78:	01000539 09cf04a1 06cf0021 07cf01e1     9.......!.......
   15c88:	0bcf028d 01000785 00800099 070f023d     ............=...
   15c98:	070f02b9 070f02fd 01400199 078f0695     ..........@.....
   15ca8:	014001cd 078f0339 0d4f053d 07cf01f5     ..@.9...=.O.....
   15cb8:	0f4f0359 080f0431 080f0475 0140035d     Y.O.1...u...].@.
   15cc8:	0140045d 084f03e5 014004a9 080f06e1     ].@...O...@.....
   15cd8:	01400599 01400625 01400655 014006a5     ..@.%.@.U.@...@.
   15ce8:	01400771 0140079d 014007c9 01800039     q.@...@...@.9...
   15cf8:	0f4f0475 0f4f057d 0f4f0591 0d0f00f1     u.O.}.O...O.....
   15d08:	074f06b1 0acf00cd 0a8f0701 0a8f0705     ..O.............
   15d18:	0a8f06f1 0a8f0705 0a8f077d 0a8f06dd     ........}.......
   15d28:	0a8f0769 0a8f077d 0a8f0701 0acf05a1     i...}...........
   15d38:	0acf058d 0acf05a1 0acf060d 0acf0579     ............y...
   15d48:	0acf05f9 0acf05a1 0acf0541 0acf062d     ........A...-...
   15d58:	0acf0639 0acf062d 0acf0609 0acf060d     9...-...........
   15d68:	0acf0631 014007e1 06cf07b1 074f0635     1.....@.....5.O.
   15d78:	01800061 01800075 018000a9 06cf0751     a...u.......Q...
   15d88:	06cf0239 06cf079d 018000f9 01800479     9...........y...
   15d98:	07cf0559 078f069d 080f0021 06cf0459     Y.......!...Y...
   15da8:	070f0241 078f063d 01800685 01800695     A...=...........
   15db8:	018006a5 018006b5 018006c5 018006d5     ................
   15dc8:	018006e9 01800735 074f06f9 068f0411     ....5.....O.....
   15dd8:	068f0435 068f039d 074f072d 0f4f0505     5.......-.O...O.
   15de8:	0acf07f5 0f4f035d 0d8f010d 0d0f0151     ....].O.....Q...
   15df8:	01c003c9 0f4f0515 0b4f01c1 0b4f00b9     ......O...O...O.
   15e08:	0b4f013d 0b0f0759 0b0f0789 0b4f0015     =.O.Y.........O.
   15e18:	0f4f0285 06cf0491 020001c9 020001d5     ..O.............
   15e28:	020001e1 020001ed 020001f9 02000205     ................
   15e38:	0200020d 02000215 02000265 02000271     ........e...q...
   15e48:	02000279 02000281 02000289 02000291     y...............
   15e58:	02000299 07cf034d 078f0649 07cf016d     ....M...I...m...
   15e68:	0b8f0051 0b4f0771 0b8f00fd 0b8f0165     Q...q.O.....e...
   15e78:	0b4f0405 0b4f02e5 0b4f0575 0b4f0621     ..O...O.u.O.!.O.
   15e88:	0b8f019d 0b4f0519 0b4f01a1 0b4f0221     ......O...O.!.O.
   15e98:	0b4f06bd 0b4f0401 0b4f03c9 0b8f0099     ..O...O...O.....
   15ea8:	078f0465 07cf0509 07cf0531 06cf021d     e.......1.......
   15eb8:	078f038d 06cf07e9 078f0269 06cf066d     ........i...m...
   15ec8:	078f050d 0f8f01c1 0f8f01c9 0f8f01cd     ................
   15ed8:	0f8f01d5 0f8f01d9 0f8f01e1 0f8f0265     ............e...
   15ee8:	0f8f0289 06cf0705 06cf0669 070f0259     ........i...Y...
   15ef8:	070f0271 070f00dd 074f0409 06cf06bd     q.........O.....
   15f08:	0ccf0509 0ccf0515 020005f5 0ccf051d     ................
   15f18:	02000671 0ccf065d 0ecf061d 0f0f026d     q...].......m...
   15f28:	068f0561 06cf00a5 06cf022d 06cf0271     a.......-...q...
   15f38:	024006f1 0f4f0125 0f4f010d 02800019     ..@.%.O...O.....
   15f48:	028000ed 0f8f0309 078f07d5 078f04cd     ................
   15f58:	084f07b9 098f019d 09cf0179 010002fd     ..O.....y.......
   15f68:	06cf0769 06cf07e5 070f0029 078f03c5     i.......).......
   15f78:	078f0731 080f0171 080f01a5 074f0435     1...q.......5.O.
   15f88:	014005c5 01400609 06cf01a9 06cf058d     ..@...@.........
   15f98:	01400641 01400655 01400689 06cf001d     A.@.U.@...@.....
   15fa8:	06cf0581 01800261 078f0489 078f0595     ....a...........
   15fb8:	070f0031 078f042d 018004f1 0180053d     1...-.......=...
   15fc8:	074f0501 068f0219 068f023d 068f01a5     ..O.....=.......
   15fd8:	078f071d 018005ed 078f0301 01c0027d     ............}...
   15fe8:	07cf01c1 078f04bd 078f07e1 078f076d     ............m...
   15ff8:	07cf03bd 07cf03e5 06cf00d1 078f0241     ............A...
   16008:	06cf069d 078f011d 06cf0521 078f04fd     ........!.......
   16018:	078f03a9 078f03b9 06cf05d1 06cf0535     ............5...
   16028:	070f0125 070f013d 078f0449 06cf058d     %...=...I.......
   16038:	020003ad 06cf0121 024005bd 074f03fd     ....!.....@...O.
   16048:	740a26ab 8098007f 78e07ee0 7ce026ab     .&.t.....~.x.&.|
   16058:	00400000 003f246f 7ce026ab 004f0000     ..@.o$?..&.|..O.
   16068:	003f246f 20aac0e1 70d30010 39020001     o$?.... ...p...9
   16078:	ffc207e8 007f40c3 20ab8c58 c0c10010     .....@..X.. ....
   16088:	0001382f 003f246f 78e078e0 007f40c3     /8..o$?..x.x.@..
   16098:	206b8000 702c0940 706c704c 70ac708c     ..k @.,pLplp.p.p
   160a8:	70ec70cc 702d700d 706d704d 70ad708d     .p.p.p-pMpmp.p.p
   160b8:	70ed70cd 702e700e 706e704e 70ae708e     .p.p.p.pNpnp.p.p
   160c8:	70ee70ce 702f700f 254a700c 264a3000     .p.p.p/p.pJ%.0J&
   160d8:	44db3000 11f00080 008042db 220a12f0     .0.D.....B....."
   160e8:	007f8f80 20e28c10 706f0082 0f802022     ....... ..op" ..
   160f8:	a3ac007f 048f065d 007fc1a4 0000013d     ....].......=...
   16108:	4508c2e8 85438102 0f833000 ccd03d4c     ...E..C..0..L=..
   16118:	0f803200 33333f73 00cc3001 81c0a583     .2..s?33.0......
   16128:	85028541 a5c18161 330281e1 36020003     A...a......3...6
   16138:	34011082 c47a1f80 41c30000 f17842cb     ...4..z....A.Bx.
   16148:	bbbfb8bf a5e2babf 056f0e86 00d03201     ..........o..2..
   16158:	8de0f643 70edf008 702c4d28 0c32764c     C......p(M,pLv2.
   16168:	ade0066f 10b00f2d 0f4b70cd 8d111051     o...-....pK.Q...
   16178:	41f441c3 68e1bb5d 0e564002 adf1056f     .A.A]..h.@V.o...
   16188:	000c0064 71048d14 1d12ad14 f03c1003     d......q......<.
   16198:	71048d13 780fad13 02f40883 8d154002     ...q...x.....@..
   161a8:	01b4088f 4d28adc0 0be6702c 764c066f     ......(M,p..o.Lv
   161b8:	0f85f042 8d101011 41f441c3 68e1bb5d     B........A.A]..h
   161c8:	e0b278ef 1cad27ca 0e064002 adf0056f     .x...'...@..o...
   161d8:	002c0064 083978ef 70cd0cb1 10431d00     d.,..x9....p..C.
   161e8:	f02aadd0 71048d12 780fad12 01940819     ..*....q...x....
   161f8:	081d8d14 70cd02f4 10831d00 add4add1     .......p........
   16208:	f01aadd2 e0e578ef 70cdf796 702c4d28     .....x.....p(M,p
   16218:	0b7e764c adc0066f 41c3f00e bb5d41f4     Lv~.o......A.A].
   16228:	054f0dae 8d15f6c8 ad157104 add3f004     ..O......q......
   16238:	de81add5 c6c840c1 6844706c a860702c     .....@..lpDh,p`.
   16248:	09017124 1a0400b2 b06a00d0 7fe0a064     $q........j.d...
   16258:	78e0a063 000001e9 4608c2f4 45288102     c..x.......F..(E
   16268:	30008624 3dcc0f82 3100ccd0 3f660f80     $..0...=...1..f?
   16278:	30016666 1e100094 85001500 1008160c     ff.0............
   16288:	866185e2 85218642 8581a601 00813102     ..a.B.!......1..
   16298:	8582a682 00c03002 8e80a683 10121504     .....0..........
   162a8:	10131500 b8bfb9bf 00413001 12003702     .........0A..7..
   162b8:	3101b8bf 22500000 235027d5 409127d6     ...1..P".'P#.'.@
   162c8:	ec06702e 430e41c3 f005c2a1 420e41c3     .p...A.C.....A.B
   162d8:	0cfec2a1 3602054f b8bf2540 434b41c3     ....O..6@%...AKC
   162e8:	0ceef178 21ca056f 74ed2069 8502f69b     x...o..!i .t....
   162f8:	0cde70ad 41a1056f 40c2f695 056f0cd2     .p..o..A...@..o.
   16308:	f6ca41a2 0cca4062 41a1056f f64b72ed     .A..b@..o..A.rK.
   16318:	f00973ed 0cba4042 41a1056f f64370ed     .s..B@..o..A.pC.
   16328:	3c0071ed 447a2f80 41c30000 00003f80     .q.<./zD...A.?..
   16338:	0c9e4310 4230056f 70adf60a 0c924062     .C..o.0B...pb@..
   16348:	41a1056f 24c0220a 42b1f642 08316f0a     o..A.".$B..B.o1.
   16358:	70ad00b5 3f7a41c3 0c76e148 4042056f     ...p.Az?H.v.o.B@
   16368:	002a004a 41c34042 147b3eae 054f0c62     J.*.B@.A.>{.b.O.
   16378:	41c3f6dd f178434b f01540a2 41c3ef98     ...AKCx..@.....A
   16388:	e1483f7a 056f0c4a f6514042 3eae41c3     z?H.J.o.B@Q..A.>
   16398:	0c3e147b 4042056f 41c3f6c9 f178434b     {.>.o.B@...AKCx.
   163a8:	0c2e40c2 71ad054f 70adf682 2051082b     .@..O..q...p+.Q 
   163b8:	71048e14 780fae14 02f40843 8e16706c     ...q...xC...lp..
   163c8:	02f40869 ae604e2c ae76ae77 ae74ae75     i...,N`.w.v.u.t.
   163d8:	10431e18 0863f031 092f2011 ed042010     ..C.1.c.. /.. ..
   163e8:	e8138e18 71048e15 780dae15 0412084b     .......q...xK...
   163f8:	13c31e15 10431e17 093ff01f 8e162010     ......C...?.. ..
   16408:	ae167104 8e15f019 262f7704 002af005     .q.......w/&..*.
   16418:	ae150023 10031e15 e80f8e17 10031e17     #...............
   16428:	1e00ed0b f0091043 754c702c 066f0962     ....C...,pLub.o.
   16438:	d881ae60 700ced82 78e0c6d4 6844706c     `......p...xlpDh
   16448:	a860702c 09017124 1a0400f2 a87800d0     ,p`.$q........x.
   16458:	7fe0a065 78e0a064 00000341 c1afc3f0     e...d..xA.......
   16468:	45084130 224a48dc 244a0000 c08b7100     0A.E.HJ"..J$.q..
   16478:	018020a8 04031104 00d01804 244ac487     . ............J$
   16488:	700c7100 024020a8 10012515 2415812f     .q.p. @..%../..$
   16498:	71041003 c384a320 10802515 23158002     ...q ....%.....#
   164a8:	71440081 80f20af5 141ca100 70ed3010     ..Dq.........0.p
   164b8:	a7fe2050 de7ff21e 4002be17 056f0b12     P .........@..o.
   164c8:	0380210a 244af216 c08b7100 01c020a8     .!....J$.q... ..
   164d8:	39008020 18040401 c0880050 8040702c      ..9....P...,p@.
   164e8:	3a007124 09fb0402 180480f2 c6470090     $q.:..........G.
   164f8:	c204c105 c142c006 c043c241 c181c380     ......B.A.C.....
   16508:	8041c080 0fff71e5 180490f2 708d0090     ..A..q.........p
   16518:	1108c443 244a200b c28b7100 02c020a8     C.... J$.q... ..
   16528:	04001204 330083c0 36011000 1b041000     .......3...6....
   16538:	c3880010 1304c281 c000040e 300082e0     ...............0
   16548:	37020380 71851000 90f20cef 00101a04     ...7...q........
   16558:	81608141 c0008122 c344c245 a505c146     A.`."...E.D.F...
   16568:	12022540 c184700c 04031104 08fd7104     @%...p.......q..
   16578:	1a0480f2 8d1800d0 ad386821 40308de4     ........!h8...0@
   16588:	8d19ef04 ad197104 850585c7 421041c1     .....q.......A.B
   16598:	056f0a3e 004a41d1 4042002c 30018509     >.o..AJ.,.B@...0
   165a8:	43fe0f81 4042edd6 056f0a26 21ca4130     ...C..B@&.o.0A.!
   165b8:	1d1c248b 15281440 70cd1080 1554e8b8     .$..@.(....p..T.
   165c8:	212f1080 08130407 0fc50044 15551010     ../!....D.....U.
   165d8:	0abd1082 1d280045 ad181043 09f2f085     ....E.(.C.......
   165e8:	8528056f 002a0076 0407212f 30018509     o.(.v.*./!.....0
   165f8:	c3fe0f8e 4042edd6 056f09d6 26ca41c1     ......B@..o..A.&
   16608:	a5c81489 10801528 0031088d 155470cd     ....(.....1..pT.
   16618:	212f1080 08110407 ef3a0044 10821555     ../!....D.:.U...
   16628:	00450a6d 10831d28 f05fad18 00b108bb     m.E.(....._.....
   16638:	0407222f 10811554 008509af 10801556     /"..T.......V...
   16648:	780f6038 008208a3 10801529 1d297104     8`.x....)....q).
   16658:	1d281002 ad381043 1554f047 080d1080     ..(.C.8.G.T.....
   16668:	15280045 ea331082 10821556 780f6058     E.(...3.V...X`.x
   16678:	00607110 700c002c 10811529 0947e923     .q`.,..p)...#.G.
   16688:	ef2a0115 ad19ad04 f01f72cd 13821d28     ..*......r..(...
   16698:	f02badd8 00710853 0407222f 10811554     ..+.S.q./"..T...
   166a8:	00850947 10801556 780f6038 0082083b     G...V...8`.x;...
   166b8:	10801529 1d297104 1d281002 ad381083     )....q)...(...8.
   166c8:	73cdf013 70edad04 70edf00a ade4ad18     ...s...p...p....
   166d8:	f00b70cd ade471ed 71cdad19 10021d29     .p...q.....q)...
   166e8:	1d28ad18 85091002 2f813200 d7003c23     ..(......2./#<..
   166f8:	0f803000 70a43f7d 00133101 24c03102     .0..}?.p.1...1.$
   16708:	3f7542d3 3000c28f 40d30480 bb5d42f4     .Bu?...0...@.B].
   16718:	20003301 24013301 41304410 056f08b2     .3. .3.$.D0A..o.
   16728:	14c01d24 250921ca 14401d1c 204f8508     $....!.%..@...O 
   16738:	330227d0 30002000 33010480 33022401     .'.3. .0...3.$.3
   16748:	41102000 056f088a 20ca4030 1d20244b     . .A..o.0@. K$ .
   16758:	ef8c1400 10811557 09118d19 700c0025     ....W.......%..p
   16768:	ad19ad04 10021d28 714c702c ad38ee08     ....(...,pLq..8.
   16778:	10b10e0d 10421d28 704cd981 208c8500     ....(.B...Lp... 
   16788:	20b98f83 763c0f83 80be2005 00be208a     ... ..<v. ... ..
   16798:	780f70dd 78e0c7d0 2040706c 702c0202     .p.x...xlp@ ..,p
   167a8:	a864a060 09017124 1a0400f2 41c300d0     `.d.$q.........A
   167b8:	0000447a a878a065 a027a879 44cbb99f     zD..e.x.y.'....D
   167c8:	de78007f 244aa028 20407100 41810b02     ..x.(.J$.q@ ...A
   167d8:	00c01824 00c21829 00c21828 018020a8     $...)...(.... ..
   167e8:	04031104 00d01a04 0f032040 7100244a     ........@ ..J$.q
   167f8:	14012440 018020a8 04021104 00901b04     @$... ..........
   16808:	0406218a 0044184c 184ed93c 18500505     .!..L.D.<.N...P.
   16818:	218a0044 18520d07 d9640044 00421857     D..!..R.D.d.W.B.
   16828:	1856d950 18550303 7fe00103 00421854     P.V...U.....T.B.
   16838:	4608c2ec 45cb70ed 1b440080 008041d3     ...F.p.E..D..A..
   16848:	262f21a4 f212f048 20401900 7440244a     .!/&H.....@ J$@t
   16858:	0000214a 01c020a8 25147830 71241000     J!... ..0x.%..$q
   16868:	78e0b0e0 000004af e0a19e01 f686700c     ...x.........p..
   16878:	08fa9d22 710c0f6f 9e01b502 700ce0a7     "...o..q.......p
   16888:	9d23f685 0f6f08e6 b503710c e0ad9e01     ..#...o..q......
   16898:	f686700c 08d69d24 710c0f6f 9e02b504     .p..$...o..q....
   168a8:	700ce0a1 9d25f685 0f6f08c2 b505710c     ...p..%...o..q..
   168b8:	700e9e03 700ce0a1 9d26f685 0f6f08ae     ...p...p..&...o.
   168c8:	b506710c 08119e03 710c09f2 0f6f089e     .q.........q..o.
   168d8:	40109d27 14041d0e 704e9e04 700ce0ad     '..@......Np...p
   168e8:	9d28f685 0f6f0886 b508710c e88d9600     ..(...o..q......
   168f8:	e88b9601 e8899602 e8879603 086e9d09     ..............n.
   16908:	712c0f6f 1d124210 950a1484 b50a781b     o.,q.B.......x..
   16918:	090b9e23 e00809d2 952bb50a b52b793b     #.........+.;y+.
   16928:	0a0b9e44 722409d2 9d4cb52b e290700e     D.....$r+.L..p..
   16938:	0052706c 704c002b 262f706c f20ef008     lpR.+.Lplp/&....
   16948:	7a70706c 00432044 0f802004 fffe0000     lppzD C.. ......
   16958:	202f635b f5f78002 262f704c f20ef048     [c/ ....Lp/&H...
   16968:	7850704c 00422144 2104621a 00000f80     LpPxD!B..b.!....
   16978:	212ffffe f5f78002 23d20a0b 785d7a50     ../!.......#Pz]x
   16988:	9500621a 035ee087 2025000d f0090000     .b....^...% ....
   16998:	f013f00d f02ff020 f046f03b 9e00f051     .... ./.;.F.Q...
   169a8:	087208b9 b520712c 9e00f05e 031308bd     ..r.,q .^.......
   169b8:	00200227 9e00b5e0 085208cd 10451d00     '. .......R...E.
   169c8:	0408202f 724c722c 0f2f09a6 02754010     / ..,rLr../..@u.
   169d8:	95200020 e0a69e01 00290110 9e05726c      . .......).lr..
   169e8:	00fee0ac 762c002c 02d5b520 1d020020     ....,.,v ... ...
   169f8:	9e0010c5 085208a1 10451d00 0408202f     ......R...E./ ..
   16a08:	724c742c 0f2f096a 95204010 9e00f04b     ,tLrj./..@ .K...
   16a18:	09d208a1 08df9d0e d90707b3 00200211     .............. .
   16a28:	10451d00 0f469d30 710c0f2f b5ecb510     ..E.0.F./..q....
   16a38:	0c919e80 025d1692 1d000020 9e051045     ......]. ...E...
   16a48:	09f20893 762c700c 1d00714c 09221185     .....p,vLq....".
   16a58:	1d020f2f f0be1145 08a19e05 762c0b72     /...E.......r.,v
   16a68:	b5e1b520 00000275 e0a79e05 002b0276      ...u.......v.+.
   16a78:	762c700c 1d00714c 08f61185 1d020f2f     .p,vLq....../...
   16a88:	f0ab1045 08f39e05 762c0072 1d02b520     E.......r.,v ...
   16a98:	f0d81085 08739e05 762c09f2 1d02b520     ......s...,v ...
   16aa8:	714c1105 0f2f08ca 023b4002 b5ed0020     ..Lq../..@;. ...
   16ab8:	087d9e05 762c0b72 1d02b520 f0bf1145     ..}.r.,v ...E...
   16ac8:	0b7b9e64 952109f2 f4e37534 11451d00     d.{...!.4u....E.
   16ad8:	9e24f0e0 08520991 11451d00 9e02f07d     ..$...R...E.}...
   16ae8:	0202e0a0 706c002a 732c700c b560724c     ....*.lp.p,sLr`.
   16af8:	b520f0e3 f0a3b5ef 089d9d02 722c00f2     .. ...........,r
   16b08:	4030b520 7850f0ea 03b4087d 08797870      .0@..Px}...pxy.
   16b18:	9d0d0095 0070e0e3 204a0029 e08e2380     ......p.).J .#..
   16b28:	ffe906dc 11451d00 f16a4010 08779d04     ......E..@j...w.
   16b38:	1d000152 740e1085 1602f07a 21781148     R......tz...H.x!
   16b48:	207f008b 220b1802 f43482c0 0a659d42     ... ..."..4.B.e.
   16b58:	9d4500d3 00d20a9d 7234b9a0 1d00f499     ..E.......4r....
   16b68:	f09810c5 60389e00 00f3084f 752c700c     ......8`O....p,u
   16b78:	b5e0724c 9d05f02b 00f20867 1d007870     Lr..+...g...px..
   16b88:	f12010c5 e08a9d03 204af69a 1d002240     .. .......J @"..
   16b98:	f1361085 08719d05 732c00f2 720eb520     ..6...q...,s ..r
   16ba8:	9e02f09c 09f20875 1d007870 f04010c5     ....u...px....@.
   16bb8:	10851d00 9d0ff06e 8d42208c 002b0126     ....n.... B.&.+.
   16bc8:	752c700c 1d00724c 0fa61045 b5ee0ecf     .p,uLr..E.......
   16bd8:	71149500 700cf287 724c712c 086bf081     ...q...p,qLr..k.
   16be8:	1d0002d4 9d0d1105 2049b5ed f0380250     ..........I P.8.
   16bf8:	0a719d46 639b00f2 01110997 11051d00     F.q....c........
   16c08:	f048b5ed 08bd7870 742c0334 9d0db520     ..H.px..4.,t ...
   16c18:	2049b5ed f0620250 02d408cb 08c79d0e     ..I P.b.........
   16c28:	204a02b3 1d002240 b5ed1105 724c752c     ..J @"......,uLr
   16c38:	0eef0f3e b5ee4002 e1879520 006121ca     >....@.. ....!a.
   16c48:	4002714c 9e04f04d 09d30813 9e029e41     Lq.@M.......A...
   16c58:	60589e23 088f6038 b5e00653 ffcf0565     #.X`8`..S...e...
   16c68:	16069e42 7301114b 627a9ec5 108b2300     B...K..s..zb.#..
   16c78:	0e1f7661 e90d14d2 0132086b 0ef2700c     av......k.2..p..
   16c88:	724c0eef 08919501 b5ee0151 b5e0f047     ..Lr....Q...G...
   16c98:	762c700c 0eda724c b5f00eef 95009521     .p,vLr......!...
   16ca8:	00400843 01510909 f005b5ee 01110907     C.@...Q.........
   16cb8:	700cb5ed 0eba724c 95200ecf f010700c     ...pLr.... ..p..
   16cc8:	080d7850 9d080315 02d2081b b520752c     Px..........,u .
   16cd8:	b5ee9d0e 03502049 0408202f 0e92714c     ....I P./ ..Lq..
   16ce8:	40260ecf 68419d2d 0c82710c 19000f2f     ..&@-.Ah.q../...
   16cf8:	b50d2080 0c769d2e 710c0f2f 9d2fb50e     . ....v./..q../.
   16d08:	0f2f0c6a b50f710c 0c629d2c 710c0f2f     j./..q..,.b./..q
   16d18:	c6ccb50c 01110807 b5e1b5ed 78e0f1ba     ...............x
   16d28:	9045c2ea 43484728 8004228c 9024f785     ..E.(GHC."....$.
   16d38:	8fc3218c 8040f713 0a1b706c dd3f02f2     .!....@.lp....?.
   16d48:	dd359024 f787e1e3 e0f99006 002600a0     $.5...........&.
   16d58:	702cdd23 70cd704c 9063f0ac 8550238c     #.,pLp.p..c..#P.
   16d68:	000d004a e2e49046 002d00a0 dd25de08     J...F.....-...%.
   16d78:	85c2218c 8080f799 9e02248c 002900fa     .!.......$....).
   16d88:	90a2e2c8 9b08258c 002d0134 e3e240b1     .....%..4.-..@..
   16d98:	002d01b2 a881208c 002d0256 0282e3b9     ..-.. ..V.-.....
   16da8:	dd0d0026 0305de2d 80800000 9e97248c     &...-........$..
   16db8:	0029007c 712c90a2 1f850d8b 10240000     |.)...,q......$.
   16dc8:	73cd9006 00d2e0c2 da37002d 000073d3     ...s....-.7..s..
   16dd8:	012e0d7c da36002d 258cda0b 01989419     |...-.6....%....
   16de8:	72cd0026 025ddb0c 75cd0020 09b30a51     &..r..]. ..uQ...
   16df8:	208cde2c 007c8c82 dd28002d 025ce28f     ,.. ..|.-.(...\.
   16e08:	de22002b f037dd17 76cd8020 e18ddd37     +."...7. ..v7...
   16e18:	218cf68c 008a8b02 de390029 72ad9002     ...!....).9....r
   16e28:	8fc3208c de26f702 00000281 1f850d3d     . ....&.....=...
   16e38:	13bd0000 da35726c f04070ad de2a75ad     ....lr5..p@..u*.
   16e48:	da3bf019 1f850d71 285d0000 1f850db9     ..;.q.....](....
   16e58:	13ec0000 9a15238c 0026014c db3473cd     .....#..L.&..s4.
   16e68:	70adda07 f026702c 736cd93c f17470ad     ...p,p&.<.ls.pt.
   16e78:	023bdd13 00980000 de0a002d 72ad756c     ..;.....-...lu.r
   16e88:	1f840bbd 09fe0000 202f9022 08b102c2     ........"./ ....
   16e98:	db270045 70adf054 702c716c 238cf00a     E.'.T..plq,p...#
   16ea8:	008a8689 de2f0026 706c70ad 764c702c     ....&./..plp,pLv
   16eb8:	000001ff 716c70ad f14f722c 72adde30     .....plq,rO.0..r
   16ec8:	1f840b7b 0c3c0000 052f0b1a 43c34061     {.....<.../.a@.C
   16ed8:	80004046 04ef0b16 2840704c 41102182     F@......Lp@(.!.A
   16ee8:	0b024040 4030052f 43204200 0c8e4022     @@../.0@.B C"@..
   16ef8:	4102056f 002c0046 de0adb29 70adf020     o..AF.,.)... ..p
   16f08:	f0f6766c db3b70ad f127724c 0bb9716c     lv...p;.Lr'.lq..
   16f18:	00001f85 de1f088e 9b43248c 002b0124     .........$C.$.+.
   16f28:	de16724c 702c71ad 9002f0c3 80ce208c     Lr...q,p..... ..
   16f38:	002600b2 de0eda2d 706cf057 724c702c     ..&.-...W.lp,pLr
   16f48:	208cf0b7 00aea703 de0d002d 015ce49c     ... ....-.....\.
   16f58:	dd27002b e2c7dd10 218cf789 014a8307     +.'........!..J.
   16f68:	de11002d 208cde14 0140a002 de1f0005     -...... ..@.....
   16f78:	f09cdd0a 0d75088d 9243248c 002900a8     ......u..$C...).
   16f88:	02c2202f 72c1263c 09fd0000 0340203c     / ..<&.r....< @.
   16f98:	f471790b 0ddfde2d 00001f85 71ad0c3c     .yq.-.......<..q
   16fa8:	f085db0b e0cc9006 002d0068 0b9bda35     ........h.-.5...
   16fb8:	00000f85 248c1650 00c2908b da0e002a     ....P..$....*...
   16fc8:	f095db2f 9e44248c 0029004c 9002de09     /....$D.L.).....
   16fd8:	208cda26 f7898fcd 71adde2a da08702c     &.. ....*..q,p..
   16fe8:	de2af067 70adda11 702c706c 74adf061     g.*....plp,pa..t
   16ff8:	238cf006 00588b02 72ad0026 f056de34     ...#..X.&..r4.V.
   17008:	9d43248c 002a005c 71adde31 f150726c     .$C.\.*.1..qlrP.
   17018:	f06ddb08 766c71ad da09702c de10f049     ..m..qlv,p..I...
   17028:	f044dd1c 9fc9248c 0009005c 1f850d8f     ..D..$..\.......
   17038:	09f80000 000073d3 00a40932 db1d0026     .....s..2...&...
   17048:	702c72ad db0cf035 f051da33 0040e2c3     .r,p5...3.Q...@.
   17058:	de070026 706cdd07 704c702c f029de13     &.....lp,pLp..).
   17068:	9f85248c db07f65b 71adda2e 73cd702c     .$..[......q,p.s
   17078:	de0af01f 71addb29 0d49f019 db1510e5     ....)..q..I.....
   17088:	f035da27 da1edb12 f03272ad 8c5f218c     '.5......r2..!_.
   17098:	75adf75c 714cde27 248cf1a8 f6599a49     \..u'.Lq...$I.Y.
   170a8:	da0fdb1f dd0df023 702c706c b7a0704c     ....#...lp,pLp..
   170b8:	b722b761 b7c4b743 05a9c6ca db2dffef     a.".C.........-.
   170c8:	db28da13 f01570ad dd08da1e 0b1bf18e     ..(..p..........
   170d8:	00000f85 db140ebd f009da26 da3371cd     ........&....q3.
   170e8:	ffef0583 da13756c 70addb28 046b702c     ....lu..(..p,pk.
   170f8:	78e0ffcf 46cbc3e4 3b380080 10031e01     ...x...F..8;....
   17108:	0c9d8e80 c1a41030 01150b95 00100a91     ....0...........
   17118:	43c38040 cccd3dcc 00c23200 008045cb     @..C.=...2...E..
   17128:	a5403ae8 32008041 a54100c2 734c8002     .:@.A..2..A...Ls
   17138:	00c03000 8100a502 3d7943c3 3000db23     .0.......Cy=#..0
   17148:	b8bf00c0 8101c040 00c03000 c041b8bf     ....@....0....A.
   17158:	c0808182 10c33400 bbbf702c 0a6f0ce2     .....4..,p....o.
   17168:	0842c342 24400020 140f33c1 4dbc3082     B.B. .@$.3...0.M
   17178:	002009aa 42c340a1 12a10080 ae018a20     .. ..@.B.... ...
   17188:	ae224d1c a52b8020 a52c8524 a52d8525     .M". .+.$.,.%.-.
   17198:	8a218566 08cea56e aa2c0aef c7c4700c     f.!.n.....,..p..
   171a8:	45cbc2e8 3ae40080 470885c0 1b0c2680     ...E...:...G.&..
   171b8:	40308602 04ef0e1a f65541e1 0e128600     ..0@.....AU.....
   171c8:	41e104ef 8601f652 04ef0e06 004241e1     ...AR........AB.
   171d8:	1800000a 85002103 020d2080 a5149000     .....!... ......
   171e8:	1800f00e f0042043 20831800 68298513     ....C ..... ..)h
   171f8:	8514a533 080f7704 a5140032 21031800     3....w..2......!
   17208:	090bf005 18000012 700c20c3 1800c6c8     ......... .p....
   17218:	850020c3 018d2080 f1ec9020 008041c3     . ... .. ....A..
   17228:	892012a1 7fe0a820 78e0700c 008041c3     .. . ....p.x.A..
   17238:	892012ac 7fe0a820 78e0700c 008041c3     .. . ....p.x.A..
   17248:	81403ea8 a0404300 a3018101 700c8122     .>@..C@....."..p
   17258:	a3227fe0 c1a6c3e8 008040d3 db7f3b3c     .."......@..<;..
   17268:	20001800 40c370ad 3eec0080 008047cb     ... .p.@...>.G..
   17278:	b0a03e98 a0a2a8ac 008046cb b0a21288     .>.......F......
   17288:	702cb0a3 6f04da18 afa0bb17 a6a1a76b     ..,p...o....k...
   17298:	05ef0afe 710ca76c ae10ae0c 000040c3     ....l..q.....@..
   172a8:	a6057530 b6a4700c 13441e0a 13051e0e     0u...p....D.....
   172b8:	2715790f 71041041 790fa1b1 80f409f5     .y.'A..q...y....
   172c8:	7280244a 028020a8 261578af 00807000     J$.r. ...x.&.p..
   172d8:	71a53e70 00011800 0aaf0f8a 700c4f3c     p>.q........<O.p
   172e8:	a70fa70e d83fa710 10008751 b818200b     ......?.Q.... ..
   172f8:	87738792 c041c040 3f3440c3 c042fdf4     ..s.@.A..@4?..B.
   17308:	c180c243 1ec22355 21002040 0aeec444     C...U#..@ .!D...
   17318:	c3450020 c7c8700c 8080c2e2 008043c3      .E..p.......C..
   17328:	a3803e9c a3818081 a3028002 a3068100     .>..............
   17338:	a3078101 a3088102 008040c3 81831288     .........@......
   17348:	a3898830 0071090b 097aa858 45cb0000     0.....q.X.z....E
   17358:	3ef40080 e8048d02 0dcf0e62 e8048d01     ...>....b.......
   17368:	00000842 40c38d20 3b3c0080 01b00917     B... ..@..<;....
   17378:	091970ad 091d0090 08da0111 71ad00c0     .p.............q
   17388:	0eeaf00b f0090080 00800fa6 f00571ad     .............q..
   17398:	08f2e983 08b200c0 40a10000 78e0c6c2     ...........@...x
   173a8:	704cc0f1 008040c3 a8403ef4 8803a841     ..Lp.@...>@.A...
   173b8:	008041c3 a140128c 40c3e806 3b3c0080     .A....@....@..<;
   173c8:	00c00966 7fe0c0d1 78e0700c c1a6c3e8     f........p.x....
   173d8:	45cb8080 3ea80080 8061a580 008046cb     ...E...>..a..F..
   173e8:	a5613b3c c1808042 80e3a542 c4406e04     <;a.B...B....n@.
   173f8:	a5e7c341 0b524010 c2420e2f 0b5e4002     A....@R./.B..@^.
   17408:	41e10020 c2838600 0e812056 00c0204a      ..A....V ..J ..
   17418:	0403111c 08fd7104 1a0481b4 c18300d0     .....q..........
   17428:	0e2f0dfe 43c34002 3ef40080 e8888b00     ../..@.C...>....
   17438:	c101c200 a54ac002 a50ca52b 1b04700c     ......J.+....p..
   17448:	c7c80043 c1a1c3e8 008042c3 6a043b3c     C........B..<;.j
   17458:	0da2c180 82c00e2f 008045cb 8dfb1288     ..../....E......
   17468:	c000ef97 0b6a8623 401004ef 730cf643     ....#.j....@C..s
   17478:	8622f010 04ef0b5a f6444002 f00a720c     ..".Z....@D..r..
   17488:	0b4e8621 400204ef 710cf643 700cf002     !.N....@C..q...p
   17498:	09198d3c ad190071 ad1a8d2c 0815e90a     <...q...,.......
   174a8:	1d1c00d1 f00b1003 1d1aef07 f0071003     ................
   174b8:	10431d1c 1d1af003 700c10c3 78e0c7c8     ..C........p...x
   174c8:	c1a6c3e4 008045cb c1833b40 0e2f0a6a     .....E..@;..j./.
   174d8:	c18040a1 0e2f0a86 c00140a1 c302c100     .@..../..@......
   174e8:	00023000 00403100 00813001 00c03300     .0...1@..0...3..
   174f8:	800b3101 40c3f222 3e9c0080 8041c104     .1.."..@...>..A.
   17508:	8080c303 c60580a2 00413202 10c03402     .........2A..4..
   17518:	00413100 00003000 00413001 13803502     .1A..0...0A..5..
   17528:	00003000 00003101 02c03800 70013602     .0...1...8...6.p
   17538:	00003f80 f005b9bf 42c841c3 42c30000     .?.......A.B...B
   17548:	12a80080 a220700c 78e0c7c4 c1a1c3ea     .....p ....x....
   17558:	008045cb 8d101288 47cb712e 12a80080     .E.......q.G....
   17568:	8d1be808 10101700 d93fe819 f019b918     ..........?.....
   17578:	008046cb 41c33b3c 3e9c0080 c2806e04     .F..<;.A...>.n..
   17588:	0def0daa c1004030 20401830 0a428600     ....0@..0.@ ..B.
   17598:	800004ef f65870cd d97ff011 0a32b917     .....pX.......2.
   175a8:	400204ef f60371cd 41c370cd 00004396     ...@.q...p.A.C..
   175b8:	04ef0a1e 41d14002 710cf6c6 10051d0e     .....@.A...q....
   175c8:	f010af04 71049507 7810b507 700ce08d     .......q...x...p
   175d8:	1d0ef785 af041305 1f04f003 41d11043     ............C..A
   175e8:	14421d1b 78e0c7ca 008040c3 804012b0     ..B....x.@....@.
   175f8:	7fe0700c 78e0a140 c1a9c3e8 46484428     .p..@..x....(DHF
   17608:	489c4708 716c764c 0a6f0c96 27554081     .G.HLvlq..o..@U'
   17618:	764c1b41 0c8a766c 40c10a6f 764c4fcc     A.Lvlv..o..@.OLv
   17628:	0c7e766c 40c10a6f 030c208a 60f870ad     lv~.o..@. ...p.`
   17638:	714c732c 0a6f0cca 208a43a1 60f8060c     ,sLq..o..C. ...`
   17648:	714c732c 0a6f0cba 208a43a1 60f80b07     ,sLq..o..C. ...`
   17658:	764c762c 0a6f0caa 208a43a1 60f8010b     ,vLv..o..C. ...`
   17668:	764c732c 0c9a43a1 40100a6f 0beec080     ,sLv.C..o..@....
   17678:	732c0a6f c080738c 706c704c 76cc4580     o.,s.s..Lplp.E.v
   17688:	0a6f0c3a 736c4102 704cc080 45604460     :.o..Als..Lp`D`E
   17698:	0c2a76cc 41020a6f 714c762c 0d6a766c     .v*.o..A,vLqlvj.
   176a8:	40c10a6f 10181fc9 714c762c 0d5a736c     o..@....,vLqlsZ.
   176b8:	40c10a6f 10181fca 008041c3 08c212b0     o..@.....A......
   176c8:	40e10020 1b0c2780 1f00700c c7c81043      ..@.'...p..C...
   176d8:	4708c2e8 4448766c 0105208a 671a4030     ...GlvHD. ..0@.g
   176e8:	1b402755 0b264460 41810a6f 0507208a     U'@.`D&.o..A. ..
   176f8:	4f1c671d 766c714c 0a6f0ba6 208a41a1     .g.OLqlv..o..A. 
   17708:	671e010b 704c738c 4580706c 400276cc     ...g.sLplp.E.v.@
   17718:	0a6f0baa 208a41c1 671a060c 768c736c     ..o..A. ...gls.v
   17728:	40c171ac 0a6f0a72 41c341a1 12b00080     .q.@r.o..A.A....
   17738:	0020084e 700c40e1 78e0c6c8 0b422055     N. ..@.p...xU B.
   17748:	78c0244a 20a8e024 100401c0 1a040401     J$.x$.. ........
   17758:	7fe00050 78e0700c 0f823100 00003f00     P....p.x.1...?..
   17768:	a044a043 0f823100 fdf43f34 42c3a045     C.D..1..4?..E..B
   17778:	12b00080 7fe0700c 78e0a220 8044c2e2     .....p.. ..x..D.
   17788:	80858063 00823200 00c03300 00823001     c....2...3...0..
   17798:	13003400 00003201 04ef0cc2 a5004528     .4...2......(E..
   177a8:	c6c2700c c1a2c0f1 008044cb 145835e4     .p.......D...5X.
   177b8:	14541007 14501006 144c1005 84631004     ..T...P...L...c.
   177c8:	84218442 c0418480 09924081 1c000aaf     B.!...A..@......
   177d8:	c0a23041 7fe0c0d1 78e0700c 40c3c0f1     A0.......p.x...@
   177e8:	13640080 008041c3 49121bb4 05af0da2     ..d..A.....I....
   177f8:	0812702c 0de20000 c0d100c0 78e07ee0     ,p...........~.x
   17808:	c1a1c3e8 007f40c3 e833de10 007f46cb     .....@....3..F..
   17818:	0f7adc2c 40c103ef 8e03e8ac 00f4080f     ,.z....@........
   17828:	87a06ee4 120f2640 45cbf010 237c0060     .n..@&.....E`.|#
   17838:	00000019 4002c380 7d6041c1 6e034281     .......@.A`}.B.n
   17848:	0040206c e708671f 70d587c1 0021001a     l @..g.....p..!.
   17858:	27408780 f6301210 702c7ad3 05af0d32     ..@'..0..z,p2...
   17868:	470a4081 ec05f1f2 68e46f04 700cf1ee     .@.G.....o.h...p
   17878:	78e0c7c8 c1a5c3e4 70c11600 1fe40080     ...x.......p....
   17888:	0033093d c0804508 5aa4c680 34c02440     =.3..E.....Z@$.4
   17898:	14135aa3 382f3080 c0430003 0000204a     .Z...0/8..C.J ..
   178a8:	71048620 0f813900 ac123c20 80f208f5      ..q.9.. <......
   178b8:	10501e04 d8fa8548 5acdc180 08af0bea     ..P.H......Z....
   178c8:	c7c440a1 008040c3 18003f5c 00800f80     .@...@..\?......
   178d8:	68241414 1900e008 00800f80 18001540     ..$h........@...
   178e8:	00800f80 40c3166c 218c0080 0f801800     ....l..@...!....
   178f8:	17980080 008040c3 18002190 00800f80     .....@...!......
   17908:	40c318c4 21940080 0f801800 19f00080     ...@...!........
   17918:	70451e00 21880080 0e4f0089 c1a1c3e6     ..Ep...!..O.....
   17928:	008046cb 86401fb4 47084528 00600a7b     .F....@.(E.G{.`.
   17938:	30031c03 9002258c d912f403 258cf007     ...0.%.........%
   17948:	f4049fc3 f003d911 40e1d910 07af0dee     ...........@....
   17958:	30421c03 5aa2740c 9002258c dcb7f403     ..B0.t.Z.%......
   17968:	d940f00c 30c22440 40e1716c 14035abf     ..@.@$.0lq.@.Z..
   17978:	b8c33080 014c204f 2440d940 716c30c2     .0..O L.@.@$.0lq
   17988:	1c0340e1 5ac13302 5aa2710c 2440d96c     .@...3.Z.q.Zl.@$
   17998:	716c30c2 1c0340e1 5ac13003 9002258c     .0lq.@...0.Z.%..
   179a8:	710cf403 a6a05aa2 78e0c7c6 c1a1c3e6     ...q.Z.....x....
   179b8:	008045cb 85201268 70cd4708 702ce92e     .E..h. ..G.p..,p
   179c8:	30c22440 40e1716c de225abf 1403e8a6     @$.0lq.@.Z".....
   179d8:	de213080 0080206c 8403208c d9b6f41e     .0!.l ... ......
   179e8:	07af0d5a 730c40e1 70cd5aa2 2440d97f     Z....@.s.Z.p..@$
   179f8:	716c30c2 1c0340e1 5ac13382 5aa2710c     .0lq.@...3.Z.q.Z
   17a08:	07ef0bda 702c40e1 ffef0f16 702c40e1     .....@,p.....@,p
   17a18:	07ef0c42 a5c040e1 c7c640c1 c1a1c3f6     B....@...@......
   17a28:	d9b670ad 1c034310 0d123342 1c0007af     .p...C..B3......
   17a38:	47083344 5aa2d83c 0d02d911 406207af     D3.G<..Z......b@
   17a48:	d83c4608 d9085aa2 07ef0a72 40104062     .F<..Z..r...b@.@
   17a58:	09aed90c 406207ef 260066fe 712c1412     ......b@.f.&..,q
   17a68:	0015204e 214adf12 40d328c0 12680080     N ....J!.(.@..h.
   17a78:	21ab70cd 25400a61 d96d134c 30c22440     .p.!a.@%L.m.@$.0
   17a88:	4062716c 33021c03 d8325ac1 79ef5aa2     lqb@...3.Z2..Z.y
   17a98:	726cc280 47304062 25405abf 1400124c     ..lrb@0G.Z@%L...
   17aa8:	14013094 d96d30d6 30c22440 4062716c     .0...0m.@$.0lqb@
   17ab8:	33021c03 d8325ac1 c2805aa2 4062726c     ...3.Z2..Z..lrb@
   17ac8:	5abf41e2 1401c220 d86030c3 25610a71     .A.Z ....0`.q.a%
   17ad8:	24401800 22002e40 05012005 02002b40     ..@$@..". ..@+..
   17ae8:	78227845 07c12842 78276038 10b10d13     Ex"xB(..8`'x....
   17af8:	208c7810 f78c8a19 7ecfbe82 0811f008     .x. .......~....
   17b08:	00000f84 78cf0cce 034e200f 71a5710c     .......x. N..q.q
   17b18:	0d6772e5 20ab90f2 d9b60a61 07af0c1e     .rg.... a.......
   17b28:	d83c4062 0e195aa2 d861103e 091179cf     b@<..Z..>.a..y..
   17b38:	d862007e 00be0909 720cd864 78e0c7d6     ~.b.....d..r...x
   17b48:	c1a1c3e6 d9b670ad 0bf24708 1c0307af     .....p...G......
   17b58:	d8323342 71cd5aa2 40e1d915 07af0bde     B32..Z.q...@....
   17b68:	1a6126ab 5aa2d832 26ab750c 5aa21a61     .&a.2..Z.u.&a..Z
   17b78:	2440732c 716c30c2 5abf40e1 30801403     ,s@$.0lq.@.Z...0
   17b88:	03002044 0110080b 0de171a5 712c9152     D .......q..R.,q
   17b98:	07af0f76 d83240e1 71cd5aa2 26ab750c     v....@2..Z.q.u.&
   17ba8:	5aa21a61 30c12440 07af0e7e 140340e1     a..Z@$.0~....@..
   17bb8:	080d3080 71a50070 91520de5 0b7ed9b6     .0..p..q..R...~.
   17bc8:	40e107af 5aa2d832 30801403 7014d960     ...@2..Z...0`..p
   17bd8:	20ca720c d9230041 70401e00 12680080     .r. A.#...@p..h.
   17be8:	78e0c7c6 0f62c2e2 452807af 710ced03     ...x..b...(E...q
   17bf8:	700c5aa2 78e0c6c2 c1a1c3e4 88044508     .Z.p...x.....E..
   17c08:	2440702c 716c30c2 de225abf 1403e892     ,p@$.0lq.Z".....
   17c18:	de213080 0080206c 8403208c 0d92f40a     .0!.l ... ......
   17c28:	8d04ffef 700ce886 0020080e 70cd41a1     .......p.. ..A.p
   17c38:	c7c440c1 4628c2ec 05ef0bd2 0baa4508     .@....(F.....E..
   17c48:	401005ef d8114708 420241e1 42105ab1     ...@.G...A.B.Z.B
   17c58:	41e1d812 5ab14202 d8134110 420241e1     ...A.B.Z.A...A.B
   17c68:	47085ab1 9fc3258c 0d4df221 258c1430     .Z.G.%..!.M.0..%
   17c78:	f2299002 10b50d65 08c64042 e80d07cf     ..).e...B@......
   17c88:	07ef08be e8094022 07ef08b6 e80540e1     ...."@.......@..
   17c98:	702c8e04 8e04f003 0c86d980 1672ffcf     ..,p..........r.
   17ca8:	b8c61080 10021e72 8e04f011 ffef0c72     ....r.......r...
   17cb8:	f00dd9ff ffef0d6a 41008e04 5acf40c1     ....j......A.@.Z
   17cc8:	8e04f005 ffef0c5a 42c3d980 1fc80080     ....Z......B....
   17cd8:	41c1700c 5ad5a2a0 008040c3 80001fc8     .p.A...Z.@......
   17ce8:	78e0c6cc c1a1c3ea 46cb70ad de20007f     ...x.....p.F.. .
   17cf8:	41104728 33421c03 2380200a 41229600     (G.A..B3. .#.."A
   17d08:	04af0ace 0003382f 71a5f645 91340df1     ..../8..E..q..4.
   17d18:	086274c5 40e107ef 8002208c f21d710c     .tb....@. ...q..
   17d28:	07ef0852 208c40e1 f4168fc3 20158f04     R....@. ....... 
   17d38:	d940234c 30c22440 8cc2716c 26535abf     L#@.@$.0lq...ZS&
   17d48:	b88510c0 30021c03 d9408f04 30c22440     .......0..@.@$.0
   17d58:	5ac1716c 201540a1 91002001 008045cb     lq.Z.@. . ...E..
   17d68:	3a2f1fd0 700c0003 a54041e1 85005ad7     ../:...p.A@..Z..
   17d78:	78e0c7ca 0a0b8848 80310c51 01798123     ...xH...Q.1.#.y.
   17d88:	78e0080f 4528c2e8 05ef0a76 0a964010     ...x..(Ev....@..
   17d98:	470805ef d8404608 42c141e1 08275ab6     ...G.F@..A.B.Z'.
   17da8:	d8170421 42c141e1 e80d5ab6 e80b880d     !....A.B.Z......
   17db8:	1e00d8c8 00807000 40c32078 00004348     .....p..x .@HC..
   17dc8:	c6c8a500 0a22c2e6 0a3605cf 470805ef     ......"...6....G
   17dd8:	05ef0a52 0a364608 450805ef d8104200     R....F6....E.B..
   17de8:	5ab141e1 8020e805 180de983 d8170003     .A.Z.. .........
   17df8:	42a141c1 e80b5ab6 e809880d 41c1d840     .A.B.Z......@..A
   17e08:	5ab642a1 180de803 c6c60043 c1a1c3e4     .B.Z....C.......
   17e18:	450870cd 33821c03 40c3a8c0 2ab00080     .p.E...3...@...*
   17e28:	e81c8817 008040c3 88002bf4 00910819     .....@...+......
   17e38:	008040c3 882012ad 30c02440 0d6f0ebe     .@.... .@$.0..o.
   17e48:	f00dad20 00710815 088640a1 09260c8f      .....q..@....&.
   17e58:	24400caf f00430c0 700cadc0 30811403     ..@$.0.....p...0
   17e68:	adc0e902 78e0c7c4 01851802 18004100     .......x.....A..
   17e78:	d82500c5 700cb103 19047fe0 78e00045     ..%....p....E..x
   17e88:	c1adc3f8 00121020 5ad34508 008047cb     .... ....E.Z.G..
   17e98:	87201238 00002079 090d7104 0f2a0000     8. .y ...q....*.
   17ea8:	a700086f 05cf0942 05ef0962 47104018     o...B...b....@.G
   17eb8:	40a1d936 0da021ab 41c35ab3 24004974     6..@.!...Z.AtI.$
   17ec8:	04af0916 00003900 70cd8721 24406038     .....9..!..p8`@$
   17ed8:	70ad3116 2532a701 007f1f80 4103de1c     .1.p..2%.......A
   17ee8:	5ab142e2 e8274410 20011420 40827960     .B.Z.D'. .. `y.@
   17ef8:	0042e0c0 24400025 40d330c0 1b1c0080     ..B.%.@$.0.@....
   17f08:	734126f0 13580080 23502015 20131444     .&As..X.. P#D.. 
   17f18:	2015100c 10007960 0ef22011 140307ef     ... `y... ......
   17f28:	08b63080 081d048f 41c30191 71000002     .0.........A...q
   17f38:	6d14f014 a0c370c2 a0c1a0c2 f032a0c0     ...m.p........2.
   17f48:	0331080f 41c37014 38800001 41c3f006     ..1..p.A...8...A
   17f58:	4240000f 000229c5 043f266f 003f236f     ..@B.)..o&?.o#?.
   17f68:	144c6d74 13082009 13042008 1300200b     tmL.. ... ... ..
   17f78:	266f200c 874105ff 6078c081 04432202     . o&..A...x`."C.
   17f88:	1804a080 0b0f02c0 18080065 0d0d0200     ........e.......
   17f98:	41502240 20801800 2240180c 0440180c     @"PA... ..@"..@.
   17fa8:	73b571a5 ffc50732 008045cb 8d001fe4     .q.s2....E......
   17fb8:	003e080f d8fbc181 5acd4242 08118d00     ..>.....BB.Z....
   17fc8:	c185007e 4242d8fa 8d005acd 00be080d     ~.....BB.Z......
   17fd8:	c189d8f9 5acd4242 c081d93a 092f0f32     ....BB.Z:...2./.
   17fe8:	0da021ab 094f0906 086f0f12 30802440     .!....O...o.@$.0
   17ff8:	30801402 0ffee813 081e058f 450805ef     ...0...........E
   18008:	d8414200 5ab641a1 180de807 181d0043     .BA..A.Z....C...
   18018:	5adb0043 d857f003 d93b5acc 21ab700c     C..Z..W..Z;..p.!
   18028:	c7d80da0 0fbac2e2 450807cf 41c3d80f     ...........E...A
   18038:	c8d0007f d80f5acb 007f41c3 5acac828     .....Z...A..(..Z
   18048:	007f41c3 e904c7bc 5acb720c 007f41c3     .A.......r.Z.A..
   18058:	e904c720 5aca720c c6c240a1 710c7fe0      ....r.Z.@.....q
   18068:	c1a4c3e8 008041c3 8920120e 26f04508     .....A.... ..E.&
   18078:	00807042 c1832038 086f0da2 c0234040     Bp..8 ....o.@@#.
   18088:	0071084f 0f96c080 c022088f 00d10843     O.q.......".C...
   18098:	31401400 0cc72080 898f208c 1402f719     ..@1. ... ......
   180a8:	20803140 208c0cc7 f713898f 31401404     @1. ... ......@1
   180b8:	0cc72080 898f208c c300f70b 1408c201     . ... ..........
   180c8:	40c33101 13640080 a060a041 140db024     .1.@..d.A.`.$...
   180d8:	08273080 c0800071 088f0a2a 081bc022     .0'.q...*..."...
   180e8:	c30000d1 1408c201 40c33101 13700080     .........1.@..p.
   180f8:	a060a041 140eb024 08273080 c0800071     A.`.$....0'.q...
   18108:	08cf0a76 081bc022 c30000d1 1408c201     v..."...........
   18118:	40c33101 137c0080 a060a041 0aa6b024     .1.@..|.A.`.$...
   18128:	40a1092f 0cf68500 c183086f 0929c123     /..@....o...#.).
   18138:	40100071 008040c3 80211364 90048040     q..@.@..d.!.@...
   18148:	c240c141 30041c08 080dc022 c08000f1     A.@....0".......
   18158:	088f0e6a 3080140d 00510825 008040c3     j......0%.Q..@..
   18168:	80211370 90048040 c240c141 30041c08     p.!.@...A.@....0
   18178:	080dc022 c08000f1 088f0bda 3080140e     "..............0
   18188:	00510825 008040c3 8021137c 90048040     %.Q..@..|.!.@...
   18198:	c240c141 30041c08 080dc022 c08000f1     A.@....0".......
   181a8:	08cf098e c7c84002 008041c3 40c320c0     .....@...A... .@
   181b8:	967f0098 01031901 700ca101 19007fe0     ...........p....
   181c8:	78e00003 0e22c2ec 401005af 05af0e3e     ...x.."....@>...
   181d8:	41104508 e81b70cd 13522540 70ede515     .E.A.p..@%R....p
   181e8:	24801278 8d00e80d 00df0817 1001150b     x..$............
   181f8:	7960e906 15402542 f203e0c0 71c571e5     ..`yB%@......q.q
   18208:	94640ee1 1f0d2554 70edf002 008045cb     ..d.T%.....p.E..
   18218:	85011204 a5216821 21001006 00c0205f     ....!h!....!_ ..
   18228:	00430809 10011d04 5ac5ef8f 4006e88d     ..C........Z...@
   18238:	e80f706c 0000224a 8000882d 21797945     lp..J"..-...Eyy!
   18248:	e8fc0002 1d00e905 700c1043 4002c6cc     ........C..p...@
   18258:	5adaad60 78e0f1fb 4588c2f4 45504270     `..Z...x...EpBPE
   18268:	44104130 03bf272f 003f236f 40a25aa9     0A.D/'..o#?..Z.@
   18278:	5abe4142 70811600 1ea40080 f40e7034     BA.Z...p....4p..
   18288:	205278a5 f20a803e 043f266f 003f236f     .xR >...o&?.o#?.
   18298:	262f5aaa f09e03bf 4082da78 262f4122     .Z/&....x..@"A/&
   182a8:	0ae603bf da3405cf 0ade40a2 414205ef     ......4..@....BA
   182b8:	41224082 434242a2 238a5aa8 09bb2e01     .@"A.BBC.Z.#....
   182c8:	70ed2030 261a70cd 758214cd 5aa740a1     0 .p.p.&...u.@.Z
   182d8:	0d768536 401003ef 40a1f227 a7fe2050     6.v....@'..@P ..
   182e8:	5adcf225 20508516 f20a87fe 209a40c1     %..Z..P .....@. 
   182f8:	70820e01 e904802c 40a17960 269a46d1     ...p,...`y.@.F.&
   18308:	1d582e01 40021400 25162600 20021624     ..X....@.&.%$.. 
   18318:	41a17a60 0120087a 162c40a1 e90c2001     `z.Az. ..@,.. ..
   18328:	40a17960 712cf008 5ad9f003 08de702c     `y.@..,q...Z,p..
   18338:	40a10020 a7fe2050 40d1f21a 2e01209a      ..@P .....@. ..
   18348:	200040a1 5adc2510 5aa640a1 105c4610     .@. .%.Z.@.Z.F\.
   18358:	70d62100 206126ca 05a00815 0588202f     .!.p.&a ..../ ..
   18368:	2002103c 41a17a60 2584185c 5abd40a1     <.. `z.A\..%.@.Z
   18378:	0e5771c5 0a5b9444 275a2010 75a21d0d     .qW.D.[.. Z'...u
   18388:	b8c18d15 00510845 e8209503 087e712c     ....E.Q... .,q~.
   18398:	40a10020 e8188d0d 05af0a2a 10c01505      ..@....*.......
   183a8:	0946e894 15050160 d8ff10c0 42005aad     ..F.`........Z.B
   183b8:	0b02732c 40a105ef 704c722c 05ef0af6     ,s.....@,rLp....
   183c8:	f00440a1 5ada40a1 0fb371e5 5aaa9484     .@...@.Z.q.....Z
   183d8:	c6d4700c 42c3c0f1 12100080 81208221     .p.....B....!. .
   183e8:	0f80091b b66b5aa5 e9898a28 7014712c     .....Zk.(...,q.p
   183f8:	aa28d827 d827f205 c0d15acc 20ab7ee0     '.(...'..Z...~. 
   18408:	21ab0ce0 f1ff0a61 4508c3f4 05af0c4a     ...!a......EJ...
   18418:	b8024030 206c7304 24020040 0b16300f     0@...sl @..$.0..
   18428:	44f9056f 41f1ed0a 1340260a 5ab340c1     o..D...A.&@..@.Z
   18438:	20101904 eefc86c0 b8c18d15 00710897     ... ..........q.
   18448:	8d0d40a1 0030089b 1d1d704e 95031043     .@....0.Np..C...
   18458:	20033a2f b8c18d04 0091088f 5aa740a1     /:. .........@.Z
   18468:	20504310 f24987fe be18de3f 2480210a     .CP ..I.?....!.$
   18478:	23803100 220a4162 0b562440 4110046f     .1.#bA."@$V.o..A
   18488:	0b56f698 4042046f 382f781d 0bba0003     ..V.o.B@.x/8....
   18498:	412203ef 8d04f40e 80812841 8d1df3ea     .."A....A(......
   184a8:	09d1781b f0068003 220a783b ad1d2440     .x......;x."@$..
   184b8:	23803200 0b1a4162 4110046f 000b003a     .2.#bA..o..A:...
   184c8:	8d3d8d04 80822841 783bf3f0 80030add     ..=.A(....;x....
   184d8:	852af013 85a07940 710c4210 700cf002     ..*.@y...B.q...p
   184e8:	ed9971cd 0813f0a5 40a10071 20505aa7     .q......q..@.ZP 
   184f8:	f20387fe 8ddd4210 0383382f 046f0ada     .....B../8....o.
   18508:	20003200 10c21505 087a7910 40400160     .2. .....yz.`.@@
   18518:	2052700c 7f152015 7f8043d3 700e0000     .pR . ...C.....p
   18528:	74e5f002 08b38d0d 40a10030 41105ab2     ...t....0..@.Z.A
   18538:	05af0fae 260a40a1 e80624c0 0100105e     .....@.&.$..^...
   18548:	20033e2f 2010090b 08c18d15 1516011e     />. ... ........
   18558:	712e1094 04ef095e 25803a00 044f0a7a     ...q^....:.%z.O.
   18568:	70144200 203f0c15 006122ca 00e00e0e     .B.p..? ."a.....
   18578:	08094040 7a1b0080 21ca7232 0d1e208d     @@.....z2r.!. ..
   18588:	4022046f 211a8d3d 0929238e 3a0003a0     o."@=..!.#)....:
   18598:	e98d2012 10911514 5aadd8ff 5ab54410     . .........Z.D.Z
   185a8:	730c4300 42824122 addd5ad0 10031d1e     .C.s"A.B.Z......
   185b8:	0a968700 414203ef 20c540a2 083d0061     ......BA.@. a.=.
   185c8:	71cd003f 10911514 43005ab5 704c720c     ?..q.....Z.C.rLp
   185d8:	5ad04122 8d1df012 1514e810 700c1091     "A.Z...........p
   185e8:	44105aad 43005ab5 4122730c 5ad04282     .Z.D.Z.C.s"A.B.Z
   185f8:	14021d1e 14021d1d ed1b85a0 08278501     ..............'.
   18608:	5ab38010 f18f4210 0443382f 046f09ca     ...Z.B../8C...o.
   18618:	20003a00 712e8d36 21ca7114 0939200d     .:. 6..q.q.!. 9.
   18628:	4430803f 00e00d56 41104022 c7d4f194     ?.0DV..."@.A....
   18638:	c1a1c3e4 008046cb 8ea02074 008042c3     .....F..t ...B..
   18648:	0e96120e aaa007af 0d218e20 46081060     ........ .!.`..F
   18658:	31431c01 30431c02 30421c03 42005ab5     ..C1..C0..B0.Z.B
   18668:	2440d8fe 5acd3041 c7c440c1 272fc2e6     ..@$A0.Z.@..../'
   18678:	236f03bf 4708003f 008045cb 208c1f34     ..o#?..G.E..4.. 
   18688:	f2258e83 9ec3278c 9f8227cc 00fe0000     ..%..'...'......
   18698:	700cf43a 066f0c26 0b32702c 700c06ef     :..p&.o.,p2....p
   186a8:	244a8500 20807800 20a80105 180a0140     ..J$.x. ... @...
   186b8:	41c30015 1f440080 274f8140 208c1080     ...A..D.@.O'... 
   186c8:	22468f83 a1000280 710cf41e 066f0bee     ..F".......q..o.
   186d8:	0afa702c 710c06ef 244a8500 e00e77c0     ,p.....q..J$.w..
   186e8:	010020a8 0015180a 008041c3 81001f44     . .......A..D...
   186f8:	9f83278c 01402046 f406a100 20848100     .'..F @........ 
   18708:	a10007fe 70031e00 1f8c0080 262f5aa0     .......p.....Z/&
   18718:	c6c603bf 4768c2e6 45089361 73104688     ......hGa..E.F.s
   18728:	10cd25ca 25ca7530 4140104d 081a42c1     .%..0u.%M.@A.B..
   18738:	40a10020 41e140a1 0020080e 40a142c1      ..@.@.A.. ..B.@
   18748:	78e0c6c6 4528c2e4 062f0d3e 8e164648     ...x..(E>./.HF..
   18758:	001f080d 00e00c26 ad078d07 78e0c6c4     ....&..........x
   18768:	45cbc2e4 11f00080 ea1e8d40 41c38d01     ...E....@......A
   18778:	20900080 00600d9e 854389c0 85818d28     ... ..`...C.(...
   18788:	44c3716c b330007f 202370ac 40c10300     lq.D..0..p# ...@
   18798:	85238d08 71048d40 6901ad08 6a09a503     ..#.@..q...i...j
   187a8:	c6c4ad00 07cf0f72 78e0c6c4 215fc0e6     ....r......x.._!
   187b8:	42c30603 1f480080 8581627d 44cb6262     ...B..H.}b..bb.D
   187c8:	de14007f 05fe0a2b 854468c3 43cb642b     ....+....hD.+d.C
   187d8:	ffff0000 22ca7271 a86002cd 03031801     ....qr."..`.....
   187e8:	ba28a842 a84368c7 7404df0a 76edf002     B.(..hC....t...v
   187f8:	61998542 2a4189a2 2a41060c a8a00403     B..a..A*..A*....
   18808:	a861a882 2a418904 ae00020b 12c21e02     ..a...A*........
   18818:	ae4140e1 78e0c4c6 c1a9c3f2 70121600     .@A....x.......p
   18828:	1f440080 0614215f 2203218a a0022284     ..D._!...!."."..
   18838:	40304608 008043d3 24001f34 00802f8f     .F0@.C..4..$./..
   18848:	21ca1f58 272f26e2 236f003f f005003f     X..!.&/'?.o#?...
   18858:	4002c180 86235ab9 49108601 04650893     ...@.Z#....I..e.
   18868:	860170ad 081de819 86222030 008040c3     .p......0 "..@..
   18878:	90001fac 00050923 008040c3 f00b1fa4     ....#....@......
   18888:	008040c3 90001fa0 0005090f 008040c3     .@...........@..
   18898:	80001f98 255f602d e5bf1280 4166f705     ....-`_%......fA
   188a8:	49196119 70c3f004 153b0080 c2808800     .a.I...p..;.....
   188b8:	204941c1 40020883 072f0812 ed054570     .AI ...@../.pE..
   188c8:	20300d4d 8700d870 a70070a2 e0bfc020     M.0 p....p.. ...
   188d8:	ffcd0780 205f4166 60380280 90228848     ....fA_ ..8`H.".
   188e8:	0971ba80 a8488030 b0227724 0a1ff1b2     ..q.0.H.$w".....
   188f8:	87002030 2f812434 28840080 2000e907     0 ..4$./...(... 
   18908:	00802f90 1800120c c7d22043 0ce020ab     ./......C ... ..
   18918:	266f700c 236f043f c7d2003f c1a3c3e4     .po&?.o#?.......
   18928:	0602215f 41c34628 1f480080 8224623a     _!..(F.A..H.:b$.
   18938:	e91b4508 82008201 081b706c bb9705fe     .E......lp......
   18948:	82208201 790b787d 2678f205 71041000     .. .}x.y..x&...q
   18958:	c0805ad8 ffef0e5a 430041c1 40c1c280     .Z..Z....A.C...@
   18968:	06ef0fea 266f41a1 236f043f c7c4003f     .....Ao&?.o#?...
   18978:	4660c2ec 40304740 70ed4110 008045cb     ..`F@G0@.A.p.E..
   18988:	70cd2874 213279ef 00800f80 08a9120c     t(.p.y2!........
   18998:	44200030 6a099548 009ce0cc 47db000d     0. DH..j.......G
   189a8:	1fa00080 008044cb 43c31f34 1fa40080     .....D..4..C....
   189b8:	008041c3 40c31fac 1f980080 10051400     .A.....@........
   189c8:	00091300 01081100 000b1000 311f1700     ...............1
   189d8:	850170cd 0b337bd0 702c0025 150c8502     .p...{3.%.,p....
   189e8:	60781012 0c0b7c10 85031484 0c134c10     ..x`.|.......L..
   189f8:	78100030 02050813 10012132 080bf005     0..x....2!......
   18a08:	233207c5 215f1001 e1bf0280 70a0f704     ..2#.._!.......p
   18a18:	f005e009 008070c3 e90c153b e80a8800     .....p..;.......
   18a28:	09117950 49120024 262f607e f5d3f088     Py..$..I~`/&....
   18a38:	71cdb5c8 78ef71e5 80b4084d 4022e518     ...q.q.xM....."@
   18a48:	42e04102 06ef0a7e ee0d43c0 f0077910     .A.B~....C...y..
   18a58:	72227104 1a007910 09f90003 7a108424     .q"r.y......$..z
   18a68:	78104002 78e0c6cc c1a3c3e4 008046cb     .@.x...x.....F..
   18a78:	86211288 8e4c8e70 69014508 2205a601     ..!.p.L..E.i..."
   18a88:	f20880fe 08fe702c 40a10020 f0104408     ....,p.. ..@.D..
   18a98:	08f2712c 40a10020 080d8601 6d040071     ,q.. ..@....q..m
   18aa8:	ff4f0c9e 008040c3 888012ac f307262f     ..O..@....../&..
   18ab8:	208af40b 65190e0e 19006d04 0c820083     ... ...e.m......
   18ac8:	1e04ff6f 86251001 092b8601 c0800025     o.....%...+.%...
   18ad8:	ff0f0f6e 1de5c000 c0011018 10181de6     n...............
   18ae8:	1de7c002 25801018 1d001e0e 1e041003     .......%........
   18af8:	788d1001 78e0c7c4 c1a6c3e2 45088160     ...x...x....`..E
   18b08:	8161c340 c3417404 c3428162 c3438163     @.a..tA.b.B.c.C.
   18b18:	c3448164 c1808165 ff6f0ae2 2580c345     d.D.e.....o.E..%
   18b28:	700c1ece 10431d00 78e0c7c2 46cbc2e4     ...p..C....x...F
   18b38:	12880080 8e5a8621 69014508 00f40a0b     ....!.Z..E.i....
   18b48:	1e04a601 712c1001 0020083a 8e3940a1     ......,q:. ..@9.
   18b58:	00f10919 f007262f 2580f408 1d001e0e     ..../&.....%....
   18b68:	1e041103 c6c41001 86418520 000d2180     ........ .A..!..
   18b78:	090f9120 258000a5 1d001e4e c6c41043      ......%N...C...
   18b88:	c1a9c3ea 008046cb 40101298 8e0880a0     .....F.....@....
   18b98:	2f8f2000 03780000 00700851 87634130     . ./..x.Q.p.0Ac.
   18ba8:	87218742 248a8700 09a60e0d 24000a2f     B.!....$..../..$
   18bb8:	87630404 87218742 08e68700 24400a2f     ..c.B.!...../.@$
   18bc8:	8e283004 21002040 0131090d 228042a1     .0(.@ .!..1..B."
   18bd8:	f009070a 00d1090b 03082280 2280f003     ........."....."
   18be8:	0af20f05 c180ff6f ff4f0966 8e288e14     ....o...f.O...(.
   18bf8:	8e00e815 20022179 00002078 f40f7a0b     ....y!. x ...z..
   18c08:	00700937 093371ed 218a0130 7102080d     7.p..q3.0..!...q
   18c18:	21002040 1e022540 091ff00d 70ed0070     @ .!@%......p..p
   18c28:	01300917 080d218a 20407102 25402100     ..0..!...q@ .!@%
   18c38:	0c461502 45cb0d4f 3ea80080 008040c3     ..F.O..E...>.@..
   18c48:	0af63b40 41a10d6f 40e18626 c7caa527     @;..o..A&..@'...
   18c58:	702cc2e2 ffef0f2e 42c34508 12880080     ..,p.....E.B....
   18c68:	090d8a39 262f00f0 f205f007 0913790f     9...../&.....y..
   18c78:	25800051 1d001e0e 1a041183 c6c20001     Q..%............
   18c88:	42c3c0f1 12880080 71248221 0174091d     ...B....!.$q..t.
   18c98:	218aa221 61190e0e 00831900 00011a04     !..!...a........
   18ca8:	00200812 00431a1c 7fe0c0d1 78e0700c     .. ...C......p.x
   18cb8:	c1a9c3e4 0f8d2000 03600000 85004608     ..... ....`..F..
   18cc8:	c0408620 21548501 c0410b82 c1808502      .@...T!..A.....
   18cd8:	850dc042 850ec043 856fc044 0e1e40c1     B...C...D.o..@..
   18ce8:	c345ffef 0f0e208a 8e00661e 0071082f     ..E.. ...f../.q.
   18cf8:	43c3c286 3b3c0080 20568300 730c0e81     ...C..<;..V ...s
   18d08:	040c111c 08fd7104 1a0481b4 6b040310     .....q.........k
   18d18:	0d6f0d0e 1e00c186 700c1003 a50ea50d     ..o........p....
   18d28:	c7c4a50f 80044100 001819e8 19e98105     .....A..........
   18d38:	81060018 001819ea 0ece2180 7fe0700c     .........!...p..
   18d48:	00031900 4528c2e2 255a5ab3 16001281     ......(E.ZZ%....
   18d58:	00807002 45081f34 6159700c ea169141     .p..4..E.pYaA...
   18d68:	e8848907 a907710c 0003382f 042f0a6a     .....q../8..j./.
   18d78:	10003d00 97fe2550 21ca702c 20780062     .=..P%..,p.!b.x 
   18d88:	794b0002 006220ca 78e0c6c2 1800e805     ..Ky. b....x....
   18d98:	00000f84 e90607df 0f821900 000c0000     ................
   18da8:	1a00ea05 00000f82 eb060017 0f821b00     ................
   18db8:	00050000 00100c0d 0f821c00 00110000     ................
   18dc8:	7ce070b4 0f821d00 000a0000 78e07ee0     .p.|.........~.x
   18dd8:	0e56c2e2 450805ef e8064200 090b8d35     ..V....E.B..5...
   18de8:	710c013f c6c24040 8835c2e2 0929b9c1     ?..q@@....5...).
   18df8:	882d0051 88bde913 00c01005 0f5e70b5     Q.-..........p^.
   18e08:	25ca00e0 392f1061 382f0343 38000003     ...%a./9C./8...8
   18e18:	c6c20040 054f0d8e 700cc6c2 78e0c6c2     @.....O....p...x
   18e28:	c1a1c3ec 88164608 458847a8 41504070     .....F...G.Ep@PA
   18e38:	003e0819 40c14230 42224142 44a14302     ..>.0B.@BA"B.C.D
   18e48:	056f0dd6 c7cc45e1 056f0ade 414240c1     ..o..E....o..@BA
   18e58:	43024222 0dc244a1 45e1056f 30842440     "B.C.D..o..E@$.0
   18e68:	414240c1 43024222 056f0dae 952045e1     .@BA"B.C..o..E .
   18e78:	31021402 0a014020 793d0024 c7ccb500     ...1 @..$.=y....
   18e88:	06412042 0095090d 006040c3 7ee01a5c     B A......@`.\..~
   18e98:	05950817 003041c3 090f0008 40c3000e     .....A0........@
   18ea8:	13d80060 40c37ee0 0d540060 78e07ee0     `....~.@`.T..~.x
   18eb8:	41c3c0f1 12240080 702c8140 c0d15ace     ...A..$.@.,p.Z..
   18ec8:	700c7fe0 c1a5c3e4 c0804508 086f0a06     ...p.....E....o.
   18ed8:	0a22c680 2440082f 141334c0 382f3080     .."./.@$.4...0/8
   18ee8:	c0430003 0000204a 71048620 0f813900     ..C.J .. ..q.9..
   18ef8:	ac123c20 80f208f5 10501e04 70801600      <........P....p
   18f08:	1fe40080 013e080d 8548d8fa 5acdc180     ......>...H....Z
   18f18:	008040c3 09ee13fc c180feaf 00422084     .@........... B.
   18f28:	8042208c 8528f40d 008040c3 a0201224     . B...(..@..$. .
   18f38:	702c8548 5ace40a1 40a1702c 700c5add     H.,p.@.Z,p.@.Z.p
   18f48:	78e0c7c4 40c3c0f1 13fc0080 fe8f09b2     ...x...@........
   18f58:	7fe0c0d1 78e0700c 088ec2e4 4508056f     .....p.x....o..E
   18f68:	056f08aa 42004608 41c1710c 15725ab1     ..o..F.B.q.A.Zr.
   18f78:	b9c61081 10421d72 1072e805 081100c0     ....r.B...r.....
   18f88:	8d040012 0c62742c 704cff6f c6c4700c     ....,tb.o.Lp.p..
   18f98:	0856c2e4 4508056f 056f0872 42004608     ..V.o..Er.o..F.B
   18fa8:	41c1710c 15725ab1 091f10c1 e8060012     .q.A.Zr.........
   18fb8:	00c01072 00120813 742c8d04 ff6f0c2a     r.........,t*.o.
   18fc8:	1572714c b9871081 1d72700c c6c41042     Lqr......pr.B...
   18fd8:	008040c3 7fe0126c 78e09000 008040c3     .@..l......x.@..
   18fe8:	7fe01274 78e08000 4520c0f1 00c11172     t......x.. Er...
   18ff8:	0033091f 42c3d90c 126c0080 1504a203     ..3....B..l.....
   19008:	e2100080 44c3766c bbfc007f c0d15ac0     ....lv.D.....Z..
   19018:	78e07ee0 008040c3 7fe01284 78e08000     .~.x.@.........x
   19028:	008040c3 7fe01270 78e08000 4328c2e6     .@..p......x..(C
   19038:	40c3e89e 126c0080 00c11011 10138890     ...@..l.........
   19048:	101500cf 88b400c2 806388d2 02002940     ..........c.@)..
   19058:	44cb7885 1b340080 2f40a400 ba081200     .x.D..4...@/....
   19068:	a40178c5 40617aa5 a4427b60 78e0c6c6     .x...za@`{B....x
   19078:	c1a1c3e4 88044508 2440702c 716c30c2     .....E..,p@$.0lq
   19088:	de225abf 1403e892 de213080 0080206c     .Z"......0!.l ..
   19098:	8403208c 091af40a 8d04ff6f 700ce886     . ......o......p
   190a8:	00200852 70cd41a1 c7c440c1 4628c2e6     R. ..A.p.@....(F
   190b8:	42c3702c de3e007f 090f92a3 e20800f5     ,p.B..>.........
   190c8:	90240df9 12027124 47cb0000 126c0080     ..$.$q.....G..l.
   190d8:	b7a0a701 0c2e8a20 8e04072f 080b8702     .... .../.......
   190e8:	710c00b5 700c5aa2 5ad641c1 c6c640a1     ...q.Z.p.A.Z.@..
   190f8:	4528c2e6 46cb4708 126c0080 8fc3208c     ..(E.G.F..l.. ..
   19108:	0f35f213 278c1430 f20f9002 10b50f3b     ..5.0..'....;...
   19118:	0d42702c 8d04072f 10801572 1d72b8c6     ,pB./...r.....r.
   19128:	a6e21002 8d04f00e 072f0d2a d8ffd9ff     ........*./.....
   19138:	f008a602 ff6f0a0e 41008d04 5acf40a1     ......o....A.@.Z
   19148:	41a1700c 86025ad5 78e0c6c6 c1a1c3ea     .p.A.Z.....x....
   19158:	46cb70ad de64007f 41104728 33421c03     .p.F..d.(G.A..B3
   19168:	2380200a 41229600 03ef0e66 0003382f     . .#.."Af.../8..
   19178:	71a5f645 91340df1 8f0474c5 2440d942     E..q..4..t..B.@$
   19188:	716c30c2 20155abf 14032350 10023081     .0lq.Z. P#...0..
   19198:	216c2080 b8c300c1 1c037825 8f043002     . l!....%x...0..
   191a8:	2440d942 716c30c2 45cb5ac1 126c0080     B.@$.0lq.Z.E..l.
   191b8:	080b8502 710c00b5 8f045aa2 2440d976     .......q.Z..v.@$
   191c8:	716c30c2 10005abf 700c2103 10c33c2f     .0lq.Z...!.p/<..
   191d8:	30811403 7934796a 00433a2f 0f83392f     ...0jy4y/:C./9..
   191e8:	32000000 00413a00 10423401 008041c3     ...2.:A..4B..A..
   191f8:	a1401b40 00c33a2f a54641e1 85065ad7     @.@./:...AF..Z..
   19208:	78e0c7ca 47cbc3ec 1f440080 b8e78700     ...x...G..D.....
   19218:	00220184 5aabc1a2 008040d3 70ad1f54     .."....Z.@..T..p
   19228:	228e2040 5aac78af 1e1871a5 78af1014     @ .".x.Z.q.....x
   19238:	809408f5 008046cb 1e001f8c 5ac81003     .....F.........Z
   19248:	204b8700 f2058480 b8838e00 8700ae00     ..K ............
   19258:	8440204b 5ac3f206 8e00e884 ae00b886     K @....Z........
   19268:	20ab8e00 20aa0660 21aa0e20 08fb0e20     ... `..  ..! ...
   19278:	5ac48041 f20f7014 e80b5ac3 70001600     A..Z.p...Z.....p
   19288:	1f780080 8e00e885 8180204b 8700f203     ..x.....K ......
   19298:	f2827014 dd805ab8 252f40e1 0d0f100c     .p...Z...@/%....
   192a8:	c540107e b8838e00 0d11ae00 5ac3101e     ~.@............Z
   192b8:	8e00e884 ae00b886 113e0d11 5ac7c080     ..........>....Z
   192c8:	8e00e804 f26a7014 080dc000 700c00de     .....pj........p
   192d8:	c0005ad1 009e080d e8845ac3 5ad1710c     .Z.......Z...q.Z
   192e8:	086dc020 5ab5011e 45cb8e20 1f8d0080      .m....Z ..E....
   192f8:	02012185 1c05ae20 8d203043 30421c06     .!.. ...C0 ...B0
   19308:	30031c07 09198d20 46080834 208c8d00     ...0 ...4..F... 
   19318:	f2068f03 208c8d00 f4078fc3 2440d8fe     ....... ......@$
   19328:	42c13141 8d005acd 0814080b e0c08d00     A1.B.Z..........
   19338:	8d00f789 8f43208c 8d00f205 8fc3208c     ..... C...... ..
   19348:	d8f8f406 31412440 5acd42c1 043f266f     ....@$A1.B.Zo&?.
   19358:	003f236f 702e5aab 2400220a 7eaf70ad     o#?..Z.p.".$.p.~
   19368:	1a1840c1 5aac2450 1af271a5 76c3a004     .@..P$.Z.q.....v
   19378:	120c0080 08eb78af 1e0080b4 87001442     .....x......B...
   19388:	0040206c 266fa700 100a05ff 10222100     l @...o&.....!".
   19398:	5ac62101 c7cc700c f1fe5aa0 c1a1c3ec     .!.Z.p...Z......
   193a8:	4b504110 454846a8 28424030 1c038092     .APK.FHE0@B(....
   193b8:	f2203003 01100c13 01d00c09 01910c0f     .0 .............
   193c8:	30d02440 2440f003 082930d1 71ed0072     @$.0..@$.0).r..q
   193d8:	24408500 806130c2 7b604022 ee034102     ..@$.0a."@`{.A..
   193e8:	1403a600 e8863080 74a57752 f6b271e5     .....0..Rw.t.q..
   193f8:	78e0c7cc 0935c0e6 46280012 0929b961     ...x..5...(Fa.).
   19408:	706c0072 42008080 8ce082a1 108b1500     r.lp...B........
   19418:	77717164 134e24ca a281f7c3 0beda2a0     dqqw.$N.........
   19428:	74448062 90530ed7 78e0c4c6 007f42c3     b.Dt..S....x.B..
   19438:	43c3deb4 deb8007f 0765758c 70acffef     ...C.....ue....p
   19448:	007f42c3 43c3dea8 deac007f 0751738c     .B.....C.....sQ.
   19458:	70acffef 42c3708c de98007f 007f43c3     ...p.p.B.....C..
   19468:	073dde9c 4580ffef 007f42c3 43c3dea4     ..=....E.B.....C
   19478:	dea8007f 0729728c 70acffef 007f42c3     .....r)....p.B..
   19488:	43c3de9c dea4007f 0715718c 70acffef     ...C.....q.....p
   19498:	702c700c 007f42c3 43c3deac deb4007f     .p,p.B.....C....
   194a8:	06fd748c 4500ffef c1a1c0f1 42c3702c     .t.....E....,p.B
   194b8:	deb8007f 007f43c3 244adebc 0ee201c0     .....C....J$....
   194c8:	2440ffef c0003005 c0d17487 78e07ee0     ..@$.0...t...~.x
   194d8:	70adc2e4 008046cb 86001318 79028621     ...p.F......!..y
   194e8:	792fb922 00920909 ffcf0f0e 0def71a5     "./y.........q..
   194f8:	e6089234 78e0c6c4 42c3702c deb8007f     4......x,p.B....
   19508:	007f43c3 768cdeb8 ffef0695 78e04520     .C.....v.... E.x
   19518:	238ac1a1 714c0806 4183f00e 9121b161     ...#..Lq...Aa.!.
   19528:	f0097704 0a6122ab 9421448b b4217724     .w..."a..D!.$w!.
   19538:	e9fa9421 f008262f 7fe0f5f1 78e07487     !.../&.......t.x
   19548:	4148c2e6 40688857 88f68875 88ac8894     ..HAW.h@u.......
   19558:	bb08ba08 7b857f45 14022f40 46cb4620     ....E..{@/.. F.F
   19568:	0aaa0000 726d702c 7200244a 7b45bdc3     ....,pmrJ$.r..E{
   19578:	058020a8 00422353 004c224f 10b10c13     . ..S#B.O"L.....
   19588:	104c2b00 72547e86 104126cf 0a0df206     .+L..~Tr.&A.....
   19598:	2b000071 7e451042 7224bb22 422141c0     q..+B.E~".$r.A!B
   195a8:	06af0e1e 710c4301 732c7bbb 6d927978     .....C.q.{,sxy.m
   195b8:	7a984200 22ab7e26 26ab0da1 c6c613e2     .B.z&~."...&....
   195c8:	0e2020aa 0e2021aa f5fc7030 08002044     .  ..! .0p..D ..
   195d8:	b8257fe0 2482c3ec 2456320e c1803840     ..%....$.2V$@8..
   195e8:	000a2080 0025090b 4100c140 c082c040     . ....%.@..A@...
   195f8:	08002056 00050907 42d3c040 05eb0080     V ......@..B....
   19608:	46cb700c 12100080 20412240 5aa543c3     .p.F....@"A .C.Z
   19618:	da1bb66b a160a621 ff6f0dbe 0da022ab     k...!.`...o.."..
   19628:	007f40c3 41c3debc e114007f 41d37902     .@.....A.....y.A
   19638:	e114007f 007f43c3 40d3e3b8 e3b8007f     .....C.....@....
   19648:	007f42c3 2302e488 2202044f 2984040d     .B.....#O.."...)
   19658:	2f440e01 ae291d0f 2d44792f aeea1d0d     ..D/..)./yD-....
   19668:	052f0a96 79efaeab 052f0a9e 79af4022     ../....y../."@.y
   19678:	052f0aa6 45cb4002 e488007f 036f09b2     ../..@.E......o.
   19688:	22aa40a1 245604e1 d9203840 0f822205     .@."..V$@8 .."..
   19698:	00002a54 04ef08ce 04e122ab 0e4ac082     T*......."....J.
   196a8:	d91004ef 007f40c3 41c3e4b8 ffff007f     .....@.....A....
   196b8:	008042c3 43420000 70145ac9 002101ac     .B....BC.Z.p..!.
   196c8:	700cd91c ff6f0d12 0da021ab 8e2b8e0a     ...p..o..!....+.
   196d8:	008047cb 8e4912e0 00042100 87208761     .G....I..!..a. .
   196e8:	ffef0e62 d91d40a1 0cee700c 21abff6f     b....@...p..o..!
   196f8:	40c30da0 c0a0007f 2022e805 007f0f80     ...@......" ....
   19708:	0c22c0a0 d8200000 31922440 000040d3     .."... .@$.1.@..
   19718:	20ab0000 f0070da0 20abd827 20690da0     ... ....'.. ..i 
   19728:	d8218040 20ab70ad 25ab0da0 20aa1ce0     @.!..p. ...%... 
   19738:	21aa05e0 08fb05e0 e88a8041 f2857016     ...!....A....p..
   19748:	0f802022 00000000 f27f7014 d9225ac2     " .......p...Z".
   19758:	000040c3 21ab0000 e8060da0 0f802022     .@.....!...." ..
   19768:	00000000 ff6f0c72 f004710c 068f0bde     ....r.o..q......
   19778:	20aa70ad 21aa05e0 08fb05e0 e88a8041     .p. ...!....A...
   19788:	201008c7 0f802022 00000000 001008bb     ... " ..........
   19798:	262f5abb f459f347 803e2052 d823f255     .Z/&G.Y.R >.U.#.
   197a8:	0da020ab 8e0b8e2a 603b8741 0daa8e29     . ..*...A.;`)...
   197b8:	870006af e8084508 5acc40a1 20abd85e     .....E...@.Z^.. 
   197c8:	f02a0da0 ff6f0c12 40c3710c 00000000     ..*...o..q.@....
   197d8:	2022e805 00000f80 700c0000 40c35aa1     .." .......p.Z.@
   197e8:	2a540000 34031c05 20041a00 42005ab5     ..T*...4... .Z.B
   197f8:	2440d8fe 5acd3141 1084160b 87418e6a     ..@$A1.Z....j.A.
   19808:	08828e29 87000020 70ad4110 4022e804     )... ....A.p.."@
   19818:	452a5acc 20abd824 8e0a0da0 87418e6b     .Z*E$.. ....k.A.
   19828:	631b8e29 06af0e2a 40c38700 00000000     )..c*......@....
   19838:	2022e805 00000f80 d8250000 90310d37     .." ......%.7.1.
   19848:	0da020ab d826f194 f347262f 0da020ab     . ....&./&G.. ..
   19858:	0b2ef203 20aa068f 21aa05e0 08fb05e0     ....... ...!....
   19868:	70148041 f15af55f 0ce020aa f007262f     A..p_.Z.. ../&..
   19878:	d820f404 0ce020ab 20ab710c f1fe0a61     .. .. ...q. a...
   19888:	710ec2f0 008041d3 47881204 44504568     ...q.A.....GhEPD
   19898:	43104230 24021900 e8065ad2 0cfe4062     0B.C...$.Z..b@..
   198a8:	4142052f 70ad67bf d82ef005 20ab700e     /.BA.g.p.....p. 
   198b8:	20aa0da0 21aa05e0 08fb05e0 e88d8041     ... ...!....A...
   198c8:	000040c3 70140000 2022f272 00000f80     .@.....pr." ....
   198d8:	70140000 5abbf26c f347262f 2052f468     ...pl..Z/&G.h.R 
   198e8:	f266803e 406271cd 42824142 240a43e1     >.f..qb@BA.B.C.$
   198f8:	26ab0400 5aa51a61 e8d94508 26abd828     ...&a..Z.E..(..&
   19908:	20ab1a61 5ab70da0 e8d14508 20ab710c     a.. ...Z.E...q. 
   19918:	dc290a61 41424062 43e14282 056f0c52     a.).b@BA.B.CR.o.
   19928:	1da024ab 0ab270ad 710cff6f 008046cb     .$...p..o..q.F..
   19938:	8e001210 710ce806 0a6120ab 0aa120ab     .......q. a.. ..
   19948:	d8ffd92a 0da021ab d82b5aba f347262f     *....!...Z+./&G.
   19958:	0da020ab 4062f40c 42824142 240a43e1     . ....b@BA.B.C.$
   19968:	5aa50400 e8844508 45085ab7 20abd82c     ...Z.E...Z.E,.. 
   19978:	8e000da0 1100e884 e8852080 20abd85a     ......... ..Z.. 
   19988:	700c0aa1 008041c3 202f1ea0 089b004c     ...p.A..../ L...
   19998:	216f8011 8e00003f 710ce806 0a6120ab     ..o!?......q. a.
   199a8:	0aa120ab 20abd82d f1810da0 78afd93f     . ..-.. ....?..x
   199b8:	0da021ab 78e0c6d0 0e3ac2ec 401004ef     .!.....x..:....@
   199c8:	04ef0e56 42004508 41a14002 45085ab6     V....E.B.@.A.Z.E
   199d8:	0e2ee88c 0e4e04cf 450804ef 40024200     ......N....E.B.@
   199e8:	5ab641a1 e8394508 5ab340a1 2152204f     .A.Z.E9..@.ZO R!
   199f8:	21502050 700e1600 1f340080 228f225a     P P!...p..4.Z"."
   19a08:	2281205a 0dd267df 663e03af 09178d35     Z .".g....>f5...
   19a18:	4110017e 05af0a66 0a6240c1 40e105af     ~..Af....@b....@
   19a28:	4022f00b 0d2241c1 42a1ff6f 41e14022     .."@.A".o..B"@.A
   19a38:	ff6f0d16 40a142a1 5aae4102 40a1b601     ..o..B.@.A.Z...@
   19a48:	5aae4142 8d32b701 9621e987 71507a10     BA.Z..2...!..zPq
   19a58:	004920ca c6ccb513 40c3c2e8 1f440080     . I........@..D.
   19a68:	08378000 700e01ff 45cb5aab 1f540080     ..7....p.Z.E..T.
   19a78:	7fcf70cd 5aac40e1 10710f0b 5ac3b505     .p...@.Z..q....Z
   19a88:	9505e883 71c5e887 08eb78cf e51880b4     .......q.x......
   19a98:	1500f003 40021010 78e0c6c8 45cbc2e6     .......@...x...E
   19aa8:	1e8c0080 70cd8d00 e80e70ed 04ef09d6     .......p.p......
   19ab8:	900078cd 71c58d20 b8c0781d 0af17acf     .x.. ..q.x...z..
   19ac8:	671f8064 c6c678ef 43c3c0f1 fe0046ff     d..g.x.....C.F..
   19ad8:	0000080e 7fe0c0d1 78e0700c c1a6c3ea     .........p.x....
   19ae8:	47684508 41304050 41005ab0 2023c083     .EhGP@0A.Z.A..# 
   19af8:	3e2f0440 20231043 24400400 3f0030c0     @./>C.# ..@$.0.?
   19b08:	c1831380 0060089a 1403c281 c1813080     ......`......0..
   19b18:	30021c0a 40a18548 700c5ace 78e0c7ca     ...0H..@.Z.p...x
   19b28:	08d2c2e2 710c062f 008042c3 a2001200     ..../..q.B......
   19b38:	007f41c3 710cc9f8 20795acb 710c000d     .A.....q.Zy ...q
   19b48:	007f41c3 5acac97c 00002079 c6c278a4     .A..|..Zy ...x..
   19b58:	4648c2e8 0a824528 4708076f e7ff4010     ..HF(E..o..G.@..
   19b68:	700cf41c 44cbdfff 1fe40080 0000001f     ...p...D........
   19b78:	7a248c40 660bac40 2900712c 7074000b     @.$z@..f,q.)..tp
   19b88:	717d702c ac207945 08617104 08e50213     ,p}qEy ..qa.....
   19b98:	27128362 f02a1001 13c02742 00d5084d     b..'..*.B'..M...
   19ba8:	008045cb 0f1d1364 710e1470 14310f2b     .E..d...p..q+.1.
   19bb8:	da084d1c 04af09ee 1d1441c1 f01610c3     .M.......A......
   19bc8:	da084d38 04af09de 40c341c1 13840080     8M.......A.@....
   19bd8:	00c31800 0f15f00a da0813f1 09c640a1     .............@..
   19be8:	41c104af 10c31d08 c6c84002 4628c2e6     ...A.....@....(F
   19bf8:	076f08f6 47084508 f417e5ff 716c700c     ..o..E.G.....plq
   19c08:	7200244a 1f80240a 1fe40080 02c020a8     J$.r.$....... ..
   19c18:	2b008c20 79a4000d 2179661a 71040001      ..+...y.fy!...q
   19c28:	78e0aa20 2542f017 082b13c0 41c300d5      ..x..B%..+....A
   19c38:	13640080 14700d0f 0d0f71ed e10c1411     ..d...p..q......
   19c48:	e118f005 0d0ff003 da0a13d1 04af0956     ............V...
   19c58:	40e140c1 78e0c6c6 4300c0f1 0b0fe807     .@.@...x...C....
   19c68:	40600275 0000081e 40c3f00a 00000000     u.`@.......@....
   19c78:	700c7014 0fbef204 406001ac 7ee0c0d1     .p.p......`@...~
   19c88:	8a61c2ea 008045cb 120011f0 ad680091     ..a..E........h.
   19c98:	40d38a62 20900080 2040ad60 46082103     b..@... `.@ .!.F
   19ca8:	076f0aa6 71eda563 0e53e8aa 700c1275     ..o.c..q..S.u..p
   19cb8:	bee08d20 006042c3 46cb5d68 5dd40060      ....B`.h].F`..]
   19cc8:	108126ca e91ba5c1 01750933 8543716c     .&......3.u.lqC.
   19cd8:	18038d28 44c32002 b330007f 402270ac     (.... .D..0..p"@
   19ce8:	03802023 8d00ade1 85438d28 ad007704     # ......(.C..w..
   19cf8:	ad086901 a5036a01 70edf002 c6ca40e1     .i...j.....p.@..
   19d08:	4320c0f1 e8104100 001ce188 700c002d     .. C.A......-..p
   19d18:	41c3f714 20900080 088ada08 406004af     ...A... ......`@
   19d28:	f00c710c 000040c3 70140000 f206700c     .q...@.....p.p..
   19d38:	0f024020 416001ac 7ee0c0d1 882dc2e4      @....`A...~..-.
   19d48:	00300967 881470ad 0071085f 0aa6ddff     g.0..p.._.q.....
   19d58:	0ac604cf 460804ef 710c4200 5ab641c1     .......F.B.q.A.Z
   19d68:	5ab2e803 0a9ae8a1 0aba04cf 460804ef     ...Z...........F
   19d78:	d8174200 5ab641c1 880de803 1600e895     .B...A.Z........
   19d88:	00807000 08232080 dd800070 0f80081b     .p... #.p.......
   19d98:	80050001 0f800813 00110008 0f80080b     ................
   19da8:	2015000e 40a1ddff 78e0c6c4 4548c2e6     ... ...@...x..HE
   19db8:	0874086b 0a324608 0a5204cf 470804ef     k.t..F2...R....G
   19dc8:	18012642 782f4200 5ab141e1 706c4200     B&...B/x.A.Z.Blp
   19dd8:	4348e82a 1a412380 f016dcf0 008e2b44     *.HC.#A.....D+..
   19de8:	07c02b41 b9c06319 68324910 716465c8     A+...c...I2h.edq
   19df8:	00412801 03002105 b9c3b9e3 004120ca     .(A..!....... A.
   19e08:	10121b01 00811272 792ab9c6 21cae189     ....r.....*y...!
   19e18:	0bcd0265 710c8064 40c1f005 05ef0d06     e...d..q...@....
   19e28:	c6c642a1 c6c6700c c1a2c3ea 008042c3     .B...p.......B..
   19e38:	82401200 7a604728 087f4608 6e0b0030     ..@.(G`z.F..0..n
   19e48:	04b50835 700e6eb4 14432580 e0bf78af     5....n.p.%C..x..
   19e58:	1600f70b 00807002 205f1f34 61590281     .....p..4._ ..Ya
   19e68:	090d8928 0d8e009f 712c056f 08e17106     (.......o.,q.q..
   19e78:	71a5a432 e69f71ad 096ef4b1 401004cf     2..q.q....n....@
   19e88:	04ef098a 411074e5 263270cd 007f1f80     .....t.A.p2&....
   19e98:	4102de10 5ab14222 8028e80a 5aad7940     ...A"B.Z..(.@y.Z
   19ea8:	68558f20 01002153 af007845 0edf71c5      .UhS!..Ex...q..
   19eb8:	75e590f4 0e2ff093 09821611 708d030f     ...u../........p
   19ec8:	8827e805 b9088886 6f027c25 6f456f24     ..'.....%|.o$oEo
   19ed8:	27406f66 274011c4 b7801205 71ad5aaf     fo@'..@'.....Z.q
   19ee8:	0e3df07d 70ad1831 04cf0922 04ef08fa     }.=.1..p".......
   19ef8:	0eeb4608 71ad1030 87408721 05032040     .F..0..q!.@.@ ..
   19f08:	04801378 904e2642 0002220f 10002d00     x...B&N.."...-..
   19f18:	7905b85f a740f5f6 f061a721 18540ebf     _..y..@.!.a...T.
   19f28:	04cf08c6 04ef08e6 26424010 42001801     .........@B&...B
   19f38:	4102782f 08a75ab1 40100030 1e002655     /x.A.Z..0..@U&..
   19f48:	1008af00 6f232080 31822440 1009af01     ..... #o@$.1....
   19f58:	c381208c 30842440 30452440 af824002     . ..@$.0@$E0.@..
   19f68:	40025ab4 b7025ab0 5ab34002 038f086a     .Z.@.Z...@.Zj...
   19f78:	b7048f26 20801072 b827b9a0 af067825     &...r.. ..'.%x..
   19f88:	20011020 40027960 8f265aad 71ad6855      .. `y.@.Z&.Uh.q
   19f98:	01002153 af067845 20801072 2080702c     S!..Ex..r.. ,p. 
   19fa8:	b8c62a41 f013af0a 008c2944 10016158     A*......D)..Xa..
   19fb8:	b8c02483 64fa7842 bbc38a8b 2b00b802     .$..Bx.d.......+
   19fc8:	78850000 8f0aaa0b 780a7124 20cae08a     ...x....$q.x... 
   19fd8:	09d902a5 29418024 40a107c2 78e0c7ca     ....$.A)...@...x
   19fe8:	008041c3 81201b6c 7fe0a020 78e0700c     .A..l. . ....p.x
   19ff8:	008041c3 81201b70 7fe0a020 78e0700c     .A..p. . ....p.x
   1a008:	008041c3 81201b68 7fe0a020 78e0700c     .A..h. . ....p.x
   1a018:	008041c3 81201b90 7fe0a020 78e0700c     .A.... . ....p.x
   1a028:	008041c3 81201b9c 7fe0a020 78e0700c     .A.... . ....p.x
   1a038:	008041c3 810e1b68 812f7fe0 008040c3     .A..h...../..@..
   1a048:	7fe01bb0 78e08800 008041c3 704c1b68     .......x.A..h.Lp
   1a058:	3f7843c3 a14f0000 a14ca14e 01411934     .Cx?..O.N.L.4.A.
   1a068:	44cba160 33333f33 3dcc43c3 a181cccd     `..D3?33.C.=....
   1a078:	43c3a162 66663f26 a164a163 414043c3     b..C&?ffc.d..C@A
   1a088:	19400000 a18900c1 a148a14b a146a147     ..@.....K.H.G.F.
   1a098:	a16aa145 700ca151 a1527fe0 008041c3     E.j.Q..p..R..A..
   1a0a8:	700c1b68 7fe0a10f 78e0a10e 008041c3     h..p.......x.A..
   1a0b8:	a1001b6c 700c7fe0 008041c3 a1001b70     l......p.A..p...
   1a0c8:	700c7fe0 008041c3 a1001b68 700c7fe0     ...p.A..h......p
   1a0d8:	008041c3 a1001b90 700c7fe0 008041c3     .A.........p.A..
   1a0e8:	a1001b9c 700c7fe0 46cbc2f8 1b680080     .......p...F..h.
   1a0f8:	10011e48 443086a5 b8bf4310 1618b9bf     H.....0D.C......
   1a108:	161c1011 47481010 45304210 036f0ec2     ......HG.B0E..o.
   1a118:	24caa6a6 275024c9 245017c1 0eb227c0     ...$.$P'..P$.'..
   1a128:	4330036f 150927ca 25403201 3f4044d3     o.0C.'...2@%.D@?
   1a138:	bfbf0000 04c13001 25802450 15023700     .....0..P$.%.7..
   1a148:	00003100 036f0da6 00803001 ed0942c3     .1....o..0...B..
   1a158:	43c37b42 b4253fe7 034f0892 034f0ce6     B{.C.?%...O...O.
   1a168:	3e8042d3 30000000 30000482 31012481     .B.>...0...0.$.1
   1a178:	244f0083 310027c1 35002482 31011041     ..O$.'.1.$.5A..1
   1a188:	33020081 a6e5004f 1624a607 86031011     ...3O.....$.....
   1a198:	30028621 31000440 31010000 1e0c2015     !..0@..1...1. ..
   1a1a8:	86041540 04403002 00003100 20103101     @....0@..1...1. 
   1a1b8:	14001e10 68a1860b 8622a6ab 24403502     .......h.."..5@$
   1a1c8:	036f0e0e f6464330 24d53101 15401e0c     ..o.0CF..1.$..@.
   1a1d8:	0dfe40e1 41a2036f 000c00a2 8610a6e3     .@..o..A........
   1a1e8:	0091089b e8338611 11d40d63 10161638     ......3.c...8...
   1a1f8:	1017163c a0412640 a0002741 a62ea60f     <...@&A.A'......
   1a208:	10151628 089640a1 350103af 45082558     (....@.....5X%.E
   1a218:	30003002 404041c3 0db60000 b8bf036f     .0.0.A@@....o...
   1a228:	2640f647 2741a081 a60fa000 3500a62e     G.@&..A'.......5
   1a238:	35001480 30012501 70ad0040 10411e40     ...5.%.0@..p@.A.
   1a248:	a6aba60a 10411e48 e899f019 11f40d2f     ....H.A...../...
   1a258:	a652714c 70ad860c a60c7104 a650a6ab     LqR....p.q....P.
   1a268:	081b862d 862e0044 2100866f 23418001     -...D...o..!..A#
   1a278:	a60f8000 a6aca62e 3102a651 0d522400     ........Q..1.$R.
   1a288:	4162036f 3102f645 1e1024d0 40e11400     o.bAE..1.$.....@
   1a298:	036f0d3e f6454102 1e40a6e4 0d171081     >.o..AE...@.....
   1a2a8:	40c31994 00004140 10011e44 10011e30     ...@@A..D...0...
   1a2b8:	8600a60a 20013100 70003602 00003f80     .....1. .6.p.?..
   1a2c8:	10003700 00013101 a629700c 78e0c6d8     .7...1...p)....x
   1a2d8:	41c3c0f1 12200080 702c8140 c0d15ace     ...A.. .@.,p.Z..
   1a2e8:	700c7fe0 c1a5c3e4 c0804508 07af0de6     ...p.....E......
   1a2f8:	0e02c680 2440076f 141334c0 382f3080     ....o.@$.4...0/8
   1a308:	c0430003 0000204a 71048620 0f813900     ..C.J .. ..q.9..
   1a318:	ac123c20 80f208f5 10501e04 70801600      <........P....p
   1a328:	1fe40080 017e080d 8548d8f9 5acdc180     ......~...H....Z
   1a338:	008040c3 0f2613e0 c180fdef 00422084     .@....&...... B.
   1a348:	8042208c 8528f40d 008040c3 a0201220     . B...(..@.. . .
   1a358:	702c8548 5ace40a1 40a1702c 700c5add     H.,p.@.Z,p.@.Z.p
   1a368:	78e0c7c4 40c3c0f1 13e00080 fdcf0eea     ...x...@........
   1a378:	7fe0c0d1 78e0700c f003702c 08017124     .....p.x,p..$q..
   1a388:	781d0071 7fe0710c 78e07838 1863702c     q..x.q..8x.x,pc.
   1a398:	18680042 7fe00042 00421867 47cbc2ee     B.h.B...g.B....G
   1a3a8:	7fff0000 78f24310 46284250 00512040     .....C.xPB(F@ Q.
   1a3b8:	70ad4010 0c328600 3000036f 41e104c0     .@.p..2.o..0...A
   1a3c8:	21ca70f1 20cc000c 21ca840c 71a5044c     .p.!... ...!L..q
   1a3d8:	20541a02 90f20de1 c6ce74c5 4508c2e2     ..T .....t.....E
   1a3e8:	04af09e2 00c01005 0b8ee805 150504af     ................
   1a3f8:	c6c210c0 41c3c0f1 12340080 702c8140     .......A..4.@.,p
   1a408:	c0d15ace 700c7fe0 8028c2e2 40c34508     .Z.....p..(..E.@
   1a418:	12340080 8548a020 40a1702c 702c5ace     ..4. .H.,p.@.Z,p
   1a428:	5add40a1 c6c2700c 700c7fe0 4508c2e2     .@.Z.p.....p...E
   1a438:	00801072 b8c6d9b1 10021d72 066f0afe     r.......r.....o.
   1a448:	710c8d04 8d045aa2 066f0d02 710c702c     ...q.Z....o.,p.q
   1a458:	8d045aa2 066f0c1e 710c702c 700c5aa2     .Z....o.,p.q.Z.p
   1a468:	78e0c6c2 4508c2e2 00c01072 00320845     ...x...Er...E.2.
   1a478:	0cbed91e 8d04066f 5aa2710c 0c368d04     ....o....q.Z..6.
   1a488:	702c066f 5aa2710c 0c6a8d04 712c066f     o.,p.q.Z..j.o.,q
   1a498:	5aa2710c 0cb68d04 712c066f 5aa2710c     .q.Z....o.,q.q.Z
   1a4a8:	0bd28d04 712c066f 5aa2710c 10801572     ....o.,q.q.Zr...
   1a4b8:	01c1204f 1d72700c c6c21042 710c7fe0     O ...pr.B......q
   1a4c8:	008040c3 7fe01240 78e08000 4528c2e2     .@..@......x..(E
   1a4d8:	00c11172 00330915 7a604200 157240a1     r.....3..B`z.@r.
   1a4e8:	b8c61080 10021d72 78e0c6c2 7fe0d87f     ....r......x....
   1a4f8:	78e0b817 7fe0d87f 78e0b817 008043c3     ...x.......x.C..
   1a508:	218a36b0 b3260b1d 0406218a d925b327     .6.!..&..!..'.%.
   1a518:	704cb328 008041c3 1b121288 b34c0305     (.Lp.A........L.
   1a528:	ab5d700c b1407fe0 c1a1c3e4 7fc51e00     .p]...@.........
   1a538:	201a0080 88044508 2440702c 716c30c2     ... .E..,p@$.0lq
   1a548:	de225abf 1403e89c de213080 0080206c     .Z"......0!.l ..
   1a558:	8403208c 0c5af414 8d04feaf 1c03e890     . ....Z.........
   1a568:	8d043043 2440d954 716c30c2 710c5ac1     C0..T.@$.0lq.Z.q
   1a578:	700c5aa2 0020092e 70cd41a1 c7c440c1     .Z.p.. ..A.p.@..
   1a588:	45cbc0e6 36b00080 85818560 240585c2     ...E...6`......$
   1a598:	230510cb f40893be 44284648 a5004300     ...#....HF(D.C..
   1a5a8:	a542a521 efa895ea 2b424873 150c07cf     !.B.....sHB+....
   1a5b8:	63fb110b 0bb37be7 499310e2 07cc2b42     ...c.{.....IB+..
   1a5c8:	7b87639b 10e20ba3 2b424ad3 639b07cc     .c.{.....JB+...c
   1a5d8:	0b977b87 8d1c10c2 005108af 7104950b     .{........Q....q
   1a5e8:	9529b50b 09a37810 1d160003 1d1c1005     ..)..x..........
   1a5f8:	f04b1003 10510f15 44284648 a5004300     ..K...Q.HF(D.C..
   1a608:	a542a521 10051d16 28427862 150e07c3     !.B.....bxB(....
   1a618:	6078110b 086b7867 499002e3 07c12842     ..x`gxk....IB(..
   1a628:	78276038 02e3085b 28424ad0 603807c1     8`'x[....JB(..8`
   1a638:	084f7827 41c302c3 12880080 78e29100     'xO....A.......x
   1a648:	07c32842 78676078 080d7810 8d5d0071     B(..x`gx.x..q.].
   1a658:	ad5d7144 082f784d b1e000b2 10031d1c     Dq].Mx/.........
   1a668:	10051d14 8d7cf019 706c7174 a500f410     ......|.tqlp....
   1a678:	a542a521 10451d18 b56bad7c 1d1df00d     !.B...E.|.k.....
   1a688:	6f091003 1d18b50a f0071005 10431d1c     ...o..........C.
   1a698:	b50a9508 700cb56c 78e0c4c6 710c7fe0     ....l..p...x...q
   1a6a8:	4628c2ec 04af0966 093e4508 411004af     ..(Ff....E>....A
   1a6b8:	710c4100 40304222 47085ab1 4102d812     .A.q"B0@.Z.G...A
   1a6c8:	5ab14222 d8134210 42224102 40105ab1     "B.Z.B...A"B.Z.@
   1a6d8:	9fc3258c 9f8225cc 00800000 0d55f219     .%...%........U.
   1a6e8:	40e110b5 064f0e5a 0e56e80d 4042066f     ...@Z.O...V.o.B@
   1a6f8:	0e4ee809 4002066f 8e04e805 feaf0a22     ..N.o..@...."...
   1a708:	1672702c b8c61080 10021e72 8728f00b     ,pr.....r.....(.
   1a718:	40e17960 8fc3208c 8e04f205 feaf0a02     `y.@. ..........
   1a728:	42c3d980 12400080 41c1700c 5ad5a2a0     ...B..@..p.A...Z
   1a738:	008040c3 80001240 78e0c6cc 700cc0f1     .@..@......x...p
   1a748:	d87f5ad7 7fe0c0d1 78e0b817 c1a1c0f1     .Z.........x....
   1a758:	008041c3 9160122c c1808141 30c41c00     .A..,.`.A......0
   1a768:	74875ace 7fe0c0d1 78e0700c c1a1c3e2     .Z.t.....p.x....
   1a778:	dd248021 8131e912 008043c3 9140122c     !.$...1..C..,.@.
   1a788:	0a199320 70ad0060 8028b340 30841c00      ...`..p@.(....0
   1a798:	8048a321 5acec180 c7c240a1 700c7fe0     !.H....Z.@.....p
   1a7a8:	41c3c0f1 12280080 702c8140 c0d15ace     ...A..(.@.,p.Z..
   1a7b8:	700c7fe0 8048c0f1 008041c3 a1401228     ...p..H..A..(.@.
   1a7c8:	702c8048 c0d15ace 700c7fe0 700c7fe0     H.,p.Z.....p...p
   1a7d8:	0816c2e4 460804af 04af0832 42004508     .......F2....E.B
   1a7e8:	41a1d813 45cb5ab1 12640080 ee85a500     ...A.Z.E..d.....
   1a7f8:	85205ab5 c6c45ad4 45cbc2e4 12500080     .Z ..Z.....E..P.
   1a808:	10c1150c 0f724608 4020046f 08268e04     .....Fr.o. @..&.
   1a818:	702c066f 5aa2710c 700c9520 c6c4b525     o.,p.q.Z ..p%...
   1a828:	4608c2e4 90039042 008045cb 85241250     ...FB....E..P.$.
   1a838:	7845b810 8002218c 8f8221cc 00ff0000     ..Ex.!...!......
   1a848:	780ff410 062f0f9e 8e04702c 062f0fe6     ...x../.,p..../.
   1a858:	710c712c 0c925aa2 150c0020 f00810c0     ,q.q.Z.. .......
   1a868:	0fd2780f 702c062f 5aa2710c c6c4700c     .x../.,p.q.Z.p..
   1a878:	000040c3 7ee0ffff 008040c3 7fe01260     .@.....~.@..`...
   1a888:	78e08000 42c3c0f1 12500080 8904a201     ...x...B..P.....
   1a898:	e2084520 726cd978 007f44c3 5ac0d484      E..x.lr.D.....Z
   1a8a8:	7ee0c0d1 7fe0d87f 78e0b817 7fe0d87f     ...~.......x....
   1a8b8:	78e0b817 e88fc2e2 008043c3 8b491250     ...x.....C..P.I.
   1a8c8:	93a58b08 8381ba08 62ba7a05 7c604020     .........z.b @`|
   1a8d8:	c6c2b340 c1a1c3e6 7fc51e00 201e0080     @.............. 
   1a8e8:	88044508 2440702c 716c30c2 de225abf     .E..,p@$.0lq.Z".
   1a8f8:	1403e8ac de213080 0080206c 8403208c     .....0!.l ... ..
   1a908:	08aef424 8d04feaf 1c03e8a0 8d043043     $...........C0..
   1a918:	2440d954 716c30c2 710c5ac1 700c5aa2     T.@$.0lq.Z.q.Z.p
   1a928:	00200836 47cb41a1 12500080 10c0170c     6. ..A.G..P.....
   1a938:	0c5670cd b7c5046f 41c3d814 d3a0007f     .pV.o......A....
   1a948:	00200c2e af0c42a1 c7c640c1 000040c3     .. ..B...@...@..
   1a958:	7ee0ffff 4628c2ec 046f0eb2 0e8a4508     ...~..(F..o..E..
   1a968:	4110046f 710c4100 40304222 47085ab1     o..A.A.q"B0@.Z.G
   1a978:	4102d811 5ab14222 d8124210 42224102     ...A"B.Z.B...A"B
   1a988:	40105ab1 9fc3258c 9f8225cc 00800000     .Z.@.%...%......
   1a998:	0d79f220 40e110b5 064f0ba6 0ba2e80d      .y....@..O.....
   1a9a8:	4002066f 0b9ae809 4042066f 8e04e805     o..@....o.B@....
   1a9b8:	fe6f0f6e 40c3702c 125c0080 046f0dba     n.o.,p.@..\...o.
   1a9c8:	00c01000 10801672 1e72b8c6 f0171002     ....r.....r.....
   1a9d8:	79608728 208c40e1 f2068fc3 0f428e04     (.`y.@. ......B.
   1a9e8:	d980fe6f 10c01672 00130813 008040c3     o...r........@..
   1a9f8:	0af6125c 10000020 42c300c0 12600080     \... ......B..`.
   1aa08:	41c1700c 5ad5a2a0 008040c3 80001260     .p.A...Z.@..`...
   1aa18:	78e0c6cc 700cc0f1 d87f5ad7 7fe0c0d1     ...x...p.Z......
   1aa28:	78e0b817 4508c2e2 00801072 b8c6702c     ...x...Er...,p..
   1aa38:	10021d72 062f0f6e 8d048d04 062f0dba     r...n./......./.
   1aa48:	41c3702c 12480080 1900700c c6c20005     ,p.A..H..p......
   1aa58:	4508c2e2 00c01072 00320823 0f46712c     ...Er...#.2.,qF.
   1aa68:	8d04062f 0d928d04 712c062f 008040c3     /......./.,q.@..
   1aa78:	18001248 15720005 204f1080 700c01c1     H.....r...O ...p
   1aa88:	10421d72 78e0c6c2 710c7fe0 008040c3     r.B....x...q.@..
   1aa98:	7fe0124c 78e08000 45cbc2ea 12440080     L......x...E..D.
   1aaa8:	47089542 41306a01 ea18b502 2008202f     B..G.j0A..../ . 
   1aab8:	08115ab5 460820b1 7f604022 c6caa5c0     .Z... .F"@`.....
   1aac8:	4e108500 8059208c 7f60f785 a5c04022     ...N. Y...`."@..
   1aad8:	9502c6ca b5027704 78e0c6ca 7fe0d87f     .....w.....x....
   1aae8:	78e0b817 7fe0d87f 78e0b817 c1a1c3e4     ...x.......x....
   1aaf8:	7fc51e00 201c0080 88044508 2440702c     ....... .E..,p@$
   1ab08:	716c30c2 de225abf 1403e89c de213080     .0lq.Z"......0!.
   1ab18:	0080206c 8403208c 0e96f414 8d04fe6f     l ... ......o...
   1ab28:	1c03e890 8d043043 2440d954 716c30c2     ....C0..T.@$.0lq
   1ab38:	710c5ac1 700c5aa2 00200812 70cd41a1     .Z.q.Z.p.. ..A.p
   1ab48:	c7c440c1 710c7fe0 4628c2ec 046f0cbe     .@.....q..(F..o.
   1ab58:	0c964508 4110046f 710c4100 40304222     .E..o..A.A.q"B0@
   1ab68:	47085ab1 4102d811 5ab14222 d8134210     .Z.G...A"B.Z.B..
   1ab78:	42224102 40105ab1 9fc3258c 9f8225cc     .A"B.Z.@.%...%..
   1ab88:	00800000 0d55f219 40e110b5 064f09b2     ......U....@..O.
   1ab98:	09aee80d 4002066f 09a6e809 4042066f     ....o..@....o.B@
   1aba8:	8e04e805 fe6f0d7a 1672702c b8c61080     ....z.o.,pr.....
   1abb8:	10021e72 8728f00b 40e17960 8fc3208c     r.....(.`y.@. ..
   1abc8:	8e04f205 fe6f0d5a 42c3d980 124c0080     ....Z.o....B..L.
   1abd8:	41c1700c 5ad5a2a0 008040c3 8000124c     .p.A...Z.@..L...
   1abe8:	78e0c6cc 700cc0f1 d87f5ad7 7fe0c0d1     ...x...p.Z......
   1abf8:	78e0b817 c1a5c3e4 70811600 1fe40080     ...x.......p....
   1ac08:	01be093d c0804508 5aa4c680 34c02440     =....E.....Z@$.4
   1ac18:	14135aa3 382f3080 c0430003 0000204a     .Z...0/8..C.J ..
   1ac28:	71048620 0f813900 ac123c20 80f208f5      ..q.9.. <......
   1ac38:	10501e04 d8fb8548 5acdc180 06ef0fc2     ..P.H......Z....
   1ac48:	c7c440a1 4608c2ea f2437014 b8e48e00     .@.....F.pC.....
   1ac58:	9602f43f 40d370ad 1e8c0080 70ed7104     ?....p.@.....q.p
   1ac68:	2008212f 00000007 100071e5 78ed2081     /!. .....q... .x
   1ac78:	00630841 080e70b5 7014044f 838220cc     A.c..p..O..p. ..
   1ac88:	9020f3f4 807e09e5 9042b9e4 79306a21     .. ...~...B.!j0y
   1ac98:	edecf206 04412139 f1e8e90a f21a7132     ....9!A.....2q..
   1aca8:	847e2909 2909f204 f5e0a07e f1de4508     .)~....)~....E..
   1acb8:	272ff20f 236f007f 9503003f 28097104     ../'..o#?....q.(
   1acc8:	70c30440 ffff0000 262fb603 c6ca007f     @..p....../&....
   1acd8:	007f272f 003f236f b6039003 007f262f     /'..o#?...../&..
   1ace8:	78e0c6ca 0f9ec2e2 4508040f 8d00e834     ...x.......E4...
   1acf8:	007f0865 0f5240a1 0da6ffcf 702cff4f     e....@R.....O.,p
   1ad08:	e80ab98b 06e221ab b8819500 21abb500     .....!.........!
   1ad18:	f01a06a2 704c9500 103c248a b500b881     ......Lp.$<.....
   1ad28:	07a122ab 076120aa 2004716c b8810302     ."... a.lq. ....
   1ad38:	7845780f 076120ab 076221ab 06a221ab     .xEx. a..!b..!..
   1ad48:	076123ab 000040c3 e8060000 0f802022     .#a..@......" ..
   1ad58:	00000000 78e0c6c2 0f2ac0f1 4100040f     .......x..*....A
   1ad68:	e903700c c0d19101 78e07ee0 0fbec2e2     .p.......~.x....
   1ad78:	080d040f 45080033 5accd8a0 c6c240a1     ....3..E...Z.@..
   1ad88:	4010c2ea 042f0efe 45084728 70b5d8ff     ...@../.(G.E...p
   1ad98:	8d20f230 f22eb9e0 047f272f 003f236f     0. ...../'..o#?.
   1ada8:	ff4f0cfe e8064608 76e226ab 08000000     ..O..F...&.v....
   1adb8:	047f262f 20aab5e1 d9200422 b8c1b822     /&..... ". ."...
   1adc8:	00002900 0a0f209a 03c12805 b8e18d00     .)... ...(......
   1add8:	000071c3 4020ffff f403b522 0e6ab503     .q.... @".....j.
   1ade8:	40a1ffef 26abee05 000076a2 40020800     ...@...&.v.....@
   1adf8:	c6ca780d 4508c2e6 70cd8007 8508e810     .x.....E...p....
   1ae08:	40a1e80e 85285abc 79604708 0f1140a1     ...@.Z(..G`y.@..
   1ae18:	40e11020 7a608547 71cd41a1 c6c640c1      ..@G.`z.A.q.@..
   1ae28:	c1a3c3ea 88154708 b8c14150 00b008e7     .....G..PA......
   1ae38:	16004628 0080700d 24401f34 c28232c1     (F...p..4.@$.2..
   1ae48:	31832440 30842440 31452440 5ab440e1     @$.1@$.0@$E1.@.Z
   1ae58:	31021402 2140214f 21412150 0290205a     ...1O!@!P!A!Z ..
   1ae68:	0280215a 200072d1 651d2350 2111216c     Z!...r. P#.el!.!
   1ae78:	2831090f 108526ca 23841802 b5c1f002     ..1(.&.....#....
   1ae88:	08218f15 40a1017e 04cf0df2 04ef0dee     ..!.~..@........
   1ae98:	10024002 e8842100 e8339501 f03171cd     .@...!....3..q1.
   1aea8:	21011002 09419501 20080020 e91c004e     ...!..A. .. N...
   1aeb8:	40e1e81a 09225ab3 1402030f e88f3101     ...@.Z"......1..
   1aec8:	714c8f76 0000000d 7144785b 000122ca     v.Lq....[xDq."..
   1aed8:	00802904 83a508f5 091bbbe0 42a12831     .)..........1(.B
   1aee8:	f00b4302 04ef0d96 0d9240a1 400204ef     .C.......@.....@
   1aef8:	4202f007 082243a1 44e1feef 97134608     ...B.C"....D.F..
   1af08:	03800813 10431f12 1e00b7d3 00807043     ......C.....Cp..
   1af18:	c7ca1f96 006041c3 42c3c4a0 bcc00060     .....A`....B`...
   1af28:	455043c3 03b9d4dd 78e0ff4f 006041c3     .CPE....O..x.A`.
   1af38:	42c3dee4 c8380060 ff4f0391 006041c3     ...B`.8...O..A`.
   1af48:	42c3cba0 bcc00060 455043c3 0391d4dd     ...B`....CPE....
   1af58:	78e0ff4f 45cbc2e2 975e0060 30001400     O..x...E`.^....0
   1af68:	03410815 0ce020aa 5acc780f 1c004d1e     ..A.. ...x.Z.M..
   1af78:	c6c23000 05cf0bca 78e0c6c2 41c3c0f1     .0.........x...A
   1af88:	121c0080 702c8140 c0d15ace 700c7fe0     ....@.,p.Z.....p
   1af98:	c1a5c3e4 c0804508 076f093a 0956c680     .....E..:.o...V.
   1afa8:	2440072f 141334c0 382f3080 c0430003     /.@$.4...0/8..C.
   1afb8:	0000204a 71048620 0f813900 ac123c20     J .. ..q.9.. <..
   1afc8:	80f208f5 10501e04 70801600 1fe40080     ......P....p....
   1afd8:	00fe080d 8548d8fb 5acdc180 008040c3     ......H....Z.@..
   1afe8:	0c7e1388 c180fdaf 00422084 8042208c     ..~...... B.. B.
   1aff8:	8528f40d 008040c3 a020121c 702c8548     ..(..@.... .H.,p
   1b008:	5ace40a1 40a1702c 700c5add 78e0c7c4     .@.Z,p.@.Z.p...x
   1b018:	41c3c0f1 1ff80080 40c39156 13880080     ...A....V..@....
   1b028:	fdaf0c3a c0d1b157 700c7fe0 0d7ac2e4     :...W......p..z.
   1b038:	4528066f 10710d23 0fc64608 0fe6040f     o.(E#.q..F......
   1b048:	4508042f d8174200 5ab641a1 880de805     /..E.B...A.Z....
   1b058:	d8c87014 40c1f402 0000c6c4 02494e49     .p.....@....INI.
   1b068:	007fde98 00000004 008012f8 007fde9c     ................
   1b078:	00000008 008012d0 00801300 007fdea4     ................
   1b088:	00000004 00801308 007fdea8 00000004     ................
   1b098:	00801310 007fdeac 00000008 008012c8     ................
   1b0a8:	008012f0 007fdeb4 00000004 008012e8     ................
   1b0b8:	007fdeb8 00000004 008012d8 008011f0     ................
   1b0c8:	00000174 00000000 00000000 00000000     t...............
	...
   1b138:	000000ff 00000000 00000000 00000023     ............#...
	...
   1b1a4:	00000006 007fa994 00000006 007fa954     ............T...
   1b1b4:	00000005 007fc90c 007fdebc 007fe114     ................
   1b1c4:	00000005 0060a87c 00000005 0060add4     ....|.`.......`.
   1b1d4:	00000005 0060ab60 00000005 0060b044     ....`.`.....D.`.
   1b1e4:	00000005 007fa944 00000005 0060ab8c     ....D.........`.
   1b1f4:	007fde98 007fde9c 007fde9c 007fdea4     ................
   1b204:	007fdea4 007fdea8 007fdea8 007fdeac     ................
   1b214:	007fdeac 007fdeb4 007fdeb4 007fdeb8     ................
   1b224:	007fdeb8 007fdeb8 007fdeb8 007fdebc     ................
   1b234:	0060c378 0060be34 0060c6ec 00000000     x.`.4.`...`.....
   1b244:	00000000 000e1001 fdf7fef8 0000fcf6     ................
   1b254:	00100e01 00060019 00070032 00080064     ........2...d...
   1b264:	000900c8 000a0190 0101000e 880c0901     ................
   1b274:	01011013 00002a71 000300fa 390b7d77     ....q*......w}.9
   1b284:	000201f4 398bb3fb 000103e8 3a0b7d77     .......9....w}.:
   1b294:	000007d0 3a8b7d77 00060019 00070032     ....w}.:....2...
   1b2a4:	00080064 000900c8 000a0190 3d01ccaf     d..............=
   1b2b4:	bdc2b307 3dc2b307 bd01ccaf 3f800000     .......=.......?
   1b2c4:	3fbac177 3f690df1 3e4a92b0 00000000     w..?..i?..J>....
	...
   1b2f8:	01902f69 0000012d 00000000 00000000     i/..-...........
   1b308:	00000a11 007fd0f8 007fd270 007fd090     ........p.......
   1b318:	007fd30c 007fd0bc 007fd034 007fcffc     ........4.......
   1b328:	007fd0c4 007fd09c 007fd26c 007fd08c     ........l.......
	...
   1b348:	3d75c28f 00000000 00010000 00010001     ..u=............
	...
   1b364:	00010000 00000000 00000000 01902f69     ............i/..
   1b374:	0000012e 00000000 00000000 00000a12     ................
   1b384:	007fd6bc 007fd718 007fd65c 007fd7b4     ........\.......
   1b394:	007fd6ac 007fd620 007fd5f4 007fd6b4     .... ...........
   1b3a4:	007fd668 007fd714 007fd658 00000000     h.......X.......
	...
   1b3c0:	3d75c28f 00000000 00010000 00010001     ..u=............
	...
   1b3dc:	00010000 00000000 00000000 01902f69     ............i/..
   1b3ec:	0010012f 00000000 00000000 00000a13     /...............
   1b3fc:	007fd4a4 007fd524 007fd448 007fd5e4     ....$...H.......
   1b40c:	007fd474 007fd3f0 007fd3c8 007fd47c     t...........|...
   1b41c:	007fd454 007fd51c 007fd440 00801250     T.......@...P...
	...
   1b438:	3d75c28f 00000000 00010000 0001ffff     ..u=............
	...
   1b454:	00010000 00000000 00000000 01900869     ............i...
   1b464:	00100130 00000000 00000000 00000201     0...............
   1b474:	007fa7c8 007fa804 0060a140 007fa8b4     ........@.`.....
   1b484:	0060a14c 0060a6c8 0060a708 0060a158     L.`...`...`.X.`.
   1b494:	0060a4bc 0060a604 0060a134 008028c4     ..`...`.4.`..(..
   1b4a4:	008022cc 00000000 00000000 3e051eb8     .".............>
   1b4b4:	00000000 01900000 00010010 00000000     ................
   1b4c4:	00ff0000 00000001 00030100 00000000     ................
   1b4d4:	00000000 01902f69 00100131 00000000     ....i/..1.......
   1b4e4:	00000000 00000210 007fbc40 007fbcc0     ........@.......
   1b4f4:	007fbbac 007fbd1c 007fbbe4 007fbb60     ............`...
   1b504:	007fbb28 007fbbf0 007fbbb8 007fbc7c     (...........|...
   1b514:	007fbba0 00801b34 007fde34 00000000     ....4...4.......
   1b524:	00000000 3f4ccccd 00000000 01900000     ......L?........
   1b534:	000103e8 00000000 00ff0000 00000001     ................
   1b544:	00030100 00000000 00000000 00000116     ................
   1b554:	000001e9 00000000 00000000 00003419     .............4..
   1b564:	00000000 00000004 00000000 00000000     ................
   1b574:	007fcf34 007fceb4 007fcea0 00000000     4...............
   1b584:	00000116 000001ea 00000000 00000000     ................
   1b594:	00003418 00000000 00000004 00000000     .4..............
   1b5a4:	00000000 007fbb14 007fba94 007fba80     ................
   1b5b4:	00000000 00000116 000001eb 00000000     ................
   1b5c4:	00000000 0000341f 00000000 02000004     .....4..........
	...
   1b5dc:	0060b85c 007fa444 0060b930 00000000     \.`.D...0.`.....
   1b5ec:	00000212 000001ed 00000000 00000000     ................
   1b5fc:	00003012 00000212 00000006 00000000     .0..............
   1b60c:	00000000 007fd39c 007fd384 007fd370     ............p...
   1b61c:	00000000 00000213 000001ee 00000000     ................
   1b62c:	00000000 00003013 00000213 02000006     .....0..........
	...
   1b644:	007fd36c 007fd33c 007fd31c 00000000     l...<...........
   1b654:	00000211 000001ef 00000000 00000000     ................
   1b664:	00002411 00000211 00000006 00000000     .$..............
   1b674:	00000000 007fcff8 007fcfd8 007fcfc4     ................
	...
   1b68c:	000001f0 00000000 00000000 00000041     ............A...
   1b69c:	00000000 00000007 00000000 00000000     ................
   1b6ac:	00000000 0060adb0 00000000 00000000     ......`.........
   1b6bc:	00000140 000001f1 00000000 00000000     @...............
   1b6cc:	00000001 00000201 07000002 00000000     ................
	...
   1b6e4:	007fdae4 00000000 00000000 00000140     ............@...
   1b6f4:	000001f3 00000000 00000000 00000004     ................
   1b704:	00000210 07000002 00000000 00000000     ................
   1b714:	00000000 007fdafc 00000000 00000000     ................
   1b724:	00000140 000001f4 00000000 00000000     @...............
   1b734:	00000010 00000210 0d000002 00000000     ................
	...
   1b74c:	0060b5d4 00000000 00000000 00000140     ..`.........@...
   1b75c:	000001f6 00000000 00000000 0000000a     ................
   1b76c:	00000201 07000002 00000000 00000000     ................
   1b77c:	00000000 007fdb0c 00000000 00000000     ................
   1b78c:	00000140 000001f7 00000000 00000000     @...............
   1b79c:	00000009 00000201 07000002 00000000     ................
	...
   1b7b4:	0060b3fc 00000000 00000000 00000140     ..`.........@...
   1b7c4:	000001fc 00000000 00000000 0000000f     ................
   1b7d4:	00000000 0a000002 00000000 00000000     ................
   1b7e4:	00000000 0060b4a4 00000000 00000000     ......`.........
   1b7f4:	001e0000 000001e0 00000000 00000000     ................
   1b804:	00004150 00000000 00000002 00000000     PA..............
	...
   1b81c:	007fad94 00000000 00000000 00c80000     ................
   1b82c:	000001e8 00000000 00000000 00003517     .............5..
   1b83c:	00000000 00000003 00000000 00000000     ................
   1b84c:	007fdbe0 007fdb60 007fdb4c 00000000     ....`...L.......
   1b85c:	00320000 000001ec 00000000 00000000     ..2.............
   1b86c:	00003516 00000000 00000004 00000000     .5..............
   1b87c:	00000000 0060b7bc 007fd7c4 0060b848     ......`.....H.`.
   1b88c:	00000000 00c80042 000001f0 00000000     ....B...........
   1b89c:	00000000 00000140 00000000 00000002     ....@...........
	...
   1b8b4:	007fabf4 007faa50 00000000 0000c88b     ....P...........
   1b8c4:	00041105 00032a54 00000006 00000000     ....T*..........
   1b8d4:	00001555 00000000 00000000 00000000     U...............
	...

0001b8f0 <_bhi_fw_len>:
   1b8f0:	000064c8 0000a490 0000a4ea 0000a4ea     .d..............
   1b900:	0000a4ea 0000a4ea 0000a53e 0000a57a     ........>...z...
   1b910:	0000a55c 0000a53e 0000a4ea 0000a4ea     \...>...........
   1b920:	0000a49c 0000a53e 0000a55c 0000a5aa     ....>...\.......
   1b930:	0000a49c 0000a5aa 0000a59e 0000a59e     ................
   1b940:	0000a53e 0000a49c 0000a526 0000a59e     >.......&.......
   1b950:	0000a59e 0000a59e 0000a59e 0000a718     ................
   1b960:	0000a718 0000a718 0000a718 0000a718     ................
   1b970:	0000a53e 0000a718 0000a4ea 0000a4ea     >...............
   1b980:	0000a4ea 0000a4ea 0000a53e 0000a57a     ........>...z...
   1b990:	0000a55c 0000a53e 0000a4ea 0000a4ea     \...>...........
   1b9a0:	0000a49c 0000a53e 0000a55c 0000a5aa     ....>...\.......
   1b9b0:	0000a49c 0000a5aa 0000a59e 0000a59e     ................
   1b9c0:	0000a53e 0000a49c 0000a526 0000a59e     >.......&.......
   1b9d0:	0000a59e 0000a59e 0000a59e 0000a718     ................
   1b9e0:	0000a718 0000a718 0000a718 0000a718     ................
   1b9f0:	0000a53e 0000a718 0000a718 0000a718     >...............
   1ba00:	0000a718 0000a718 0000a718 0000a718     ................
   1ba10:	0000a718 0000a718 0000a718 0000a718     ................
   1ba20:	0000a718 0000a718 0000a718 0000a718     ................
   1ba30:	0000a718 0000a718 0000a718 0000a718     ................
   1ba40:	0000a718 0000a718 0000a718 0000a718     ................
   1ba50:	0000a718 0000a718 0000a718 0000a718     ................
   1ba60:	0000a718 0000a718 0000a718 0000a718     ................
   1ba70:	0000a718 0000a718 0000a718 0000a718     ................
   1ba80:	0000a718 0000a718 0000a718 0000a718     ................
   1ba90:	0000a718 0000a718 0000a718 0000a718     ................
   1baa0:	0000a718 0000a718 0000a718 0000a718     ................
   1bab0:	0000a718 0000a718 0000a718 0000a718     ................
   1bac0:	0000a718 0000a718 0000a718 0000a718     ................
   1bad0:	0000a718 0000a718 0000a718 0000a718     ................
   1bae0:	0000a718 0000a718 0000a718 0000a718     ................
   1baf0:	0000a718 0000a718 0000a718 0000a718     ................
   1bb00:	0000a718 0000a718 0000a718 0000a718     ................
   1bb10:	0000a718 0000a718 0000a718 0000a718     ................
   1bb20:	0000a718 0000a718 0000a718 0000a718     ................
   1bb30:	0000a718 0000a718 0000a718 0000a718     ................
   1bb40:	0000a718 0000a718 0000a718 0000a718     ................
   1bb50:	0000a718 0000a718 0000a718 0000a718     ................
   1bb60:	0000a718 0000a718 0000a718 0000a718     ................
   1bb70:	0000a718 0000a718 0000a718 0000a718     ................
   1bb80:	0000a718 0000a718 0000a718 0000a718     ................
   1bb90:	0000a718 0000a718 0000a718 0000a718     ................
   1bba0:	0000a718 0000a718 0000a718 0000a718     ................
   1bbb0:	0000a718 0000a718 0000a718 0000a718     ................
   1bbc0:	0000a718 0000a718 0000a718 0000a718     ................
   1bbd0:	0000a718 0000a718 0000a718 0000a718     ................
   1bbe0:	0000a718 0000a718 0000a718 0000a718     ................
   1bbf0:	0000a718 0000a718 0000a718 0000a718     ................
   1bc00:	0000a718 0000a718 0000a718 0000a718     ................
   1bc10:	0000a718 0000a718 0000a718 0000a718     ................
   1bc20:	0000a718 0000a718 0000a718 0000a718     ................
   1bc30:	0000a718 0000a718 0000a718 0000a718     ................
   1bc40:	0000a718 0000a718 0000a718 0000a718     ................
   1bc50:	0000a718 0000a718 0000a718 0000a718     ................
   1bc60:	0000a718 0000a718 0000a718 0000a718     ................
   1bc70:	0000a718 0000a718 0000a718 0000a718     ................
   1bc80:	0000a718 0000a718 0000a718 0000a718     ................
   1bc90:	0000a718 0000a718 0000a718 0000a718     ................
   1bca0:	0000a718 0000a718 0000a718 0000a718     ................
   1bcb0:	0000a718 0000a718 0000a718 0000a718     ................
   1bcc0:	0000a718 0000a718 0000a718 0000a53e     ............>...
   1bcd0:	0000a53e 0000a60a 0000a62e 0000a62e     >...............
   1bce0:	0000a62e 0000a53e 0000a53e 0000a60a     ....>...>.......

0001bcf0 <_fifoSizes>:
   1bcf0:	02080b01 01040303 0011040e 0000aa22     ............"...
   1bd00:	0000ac60 0000ac60 0000ac60 0000ac60     `...`...`...`...
   1bd10:	0000ac60 0000ac60 0000ac60 0000ac60     `...`...`...`...
   1bd20:	0000ac60 0000ac60 0000ac60 0000ac60     `...`...`...`...
   1bd30:	0000ac60 0000ac60 0000ac60 0000aa0a     `...`...`.......
   1bd40:	0000ac60 0000ac60 0000ac60 0000ac60     `...`...`...`...
   1bd50:	0000ac60 0000ac60 0000ac60 0000ac60     `...`...`...`...
   1bd60:	0000ac60 0000ac60 0000ac60 0000ac60     `...`...`...`...
   1bd70:	0000ac60 0000ac60 0000ac60 0000aa1a     `...`...`.......
   1bd80:	0000ac60 0000ac60 0000ac60 0000ac60     `...`...`...`...
   1bd90:	0000ac60 0000ac60 0000ac60 0000ac60     `...`...`...`...
   1bda0:	0000ac60 0000ac60 0000ac60 0000ac60     `...`...`...`...
   1bdb0:	0000ac60 0000ac60 0000ac60 0000aa12     `...`...`.......
   1bdc0:	0000aa2a 0000a9f2 0000aa02 0000a9fa     *...............
   1bdd0:	00000002 00000003 00000028 00000029     ........(...)...
   1bde0:	00000004 00000005 00000006 00000007     ................
   1bdf0:	0000ffff 0000ffff 00000022 00000023     ........"...#...
   1be00:	0000ffff 0000ffff 0000ffff 0000ffff     ................
   1be10:	00000008 00000009 0000000a 0000000b     ................
   1be20:	0000ffff 0000ffff 0000ffff 0000ffff     ................
   1be30:	42000000 42000400 42000800 42000c00     ...B...B...B...B
   1be40:	42001000 43000400 0b0a0908 00000d0c     ...B...C........
   1be50:	0000d26a 0000d266 0000d266 0000d2c8     j...f...f.......
   1be60:	0000d2c8 0000d280 0000d270 0000d286     ........p.......
   1be70:	0000d2b6 0000d48c 0000d46c 0000d46c     ........l...l...
   1be80:	0000d506 0000d47e 0000d49a 0000d470     ....~.......p...
   1be90:	0000d4a8 0000d4ea 0000d544 0000d586     ........D.......
   1bea0:	0000d586 0000d586 0000d536 0000d552     ........6...R...
   1beb0:	0000d528 0000d560 0000d576 0000dc7a     (...`...v...z...
   1bec0:	0000dc84 0000dc8e 0000dc98 0000dca2     ................
   1bed0:	0000dcce 0000dcd8 0000dce2 0000dcec     ................
   1bee0:	0000dcf6 42002000 42002400 43000800     ..... .B.$.B...C
   1bef0:	001d1b1b 00000002 00000100 00000002     ................
   1bf00:	00000200 00000003 00000004 74696e49     ............Init
   1bf10:	696c6169 676e697a 61655720 6c626172     ializing Wearabl
   1bf20:	65442065 44206f6d 63697665 00000065     e Demo Device...
   1bf30:	5f757063 71657266 0a64253d 00000000     cpu_freq=%d.....
   1bf40:	00000032 00000031 6d726946 65726177     2...1...Firmware
   1bf50:	72657620 6e6f6973 7325203a 0073252e      version: %s.%s.
   1bf60:	00776f70 00000000                       pow.....

0001bf68 <TWO52>:
   1bf68:	00000000 43300000 00000000 c3300000     ......0C......0.
   1bf78:	00010434 00010302 00010408 000102f8     4...............
   1bf88:	00010408 00010412 00010408 000102f8     ................
   1bf98:	00010302 00010302 00010412 000102f8     ................
   1bfa8:	000102ee 000102ee 000102ee 00010664     ............d...
   1bfb8:	00010c7c 00010b3c 00010b3c 00010b3a     |...<...<...:...
   1bfc8:	00010c54 00010c54 00010c46 00010b3a     T...T...F...:...
   1bfd8:	00010c54 00010c46 00010c54 00010b3a     T...F...T...:...
   1bfe8:	00010c5c 00010c5c 00010c5c 00010e5c     \...\...\...\...

0001bff8 <_ctype_>:
   1bff8:	20202000 20202020 28282020 20282828     .         ((((( 
   1c008:	20202020 20202020 20202020 20202020                     
   1c018:	10108820 10101010 10101010 10101010      ...............
   1c028:	04040410 04040404 10040404 10101010     ................
   1c038:	41411010 41414141 01010101 01010101     ..AAAAAA........
   1c048:	01010101 01010101 01010101 10101010     ................
   1c058:	42421010 42424242 02020202 02020202     ..BBBBBB........
   1c068:	02020202 02020202 02020202 10101010     ................
   1c078:	00000020 00000000 00000000 00000000      ...............
	...
   1c0f8:	00004300                                .C..

0001c0fc <_global_impure_ptr>:
   1c0fc:	20000140                                @.. 

0001c100 <__sf_fake_stdin>:
	...

0001c120 <__sf_fake_stdout>:
	...

0001c140 <__sf_fake_stderr>:
	...
   1c160:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
   1c170:	32313000 36353433 41393837 45444342     .0123456789ABCDE
   1c180:	31300046 35343332 39383736 64636261     F.0123456789abcd
   1c190:	00006665                                ef..

0001c194 <_init>:
   1c194:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c196:	46c0      	nop			; (mov r8, r8)
   1c198:	bcf8      	pop	{r3, r4, r5, r6, r7}
   1c19a:	bc08      	pop	{r3}
   1c19c:	469e      	mov	lr, r3
   1c19e:	4770      	bx	lr

0001c1a0 <__init_array_start>:
   1c1a0:	000000dd 	.word	0x000000dd

0001c1a4 <_fini>:
   1c1a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c1a6:	46c0      	nop			; (mov r8, r8)
   1c1a8:	bcf8      	pop	{r3, r4, r5, r6, r7}
   1c1aa:	bc08      	pop	{r3}
   1c1ac:	469e      	mov	lr, r3
   1c1ae:	4770      	bx	lr

0001c1b0 <__fini_array_start>:
   1c1b0:	000000b5 	.word	0x000000b5
