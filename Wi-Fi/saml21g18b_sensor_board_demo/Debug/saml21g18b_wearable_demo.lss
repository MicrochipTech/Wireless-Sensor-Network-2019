
saml21g18b_wearable_demo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000137c0  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000134  20000000  000137c0  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .lpram        00000000  30000000  30000000  00030134  2**0
                  CONTENTS
  3 .bss          000012ac  20000134  000138f4  00030134  2**2
                  ALLOC
  4 .stack        00002000  200013e0  00014ba0  00030134  2**0
                  ALLOC
  5 .ARM.attributes 00000028  00000000  00000000  00030134  2**0
                  CONTENTS, READONLY
  6 .comment      000000b4  00000000  00000000  0003015c  2**0
                  CONTENTS, READONLY
  7 .debug_info   00082df9  00000000  00000000  00030210  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000a9ee  00000000  00000000  000b3009  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0001e0b4  00000000  00000000  000bd9f7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00001760  00000000  00000000  000dbaab  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00001bc8  00000000  00000000  000dd20b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  000308de  00000000  00000000  000dedd3  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00030803  00000000  00000000  0010f6b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000b97cd  00000000  00000000  0013feb4  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00004770  00000000  00000000  001f9684  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:

/*! \brief  Active and low power measurement state machine
 *
 */
void touch_meas_state_machine(void)
{
       0:	200033e0 	.word	0x200033e0
	touch_ret_t touch_ret_lp = TOUCH_SUCCESS;
    uint8_t counter=0;

	switch(current_state)
       4:	00007c69 	.word	0x00007c69
       8:	00007c65 	.word	0x00007c65
       c:	00007c65 	.word	0x00007c65
	...
                    break;

          case STATE_ACTIVE_MEASURE:

                    /* STATE_ACTIVE_MEASURE: Active touch measurement  */
					if(p_selfcap_measure_data->measurement_done_touch==0)
      2c:	00007c65 	.word	0x00007c65
	...
					{
						touch_sensors_measure();
						sleep_Enable=1;
      38:	00007c65 	.word	0x00007c65
					}

					if(p_selfcap_measure_data->measurement_done_touch==1)
      3c:	00007c65 	.word	0x00007c65
      40:	00007c65 	.word	0x00007c65
      44:	00005255 	.word	0x00005255
                    {
                       p_selfcap_measure_data->measurement_done_touch=0;
      48:	000061b5 	.word	0x000061b5
					   
					   if(system_state == SYSTEM_STANDBY)
      4c:	000063b9 	.word	0x000063b9
      50:	00007c65 	.word	0x00007c65
					   {
						   if(p_selfcap_measure_data->p_sensor_states[0] & 0x04)
      54:	00007c65 	.word	0x00007c65
      58:	00007c65 	.word	0x00007c65
      5c:	00005f69 	.word	0x00005f69
						   {							   
							   long_press_timer++;
      60:	00006a0d 	.word	0x00006a0d
      64:	00006a1d 	.word	0x00006a1d
      68:	00006a2d 	.word	0x00006a2d
							   if(long_press_timer > TOUCH_LONG_PRESS_TIME)
      6c:	00006a3d 	.word	0x00006a3d
							   {
									system_state = SYSTEM_ACTIVE;
      70:	00006a4d 	.word	0x00006a4d
									long_press_timer = 0;
      74:	00006a5d 	.word	0x00006a5d
      78:	00007c65 	.word	0x00007c65
									
									/* enable hw timer used by BLE */
									enable_hw_timer();
      7c:	00007c65 	.word	0x00007c65
									/* enable ble uart */
									enable_usart();
      80:	00007c65 	.word	0x00007c65
									/* enable i2c peripheral */
									enable_i2c();
      84:	000078f5 	.word	0x000078f5
									
									/* Start the advertisement */
									wbe_start_advertisement();
      88:	00007905 	.word	0x00007905
	...
									DBG_LOG("System Active");							   
      94:	00007915 	.word	0x00007915
						   }
					   }
					   else
					   {
						   /* check swipe gesture */
						   touch_check_swipe();
      98:	00004975 	.word	0x00004975
					   }					   	

					   if ((p_selfcap_measure_data->p_sensor_states[0] != 0) )
      9c:	00007c65 	.word	0x00007c65
      a0:	00007c65 	.word	0x00007c65
      a4:	00009475 	.word	0x00009475
                       {
						    if(drift_wakeup==1)
      a8:	00007c65 	.word	0x00007c65
      ac:	00007c65 	.word	0x00007c65
						    {
							    set_time_to_measure_count();
      b0:	00000000 	.word	0x00000000

000000b4 <__do_global_dtors_aux>:
								drift_wakeup=0;
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
								sleep_Enable=0;
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
						    }

							if(snsrs_disabled==1)
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
						    {
                                snsrs_disabled=0;
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
								for(counter=0;counter<DEF_SELFCAP_NUM_SENSORS;counter++)
								{

									if(counter!=DEF_LOWPOWER_SENSOR_ID)
									{
										touch_ret_lp=touch_selfcap_sensor_reenable(counter,0);//NO_RECAL_RE_EN
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	20000134 	.word	0x20000134

										if(touch_ret_lp!=TOUCH_SUCCESS)
      d4:	00000000 	.word	0x00000000
								for(counter=0;counter<DEF_SELFCAP_NUM_SENSORS;counter++)
								{

									if(counter!=DEF_LOWPOWER_SENSOR_ID)
									{
										touch_ret_lp=touch_selfcap_sensor_reenable(counter,0);//NO_RECAL_RE_EN
      d8:	000137c0 	.word	0x000137c0

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}

										if(touch_ret_lp!=TOUCH_SUCCESS)
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
						else
						{
							turn_off_touch_led();
						}

					   if((advertisement_timer >= (BLE_ADVERTISEMENT_TIMEOUT/DEF_TOUCH_MEASUREMENT_PERIOD_MS)) || (power_up_flag == true))					   
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
                       {
						   if(power_up_flag == false)
     104:	20000138 	.word	0x20000138
     108:	000137c0 	.word	0x000137c0
						   {
							   	/* stop BLE advertising */
							   	at_ble_adv_stop();
     10c:	000137c0 	.word	0x000137c0
							   	started_advertising = false;
     110:	00000000 	.word	0x00000000

00000114 <chip_isr>:
#include "conf_winc.h"

static tpfNmBspIsr gpfIsr;

static void chip_isr(void)
{
     114:	b510      	push	{r4, lr}
	if (gpfIsr) {
     116:	4b03      	ldr	r3, [pc, #12]	; (124 <chip_isr+0x10>)
     118:	681b      	ldr	r3, [r3, #0]
     11a:	2b00      	cmp	r3, #0
     11c:	d000      	beq.n	120 <chip_isr+0xc>
		gpfIsr();
     11e:	4798      	blx	r3
	}
}
     120:	bd10      	pop	{r4, pc}
     122:	46c0      	nop			; (mov r8, r8)
     124:	20000150 	.word	0x20000150

00000128 <nm_bsp_sleep>:
 *	@brief	Sleep in units of mSec
 *	@param[IN]	u32TimeMsec
 *				Time in milliseconds
 */
void nm_bsp_sleep(uint32 u32TimeMsec)
{
     128:	b570      	push	{r4, r5, r6, lr}
	while (u32TimeMsec--) {
     12a:	2800      	cmp	r0, #0
     12c:	d006      	beq.n	13c <nm_bsp_sleep+0x14>
     12e:	0004      	movs	r4, r0
		delay_ms(1);
     130:	4d03      	ldr	r5, [pc, #12]	; (140 <nm_bsp_sleep+0x18>)
     132:	2001      	movs	r0, #1
     134:	47a8      	blx	r5
     136:	3c01      	subs	r4, #1
 *	@param[IN]	u32TimeMsec
 *				Time in milliseconds
 */
void nm_bsp_sleep(uint32 u32TimeMsec)
{
	while (u32TimeMsec--) {
     138:	2c00      	cmp	r4, #0
     13a:	d1fa      	bne.n	132 <nm_bsp_sleep+0xa>
		delay_ms(1);
	}
}
     13c:	bd70      	pop	{r4, r5, r6, pc}
     13e:	46c0      	nop			; (mov r8, r8)
     140:	000062b1 	.word	0x000062b1

00000144 <nm_bsp_reset>:
 *	@fn		nm_bsp_reset
 *	@brief	Reset NMC1500 SoC by setting CHIP_EN and RESET_N signals low,
 *           CHIP_EN high then RESET_N high
 */
void nm_bsp_reset(void)
{
     144:	b5f0      	push	{r4, r5, r6, r7, lr}
     146:	4647      	mov	r7, r8
     148:	b480      	push	{r7}
	} else {
		port_base->OUTCLR.reg = pin_mask;
     14a:	4d0b      	ldr	r5, [pc, #44]	; (178 <nm_bsp_reset+0x34>)
     14c:	002f      	movs	r7, r5
     14e:	3780      	adds	r7, #128	; 0x80
     150:	2380      	movs	r3, #128	; 0x80
     152:	009b      	lsls	r3, r3, #2
     154:	4698      	mov	r8, r3
     156:	617b      	str	r3, [r7, #20]
     158:	2608      	movs	r6, #8
     15a:	616e      	str	r6, [r5, #20]
	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, false);
	port_pin_set_output_level(CONF_WINC_PIN_RESET, false);
	nm_bsp_sleep(100);
     15c:	2064      	movs	r0, #100	; 0x64
     15e:	4c07      	ldr	r4, [pc, #28]	; (17c <nm_bsp_reset+0x38>)
     160:	47a0      	blx	r4
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
     162:	4643      	mov	r3, r8
     164:	61bb      	str	r3, [r7, #24]
	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, true);
	nm_bsp_sleep(100);
     166:	2064      	movs	r0, #100	; 0x64
     168:	47a0      	blx	r4
     16a:	61ae      	str	r6, [r5, #24]
	port_pin_set_output_level(CONF_WINC_PIN_RESET, true);
	nm_bsp_sleep(100);
     16c:	2064      	movs	r0, #100	; 0x64
     16e:	47a0      	blx	r4
}
     170:	bc04      	pop	{r2}
     172:	4690      	mov	r8, r2
     174:	bdf0      	pop	{r4, r5, r6, r7, pc}
     176:	46c0      	nop			; (mov r8, r8)
     178:	40002800 	.word	0x40002800
     17c:	00000129 	.word	0x00000129

00000180 <nm_bsp_init>:
 *	@fn		nm_bsp_init
 *	@brief	Initialize BSP
 *	@return	0 in case of success and -1 in case of failure
 */
sint8 nm_bsp_init(void)
{
     180:	b570      	push	{r4, r5, r6, lr}
     182:	b082      	sub	sp, #8
	gpfIsr = NULL;
     184:	2300      	movs	r3, #0
     186:	4a17      	ldr	r2, [pc, #92]	; (1e4 <nm_bsp_init+0x64>)
     188:	6013      	str	r3, [r2, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
     18a:	ac01      	add	r4, sp, #4
     18c:	2501      	movs	r5, #1
     18e:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
     190:	70a3      	strb	r3, [r4, #2]
	struct port_config pin_conf;

	port_get_config_defaults(&pin_conf);

	/* Configure control pins as output. */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
     192:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(CONF_WINC_PIN_RESET, &pin_conf);
     194:	0021      	movs	r1, r4
     196:	2003      	movs	r0, #3
     198:	4e13      	ldr	r6, [pc, #76]	; (1e8 <nm_bsp_init+0x68>)
     19a:	47b0      	blx	r6
	port_pin_set_config(CONF_WINC_PIN_CHIP_ENABLE, &pin_conf);
     19c:	0021      	movs	r1, r4
     19e:	2029      	movs	r0, #41	; 0x29
     1a0:	47b0      	blx	r6
	port_pin_set_config(CONF_WINC_PIN_WAKE, &pin_conf);
     1a2:	0021      	movs	r1, r4
     1a4:	2028      	movs	r0, #40	; 0x28
     1a6:	47b0      	blx	r6

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
     1a8:	4b10      	ldr	r3, [pc, #64]	; (1ec <nm_bsp_init+0x6c>)
     1aa:	001a      	movs	r2, r3
     1ac:	3280      	adds	r2, #128	; 0x80
     1ae:	2180      	movs	r1, #128	; 0x80
     1b0:	0089      	lsls	r1, r1, #2
     1b2:	6151      	str	r1, [r2, #20]
     1b4:	2208      	movs	r2, #8
     1b6:	615a      	str	r2, [r3, #20]

	/* Initialize chip IOs. */
	init_chip_pins();

    /* Make sure a 1ms Systick is configured. */
    if (!(SysTick->CTRL & SysTick_CTRL_ENABLE_Msk && SysTick->CTRL & SysTick_CTRL_TICKINT_Msk)) {
     1b8:	4b0d      	ldr	r3, [pc, #52]	; (1f0 <nm_bsp_init+0x70>)
     1ba:	681b      	ldr	r3, [r3, #0]
     1bc:	421d      	tst	r5, r3
     1be:	d003      	beq.n	1c8 <nm_bsp_init+0x48>
     1c0:	4b0b      	ldr	r3, [pc, #44]	; (1f0 <nm_bsp_init+0x70>)
     1c2:	681b      	ldr	r3, [r3, #0]
     1c4:	079b      	lsls	r3, r3, #30
     1c6:	d401      	bmi.n	1cc <nm_bsp_init+0x4c>
	    delay_init();
     1c8:	4b0a      	ldr	r3, [pc, #40]	; (1f4 <nm_bsp_init+0x74>)
     1ca:	4798      	blx	r3
    }

	/* Perform chip reset. */
	nm_bsp_reset();
     1cc:	4b0a      	ldr	r3, [pc, #40]	; (1f8 <nm_bsp_init+0x78>)
     1ce:	4798      	blx	r3
 *
 * Enables global interrupts in the device to fire any enabled interrupt handlers.
 */
static inline void system_interrupt_enable_global(void)
{
	cpu_irq_enable();
     1d0:	2201      	movs	r2, #1
     1d2:	4b0a      	ldr	r3, [pc, #40]	; (1fc <nm_bsp_init+0x7c>)
     1d4:	701a      	strb	r2, [r3, #0]
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
     1d6:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
     1da:	b662      	cpsie	i

	system_interrupt_enable_global();

	return M2M_SUCCESS;
}
     1dc:	2000      	movs	r0, #0
     1de:	b002      	add	sp, #8
     1e0:	bd70      	pop	{r4, r5, r6, pc}
     1e2:	46c0      	nop			; (mov r8, r8)
     1e4:	20000150 	.word	0x20000150
     1e8:	00006581 	.word	0x00006581
     1ec:	40002800 	.word	0x40002800
     1f0:	e000e010 	.word	0xe000e010
     1f4:	00006271 	.word	0x00006271
     1f8:	00000145 	.word	0x00000145
     1fc:	200000b0 	.word	0x200000b0

00000200 <nm_bsp_register_isr>:
 *	@brief	Register interrupt service routine
 *	@param[IN]	pfIsr
 *				Pointer to ISR handler
 */
void nm_bsp_register_isr(tpfNmBspIsr pfIsr)
{
     200:	b510      	push	{r4, lr}
     202:	b084      	sub	sp, #16
	struct extint_chan_conf config_extint_chan;

	gpfIsr = pfIsr;
     204:	4b0e      	ldr	r3, [pc, #56]	; (240 <nm_bsp_register_isr+0x40>)
     206:	6018      	str	r0, [r3, #0]

	extint_chan_get_config_defaults(&config_extint_chan);
     208:	ac01      	add	r4, sp, #4
     20a:	0020      	movs	r0, r4
     20c:	4b0d      	ldr	r3, [pc, #52]	; (244 <nm_bsp_register_isr+0x44>)
     20e:	4798      	blx	r3
	config_extint_chan.gpio_pin = CONF_WINC_SPI_INT_PIN;
     210:	2310      	movs	r3, #16
     212:	9301      	str	r3, [sp, #4]
	config_extint_chan.gpio_pin_mux = CONF_WINC_SPI_INT_MUX;
     214:	2300      	movs	r3, #0
     216:	6063      	str	r3, [r4, #4]
	config_extint_chan.gpio_pin_pull = EXTINT_PULL_UP;
     218:	3301      	adds	r3, #1
     21a:	7223      	strb	r3, [r4, #8]
	config_extint_chan.detection_criteria = EXTINT_DETECT_FALLING;
     21c:	3301      	adds	r3, #1
     21e:	72e3      	strb	r3, [r4, #11]
	//config_extint_chan.detection_criteria = EXTINT_DETECT_LOW;

	extint_chan_set_config(CONF_WINC_SPI_INT_EIC, &config_extint_chan);
     220:	0021      	movs	r1, r4
     222:	2000      	movs	r0, #0
     224:	4b08      	ldr	r3, [pc, #32]	; (248 <nm_bsp_register_isr+0x48>)
     226:	4798      	blx	r3
	extint_register_callback(chip_isr, CONF_WINC_SPI_INT_EIC,
     228:	2200      	movs	r2, #0
     22a:	2100      	movs	r1, #0
     22c:	4807      	ldr	r0, [pc, #28]	; (24c <nm_bsp_register_isr+0x4c>)
     22e:	4b08      	ldr	r3, [pc, #32]	; (250 <nm_bsp_register_isr+0x50>)
     230:	4798      	blx	r3
			EXTINT_CALLBACK_TYPE_DETECT);
	extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
     232:	2100      	movs	r1, #0
     234:	2000      	movs	r0, #0
     236:	4b07      	ldr	r3, [pc, #28]	; (254 <nm_bsp_register_isr+0x54>)
     238:	4798      	blx	r3
			EXTINT_CALLBACK_TYPE_DETECT);
}
     23a:	b004      	add	sp, #16
     23c:	bd10      	pop	{r4, pc}
     23e:	46c0      	nop			; (mov r8, r8)
     240:	20000150 	.word	0x20000150
     244:	000064e5 	.word	0x000064e5
     248:	000064f9 	.word	0x000064f9
     24c:	00000115 	.word	0x00000115
     250:	0000634d 	.word	0x0000634d
     254:	00006379 	.word	0x00006379

00000258 <nm_bsp_interrupt_ctrl>:
 *	@brief	Enable/Disable interrupts
 *	@param[IN]	u8Enable
 *				'0' disable interrupts. '1' enable interrupts
 */
void nm_bsp_interrupt_ctrl(uint8 u8Enable)
{
     258:	b510      	push	{r4, lr}
	if (u8Enable) {
     25a:	2800      	cmp	r0, #0
     25c:	d004      	beq.n	268 <nm_bsp_interrupt_ctrl+0x10>
		extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
     25e:	2100      	movs	r1, #0
     260:	2000      	movs	r0, #0
     262:	4b04      	ldr	r3, [pc, #16]	; (274 <nm_bsp_interrupt_ctrl+0x1c>)
     264:	4798      	blx	r3
     266:	e003      	b.n	270 <nm_bsp_interrupt_ctrl+0x18>
				EXTINT_CALLBACK_TYPE_DETECT);
	} else {
		extint_chan_disable_callback(CONF_WINC_SPI_INT_EIC,
     268:	2100      	movs	r1, #0
     26a:	2000      	movs	r0, #0
     26c:	4b02      	ldr	r3, [pc, #8]	; (278 <nm_bsp_interrupt_ctrl+0x20>)
     26e:	4798      	blx	r3
				EXTINT_CALLBACK_TYPE_DETECT);
	}
}
     270:	bd10      	pop	{r4, pc}
     272:	46c0      	nop			; (mov r8, r8)
     274:	00006379 	.word	0x00006379
     278:	00006399 	.word	0x00006399

0000027c <nm_bus_init>:
*	@fn		nm_bus_init
*	@brief	Initialize the bus wrapper
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*/
sint8 nm_bus_init(void *pvinit)
{
     27c:	b530      	push	{r4, r5, lr}
     27e:	b091      	sub	sp, #68	; 0x44
		const struct spi_slave_inst_config *const config)
{
	Assert(slave);
	Assert(config);

	slave->ss_pin          = config->ss_pin;
     280:	4c31      	ldr	r4, [pc, #196]	; (348 <nm_bus_init+0xcc>)
     282:	2306      	movs	r3, #6
     284:	7023      	strb	r3, [r4, #0]
	slave->address_enabled = config->address_enabled;
     286:	2300      	movs	r3, #0
     288:	7063      	strb	r3, [r4, #1]
	slave->address         = config->address;
     28a:	70a3      	strb	r3, [r4, #2]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
     28c:	a901      	add	r1, sp, #4
     28e:	2201      	movs	r2, #1
     290:	704a      	strb	r2, [r1, #1]
	config->powersave  = false;
     292:	708b      	strb	r3, [r1, #2]
	/* Get default config for pin */
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Edit config to set the pin as output */
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
     294:	700a      	strb	r2, [r1, #0]

	/* Set config on Slave Select pin */
	port_pin_set_config(slave->ss_pin, &pin_conf);
     296:	2006      	movs	r0, #6
     298:	4b2c      	ldr	r3, [pc, #176]	; (34c <nm_bus_init+0xd0>)
     29a:	4798      	blx	r3
	port_pin_set_output_level(slave->ss_pin, true);
     29c:	7823      	ldrb	r3, [r4, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
     29e:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
     2a0:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
     2a2:	2900      	cmp	r1, #0
     2a4:	d104      	bne.n	2b0 <nm_bus_init+0x34>
		return &(ports[port_index]->Group[group_index]);
     2a6:	095a      	lsrs	r2, r3, #5
     2a8:	01d2      	lsls	r2, r2, #7
     2aa:	4929      	ldr	r1, [pc, #164]	; (350 <nm_bus_init+0xd4>)
     2ac:	468c      	mov	ip, r1
     2ae:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
     2b0:	211f      	movs	r1, #31
     2b2:	400b      	ands	r3, r1
     2b4:	391e      	subs	r1, #30
     2b6:	0008      	movs	r0, r1
     2b8:	4098      	lsls	r0, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
     2ba:	6190      	str	r0, [r2, #24]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
     2bc:	ac02      	add	r4, sp, #8
     2be:	7021      	strb	r1, [r4, #0]
	config->data_order       = SPI_DATA_ORDER_MSB;
     2c0:	2300      	movs	r3, #0
     2c2:	9303      	str	r3, [sp, #12]
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
     2c4:	9304      	str	r3, [sp, #16]
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
     2c6:	22c0      	movs	r2, #192	; 0xc0
     2c8:	0392      	lsls	r2, r2, #14
     2ca:	9205      	str	r2, [sp, #20]
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
     2cc:	7423      	strb	r3, [r4, #16]
	config->run_in_standby   = false;
     2ce:	7463      	strb	r3, [r4, #17]
	config->receiver_enable  = true;
     2d0:	74a1      	strb	r1, [r4, #18]
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	config->select_slave_low_detect_enable= true;
     2d2:	74e1      	strb	r1, [r4, #19]
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
     2d4:	7523      	strb	r3, [r4, #20]
#  endif
	config->generator_source = GCLK_GENERATOR_0;
     2d6:	2224      	movs	r2, #36	; 0x24
     2d8:	54a3      	strb	r3, [r4, r2]

	/* Clear mode specific config */
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
     2da:	3a18      	subs	r2, #24
     2dc:	2100      	movs	r1, #0
     2de:	a808      	add	r0, sp, #32
     2e0:	4b1c      	ldr	r3, [pc, #112]	; (354 <nm_bus_init+0xd8>)
     2e2:	4798      	blx	r3
	spi_attach_slave(&slave_inst, &slave_config);

	/* Configure the SPI master. */
	spi_get_config_defaults(&config);
	config.mux_setting = CONF_WINC_SPI_SERCOM_MUX;
	config.pinmux_pad0 = CONF_WINC_SPI_PINMUX_PAD0;
     2e4:	4b1c      	ldr	r3, [pc, #112]	; (358 <nm_bus_init+0xdc>)
     2e6:	62a3      	str	r3, [r4, #40]	; 0x28
	config.pinmux_pad1 = CONF_WINC_SPI_PINMUX_PAD1;
     2e8:	4b1c      	ldr	r3, [pc, #112]	; (35c <nm_bus_init+0xe0>)
     2ea:	62e3      	str	r3, [r4, #44]	; 0x2c
	config.pinmux_pad2 = CONF_WINC_SPI_PINMUX_PAD2;
     2ec:	2301      	movs	r3, #1
     2ee:	425b      	negs	r3, r3
     2f0:	6323      	str	r3, [r4, #48]	; 0x30
	config.pinmux_pad3 = CONF_WINC_SPI_PINMUX_PAD3;
     2f2:	4b1b      	ldr	r3, [pc, #108]	; (360 <nm_bus_init+0xe4>)
     2f4:	6363      	str	r3, [r4, #52]	; 0x34
	config.master_slave_select_enable = false;

	config.mode_specific.master.baudrate = CONF_WINC_SPI_CLOCK;
     2f6:	4b1b      	ldr	r3, [pc, #108]	; (364 <nm_bus_init+0xe8>)
     2f8:	61a3      	str	r3, [r4, #24]
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
     2fa:	0022      	movs	r2, r4
     2fc:	2184      	movs	r1, #132	; 0x84
     2fe:	05c9      	lsls	r1, r1, #23
     300:	4819      	ldr	r0, [pc, #100]	; (368 <nm_bus_init+0xec>)
     302:	4b1a      	ldr	r3, [pc, #104]	; (36c <nm_bus_init+0xf0>)
     304:	4798      	blx	r3
     306:	2800      	cmp	r0, #0
     308:	d119      	bne.n	33e <nm_bus_init+0xc2>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
     30a:	4d17      	ldr	r5, [pc, #92]	; (368 <nm_bus_init+0xec>)
     30c:	682c      	ldr	r4, [r5, #0]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
     30e:	0020      	movs	r0, r4
     310:	4b17      	ldr	r3, [pc, #92]	; (370 <nm_bus_init+0xf4>)
     312:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
     314:	231f      	movs	r3, #31
     316:	4018      	ands	r0, r3
     318:	3b1e      	subs	r3, #30
     31a:	4083      	lsls	r3, r0
     31c:	4a15      	ldr	r2, [pc, #84]	; (374 <nm_bus_init+0xf8>)
     31e:	6013      	str	r3, [r2, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
     320:	682a      	ldr	r2, [r5, #0]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
     322:	69d3      	ldr	r3, [r2, #28]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
     324:	2b00      	cmp	r3, #0
     326:	d1fc      	bne.n	322 <nm_bus_init+0xa6>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
     328:	6822      	ldr	r2, [r4, #0]
     32a:	3302      	adds	r3, #2
     32c:	4313      	orrs	r3, r2
     32e:	6023      	str	r3, [r4, #0]
	}

	/* Enable the SPI master. */
	spi_enable(&master);

	nm_bsp_reset();
     330:	4b11      	ldr	r3, [pc, #68]	; (378 <nm_bus_init+0xfc>)
     332:	4798      	blx	r3
	nm_bsp_sleep(1);
     334:	2001      	movs	r0, #1
     336:	4b11      	ldr	r3, [pc, #68]	; (37c <nm_bus_init+0x100>)
     338:	4798      	blx	r3
#endif
	return result;
     33a:	2000      	movs	r0, #0
     33c:	e001      	b.n	342 <nm_bus_init+0xc6>
	config.pinmux_pad3 = CONF_WINC_SPI_PINMUX_PAD3;
	config.master_slave_select_enable = false;

	config.mode_specific.master.baudrate = CONF_WINC_SPI_CLOCK;
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
		return M2M_ERR_BUS_FAIL;
     33e:	2006      	movs	r0, #6
     340:	4240      	negs	r0, r0

	nm_bsp_reset();
	nm_bsp_sleep(1);
#endif
	return result;
}
     342:	b011      	add	sp, #68	; 0x44
     344:	bd30      	pop	{r4, r5, pc}
     346:	46c0      	nop			; (mov r8, r8)
     348:	20000cd0 	.word	0x20000cd0
     34c:	00006581 	.word	0x00006581
     350:	40002800 	.word	0x40002800
     354:	0000a75f 	.word	0x0000a75f
     358:	00040003 	.word	0x00040003
     35c:	00050003 	.word	0x00050003
     360:	00070003 	.word	0x00070003
     364:	00b71b00 	.word	0x00b71b00
     368:	20000cd4 	.word	0x20000cd4
     36c:	0000319d 	.word	0x0000319d
     370:	000069e1 	.word	0x000069e1
     374:	e000e100 	.word	0xe000e100
     378:	00000145 	.word	0x00000145
     37c:	00000129 	.word	0x00000129

00000380 <nm_bus_ioctl>:
*					Arbitrary parameter depenging on IOCTL
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*	@note	For SPI only, it's important to be able to send/receive at the same time
*/
sint8 nm_bus_ioctl(uint8 u8Cmd, void* pvParameter)
{
     380:	b5f0      	push	{r4, r5, r6, r7, lr}
     382:	465f      	mov	r7, fp
     384:	4656      	mov	r6, sl
     386:	464d      	mov	r5, r9
     388:	4644      	mov	r4, r8
     38a:	b4f0      	push	{r4, r5, r6, r7}
     38c:	b085      	sub	sp, #20
	sint8 s8Ret = 0;
	switch(u8Cmd)
     38e:	2803      	cmp	r0, #3
     390:	d164      	bne.n	45c <nm_bus_ioctl+0xdc>
		}
		break;
#elif defined CONF_WINC_USE_SPI
		case NM_BUS_IOCTL_RW: {
			tstrNmSpiRw *pstrParam = (tstrNmSpiRw *)pvParameter;
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
     392:	680f      	ldr	r7, [r1, #0]
     394:	684e      	ldr	r6, [r1, #4]
     396:	890d      	ldrh	r5, [r1, #8]
struct spi_module master;
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
     398:	2200      	movs	r2, #0
     39a:	ab02      	add	r3, sp, #8
     39c:	71da      	strb	r2, [r3, #7]
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
	uint16_t txd_data = 0;
	uint16_t rxd_data = 0;

	
	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) || (u16Sz == 0)) {
     39e:	2e00      	cmp	r6, #0
     3a0:	d102      	bne.n	3a8 <nm_bus_ioctl+0x28>
     3a2:	2f00      	cmp	r7, #0
     3a4:	d17a      	bne.n	49c <nm_bus_ioctl+0x11c>
     3a6:	e050      	b.n	44a <nm_bus_ioctl+0xca>
     3a8:	2d00      	cmp	r5, #0
     3aa:	d051      	beq.n	450 <nm_bus_ioctl+0xd0>
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
     3ac:	2300      	movs	r3, #0
     3ae:	9301      	str	r3, [sp, #4]
	
	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) || (u16Sz == 0)) {
		return M2M_ERR_INVALID_ARG;
	}

	if (pu8Mosi == NULL) {
     3b0:	2f00      	cmp	r7, #0
     3b2:	d103      	bne.n	3bc <nm_bus_ioctl+0x3c>
		pu8Mosi = &u8Dummy;
		u8SkipMosi = 1;
     3b4:	3301      	adds	r3, #1
     3b6:	9301      	str	r3, [sp, #4]
	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) || (u16Sz == 0)) {
		return M2M_ERR_INVALID_ARG;
	}

	if (pu8Mosi == NULL) {
		pu8Mosi = &u8Dummy;
     3b8:	ab02      	add	r3, sp, #8
     3ba:	1ddf      	adds	r7, r3, #7
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
     3bc:	2400      	movs	r4, #0

	if (pu8Mosi == NULL) {
		pu8Mosi = &u8Dummy;
		u8SkipMosi = 1;
	}
	if(pu8Miso == NULL) {
     3be:	2e00      	cmp	r6, #0
     3c0:	d15b      	bne.n	47a <nm_bus_ioctl+0xfa>
		pu8Miso = &u8Dummy;
		u8SkipMiso = 1;
     3c2:	3401      	adds	r4, #1
	if (pu8Mosi == NULL) {
		pu8Mosi = &u8Dummy;
		u8SkipMosi = 1;
	}
	if(pu8Miso == NULL) {
		pu8Miso = &u8Dummy;
     3c4:	ab02      	add	r3, sp, #8
     3c6:	1dde      	adds	r6, r3, #7
     3c8:	e057      	b.n	47a <nm_bus_ioctl+0xfa>


	spi_select_slave(&master, &slave_inst, true);

	while (u16Sz) {
		txd_data = *pu8Mosi;
     3ca:	783c      	ldrb	r4, [r7, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
     3cc:	4653      	mov	r3, sl
     3ce:	681b      	ldr	r3, [r3, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
     3d0:	7e19      	ldrb	r1, [r3, #24]
		while (!spi_is_ready_to_write(&master))
     3d2:	4201      	tst	r1, r0
     3d4:	d0fc      	beq.n	3d0 <nm_bus_ioctl+0x50>
     3d6:	7e19      	ldrb	r1, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
     3d8:	4201      	tst	r1, r0
     3da:	d0fc      	beq.n	3d6 <nm_bus_ioctl+0x56>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
     3dc:	629c      	str	r4, [r3, #40]	; 0x28
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
     3de:	7e19      	ldrb	r1, [r3, #24]
			;
		while(spi_write(&master, txd_data) != STATUS_OK)
			;

		/* Read SPI master data register. */
		while (!spi_is_ready_to_read(&master))
     3e0:	4211      	tst	r1, r2
     3e2:	d0fc      	beq.n	3de <nm_bus_ioctl+0x5e>
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
     3e4:	4649      	mov	r1, r9
     3e6:	798c      	ldrb	r4, [r1, #6]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
     3e8:	7e19      	ldrb	r1, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
     3ea:	4211      	tst	r1, r2
     3ec:	d0fc      	beq.n	3e8 <nm_bus_ioctl+0x68>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
     3ee:	8b59      	ldrh	r1, [r3, #26]
		/* No data has been received, return */
		return STATUS_ERR_IO;
	}

	/* Return value */
	enum status_code retval = STATUS_OK;
     3f0:	2500      	movs	r5, #0

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
     3f2:	4211      	tst	r1, r2
     3f4:	d005      	beq.n	402 <nm_bus_ioctl+0x82>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
     3f6:	8b59      	ldrh	r1, [r3, #26]
     3f8:	4645      	mov	r5, r8
     3fa:	4329      	orrs	r1, r5
     3fc:	b289      	uxth	r1, r1
     3fe:	8359      	strh	r1, [r3, #26]
	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
		retval = STATUS_ERR_OVERFLOW;
     400:	251e      	movs	r5, #30
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
     402:	2c01      	cmp	r4, #1
     404:	d103      	bne.n	40e <nm_bus_ioctl+0x8e>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
     406:	6a99      	ldr	r1, [r3, #40]	; 0x28
     408:	05c9      	lsls	r1, r1, #23
     40a:	0dc9      	lsrs	r1, r1, #23
     40c:	e001      	b.n	412 <nm_bus_ioctl+0x92>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
     40e:	6a99      	ldr	r1, [r3, #40]	; 0x28
     410:	b2c9      	uxtb	r1, r1
			;
		while (spi_read(&master, &rxd_data) != STATUS_OK)
     412:	2d00      	cmp	r5, #0
     414:	d1e8      	bne.n	3e8 <nm_bus_ioctl+0x68>
			;
		*pu8Miso = rxd_data;
     416:	7031      	strb	r1, [r6, #0]

		u16Sz--;
     418:	9d00      	ldr	r5, [sp, #0]
     41a:	3d01      	subs	r5, #1
     41c:	b2ab      	uxth	r3, r5
     41e:	001c      	movs	r4, r3
     420:	9300      	str	r3, [sp, #0]
		if (!u8SkipMiso)
			pu8Miso++;
     422:	445e      	add	r6, fp
		if (!u8SkipMosi)
			pu8Mosi++;
     424:	9b01      	ldr	r3, [sp, #4]
     426:	4259      	negs	r1, r3
     428:	414b      	adcs	r3, r1
     42a:	18ff      	adds	r7, r7, r3
	}


	spi_select_slave(&master, &slave_inst, true);

	while (u16Sz) {
     42c:	2c00      	cmp	r4, #0
     42e:	d1cc      	bne.n	3ca <nm_bus_ioctl+0x4a>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
     430:	4b20      	ldr	r3, [pc, #128]	; (4b4 <nm_bus_ioctl+0x134>)
     432:	6819      	ldr	r1, [r3, #0]
			pu8Miso++;
		if (!u8SkipMosi)
			pu8Mosi++;
	}

	while (!spi_is_write_complete(&master))
     434:	2202      	movs	r2, #2

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
     436:	7e0b      	ldrb	r3, [r1, #24]
     438:	4213      	tst	r3, r2
     43a:	d0fc      	beq.n	436 <nm_bus_ioctl+0xb6>
		;

	spi_select_slave(&master, &slave_inst, false);
     43c:	2200      	movs	r2, #0
     43e:	491e      	ldr	r1, [pc, #120]	; (4b8 <nm_bus_ioctl+0x138>)
     440:	481c      	ldr	r0, [pc, #112]	; (4b4 <nm_bus_ioctl+0x134>)
     442:	4b1e      	ldr	r3, [pc, #120]	; (4bc <nm_bus_ioctl+0x13c>)
     444:	4798      	blx	r3

	return M2M_SUCCESS;
     446:	2000      	movs	r0, #0
     448:	e02d      	b.n	4a6 <nm_bus_ioctl+0x126>
	uint16_t txd_data = 0;
	uint16_t rxd_data = 0;

	
	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) || (u16Sz == 0)) {
		return M2M_ERR_INVALID_ARG;
     44a:	200f      	movs	r0, #15
     44c:	4240      	negs	r0, r0
     44e:	e02a      	b.n	4a6 <nm_bus_ioctl+0x126>
     450:	200f      	movs	r0, #15
     452:	4240      	negs	r0, r0
     454:	e027      	b.n	4a6 <nm_bus_ioctl+0x126>
     456:	200f      	movs	r0, #15
     458:	4240      	negs	r0, r0
#elif defined CONF_WINC_USE_SPI
		case NM_BUS_IOCTL_RW: {
			tstrNmSpiRw *pstrParam = (tstrNmSpiRw *)pvParameter;
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
		}
		break;
     45a:	e024      	b.n	4a6 <nm_bus_ioctl+0x126>
#endif
		default:
			s8Ret = -1;
			M2M_ERR("invalide ioclt cmd\n");
     45c:	2210      	movs	r2, #16
     45e:	32ff      	adds	r2, #255	; 0xff
     460:	4917      	ldr	r1, [pc, #92]	; (4c0 <nm_bus_ioctl+0x140>)
     462:	4818      	ldr	r0, [pc, #96]	; (4c4 <nm_bus_ioctl+0x144>)
     464:	4b18      	ldr	r3, [pc, #96]	; (4c8 <nm_bus_ioctl+0x148>)
     466:	4798      	blx	r3
     468:	4818      	ldr	r0, [pc, #96]	; (4cc <nm_bus_ioctl+0x14c>)
     46a:	4b19      	ldr	r3, [pc, #100]	; (4d0 <nm_bus_ioctl+0x150>)
     46c:	4798      	blx	r3
     46e:	200d      	movs	r0, #13
     470:	4b18      	ldr	r3, [pc, #96]	; (4d4 <nm_bus_ioctl+0x154>)
     472:	4798      	blx	r3
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
		}
		break;
#endif
		default:
			s8Ret = -1;
     474:	2001      	movs	r0, #1
     476:	4240      	negs	r0, r0
			M2M_ERR("invalide ioclt cmd\n");
			break;
	}

	return s8Ret;
     478:	e015      	b.n	4a6 <nm_bus_ioctl+0x126>
		pu8Miso = &u8Dummy;
		u8SkipMiso = 1;
	}


	spi_select_slave(&master, &slave_inst, true);
     47a:	2201      	movs	r2, #1
     47c:	490e      	ldr	r1, [pc, #56]	; (4b8 <nm_bus_ioctl+0x138>)
     47e:	480d      	ldr	r0, [pc, #52]	; (4b4 <nm_bus_ioctl+0x134>)
     480:	4b0e      	ldr	r3, [pc, #56]	; (4bc <nm_bus_ioctl+0x13c>)
     482:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
     484:	4b0b      	ldr	r3, [pc, #44]	; (4b4 <nm_bus_ioctl+0x134>)
     486:	469a      	mov	sl, r3

	while (u16Sz) {
		txd_data = *pu8Mosi;
		while (!spi_is_ready_to_write(&master))
     488:	2001      	movs	r0, #1
			;
		while(spi_write(&master, txd_data) != STATUS_OK)
			;

		/* Read SPI master data register. */
		while (!spi_is_ready_to_read(&master))
     48a:	2204      	movs	r2, #4
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
     48c:	4699      	mov	r9, r3

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
     48e:	2304      	movs	r3, #4
     490:	4698      	mov	r8, r3
			;
		*pu8Miso = rxd_data;

		u16Sz--;
		if (!u8SkipMiso)
			pu8Miso++;
     492:	4263      	negs	r3, r4
     494:	4163      	adcs	r3, r4
     496:	469b      	mov	fp, r3
     498:	9500      	str	r5, [sp, #0]
     49a:	e796      	b.n	3ca <nm_bus_ioctl+0x4a>
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
	uint16_t txd_data = 0;
	uint16_t rxd_data = 0;

	
	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) || (u16Sz == 0)) {
     49c:	2d00      	cmp	r5, #0
     49e:	d0da      	beq.n	456 <nm_bus_ioctl+0xd6>
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
     4a0:	2300      	movs	r3, #0
     4a2:	9301      	str	r3, [sp, #4]
     4a4:	e78a      	b.n	3bc <nm_bus_ioctl+0x3c>
			M2M_ERR("invalide ioclt cmd\n");
			break;
	}

	return s8Ret;
}
     4a6:	b005      	add	sp, #20
     4a8:	bc3c      	pop	{r2, r3, r4, r5}
     4aa:	4690      	mov	r8, r2
     4ac:	4699      	mov	r9, r3
     4ae:	46a2      	mov	sl, r4
     4b0:	46ab      	mov	fp, r5
     4b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
     4b4:	20000cd4 	.word	0x20000cd4
     4b8:	20000cd0 	.word	0x20000cd0
     4bc:	000033bd 	.word	0x000033bd
     4c0:	0000b8a4 	.word	0x0000b8a4
     4c4:	0000b8b4 	.word	0x0000b8b4
     4c8:	0000a771 	.word	0x0000a771
     4cc:	0000b8c8 	.word	0x0000b8c8
     4d0:	0000a891 	.word	0x0000a891
     4d4:	0000a7a5 	.word	0x0000a7a5

000004d8 <nm_bus_deinit>:
/*
*	@fn		nm_bus_deinit
*	@brief	De-initialize the bus wrapper
*/
sint8 nm_bus_deinit(void)
{
     4d8:	b570      	push	{r4, r5, r6, lr}
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
     4da:	4d0b      	ldr	r5, [pc, #44]	; (508 <nm_bus_deinit+0x30>)
     4dc:	682c      	ldr	r4, [r5, #0]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
     4de:	0020      	movs	r0, r4
     4e0:	4b0a      	ldr	r3, [pc, #40]	; (50c <nm_bus_deinit+0x34>)
     4e2:	4798      	blx	r3
 * \param[in] vector  Interrupt vector to disable
 */
static inline void system_interrupt_disable(
		const enum system_interrupt_vector vector)
{
	NVIC->ICER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
     4e4:	231f      	movs	r3, #31
     4e6:	4018      	ands	r0, r3
     4e8:	3b1e      	subs	r3, #30
     4ea:	4083      	lsls	r3, r0
     4ec:	2280      	movs	r2, #128	; 0x80
     4ee:	4908      	ldr	r1, [pc, #32]	; (510 <nm_bus_deinit+0x38>)
     4f0:	508b      	str	r3, [r1, r2]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
     4f2:	682a      	ldr	r2, [r5, #0]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
     4f4:	69d3      	ldr	r3, [r2, #28]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
     4f6:	2b00      	cmp	r3, #0
     4f8:	d1fc      	bne.n	4f4 <nm_bus_deinit+0x1c>
		/* Wait until the synchronization is complete */
	}

	/* Disable SPI */
	spi_module->CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
     4fa:	6823      	ldr	r3, [r4, #0]
     4fc:	2202      	movs	r2, #2
     4fe:	4393      	bics	r3, r2
     500:	6023      	str	r3, [r4, #0]
#endif /* CONF_WINC_USE_I2C */
#ifdef CONF_WINC_USE_SPI
	spi_disable(&master);
#endif /* CONF_WINC_USE_SPI */
	return result;
}
     502:	2000      	movs	r0, #0
     504:	bd70      	pop	{r4, r5, r6, pc}
     506:	46c0      	nop			; (mov r8, r8)
     508:	20000cd4 	.word	0x20000cd4
     50c:	000069e1 	.word	0x000069e1
     510:	e000e100 	.word	0xe000e100

00000514 <m2m_memcpy>:
 */
#include "common/include/nm_common.h"

void m2m_memcpy(uint8* pDst,uint8* pSrc,uint32 sz)
{
	if(sz == 0) return;
     514:	2a00      	cmp	r2, #0
     516:	d006      	beq.n	526 <m2m_memcpy+0x12>
     518:	1882      	adds	r2, r0, r2
	do
	{
		*pDst = *pSrc;
     51a:	780b      	ldrb	r3, [r1, #0]
     51c:	7003      	strb	r3, [r0, #0]
		pDst++;
     51e:	3001      	adds	r0, #1
		pSrc++;
     520:	3101      	adds	r1, #1
	}while(--sz);
     522:	4290      	cmp	r0, r2
     524:	d1f9      	bne.n	51a <m2m_memcpy+0x6>
}
     526:	4770      	bx	lr

00000528 <m2m_memset>:
	return cs;
}

void m2m_memset(uint8* pBuf,uint8 val,uint32 sz)
{
	if(sz == 0) return;
     528:	2a00      	cmp	r2, #0
     52a:	d004      	beq.n	536 <m2m_memset+0xe>
     52c:	1882      	adds	r2, r0, r2
	do
	{
		*pBuf = val;
     52e:	7001      	strb	r1, [r0, #0]
		pBuf++;
     530:	3001      	adds	r0, #1
	}while(--sz);
     532:	4290      	cmp	r0, r2
     534:	d1fb      	bne.n	52e <m2m_memset+0x6>
}
     536:	4770      	bx	lr

00000538 <m2m_strlen>:

uint16 m2m_strlen(uint8 * pcStr)
{
     538:	0003      	movs	r3, r0
	uint16	u16StrLen = 0;
	while(*pcStr)
     53a:	7802      	ldrb	r2, [r0, #0]
     53c:	2a00      	cmp	r2, #0
     53e:	d007      	beq.n	550 <m2m_strlen+0x18>
     540:	2000      	movs	r0, #0
	{
		u16StrLen ++;
     542:	3001      	adds	r0, #1
     544:	b280      	uxth	r0, r0
		pcStr++;
     546:	3301      	adds	r3, #1
}

uint16 m2m_strlen(uint8 * pcStr)
{
	uint16	u16StrLen = 0;
	while(*pcStr)
     548:	781a      	ldrb	r2, [r3, #0]
     54a:	2a00      	cmp	r2, #0
     54c:	d1f9      	bne.n	542 <m2m_strlen+0xa>
     54e:	e000      	b.n	552 <m2m_strlen+0x1a>
	}while(--sz);
}

uint16 m2m_strlen(uint8 * pcStr)
{
	uint16	u16StrLen = 0;
     550:	2000      	movs	r0, #0
	{
		u16StrLen ++;
		pcStr++;
	}
	return u16StrLen;
}
     552:	4770      	bx	lr

00000554 <isr>:

volatile tstrHifContext gstrHifCxt;

static void isr(void)
{
	gstrHifCxt.u8Interrupt++;
     554:	4a02      	ldr	r2, [pc, #8]	; (560 <isr+0xc>)
     556:	78d3      	ldrb	r3, [r2, #3]
     558:	3301      	adds	r3, #1
     55a:	b2db      	uxtb	r3, r3
     55c:	70d3      	strb	r3, [r2, #3]
#ifdef NM_LEVEL_INTERRUPT
	nm_bsp_interrupt_ctrl(0);
#endif
}
     55e:	4770      	bx	lr
     560:	20000d10 	.word	0x20000d10

00000564 <m2m_hif_cb>:
*/
static void m2m_hif_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
{


}
     564:	4770      	bx	lr
     566:	46c0      	nop			; (mov r8, r8)

00000568 <hif_set_rx_done>:
#ifdef NM_LEVEL_INTERRUPT
	nm_bsp_interrupt_ctrl(0);
#endif
}
static sint8 hif_set_rx_done(void)
{
     568:	b500      	push	{lr}
     56a:	b083      	sub	sp, #12
	uint32 reg;
	sint8 ret = M2M_SUCCESS;

	gstrHifCxt.u8HifRXDone = 0;
     56c:	2200      	movs	r2, #0
     56e:	4b0a      	ldr	r3, [pc, #40]	; (598 <hif_set_rx_done+0x30>)
     570:	709a      	strb	r2, [r3, #2]
#ifdef NM_EDGE_INTERRUPT
	nm_bsp_interrupt_ctrl(1);
     572:	2001      	movs	r0, #1
     574:	4b09      	ldr	r3, [pc, #36]	; (59c <hif_set_rx_done+0x34>)
     576:	4798      	blx	r3
#endif
	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
     578:	a901      	add	r1, sp, #4
     57a:	4809      	ldr	r0, [pc, #36]	; (5a0 <hif_set_rx_done+0x38>)
     57c:	4b09      	ldr	r3, [pc, #36]	; (5a4 <hif_set_rx_done+0x3c>)
     57e:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
     580:	2800      	cmp	r0, #0
     582:	d106      	bne.n	592 <hif_set_rx_done+0x2a>
	/* Set RX Done */
	reg |= NBIT1;
     584:	2102      	movs	r1, #2
     586:	9b01      	ldr	r3, [sp, #4]
     588:	4319      	orrs	r1, r3
     58a:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
     58c:	4804      	ldr	r0, [pc, #16]	; (5a0 <hif_set_rx_done+0x38>)
     58e:	4b06      	ldr	r3, [pc, #24]	; (5a8 <hif_set_rx_done+0x40>)
     590:	4798      	blx	r3
	nm_bsp_interrupt_ctrl(1);
#endif
ERR1:
	return ret;

}
     592:	b003      	add	sp, #12
     594:	bd00      	pop	{pc}
     596:	46c0      	nop			; (mov r8, r8)
     598:	20000d10 	.word	0x20000d10
     59c:	00000259 	.word	0x00000259
     5a0:	00001070 	.word	0x00001070
     5a4:	00001945 	.word	0x00001945
     5a8:	00001951 	.word	0x00001951

000005ac <hif_chip_wake>:
*	@brief	To Wakeup the chip.
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_wake(void)
{
     5ac:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
	if(gstrHifCxt.u8HifRXDone)
     5ae:	4b0c      	ldr	r3, [pc, #48]	; (5e0 <hif_chip_wake+0x34>)
     5b0:	789b      	ldrb	r3, [r3, #2]
	{
		/*chip already wake for the rx not done no need to send wake request*/
		return ret;
     5b2:	2000      	movs	r0, #0
*/

sint8 hif_chip_wake(void)
{
	sint8 ret = M2M_SUCCESS;
	if(gstrHifCxt.u8HifRXDone)
     5b4:	2b00      	cmp	r3, #0
     5b6:	d111      	bne.n	5dc <hif_chip_wake+0x30>
	{
		/*chip already wake for the rx not done no need to send wake request*/
		return ret;
	}
	if(gstrHifCxt.u8ChipSleep == 0)
     5b8:	4b09      	ldr	r3, [pc, #36]	; (5e0 <hif_chip_wake+0x34>)
     5ba:	785b      	ldrb	r3, [r3, #1]
     5bc:	2b00      	cmp	r3, #0
     5be:	d107      	bne.n	5d0 <hif_chip_wake+0x24>
	{
		if(gstrHifCxt.u8ChipMode != M2M_NO_PS)
     5c0:	4b07      	ldr	r3, [pc, #28]	; (5e0 <hif_chip_wake+0x34>)
     5c2:	781b      	ldrb	r3, [r3, #0]
     5c4:	2b00      	cmp	r3, #0
     5c6:	d003      	beq.n	5d0 <hif_chip_wake+0x24>
		{
			ret = chip_wake();
     5c8:	4b06      	ldr	r3, [pc, #24]	; (5e4 <hif_chip_wake+0x38>)
     5ca:	4798      	blx	r3
			if(ret != M2M_SUCCESS)goto ERR1;
     5cc:	2800      	cmp	r0, #0
     5ce:	d105      	bne.n	5dc <hif_chip_wake+0x30>
		}
		else
		{
		}
	}
	gstrHifCxt.u8ChipSleep++;
     5d0:	4a03      	ldr	r2, [pc, #12]	; (5e0 <hif_chip_wake+0x34>)
     5d2:	7853      	ldrb	r3, [r2, #1]
     5d4:	3301      	adds	r3, #1
     5d6:	b2db      	uxtb	r3, r3
     5d8:	7053      	strb	r3, [r2, #1]
     5da:	2000      	movs	r0, #0
ERR1:
	return ret;
}
     5dc:	bd10      	pop	{r4, pc}
     5de:	46c0      	nop			; (mov r8, r8)
     5e0:	20000d10 	.word	0x20000d10
     5e4:	0000162d 	.word	0x0000162d

000005e8 <hif_chip_sleep_sc>:
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep_sc(void)
{
	if(gstrHifCxt.u8ChipSleep >= 1)
     5e8:	4b05      	ldr	r3, [pc, #20]	; (600 <hif_chip_sleep_sc+0x18>)
     5ea:	785b      	ldrb	r3, [r3, #1]
     5ec:	2b00      	cmp	r3, #0
     5ee:	d004      	beq.n	5fa <hif_chip_sleep_sc+0x12>
	{
		gstrHifCxt.u8ChipSleep--;
     5f0:	4a03      	ldr	r2, [pc, #12]	; (600 <hif_chip_sleep_sc+0x18>)
     5f2:	7853      	ldrb	r3, [r2, #1]
     5f4:	3b01      	subs	r3, #1
     5f6:	b2db      	uxtb	r3, r3
     5f8:	7053      	strb	r3, [r2, #1]
	}
	return M2M_SUCCESS;
}
     5fa:	2000      	movs	r0, #0
     5fc:	4770      	bx	lr
     5fe:	46c0      	nop			; (mov r8, r8)
     600:	20000d10 	.word	0x20000d10

00000604 <hif_chip_sleep>:
*	@brief	To make the chip sleep.
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep(void)
{
     604:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;

	if(gstrHifCxt.u8ChipSleep >= 1)
     606:	4b0a      	ldr	r3, [pc, #40]	; (630 <hif_chip_sleep+0x2c>)
     608:	785b      	ldrb	r3, [r3, #1]
     60a:	2b00      	cmp	r3, #0
     60c:	d004      	beq.n	618 <hif_chip_sleep+0x14>
	{
		gstrHifCxt.u8ChipSleep--;
     60e:	4a08      	ldr	r2, [pc, #32]	; (630 <hif_chip_sleep+0x2c>)
     610:	7853      	ldrb	r3, [r2, #1]
     612:	3b01      	subs	r3, #1
     614:	b2db      	uxtb	r3, r3
     616:	7053      	strb	r3, [r2, #1]
	}
	
	if(gstrHifCxt.u8ChipSleep == 0)
     618:	4b05      	ldr	r3, [pc, #20]	; (630 <hif_chip_sleep+0x2c>)
     61a:	785b      	ldrb	r3, [r3, #1]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep(void)
{
	sint8 ret = M2M_SUCCESS;
     61c:	2000      	movs	r0, #0
	if(gstrHifCxt.u8ChipSleep >= 1)
	{
		gstrHifCxt.u8ChipSleep--;
	}
	
	if(gstrHifCxt.u8ChipSleep == 0)
     61e:	2b00      	cmp	r3, #0
     620:	d105      	bne.n	62e <hif_chip_sleep+0x2a>
	{
		if(gstrHifCxt.u8ChipMode != M2M_NO_PS)
     622:	4b03      	ldr	r3, [pc, #12]	; (630 <hif_chip_sleep+0x2c>)
     624:	781b      	ldrb	r3, [r3, #0]
     626:	2b00      	cmp	r3, #0
     628:	d001      	beq.n	62e <hif_chip_sleep+0x2a>
		{
			ret = chip_sleep();
     62a:	4b02      	ldr	r3, [pc, #8]	; (634 <hif_chip_sleep+0x30>)
     62c:	4798      	blx	r3
		{
		}
	}
ERR1:
	return ret;
}
     62e:	bd10      	pop	{r4, pc}
     630:	20000d10 	.word	0x20000d10
     634:	000015c9 	.word	0x000015c9

00000638 <hif_send>:
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSize,
			   uint8 *pu8DataBuf,uint16 u16DataSize, uint16 u16DataOffset)
{
     638:	b5f0      	push	{r4, r5, r6, r7, lr}
     63a:	465f      	mov	r7, fp
     63c:	4656      	mov	r6, sl
     63e:	b4c0      	push	{r6, r7}
     640:	b08b      	sub	sp, #44	; 0x2c
     642:	4683      	mov	fp, r0
     644:	000c      	movs	r4, r1
     646:	9203      	str	r2, [sp, #12]
     648:	9302      	str	r3, [sp, #8]
     64a:	ab12      	add	r3, sp, #72	; 0x48
     64c:	cb80      	ldmia	r3!, {r7}
     64e:	881e      	ldrh	r6, [r3, #0]
     650:	ab14      	add	r3, sp, #80	; 0x50
     652:	881d      	ldrh	r5, [r3, #0]
	sint8		ret = M2M_ERR_SEND;
	volatile tstrHifHdr	strHif;

	strHif.u8Opcode		= u8Opcode&(~NBIT7);
     654:	227f      	movs	r2, #127	; 0x7f
     656:	400a      	ands	r2, r1
     658:	ab09      	add	r3, sp, #36	; 0x24
     65a:	705a      	strb	r2, [r3, #1]
	strHif.u8Gid		= u8Gid;
     65c:	7018      	strb	r0, [r3, #0]
	strHif.u16Length	= M2M_HIF_HDR_OFFSET;
     65e:	2208      	movs	r2, #8
     660:	805a      	strh	r2, [r3, #2]
	if(pu8DataBuf != NULL)
     662:	2f00      	cmp	r7, #0
     664:	d005      	beq.n	672 <hif_send+0x3a>
	{
		strHif.u16Length += u16DataOffset + u16DataSize;
     666:	885a      	ldrh	r2, [r3, #2]
     668:	1992      	adds	r2, r2, r6
     66a:	18aa      	adds	r2, r5, r2
     66c:	b292      	uxth	r2, r2
     66e:	805a      	strh	r2, [r3, #2]
     670:	e006      	b.n	680 <hif_send+0x48>
	}
	else
	{
		strHif.u16Length += u16CtrlBufSize;
     672:	ab09      	add	r3, sp, #36	; 0x24
     674:	885a      	ldrh	r2, [r3, #2]
     676:	9902      	ldr	r1, [sp, #8]
     678:	468c      	mov	ip, r1
     67a:	4462      	add	r2, ip
     67c:	b292      	uxth	r2, r2
     67e:	805a      	strh	r2, [r3, #2]
	}
	ret = hif_chip_wake();
     680:	4b66      	ldr	r3, [pc, #408]	; (81c <hif_send+0x1e4>)
     682:	4798      	blx	r3
     684:	9001      	str	r0, [sp, #4]
	if(ret == M2M_SUCCESS)
     686:	2800      	cmp	r0, #0
     688:	d000      	beq.n	68c <hif_send+0x54>
     68a:	e0ad      	b.n	7e8 <hif_send+0x1b0>
	{
		volatile uint32 reg, dma_addr = 0;
     68c:	9007      	str	r0, [sp, #28]
		volatile uint16 cnt = 0;
     68e:	aa04      	add	r2, sp, #16
     690:	80d0      	strh	r0, [r2, #6]
//#define OPTIMIZE_BUS 
/*please define in firmware also*/
#ifndef OPTIMIZE_BUS
		reg = 0UL;
     692:	9006      	str	r0, [sp, #24]
		reg |= (uint32)u8Gid;
     694:	9b06      	ldr	r3, [sp, #24]
     696:	465a      	mov	r2, fp
     698:	431a      	orrs	r2, r3
     69a:	9206      	str	r2, [sp, #24]
		reg |= ((uint32)u8Opcode<<8);
     69c:	9a06      	ldr	r2, [sp, #24]
     69e:	0223      	lsls	r3, r4, #8
     6a0:	4313      	orrs	r3, r2
     6a2:	9306      	str	r3, [sp, #24]
		reg |= ((uint32)strHif.u16Length<<16);
     6a4:	ab09      	add	r3, sp, #36	; 0x24
     6a6:	885b      	ldrh	r3, [r3, #2]
     6a8:	9a06      	ldr	r2, [sp, #24]
     6aa:	041b      	lsls	r3, r3, #16
     6ac:	4313      	orrs	r3, r2
     6ae:	9306      	str	r3, [sp, #24]
		ret = nm_write_reg(NMI_STATE_REG,reg);
     6b0:	9906      	ldr	r1, [sp, #24]
     6b2:	485b      	ldr	r0, [pc, #364]	; (820 <hif_send+0x1e8>)
     6b4:	4b5b      	ldr	r3, [pc, #364]	; (824 <hif_send+0x1ec>)
     6b6:	4798      	blx	r3
     6b8:	1e04      	subs	r4, r0, #0
		if(M2M_SUCCESS != ret) goto ERR1;
     6ba:	d000      	beq.n	6be <hif_send+0x86>
     6bc:	e0a5      	b.n	80a <hif_send+0x1d2>

		reg = 0UL;
     6be:	2300      	movs	r3, #0
     6c0:	9306      	str	r3, [sp, #24]
		reg |= NBIT1;
     6c2:	9a06      	ldr	r2, [sp, #24]
     6c4:	3302      	adds	r3, #2
     6c6:	4313      	orrs	r3, r2
     6c8:	9306      	str	r3, [sp, #24]
		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
     6ca:	9906      	ldr	r1, [sp, #24]
     6cc:	4856      	ldr	r0, [pc, #344]	; (828 <hif_send+0x1f0>)
     6ce:	4b55      	ldr	r3, [pc, #340]	; (824 <hif_send+0x1ec>)
     6d0:	4798      	blx	r3
     6d2:	1e04      	subs	r4, r0, #0
		if(M2M_SUCCESS != ret) goto ERR1;
     6d4:	d000      	beq.n	6d8 <hif_send+0xa0>
     6d6:	e098      	b.n	80a <hif_send+0x1d2>
		reg |= (u8Gid == M2M_REQ_GROUP_IP) ? (NBIT3):(0); /*IP = 1 or non IP*/
		reg |= ((uint32)strHif.u16Length << 4); /*length of pkt max = 4096*/
		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
		if(M2M_SUCCESS != ret) goto ERR1;
#endif
		dma_addr = 0;
     6d8:	2200      	movs	r2, #0
     6da:	9207      	str	r2, [sp, #28]
		
		for(cnt = 0; cnt < 1000; cnt ++)
     6dc:	ab04      	add	r3, sp, #16
     6de:	80da      	strh	r2, [r3, #6]
     6e0:	3306      	adds	r3, #6
     6e2:	881b      	ldrh	r3, [r3, #0]
     6e4:	b29b      	uxth	r3, r3
     6e6:	4a51      	ldr	r2, [pc, #324]	; (82c <hif_send+0x1f4>)
     6e8:	4293      	cmp	r3, r2
     6ea:	d838      	bhi.n	75e <hif_send+0x126>
		{
			ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_2,(uint32 *)&reg);
     6ec:	4c50      	ldr	r4, [pc, #320]	; (830 <hif_send+0x1f8>)
			 */
			if(cnt >= 500) {
				if(cnt < 501) {
					M2M_INFO("Slowing down...\n");
				}
				nm_bsp_sleep(1);
     6ee:	4b51      	ldr	r3, [pc, #324]	; (834 <hif_send+0x1fc>)
     6f0:	469a      	mov	sl, r3
#endif
		dma_addr = 0;
		
		for(cnt = 0; cnt < 1000; cnt ++)
		{
			ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_2,(uint32 *)&reg);
     6f2:	a906      	add	r1, sp, #24
     6f4:	484c      	ldr	r0, [pc, #304]	; (828 <hif_send+0x1f0>)
     6f6:	47a0      	blx	r4
			if(ret != M2M_SUCCESS) break;
     6f8:	2800      	cmp	r0, #0
     6fa:	d130      	bne.n	75e <hif_send+0x126>
			/*
			 * If it takes too long to get a response, the slow down to 
			 * avoid back-to-back register read operations.
			 */
			if(cnt >= 500) {
     6fc:	ab04      	add	r3, sp, #16
     6fe:	3306      	adds	r3, #6
     700:	881b      	ldrh	r3, [r3, #0]
     702:	b29b      	uxth	r3, r3
     704:	22f4      	movs	r2, #244	; 0xf4
     706:	32ff      	adds	r2, #255	; 0xff
     708:	4293      	cmp	r3, r2
     70a:	d911      	bls.n	730 <hif_send+0xf8>
				if(cnt < 501) {
     70c:	ab04      	add	r3, sp, #16
     70e:	3306      	adds	r3, #6
     710:	881b      	ldrh	r3, [r3, #0]
     712:	b29b      	uxth	r3, r3
     714:	3201      	adds	r2, #1
     716:	4293      	cmp	r3, r2
     718:	d808      	bhi.n	72c <hif_send+0xf4>
					M2M_INFO("Slowing down...\n");
     71a:	4847      	ldr	r0, [pc, #284]	; (838 <hif_send+0x200>)
     71c:	4b47      	ldr	r3, [pc, #284]	; (83c <hif_send+0x204>)
     71e:	4798      	blx	r3
     720:	4847      	ldr	r0, [pc, #284]	; (840 <hif_send+0x208>)
     722:	4b48      	ldr	r3, [pc, #288]	; (844 <hif_send+0x20c>)
     724:	4798      	blx	r3
     726:	200d      	movs	r0, #13
     728:	4b47      	ldr	r3, [pc, #284]	; (848 <hif_send+0x210>)
     72a:	4798      	blx	r3
				}
				nm_bsp_sleep(1);
     72c:	2001      	movs	r0, #1
     72e:	47d0      	blx	sl
			}
			if (!(reg & NBIT1))
     730:	9b06      	ldr	r3, [sp, #24]
     732:	079b      	lsls	r3, r3, #30
     734:	d408      	bmi.n	748 <hif_send+0x110>
			{
				ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_4,(uint32 *)&dma_addr);
     736:	a907      	add	r1, sp, #28
     738:	4844      	ldr	r0, [pc, #272]	; (84c <hif_send+0x214>)
     73a:	4b3d      	ldr	r3, [pc, #244]	; (830 <hif_send+0x1f8>)
     73c:	4798      	blx	r3
     73e:	1e04      	subs	r4, r0, #0
				if(ret != M2M_SUCCESS) {
     740:	d00d      	beq.n	75e <hif_send+0x126>
					/*in case of read error clear the DMA address and return error*/
					dma_addr = 0;
     742:	2300      	movs	r3, #0
     744:	9307      	str	r3, [sp, #28]
					goto ERR1;
     746:	e060      	b.n	80a <hif_send+0x1d2>
		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
		if(M2M_SUCCESS != ret) goto ERR1;
#endif
		dma_addr = 0;
		
		for(cnt = 0; cnt < 1000; cnt ++)
     748:	ab04      	add	r3, sp, #16
     74a:	88da      	ldrh	r2, [r3, #6]
     74c:	3201      	adds	r2, #1
     74e:	b292      	uxth	r2, r2
     750:	80da      	strh	r2, [r3, #6]
     752:	3306      	adds	r3, #6
     754:	881b      	ldrh	r3, [r3, #0]
     756:	b29b      	uxth	r3, r3
     758:	4a34      	ldr	r2, [pc, #208]	; (82c <hif_send+0x1f4>)
     75a:	4293      	cmp	r3, r2
     75c:	d9c9      	bls.n	6f2 <hif_send+0xba>
				/*in case of success break */
				break;
			}
		}

		if (dma_addr != 0)
     75e:	9b07      	ldr	r3, [sp, #28]
     760:	2b00      	cmp	r3, #0
     762:	d03c      	beq.n	7de <hif_send+0x1a6>
		{
			volatile uint32	u32CurrAddr;
			u32CurrAddr = dma_addr;
     764:	9b07      	ldr	r3, [sp, #28]
     766:	9308      	str	r3, [sp, #32]
			strHif.u16Length=NM_BSP_B_L_16(strHif.u16Length);
     768:	a909      	add	r1, sp, #36	; 0x24
     76a:	884b      	ldrh	r3, [r1, #2]
     76c:	b29b      	uxth	r3, r3
     76e:	804b      	strh	r3, [r1, #2]
			ret = nm_write_block(u32CurrAddr, (uint8*)&strHif, M2M_HIF_HDR_OFFSET);
     770:	9808      	ldr	r0, [sp, #32]
     772:	2208      	movs	r2, #8
     774:	4b36      	ldr	r3, [pc, #216]	; (850 <hif_send+0x218>)
     776:	4798      	blx	r3
     778:	1e04      	subs	r4, r0, #0
			if(M2M_SUCCESS != ret) goto ERR1;
     77a:	d146      	bne.n	80a <hif_send+0x1d2>
			u32CurrAddr += M2M_HIF_HDR_OFFSET;
     77c:	9b08      	ldr	r3, [sp, #32]
     77e:	3308      	adds	r3, #8
     780:	9308      	str	r3, [sp, #32]
			if(pu8CtrlBuf != NULL)
     782:	9b03      	ldr	r3, [sp, #12]
     784:	2b00      	cmp	r3, #0
     786:	d00b      	beq.n	7a0 <hif_send+0x168>
			{
				ret = nm_write_block(u32CurrAddr, pu8CtrlBuf, u16CtrlBufSize);
     788:	9808      	ldr	r0, [sp, #32]
     78a:	9a02      	ldr	r2, [sp, #8]
     78c:	0019      	movs	r1, r3
     78e:	4b30      	ldr	r3, [pc, #192]	; (850 <hif_send+0x218>)
     790:	4798      	blx	r3
     792:	1e04      	subs	r4, r0, #0
				if(M2M_SUCCESS != ret) goto ERR1;
     794:	d139      	bne.n	80a <hif_send+0x1d2>
				u32CurrAddr += u16CtrlBufSize;
     796:	9b08      	ldr	r3, [sp, #32]
     798:	9a02      	ldr	r2, [sp, #8]
     79a:	4694      	mov	ip, r2
     79c:	4463      	add	r3, ip
     79e:	9308      	str	r3, [sp, #32]
			}
			if(pu8DataBuf != NULL)
     7a0:	2f00      	cmp	r7, #0
     7a2:	d00e      	beq.n	7c2 <hif_send+0x18a>
			{
				u32CurrAddr += (u16DataOffset - u16CtrlBufSize);
     7a4:	9b08      	ldr	r3, [sp, #32]
     7a6:	9a02      	ldr	r2, [sp, #8]
     7a8:	1aad      	subs	r5, r5, r2
     7aa:	18ed      	adds	r5, r5, r3
     7ac:	9508      	str	r5, [sp, #32]
				ret = nm_write_block(u32CurrAddr, pu8DataBuf, u16DataSize);
     7ae:	9808      	ldr	r0, [sp, #32]
     7b0:	0032      	movs	r2, r6
     7b2:	0039      	movs	r1, r7
     7b4:	4b26      	ldr	r3, [pc, #152]	; (850 <hif_send+0x218>)
     7b6:	4798      	blx	r3
     7b8:	1e04      	subs	r4, r0, #0
				if(M2M_SUCCESS != ret) goto ERR1;
     7ba:	d126      	bne.n	80a <hif_send+0x1d2>
				u32CurrAddr += u16DataSize;
     7bc:	9b08      	ldr	r3, [sp, #32]
     7be:	18f3      	adds	r3, r6, r3
     7c0:	9308      	str	r3, [sp, #32]
			}

			reg = dma_addr << 2;
     7c2:	9b07      	ldr	r3, [sp, #28]
     7c4:	009b      	lsls	r3, r3, #2
     7c6:	9306      	str	r3, [sp, #24]
			reg |= NBIT1;
     7c8:	9a06      	ldr	r2, [sp, #24]
     7ca:	2302      	movs	r3, #2
     7cc:	4313      	orrs	r3, r2
     7ce:	9306      	str	r3, [sp, #24]
			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_3, reg);
     7d0:	9906      	ldr	r1, [sp, #24]
     7d2:	4820      	ldr	r0, [pc, #128]	; (854 <hif_send+0x21c>)
     7d4:	4b13      	ldr	r3, [pc, #76]	; (824 <hif_send+0x1ec>)
     7d6:	4798      	blx	r3
     7d8:	1e04      	subs	r4, r0, #0
			if(M2M_SUCCESS != ret) goto ERR1;
     7da:	d116      	bne.n	80a <hif_send+0x1d2>
     7dc:	e012      	b.n	804 <hif_send+0x1cc>
		}
		else
		{
			ret = hif_chip_sleep();
     7de:	4b1e      	ldr	r3, [pc, #120]	; (858 <hif_send+0x220>)
     7e0:	4798      	blx	r3
			M2M_DBG("Failed to alloc rx size %d\r",ret);
			ret = M2M_ERR_MEM_ALLOC;
     7e2:	2003      	movs	r0, #3
     7e4:	4240      	negs	r0, r0
			goto ERR2;
     7e6:	e013      	b.n	810 <hif_send+0x1d8>
		}

	}
	else
	{
		M2M_ERR("(HIF)Fail to wakup the chip\n");
     7e8:	22cb      	movs	r2, #203	; 0xcb
     7ea:	0052      	lsls	r2, r2, #1
     7ec:	491b      	ldr	r1, [pc, #108]	; (85c <hif_send+0x224>)
     7ee:	481c      	ldr	r0, [pc, #112]	; (860 <hif_send+0x228>)
     7f0:	4b12      	ldr	r3, [pc, #72]	; (83c <hif_send+0x204>)
     7f2:	4798      	blx	r3
     7f4:	481b      	ldr	r0, [pc, #108]	; (864 <hif_send+0x22c>)
     7f6:	4b13      	ldr	r3, [pc, #76]	; (844 <hif_send+0x20c>)
     7f8:	4798      	blx	r3
     7fa:	200d      	movs	r0, #13
     7fc:	4b12      	ldr	r3, [pc, #72]	; (848 <hif_send+0x210>)
     7fe:	4798      	blx	r3
	}
	else
	{
		strHif.u16Length += u16CtrlBufSize;
	}
	ret = hif_chip_wake();
     800:	9801      	ldr	r0, [sp, #4]

	}
	else
	{
		M2M_ERR("(HIF)Fail to wakup the chip\n");
		goto ERR2;
     802:	e005      	b.n	810 <hif_send+0x1d8>
	}
	/*actual sleep ret = M2M_SUCCESS*/
 	ret = hif_chip_sleep();
     804:	4b14      	ldr	r3, [pc, #80]	; (858 <hif_send+0x220>)
     806:	4798      	blx	r3
	return ret;
     808:	e002      	b.n	810 <hif_send+0x1d8>
ERR1:
	/*reset the count but no actual sleep as it already bus error*/
	hif_chip_sleep_sc();
     80a:	4b17      	ldr	r3, [pc, #92]	; (868 <hif_send+0x230>)
     80c:	4798      	blx	r3
     80e:	0020      	movs	r0, r4
ERR2:
	/*logical error*/
	return ret;
}
     810:	b00b      	add	sp, #44	; 0x2c
     812:	bc0c      	pop	{r2, r3}
     814:	4692      	mov	sl, r2
     816:	469b      	mov	fp, r3
     818:	bdf0      	pop	{r4, r5, r6, r7, pc}
     81a:	46c0      	nop			; (mov r8, r8)
     81c:	000005ad 	.word	0x000005ad
     820:	0000108c 	.word	0x0000108c
     824:	00001951 	.word	0x00001951
     828:	00001078 	.word	0x00001078
     82c:	000003e7 	.word	0x000003e7
     830:	00001945 	.word	0x00001945
     834:	00000129 	.word	0x00000129
     838:	0000b928 	.word	0x0000b928
     83c:	0000a771 	.word	0x0000a771
     840:	0000b934 	.word	0x0000b934
     844:	0000a891 	.word	0x0000a891
     848:	0000a7a5 	.word	0x0000a7a5
     84c:	00150400 	.word	0x00150400
     850:	000019c5 	.word	0x000019c5
     854:	0000106c 	.word	0x0000106c
     858:	00000605 	.word	0x00000605
     85c:	0000bc08 	.word	0x0000bc08
     860:	0000b8b4 	.word	0x0000b8b4
     864:	0000b944 	.word	0x0000b944
     868:	000005e9 	.word	0x000005e9

0000086c <hif_handle_isr>:
*	@brief	Handle interrupt received from NMC1500 firmware.
*   @return     The function SHALL return 0 for success and a negative value otherwise.
*/

sint8 hif_handle_isr(void)
{
     86c:	b5f0      	push	{r4, r5, r6, r7, lr}
     86e:	464f      	mov	r7, r9
     870:	4646      	mov	r6, r8
     872:	b4c0      	push	{r6, r7}
     874:	b087      	sub	sp, #28
	sint8 ret = M2M_SUCCESS;	
	while (gstrHifCxt.u8Interrupt) {
     876:	4bcd      	ldr	r3, [pc, #820]	; (bac <hif_handle_isr+0x340>)
     878:	4698      	mov	r8, r3
		/*must be at that place because of the race of interrupt increment and that decrement*/
		/*when the interrupt enabled*/
		gstrHifCxt.u8Interrupt--;
     87a:	4699      	mov	r9, r3
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg;
	volatile tstrHifHdr strHif;

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0, &reg);
     87c:	4ecc      	ldr	r6, [pc, #816]	; (bb0 <hif_handle_isr+0x344>)
*/

sint8 hif_handle_isr(void)
{
	sint8 ret = M2M_SUCCESS;	
	while (gstrHifCxt.u8Interrupt) {
     87e:	e1d9      	b.n	c34 <hif_handle_isr+0x3c8>
		/*must be at that place because of the race of interrupt increment and that decrement*/
		/*when the interrupt enabled*/
		gstrHifCxt.u8Interrupt--;
     880:	464b      	mov	r3, r9
     882:	78db      	ldrb	r3, [r3, #3]
     884:	3b01      	subs	r3, #1
     886:	b2db      	uxtb	r3, r3
     888:	464a      	mov	r2, r9
     88a:	70d3      	strb	r3, [r2, #3]
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg;
	volatile tstrHifHdr strHif;

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0, &reg);
     88c:	a903      	add	r1, sp, #12
     88e:	48c9      	ldr	r0, [pc, #804]	; (bb4 <hif_handle_isr+0x348>)
     890:	47b0      	blx	r6
     892:	1e04      	subs	r4, r0, #0
	if(M2M_SUCCESS == ret)
     894:	d000      	beq.n	898 <hif_handle_isr+0x2c>
     896:	e16f      	b.n	b78 <hif_handle_isr+0x30c>
	{
		if(reg & 0x1)	/* New interrupt has been received */
     898:	9b03      	ldr	r3, [sp, #12]
     89a:	07db      	lsls	r3, r3, #31
     89c:	d400      	bmi.n	8a0 <hif_handle_isr+0x34>
     89e:	e15c      	b.n	b5a <hif_handle_isr+0x2ee>
		{
			uint16 size;

			nm_bsp_interrupt_ctrl(0);
     8a0:	2000      	movs	r0, #0
     8a2:	4bc5      	ldr	r3, [pc, #788]	; (bb8 <hif_handle_isr+0x34c>)
     8a4:	4798      	blx	r3
			/*Clearing RX interrupt*/
			reg &= ~NBIT0;
     8a6:	2301      	movs	r3, #1
     8a8:	9903      	ldr	r1, [sp, #12]
     8aa:	4399      	bics	r1, r3
     8ac:	9103      	str	r1, [sp, #12]
			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
     8ae:	48c1      	ldr	r0, [pc, #772]	; (bb4 <hif_handle_isr+0x348>)
     8b0:	4bc2      	ldr	r3, [pc, #776]	; (bbc <hif_handle_isr+0x350>)
     8b2:	4798      	blx	r3
     8b4:	1e04      	subs	r4, r0, #0
			if(ret != M2M_SUCCESS)goto ERR1;
     8b6:	d000      	beq.n	8ba <hif_handle_isr+0x4e>
     8b8:	e16c      	b.n	b94 <hif_handle_isr+0x328>
			gstrHifCxt.u8HifRXDone = 1;
     8ba:	2201      	movs	r2, #1
     8bc:	4bbb      	ldr	r3, [pc, #748]	; (bac <hif_handle_isr+0x340>)
     8be:	709a      	strb	r2, [r3, #2]
			size = (uint16)((reg >> 2) & 0xfff);
     8c0:	9b03      	ldr	r3, [sp, #12]
     8c2:	0499      	lsls	r1, r3, #18
     8c4:	0d0f      	lsrs	r7, r1, #20
			if (size > 0) {
     8c6:	d100      	bne.n	8ca <hif_handle_isr+0x5e>
     8c8:	e138      	b.n	b3c <hif_handle_isr+0x2d0>
				uint32 address = 0;
     8ca:	2300      	movs	r3, #0
     8cc:	9305      	str	r3, [sp, #20]
				/**
				start bus transfer
				**/
				ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_1, &address);
     8ce:	a905      	add	r1, sp, #20
     8d0:	48bb      	ldr	r0, [pc, #748]	; (bc0 <hif_handle_isr+0x354>)
     8d2:	4bb7      	ldr	r3, [pc, #732]	; (bb0 <hif_handle_isr+0x344>)
     8d4:	4798      	blx	r3
     8d6:	1e04      	subs	r4, r0, #0
				if(M2M_SUCCESS != ret)
     8d8:	d00f      	beq.n	8fa <hif_handle_isr+0x8e>
				{
					M2M_ERR("(hif) WIFI_HOST_RCV_CTRL_1 bus fail\n");
     8da:	22c8      	movs	r2, #200	; 0xc8
     8dc:	32ff      	adds	r2, #255	; 0xff
     8de:	49b9      	ldr	r1, [pc, #740]	; (bc4 <hif_handle_isr+0x358>)
     8e0:	48b9      	ldr	r0, [pc, #740]	; (bc8 <hif_handle_isr+0x35c>)
     8e2:	4bba      	ldr	r3, [pc, #744]	; (bcc <hif_handle_isr+0x360>)
     8e4:	4798      	blx	r3
     8e6:	48ba      	ldr	r0, [pc, #744]	; (bd0 <hif_handle_isr+0x364>)
     8e8:	4bba      	ldr	r3, [pc, #744]	; (bd4 <hif_handle_isr+0x368>)
     8ea:	4798      	blx	r3
     8ec:	200d      	movs	r0, #13
     8ee:	4bba      	ldr	r3, [pc, #744]	; (bd8 <hif_handle_isr+0x36c>)
     8f0:	4798      	blx	r3
					nm_bsp_interrupt_ctrl(1);
     8f2:	2001      	movs	r0, #1
     8f4:	4bb0      	ldr	r3, [pc, #704]	; (bb8 <hif_handle_isr+0x34c>)
     8f6:	4798      	blx	r3
     8f8:	e14a      	b.n	b90 <hif_handle_isr+0x324>
					goto ERR1;
				}
				gstrHifCxt.u32RxAddr = address;
     8fa:	4bac      	ldr	r3, [pc, #688]	; (bac <hif_handle_isr+0x340>)
     8fc:	9a05      	ldr	r2, [sp, #20]
     8fe:	605a      	str	r2, [r3, #4]
				gstrHifCxt.u32RxSize = size;
     900:	609f      	str	r7, [r3, #8]
				ret = nm_read_block(address, (uint8*)&strHif, sizeof(tstrHifHdr));
     902:	ad04      	add	r5, sp, #16
     904:	2204      	movs	r2, #4
     906:	0029      	movs	r1, r5
     908:	9805      	ldr	r0, [sp, #20]
     90a:	4bb4      	ldr	r3, [pc, #720]	; (bdc <hif_handle_isr+0x370>)
     90c:	4798      	blx	r3
     90e:	0004      	movs	r4, r0
				strHif.u16Length = NM_BSP_B_L_16(strHif.u16Length);
     910:	886b      	ldrh	r3, [r5, #2]
     912:	b29b      	uxth	r3, r3
     914:	806b      	strh	r3, [r5, #2]
				if(M2M_SUCCESS != ret)
     916:	2800      	cmp	r0, #0
     918:	d00f      	beq.n	93a <hif_handle_isr+0xce>
				{
					M2M_ERR("(hif) address bus fail\n");
     91a:	22d2      	movs	r2, #210	; 0xd2
     91c:	32ff      	adds	r2, #255	; 0xff
     91e:	49a9      	ldr	r1, [pc, #676]	; (bc4 <hif_handle_isr+0x358>)
     920:	48a9      	ldr	r0, [pc, #676]	; (bc8 <hif_handle_isr+0x35c>)
     922:	4baa      	ldr	r3, [pc, #680]	; (bcc <hif_handle_isr+0x360>)
     924:	4798      	blx	r3
     926:	48ae      	ldr	r0, [pc, #696]	; (be0 <hif_handle_isr+0x374>)
     928:	4baa      	ldr	r3, [pc, #680]	; (bd4 <hif_handle_isr+0x368>)
     92a:	4798      	blx	r3
     92c:	200d      	movs	r0, #13
     92e:	4baa      	ldr	r3, [pc, #680]	; (bd8 <hif_handle_isr+0x36c>)
     930:	4798      	blx	r3
					nm_bsp_interrupt_ctrl(1);
     932:	2001      	movs	r0, #1
     934:	4ba0      	ldr	r3, [pc, #640]	; (bb8 <hif_handle_isr+0x34c>)
     936:	4798      	blx	r3
     938:	e12a      	b.n	b90 <hif_handle_isr+0x324>
					goto ERR1;
				}
				if(strHif.u16Length != size)
     93a:	ab04      	add	r3, sp, #16
     93c:	885b      	ldrh	r3, [r3, #2]
     93e:	b29b      	uxth	r3, r3
     940:	429f      	cmp	r7, r3
     942:	d01d      	beq.n	980 <hif_handle_isr+0x114>
				{
					if((size - strHif.u16Length) > 4)
     944:	ab04      	add	r3, sp, #16
     946:	885b      	ldrh	r3, [r3, #2]
     948:	1afb      	subs	r3, r7, r3
     94a:	2b04      	cmp	r3, #4
     94c:	dd18      	ble.n	980 <hif_handle_isr+0x114>
					{
						M2M_ERR("(hif) Corrupted packet Size = %u <L = %u, G = %u, OP = %02X>\n",
     94e:	22ed      	movs	r2, #237	; 0xed
     950:	0052      	lsls	r2, r2, #1
     952:	499c      	ldr	r1, [pc, #624]	; (bc4 <hif_handle_isr+0x358>)
     954:	489c      	ldr	r0, [pc, #624]	; (bc8 <hif_handle_isr+0x35c>)
     956:	4c9d      	ldr	r4, [pc, #628]	; (bcc <hif_handle_isr+0x360>)
     958:	47a0      	blx	r4
     95a:	a904      	add	r1, sp, #16
     95c:	884a      	ldrh	r2, [r1, #2]
     95e:	b292      	uxth	r2, r2
     960:	780b      	ldrb	r3, [r1, #0]
     962:	b2db      	uxtb	r3, r3
     964:	7849      	ldrb	r1, [r1, #1]
     966:	9100      	str	r1, [sp, #0]
     968:	0039      	movs	r1, r7
     96a:	489e      	ldr	r0, [pc, #632]	; (be4 <hif_handle_isr+0x378>)
     96c:	47a0      	blx	r4
     96e:	200d      	movs	r0, #13
     970:	4b99      	ldr	r3, [pc, #612]	; (bd8 <hif_handle_isr+0x36c>)
     972:	4798      	blx	r3
							size, strHif.u16Length, strHif.u8Gid, strHif.u8Opcode);
						nm_bsp_interrupt_ctrl(1);
     974:	2001      	movs	r0, #1
     976:	4b90      	ldr	r3, [pc, #576]	; (bb8 <hif_handle_isr+0x34c>)
     978:	4798      	blx	r3
						ret = M2M_ERR_BUS_FAIL;
     97a:	2406      	movs	r4, #6
     97c:	4264      	negs	r4, r4
     97e:	e107      	b.n	b90 <hif_handle_isr+0x324>
						goto ERR1;
					}
				}

				if(M2M_REQ_GROUP_WIFI == strHif.u8Gid)
     980:	ab04      	add	r3, sp, #16
     982:	781b      	ldrb	r3, [r3, #0]
     984:	2b01      	cmp	r3, #1
     986:	d11c      	bne.n	9c2 <hif_handle_isr+0x156>
				{
					if(gstrHifCxt.pfWifiCb)
     988:	4b88      	ldr	r3, [pc, #544]	; (bac <hif_handle_isr+0x340>)
     98a:	68db      	ldr	r3, [r3, #12]
     98c:	2b00      	cmp	r3, #0
     98e:	d00b      	beq.n	9a8 <hif_handle_isr+0x13c>
						gstrHifCxt.pfWifiCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
     990:	4b86      	ldr	r3, [pc, #536]	; (bac <hif_handle_isr+0x340>)
     992:	68db      	ldr	r3, [r3, #12]
     994:	aa04      	add	r2, sp, #16
     996:	7850      	ldrb	r0, [r2, #1]
     998:	b2c0      	uxtb	r0, r0
     99a:	8851      	ldrh	r1, [r2, #2]
     99c:	9a05      	ldr	r2, [sp, #20]
     99e:	3208      	adds	r2, #8
     9a0:	3908      	subs	r1, #8
     9a2:	b289      	uxth	r1, r1
     9a4:	4798      	blx	r3
     9a6:	e0b0      	b.n	b0a <hif_handle_isr+0x29e>
					else
						M2M_ERR("WIFI callback is not registered\n");
     9a8:	22f3      	movs	r2, #243	; 0xf3
     9aa:	0052      	lsls	r2, r2, #1
     9ac:	4985      	ldr	r1, [pc, #532]	; (bc4 <hif_handle_isr+0x358>)
     9ae:	4886      	ldr	r0, [pc, #536]	; (bc8 <hif_handle_isr+0x35c>)
     9b0:	4b86      	ldr	r3, [pc, #536]	; (bcc <hif_handle_isr+0x360>)
     9b2:	4798      	blx	r3
     9b4:	488c      	ldr	r0, [pc, #560]	; (be8 <hif_handle_isr+0x37c>)
     9b6:	4b87      	ldr	r3, [pc, #540]	; (bd4 <hif_handle_isr+0x368>)
     9b8:	4798      	blx	r3
     9ba:	200d      	movs	r0, #13
     9bc:	4b86      	ldr	r3, [pc, #536]	; (bd8 <hif_handle_isr+0x36c>)
     9be:	4798      	blx	r3
     9c0:	e0a3      	b.n	b0a <hif_handle_isr+0x29e>

				}
				else if(M2M_REQ_GROUP_IP == strHif.u8Gid)
     9c2:	ab04      	add	r3, sp, #16
     9c4:	781b      	ldrb	r3, [r3, #0]
     9c6:	2b02      	cmp	r3, #2
     9c8:	d11c      	bne.n	a04 <hif_handle_isr+0x198>
				{
					if(gstrHifCxt.pfIpCb)
     9ca:	4b78      	ldr	r3, [pc, #480]	; (bac <hif_handle_isr+0x340>)
     9cc:	691b      	ldr	r3, [r3, #16]
     9ce:	2b00      	cmp	r3, #0
     9d0:	d00b      	beq.n	9ea <hif_handle_isr+0x17e>
						gstrHifCxt.pfIpCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
     9d2:	4b76      	ldr	r3, [pc, #472]	; (bac <hif_handle_isr+0x340>)
     9d4:	691b      	ldr	r3, [r3, #16]
     9d6:	aa04      	add	r2, sp, #16
     9d8:	7850      	ldrb	r0, [r2, #1]
     9da:	b2c0      	uxtb	r0, r0
     9dc:	8851      	ldrh	r1, [r2, #2]
     9de:	9a05      	ldr	r2, [sp, #20]
     9e0:	3208      	adds	r2, #8
     9e2:	3908      	subs	r1, #8
     9e4:	b289      	uxth	r1, r1
     9e6:	4798      	blx	r3
     9e8:	e08f      	b.n	b0a <hif_handle_isr+0x29e>
					else
						M2M_ERR("Scoket callback is not registered\n");
     9ea:	22f7      	movs	r2, #247	; 0xf7
     9ec:	0052      	lsls	r2, r2, #1
     9ee:	4975      	ldr	r1, [pc, #468]	; (bc4 <hif_handle_isr+0x358>)
     9f0:	4875      	ldr	r0, [pc, #468]	; (bc8 <hif_handle_isr+0x35c>)
     9f2:	4b76      	ldr	r3, [pc, #472]	; (bcc <hif_handle_isr+0x360>)
     9f4:	4798      	blx	r3
     9f6:	487d      	ldr	r0, [pc, #500]	; (bec <hif_handle_isr+0x380>)
     9f8:	4b76      	ldr	r3, [pc, #472]	; (bd4 <hif_handle_isr+0x368>)
     9fa:	4798      	blx	r3
     9fc:	200d      	movs	r0, #13
     9fe:	4b76      	ldr	r3, [pc, #472]	; (bd8 <hif_handle_isr+0x36c>)
     a00:	4798      	blx	r3
     a02:	e082      	b.n	b0a <hif_handle_isr+0x29e>

				}
				else if(M2M_REQ_GROUP_OTA == strHif.u8Gid)
     a04:	ab04      	add	r3, sp, #16
     a06:	781b      	ldrb	r3, [r3, #0]
     a08:	2b04      	cmp	r3, #4
     a0a:	d11c      	bne.n	a46 <hif_handle_isr+0x1da>
				{
					if(gstrHifCxt.pfOtaCb)
     a0c:	4b67      	ldr	r3, [pc, #412]	; (bac <hif_handle_isr+0x340>)
     a0e:	695b      	ldr	r3, [r3, #20]
     a10:	2b00      	cmp	r3, #0
     a12:	d00b      	beq.n	a2c <hif_handle_isr+0x1c0>
						gstrHifCxt.pfOtaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
     a14:	4b65      	ldr	r3, [pc, #404]	; (bac <hif_handle_isr+0x340>)
     a16:	695b      	ldr	r3, [r3, #20]
     a18:	aa04      	add	r2, sp, #16
     a1a:	7850      	ldrb	r0, [r2, #1]
     a1c:	b2c0      	uxtb	r0, r0
     a1e:	8851      	ldrh	r1, [r2, #2]
     a20:	9a05      	ldr	r2, [sp, #20]
     a22:	3208      	adds	r2, #8
     a24:	3908      	subs	r1, #8
     a26:	b289      	uxth	r1, r1
     a28:	4798      	blx	r3
     a2a:	e06e      	b.n	b0a <hif_handle_isr+0x29e>
					else
						M2M_ERR("Ota callback is not registered\n");
     a2c:	22fb      	movs	r2, #251	; 0xfb
     a2e:	0052      	lsls	r2, r2, #1
     a30:	4964      	ldr	r1, [pc, #400]	; (bc4 <hif_handle_isr+0x358>)
     a32:	4865      	ldr	r0, [pc, #404]	; (bc8 <hif_handle_isr+0x35c>)
     a34:	4b65      	ldr	r3, [pc, #404]	; (bcc <hif_handle_isr+0x360>)
     a36:	4798      	blx	r3
     a38:	486d      	ldr	r0, [pc, #436]	; (bf0 <hif_handle_isr+0x384>)
     a3a:	4b66      	ldr	r3, [pc, #408]	; (bd4 <hif_handle_isr+0x368>)
     a3c:	4798      	blx	r3
     a3e:	200d      	movs	r0, #13
     a40:	4b65      	ldr	r3, [pc, #404]	; (bd8 <hif_handle_isr+0x36c>)
     a42:	4798      	blx	r3
     a44:	e061      	b.n	b0a <hif_handle_isr+0x29e>

				}
				else if(M2M_REQ_GROUP_CRYPTO == strHif.u8Gid)
     a46:	ab04      	add	r3, sp, #16
     a48:	781b      	ldrb	r3, [r3, #0]
     a4a:	2b06      	cmp	r3, #6
     a4c:	d11b      	bne.n	a86 <hif_handle_isr+0x21a>
				{
					if(gstrHifCxt.pfCryptoCb)
     a4e:	4b57      	ldr	r3, [pc, #348]	; (bac <hif_handle_isr+0x340>)
     a50:	6a1b      	ldr	r3, [r3, #32]
     a52:	2b00      	cmp	r3, #0
     a54:	d00b      	beq.n	a6e <hif_handle_isr+0x202>
						gstrHifCxt.pfCryptoCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
     a56:	4b55      	ldr	r3, [pc, #340]	; (bac <hif_handle_isr+0x340>)
     a58:	6a1b      	ldr	r3, [r3, #32]
     a5a:	aa04      	add	r2, sp, #16
     a5c:	7850      	ldrb	r0, [r2, #1]
     a5e:	b2c0      	uxtb	r0, r0
     a60:	8851      	ldrh	r1, [r2, #2]
     a62:	9a05      	ldr	r2, [sp, #20]
     a64:	3208      	adds	r2, #8
     a66:	3908      	subs	r1, #8
     a68:	b289      	uxth	r1, r1
     a6a:	4798      	blx	r3
     a6c:	e04d      	b.n	b0a <hif_handle_isr+0x29e>

					else
						M2M_ERR("Crypto callback is not registered\n");
     a6e:	4a61      	ldr	r2, [pc, #388]	; (bf4 <hif_handle_isr+0x388>)
     a70:	4954      	ldr	r1, [pc, #336]	; (bc4 <hif_handle_isr+0x358>)
     a72:	4855      	ldr	r0, [pc, #340]	; (bc8 <hif_handle_isr+0x35c>)
     a74:	4b55      	ldr	r3, [pc, #340]	; (bcc <hif_handle_isr+0x360>)
     a76:	4798      	blx	r3
     a78:	485f      	ldr	r0, [pc, #380]	; (bf8 <hif_handle_isr+0x38c>)
     a7a:	4b56      	ldr	r3, [pc, #344]	; (bd4 <hif_handle_isr+0x368>)
     a7c:	4798      	blx	r3
     a7e:	200d      	movs	r0, #13
     a80:	4b55      	ldr	r3, [pc, #340]	; (bd8 <hif_handle_isr+0x36c>)
     a82:	4798      	blx	r3
     a84:	e041      	b.n	b0a <hif_handle_isr+0x29e>
				}
				else if(M2M_REQ_GROUP_SIGMA == strHif.u8Gid)
     a86:	ab04      	add	r3, sp, #16
     a88:	781b      	ldrb	r3, [r3, #0]
     a8a:	2b07      	cmp	r3, #7
     a8c:	d11b      	bne.n	ac6 <hif_handle_isr+0x25a>
				{
					if(gstrHifCxt.pfSigmaCb)
     a8e:	4b47      	ldr	r3, [pc, #284]	; (bac <hif_handle_isr+0x340>)
     a90:	699b      	ldr	r3, [r3, #24]
     a92:	2b00      	cmp	r3, #0
     a94:	d00b      	beq.n	aae <hif_handle_isr+0x242>
						gstrHifCxt.pfSigmaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
     a96:	4b45      	ldr	r3, [pc, #276]	; (bac <hif_handle_isr+0x340>)
     a98:	699b      	ldr	r3, [r3, #24]
     a9a:	aa04      	add	r2, sp, #16
     a9c:	7850      	ldrb	r0, [r2, #1]
     a9e:	b2c0      	uxtb	r0, r0
     aa0:	8851      	ldrh	r1, [r2, #2]
     aa2:	9a05      	ldr	r2, [sp, #20]
     aa4:	3208      	adds	r2, #8
     aa6:	3908      	subs	r1, #8
     aa8:	b289      	uxth	r1, r1
     aaa:	4798      	blx	r3
     aac:	e02d      	b.n	b0a <hif_handle_isr+0x29e>
					else
						M2M_ERR("Sigma callback is not registered\n");
     aae:	4a53      	ldr	r2, [pc, #332]	; (bfc <hif_handle_isr+0x390>)
     ab0:	4944      	ldr	r1, [pc, #272]	; (bc4 <hif_handle_isr+0x358>)
     ab2:	4845      	ldr	r0, [pc, #276]	; (bc8 <hif_handle_isr+0x35c>)
     ab4:	4b45      	ldr	r3, [pc, #276]	; (bcc <hif_handle_isr+0x360>)
     ab6:	4798      	blx	r3
     ab8:	4851      	ldr	r0, [pc, #324]	; (c00 <hif_handle_isr+0x394>)
     aba:	4b46      	ldr	r3, [pc, #280]	; (bd4 <hif_handle_isr+0x368>)
     abc:	4798      	blx	r3
     abe:	200d      	movs	r0, #13
     ac0:	4b45      	ldr	r3, [pc, #276]	; (bd8 <hif_handle_isr+0x36c>)
     ac2:	4798      	blx	r3
     ac4:	e021      	b.n	b0a <hif_handle_isr+0x29e>
				}
				else if(M2M_REQ_GROUP_SSL == strHif.u8Gid)
     ac6:	ab04      	add	r3, sp, #16
     ac8:	781b      	ldrb	r3, [r3, #0]
     aca:	2b05      	cmp	r3, #5
     acc:	d10f      	bne.n	aee <hif_handle_isr+0x282>
				{
				    if(gstrHifCxt.pfSslCb)
     ace:	4b37      	ldr	r3, [pc, #220]	; (bac <hif_handle_isr+0x340>)
     ad0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     ad2:	2b00      	cmp	r3, #0
     ad4:	d019      	beq.n	b0a <hif_handle_isr+0x29e>
						gstrHifCxt.pfSslCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
     ad6:	4b35      	ldr	r3, [pc, #212]	; (bac <hif_handle_isr+0x340>)
     ad8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     ada:	aa04      	add	r2, sp, #16
     adc:	7850      	ldrb	r0, [r2, #1]
     ade:	b2c0      	uxtb	r0, r0
     ae0:	8851      	ldrh	r1, [r2, #2]
     ae2:	9a05      	ldr	r2, [sp, #20]
     ae4:	3208      	adds	r2, #8
     ae6:	3908      	subs	r1, #8
     ae8:	b289      	uxth	r1, r1
     aea:	4798      	blx	r3
     aec:	e00d      	b.n	b0a <hif_handle_isr+0x29e>
				}
				else
				{
					M2M_ERR("(hif) invalid group ID\n");
     aee:	4a45      	ldr	r2, [pc, #276]	; (c04 <hif_handle_isr+0x398>)
     af0:	4934      	ldr	r1, [pc, #208]	; (bc4 <hif_handle_isr+0x358>)
     af2:	4835      	ldr	r0, [pc, #212]	; (bc8 <hif_handle_isr+0x35c>)
     af4:	4b35      	ldr	r3, [pc, #212]	; (bcc <hif_handle_isr+0x360>)
     af6:	4798      	blx	r3
     af8:	4843      	ldr	r0, [pc, #268]	; (c08 <hif_handle_isr+0x39c>)
     afa:	4b36      	ldr	r3, [pc, #216]	; (bd4 <hif_handle_isr+0x368>)
     afc:	4798      	blx	r3
     afe:	200d      	movs	r0, #13
     b00:	4b35      	ldr	r3, [pc, #212]	; (bd8 <hif_handle_isr+0x36c>)
     b02:	4798      	blx	r3
					ret = M2M_ERR_BUS_FAIL;
     b04:	2406      	movs	r4, #6
     b06:	4264      	negs	r4, r4
     b08:	e042      	b.n	b90 <hif_handle_isr+0x324>
					goto ERR1;
				}
				if(gstrHifCxt.u8HifRXDone)
     b0a:	4b28      	ldr	r3, [pc, #160]	; (bac <hif_handle_isr+0x340>)
     b0c:	789b      	ldrb	r3, [r3, #2]
     b0e:	2b00      	cmp	r3, #0
     b10:	d03e      	beq.n	b90 <hif_handle_isr+0x324>
				{
					M2M_ERR("(hif) host app didn't set RX Done <%u><%X>\n", strHif.u8Gid, strHif.u8Opcode);
     b12:	4a3e      	ldr	r2, [pc, #248]	; (c0c <hif_handle_isr+0x3a0>)
     b14:	492b      	ldr	r1, [pc, #172]	; (bc4 <hif_handle_isr+0x358>)
     b16:	482c      	ldr	r0, [pc, #176]	; (bc8 <hif_handle_isr+0x35c>)
     b18:	4d2c      	ldr	r5, [pc, #176]	; (bcc <hif_handle_isr+0x360>)
     b1a:	47a8      	blx	r5
     b1c:	ab04      	add	r3, sp, #16
     b1e:	7819      	ldrb	r1, [r3, #0]
     b20:	b2c9      	uxtb	r1, r1
     b22:	785a      	ldrb	r2, [r3, #1]
     b24:	b2d2      	uxtb	r2, r2
     b26:	483a      	ldr	r0, [pc, #232]	; (c10 <hif_handle_isr+0x3a4>)
     b28:	47a8      	blx	r5
     b2a:	200d      	movs	r0, #13
     b2c:	4b2a      	ldr	r3, [pc, #168]	; (bd8 <hif_handle_isr+0x36c>)
     b2e:	4798      	blx	r3
					ret = hif_set_rx_done();
     b30:	4b38      	ldr	r3, [pc, #224]	; (c14 <hif_handle_isr+0x3a8>)
     b32:	4798      	blx	r3
					if(ret != M2M_SUCCESS) goto ERR1;
     b34:	2800      	cmp	r0, #0
     b36:	d02b      	beq.n	b90 <hif_handle_isr+0x324>
					goto ERR1;
				}
				if(gstrHifCxt.u8HifRXDone)
				{
					M2M_ERR("(hif) host app didn't set RX Done <%u><%X>\n", strHif.u8Gid, strHif.u8Opcode);
					ret = hif_set_rx_done();
     b38:	0004      	movs	r4, r0
     b3a:	e029      	b.n	b90 <hif_handle_isr+0x324>
					if(ret != M2M_SUCCESS) goto ERR1;
				}
			}
			else
			{
				M2M_ERR("(hif) Wrong Size\n");
     b3c:	2287      	movs	r2, #135	; 0x87
     b3e:	0092      	lsls	r2, r2, #2
     b40:	4920      	ldr	r1, [pc, #128]	; (bc4 <hif_handle_isr+0x358>)
     b42:	4821      	ldr	r0, [pc, #132]	; (bc8 <hif_handle_isr+0x35c>)
     b44:	4b21      	ldr	r3, [pc, #132]	; (bcc <hif_handle_isr+0x360>)
     b46:	4798      	blx	r3
     b48:	4833      	ldr	r0, [pc, #204]	; (c18 <hif_handle_isr+0x3ac>)
     b4a:	4b22      	ldr	r3, [pc, #136]	; (bd4 <hif_handle_isr+0x368>)
     b4c:	4798      	blx	r3
     b4e:	200d      	movs	r0, #13
     b50:	4b21      	ldr	r3, [pc, #132]	; (bd8 <hif_handle_isr+0x36c>)
     b52:	4798      	blx	r3
				ret = M2M_ERR_RCV;
     b54:	2402      	movs	r4, #2
     b56:	4264      	negs	r4, r4
     b58:	e01c      	b.n	b94 <hif_handle_isr+0x328>
			}
		}
		else
		{
#ifndef WIN32
			M2M_ERR("(hif) False interrupt %lx",reg);
     b5a:	2289      	movs	r2, #137	; 0x89
     b5c:	0092      	lsls	r2, r2, #2
     b5e:	4919      	ldr	r1, [pc, #100]	; (bc4 <hif_handle_isr+0x358>)
     b60:	4819      	ldr	r0, [pc, #100]	; (bc8 <hif_handle_isr+0x35c>)
     b62:	4c1a      	ldr	r4, [pc, #104]	; (bcc <hif_handle_isr+0x360>)
     b64:	47a0      	blx	r4
     b66:	9903      	ldr	r1, [sp, #12]
     b68:	482c      	ldr	r0, [pc, #176]	; (c1c <hif_handle_isr+0x3b0>)
     b6a:	47a0      	blx	r4
     b6c:	200d      	movs	r0, #13
     b6e:	4b1a      	ldr	r3, [pc, #104]	; (bd8 <hif_handle_isr+0x36c>)
     b70:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
     b72:	240c      	movs	r4, #12
     b74:	4264      	negs	r4, r4
     b76:	e00d      	b.n	b94 <hif_handle_isr+0x328>
#endif
		}
	}
	else
	{
		M2M_ERR("(hif) Fail to Read interrupt reg\n");
     b78:	4a29      	ldr	r2, [pc, #164]	; (c20 <hif_handle_isr+0x3b4>)
     b7a:	4912      	ldr	r1, [pc, #72]	; (bc4 <hif_handle_isr+0x358>)
     b7c:	4812      	ldr	r0, [pc, #72]	; (bc8 <hif_handle_isr+0x35c>)
     b7e:	4b13      	ldr	r3, [pc, #76]	; (bcc <hif_handle_isr+0x360>)
     b80:	4798      	blx	r3
     b82:	4828      	ldr	r0, [pc, #160]	; (c24 <hif_handle_isr+0x3b8>)
     b84:	4b13      	ldr	r3, [pc, #76]	; (bd4 <hif_handle_isr+0x368>)
     b86:	4798      	blx	r3
     b88:	200d      	movs	r0, #13
     b8a:	4b13      	ldr	r3, [pc, #76]	; (bd8 <hif_handle_isr+0x36c>)
     b8c:	4798      	blx	r3
     b8e:	e001      	b.n	b94 <hif_handle_isr+0x328>
		/*when the interrupt enabled*/
		gstrHifCxt.u8Interrupt--;
		while(1)
		{
			ret = hif_isr();
			if(ret == M2M_SUCCESS) {
     b90:	2c00      	cmp	r4, #0
     b92:	d04f      	beq.n	c34 <hif_handle_isr+0x3c8>
				/*we will try forever untill we get that interrupt*/
				/*Fail return errors here due to bus errors (reading expected values)*/
				break;
			} else {
				M2M_ERR("(HIF) Fail to handle interrupt %d try Again..\n",ret);
     b94:	4a24      	ldr	r2, [pc, #144]	; (c28 <hif_handle_isr+0x3bc>)
     b96:	4925      	ldr	r1, [pc, #148]	; (c2c <hif_handle_isr+0x3c0>)
     b98:	480b      	ldr	r0, [pc, #44]	; (bc8 <hif_handle_isr+0x35c>)
     b9a:	4d0c      	ldr	r5, [pc, #48]	; (bcc <hif_handle_isr+0x360>)
     b9c:	47a8      	blx	r5
     b9e:	0021      	movs	r1, r4
     ba0:	4823      	ldr	r0, [pc, #140]	; (c30 <hif_handle_isr+0x3c4>)
     ba2:	47a8      	blx	r5
     ba4:	200d      	movs	r0, #13
     ba6:	4b0c      	ldr	r3, [pc, #48]	; (bd8 <hif_handle_isr+0x36c>)
     ba8:	4798      	blx	r3
			}
		}
     baa:	e66f      	b.n	88c <hif_handle_isr+0x20>
     bac:	20000d10 	.word	0x20000d10
     bb0:	00001945 	.word	0x00001945
     bb4:	00001070 	.word	0x00001070
     bb8:	00000259 	.word	0x00000259
     bbc:	00001951 	.word	0x00001951
     bc0:	00001084 	.word	0x00001084
     bc4:	0000bc14 	.word	0x0000bc14
     bc8:	0000b8b4 	.word	0x0000b8b4
     bcc:	0000a771 	.word	0x0000a771
     bd0:	0000b960 	.word	0x0000b960
     bd4:	0000a891 	.word	0x0000a891
     bd8:	0000a7a5 	.word	0x0000a7a5
     bdc:	0000195d 	.word	0x0000195d
     be0:	0000b984 	.word	0x0000b984
     be4:	0000b99c 	.word	0x0000b99c
     be8:	0000b9dc 	.word	0x0000b9dc
     bec:	0000b9fc 	.word	0x0000b9fc
     bf0:	0000ba20 	.word	0x0000ba20
     bf4:	000001ff 	.word	0x000001ff
     bf8:	0000ba40 	.word	0x0000ba40
     bfc:	00000206 	.word	0x00000206
     c00:	0000ba64 	.word	0x0000ba64
     c04:	0000020f 	.word	0x0000020f
     c08:	0000ba88 	.word	0x0000ba88
     c0c:	00000215 	.word	0x00000215
     c10:	0000baa0 	.word	0x0000baa0
     c14:	00000569 	.word	0x00000569
     c18:	0000bacc 	.word	0x0000bacc
     c1c:	0000bae0 	.word	0x0000bae0
     c20:	0000022d 	.word	0x0000022d
     c24:	0000bafc 	.word	0x0000bafc
     c28:	0000024a 	.word	0x0000024a
     c2c:	0000b8fc 	.word	0x0000b8fc
     c30:	0000bb20 	.word	0x0000bb20
*/

sint8 hif_handle_isr(void)
{
	sint8 ret = M2M_SUCCESS;	
	while (gstrHifCxt.u8Interrupt) {
     c34:	4643      	mov	r3, r8
     c36:	78db      	ldrb	r3, [r3, #3]
     c38:	2b00      	cmp	r3, #0
     c3a:	d000      	beq.n	c3e <hif_handle_isr+0x3d2>
     c3c:	e620      	b.n	880 <hif_handle_isr+0x14>
			}
		}
	}

	return ret;
}
     c3e:	2000      	movs	r0, #0
     c40:	b007      	add	sp, #28
     c42:	bc0c      	pop	{r2, r3}
     c44:	4690      	mov	r8, r2
     c46:	4699      	mov	r9, r3
     c48:	bdf0      	pop	{r4, r5, r6, r7, pc}
     c4a:	46c0      	nop			; (mov r8, r8)

00000c4c <hif_receive>:
*	@param [in]	isDone
*				If you don't need any more packets send True otherwise send false
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/
sint8 hif_receive(uint32 u32Addr, uint8 *pu8Buf, uint16 u16Sz, uint8 isDone)
{
     c4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     c4e:	0014      	movs	r4, r2
     c50:	001d      	movs	r5, r3
	sint8 ret = M2M_SUCCESS;
	if((u32Addr == 0)||(pu8Buf == NULL) || (u16Sz == 0))
     c52:	2800      	cmp	r0, #0
     c54:	d003      	beq.n	c5e <hif_receive+0x12>
     c56:	2900      	cmp	r1, #0
     c58:	d001      	beq.n	c5e <hif_receive+0x12>
     c5a:	2a00      	cmp	r2, #0
     c5c:	d112      	bne.n	c84 <hif_receive+0x38>
	{
		if(isDone)
     c5e:	2d00      	cmp	r5, #0
     c60:	d002      	beq.n	c68 <hif_receive+0x1c>
		{			
			/* set RX done */
			ret = hif_set_rx_done();
     c62:	4b27      	ldr	r3, [pc, #156]	; (d00 <hif_receive+0xb4>)
     c64:	4798      	blx	r3
     c66:	e049      	b.n	cfc <hif_receive+0xb0>
		}
		else
		{
			ret = M2M_ERR_FAIL;
			M2M_ERR(" hif_receive: Invalid argument\n");
     c68:	4a26      	ldr	r2, [pc, #152]	; (d04 <hif_receive+0xb8>)
     c6a:	4927      	ldr	r1, [pc, #156]	; (d08 <hif_receive+0xbc>)
     c6c:	4827      	ldr	r0, [pc, #156]	; (d0c <hif_receive+0xc0>)
     c6e:	4b28      	ldr	r3, [pc, #160]	; (d10 <hif_receive+0xc4>)
     c70:	4798      	blx	r3
     c72:	4828      	ldr	r0, [pc, #160]	; (d14 <hif_receive+0xc8>)
     c74:	4b28      	ldr	r3, [pc, #160]	; (d18 <hif_receive+0xcc>)
     c76:	4798      	blx	r3
     c78:	200d      	movs	r0, #13
     c7a:	4b28      	ldr	r3, [pc, #160]	; (d1c <hif_receive+0xd0>)
     c7c:	4798      	blx	r3
			/* set RX done */
			ret = hif_set_rx_done();
		}
		else
		{
			ret = M2M_ERR_FAIL;
     c7e:	200c      	movs	r0, #12
     c80:	4240      	negs	r0, r0
     c82:	e03b      	b.n	cfc <hif_receive+0xb0>
			M2M_ERR(" hif_receive: Invalid argument\n");
		}
		goto ERR1;
	}

	if(u16Sz > gstrHifCxt.u32RxSize)
     c84:	4b26      	ldr	r3, [pc, #152]	; (d20 <hif_receive+0xd4>)
     c86:	689b      	ldr	r3, [r3, #8]
     c88:	429a      	cmp	r2, r3
     c8a:	d90f      	bls.n	cac <hif_receive+0x60>
	{
		ret = M2M_ERR_FAIL;
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%u><%lu>\n",u16Sz, gstrHifCxt.u32RxSize);
     c8c:	4a25      	ldr	r2, [pc, #148]	; (d24 <hif_receive+0xd8>)
     c8e:	491e      	ldr	r1, [pc, #120]	; (d08 <hif_receive+0xbc>)
     c90:	481e      	ldr	r0, [pc, #120]	; (d0c <hif_receive+0xc0>)
     c92:	4d1f      	ldr	r5, [pc, #124]	; (d10 <hif_receive+0xc4>)
     c94:	47a8      	blx	r5
     c96:	4b22      	ldr	r3, [pc, #136]	; (d20 <hif_receive+0xd4>)
     c98:	689a      	ldr	r2, [r3, #8]
     c9a:	0021      	movs	r1, r4
     c9c:	4822      	ldr	r0, [pc, #136]	; (d28 <hif_receive+0xdc>)
     c9e:	47a8      	blx	r5
     ca0:	200d      	movs	r0, #13
     ca2:	4b1e      	ldr	r3, [pc, #120]	; (d1c <hif_receive+0xd0>)
     ca4:	4798      	blx	r3
		goto ERR1;
	}

	if(u16Sz > gstrHifCxt.u32RxSize)
	{
		ret = M2M_ERR_FAIL;
     ca6:	200c      	movs	r0, #12
     ca8:	4240      	negs	r0, r0
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%u><%lu>\n",u16Sz, gstrHifCxt.u32RxSize);
		goto ERR1;
     caa:	e027      	b.n	cfc <hif_receive+0xb0>
	}
	if((u32Addr < gstrHifCxt.u32RxAddr)||((u32Addr + u16Sz)>(gstrHifCxt.u32RxAddr + gstrHifCxt.u32RxSize)))
     cac:	4b1c      	ldr	r3, [pc, #112]	; (d20 <hif_receive+0xd4>)
     cae:	685b      	ldr	r3, [r3, #4]
     cb0:	4298      	cmp	r0, r3
     cb2:	d306      	bcc.n	cc2 <hif_receive+0x76>
     cb4:	1886      	adds	r6, r0, r2
     cb6:	4a1a      	ldr	r2, [pc, #104]	; (d20 <hif_receive+0xd4>)
     cb8:	6857      	ldr	r7, [r2, #4]
     cba:	6893      	ldr	r3, [r2, #8]
     cbc:	18fb      	adds	r3, r7, r3
     cbe:	429e      	cmp	r6, r3
     cc0:	d90d      	bls.n	cde <hif_receive+0x92>
	{
		ret = M2M_ERR_FAIL;
		M2M_ERR("APP Requested Address beyond the recived buffer address and length\n");
     cc2:	4a1a      	ldr	r2, [pc, #104]	; (d2c <hif_receive+0xe0>)
     cc4:	4910      	ldr	r1, [pc, #64]	; (d08 <hif_receive+0xbc>)
     cc6:	4811      	ldr	r0, [pc, #68]	; (d0c <hif_receive+0xc0>)
     cc8:	4b11      	ldr	r3, [pc, #68]	; (d10 <hif_receive+0xc4>)
     cca:	4798      	blx	r3
     ccc:	4818      	ldr	r0, [pc, #96]	; (d30 <hif_receive+0xe4>)
     cce:	4b12      	ldr	r3, [pc, #72]	; (d18 <hif_receive+0xcc>)
     cd0:	4798      	blx	r3
     cd2:	200d      	movs	r0, #13
     cd4:	4b11      	ldr	r3, [pc, #68]	; (d1c <hif_receive+0xd0>)
     cd6:	4798      	blx	r3
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%u><%lu>\n",u16Sz, gstrHifCxt.u32RxSize);
		goto ERR1;
	}
	if((u32Addr < gstrHifCxt.u32RxAddr)||((u32Addr + u16Sz)>(gstrHifCxt.u32RxAddr + gstrHifCxt.u32RxSize)))
	{
		ret = M2M_ERR_FAIL;
     cd8:	200c      	movs	r0, #12
     cda:	4240      	negs	r0, r0
		M2M_ERR("APP Requested Address beyond the recived buffer address and length\n");
		goto ERR1;
     cdc:	e00e      	b.n	cfc <hif_receive+0xb0>
	}
	
	/* Receive the payload */
	ret = nm_read_block(u32Addr, pu8Buf, u16Sz);
     cde:	0022      	movs	r2, r4
     ce0:	4b14      	ldr	r3, [pc, #80]	; (d34 <hif_receive+0xe8>)
     ce2:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
     ce4:	2800      	cmp	r0, #0
     ce6:	d109      	bne.n	cfc <hif_receive+0xb0>

	/* check if this is the last packet */
	if((((gstrHifCxt.u32RxAddr + gstrHifCxt.u32RxSize) - (u32Addr + u16Sz)) <= 0) || isDone)
     ce8:	4a0d      	ldr	r2, [pc, #52]	; (d20 <hif_receive+0xd4>)
     cea:	6851      	ldr	r1, [r2, #4]
     cec:	6893      	ldr	r3, [r2, #8]
     cee:	18cb      	adds	r3, r1, r3
     cf0:	429e      	cmp	r6, r3
     cf2:	d001      	beq.n	cf8 <hif_receive+0xac>
     cf4:	2d00      	cmp	r5, #0
     cf6:	d001      	beq.n	cfc <hif_receive+0xb0>
	{
		/* set RX done */
		ret = hif_set_rx_done();
     cf8:	4b01      	ldr	r3, [pc, #4]	; (d00 <hif_receive+0xb4>)
     cfa:	4798      	blx	r3
	}

ERR1:
	return ret;
}
     cfc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     cfe:	46c0      	nop			; (mov r8, r8)
     d00:	00000569 	.word	0x00000569
     d04:	0000026b 	.word	0x0000026b
     d08:	0000b90c 	.word	0x0000b90c
     d0c:	0000b8b4 	.word	0x0000b8b4
     d10:	0000a771 	.word	0x0000a771
     d14:	0000bb50 	.word	0x0000bb50
     d18:	0000a891 	.word	0x0000a891
     d1c:	0000a7a5 	.word	0x0000a7a5
     d20:	20000d10 	.word	0x20000d10
     d24:	00000273 	.word	0x00000273
     d28:	0000bb70 	.word	0x0000bb70
     d2c:	00000279 	.word	0x00000279
     d30:	0000bbb8 	.word	0x0000bbb8
     d34:	0000195d 	.word	0x0000195d

00000d38 <hif_register_cb>:
*				function to be set
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
     d38:	b570      	push	{r4, r5, r6, lr}
     d3a:	1e04      	subs	r4, r0, #0
	sint8 ret = M2M_SUCCESS;
	switch(u8Grp)
     d3c:	2c07      	cmp	r4, #7
     d3e:	d81f      	bhi.n	d80 <hif_register_cb+0x48>
     d40:	0083      	lsls	r3, r0, #2
     d42:	4a16      	ldr	r2, [pc, #88]	; (d9c <hif_register_cb+0x64>)
     d44:	58d3      	ldr	r3, [r2, r3]
     d46:	469f      	mov	pc, r3
	{
		case M2M_REQ_GROUP_IP:
			gstrHifCxt.pfIpCb = fn;
     d48:	4b15      	ldr	r3, [pc, #84]	; (da0 <hif_register_cb+0x68>)
     d4a:	6119      	str	r1, [r3, #16]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
     d4c:	2000      	movs	r0, #0
	switch(u8Grp)
	{
		case M2M_REQ_GROUP_IP:
			gstrHifCxt.pfIpCb = fn;
			break;
     d4e:	e024      	b.n	d9a <hif_register_cb+0x62>
		case M2M_REQ_GROUP_WIFI:
			gstrHifCxt.pfWifiCb = fn;
     d50:	4b13      	ldr	r3, [pc, #76]	; (da0 <hif_register_cb+0x68>)
     d52:	60d9      	str	r1, [r3, #12]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
     d54:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_IP:
			gstrHifCxt.pfIpCb = fn;
			break;
		case M2M_REQ_GROUP_WIFI:
			gstrHifCxt.pfWifiCb = fn;
			break;
     d56:	e020      	b.n	d9a <hif_register_cb+0x62>
		case M2M_REQ_GROUP_OTA:
			gstrHifCxt.pfOtaCb = fn;
     d58:	4b11      	ldr	r3, [pc, #68]	; (da0 <hif_register_cb+0x68>)
     d5a:	6159      	str	r1, [r3, #20]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
     d5c:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_WIFI:
			gstrHifCxt.pfWifiCb = fn;
			break;
		case M2M_REQ_GROUP_OTA:
			gstrHifCxt.pfOtaCb = fn;
			break;
     d5e:	e01c      	b.n	d9a <hif_register_cb+0x62>
		case M2M_REQ_GROUP_HIF:
			gstrHifCxt.pfHifCb = fn;
     d60:	4b0f      	ldr	r3, [pc, #60]	; (da0 <hif_register_cb+0x68>)
     d62:	61d9      	str	r1, [r3, #28]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
     d64:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_OTA:
			gstrHifCxt.pfOtaCb = fn;
			break;
		case M2M_REQ_GROUP_HIF:
			gstrHifCxt.pfHifCb = fn;
			break;
     d66:	e018      	b.n	d9a <hif_register_cb+0x62>
		case M2M_REQ_GROUP_CRYPTO:
			gstrHifCxt.pfCryptoCb = fn;
     d68:	4b0d      	ldr	r3, [pc, #52]	; (da0 <hif_register_cb+0x68>)
     d6a:	6219      	str	r1, [r3, #32]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
     d6c:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_HIF:
			gstrHifCxt.pfHifCb = fn;
			break;
		case M2M_REQ_GROUP_CRYPTO:
			gstrHifCxt.pfCryptoCb = fn;
			break;
     d6e:	e014      	b.n	d9a <hif_register_cb+0x62>
		case M2M_REQ_GROUP_SIGMA:
			gstrHifCxt.pfSigmaCb = fn;
     d70:	4b0b      	ldr	r3, [pc, #44]	; (da0 <hif_register_cb+0x68>)
     d72:	6199      	str	r1, [r3, #24]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
     d74:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_CRYPTO:
			gstrHifCxt.pfCryptoCb = fn;
			break;
		case M2M_REQ_GROUP_SIGMA:
			gstrHifCxt.pfSigmaCb = fn;
			break;
     d76:	e010      	b.n	d9a <hif_register_cb+0x62>
		case M2M_REQ_GROUP_SSL:
			gstrHifCxt.pfSslCb = fn;
     d78:	4b09      	ldr	r3, [pc, #36]	; (da0 <hif_register_cb+0x68>)
     d7a:	6259      	str	r1, [r3, #36]	; 0x24
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
     d7c:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_SIGMA:
			gstrHifCxt.pfSigmaCb = fn;
			break;
		case M2M_REQ_GROUP_SSL:
			gstrHifCxt.pfSslCb = fn;
			break;
     d7e:	e00c      	b.n	d9a <hif_register_cb+0x62>
		default:
			M2M_ERR("GRp ? %d\n",u8Grp);
     d80:	4a08      	ldr	r2, [pc, #32]	; (da4 <hif_register_cb+0x6c>)
     d82:	4909      	ldr	r1, [pc, #36]	; (da8 <hif_register_cb+0x70>)
     d84:	4809      	ldr	r0, [pc, #36]	; (dac <hif_register_cb+0x74>)
     d86:	4d0a      	ldr	r5, [pc, #40]	; (db0 <hif_register_cb+0x78>)
     d88:	47a8      	blx	r5
     d8a:	0021      	movs	r1, r4
     d8c:	4809      	ldr	r0, [pc, #36]	; (db4 <hif_register_cb+0x7c>)
     d8e:	47a8      	blx	r5
     d90:	200d      	movs	r0, #13
     d92:	4b09      	ldr	r3, [pc, #36]	; (db8 <hif_register_cb+0x80>)
     d94:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
     d96:	200c      	movs	r0, #12
     d98:	4240      	negs	r0, r0
			break;
	}
	return ret;
}
     d9a:	bd70      	pop	{r4, r5, r6, pc}
     d9c:	0000b8dc 	.word	0x0000b8dc
     da0:	20000d10 	.word	0x20000d10
     da4:	000002b1 	.word	0x000002b1
     da8:	0000b918 	.word	0x0000b918
     dac:	0000b8b4 	.word	0x0000b8b4
     db0:	0000a771 	.word	0x0000a771
     db4:	0000bbfc 	.word	0x0000bbfc
     db8:	0000a7a5 	.word	0x0000a7a5

00000dbc <hif_init>:
*				Pointer to the arguments.
*   @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_init(void * arg)
{
     dbc:	b510      	push	{r4, lr}
	m2m_memset((uint8*)&gstrHifCxt,0,sizeof(tstrHifContext));
     dbe:	2228      	movs	r2, #40	; 0x28
     dc0:	2100      	movs	r1, #0
     dc2:	4806      	ldr	r0, [pc, #24]	; (ddc <hif_init+0x20>)
     dc4:	4b06      	ldr	r3, [pc, #24]	; (de0 <hif_init+0x24>)
     dc6:	4798      	blx	r3
	nm_bsp_register_isr(isr);
     dc8:	4806      	ldr	r0, [pc, #24]	; (de4 <hif_init+0x28>)
     dca:	4b07      	ldr	r3, [pc, #28]	; (de8 <hif_init+0x2c>)
     dcc:	4798      	blx	r3
	hif_register_cb(M2M_REQ_GROUP_HIF,m2m_hif_cb);
     dce:	4907      	ldr	r1, [pc, #28]	; (dec <hif_init+0x30>)
     dd0:	2003      	movs	r0, #3
     dd2:	4b07      	ldr	r3, [pc, #28]	; (df0 <hif_init+0x34>)
     dd4:	4798      	blx	r3
	return M2M_SUCCESS;
}
     dd6:	2000      	movs	r0, #0
     dd8:	bd10      	pop	{r4, pc}
     dda:	46c0      	nop			; (mov r8, r8)
     ddc:	20000d10 	.word	0x20000d10
     de0:	00000529 	.word	0x00000529
     de4:	00000555 	.word	0x00000555
     de8:	00000201 	.word	0x00000201
     dec:	00000565 	.word	0x00000565
     df0:	00000d39 	.word	0x00000d39

00000df4 <m2m_wifi_cb>:
*	@author
*	@date
*	@version	1.0
*/
static void m2m_wifi_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
{
     df4:	b530      	push	{r4, r5, lr}
     df6:	b09f      	sub	sp, #124	; 0x7c
     df8:	0004      	movs	r4, r0
     dfa:	0015      	movs	r5, r2
	uint8 rx_buf[8];
	if (u8OpCode == M2M_WIFI_RESP_CON_STATE_CHANGED)
     dfc:	282c      	cmp	r0, #44	; 0x2c
     dfe:	d111      	bne.n	e24 <m2m_wifi_cb+0x30>
	{
		tstrM2mWifiStateChanged strState;
		if (hif_receive(u32Addr, (uint8*) &strState,sizeof(tstrM2mWifiStateChanged), 0) == M2M_SUCCESS)
     e00:	2300      	movs	r3, #0
     e02:	2204      	movs	r2, #4
     e04:	a903      	add	r1, sp, #12
     e06:	0028      	movs	r0, r5
     e08:	4c94      	ldr	r4, [pc, #592]	; (105c <m2m_wifi_cb+0x268>)
     e0a:	47a0      	blx	r4
     e0c:	2800      	cmp	r0, #0
     e0e:	d000      	beq.n	e12 <m2m_wifi_cb+0x1e>
     e10:	e122      	b.n	1058 <m2m_wifi_cb+0x264>
		{
			if (gpfAppWifiCb)
     e12:	4b93      	ldr	r3, [pc, #588]	; (1060 <m2m_wifi_cb+0x26c>)
     e14:	681b      	ldr	r3, [r3, #0]
     e16:	2b00      	cmp	r3, #0
     e18:	d100      	bne.n	e1c <m2m_wifi_cb+0x28>
     e1a:	e11d      	b.n	1058 <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_CON_STATE_CHANGED, &strState);
     e1c:	a903      	add	r1, sp, #12
     e1e:	302c      	adds	r0, #44	; 0x2c
     e20:	4798      	blx	r3
     e22:	e119      	b.n	1058 <m2m_wifi_cb+0x264>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_GET_SYS_TIME)
     e24:	281b      	cmp	r0, #27
     e26:	d111      	bne.n	e4c <m2m_wifi_cb+0x58>
	{
		tstrSystemTime strSysTime;
		if (hif_receive(u32Addr, (uint8*) &strSysTime,sizeof(tstrSystemTime), 0) == M2M_SUCCESS)
     e28:	2300      	movs	r3, #0
     e2a:	2208      	movs	r2, #8
     e2c:	a903      	add	r1, sp, #12
     e2e:	0028      	movs	r0, r5
     e30:	4c8a      	ldr	r4, [pc, #552]	; (105c <m2m_wifi_cb+0x268>)
     e32:	47a0      	blx	r4
     e34:	2800      	cmp	r0, #0
     e36:	d000      	beq.n	e3a <m2m_wifi_cb+0x46>
     e38:	e10e      	b.n	1058 <m2m_wifi_cb+0x264>
		{
			if (gpfAppWifiCb)
     e3a:	4b89      	ldr	r3, [pc, #548]	; (1060 <m2m_wifi_cb+0x26c>)
     e3c:	681b      	ldr	r3, [r3, #0]
     e3e:	2b00      	cmp	r3, #0
     e40:	d100      	bne.n	e44 <m2m_wifi_cb+0x50>
     e42:	e109      	b.n	1058 <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_GET_SYS_TIME, &strSysTime);
     e44:	a903      	add	r1, sp, #12
     e46:	301b      	adds	r0, #27
     e48:	4798      	blx	r3
     e4a:	e105      	b.n	1058 <m2m_wifi_cb+0x264>
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_CONN_INFO)
     e4c:	2806      	cmp	r0, #6
     e4e:	d111      	bne.n	e74 <m2m_wifi_cb+0x80>
	{
		tstrM2MConnInfo		strConnInfo;
		if(hif_receive(u32Addr, (uint8*)&strConnInfo, sizeof(tstrM2MConnInfo), 1) == M2M_SUCCESS)
     e50:	2301      	movs	r3, #1
     e52:	2230      	movs	r2, #48	; 0x30
     e54:	a903      	add	r1, sp, #12
     e56:	0028      	movs	r0, r5
     e58:	4c80      	ldr	r4, [pc, #512]	; (105c <m2m_wifi_cb+0x268>)
     e5a:	47a0      	blx	r4
     e5c:	2800      	cmp	r0, #0
     e5e:	d000      	beq.n	e62 <m2m_wifi_cb+0x6e>
     e60:	e0fa      	b.n	1058 <m2m_wifi_cb+0x264>
		{
			if(gpfAppWifiCb)
     e62:	4b7f      	ldr	r3, [pc, #508]	; (1060 <m2m_wifi_cb+0x26c>)
     e64:	681b      	ldr	r3, [r3, #0]
     e66:	2b00      	cmp	r3, #0
     e68:	d100      	bne.n	e6c <m2m_wifi_cb+0x78>
     e6a:	e0f5      	b.n	1058 <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_CONN_INFO, &strConnInfo);
     e6c:	a903      	add	r1, sp, #12
     e6e:	3006      	adds	r0, #6
     e70:	4798      	blx	r3
     e72:	e0f1      	b.n	1058 <m2m_wifi_cb+0x264>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_MEMORY_RECOVER)
     e74:	280e      	cmp	r0, #14
     e76:	d100      	bne.n	e7a <m2m_wifi_cb+0x86>
     e78:	e0ee      	b.n	1058 <m2m_wifi_cb+0x264>
			if (app_wifi_recover_cb)
				app_wifi_recover_cb(strState.u8CurrState);
		}
#endif
	}
	else if (u8OpCode == M2M_WIFI_REQ_DHCP_CONF)
     e7a:	2832      	cmp	r0, #50	; 0x32
     e7c:	d111      	bne.n	ea2 <m2m_wifi_cb+0xae>
	{
		tstrM2MIPConfig strIpConfig;
		if (hif_receive(u32Addr, (uint8 *)&strIpConfig, sizeof(tstrM2MIPConfig), 0) == M2M_SUCCESS)
     e7e:	2300      	movs	r3, #0
     e80:	2214      	movs	r2, #20
     e82:	a903      	add	r1, sp, #12
     e84:	0028      	movs	r0, r5
     e86:	4c75      	ldr	r4, [pc, #468]	; (105c <m2m_wifi_cb+0x268>)
     e88:	47a0      	blx	r4
     e8a:	2800      	cmp	r0, #0
     e8c:	d000      	beq.n	e90 <m2m_wifi_cb+0x9c>
     e8e:	e0e3      	b.n	1058 <m2m_wifi_cb+0x264>
		{
			if (gpfAppWifiCb)
     e90:	4b73      	ldr	r3, [pc, #460]	; (1060 <m2m_wifi_cb+0x26c>)
     e92:	681b      	ldr	r3, [r3, #0]
     e94:	2b00      	cmp	r3, #0
     e96:	d100      	bne.n	e9a <m2m_wifi_cb+0xa6>
     e98:	e0de      	b.n	1058 <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_REQ_DHCP_CONF, (uint8 *)&strIpConfig);
     e9a:	a903      	add	r1, sp, #12
     e9c:	3032      	adds	r0, #50	; 0x32
     e9e:	4798      	blx	r3
     ea0:	e0da      	b.n	1058 <m2m_wifi_cb+0x264>
		}
	}
	else if (u8OpCode == M2M_WIFI_REQ_WPS)
     ea2:	282f      	cmp	r0, #47	; 0x2f
     ea4:	d116      	bne.n	ed4 <m2m_wifi_cb+0xe0>
	{
		tstrM2MWPSInfo strWps;
		m2m_memset((uint8*)&strWps,0,sizeof(tstrM2MWPSInfo));
     ea6:	2264      	movs	r2, #100	; 0x64
     ea8:	2100      	movs	r1, #0
     eaa:	a803      	add	r0, sp, #12
     eac:	4b6d      	ldr	r3, [pc, #436]	; (1064 <m2m_wifi_cb+0x270>)
     eae:	4798      	blx	r3
		if(hif_receive(u32Addr, (uint8*)&strWps, sizeof(tstrM2MWPSInfo), 0) == M2M_SUCCESS)
     eb0:	2300      	movs	r3, #0
     eb2:	2264      	movs	r2, #100	; 0x64
     eb4:	a903      	add	r1, sp, #12
     eb6:	0028      	movs	r0, r5
     eb8:	4c68      	ldr	r4, [pc, #416]	; (105c <m2m_wifi_cb+0x268>)
     eba:	47a0      	blx	r4
     ebc:	2800      	cmp	r0, #0
     ebe:	d000      	beq.n	ec2 <m2m_wifi_cb+0xce>
     ec0:	e0ca      	b.n	1058 <m2m_wifi_cb+0x264>
		{
			if (gpfAppWifiCb)
     ec2:	4b67      	ldr	r3, [pc, #412]	; (1060 <m2m_wifi_cb+0x26c>)
     ec4:	681b      	ldr	r3, [r3, #0]
     ec6:	2b00      	cmp	r3, #0
     ec8:	d100      	bne.n	ecc <m2m_wifi_cb+0xd8>
     eca:	e0c5      	b.n	1058 <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_REQ_WPS, &strWps);
     ecc:	a903      	add	r1, sp, #12
     ece:	302f      	adds	r0, #47	; 0x2f
     ed0:	4798      	blx	r3
     ed2:	e0c1      	b.n	1058 <m2m_wifi_cb+0x264>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_IP_CONFLICT)
     ed4:	2834      	cmp	r0, #52	; 0x34
     ed6:	d122      	bne.n	f1e <m2m_wifi_cb+0x12a>
	{
		uint32  u32ConflictedIP;
		if(hif_receive(u32Addr, (uint8 *)&u32ConflictedIP, sizeof(u32ConflictedIP), 0) == M2M_SUCCESS)
     ed8:	2300      	movs	r3, #0
     eda:	2204      	movs	r2, #4
     edc:	a903      	add	r1, sp, #12
     ede:	0028      	movs	r0, r5
     ee0:	4c5e      	ldr	r4, [pc, #376]	; (105c <m2m_wifi_cb+0x268>)
     ee2:	47a0      	blx	r4
     ee4:	2800      	cmp	r0, #0
     ee6:	d000      	beq.n	eea <m2m_wifi_cb+0xf6>
     ee8:	e0b6      	b.n	1058 <m2m_wifi_cb+0x264>
		{
			M2M_INFO("Conflicted IP \" %u.%u.%u.%u \" \n", 
     eea:	485f      	ldr	r0, [pc, #380]	; (1068 <m2m_wifi_cb+0x274>)
     eec:	4c5f      	ldr	r4, [pc, #380]	; (106c <m2m_wifi_cb+0x278>)
     eee:	47a0      	blx	r4
     ef0:	9803      	ldr	r0, [sp, #12]
     ef2:	0c03      	lsrs	r3, r0, #16
     ef4:	21ff      	movs	r1, #255	; 0xff
     ef6:	400b      	ands	r3, r1
     ef8:	0a02      	lsrs	r2, r0, #8
     efa:	400a      	ands	r2, r1
     efc:	4001      	ands	r1, r0
     efe:	0e00      	lsrs	r0, r0, #24
     f00:	9000      	str	r0, [sp, #0]
     f02:	485b      	ldr	r0, [pc, #364]	; (1070 <m2m_wifi_cb+0x27c>)
     f04:	47a0      	blx	r4
     f06:	200d      	movs	r0, #13
     f08:	4b5a      	ldr	r3, [pc, #360]	; (1074 <m2m_wifi_cb+0x280>)
     f0a:	4798      	blx	r3
				BYTE_0(u32ConflictedIP),BYTE_1(u32ConflictedIP),BYTE_2(u32ConflictedIP),BYTE_3(u32ConflictedIP));
			if (gpfAppWifiCb)
     f0c:	4b54      	ldr	r3, [pc, #336]	; (1060 <m2m_wifi_cb+0x26c>)
     f0e:	681b      	ldr	r3, [r3, #0]
     f10:	2b00      	cmp	r3, #0
     f12:	d100      	bne.n	f16 <m2m_wifi_cb+0x122>
     f14:	e0a0      	b.n	1058 <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_IP_CONFLICT, NULL);
     f16:	2100      	movs	r1, #0
     f18:	2034      	movs	r0, #52	; 0x34
     f1a:	4798      	blx	r3
     f1c:	e09c      	b.n	1058 <m2m_wifi_cb+0x264>

		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_SCAN_DONE)
     f1e:	2811      	cmp	r0, #17
     f20:	d118      	bne.n	f54 <m2m_wifi_cb+0x160>
	{
		tstrM2mScanDone strState;
		gu8scanInProgress = 0;
     f22:	2200      	movs	r2, #0
     f24:	4b54      	ldr	r3, [pc, #336]	; (1078 <m2m_wifi_cb+0x284>)
     f26:	701a      	strb	r2, [r3, #0]
		if(hif_receive(u32Addr, (uint8*)&strState, sizeof(tstrM2mScanDone), 0) == M2M_SUCCESS)
     f28:	2300      	movs	r3, #0
     f2a:	3204      	adds	r2, #4
     f2c:	a903      	add	r1, sp, #12
     f2e:	0028      	movs	r0, r5
     f30:	4c4a      	ldr	r4, [pc, #296]	; (105c <m2m_wifi_cb+0x268>)
     f32:	47a0      	blx	r4
     f34:	2800      	cmp	r0, #0
     f36:	d000      	beq.n	f3a <m2m_wifi_cb+0x146>
     f38:	e08e      	b.n	1058 <m2m_wifi_cb+0x264>
		{
			gu8ChNum = strState.u8NumofCh;
     f3a:	ab03      	add	r3, sp, #12
     f3c:	781a      	ldrb	r2, [r3, #0]
     f3e:	4b4f      	ldr	r3, [pc, #316]	; (107c <m2m_wifi_cb+0x288>)
     f40:	701a      	strb	r2, [r3, #0]
			if (gpfAppWifiCb)
     f42:	4b47      	ldr	r3, [pc, #284]	; (1060 <m2m_wifi_cb+0x26c>)
     f44:	681b      	ldr	r3, [r3, #0]
     f46:	2b00      	cmp	r3, #0
     f48:	d100      	bne.n	f4c <m2m_wifi_cb+0x158>
     f4a:	e085      	b.n	1058 <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_DONE, &strState);
     f4c:	a903      	add	r1, sp, #12
     f4e:	3011      	adds	r0, #17
     f50:	4798      	blx	r3
     f52:	e081      	b.n	1058 <m2m_wifi_cb+0x264>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_SCAN_RESULT)
     f54:	2813      	cmp	r0, #19
     f56:	d10f      	bne.n	f78 <m2m_wifi_cb+0x184>
	{
		tstrM2mWifiscanResult strScanResult;
		if(hif_receive(u32Addr, (uint8*)&strScanResult, sizeof(tstrM2mWifiscanResult), 0) == M2M_SUCCESS)
     f58:	2300      	movs	r3, #0
     f5a:	222c      	movs	r2, #44	; 0x2c
     f5c:	a903      	add	r1, sp, #12
     f5e:	0028      	movs	r0, r5
     f60:	4c3e      	ldr	r4, [pc, #248]	; (105c <m2m_wifi_cb+0x268>)
     f62:	47a0      	blx	r4
     f64:	2800      	cmp	r0, #0
     f66:	d177      	bne.n	1058 <m2m_wifi_cb+0x264>
		{
			if (gpfAppWifiCb)
     f68:	4b3d      	ldr	r3, [pc, #244]	; (1060 <m2m_wifi_cb+0x26c>)
     f6a:	681b      	ldr	r3, [r3, #0]
     f6c:	2b00      	cmp	r3, #0
     f6e:	d073      	beq.n	1058 <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_RESULT, &strScanResult);
     f70:	a903      	add	r1, sp, #12
     f72:	3013      	adds	r0, #19
     f74:	4798      	blx	r3
     f76:	e06f      	b.n	1058 <m2m_wifi_cb+0x264>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_CURRENT_RSSI)
     f78:	2804      	cmp	r0, #4
     f7a:	d10f      	bne.n	f9c <m2m_wifi_cb+0x1a8>
	{
		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
     f7c:	2300      	movs	r3, #0
     f7e:	2204      	movs	r2, #4
     f80:	a91c      	add	r1, sp, #112	; 0x70
     f82:	0028      	movs	r0, r5
     f84:	4c35      	ldr	r4, [pc, #212]	; (105c <m2m_wifi_cb+0x268>)
     f86:	47a0      	blx	r4
     f88:	2800      	cmp	r0, #0
     f8a:	d165      	bne.n	1058 <m2m_wifi_cb+0x264>
		{
			if (gpfAppWifiCb)
     f8c:	4b34      	ldr	r3, [pc, #208]	; (1060 <m2m_wifi_cb+0x26c>)
     f8e:	681b      	ldr	r3, [r3, #0]
     f90:	2b00      	cmp	r3, #0
     f92:	d061      	beq.n	1058 <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_CURRENT_RSSI, rx_buf);
     f94:	a91c      	add	r1, sp, #112	; 0x70
     f96:	3004      	adds	r0, #4
     f98:	4798      	blx	r3
     f9a:	e05d      	b.n	1058 <m2m_wifi_cb+0x264>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_CLIENT_INFO)
     f9c:	2865      	cmp	r0, #101	; 0x65
     f9e:	d10f      	bne.n	fc0 <m2m_wifi_cb+0x1cc>
	{
		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
     fa0:	2300      	movs	r3, #0
     fa2:	2204      	movs	r2, #4
     fa4:	a91c      	add	r1, sp, #112	; 0x70
     fa6:	0028      	movs	r0, r5
     fa8:	4c2c      	ldr	r4, [pc, #176]	; (105c <m2m_wifi_cb+0x268>)
     faa:	47a0      	blx	r4
     fac:	2800      	cmp	r0, #0
     fae:	d153      	bne.n	1058 <m2m_wifi_cb+0x264>
		{
			if (gpfAppWifiCb)
     fb0:	4b2b      	ldr	r3, [pc, #172]	; (1060 <m2m_wifi_cb+0x26c>)
     fb2:	681b      	ldr	r3, [r3, #0]
     fb4:	2b00      	cmp	r3, #0
     fb6:	d04f      	beq.n	1058 <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_CLIENT_INFO, rx_buf);
     fb8:	a91c      	add	r1, sp, #112	; 0x70
     fba:	3065      	adds	r0, #101	; 0x65
     fbc:	4798      	blx	r3
     fbe:	e04b      	b.n	1058 <m2m_wifi_cb+0x264>
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_PROVISION_INFO)
     fc0:	2809      	cmp	r0, #9
     fc2:	d10f      	bne.n	fe4 <m2m_wifi_cb+0x1f0>
	{
		tstrM2MProvisionInfo	strProvInfo;
		if(hif_receive(u32Addr, (uint8*)&strProvInfo, sizeof(tstrM2MProvisionInfo), 1) == M2M_SUCCESS)
     fc4:	2301      	movs	r3, #1
     fc6:	2264      	movs	r2, #100	; 0x64
     fc8:	a903      	add	r1, sp, #12
     fca:	0028      	movs	r0, r5
     fcc:	4c23      	ldr	r4, [pc, #140]	; (105c <m2m_wifi_cb+0x268>)
     fce:	47a0      	blx	r4
     fd0:	2800      	cmp	r0, #0
     fd2:	d141      	bne.n	1058 <m2m_wifi_cb+0x264>
		{
			if(gpfAppWifiCb)
     fd4:	4b22      	ldr	r3, [pc, #136]	; (1060 <m2m_wifi_cb+0x26c>)
     fd6:	681b      	ldr	r3, [r3, #0]
     fd8:	2b00      	cmp	r3, #0
     fda:	d03d      	beq.n	1058 <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_PROVISION_INFO, &strProvInfo);
     fdc:	a903      	add	r1, sp, #12
     fde:	3009      	adds	r0, #9
     fe0:	4798      	blx	r3
     fe2:	e039      	b.n	1058 <m2m_wifi_cb+0x264>
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_DEFAULT_CONNECT)
     fe4:	282a      	cmp	r0, #42	; 0x2a
     fe6:	d10f      	bne.n	1008 <m2m_wifi_cb+0x214>
	{
		tstrM2MDefaultConnResp	strResp;
		if(hif_receive(u32Addr, (uint8*)&strResp, sizeof(tstrM2MDefaultConnResp), 1) == M2M_SUCCESS)
     fe8:	2301      	movs	r3, #1
     fea:	2204      	movs	r2, #4
     fec:	a903      	add	r1, sp, #12
     fee:	0028      	movs	r0, r5
     ff0:	4c1a      	ldr	r4, [pc, #104]	; (105c <m2m_wifi_cb+0x268>)
     ff2:	47a0      	blx	r4
     ff4:	2800      	cmp	r0, #0
     ff6:	d12f      	bne.n	1058 <m2m_wifi_cb+0x264>
		{
			if(gpfAppWifiCb)
     ff8:	4b19      	ldr	r3, [pc, #100]	; (1060 <m2m_wifi_cb+0x26c>)
     ffa:	681b      	ldr	r3, [r3, #0]
     ffc:	2b00      	cmp	r3, #0
     ffe:	d02b      	beq.n	1058 <m2m_wifi_cb+0x264>
				gpfAppWifiCb(M2M_WIFI_RESP_DEFAULT_CONNECT, &strResp);
    1000:	a903      	add	r1, sp, #12
    1002:	302a      	adds	r0, #42	; 0x2a
    1004:	4798      	blx	r3
    1006:	e027      	b.n	1058 <m2m_wifi_cb+0x264>
		}
	}
	
	else if(u8OpCode == M2M_WIFI_RESP_GET_PRNG)
    1008:	2820      	cmp	r0, #32
    100a:	d119      	bne.n	1040 <m2m_wifi_cb+0x24c>
	{
		tstrPrng strPrng;
		if(hif_receive(u32Addr, (uint8*)&strPrng,sizeof(tstrPrng), 0) == M2M_SUCCESS)
    100c:	2300      	movs	r3, #0
    100e:	2208      	movs	r2, #8
    1010:	a903      	add	r1, sp, #12
    1012:	0028      	movs	r0, r5
    1014:	4c11      	ldr	r4, [pc, #68]	; (105c <m2m_wifi_cb+0x268>)
    1016:	47a0      	blx	r4
    1018:	2800      	cmp	r0, #0
    101a:	d11d      	bne.n	1058 <m2m_wifi_cb+0x264>
		{
			if(hif_receive(u32Addr + sizeof(tstrPrng),strPrng.pu8RngBuff,strPrng.u16PrngSize, 1) == M2M_SUCCESS)
    101c:	ab03      	add	r3, sp, #12
    101e:	889a      	ldrh	r2, [r3, #4]
    1020:	0028      	movs	r0, r5
    1022:	3008      	adds	r0, #8
    1024:	2301      	movs	r3, #1
    1026:	9903      	ldr	r1, [sp, #12]
    1028:	4c0c      	ldr	r4, [pc, #48]	; (105c <m2m_wifi_cb+0x268>)
    102a:	47a0      	blx	r4
    102c:	2800      	cmp	r0, #0
    102e:	d113      	bne.n	1058 <m2m_wifi_cb+0x264>
			{
				if(gpfAppWifiCb)
    1030:	4b0b      	ldr	r3, [pc, #44]	; (1060 <m2m_wifi_cb+0x26c>)
    1032:	681b      	ldr	r3, [r3, #0]
    1034:	2b00      	cmp	r3, #0
    1036:	d00f      	beq.n	1058 <m2m_wifi_cb+0x264>
					gpfAppWifiCb(M2M_WIFI_RESP_GET_PRNG,&strPrng);
    1038:	a903      	add	r1, sp, #12
    103a:	3020      	adds	r0, #32
    103c:	4798      	blx	r3
    103e:	e00b      	b.n	1058 <m2m_wifi_cb+0x264>
		}
	}
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
    1040:	2292      	movs	r2, #146	; 0x92
    1042:	0052      	lsls	r2, r2, #1
    1044:	490e      	ldr	r1, [pc, #56]	; (1080 <m2m_wifi_cb+0x28c>)
    1046:	480f      	ldr	r0, [pc, #60]	; (1084 <m2m_wifi_cb+0x290>)
    1048:	4d08      	ldr	r5, [pc, #32]	; (106c <m2m_wifi_cb+0x278>)
    104a:	47a8      	blx	r5
    104c:	0021      	movs	r1, r4
    104e:	480e      	ldr	r0, [pc, #56]	; (1088 <m2m_wifi_cb+0x294>)
    1050:	47a8      	blx	r5
    1052:	200d      	movs	r0, #13
    1054:	4b07      	ldr	r3, [pc, #28]	; (1074 <m2m_wifi_cb+0x280>)
    1056:	4798      	blx	r3
	}
}
    1058:	b01f      	add	sp, #124	; 0x7c
    105a:	bd30      	pop	{r4, r5, pc}
    105c:	00000c4d 	.word	0x00000c4d
    1060:	20000154 	.word	0x20000154
    1064:	00000529 	.word	0x00000529
    1068:	0000b928 	.word	0x0000b928
    106c:	0000a771 	.word	0x0000a771
    1070:	0000bc3c 	.word	0x0000bc3c
    1074:	0000a7a5 	.word	0x0000a7a5
    1078:	20000158 	.word	0x20000158
    107c:	20000159 	.word	0x20000159
    1080:	0000bc30 	.word	0x0000bc30
    1084:	0000b8b4 	.word	0x0000b8b4
    1088:	0000bc5c 	.word	0x0000bc5c

0000108c <m2m_wifi_init>:
	s8Ret = hif_send(M2M_REQ_GROUP_SSL, M2M_SSL_IND_CRL|M2M_REQ_DATA_PKT, NULL, 0, (uint8*)pCRL, sizeof(tstrTlsCrlInfo), 0);
	return s8Ret;
}

sint8 m2m_wifi_init(tstrWifiInitParam * param)
{
    108c:	b5f0      	push	{r4, r5, r6, r7, lr}
    108e:	b08f      	sub	sp, #60	; 0x3c
	tstrM2mRev strtmp;
	sint8 ret = M2M_SUCCESS;
	uint8 u8WifiMode = M2M_WIFI_MODE_NORMAL;
    1090:	2201      	movs	r2, #1
    1092:	230f      	movs	r3, #15
    1094:	446b      	add	r3, sp
    1096:	701a      	strb	r2, [r3, #0]
	
	if(param == NULL) {
    1098:	2800      	cmp	r0, #0
    109a:	d05e      	beq.n	115a <m2m_wifi_init+0xce>
		ret = M2M_ERR_FAIL;
		goto _EXIT0;
	}
	
	gpfAppWifiCb = param->pfAppWifiCb;
    109c:	6802      	ldr	r2, [r0, #0]
    109e:	4b31      	ldr	r3, [pc, #196]	; (1164 <m2m_wifi_init+0xd8>)
    10a0:	601a      	str	r2, [r3, #0]
#endif /* ETH_MODE */

#ifdef CONF_MGMT
	gpfAppMonCb  = param->pfAppMonCb;
#endif
	gu8scanInProgress = 0;
    10a2:	2200      	movs	r2, #0
    10a4:	4b30      	ldr	r3, [pc, #192]	; (1168 <m2m_wifi_init+0xdc>)
    10a6:	701a      	strb	r2, [r3, #0]
	/* Apply device specific initialization. */
	ret = nm_drv_init(&u8WifiMode);
    10a8:	200f      	movs	r0, #15
    10aa:	4468      	add	r0, sp
    10ac:	4b2f      	ldr	r3, [pc, #188]	; (116c <m2m_wifi_init+0xe0>)
    10ae:	4798      	blx	r3
    10b0:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS) 	goto _EXIT0;
    10b2:	d154      	bne.n	115e <m2m_wifi_init+0xd2>
	/* Initialize host interface module */
	ret = hif_init(NULL);
    10b4:	2000      	movs	r0, #0
    10b6:	4b2e      	ldr	r3, [pc, #184]	; (1170 <m2m_wifi_init+0xe4>)
    10b8:	4798      	blx	r3
    10ba:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS) 	goto _EXIT1;
    10bc:	d149      	bne.n	1152 <m2m_wifi_init+0xc6>

	hif_register_cb(M2M_REQ_GROUP_WIFI,m2m_wifi_cb);
    10be:	492d      	ldr	r1, [pc, #180]	; (1174 <m2m_wifi_init+0xe8>)
    10c0:	2001      	movs	r0, #1
    10c2:	4b2d      	ldr	r3, [pc, #180]	; (1178 <m2m_wifi_init+0xec>)
    10c4:	4798      	blx	r3

	ret = nm_get_firmware_full_info(&strtmp);
    10c6:	ae04      	add	r6, sp, #16
    10c8:	0030      	movs	r0, r6
    10ca:	4b2c      	ldr	r3, [pc, #176]	; (117c <m2m_wifi_init+0xf0>)
    10cc:	4798      	blx	r3
    10ce:	0004      	movs	r4, r0

	M2M_INFO("Firmware ver   : %u.%u.%u Svnrev %u\n", strtmp.u8FirmwareMajor, strtmp.u8FirmwareMinor, strtmp.u8FirmwarePatch,strtmp.u16FirmwareSvnNum);
    10d0:	482b      	ldr	r0, [pc, #172]	; (1180 <m2m_wifi_init+0xf4>)
    10d2:	4d2c      	ldr	r5, [pc, #176]	; (1184 <m2m_wifi_init+0xf8>)
    10d4:	47a8      	blx	r5
    10d6:	79b3      	ldrb	r3, [r6, #6]
    10d8:	7972      	ldrb	r2, [r6, #5]
    10da:	7931      	ldrb	r1, [r6, #4]
    10dc:	8c30      	ldrh	r0, [r6, #32]
    10de:	9000      	str	r0, [sp, #0]
    10e0:	4829      	ldr	r0, [pc, #164]	; (1188 <m2m_wifi_init+0xfc>)
    10e2:	47a8      	blx	r5
    10e4:	200d      	movs	r0, #13
    10e6:	4f29      	ldr	r7, [pc, #164]	; (118c <m2m_wifi_init+0x100>)
    10e8:	47b8      	blx	r7
	M2M_INFO("Firmware Build %s Time %s\n",strtmp.BuildDate,strtmp.BuildTime);
    10ea:	4825      	ldr	r0, [pc, #148]	; (1180 <m2m_wifi_init+0xf4>)
    10ec:	47a8      	blx	r5
    10ee:	2226      	movs	r2, #38	; 0x26
    10f0:	446a      	add	r2, sp
    10f2:	211a      	movs	r1, #26
    10f4:	4469      	add	r1, sp
    10f6:	4826      	ldr	r0, [pc, #152]	; (1190 <m2m_wifi_init+0x104>)
    10f8:	47a8      	blx	r5
    10fa:	200d      	movs	r0, #13
    10fc:	47b8      	blx	r7
	M2M_INFO("Firmware Min driver ver : %u.%u.%u\n", strtmp.u8DriverMajor, strtmp.u8DriverMinor, strtmp.u8DriverPatch);
    10fe:	4820      	ldr	r0, [pc, #128]	; (1180 <m2m_wifi_init+0xf4>)
    1100:	47a8      	blx	r5
    1102:	7a73      	ldrb	r3, [r6, #9]
    1104:	7a32      	ldrb	r2, [r6, #8]
    1106:	79f1      	ldrb	r1, [r6, #7]
    1108:	4822      	ldr	r0, [pc, #136]	; (1194 <m2m_wifi_init+0x108>)
    110a:	47a8      	blx	r5
    110c:	200d      	movs	r0, #13
    110e:	47b8      	blx	r7
	M2M_INFO("Driver ver: %u.%u.%u\n", M2M_RELEASE_VERSION_MAJOR_NO, M2M_RELEASE_VERSION_MINOR_NO, M2M_RELEASE_VERSION_PATCH_NO);
    1110:	481b      	ldr	r0, [pc, #108]	; (1180 <m2m_wifi_init+0xf4>)
    1112:	47a8      	blx	r5
    1114:	2302      	movs	r3, #2
    1116:	2205      	movs	r2, #5
    1118:	2113      	movs	r1, #19
    111a:	481f      	ldr	r0, [pc, #124]	; (1198 <m2m_wifi_init+0x10c>)
    111c:	47a8      	blx	r5
    111e:	200d      	movs	r0, #13
    1120:	47b8      	blx	r7
	M2M_INFO("Driver built at %s\t%s\n",__DATE__,__TIME__);
    1122:	4817      	ldr	r0, [pc, #92]	; (1180 <m2m_wifi_init+0xf4>)
    1124:	47a8      	blx	r5
    1126:	4a1d      	ldr	r2, [pc, #116]	; (119c <m2m_wifi_init+0x110>)
    1128:	491d      	ldr	r1, [pc, #116]	; (11a0 <m2m_wifi_init+0x114>)
    112a:	481e      	ldr	r0, [pc, #120]	; (11a4 <m2m_wifi_init+0x118>)
    112c:	47a8      	blx	r5
    112e:	200d      	movs	r0, #13
    1130:	47b8      	blx	r7
	if(M2M_ERR_FW_VER_MISMATCH == ret)
    1132:	0023      	movs	r3, r4
    1134:	330d      	adds	r3, #13
    1136:	d112      	bne.n	115e <m2m_wifi_init+0xd2>
	{
		M2M_ERR("Mismatch Firmawre Version\n");
    1138:	22e8      	movs	r2, #232	; 0xe8
    113a:	32ff      	adds	r2, #255	; 0xff
    113c:	491a      	ldr	r1, [pc, #104]	; (11a8 <m2m_wifi_init+0x11c>)
    113e:	481b      	ldr	r0, [pc, #108]	; (11ac <m2m_wifi_init+0x120>)
    1140:	4b10      	ldr	r3, [pc, #64]	; (1184 <m2m_wifi_init+0xf8>)
    1142:	4798      	blx	r3
    1144:	481a      	ldr	r0, [pc, #104]	; (11b0 <m2m_wifi_init+0x124>)
    1146:	4b1b      	ldr	r3, [pc, #108]	; (11b4 <m2m_wifi_init+0x128>)
    1148:	4798      	blx	r3
    114a:	200d      	movs	r0, #13
    114c:	4b0f      	ldr	r3, [pc, #60]	; (118c <m2m_wifi_init+0x100>)
    114e:	4798      	blx	r3
    1150:	e005      	b.n	115e <m2m_wifi_init+0xd2>
	}

	goto _EXIT0;

_EXIT1:
	nm_drv_deinit(NULL);
    1152:	2000      	movs	r0, #0
    1154:	4b18      	ldr	r3, [pc, #96]	; (11b8 <m2m_wifi_init+0x12c>)
    1156:	4798      	blx	r3
    1158:	e001      	b.n	115e <m2m_wifi_init+0xd2>
	tstrM2mRev strtmp;
	sint8 ret = M2M_SUCCESS;
	uint8 u8WifiMode = M2M_WIFI_MODE_NORMAL;
	
	if(param == NULL) {
		ret = M2M_ERR_FAIL;
    115a:	240c      	movs	r4, #12
    115c:	4264      	negs	r4, r4

_EXIT1:
	nm_drv_deinit(NULL);
_EXIT0:
	return ret;
}
    115e:	0020      	movs	r0, r4
    1160:	b00f      	add	sp, #60	; 0x3c
    1162:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1164:	20000154 	.word	0x20000154
    1168:	20000158 	.word	0x20000158
    116c:	00001b11 	.word	0x00001b11
    1170:	00000dbd 	.word	0x00000dbd
    1174:	00000df5 	.word	0x00000df5
    1178:	00000d39 	.word	0x00000d39
    117c:	00001a2d 	.word	0x00001a2d
    1180:	0000b928 	.word	0x0000b928
    1184:	0000a771 	.word	0x0000a771
    1188:	0000bd28 	.word	0x0000bd28
    118c:	0000a7a5 	.word	0x0000a7a5
    1190:	0000bd50 	.word	0x0000bd50
    1194:	0000bd6c 	.word	0x0000bd6c
    1198:	0000bd90 	.word	0x0000bd90
    119c:	0000bda8 	.word	0x0000bda8
    11a0:	0000bdb4 	.word	0x0000bdb4
    11a4:	0000bdc0 	.word	0x0000bdc0
    11a8:	0000bfd0 	.word	0x0000bfd0
    11ac:	0000b8b4 	.word	0x0000b8b4
    11b0:	0000bdd8 	.word	0x0000bdd8
    11b4:	0000a891 	.word	0x0000a891
    11b8:	00001be5 	.word	0x00001be5

000011bc <m2m_wifi_handle_events>:
	return M2M_SUCCESS;
}


sint8 m2m_wifi_handle_events(void * arg)
{
    11bc:	b510      	push	{r4, lr}
	return hif_handle_isr();
    11be:	4b01      	ldr	r3, [pc, #4]	; (11c4 <m2m_wifi_handle_events+0x8>)
    11c0:	4798      	blx	r3
}
    11c2:	bd10      	pop	{r4, pc}
    11c4:	0000086d 	.word	0x0000086d

000011c8 <m2m_wifi_connect_sc>:
sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch)
{
	return m2m_wifi_connect_sc(pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);
}
sint8 m2m_wifi_connect_sc(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch, uint8 u8NoSaveCred)
{
    11c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    11ca:	464f      	mov	r7, r9
    11cc:	4646      	mov	r6, r8
    11ce:	b4c0      	push	{r6, r7}
    11d0:	b0a3      	sub	sp, #140	; 0x8c
    11d2:	9005      	str	r0, [sp, #20]
    11d4:	000c      	movs	r4, r1
    11d6:	0015      	movs	r5, r2
    11d8:	001f      	movs	r7, r3
    11da:	ab2a      	add	r3, sp, #168	; 0xa8
    11dc:	881b      	ldrh	r3, [r3, #0]
    11de:	4699      	mov	r9, r3
    11e0:	ab2b      	add	r3, sp, #172	; 0xac
    11e2:	781b      	ldrb	r3, [r3, #0]
    11e4:	4698      	mov	r8, r3
	sint8				ret = M2M_SUCCESS;
	tstrM2mWifiConnect	strConnect;
	tstrM2MWifiSecInfo	*pstrAuthInfo;

	if(u8SecType != M2M_WIFI_SEC_OPEN)
    11e6:	2a01      	cmp	r2, #1
    11e8:	d040      	beq.n	126c <m2m_wifi_connect_sc+0xa4>
	{
		if(pvAuthInfo == NULL)
    11ea:	2f00      	cmp	r7, #0
    11ec:	d10d      	bne.n	120a <m2m_wifi_connect_sc+0x42>
		{
			M2M_ERR("Key is not valid\n");
    11ee:	4a80      	ldr	r2, [pc, #512]	; (13f0 <m2m_wifi_connect_sc+0x228>)
    11f0:	4980      	ldr	r1, [pc, #512]	; (13f4 <m2m_wifi_connect_sc+0x22c>)
    11f2:	4881      	ldr	r0, [pc, #516]	; (13f8 <m2m_wifi_connect_sc+0x230>)
    11f4:	4b81      	ldr	r3, [pc, #516]	; (13fc <m2m_wifi_connect_sc+0x234>)
    11f6:	4798      	blx	r3
    11f8:	4881      	ldr	r0, [pc, #516]	; (1400 <m2m_wifi_connect_sc+0x238>)
    11fa:	4b82      	ldr	r3, [pc, #520]	; (1404 <m2m_wifi_connect_sc+0x23c>)
    11fc:	4798      	blx	r3
    11fe:	200d      	movs	r0, #13
    1200:	4b81      	ldr	r3, [pc, #516]	; (1408 <m2m_wifi_connect_sc+0x240>)
    1202:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    1204:	200c      	movs	r0, #12
    1206:	4240      	negs	r0, r0
			goto ERR1;
    1208:	e0ec      	b.n	13e4 <m2m_wifi_connect_sc+0x21c>
		}
		if((u8SecType == M2M_WIFI_SEC_WPA_PSK) && (m2m_strlen(pvAuthInfo) == (M2M_MAX_PSK_LEN-1)))
    120a:	2a02      	cmp	r2, #2
    120c:	d12e      	bne.n	126c <m2m_wifi_connect_sc+0xa4>
    120e:	0038      	movs	r0, r7
    1210:	4b7e      	ldr	r3, [pc, #504]	; (140c <m2m_wifi_connect_sc+0x244>)
    1212:	4798      	blx	r3
    1214:	2840      	cmp	r0, #64	; 0x40
    1216:	d129      	bne.n	126c <m2m_wifi_connect_sc+0xa4>
		{
			uint8 i = 0;
			uint8* pu8Psk = (uint8*)pvAuthInfo;
			while(i < (M2M_MAX_PSK_LEN-1))
			{
				if(pu8Psk[i]<'0' || (pu8Psk[i]>'9' && pu8Psk[i] < 'A')|| (pu8Psk[i]>'F' && pu8Psk[i] < 'a') || pu8Psk[i] > 'f')
    1218:	783b      	ldrb	r3, [r7, #0]
    121a:	001a      	movs	r2, r3
    121c:	3a30      	subs	r2, #48	; 0x30
    121e:	2a36      	cmp	r2, #54	; 0x36
    1220:	d813      	bhi.n	124a <m2m_wifi_connect_sc+0x82>
    1222:	3a0a      	subs	r2, #10
    1224:	2a06      	cmp	r2, #6
    1226:	d910      	bls.n	124a <m2m_wifi_connect_sc+0x82>
    1228:	3b47      	subs	r3, #71	; 0x47
    122a:	2b19      	cmp	r3, #25
    122c:	d90d      	bls.n	124a <m2m_wifi_connect_sc+0x82>
    122e:	1c7a      	adds	r2, r7, #1
    1230:	0038      	movs	r0, r7
    1232:	3040      	adds	r0, #64	; 0x40
    1234:	7813      	ldrb	r3, [r2, #0]
    1236:	0019      	movs	r1, r3
    1238:	3930      	subs	r1, #48	; 0x30
    123a:	2936      	cmp	r1, #54	; 0x36
    123c:	d805      	bhi.n	124a <m2m_wifi_connect_sc+0x82>
    123e:	390a      	subs	r1, #10
    1240:	2906      	cmp	r1, #6
    1242:	d902      	bls.n	124a <m2m_wifi_connect_sc+0x82>
    1244:	3b47      	subs	r3, #71	; 0x47
    1246:	2b19      	cmp	r3, #25
    1248:	d80d      	bhi.n	1266 <m2m_wifi_connect_sc+0x9e>
				{
					M2M_ERR("Invalid Key\n");
    124a:	4a71      	ldr	r2, [pc, #452]	; (1410 <m2m_wifi_connect_sc+0x248>)
    124c:	4969      	ldr	r1, [pc, #420]	; (13f4 <m2m_wifi_connect_sc+0x22c>)
    124e:	486a      	ldr	r0, [pc, #424]	; (13f8 <m2m_wifi_connect_sc+0x230>)
    1250:	4b6a      	ldr	r3, [pc, #424]	; (13fc <m2m_wifi_connect_sc+0x234>)
    1252:	4798      	blx	r3
    1254:	486f      	ldr	r0, [pc, #444]	; (1414 <m2m_wifi_connect_sc+0x24c>)
    1256:	4b6b      	ldr	r3, [pc, #428]	; (1404 <m2m_wifi_connect_sc+0x23c>)
    1258:	4798      	blx	r3
    125a:	200d      	movs	r0, #13
    125c:	4b6a      	ldr	r3, [pc, #424]	; (1408 <m2m_wifi_connect_sc+0x240>)
    125e:	4798      	blx	r3
					ret = M2M_ERR_FAIL;
    1260:	200c      	movs	r0, #12
    1262:	4240      	negs	r0, r0
					goto ERR1;
    1264:	e0be      	b.n	13e4 <m2m_wifi_connect_sc+0x21c>
    1266:	3201      	adds	r2, #1
		}
		if((u8SecType == M2M_WIFI_SEC_WPA_PSK) && (m2m_strlen(pvAuthInfo) == (M2M_MAX_PSK_LEN-1)))
		{
			uint8 i = 0;
			uint8* pu8Psk = (uint8*)pvAuthInfo;
			while(i < (M2M_MAX_PSK_LEN-1))
    1268:	4282      	cmp	r2, r0
    126a:	d1e3      	bne.n	1234 <m2m_wifi_connect_sc+0x6c>
				}
				i++;
			}
		}
	}
	if((u8SsidLen<=0)||(u8SsidLen>=M2M_MAX_SSID_LEN))
    126c:	1e63      	subs	r3, r4, #1
    126e:	2b1f      	cmp	r3, #31
    1270:	d90d      	bls.n	128e <m2m_wifi_connect_sc+0xc6>
	{
		M2M_ERR("SSID LEN INVALID\n");
    1272:	4a69      	ldr	r2, [pc, #420]	; (1418 <m2m_wifi_connect_sc+0x250>)
    1274:	495f      	ldr	r1, [pc, #380]	; (13f4 <m2m_wifi_connect_sc+0x22c>)
    1276:	4860      	ldr	r0, [pc, #384]	; (13f8 <m2m_wifi_connect_sc+0x230>)
    1278:	4b60      	ldr	r3, [pc, #384]	; (13fc <m2m_wifi_connect_sc+0x234>)
    127a:	4798      	blx	r3
    127c:	4867      	ldr	r0, [pc, #412]	; (141c <m2m_wifi_connect_sc+0x254>)
    127e:	4b61      	ldr	r3, [pc, #388]	; (1404 <m2m_wifi_connect_sc+0x23c>)
    1280:	4798      	blx	r3
    1282:	200d      	movs	r0, #13
    1284:	4b60      	ldr	r3, [pc, #384]	; (1408 <m2m_wifi_connect_sc+0x240>)
    1286:	4798      	blx	r3
		ret = M2M_ERR_FAIL;
    1288:	200c      	movs	r0, #12
    128a:	4240      	negs	r0, r0
		goto ERR1;
    128c:	e0aa      	b.n	13e4 <m2m_wifi_connect_sc+0x21c>
	}

	if(u16Ch < M2M_WIFI_CH_1|| u16Ch > M2M_WIFI_CH_14)
    128e:	464b      	mov	r3, r9
    1290:	3b01      	subs	r3, #1
    1292:	b29b      	uxth	r3, r3
    1294:	2b0d      	cmp	r3, #13
    1296:	d911      	bls.n	12bc <m2m_wifi_connect_sc+0xf4>
	{
		if(u16Ch!=M2M_WIFI_CH_ALL)
    1298:	464b      	mov	r3, r9
    129a:	2bff      	cmp	r3, #255	; 0xff
    129c:	d00e      	beq.n	12bc <m2m_wifi_connect_sc+0xf4>
		{
			M2M_ERR("CH INVALID\n");
    129e:	228d      	movs	r2, #141	; 0x8d
    12a0:	0092      	lsls	r2, r2, #2
    12a2:	4954      	ldr	r1, [pc, #336]	; (13f4 <m2m_wifi_connect_sc+0x22c>)
    12a4:	4854      	ldr	r0, [pc, #336]	; (13f8 <m2m_wifi_connect_sc+0x230>)
    12a6:	4b55      	ldr	r3, [pc, #340]	; (13fc <m2m_wifi_connect_sc+0x234>)
    12a8:	4798      	blx	r3
    12aa:	485d      	ldr	r0, [pc, #372]	; (1420 <m2m_wifi_connect_sc+0x258>)
    12ac:	4b55      	ldr	r3, [pc, #340]	; (1404 <m2m_wifi_connect_sc+0x23c>)
    12ae:	4798      	blx	r3
    12b0:	200d      	movs	r0, #13
    12b2:	4b55      	ldr	r3, [pc, #340]	; (1408 <m2m_wifi_connect_sc+0x240>)
    12b4:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    12b6:	200c      	movs	r0, #12
    12b8:	4240      	negs	r0, r0
			goto ERR1;
    12ba:	e093      	b.n	13e4 <m2m_wifi_connect_sc+0x21c>
		}
	}


	m2m_memcpy(strConnect.au8SSID, (uint8*)pcSsid, u8SsidLen);
    12bc:	ae07      	add	r6, sp, #28
    12be:	0022      	movs	r2, r4
    12c0:	9905      	ldr	r1, [sp, #20]
    12c2:	205a      	movs	r0, #90	; 0x5a
    12c4:	ab02      	add	r3, sp, #8
    12c6:	469c      	mov	ip, r3
    12c8:	4460      	add	r0, ip
    12ca:	4b56      	ldr	r3, [pc, #344]	; (1424 <m2m_wifi_connect_sc+0x25c>)
    12cc:	4798      	blx	r3
	strConnect.au8SSID[u8SsidLen]	= 0;
    12ce:	1934      	adds	r4, r6, r4
    12d0:	3446      	adds	r4, #70	; 0x46
    12d2:	2300      	movs	r3, #0
    12d4:	7023      	strb	r3, [r4, #0]
	strConnect.u16Ch				= NM_BSP_B_L_16(u16Ch);
    12d6:	3344      	adds	r3, #68	; 0x44
    12d8:	464a      	mov	r2, r9
    12da:	52f2      	strh	r2, [r6, r3]
	/* Credentials will be Not be saved if u8NoSaveCred is set */ 
	strConnect.u8NoSaveCred 			= u8NoSaveCred ? 1:0;
    12dc:	4643      	mov	r3, r8
    12de:	1e5a      	subs	r2, r3, #1
    12e0:	4193      	sbcs	r3, r2
    12e2:	2267      	movs	r2, #103	; 0x67
    12e4:	54b3      	strb	r3, [r6, r2]
	pstrAuthInfo = &strConnect.strSec;
	pstrAuthInfo->u8SecType		= u8SecType;
    12e6:	2341      	movs	r3, #65	; 0x41
    12e8:	54f5      	strb	r5, [r6, r3]

	if(u8SecType == M2M_WIFI_SEC_WEP)
    12ea:	2d03      	cmp	r5, #3
    12ec:	d13b      	bne.n	1366 <m2m_wifi_connect_sc+0x19e>
	{
		tstrM2mWifiWepParams	* pstrWepParams = (tstrM2mWifiWepParams*)pvAuthInfo;
		tstrM2mWifiWepParams	*pstrWep = &pstrAuthInfo->uniAuth.strWepInfo;
		pstrWep->u8KeyIndx =pstrWepParams->u8KeyIndx-1;
    12ee:	783b      	ldrb	r3, [r7, #0]
    12f0:	3b01      	subs	r3, #1
    12f2:	b2db      	uxtb	r3, r3
    12f4:	aa07      	add	r2, sp, #28
    12f6:	7013      	strb	r3, [r2, #0]

		if(pstrWep->u8KeyIndx >= WEP_KEY_MAX_INDEX)
    12f8:	2b03      	cmp	r3, #3
    12fa:	d90e      	bls.n	131a <m2m_wifi_connect_sc+0x152>
		{
			M2M_ERR("Invalid Wep key index %d\n", pstrWep->u8KeyIndx);
    12fc:	4a4a      	ldr	r2, [pc, #296]	; (1428 <m2m_wifi_connect_sc+0x260>)
    12fe:	493d      	ldr	r1, [pc, #244]	; (13f4 <m2m_wifi_connect_sc+0x22c>)
    1300:	483d      	ldr	r0, [pc, #244]	; (13f8 <m2m_wifi_connect_sc+0x230>)
    1302:	4c3e      	ldr	r4, [pc, #248]	; (13fc <m2m_wifi_connect_sc+0x234>)
    1304:	47a0      	blx	r4
    1306:	ab07      	add	r3, sp, #28
    1308:	7819      	ldrb	r1, [r3, #0]
    130a:	4848      	ldr	r0, [pc, #288]	; (142c <m2m_wifi_connect_sc+0x264>)
    130c:	47a0      	blx	r4
    130e:	200d      	movs	r0, #13
    1310:	4b3d      	ldr	r3, [pc, #244]	; (1408 <m2m_wifi_connect_sc+0x240>)
    1312:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    1314:	200c      	movs	r0, #12
    1316:	4240      	negs	r0, r0
			goto ERR1;
    1318:	e064      	b.n	13e4 <m2m_wifi_connect_sc+0x21c>
		}
		pstrWep->u8KeySz = pstrWepParams->u8KeySz-1;
    131a:	787a      	ldrb	r2, [r7, #1]
    131c:	1e51      	subs	r1, r2, #1
    131e:	ab07      	add	r3, sp, #28
    1320:	7059      	strb	r1, [r3, #1]
		if ((pstrWep->u8KeySz != WEP_40_KEY_STRING_SIZE)&& (pstrWep->u8KeySz != WEP_104_KEY_STRING_SIZE))
    1322:	2310      	movs	r3, #16
    1324:	0011      	movs	r1, r2
    1326:	4399      	bics	r1, r3
    1328:	290b      	cmp	r1, #11
    132a:	d00e      	beq.n	134a <m2m_wifi_connect_sc+0x182>
		{
			M2M_ERR("Invalid Wep key length %d\n", pstrWep->u8KeySz);
    132c:	4a40      	ldr	r2, [pc, #256]	; (1430 <m2m_wifi_connect_sc+0x268>)
    132e:	4931      	ldr	r1, [pc, #196]	; (13f4 <m2m_wifi_connect_sc+0x22c>)
    1330:	4831      	ldr	r0, [pc, #196]	; (13f8 <m2m_wifi_connect_sc+0x230>)
    1332:	4c32      	ldr	r4, [pc, #200]	; (13fc <m2m_wifi_connect_sc+0x234>)
    1334:	47a0      	blx	r4
    1336:	ab07      	add	r3, sp, #28
    1338:	7859      	ldrb	r1, [r3, #1]
    133a:	483e      	ldr	r0, [pc, #248]	; (1434 <m2m_wifi_connect_sc+0x26c>)
    133c:	47a0      	blx	r4
    133e:	200d      	movs	r0, #13
    1340:	4b31      	ldr	r3, [pc, #196]	; (1408 <m2m_wifi_connect_sc+0x240>)
    1342:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    1344:	200c      	movs	r0, #12
    1346:	4240      	negs	r0, r0
			goto ERR1;
    1348:	e04c      	b.n	13e4 <m2m_wifi_connect_sc+0x21c>
		}
		m2m_memcpy((uint8*)pstrWep->au8WepKey,(uint8*)pstrWepParams->au8WepKey, pstrWepParams->u8KeySz);
    134a:	1cb9      	adds	r1, r7, #2
    134c:	2016      	movs	r0, #22
    134e:	ab02      	add	r3, sp, #8
    1350:	469c      	mov	ip, r3
    1352:	4460      	add	r0, ip
    1354:	4b33      	ldr	r3, [pc, #204]	; (1424 <m2m_wifi_connect_sc+0x25c>)
    1356:	4798      	blx	r3
		pstrWep->au8WepKey[pstrWepParams->u8KeySz] = 0;
    1358:	787b      	ldrb	r3, [r7, #1]
    135a:	aa07      	add	r2, sp, #28
    135c:	4694      	mov	ip, r2
    135e:	4463      	add	r3, ip
    1360:	2200      	movs	r2, #0
    1362:	709a      	strb	r2, [r3, #2]
    1364:	e034      	b.n	13d0 <m2m_wifi_connect_sc+0x208>

	}


	else if(u8SecType == M2M_WIFI_SEC_WPA_PSK)
    1366:	2d02      	cmp	r5, #2
    1368:	d11a      	bne.n	13a0 <m2m_wifi_connect_sc+0x1d8>
	{
		uint16	u16KeyLen = m2m_strlen((uint8*)pvAuthInfo);
    136a:	0038      	movs	r0, r7
    136c:	4b27      	ldr	r3, [pc, #156]	; (140c <m2m_wifi_connect_sc+0x244>)
    136e:	4798      	blx	r3
		if((u16KeyLen <= 0)||(u16KeyLen >= M2M_MAX_PSK_LEN))
    1370:	1e43      	subs	r3, r0, #1
    1372:	b29b      	uxth	r3, r3
    1374:	2b3f      	cmp	r3, #63	; 0x3f
    1376:	d90d      	bls.n	1394 <m2m_wifi_connect_sc+0x1cc>
		{
			M2M_ERR("Incorrect PSK key length\n");
    1378:	4a2f      	ldr	r2, [pc, #188]	; (1438 <m2m_wifi_connect_sc+0x270>)
    137a:	491e      	ldr	r1, [pc, #120]	; (13f4 <m2m_wifi_connect_sc+0x22c>)
    137c:	481e      	ldr	r0, [pc, #120]	; (13f8 <m2m_wifi_connect_sc+0x230>)
    137e:	4b1f      	ldr	r3, [pc, #124]	; (13fc <m2m_wifi_connect_sc+0x234>)
    1380:	4798      	blx	r3
    1382:	482e      	ldr	r0, [pc, #184]	; (143c <m2m_wifi_connect_sc+0x274>)
    1384:	4b1f      	ldr	r3, [pc, #124]	; (1404 <m2m_wifi_connect_sc+0x23c>)
    1386:	4798      	blx	r3
    1388:	200d      	movs	r0, #13
    138a:	4b1f      	ldr	r3, [pc, #124]	; (1408 <m2m_wifi_connect_sc+0x240>)
    138c:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    138e:	200c      	movs	r0, #12
    1390:	4240      	negs	r0, r0
			goto ERR1;
    1392:	e027      	b.n	13e4 <m2m_wifi_connect_sc+0x21c>
		}
		m2m_memcpy(pstrAuthInfo->uniAuth.au8PSK, (uint8*)pvAuthInfo, u16KeyLen + 1);
    1394:	1c42      	adds	r2, r0, #1
    1396:	0039      	movs	r1, r7
    1398:	a807      	add	r0, sp, #28
    139a:	4b22      	ldr	r3, [pc, #136]	; (1424 <m2m_wifi_connect_sc+0x25c>)
    139c:	4798      	blx	r3
    139e:	e017      	b.n	13d0 <m2m_wifi_connect_sc+0x208>
	}
	else if(u8SecType == M2M_WIFI_SEC_802_1X)
    13a0:	2d04      	cmp	r5, #4
    13a2:	d105      	bne.n	13b0 <m2m_wifi_connect_sc+0x1e8>
	{
		m2m_memcpy((uint8*)&pstrAuthInfo->uniAuth.strCred1x, (uint8*)pvAuthInfo, sizeof(tstr1xAuthCredentials));
    13a4:	223e      	movs	r2, #62	; 0x3e
    13a6:	0039      	movs	r1, r7
    13a8:	a807      	add	r0, sp, #28
    13aa:	4b1e      	ldr	r3, [pc, #120]	; (1424 <m2m_wifi_connect_sc+0x25c>)
    13ac:	4798      	blx	r3
    13ae:	e00f      	b.n	13d0 <m2m_wifi_connect_sc+0x208>
	}
	else if(u8SecType == M2M_WIFI_SEC_OPEN)
    13b0:	2d01      	cmp	r5, #1
    13b2:	d00d      	beq.n	13d0 <m2m_wifi_connect_sc+0x208>
	{

	}
	else
	{
		M2M_ERR("undefined sec type\n");
    13b4:	4a22      	ldr	r2, [pc, #136]	; (1440 <m2m_wifi_connect_sc+0x278>)
    13b6:	490f      	ldr	r1, [pc, #60]	; (13f4 <m2m_wifi_connect_sc+0x22c>)
    13b8:	480f      	ldr	r0, [pc, #60]	; (13f8 <m2m_wifi_connect_sc+0x230>)
    13ba:	4b10      	ldr	r3, [pc, #64]	; (13fc <m2m_wifi_connect_sc+0x234>)
    13bc:	4798      	blx	r3
    13be:	4821      	ldr	r0, [pc, #132]	; (1444 <m2m_wifi_connect_sc+0x27c>)
    13c0:	4b10      	ldr	r3, [pc, #64]	; (1404 <m2m_wifi_connect_sc+0x23c>)
    13c2:	4798      	blx	r3
    13c4:	200d      	movs	r0, #13
    13c6:	4b10      	ldr	r3, [pc, #64]	; (1408 <m2m_wifi_connect_sc+0x240>)
    13c8:	4798      	blx	r3
		ret = M2M_ERR_FAIL;
    13ca:	200c      	movs	r0, #12
    13cc:	4240      	negs	r0, r0
		goto ERR1;
    13ce:	e009      	b.n	13e4 <m2m_wifi_connect_sc+0x21c>
	}

	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_CONNECT, (uint8*)&strConnect, sizeof(tstrM2mWifiConnect),NULL, 0,0);
    13d0:	2300      	movs	r3, #0
    13d2:	9302      	str	r3, [sp, #8]
    13d4:	9301      	str	r3, [sp, #4]
    13d6:	9300      	str	r3, [sp, #0]
    13d8:	336c      	adds	r3, #108	; 0x6c
    13da:	aa07      	add	r2, sp, #28
    13dc:	2128      	movs	r1, #40	; 0x28
    13de:	2001      	movs	r0, #1
    13e0:	4c19      	ldr	r4, [pc, #100]	; (1448 <m2m_wifi_connect_sc+0x280>)
    13e2:	47a0      	blx	r4

ERR1:
	return ret;
}
    13e4:	b023      	add	sp, #140	; 0x8c
    13e6:	bc0c      	pop	{r2, r3}
    13e8:	4690      	mov	r8, r2
    13ea:	4699      	mov	r9, r3
    13ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
    13ee:	46c0      	nop			; (mov r8, r8)
    13f0:	00000215 	.word	0x00000215
    13f4:	0000bc1c 	.word	0x0000bc1c
    13f8:	0000b8b4 	.word	0x0000b8b4
    13fc:	0000a771 	.word	0x0000a771
    1400:	0000bdf4 	.word	0x0000bdf4
    1404:	0000a891 	.word	0x0000a891
    1408:	0000a7a5 	.word	0x0000a7a5
    140c:	00000539 	.word	0x00000539
    1410:	00000221 	.word	0x00000221
    1414:	0000be08 	.word	0x0000be08
    1418:	0000022b 	.word	0x0000022b
    141c:	0000be14 	.word	0x0000be14
    1420:	0000be28 	.word	0x0000be28
    1424:	00000515 	.word	0x00000515
    1428:	0000024b 	.word	0x0000024b
    142c:	0000be34 	.word	0x0000be34
    1430:	00000252 	.word	0x00000252
    1434:	0000be50 	.word	0x0000be50
    1438:	00000261 	.word	0x00000261
    143c:	0000be6c 	.word	0x0000be6c
    1440:	00000271 	.word	0x00000271
    1444:	0000be88 	.word	0x0000be88
    1448:	00000639 	.word	0x00000639

0000144c <m2m_wifi_connect>:
{
	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DEFAULT_CONNECT, NULL, 0,NULL, 0,0);
}

sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch)
{
    144c:	b530      	push	{r4, r5, lr}
    144e:	b083      	sub	sp, #12
    1450:	ac06      	add	r4, sp, #24
    1452:	8824      	ldrh	r4, [r4, #0]
	return m2m_wifi_connect_sc(pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);
    1454:	2500      	movs	r5, #0
    1456:	9501      	str	r5, [sp, #4]
    1458:	9400      	str	r4, [sp, #0]
    145a:	4c02      	ldr	r4, [pc, #8]	; (1464 <m2m_wifi_connect+0x18>)
    145c:	47a0      	blx	r4
}
    145e:	b003      	add	sp, #12
    1460:	bd30      	pop	{r4, r5, pc}
    1462:	46c0      	nop			; (mov r8, r8)
    1464:	000011c9 	.word	0x000011c9

00001468 <m2m_wifi_request_dhcp_client>:

sint8 m2m_wifi_request_dhcp_client(void)
{
	/*legacy API should be removed */
	return 0;
}
    1468:	2000      	movs	r0, #0
    146a:	4770      	bx	lr

0000146c <chip_apply_conf>:

#define TIMEOUT						(0xfffffffful)
#define WAKUP_TRAILS_TIMEOUT		(4)

sint8 chip_apply_conf(uint32 u32Conf)
{
    146c:	b5f0      	push	{r4, r5, r6, r7, lr}
    146e:	b083      	sub	sp, #12
#endif
#ifdef __DISABLE_FIRMWARE_LOGS__
	val32 |= rHAVE_LOGS_DISABLED_BIT;
#endif

	val32 |= rHAVE_RESERVED1_BIT;
    1470:	2580      	movs	r5, #128	; 0x80
    1472:	006d      	lsls	r5, r5, #1
    1474:	4305      	orrs	r5, r0
	do  {
		nm_write_reg(rNMI_GP_REG_1, val32);
    1476:	24a5      	movs	r4, #165	; 0xa5
    1478:	0164      	lsls	r4, r4, #5
    147a:	4f08      	ldr	r7, [pc, #32]	; (149c <chip_apply_conf+0x30>)
		if(val32 != 0) {		
			uint32 reg = 0;
			ret = nm_read_reg_with_ret(rNMI_GP_REG_1, &reg);
    147c:	4e08      	ldr	r6, [pc, #32]	; (14a0 <chip_apply_conf+0x34>)
	val32 |= rHAVE_LOGS_DISABLED_BIT;
#endif

	val32 |= rHAVE_RESERVED1_BIT;
	do  {
		nm_write_reg(rNMI_GP_REG_1, val32);
    147e:	0029      	movs	r1, r5
    1480:	0020      	movs	r0, r4
    1482:	47b8      	blx	r7
		if(val32 != 0) {		
			uint32 reg = 0;
    1484:	2300      	movs	r3, #0
    1486:	9301      	str	r3, [sp, #4]
			ret = nm_read_reg_with_ret(rNMI_GP_REG_1, &reg);
    1488:	a901      	add	r1, sp, #4
    148a:	0020      	movs	r0, r4
    148c:	47b0      	blx	r6
			if(ret == M2M_SUCCESS) {
    148e:	2800      	cmp	r0, #0
    1490:	d1f5      	bne.n	147e <chip_apply_conf+0x12>
				if(reg == val32)
    1492:	9b01      	ldr	r3, [sp, #4]
    1494:	429d      	cmp	r5, r3
    1496:	d1f2      	bne.n	147e <chip_apply_conf+0x12>
			break;
		}
	} while(1);

	return M2M_SUCCESS;
}
    1498:	b003      	add	sp, #12
    149a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    149c:	00001951 	.word	0x00001951
    14a0:	00001945 	.word	0x00001945

000014a4 <enable_interrupts>:
		nm_write_reg(WAKE_CLK_REG, reg);
	}
}

sint8 enable_interrupts(void)
{
    14a4:	b500      	push	{lr}
    14a6:	b083      	sub	sp, #12
	uint32 reg = 0;
    14a8:	2300      	movs	r3, #0
    14aa:	9301      	str	r3, [sp, #4]
	sint8 ret = M2M_SUCCESS;
	/**
	interrupt pin mux select
	**/
	ret = nm_read_reg_with_ret(NMI_PIN_MUX_0, &reg);
    14ac:	a901      	add	r1, sp, #4
    14ae:	4810      	ldr	r0, [pc, #64]	; (14f0 <enable_interrupts+0x4c>)
    14b0:	4b10      	ldr	r3, [pc, #64]	; (14f4 <enable_interrupts+0x50>)
    14b2:	4798      	blx	r3
	if (M2M_SUCCESS != ret) goto ERR1;
    14b4:	2800      	cmp	r0, #0
    14b6:	d119      	bne.n	14ec <enable_interrupts+0x48>
	
	reg |= ((uint32) 1 << 8);
    14b8:	2180      	movs	r1, #128	; 0x80
    14ba:	0049      	lsls	r1, r1, #1
    14bc:	9b01      	ldr	r3, [sp, #4]
    14be:	4319      	orrs	r1, r3
    14c0:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_PIN_MUX_0, reg);
    14c2:	480b      	ldr	r0, [pc, #44]	; (14f0 <enable_interrupts+0x4c>)
    14c4:	4b0c      	ldr	r3, [pc, #48]	; (14f8 <enable_interrupts+0x54>)
    14c6:	4798      	blx	r3
	if (M2M_SUCCESS != ret) goto ERR1;
    14c8:	2800      	cmp	r0, #0
    14ca:	d10f      	bne.n	14ec <enable_interrupts+0x48>
	
	/**
	interrupt enable
	**/
	ret = nm_read_reg_with_ret(NMI_INTR_ENABLE, &reg);
    14cc:	a901      	add	r1, sp, #4
    14ce:	20d0      	movs	r0, #208	; 0xd0
    14d0:	0140      	lsls	r0, r0, #5
    14d2:	4b08      	ldr	r3, [pc, #32]	; (14f4 <enable_interrupts+0x50>)
    14d4:	4798      	blx	r3
	if (M2M_SUCCESS != ret) goto ERR1;
    14d6:	2800      	cmp	r0, #0
    14d8:	d108      	bne.n	14ec <enable_interrupts+0x48>
	
	reg |= ((uint32) 1 << 16);
    14da:	2180      	movs	r1, #128	; 0x80
    14dc:	0249      	lsls	r1, r1, #9
    14de:	9b01      	ldr	r3, [sp, #4]
    14e0:	4319      	orrs	r1, r3
    14e2:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_INTR_ENABLE, reg);
    14e4:	20d0      	movs	r0, #208	; 0xd0
    14e6:	0140      	lsls	r0, r0, #5
    14e8:	4b03      	ldr	r3, [pc, #12]	; (14f8 <enable_interrupts+0x54>)
    14ea:	4798      	blx	r3
	if (M2M_SUCCESS != ret) goto ERR1;
ERR1:	
	return ret;
}
    14ec:	b003      	add	sp, #12
    14ee:	bd00      	pop	{pc}
    14f0:	00001408 	.word	0x00001408
    14f4:	00001945 	.word	0x00001945
    14f8:	00001951 	.word	0x00001951

000014fc <nmi_get_chipid>:
	nm_bsp_sleep(1);
	return ret;
}

uint32 nmi_get_chipid(void)
{
    14fc:	b510      	push	{r4, lr}
    14fe:	b082      	sub	sp, #8
	static uint32 chipid = 0;

	if (chipid == 0) {
    1500:	4b27      	ldr	r3, [pc, #156]	; (15a0 <nmi_get_chipid+0xa4>)
    1502:	681c      	ldr	r4, [r3, #0]
    1504:	2c00      	cmp	r4, #0
    1506:	d146      	bne.n	1596 <nmi_get_chipid+0x9a>
		uint32 rfrevid;
		
		if((nm_read_reg_with_ret(0x1000, &chipid)) != M2M_SUCCESS) {
    1508:	0019      	movs	r1, r3
    150a:	2080      	movs	r0, #128	; 0x80
    150c:	0140      	lsls	r0, r0, #5
    150e:	4b25      	ldr	r3, [pc, #148]	; (15a4 <nmi_get_chipid+0xa8>)
    1510:	4798      	blx	r3
    1512:	2800      	cmp	r0, #0
    1514:	d003      	beq.n	151e <nmi_get_chipid+0x22>
			chipid = 0;
    1516:	2200      	movs	r2, #0
    1518:	4b21      	ldr	r3, [pc, #132]	; (15a0 <nmi_get_chipid+0xa4>)
    151a:	601a      	str	r2, [r3, #0]
			return 0;
    151c:	e03d      	b.n	159a <nmi_get_chipid+0x9e>
		}
		//if((ret = nm_read_reg_with_ret(0x11fc, &revid)) != M2M_SUCCESS) {
		//	return 0;
		//}
		if((nm_read_reg_with_ret(0x13f4, &rfrevid)) != M2M_SUCCESS) {
    151e:	a901      	add	r1, sp, #4
    1520:	4821      	ldr	r0, [pc, #132]	; (15a8 <nmi_get_chipid+0xac>)
    1522:	4b20      	ldr	r3, [pc, #128]	; (15a4 <nmi_get_chipid+0xa8>)
    1524:	4798      	blx	r3
    1526:	2800      	cmp	r0, #0
    1528:	d003      	beq.n	1532 <nmi_get_chipid+0x36>
			chipid = 0;
    152a:	2200      	movs	r2, #0
    152c:	4b1c      	ldr	r3, [pc, #112]	; (15a0 <nmi_get_chipid+0xa4>)
    152e:	601a      	str	r2, [r3, #0]
			return 0;
    1530:	e033      	b.n	159a <nmi_get_chipid+0x9e>
		}

		if (chipid == 0x1002a0)  {
    1532:	4b1b      	ldr	r3, [pc, #108]	; (15a0 <nmi_get_chipid+0xa4>)
    1534:	681b      	ldr	r3, [r3, #0]
    1536:	4a1d      	ldr	r2, [pc, #116]	; (15ac <nmi_get_chipid+0xb0>)
    1538:	4293      	cmp	r3, r2
    153a:	d106      	bne.n	154a <nmi_get_chipid+0x4e>
			if (rfrevid == 0x1) { /* 1002A0 */
    153c:	9b01      	ldr	r3, [sp, #4]
    153e:	2b01      	cmp	r3, #1
    1540:	d021      	beq.n	1586 <nmi_get_chipid+0x8a>
			} else /* if (rfrevid == 0x2) */ { /* 1002A1 */
				chipid = 0x1002a1;
    1542:	4a1b      	ldr	r2, [pc, #108]	; (15b0 <nmi_get_chipid+0xb4>)
    1544:	4b16      	ldr	r3, [pc, #88]	; (15a0 <nmi_get_chipid+0xa4>)
    1546:	601a      	str	r2, [r3, #0]
    1548:	e01d      	b.n	1586 <nmi_get_chipid+0x8a>
			}
		} else if(chipid == 0x1002b0) {
    154a:	4a1a      	ldr	r2, [pc, #104]	; (15b4 <nmi_get_chipid+0xb8>)
    154c:	4293      	cmp	r3, r2
    154e:	d10c      	bne.n	156a <nmi_get_chipid+0x6e>
			if(rfrevid == 3) { /* 1002B0 */
    1550:	9b01      	ldr	r3, [sp, #4]
    1552:	2b03      	cmp	r3, #3
    1554:	d017      	beq.n	1586 <nmi_get_chipid+0x8a>
			} else if(rfrevid == 4) { /* 1002B1 */
    1556:	2b04      	cmp	r3, #4
    1558:	d103      	bne.n	1562 <nmi_get_chipid+0x66>
				chipid = 0x1002b1;
    155a:	4a17      	ldr	r2, [pc, #92]	; (15b8 <nmi_get_chipid+0xbc>)
    155c:	4b10      	ldr	r3, [pc, #64]	; (15a0 <nmi_get_chipid+0xa4>)
    155e:	601a      	str	r2, [r3, #0]
    1560:	e011      	b.n	1586 <nmi_get_chipid+0x8a>
			} else /* if(rfrevid == 5) */ { /* 1002B2 */
				chipid = 0x1002b2;
    1562:	4a16      	ldr	r2, [pc, #88]	; (15bc <nmi_get_chipid+0xc0>)
    1564:	4b0e      	ldr	r3, [pc, #56]	; (15a0 <nmi_get_chipid+0xa4>)
    1566:	601a      	str	r2, [r3, #0]
    1568:	e00d      	b.n	1586 <nmi_get_chipid+0x8a>
			}
		}else if(chipid == 0x1000F0) { 
    156a:	4a15      	ldr	r2, [pc, #84]	; (15c0 <nmi_get_chipid+0xc4>)
    156c:	4293      	cmp	r3, r2
    156e:	d10a      	bne.n	1586 <nmi_get_chipid+0x8a>
			if((nm_read_reg_with_ret(0x3B0000, &chipid)) != M2M_SUCCESS) {
    1570:	490b      	ldr	r1, [pc, #44]	; (15a0 <nmi_get_chipid+0xa4>)
    1572:	20ec      	movs	r0, #236	; 0xec
    1574:	0380      	lsls	r0, r0, #14
    1576:	4b0b      	ldr	r3, [pc, #44]	; (15a4 <nmi_get_chipid+0xa8>)
    1578:	4798      	blx	r3
    157a:	2800      	cmp	r0, #0
    157c:	d003      	beq.n	1586 <nmi_get_chipid+0x8a>
			chipid = 0;
    157e:	2200      	movs	r2, #0
    1580:	4b07      	ldr	r3, [pc, #28]	; (15a0 <nmi_get_chipid+0xa4>)
    1582:	601a      	str	r2, [r3, #0]
			return 0;
    1584:	e009      	b.n	159a <nmi_get_chipid+0x9e>
			}
		}
#else
		/*M2M is by default have SPI flash*/
		chipid &= ~(0x0f0000);
		chipid |= 0x050000;
    1586:	4a06      	ldr	r2, [pc, #24]	; (15a0 <nmi_get_chipid+0xa4>)
    1588:	4b0e      	ldr	r3, [pc, #56]	; (15c4 <nmi_get_chipid+0xc8>)
    158a:	6811      	ldr	r1, [r2, #0]
    158c:	400b      	ands	r3, r1
    158e:	21a0      	movs	r1, #160	; 0xa0
    1590:	02c9      	lsls	r1, r1, #11
    1592:	430b      	orrs	r3, r1
    1594:	6013      	str	r3, [r2, #0]
#endif /* PROBE_FLASH */
	}
	return chipid;
    1596:	4b02      	ldr	r3, [pc, #8]	; (15a0 <nmi_get_chipid+0xa4>)
    1598:	681c      	ldr	r4, [r3, #0]
}
    159a:	0020      	movs	r0, r4
    159c:	b002      	add	sp, #8
    159e:	bd10      	pop	{r4, pc}
    15a0:	2000015c 	.word	0x2000015c
    15a4:	00001945 	.word	0x00001945
    15a8:	000013f4 	.word	0x000013f4
    15ac:	001002a0 	.word	0x001002a0
    15b0:	001002a1 	.word	0x001002a1
    15b4:	001002b0 	.word	0x001002b0
    15b8:	001002b1 	.word	0x001002b1
    15bc:	001002b2 	.word	0x001002b2
    15c0:	001000f0 	.word	0x001000f0
    15c4:	fff0ffff 	.word	0xfff0ffff

000015c8 <chip_sleep>:

	/* Do PLL update */
	nmi_update_pll();
}
sint8 chip_sleep(void)
{
    15c8:	b530      	push	{r4, r5, lr}
    15ca:	b083      	sub	sp, #12
	uint32 reg;
	sint8 ret = M2M_SUCCESS;
	
	while(1)
	{
		ret = nm_read_reg_with_ret(CORT_HOST_COMM,&reg);
    15cc:	4c15      	ldr	r4, [pc, #84]	; (1624 <chip_sleep+0x5c>)
		if(ret != M2M_SUCCESS) goto ERR1;
		if((reg & NBIT0) == 0) break;
    15ce:	2501      	movs	r5, #1
	uint32 reg;
	sint8 ret = M2M_SUCCESS;
	
	while(1)
	{
		ret = nm_read_reg_with_ret(CORT_HOST_COMM,&reg);
    15d0:	a901      	add	r1, sp, #4
    15d2:	2010      	movs	r0, #16
    15d4:	47a0      	blx	r4
		if(ret != M2M_SUCCESS) goto ERR1;
    15d6:	2800      	cmp	r0, #0
    15d8:	d122      	bne.n	1620 <chip_sleep+0x58>
		if((reg & NBIT0) == 0) break;
    15da:	9b01      	ldr	r3, [sp, #4]
    15dc:	422b      	tst	r3, r5
    15de:	d1f7      	bne.n	15d0 <chip_sleep+0x8>
	}
	
	/* Clear bit 1 */
	ret = nm_read_reg_with_ret(WAKE_CLK_REG, &reg);
    15e0:	a901      	add	r1, sp, #4
    15e2:	3001      	adds	r0, #1
    15e4:	4b0f      	ldr	r3, [pc, #60]	; (1624 <chip_sleep+0x5c>)
    15e6:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
    15e8:	2800      	cmp	r0, #0
    15ea:	d119      	bne.n	1620 <chip_sleep+0x58>
	if(reg & NBIT1)
    15ec:	9901      	ldr	r1, [sp, #4]
    15ee:	078b      	lsls	r3, r1, #30
    15f0:	d507      	bpl.n	1602 <chip_sleep+0x3a>
	{
		reg &=~NBIT1;
    15f2:	2302      	movs	r3, #2
    15f4:	4399      	bics	r1, r3
    15f6:	9101      	str	r1, [sp, #4]
		ret = nm_write_reg(WAKE_CLK_REG, reg);
    15f8:	3001      	adds	r0, #1
    15fa:	4b0b      	ldr	r3, [pc, #44]	; (1628 <chip_sleep+0x60>)
    15fc:	4798      	blx	r3
		if(ret != M2M_SUCCESS)goto ERR1;
    15fe:	2800      	cmp	r0, #0
    1600:	d10e      	bne.n	1620 <chip_sleep+0x58>
	}
	
	ret = nm_read_reg_with_ret(HOST_CORT_COMM, &reg);
    1602:	a901      	add	r1, sp, #4
    1604:	200b      	movs	r0, #11
    1606:	4b07      	ldr	r3, [pc, #28]	; (1624 <chip_sleep+0x5c>)
    1608:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
    160a:	2800      	cmp	r0, #0
    160c:	d108      	bne.n	1620 <chip_sleep+0x58>
	if(reg & NBIT0)
    160e:	9901      	ldr	r1, [sp, #4]
    1610:	07cb      	lsls	r3, r1, #31
    1612:	d505      	bpl.n	1620 <chip_sleep+0x58>
	{
		reg &= ~NBIT0;
    1614:	2301      	movs	r3, #1
    1616:	4399      	bics	r1, r3
    1618:	9101      	str	r1, [sp, #4]
		ret = nm_write_reg(HOST_CORT_COMM, reg);
    161a:	300b      	adds	r0, #11
    161c:	4b02      	ldr	r3, [pc, #8]	; (1628 <chip_sleep+0x60>)
    161e:	4798      	blx	r3
		if(ret != M2M_SUCCESS)goto ERR1;
	}

ERR1:
	return ret;
}
    1620:	b003      	add	sp, #12
    1622:	bd30      	pop	{r4, r5, pc}
    1624:	00001945 	.word	0x00001945
    1628:	00001951 	.word	0x00001951

0000162c <chip_wake>:
sint8 chip_wake(void)
{
    162c:	b5f0      	push	{r4, r5, r6, r7, lr}
    162e:	b083      	sub	sp, #12
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, clk_status_reg = 0,trials = 0;
    1630:	2300      	movs	r3, #0
    1632:	9301      	str	r3, [sp, #4]
    1634:	9300      	str	r3, [sp, #0]

	ret = nm_read_reg_with_ret(HOST_CORT_COMM, &reg);
    1636:	a901      	add	r1, sp, #4
    1638:	200b      	movs	r0, #11
    163a:	4b28      	ldr	r3, [pc, #160]	; (16dc <chip_wake+0xb0>)
    163c:	4798      	blx	r3
    163e:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
    1640:	d148      	bne.n	16d4 <chip_wake+0xa8>
	
	if(!(reg & NBIT0))
    1642:	9901      	ldr	r1, [sp, #4]
    1644:	07cb      	lsls	r3, r1, #31
    1646:	d406      	bmi.n	1656 <chip_wake+0x2a>
	{
		/*USE bit 0 to indicate host wakeup*/
		ret = nm_write_reg(HOST_CORT_COMM, reg|NBIT0);
    1648:	2301      	movs	r3, #1
    164a:	4319      	orrs	r1, r3
    164c:	200b      	movs	r0, #11
    164e:	4b24      	ldr	r3, [pc, #144]	; (16e0 <chip_wake+0xb4>)
    1650:	4798      	blx	r3
    1652:	1e04      	subs	r4, r0, #0
		if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
    1654:	d13e      	bne.n	16d4 <chip_wake+0xa8>
	}
		
	ret = nm_read_reg_with_ret(WAKE_CLK_REG, &reg);
    1656:	a901      	add	r1, sp, #4
    1658:	2001      	movs	r0, #1
    165a:	4b20      	ldr	r3, [pc, #128]	; (16dc <chip_wake+0xb0>)
    165c:	4798      	blx	r3
    165e:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
    1660:	d138      	bne.n	16d4 <chip_wake+0xa8>
	/* Set bit 1 */
	if(!(reg & NBIT1))
    1662:	9901      	ldr	r1, [sp, #4]
    1664:	078b      	lsls	r3, r1, #30
    1666:	d406      	bmi.n	1676 <chip_wake+0x4a>
	{
		ret = nm_write_reg(WAKE_CLK_REG, reg | NBIT1);
    1668:	2302      	movs	r3, #2
    166a:	4319      	orrs	r1, r3
    166c:	2001      	movs	r0, #1
    166e:	4b1c      	ldr	r3, [pc, #112]	; (16e0 <chip_wake+0xb4>)
    1670:	4798      	blx	r3
    1672:	1e04      	subs	r4, r0, #0
		if(ret != M2M_SUCCESS) goto _WAKE_EXIT;	
    1674:	d12e      	bne.n	16d4 <chip_wake+0xa8>

ERR1:
	return ret;
}
sint8 chip_wake(void)
{
    1676:	2505      	movs	r5, #5
		if(ret != M2M_SUCCESS) goto _WAKE_EXIT;	
	}

	do
	{
		ret = nm_read_reg_with_ret(CLOCKS_EN_REG, &clk_status_reg);
    1678:	4f18      	ldr	r7, [pc, #96]	; (16dc <chip_wake+0xb0>)
			goto _WAKE_EXIT;
		}
		if(clk_status_reg & NBIT2) {
			break;
		}
		nm_bsp_sleep(2);
    167a:	4e1a      	ldr	r6, [pc, #104]	; (16e4 <chip_wake+0xb8>)
		if(ret != M2M_SUCCESS) goto _WAKE_EXIT;	
	}

	do
	{
		ret = nm_read_reg_with_ret(CLOCKS_EN_REG, &clk_status_reg);
    167c:	4669      	mov	r1, sp
    167e:	200f      	movs	r0, #15
    1680:	47b8      	blx	r7
    1682:	1e04      	subs	r4, r0, #0
		if(ret != M2M_SUCCESS) {
    1684:	d00d      	beq.n	16a2 <chip_wake+0x76>
			M2M_ERR("Bus error (5).%d %lx\n",ret,clk_status_reg);
    1686:	22aa      	movs	r2, #170	; 0xaa
    1688:	0052      	lsls	r2, r2, #1
    168a:	4917      	ldr	r1, [pc, #92]	; (16e8 <chip_wake+0xbc>)
    168c:	4817      	ldr	r0, [pc, #92]	; (16ec <chip_wake+0xc0>)
    168e:	4d18      	ldr	r5, [pc, #96]	; (16f0 <chip_wake+0xc4>)
    1690:	47a8      	blx	r5
    1692:	9a00      	ldr	r2, [sp, #0]
    1694:	0021      	movs	r1, r4
    1696:	4817      	ldr	r0, [pc, #92]	; (16f4 <chip_wake+0xc8>)
    1698:	47a8      	blx	r5
    169a:	200d      	movs	r0, #13
    169c:	4b16      	ldr	r3, [pc, #88]	; (16f8 <chip_wake+0xcc>)
    169e:	4798      	blx	r3
			goto _WAKE_EXIT;
    16a0:	e018      	b.n	16d4 <chip_wake+0xa8>
		}
		if(clk_status_reg & NBIT2) {
    16a2:	9b00      	ldr	r3, [sp, #0]
    16a4:	075b      	lsls	r3, r3, #29
    16a6:	d413      	bmi.n	16d0 <chip_wake+0xa4>
			break;
		}
		nm_bsp_sleep(2);
    16a8:	2002      	movs	r0, #2
    16aa:	47b0      	blx	r6
    16ac:	3d01      	subs	r5, #1
		trials++;
		if(trials > WAKUP_TRAILS_TIMEOUT)
    16ae:	2d00      	cmp	r5, #0
    16b0:	d1e4      	bne.n	167c <chip_wake+0x50>
		{
			M2M_ERR("Failed to wakup the chip\n");
    16b2:	22af      	movs	r2, #175	; 0xaf
    16b4:	0052      	lsls	r2, r2, #1
    16b6:	490c      	ldr	r1, [pc, #48]	; (16e8 <chip_wake+0xbc>)
    16b8:	480c      	ldr	r0, [pc, #48]	; (16ec <chip_wake+0xc0>)
    16ba:	4b0d      	ldr	r3, [pc, #52]	; (16f0 <chip_wake+0xc4>)
    16bc:	4798      	blx	r3
    16be:	480f      	ldr	r0, [pc, #60]	; (16fc <chip_wake+0xd0>)
    16c0:	4b0f      	ldr	r3, [pc, #60]	; (1700 <chip_wake+0xd4>)
    16c2:	4798      	blx	r3
    16c4:	200d      	movs	r0, #13
    16c6:	4b0c      	ldr	r3, [pc, #48]	; (16f8 <chip_wake+0xcc>)
    16c8:	4798      	blx	r3
			ret = M2M_ERR_TIME_OUT;
    16ca:	2404      	movs	r4, #4
    16cc:	4264      	negs	r4, r4
			goto _WAKE_EXIT;
    16ce:	e001      	b.n	16d4 <chip_wake+0xa8>
		}
	}while(1);
	
	/*workaround sometimes spi fail to read clock regs after reading/writing clockless registers*/
	nm_bus_reset();
    16d0:	4b0c      	ldr	r3, [pc, #48]	; (1704 <chip_wake+0xd8>)
    16d2:	4798      	blx	r3
	
_WAKE_EXIT:
	return ret;
}
    16d4:	0020      	movs	r0, r4
    16d6:	b003      	add	sp, #12
    16d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    16da:	46c0      	nop			; (mov r8, r8)
    16dc:	00001945 	.word	0x00001945
    16e0:	00001951 	.word	0x00001951
    16e4:	00000129 	.word	0x00000129
    16e8:	0000c050 	.word	0x0000c050
    16ec:	0000b8b4 	.word	0x0000b8b4
    16f0:	0000a771 	.word	0x0000a771
    16f4:	0000bfe0 	.word	0x0000bfe0
    16f8:	0000a7a5 	.word	0x0000a7a5
    16fc:	0000bff8 	.word	0x0000bff8
    1700:	0000a891 	.word	0x0000a891
    1704:	0000192d 	.word	0x0000192d

00001708 <wait_for_bootrom>:
	nm_bsp_sleep(50);
	return ret;
}

sint8 wait_for_bootrom(uint8 arg)
{
    1708:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    170a:	0007      	movs	r7, r0
				M2M_RELEASE_VERSION_PATCH_NO);


	reg = 0;
	while(1) {
		reg = nm_read_reg(0x1014);	/* wait for efuse loading done */
    170c:	4d2d      	ldr	r5, [pc, #180]	; (17c4 <wait_for_bootrom+0xbc>)
    170e:	4c2e      	ldr	r4, [pc, #184]	; (17c8 <wait_for_bootrom+0xc0>)
		if (reg & 0x80000000) {
			break;
		}
		nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
    1710:	4e2e      	ldr	r6, [pc, #184]	; (17cc <wait_for_bootrom+0xc4>)
				M2M_RELEASE_VERSION_PATCH_NO);


	reg = 0;
	while(1) {
		reg = nm_read_reg(0x1014);	/* wait for efuse loading done */
    1712:	0028      	movs	r0, r5
    1714:	47a0      	blx	r4
		if (reg & 0x80000000) {
    1716:	2800      	cmp	r0, #0
    1718:	db02      	blt.n	1720 <wait_for_bootrom+0x18>
			break;
		}
		nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
    171a:	2001      	movs	r0, #1
    171c:	47b0      	blx	r6
	}
    171e:	e7f8      	b.n	1712 <wait_for_bootrom+0xa>
	reg = nm_read_reg(M2M_WAIT_FOR_HOST_REG);
    1720:	482b      	ldr	r0, [pc, #172]	; (17d0 <wait_for_bootrom+0xc8>)
    1722:	4b29      	ldr	r3, [pc, #164]	; (17c8 <wait_for_bootrom+0xc0>)
    1724:	4798      	blx	r3
	reg &= 0x1;

	/* check if waiting for the host will be skipped or not */
	if(reg == 0)
    1726:	07c3      	lsls	r3, r0, #31
    1728:	d409      	bmi.n	173e <wait_for_bootrom+0x36>
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
		{
			nm_bsp_sleep(1);
    172a:	4e28      	ldr	r6, [pc, #160]	; (17cc <wait_for_bootrom+0xc4>)
			reg = nm_read_reg(BOOTROM_REG);
    172c:	4c29      	ldr	r4, [pc, #164]	; (17d4 <wait_for_bootrom+0xcc>)
    172e:	4d26      	ldr	r5, [pc, #152]	; (17c8 <wait_for_bootrom+0xc0>)
	if(reg == 0)
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
		{
			nm_bsp_sleep(1);
    1730:	2001      	movs	r0, #1
    1732:	47b0      	blx	r6
			reg = nm_read_reg(BOOTROM_REG);
    1734:	0020      	movs	r0, r4
    1736:	47a8      	blx	r5

	/* check if waiting for the host will be skipped or not */
	if(reg == 0)
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
    1738:	4b27      	ldr	r3, [pc, #156]	; (17d8 <wait_for_bootrom+0xd0>)
    173a:	4298      	cmp	r0, r3
    173c:	d1f8      	bne.n	1730 <wait_for_bootrom+0x28>
				goto ERR2;
			}
		}
	}
	
	if(M2M_WIFI_MODE_ATE_HIGH == arg) {
    173e:	2f02      	cmp	r7, #2
    1740:	d109      	bne.n	1756 <wait_for_bootrom+0x4e>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
    1742:	4926      	ldr	r1, [pc, #152]	; (17dc <wait_for_bootrom+0xd4>)
    1744:	4826      	ldr	r0, [pc, #152]	; (17e0 <wait_for_bootrom+0xd8>)
    1746:	4c27      	ldr	r4, [pc, #156]	; (17e4 <wait_for_bootrom+0xdc>)
    1748:	47a0      	blx	r4
		nm_write_reg(NMI_STATE_REG, NBIT20);
    174a:	2180      	movs	r1, #128	; 0x80
    174c:	0349      	lsls	r1, r1, #13
    174e:	4826      	ldr	r0, [pc, #152]	; (17e8 <wait_for_bootrom+0xe0>)
    1750:	47a0      	blx	r4

sint8 wait_for_bootrom(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32GpReg1 = 0;
    1752:	2400      	movs	r4, #0
    1754:	e017      	b.n	1786 <wait_for_bootrom+0x7e>
	}
	
	if(M2M_WIFI_MODE_ATE_HIGH == arg) {
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
		nm_write_reg(NMI_STATE_REG, NBIT20);
	}else if(M2M_WIFI_MODE_ATE_LOW == arg) {
    1756:	2f03      	cmp	r7, #3
    1758:	d108      	bne.n	176c <wait_for_bootrom+0x64>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
    175a:	4920      	ldr	r1, [pc, #128]	; (17dc <wait_for_bootrom+0xd4>)
    175c:	4820      	ldr	r0, [pc, #128]	; (17e0 <wait_for_bootrom+0xd8>)
    175e:	4c21      	ldr	r4, [pc, #132]	; (17e4 <wait_for_bootrom+0xdc>)
    1760:	47a0      	blx	r4
		nm_write_reg(NMI_STATE_REG, 0);
    1762:	2100      	movs	r1, #0
    1764:	4820      	ldr	r0, [pc, #128]	; (17e8 <wait_for_bootrom+0xe0>)
    1766:	47a0      	blx	r4

sint8 wait_for_bootrom(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32GpReg1 = 0;
    1768:	2400      	movs	r4, #0
    176a:	e00c      	b.n	1786 <wait_for_bootrom+0x7e>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
		nm_write_reg(NMI_STATE_REG, NBIT20);
	}else if(M2M_WIFI_MODE_ATE_LOW == arg) {
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
		nm_write_reg(NMI_STATE_REG, 0);
	}else if(M2M_WIFI_MODE_ETHERNET == arg){
    176c:	2f04      	cmp	r7, #4
    176e:	d105      	bne.n	177c <wait_for_bootrom+0x74>
		u32GpReg1 = rHAVE_ETHERNET_MODE_BIT;
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
    1770:	491e      	ldr	r1, [pc, #120]	; (17ec <wait_for_bootrom+0xe4>)
    1772:	481d      	ldr	r0, [pc, #116]	; (17e8 <wait_for_bootrom+0xe0>)
    1774:	4b1b      	ldr	r3, [pc, #108]	; (17e4 <wait_for_bootrom+0xdc>)
    1776:	4798      	blx	r3
		nm_write_reg(NMI_STATE_REG, NBIT20);
	}else if(M2M_WIFI_MODE_ATE_LOW == arg) {
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
		nm_write_reg(NMI_STATE_REG, 0);
	}else if(M2M_WIFI_MODE_ETHERNET == arg){
		u32GpReg1 = rHAVE_ETHERNET_MODE_BIT;
    1778:	2480      	movs	r4, #128	; 0x80
    177a:	e004      	b.n	1786 <wait_for_bootrom+0x7e>
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
	} else {
		/*bypass this step*/
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
    177c:	491b      	ldr	r1, [pc, #108]	; (17ec <wait_for_bootrom+0xe4>)
    177e:	481a      	ldr	r0, [pc, #104]	; (17e8 <wait_for_bootrom+0xe0>)
    1780:	4b18      	ldr	r3, [pc, #96]	; (17e4 <wait_for_bootrom+0xdc>)
    1782:	4798      	blx	r3

sint8 wait_for_bootrom(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32GpReg1 = 0;
    1784:	2400      	movs	r4, #0
	} else {
		/*bypass this step*/
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
	}

	if(REV(nmi_get_chipid()) >= REV_3A0){
    1786:	4b1a      	ldr	r3, [pc, #104]	; (17f0 <wait_for_bootrom+0xe8>)
    1788:	4798      	blx	r3
    178a:	0500      	lsls	r0, r0, #20
    178c:	0d00      	lsrs	r0, r0, #20
    178e:	4b19      	ldr	r3, [pc, #100]	; (17f4 <wait_for_bootrom+0xec>)
    1790:	4298      	cmp	r0, r3
    1792:	d904      	bls.n	179e <wait_for_bootrom+0x96>
		chip_apply_conf(u32GpReg1 | rHAVE_USE_PMU_BIT);
    1794:	2002      	movs	r0, #2
    1796:	4320      	orrs	r0, r4
    1798:	4b17      	ldr	r3, [pc, #92]	; (17f8 <wait_for_bootrom+0xf0>)
    179a:	4798      	blx	r3
    179c:	e002      	b.n	17a4 <wait_for_bootrom+0x9c>
	} else {
		chip_apply_conf(u32GpReg1);
    179e:	0020      	movs	r0, r4
    17a0:	4b15      	ldr	r3, [pc, #84]	; (17f8 <wait_for_bootrom+0xf0>)
    17a2:	4798      	blx	r3
	}
	M2M_INFO("DriverVerInfo: 0x%08lx\n",u32DriverVerInfo);
    17a4:	4815      	ldr	r0, [pc, #84]	; (17fc <wait_for_bootrom+0xf4>)
    17a6:	4c16      	ldr	r4, [pc, #88]	; (1800 <wait_for_bootrom+0xf8>)
    17a8:	47a0      	blx	r4
    17aa:	4910      	ldr	r1, [pc, #64]	; (17ec <wait_for_bootrom+0xe4>)
    17ac:	4815      	ldr	r0, [pc, #84]	; (1804 <wait_for_bootrom+0xfc>)
    17ae:	47a0      	blx	r4
    17b0:	200d      	movs	r0, #13
    17b2:	4b15      	ldr	r3, [pc, #84]	; (1808 <wait_for_bootrom+0x100>)
    17b4:	4798      	blx	r3

	nm_write_reg(BOOTROM_REG,M2M_START_FIRMWARE);
    17b6:	4915      	ldr	r1, [pc, #84]	; (180c <wait_for_bootrom+0x104>)
    17b8:	4806      	ldr	r0, [pc, #24]	; (17d4 <wait_for_bootrom+0xcc>)
    17ba:	4b0a      	ldr	r3, [pc, #40]	; (17e4 <wait_for_bootrom+0xdc>)
    17bc:	4798      	blx	r3
	rom_test();
#endif /* __ROM_TEST__ */

ERR2:
	return ret;
}
    17be:	2000      	movs	r0, #0
    17c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    17c2:	46c0      	nop			; (mov r8, r8)
    17c4:	00001014 	.word	0x00001014
    17c8:	00001939 	.word	0x00001939
    17cc:	00000129 	.word	0x00000129
    17d0:	000207bc 	.word	0x000207bc
    17d4:	000c000c 	.word	0x000c000c
    17d8:	10add09e 	.word	0x10add09e
    17dc:	3c1cd57d 	.word	0x3c1cd57d
    17e0:	000207ac 	.word	0x000207ac
    17e4:	00001951 	.word	0x00001951
    17e8:	0000108c 	.word	0x0000108c
    17ec:	13521352 	.word	0x13521352
    17f0:	000014fd 	.word	0x000014fd
    17f4:	0000039f 	.word	0x0000039f
    17f8:	0000146d 	.word	0x0000146d
    17fc:	0000b928 	.word	0x0000b928
    1800:	0000a771 	.word	0x0000a771
    1804:	0000c014 	.word	0x0000c014
    1808:	0000a7a5 	.word	0x0000a7a5
    180c:	ef522f61 	.word	0xef522f61

00001810 <wait_for_firmware_start>:

sint8 wait_for_firmware_start(uint8 arg)
{
    1810:	b570      	push	{r4, r5, r6, lr}
    1812:	b082      	sub	sp, #8
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32Timeout = TIMEOUT;
	volatile uint32 regAddress = NMI_STATE_REG;
    1814:	4b15      	ldr	r3, [pc, #84]	; (186c <wait_for_firmware_start+0x5c>)
    1816:	9301      	str	r3, [sp, #4]
	volatile uint32 checkValue = M2M_FINISH_INIT_STATE;
    1818:	4b15      	ldr	r3, [pc, #84]	; (1870 <wait_for_firmware_start+0x60>)
    181a:	9300      	str	r3, [sp, #0]
	
	if((M2M_WIFI_MODE_ATE_HIGH == arg)||(M2M_WIFI_MODE_ATE_LOW == arg)) {
    181c:	3802      	subs	r0, #2
    181e:	2801      	cmp	r0, #1
    1820:	d80c      	bhi.n	183c <wait_for_firmware_start+0x2c>
		regAddress = NMI_REV_REG;
    1822:	4b14      	ldr	r3, [pc, #80]	; (1874 <wait_for_firmware_start+0x64>)
    1824:	9301      	str	r3, [sp, #4]
		checkValue = M2M_ATE_FW_IS_UP_VALUE;
    1826:	4b14      	ldr	r3, [pc, #80]	; (1878 <wait_for_firmware_start+0x68>)
    1828:	9300      	str	r3, [sp, #0]
    182a:	e007      	b.n	183c <wait_for_firmware_start+0x2c>
	}
	
	
	while (checkValue != reg)
	{
		nm_bsp_sleep(2); /* TODO: Why bus error if this delay is not here. */
    182c:	2002      	movs	r0, #2
    182e:	47b0      	blx	r6
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
    1830:	9801      	ldr	r0, [sp, #4]
    1832:	47a8      	blx	r5
    1834:	3c01      	subs	r4, #1
		if(++cnt >= u32Timeout)
    1836:	2c00      	cmp	r4, #0
    1838:	d105      	bne.n	1846 <wait_for_firmware_start+0x36>
    183a:	e012      	b.n	1862 <wait_for_firmware_start+0x52>
ERR2:
	return ret;
}

sint8 wait_for_firmware_start(uint8 arg)
{
    183c:	2401      	movs	r4, #1
    183e:	4264      	negs	r4, r4
    1840:	2000      	movs	r0, #0
	}
	
	
	while (checkValue != reg)
	{
		nm_bsp_sleep(2); /* TODO: Why bus error if this delay is not here. */
    1842:	4e0e      	ldr	r6, [pc, #56]	; (187c <wait_for_firmware_start+0x6c>)
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
    1844:	4d0e      	ldr	r5, [pc, #56]	; (1880 <wait_for_firmware_start+0x70>)
	} else {
		/*bypass this step*/
	}
	
	
	while (checkValue != reg)
    1846:	9b00      	ldr	r3, [sp, #0]
    1848:	4298      	cmp	r0, r3
    184a:	d1ef      	bne.n	182c <wait_for_firmware_start+0x1c>
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
			goto ERR;
		}
	}
	if(M2M_FINISH_INIT_STATE == checkValue)
    184c:	9a00      	ldr	r2, [sp, #0]
	return ret;
}

sint8 wait_for_firmware_start(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
    184e:	2000      	movs	r0, #0
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
			goto ERR;
		}
	}
	if(M2M_FINISH_INIT_STATE == checkValue)
    1850:	4b07      	ldr	r3, [pc, #28]	; (1870 <wait_for_firmware_start+0x60>)
    1852:	429a      	cmp	r2, r3
    1854:	d107      	bne.n	1866 <wait_for_firmware_start+0x56>
	{
		nm_write_reg(NMI_STATE_REG, 0);
    1856:	2100      	movs	r1, #0
    1858:	4804      	ldr	r0, [pc, #16]	; (186c <wait_for_firmware_start+0x5c>)
    185a:	4b0a      	ldr	r3, [pc, #40]	; (1884 <wait_for_firmware_start+0x74>)
    185c:	4798      	blx	r3
	return ret;
}

sint8 wait_for_firmware_start(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
    185e:	2000      	movs	r0, #0
    1860:	e001      	b.n	1866 <wait_for_firmware_start+0x56>
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
		if(++cnt >= u32Timeout)
		{
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
    1862:	2005      	movs	r0, #5
    1864:	4240      	negs	r0, r0
	{
		nm_write_reg(NMI_STATE_REG, 0);
	}
ERR:
	return ret;
}
    1866:	b002      	add	sp, #8
    1868:	bd70      	pop	{r4, r5, r6, pc}
    186a:	46c0      	nop			; (mov r8, r8)
    186c:	0000108c 	.word	0x0000108c
    1870:	02532636 	.word	0x02532636
    1874:	000207ac 	.word	0x000207ac
    1878:	d75dc1c3 	.word	0xd75dc1c3
    187c:	00000129 	.word	0x00000129
    1880:	00001939 	.word	0x00001939
    1884:	00001951 	.word	0x00001951

00001888 <chip_deinit>:

sint8 chip_deinit(void)
{
    1888:	b510      	push	{r4, lr}
    188a:	b082      	sub	sp, #8
	uint32 reg = 0;
    188c:	2300      	movs	r3, #0
    188e:	9301      	str	r3, [sp, #4]
	sint8 ret;

	/**
	stop the firmware, need a re-download
	**/
	ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
    1890:	a901      	add	r1, sp, #4
    1892:	20a0      	movs	r0, #160	; 0xa0
    1894:	0140      	lsls	r0, r0, #5
    1896:	4b14      	ldr	r3, [pc, #80]	; (18e8 <chip_deinit+0x60>)
    1898:	4798      	blx	r3
    189a:	1e04      	subs	r4, r0, #0
	if (ret != M2M_SUCCESS) {
    189c:	d00b      	beq.n	18b6 <chip_deinit+0x2e>
		M2M_ERR("failed to de-initialize\n");
    189e:	4a13      	ldr	r2, [pc, #76]	; (18ec <chip_deinit+0x64>)
    18a0:	4913      	ldr	r1, [pc, #76]	; (18f0 <chip_deinit+0x68>)
    18a2:	4814      	ldr	r0, [pc, #80]	; (18f4 <chip_deinit+0x6c>)
    18a4:	4b14      	ldr	r3, [pc, #80]	; (18f8 <chip_deinit+0x70>)
    18a6:	4798      	blx	r3
    18a8:	4814      	ldr	r0, [pc, #80]	; (18fc <chip_deinit+0x74>)
    18aa:	4b15      	ldr	r3, [pc, #84]	; (1900 <chip_deinit+0x78>)
    18ac:	4798      	blx	r3
    18ae:	200d      	movs	r0, #13
    18b0:	4b14      	ldr	r3, [pc, #80]	; (1904 <chip_deinit+0x7c>)
    18b2:	4798      	blx	r3
		goto ERR1;
    18b4:	e014      	b.n	18e0 <chip_deinit+0x58>
	}
	reg &= ~(1 << 10);
    18b6:	4914      	ldr	r1, [pc, #80]	; (1908 <chip_deinit+0x80>)
    18b8:	9b01      	ldr	r3, [sp, #4]
    18ba:	4019      	ands	r1, r3
    18bc:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_GLB_RESET_0, reg);
    18be:	20a0      	movs	r0, #160	; 0xa0
    18c0:	0140      	lsls	r0, r0, #5
    18c2:	4b12      	ldr	r3, [pc, #72]	; (190c <chip_deinit+0x84>)
    18c4:	4798      	blx	r3
    18c6:	1e04      	subs	r4, r0, #0
	if (ret != M2M_SUCCESS) {
    18c8:	d00a      	beq.n	18e0 <chip_deinit+0x58>
		M2M_ERR("failed to de-initialize\n");
    18ca:	4a11      	ldr	r2, [pc, #68]	; (1910 <chip_deinit+0x88>)
    18cc:	4908      	ldr	r1, [pc, #32]	; (18f0 <chip_deinit+0x68>)
    18ce:	4809      	ldr	r0, [pc, #36]	; (18f4 <chip_deinit+0x6c>)
    18d0:	4b09      	ldr	r3, [pc, #36]	; (18f8 <chip_deinit+0x70>)
    18d2:	4798      	blx	r3
    18d4:	4809      	ldr	r0, [pc, #36]	; (18fc <chip_deinit+0x74>)
    18d6:	4b0a      	ldr	r3, [pc, #40]	; (1900 <chip_deinit+0x78>)
    18d8:	4798      	blx	r3
    18da:	200d      	movs	r0, #13
    18dc:	4b09      	ldr	r3, [pc, #36]	; (1904 <chip_deinit+0x7c>)
    18de:	4798      	blx	r3
		goto ERR1;
	}

ERR1:
	return ret;
}
    18e0:	0020      	movs	r0, r4
    18e2:	b002      	add	sp, #8
    18e4:	bd10      	pop	{r4, pc}
    18e6:	46c0      	nop			; (mov r8, r8)
    18e8:	00001945 	.word	0x00001945
    18ec:	00000205 	.word	0x00000205
    18f0:	0000c044 	.word	0x0000c044
    18f4:	0000b8b4 	.word	0x0000b8b4
    18f8:	0000a771 	.word	0x0000a771
    18fc:	0000c02c 	.word	0x0000c02c
    1900:	0000a891 	.word	0x0000a891
    1904:	0000a7a5 	.word	0x0000a7a5
    1908:	fffffbff 	.word	0xfffffbff
    190c:	00001951 	.word	0x00001951
    1910:	0000020b 	.word	0x0000020b

00001914 <nm_bus_iface_init>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_bus_iface_init(void *pvInitVal)
{
    1914:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
	ret = nm_bus_init(pvInitVal);
    1916:	4b01      	ldr	r3, [pc, #4]	; (191c <nm_bus_iface_init+0x8>)
    1918:	4798      	blx	r3
	return ret;
}
    191a:	bd10      	pop	{r4, pc}
    191c:	0000027d 	.word	0x0000027d

00001920 <nm_bus_iface_deinit>:
*	@author	Samer Sarhan
*	@date	07 April 2014
*	@version	1.0
*/
sint8 nm_bus_iface_deinit(void)
{
    1920:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
	ret = nm_bus_deinit();
    1922:	4b01      	ldr	r3, [pc, #4]	; (1928 <nm_bus_iface_deinit+0x8>)
    1924:	4798      	blx	r3

	return ret;
}
    1926:	bd10      	pop	{r4, pc}
    1928:	000004d9 	.word	0x000004d9

0000192c <nm_bus_reset>:
*	@brief	reset bus interface
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*	@version	1.0
*/
sint8 nm_bus_reset(void)
{
    192c:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
#ifdef CONF_WINC_USE_UART
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_reset();
    192e:	4b01      	ldr	r3, [pc, #4]	; (1934 <nm_bus_reset+0x8>)
    1930:	4798      	blx	r3
#else
#error "Plesae define bus usage"
#endif

	return ret;
}
    1932:	bd10      	pop	{r4, pc}
    1934:	000022d1 	.word	0x000022d1

00001938 <nm_read_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
uint32 nm_read_reg(uint32 u32Addr)
{
    1938:	b510      	push	{r4, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_reg(u32Addr);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_reg(u32Addr);
    193a:	4b01      	ldr	r3, [pc, #4]	; (1940 <nm_read_reg+0x8>)
    193c:	4798      	blx	r3
	return nm_i2c_read_reg(u32Addr);
#else
#error "Plesae define bus usage"
#endif

}
    193e:	bd10      	pop	{r4, pc}
    1940:	00002309 	.word	0x00002309

00001944 <nm_read_reg_with_ret>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
{
    1944:	b510      	push	{r4, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_reg_with_ret(u32Addr,pu32RetVal);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_reg_with_ret(u32Addr,pu32RetVal);
    1946:	4b01      	ldr	r3, [pc, #4]	; (194c <nm_read_reg_with_ret+0x8>)
    1948:	4798      	blx	r3
#elif defined (CONF_WINC_USE_I2C)
	return nm_i2c_read_reg_with_ret(u32Addr,pu32RetVal);
#else
#error "Plesae define bus usage"
#endif
}
    194a:	bd10      	pop	{r4, pc}
    194c:	0000231d 	.word	0x0000231d

00001950 <nm_write_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_write_reg(uint32 u32Addr, uint32 u32Val)
{
    1950:	b510      	push	{r4, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_reg(u32Addr,u32Val);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_reg(u32Addr,u32Val);
    1952:	4b01      	ldr	r3, [pc, #4]	; (1958 <nm_write_reg+0x8>)
    1954:	4798      	blx	r3
#elif defined (CONF_WINC_USE_I2C)
	return nm_i2c_write_reg(u32Addr,u32Val);
#else
#error "Plesae define bus usage"
#endif
}
    1956:	bd10      	pop	{r4, pc}
    1958:	00002335 	.word	0x00002335

0000195c <nm_read_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/ 
sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
    195c:	b5f0      	push	{r4, r5, r6, r7, lr}
    195e:	4657      	mov	r7, sl
    1960:	464e      	mov	r6, r9
    1962:	4645      	mov	r5, r8
    1964:	b4e0      	push	{r5, r6, r7}
    1966:	b082      	sub	sp, #8
    1968:	4680      	mov	r8, r0
    196a:	4689      	mov	r9, r1
    196c:	0015      	movs	r5, r2
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
    196e:	4b13      	ldr	r3, [pc, #76]	; (19bc <nm_read_block+0x60>)
    1970:	881f      	ldrh	r7, [r3, #0]
    1972:	3f08      	subs	r7, #8
    1974:	b2bb      	uxth	r3, r7
    1976:	9301      	str	r3, [sp, #4]
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    1978:	001e      	movs	r6, r3
    197a:	0004      	movs	r4, r0
    197c:	429a      	cmp	r2, r3
    197e:	d806      	bhi.n	198e <nm_read_block+0x32>
*	@version	1.0
*/ 
sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
	uint32 off = 0;
    1980:	2100      	movs	r1, #0
static sint8 p_nm_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_block(u32Addr,puBuf,u16Sz);
    1982:	b2aa      	uxth	r2, r5
    1984:	4449      	add	r1, r9
    1986:	0020      	movs	r0, r4
    1988:	4b0d      	ldr	r3, [pc, #52]	; (19c0 <nm_read_block+0x64>)
    198a:	4798      	blx	r3
	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
		{
			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], (uint16)u32Sz);	
			break;
    198c:	e010      	b.n	19b0 <nm_read_block+0x54>
static sint8 p_nm_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_block(u32Addr,puBuf,u16Sz);
    198e:	4b0c      	ldr	r3, [pc, #48]	; (19c0 <nm_read_block+0x64>)
    1990:	469a      	mov	sl, r3
    1992:	1a37      	subs	r7, r6, r0
    1994:	4643      	mov	r3, r8
    1996:	1ae1      	subs	r1, r4, r3
    1998:	4449      	add	r1, r9
    199a:	9a01      	ldr	r2, [sp, #4]
    199c:	0020      	movs	r0, r4
    199e:	47d0      	blx	sl
			break;
		}
		else
		{
			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], u16MaxTrxSz);
			if(M2M_SUCCESS != s8Ret) break;
    19a0:	2800      	cmp	r0, #0
    19a2:	d105      	bne.n	19b0 <nm_read_block+0x54>
			u32Sz -= u16MaxTrxSz;
    19a4:	1bad      	subs	r5, r5, r6
    19a6:	1939      	adds	r1, r7, r4
			off += u16MaxTrxSz;
			u32Addr += u16MaxTrxSz;
    19a8:	19a4      	adds	r4, r4, r6
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    19aa:	42b5      	cmp	r5, r6
    19ac:	d8f2      	bhi.n	1994 <nm_read_block+0x38>
    19ae:	e7e8      	b.n	1982 <nm_read_block+0x26>
			u32Addr += u16MaxTrxSz;
		}
	}

	return s8Ret;
}
    19b0:	b002      	add	sp, #8
    19b2:	bc1c      	pop	{r2, r3, r4}
    19b4:	4690      	mov	r8, r2
    19b6:	4699      	mov	r9, r3
    19b8:	46a2      	mov	sl, r4
    19ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
    19bc:	20000000 	.word	0x20000000
    19c0:	00002479 	.word	0x00002479

000019c4 <nm_write_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/ 
sint8 nm_write_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
    19c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    19c6:	4657      	mov	r7, sl
    19c8:	464e      	mov	r6, r9
    19ca:	4645      	mov	r5, r8
    19cc:	b4e0      	push	{r5, r6, r7}
    19ce:	b082      	sub	sp, #8
    19d0:	4680      	mov	r8, r0
    19d2:	4689      	mov	r9, r1
    19d4:	0015      	movs	r5, r2
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
    19d6:	4b13      	ldr	r3, [pc, #76]	; (1a24 <nm_write_block+0x60>)
    19d8:	881f      	ldrh	r7, [r3, #0]
    19da:	3f08      	subs	r7, #8
    19dc:	b2bb      	uxth	r3, r7
    19de:	9301      	str	r3, [sp, #4]
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    19e0:	001e      	movs	r6, r3
    19e2:	0004      	movs	r4, r0
    19e4:	429a      	cmp	r2, r3
    19e6:	d806      	bhi.n	19f6 <nm_write_block+0x32>
*	@version	1.0
*/ 
sint8 nm_write_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
	uint32 off = 0;
    19e8:	2100      	movs	r1, #0
static sint8 p_nm_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_block(u32Addr,puBuf,u16Sz);
    19ea:	b2aa      	uxth	r2, r5
    19ec:	4449      	add	r1, r9
    19ee:	0020      	movs	r0, r4
    19f0:	4b0d      	ldr	r3, [pc, #52]	; (1a28 <nm_write_block+0x64>)
    19f2:	4798      	blx	r3
	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
		{
			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], (uint16)u32Sz);	
			break;
    19f4:	e010      	b.n	1a18 <nm_write_block+0x54>
static sint8 p_nm_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_block(u32Addr,puBuf,u16Sz);
    19f6:	4b0c      	ldr	r3, [pc, #48]	; (1a28 <nm_write_block+0x64>)
    19f8:	469a      	mov	sl, r3
    19fa:	1a37      	subs	r7, r6, r0
    19fc:	4643      	mov	r3, r8
    19fe:	1ae1      	subs	r1, r4, r3
    1a00:	4449      	add	r1, r9
    1a02:	9a01      	ldr	r2, [sp, #4]
    1a04:	0020      	movs	r0, r4
    1a06:	47d0      	blx	sl
			break;
		}
		else
		{
			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], u16MaxTrxSz);
			if(M2M_SUCCESS != s8Ret) break;
    1a08:	2800      	cmp	r0, #0
    1a0a:	d105      	bne.n	1a18 <nm_write_block+0x54>
			u32Sz -= u16MaxTrxSz;
    1a0c:	1bad      	subs	r5, r5, r6
    1a0e:	1939      	adds	r1, r7, r4
			off += u16MaxTrxSz;
			u32Addr += u16MaxTrxSz;
    1a10:	19a4      	adds	r4, r4, r6
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    1a12:	42b5      	cmp	r5, r6
    1a14:	d8f2      	bhi.n	19fc <nm_write_block+0x38>
    1a16:	e7e8      	b.n	19ea <nm_write_block+0x26>
			u32Addr += u16MaxTrxSz;
		}
	}

	return s8Ret;
}
    1a18:	b002      	add	sp, #8
    1a1a:	bc1c      	pop	{r2, r3, r4}
    1a1c:	4690      	mov	r8, r2
    1a1e:	4699      	mov	r9, r3
    1a20:	46a2      	mov	sl, r4
    1a22:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1a24:	20000000 	.word	0x20000000
    1a28:	000025d5 	.word	0x000025d5

00001a2c <nm_get_firmware_full_info>:
*	@param [out]	M2mRev
*			    pointer holds address of structure "tstrM2mRev" that contains the firmware version parameters
*	@version	1.0
*/
sint8 nm_get_firmware_full_info(tstrM2mRev* pstrRev)
{
    1a2c:	b570      	push	{r4, r5, r6, lr}
    1a2e:	b084      	sub	sp, #16
    1a30:	0004      	movs	r4, r0
	uint16  curr_drv_ver, min_req_drv_ver,curr_firm_ver;
	uint32	reg = 0;
    1a32:	2300      	movs	r3, #0
    1a34:	9303      	str	r3, [sp, #12]
	sint8	ret = M2M_SUCCESS;
	tstrGpRegs strgp = {0};
    1a36:	2208      	movs	r2, #8
    1a38:	2100      	movs	r1, #0
    1a3a:	a801      	add	r0, sp, #4
    1a3c:	4b2d      	ldr	r3, [pc, #180]	; (1af4 <nm_get_firmware_full_info+0xc8>)
    1a3e:	4798      	blx	r3
	if (pstrRev != NULL)
    1a40:	2c00      	cmp	r4, #0
    1a42:	d045      	beq.n	1ad0 <nm_get_firmware_full_info+0xa4>
	{
		m2m_memset((uint8*)pstrRev,0,sizeof(tstrM2mRev));
    1a44:	2228      	movs	r2, #40	; 0x28
    1a46:	2100      	movs	r1, #0
    1a48:	0020      	movs	r0, r4
    1a4a:	4b2b      	ldr	r3, [pc, #172]	; (1af8 <nm_get_firmware_full_info+0xcc>)
    1a4c:	4798      	blx	r3
		ret = nm_read_reg_with_ret(rNMI_GP_REG_2, &reg);
    1a4e:	a903      	add	r1, sp, #12
    1a50:	482a      	ldr	r0, [pc, #168]	; (1afc <nm_get_firmware_full_info+0xd0>)
    1a52:	4b2b      	ldr	r3, [pc, #172]	; (1b00 <nm_get_firmware_full_info+0xd4>)
    1a54:	4798      	blx	r3
		if(ret == M2M_SUCCESS)
    1a56:	2800      	cmp	r0, #0
    1a58:	d14a      	bne.n	1af0 <nm_get_firmware_full_info+0xc4>
		{
			if(reg != 0)
    1a5a:	9803      	ldr	r0, [sp, #12]
    1a5c:	2800      	cmp	r0, #0
    1a5e:	d039      	beq.n	1ad4 <nm_get_firmware_full_info+0xa8>
			{
				ret = nm_read_block(reg|0x30000,(uint8*)&strgp,sizeof(tstrGpRegs));
    1a60:	23c0      	movs	r3, #192	; 0xc0
    1a62:	029b      	lsls	r3, r3, #10
    1a64:	4318      	orrs	r0, r3
    1a66:	2208      	movs	r2, #8
    1a68:	a901      	add	r1, sp, #4
    1a6a:	4b26      	ldr	r3, [pc, #152]	; (1b04 <nm_get_firmware_full_info+0xd8>)
    1a6c:	4798      	blx	r3
				if(ret == M2M_SUCCESS)
    1a6e:	2800      	cmp	r0, #0
    1a70:	d13e      	bne.n	1af0 <nm_get_firmware_full_info+0xc4>
				{
					reg = strgp.u32Firmware_Ota_rev;
					reg &= 0x0000ffff;
    1a72:	9b02      	ldr	r3, [sp, #8]
    1a74:	0418      	lsls	r0, r3, #16
    1a76:	0c00      	lsrs	r0, r0, #16
    1a78:	9003      	str	r0, [sp, #12]
					if(reg != 0)
    1a7a:	d02e      	beq.n	1ada <nm_get_firmware_full_info+0xae>
					{
						ret = nm_read_block(reg|0x30000,(uint8*)pstrRev,sizeof(tstrM2mRev));
    1a7c:	23c0      	movs	r3, #192	; 0xc0
    1a7e:	029b      	lsls	r3, r3, #10
    1a80:	4318      	orrs	r0, r3
    1a82:	2228      	movs	r2, #40	; 0x28
    1a84:	0021      	movs	r1, r4
    1a86:	4b1f      	ldr	r3, [pc, #124]	; (1b04 <nm_get_firmware_full_info+0xd8>)
    1a88:	4798      	blx	r3
						if(ret == M2M_SUCCESS)
    1a8a:	2800      	cmp	r0, #0
    1a8c:	d130      	bne.n	1af0 <nm_get_firmware_full_info+0xc4>
						{
							curr_firm_ver   = M2M_MAKE_VERSION(pstrRev->u8FirmwareMajor, pstrRev->u8FirmwareMinor,pstrRev->u8FirmwarePatch);
    1a8e:	7923      	ldrb	r3, [r4, #4]
    1a90:	0219      	lsls	r1, r3, #8
    1a92:	79a3      	ldrb	r3, [r4, #6]
    1a94:	250f      	movs	r5, #15
    1a96:	402b      	ands	r3, r5
    1a98:	430b      	orrs	r3, r1
    1a9a:	7966      	ldrb	r6, [r4, #5]
    1a9c:	0136      	lsls	r6, r6, #4
    1a9e:	22ff      	movs	r2, #255	; 0xff
    1aa0:	4016      	ands	r6, r2
    1aa2:	4333      	orrs	r3, r6
							curr_drv_ver    = M2M_MAKE_VERSION(M2M_RELEASE_VERSION_MAJOR_NO, M2M_RELEASE_VERSION_MINOR_NO, M2M_RELEASE_VERSION_PATCH_NO);
							min_req_drv_ver = M2M_MAKE_VERSION(pstrRev->u8DriverMajor, pstrRev->u8DriverMinor,pstrRev->u8DriverPatch);
    1aa4:	79e6      	ldrb	r6, [r4, #7]
    1aa6:	0236      	lsls	r6, r6, #8
    1aa8:	7a61      	ldrb	r1, [r4, #9]
    1aaa:	400d      	ands	r5, r1
    1aac:	4335      	orrs	r5, r6
    1aae:	7a21      	ldrb	r1, [r4, #8]
    1ab0:	0109      	lsls	r1, r1, #4
    1ab2:	4011      	ands	r1, r2
    1ab4:	002a      	movs	r2, r5
    1ab6:	430a      	orrs	r2, r1
							if((curr_firm_ver == 0)||(min_req_drv_ver == 0)||(min_req_drv_ver == 0)){
    1ab8:	2b00      	cmp	r3, #0
    1aba:	d011      	beq.n	1ae0 <nm_get_firmware_full_info+0xb4>
    1abc:	2a00      	cmp	r2, #0
    1abe:	d012      	beq.n	1ae6 <nm_get_firmware_full_info+0xba>
								ret = M2M_ERR_FAIL;
								goto EXIT;
							}
							if(curr_drv_ver <  min_req_drv_ver) {
    1ac0:	4911      	ldr	r1, [pc, #68]	; (1b08 <nm_get_firmware_full_info+0xdc>)
    1ac2:	428a      	cmp	r2, r1
    1ac4:	d812      	bhi.n	1aec <nm_get_firmware_full_info+0xc0>
								/*The current driver version should be larger or equal 
								than the min driver that the current firmware support  */
								ret = M2M_ERR_FW_VER_MISMATCH;
								goto EXIT;
							}
							if(curr_drv_ver >  curr_firm_ver) {
    1ac6:	4a11      	ldr	r2, [pc, #68]	; (1b0c <nm_get_firmware_full_info+0xe0>)
    1ac8:	4293      	cmp	r3, r2
    1aca:	d811      	bhi.n	1af0 <nm_get_firmware_full_info+0xc4>
								/*The current driver should be equal or less than the firmware version*/
								ret = M2M_ERR_FW_VER_MISMATCH;
    1acc:	380d      	subs	r0, #13
    1ace:	e00f      	b.n	1af0 <nm_get_firmware_full_info+0xc4>
*/
sint8 nm_get_firmware_full_info(tstrM2mRev* pstrRev)
{
	uint16  curr_drv_ver, min_req_drv_ver,curr_firm_ver;
	uint32	reg = 0;
	sint8	ret = M2M_SUCCESS;
    1ad0:	2000      	movs	r0, #0
    1ad2:	e00d      	b.n	1af0 <nm_get_firmware_full_info+0xc4>
					}else {
						ret = M2M_ERR_FAIL;
					}
				}
			}else{
				ret = M2M_ERR_FAIL;
    1ad4:	200c      	movs	r0, #12
    1ad6:	4240      	negs	r0, r0
    1ad8:	e00a      	b.n	1af0 <nm_get_firmware_full_info+0xc4>
								ret = M2M_ERR_FW_VER_MISMATCH;
								goto EXIT;
							}
						}
					}else {
						ret = M2M_ERR_FAIL;
    1ada:	200c      	movs	r0, #12
    1adc:	4240      	negs	r0, r0
    1ade:	e007      	b.n	1af0 <nm_get_firmware_full_info+0xc4>
						{
							curr_firm_ver   = M2M_MAKE_VERSION(pstrRev->u8FirmwareMajor, pstrRev->u8FirmwareMinor,pstrRev->u8FirmwarePatch);
							curr_drv_ver    = M2M_MAKE_VERSION(M2M_RELEASE_VERSION_MAJOR_NO, M2M_RELEASE_VERSION_MINOR_NO, M2M_RELEASE_VERSION_PATCH_NO);
							min_req_drv_ver = M2M_MAKE_VERSION(pstrRev->u8DriverMajor, pstrRev->u8DriverMinor,pstrRev->u8DriverPatch);
							if((curr_firm_ver == 0)||(min_req_drv_ver == 0)||(min_req_drv_ver == 0)){
								ret = M2M_ERR_FAIL;
    1ae0:	200c      	movs	r0, #12
    1ae2:	4240      	negs	r0, r0
    1ae4:	e004      	b.n	1af0 <nm_get_firmware_full_info+0xc4>
    1ae6:	200c      	movs	r0, #12
    1ae8:	4240      	negs	r0, r0
    1aea:	e001      	b.n	1af0 <nm_get_firmware_full_info+0xc4>
								goto EXIT;
							}
							if(curr_drv_ver <  min_req_drv_ver) {
								/*The current driver version should be larger or equal 
								than the min driver that the current firmware support  */
								ret = M2M_ERR_FW_VER_MISMATCH;
    1aec:	200d      	movs	r0, #13
    1aee:	4240      	negs	r0, r0
			}
		}
	}
EXIT:
	return ret;
}
    1af0:	b004      	add	sp, #16
    1af2:	bd70      	pop	{r4, r5, r6, pc}
    1af4:	0000a75f 	.word	0x0000a75f
    1af8:	00000529 	.word	0x00000529
    1afc:	000c0008 	.word	0x000c0008
    1b00:	00001945 	.word	0x00001945
    1b04:	0000195d 	.word	0x0000195d
    1b08:	00001352 	.word	0x00001352
    1b0c:	00001351 	.word	0x00001351

00001b10 <nm_drv_init>:
*	@author	M. Abdelmawla
*	@date	15 July 2012
*	@version	1.0
*/
sint8 nm_drv_init(void * arg)
{
    1b10:	b570      	push	{r4, r5, r6, lr}
	sint8 ret = M2M_SUCCESS;
	uint8 u8Mode;
	
	if(NULL != arg) {
    1b12:	2800      	cmp	r0, #0
    1b14:	d005      	beq.n	1b22 <nm_drv_init+0x12>
		u8Mode = *((uint8 *)arg);
    1b16:	7805      	ldrb	r5, [r0, #0]
		if((u8Mode < M2M_WIFI_MODE_NORMAL)||(u8Mode >= M2M_WIFI_MODE_MAX)) {
    1b18:	1e6b      	subs	r3, r5, #1
    1b1a:	2b03      	cmp	r3, #3
    1b1c:	d902      	bls.n	1b24 <nm_drv_init+0x14>
			u8Mode = M2M_WIFI_MODE_NORMAL;
    1b1e:	2501      	movs	r5, #1
    1b20:	e000      	b.n	1b24 <nm_drv_init+0x14>
		}
	} else {
		u8Mode = M2M_WIFI_MODE_NORMAL;
    1b22:	2501      	movs	r5, #1
	}
	
	ret = nm_bus_iface_init(NULL);
    1b24:	2000      	movs	r0, #0
    1b26:	4b1f      	ldr	r3, [pc, #124]	; (1ba4 <nm_drv_init+0x94>)
    1b28:	4798      	blx	r3
    1b2a:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    1b2c:	d00c      	beq.n	1b48 <nm_drv_init+0x38>
		M2M_ERR("[nmi start]: fail init bus\n");
    1b2e:	2228      	movs	r2, #40	; 0x28
    1b30:	32ff      	adds	r2, #255	; 0xff
    1b32:	491d      	ldr	r1, [pc, #116]	; (1ba8 <nm_drv_init+0x98>)
    1b34:	481d      	ldr	r0, [pc, #116]	; (1bac <nm_drv_init+0x9c>)
    1b36:	4b1e      	ldr	r3, [pc, #120]	; (1bb0 <nm_drv_init+0xa0>)
    1b38:	4798      	blx	r3
    1b3a:	481e      	ldr	r0, [pc, #120]	; (1bb4 <nm_drv_init+0xa4>)
    1b3c:	4b1e      	ldr	r3, [pc, #120]	; (1bb8 <nm_drv_init+0xa8>)
    1b3e:	4798      	blx	r3
    1b40:	200d      	movs	r0, #13
    1b42:	4b1e      	ldr	r3, [pc, #120]	; (1bbc <nm_drv_init+0xac>)
    1b44:	4798      	blx	r3
		goto ERR1;
    1b46:	e02b      	b.n	1ba0 <nm_drv_init+0x90>
	ret = chip_reset();
	if (M2M_SUCCESS != ret) {
		goto ERR2;
	}
#endif
	M2M_INFO("Chip ID %lx\n", nmi_get_chipid());
    1b48:	481d      	ldr	r0, [pc, #116]	; (1bc0 <nm_drv_init+0xb0>)
    1b4a:	4c19      	ldr	r4, [pc, #100]	; (1bb0 <nm_drv_init+0xa0>)
    1b4c:	47a0      	blx	r4
    1b4e:	4b1d      	ldr	r3, [pc, #116]	; (1bc4 <nm_drv_init+0xb4>)
    1b50:	4798      	blx	r3
    1b52:	0001      	movs	r1, r0
    1b54:	481c      	ldr	r0, [pc, #112]	; (1bc8 <nm_drv_init+0xb8>)
    1b56:	47a0      	blx	r4
    1b58:	200d      	movs	r0, #13
    1b5a:	4b18      	ldr	r3, [pc, #96]	; (1bbc <nm_drv_init+0xac>)
    1b5c:	4798      	blx	r3
#ifdef CONF_WINC_USE_SPI
	/* Must do this after global reset to set SPI data packet size. */
	nm_spi_init();
    1b5e:	4b1b      	ldr	r3, [pc, #108]	; (1bcc <nm_drv_init+0xbc>)
    1b60:	4798      	blx	r3
#endif
	ret = wait_for_bootrom(u8Mode);
    1b62:	0028      	movs	r0, r5
    1b64:	4b1a      	ldr	r3, [pc, #104]	; (1bd0 <nm_drv_init+0xc0>)
    1b66:	4798      	blx	r3
    1b68:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    1b6a:	d117      	bne.n	1b9c <nm_drv_init+0x8c>
		goto ERR2;
	}
		
	ret = wait_for_firmware_start(u8Mode);
    1b6c:	0028      	movs	r0, r5
    1b6e:	4b19      	ldr	r3, [pc, #100]	; (1bd4 <nm_drv_init+0xc4>)
    1b70:	4798      	blx	r3
    1b72:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    1b74:	d112      	bne.n	1b9c <nm_drv_init+0x8c>
		goto ERR2;
	}
	
	if((M2M_WIFI_MODE_ATE_HIGH == u8Mode)||(M2M_WIFI_MODE_ATE_LOW == u8Mode)) {
    1b76:	1ea8      	subs	r0, r5, #2
    1b78:	2801      	cmp	r0, #1
    1b7a:	d911      	bls.n	1ba0 <nm_drv_init+0x90>
		goto ERR1;
	} else {
		/*continue running*/
	}
	
	ret = enable_interrupts();
    1b7c:	4b16      	ldr	r3, [pc, #88]	; (1bd8 <nm_drv_init+0xc8>)
    1b7e:	4798      	blx	r3
    1b80:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    1b82:	d00d      	beq.n	1ba0 <nm_drv_init+0x90>
		M2M_ERR("failed to enable interrupts..\n");
    1b84:	2256      	movs	r2, #86	; 0x56
    1b86:	32ff      	adds	r2, #255	; 0xff
    1b88:	4907      	ldr	r1, [pc, #28]	; (1ba8 <nm_drv_init+0x98>)
    1b8a:	4808      	ldr	r0, [pc, #32]	; (1bac <nm_drv_init+0x9c>)
    1b8c:	4b08      	ldr	r3, [pc, #32]	; (1bb0 <nm_drv_init+0xa0>)
    1b8e:	4798      	blx	r3
    1b90:	4812      	ldr	r0, [pc, #72]	; (1bdc <nm_drv_init+0xcc>)
    1b92:	4b09      	ldr	r3, [pc, #36]	; (1bb8 <nm_drv_init+0xa8>)
    1b94:	4798      	blx	r3
    1b96:	200d      	movs	r0, #13
    1b98:	4b08      	ldr	r3, [pc, #32]	; (1bbc <nm_drv_init+0xac>)
    1b9a:	4798      	blx	r3
		goto ERR2;
	}
	return ret;
ERR2:
	nm_bus_iface_deinit();
    1b9c:	4b10      	ldr	r3, [pc, #64]	; (1be0 <nm_drv_init+0xd0>)
    1b9e:	4798      	blx	r3
ERR1:
	return ret;
}
    1ba0:	0020      	movs	r0, r4
    1ba2:	bd70      	pop	{r4, r5, r6, pc}
    1ba4:	00001915 	.word	0x00001915
    1ba8:	0000c108 	.word	0x0000c108
    1bac:	0000b8b4 	.word	0x0000b8b4
    1bb0:	0000a771 	.word	0x0000a771
    1bb4:	0000c05c 	.word	0x0000c05c
    1bb8:	0000a891 	.word	0x0000a891
    1bbc:	0000a7a5 	.word	0x0000a7a5
    1bc0:	0000b928 	.word	0x0000b928
    1bc4:	000014fd 	.word	0x000014fd
    1bc8:	0000c078 	.word	0x0000c078
    1bcc:	0000234d 	.word	0x0000234d
    1bd0:	00001709 	.word	0x00001709
    1bd4:	00001811 	.word	0x00001811
    1bd8:	000014a5 	.word	0x000014a5
    1bdc:	0000c088 	.word	0x0000c088
    1be0:	00001921 	.word	0x00001921

00001be4 <nm_drv_deinit>:
*	@author	M. Abdelmawla
*	@date	17 July 2012
*	@version	1.0
*/
sint8 nm_drv_deinit(void * arg)
{
    1be4:	b510      	push	{r4, lr}
	sint8 ret;

	ret = chip_deinit();
    1be6:	4b1c      	ldr	r3, [pc, #112]	; (1c58 <nm_drv_deinit+0x74>)
    1be8:	4798      	blx	r3
    1bea:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    1bec:	d00c      	beq.n	1c08 <nm_drv_deinit+0x24>
		M2M_ERR("[nmi stop]: chip_deinit fail\n");
    1bee:	22b6      	movs	r2, #182	; 0xb6
    1bf0:	0052      	lsls	r2, r2, #1
    1bf2:	491a      	ldr	r1, [pc, #104]	; (1c5c <nm_drv_deinit+0x78>)
    1bf4:	481a      	ldr	r0, [pc, #104]	; (1c60 <nm_drv_deinit+0x7c>)
    1bf6:	4b1b      	ldr	r3, [pc, #108]	; (1c64 <nm_drv_deinit+0x80>)
    1bf8:	4798      	blx	r3
    1bfa:	481b      	ldr	r0, [pc, #108]	; (1c68 <nm_drv_deinit+0x84>)
    1bfc:	4b1b      	ldr	r3, [pc, #108]	; (1c6c <nm_drv_deinit+0x88>)
    1bfe:	4798      	blx	r3
    1c00:	200d      	movs	r0, #13
    1c02:	4b1b      	ldr	r3, [pc, #108]	; (1c70 <nm_drv_deinit+0x8c>)
    1c04:	4798      	blx	r3
		goto ERR1;
    1c06:	e024      	b.n	1c52 <nm_drv_deinit+0x6e>
	}
	
	/* Disable SPI flash to save power when the chip is off */
	ret = spi_flash_enable(0);
    1c08:	2000      	movs	r0, #0
    1c0a:	4b1a      	ldr	r3, [pc, #104]	; (1c74 <nm_drv_deinit+0x90>)
    1c0c:	4798      	blx	r3
    1c0e:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    1c10:	d00c      	beq.n	1c2c <nm_drv_deinit+0x48>
		M2M_ERR("[nmi stop]: SPI flash disable fail\n");
    1c12:	2274      	movs	r2, #116	; 0x74
    1c14:	32ff      	adds	r2, #255	; 0xff
    1c16:	4911      	ldr	r1, [pc, #68]	; (1c5c <nm_drv_deinit+0x78>)
    1c18:	4811      	ldr	r0, [pc, #68]	; (1c60 <nm_drv_deinit+0x7c>)
    1c1a:	4b12      	ldr	r3, [pc, #72]	; (1c64 <nm_drv_deinit+0x80>)
    1c1c:	4798      	blx	r3
    1c1e:	4816      	ldr	r0, [pc, #88]	; (1c78 <nm_drv_deinit+0x94>)
    1c20:	4b12      	ldr	r3, [pc, #72]	; (1c6c <nm_drv_deinit+0x88>)
    1c22:	4798      	blx	r3
    1c24:	200d      	movs	r0, #13
    1c26:	4b12      	ldr	r3, [pc, #72]	; (1c70 <nm_drv_deinit+0x8c>)
    1c28:	4798      	blx	r3
		goto ERR1;
    1c2a:	e012      	b.n	1c52 <nm_drv_deinit+0x6e>
	}

	ret = nm_bus_iface_deinit();
    1c2c:	4b13      	ldr	r3, [pc, #76]	; (1c7c <nm_drv_deinit+0x98>)
    1c2e:	4798      	blx	r3
    1c30:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    1c32:	d00c      	beq.n	1c4e <nm_drv_deinit+0x6a>
		M2M_ERR("[nmi stop]: fail init bus\n");
    1c34:	227a      	movs	r2, #122	; 0x7a
    1c36:	32ff      	adds	r2, #255	; 0xff
    1c38:	4908      	ldr	r1, [pc, #32]	; (1c5c <nm_drv_deinit+0x78>)
    1c3a:	4809      	ldr	r0, [pc, #36]	; (1c60 <nm_drv_deinit+0x7c>)
    1c3c:	4b09      	ldr	r3, [pc, #36]	; (1c64 <nm_drv_deinit+0x80>)
    1c3e:	4798      	blx	r3
    1c40:	480f      	ldr	r0, [pc, #60]	; (1c80 <nm_drv_deinit+0x9c>)
    1c42:	4b0a      	ldr	r3, [pc, #40]	; (1c6c <nm_drv_deinit+0x88>)
    1c44:	4798      	blx	r3
    1c46:	200d      	movs	r0, #13
    1c48:	4b09      	ldr	r3, [pc, #36]	; (1c70 <nm_drv_deinit+0x8c>)
    1c4a:	4798      	blx	r3
		goto ERR1;
    1c4c:	e001      	b.n	1c52 <nm_drv_deinit+0x6e>
	}
#ifdef CONF_WINC_USE_SPI
	/* Must do this after global reset to set SPI data packet size. */
	nm_spi_deinit();
    1c4e:	4b0d      	ldr	r3, [pc, #52]	; (1c84 <nm_drv_deinit+0xa0>)
    1c50:	4798      	blx	r3
#endif

ERR1:
	return ret;
}
    1c52:	0020      	movs	r0, r4
    1c54:	bd10      	pop	{r4, pc}
    1c56:	46c0      	nop			; (mov r8, r8)
    1c58:	00001889 	.word	0x00001889
    1c5c:	0000c114 	.word	0x0000c114
    1c60:	0000b8b4 	.word	0x0000b8b4
    1c64:	0000a771 	.word	0x0000a771
    1c68:	0000c0a8 	.word	0x0000c0a8
    1c6c:	0000a891 	.word	0x0000a891
    1c70:	0000a7a5 	.word	0x0000a7a5
    1c74:	000030b9 	.word	0x000030b9
    1c78:	0000c0c8 	.word	0x0000c0c8
    1c7c:	00001921 	.word	0x00001921
    1c80:	0000c0ec 	.word	0x0000c0ec
    1c84:	000022f9 	.word	0x000022f9

00001c88 <nmi_spi_write>:
	spi.u16Sz = sz;
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
}

static sint8 nmi_spi_write(uint8* b, uint16 sz)
{
    1c88:	b500      	push	{lr}
    1c8a:	b085      	sub	sp, #20
	tstrNmSpiRw spi;
	spi.pu8InBuf = b;
    1c8c:	ab01      	add	r3, sp, #4
    1c8e:	9001      	str	r0, [sp, #4]
	spi.pu8OutBuf = NULL;
    1c90:	2200      	movs	r2, #0
    1c92:	9202      	str	r2, [sp, #8]
	spi.u16Sz = sz;
    1c94:	8119      	strh	r1, [r3, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
    1c96:	0019      	movs	r1, r3
    1c98:	2003      	movs	r0, #3
    1c9a:	4b02      	ldr	r3, [pc, #8]	; (1ca4 <nmi_spi_write+0x1c>)
    1c9c:	4798      	blx	r3
}
    1c9e:	b005      	add	sp, #20
    1ca0:	bd00      	pop	{pc}
    1ca2:	46c0      	nop			; (mov r8, r8)
    1ca4:	00000381 	.word	0x00000381

00001ca8 <spi_cmd>:
#define DATA_PKT_SZ_4K			(4 * 1024)
#define DATA_PKT_SZ_8K			(8 * 1024)
#define DATA_PKT_SZ				DATA_PKT_SZ_8K

static sint8 spi_cmd(uint8 cmd, uint32 adr, uint32 u32data, uint32 sz,uint8 clockless)
{
    1ca8:	b570      	push	{r4, r5, r6, lr}
    1caa:	b084      	sub	sp, #16
    1cac:	ac08      	add	r4, sp, #32
    1cae:	7825      	ldrb	r5, [r4, #0]
	uint8 bc[9];
	uint8 len = 5;
	sint8 result = N_OK;

	bc[0] = cmd;
    1cb0:	ac01      	add	r4, sp, #4
    1cb2:	7020      	strb	r0, [r4, #0]
	switch (cmd) {
    1cb4:	303f      	adds	r0, #63	; 0x3f
    1cb6:	b2c4      	uxtb	r4, r0
    1cb8:	2c0e      	cmp	r4, #14
    1cba:	d900      	bls.n	1cbe <spi_cmd+0x16>
    1cbc:	e092      	b.n	1de4 <spi_cmd+0x13c>
    1cbe:	00a0      	lsls	r0, r4, #2
    1cc0:	4c50      	ldr	r4, [pc, #320]	; (1e04 <spi_cmd+0x15c>)
    1cc2:	5820      	ldr	r0, [r4, r0]
    1cc4:	4687      	mov	pc, r0
	case CMD_SINGLE_READ:				/* single word (4 bytes) read */
		bc[1] = (uint8)(adr >> 16);
    1cc6:	ab01      	add	r3, sp, #4
    1cc8:	0c0a      	lsrs	r2, r1, #16
    1cca:	705a      	strb	r2, [r3, #1]
		bc[2] = (uint8)(adr >> 8);
    1ccc:	0a0a      	lsrs	r2, r1, #8
    1cce:	709a      	strb	r2, [r3, #2]
		bc[3] = (uint8)adr;
    1cd0:	70d9      	strb	r1, [r3, #3]
		len = 5;
    1cd2:	2105      	movs	r1, #5
		break;
    1cd4:	e08e      	b.n	1df4 <spi_cmd+0x14c>
	case CMD_INTERNAL_READ:			/* internal register read */
		bc[1] = (uint8)(adr >> 8);
    1cd6:	0a0b      	lsrs	r3, r1, #8
    1cd8:	b2db      	uxtb	r3, r3
		if(clockless)  bc[1] |= (1 << 7);
    1cda:	2d00      	cmp	r5, #0
    1cdc:	d102      	bne.n	1ce4 <spi_cmd+0x3c>
		bc[2] = (uint8)(adr >> 8);
		bc[3] = (uint8)adr;
		len = 5;
		break;
	case CMD_INTERNAL_READ:			/* internal register read */
		bc[1] = (uint8)(adr >> 8);
    1cde:	aa01      	add	r2, sp, #4
    1ce0:	7053      	strb	r3, [r2, #1]
    1ce2:	e004      	b.n	1cee <spi_cmd+0x46>
		if(clockless)  bc[1] |= (1 << 7);
    1ce4:	2280      	movs	r2, #128	; 0x80
    1ce6:	4252      	negs	r2, r2
    1ce8:	4313      	orrs	r3, r2
    1cea:	aa01      	add	r2, sp, #4
    1cec:	7053      	strb	r3, [r2, #1]
		bc[2] = (uint8)adr;
    1cee:	ab01      	add	r3, sp, #4
    1cf0:	7099      	strb	r1, [r3, #2]
		bc[3] = 0x00;
    1cf2:	2200      	movs	r2, #0
    1cf4:	70da      	strb	r2, [r3, #3]
		len = 5;
    1cf6:	2105      	movs	r1, #5
		break;
    1cf8:	e07c      	b.n	1df4 <spi_cmd+0x14c>
	case CMD_TERMINATE:					/* termination */
		bc[1] = 0x00;
    1cfa:	ab01      	add	r3, sp, #4
    1cfc:	2200      	movs	r2, #0
    1cfe:	705a      	strb	r2, [r3, #1]
		bc[2] = 0x00;
    1d00:	709a      	strb	r2, [r3, #2]
		bc[3] = 0x00;
    1d02:	70da      	strb	r2, [r3, #3]
		len = 5;
    1d04:	2105      	movs	r1, #5
		break;
    1d06:	e075      	b.n	1df4 <spi_cmd+0x14c>
	case CMD_REPEAT:						/* repeat */
		bc[1] = 0x00;
    1d08:	ab01      	add	r3, sp, #4
    1d0a:	2200      	movs	r2, #0
    1d0c:	705a      	strb	r2, [r3, #1]
		bc[2] = 0x00;
    1d0e:	709a      	strb	r2, [r3, #2]
		bc[3] = 0x00;
    1d10:	70da      	strb	r2, [r3, #3]
		len = 5;
    1d12:	2105      	movs	r1, #5
		break;
    1d14:	e06e      	b.n	1df4 <spi_cmd+0x14c>
	case CMD_RESET:							/* reset */
		bc[1] = 0xff;
    1d16:	ab01      	add	r3, sp, #4
    1d18:	22ff      	movs	r2, #255	; 0xff
    1d1a:	705a      	strb	r2, [r3, #1]
		bc[2] = 0xff;
    1d1c:	709a      	strb	r2, [r3, #2]
		bc[3] = 0xff;
    1d1e:	70da      	strb	r2, [r3, #3]
		len = 5;
    1d20:	2105      	movs	r1, #5
		break;
    1d22:	e067      	b.n	1df4 <spi_cmd+0x14c>
	case CMD_DMA_WRITE:					/* dma write */
	case CMD_DMA_READ:					/* dma read */
		bc[1] = (uint8)(adr >> 16);
    1d24:	aa01      	add	r2, sp, #4
    1d26:	0c08      	lsrs	r0, r1, #16
    1d28:	7050      	strb	r0, [r2, #1]
		bc[2] = (uint8)(adr >> 8);
    1d2a:	0a08      	lsrs	r0, r1, #8
    1d2c:	7090      	strb	r0, [r2, #2]
		bc[3] = (uint8)adr;
    1d2e:	70d1      	strb	r1, [r2, #3]
		bc[4] = (uint8)(sz >> 8);
    1d30:	0a19      	lsrs	r1, r3, #8
    1d32:	7111      	strb	r1, [r2, #4]
		bc[5] = (uint8)(sz);
    1d34:	7153      	strb	r3, [r2, #5]
		len = 7;
    1d36:	2107      	movs	r1, #7
		break;
    1d38:	e05c      	b.n	1df4 <spi_cmd+0x14c>
	case CMD_DMA_EXT_WRITE:		/* dma extended write */
	case CMD_DMA_EXT_READ:			/* dma extended read */
		bc[1] = (uint8)(adr >> 16);
    1d3a:	aa01      	add	r2, sp, #4
    1d3c:	0c08      	lsrs	r0, r1, #16
    1d3e:	7050      	strb	r0, [r2, #1]
		bc[2] = (uint8)(adr >> 8);
    1d40:	0a08      	lsrs	r0, r1, #8
    1d42:	7090      	strb	r0, [r2, #2]
		bc[3] = (uint8)adr;
    1d44:	70d1      	strb	r1, [r2, #3]
		bc[4] = (uint8)(sz >> 16);
    1d46:	0c19      	lsrs	r1, r3, #16
    1d48:	7111      	strb	r1, [r2, #4]
		bc[5] = (uint8)(sz >> 8);
    1d4a:	0a19      	lsrs	r1, r3, #8
    1d4c:	7151      	strb	r1, [r2, #5]
		bc[6] = (uint8)(sz);
    1d4e:	7193      	strb	r3, [r2, #6]
		len = 8;
    1d50:	2108      	movs	r1, #8
		break;
    1d52:	e04f      	b.n	1df4 <spi_cmd+0x14c>
	case CMD_INTERNAL_WRITE:		/* internal register write */
		bc[1] = (uint8)(adr >> 8);
    1d54:	0a0b      	lsrs	r3, r1, #8
    1d56:	b2db      	uxtb	r3, r3
		if(clockless)  bc[1] |= (1 << 7);
    1d58:	2d00      	cmp	r5, #0
    1d5a:	d102      	bne.n	1d62 <spi_cmd+0xba>
		bc[5] = (uint8)(sz >> 8);
		bc[6] = (uint8)(sz);
		len = 8;
		break;
	case CMD_INTERNAL_WRITE:		/* internal register write */
		bc[1] = (uint8)(adr >> 8);
    1d5c:	a801      	add	r0, sp, #4
    1d5e:	7043      	strb	r3, [r0, #1]
    1d60:	e004      	b.n	1d6c <spi_cmd+0xc4>
		if(clockless)  bc[1] |= (1 << 7);
    1d62:	2080      	movs	r0, #128	; 0x80
    1d64:	4240      	negs	r0, r0
    1d66:	4303      	orrs	r3, r0
    1d68:	a801      	add	r0, sp, #4
    1d6a:	7043      	strb	r3, [r0, #1]
		bc[2] = (uint8)(adr);
    1d6c:	ab01      	add	r3, sp, #4
    1d6e:	7099      	strb	r1, [r3, #2]
		bc[3] = (uint8)(u32data >> 24);
    1d70:	0e11      	lsrs	r1, r2, #24
    1d72:	70d9      	strb	r1, [r3, #3]
		bc[4] = (uint8)(u32data >> 16);
    1d74:	0c11      	lsrs	r1, r2, #16
    1d76:	7119      	strb	r1, [r3, #4]
		bc[5] = (uint8)(u32data >> 8);
    1d78:	0a11      	lsrs	r1, r2, #8
    1d7a:	7159      	strb	r1, [r3, #5]
		bc[6] = (uint8)(u32data);
    1d7c:	719a      	strb	r2, [r3, #6]
		len = 8;
    1d7e:	2108      	movs	r1, #8
		break;
    1d80:	e038      	b.n	1df4 <spi_cmd+0x14c>
	case CMD_SINGLE_WRITE:			/* single word write */
		bc[1] = (uint8)(adr >> 16);
    1d82:	ab01      	add	r3, sp, #4
    1d84:	0c08      	lsrs	r0, r1, #16
    1d86:	7058      	strb	r0, [r3, #1]
		bc[2] = (uint8)(adr >> 8);
    1d88:	0a08      	lsrs	r0, r1, #8
    1d8a:	7098      	strb	r0, [r3, #2]
		bc[3] = (uint8)(adr);
    1d8c:	70d9      	strb	r1, [r3, #3]
		bc[4] = (uint8)(u32data >> 24);
    1d8e:	0e11      	lsrs	r1, r2, #24
    1d90:	7119      	strb	r1, [r3, #4]
		bc[5] = (uint8)(u32data >> 16);
    1d92:	0c11      	lsrs	r1, r2, #16
    1d94:	7159      	strb	r1, [r3, #5]
		bc[6] = (uint8)(u32data >> 8);
    1d96:	0a11      	lsrs	r1, r2, #8
    1d98:	7199      	strb	r1, [r3, #6]
		bc[7] = (uint8)(u32data);
    1d9a:	71da      	strb	r2, [r3, #7]
		len = 9;
    1d9c:	2109      	movs	r1, #9
		break;
    1d9e:	e029      	b.n	1df4 <spi_cmd+0x14c>
};


static uint8 crc7_byte(uint8 crc, uint8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
    1da0:	005b      	lsls	r3, r3, #1
    1da2:	7810      	ldrb	r0, [r2, #0]
    1da4:	4043      	eors	r3, r0
    1da6:	5ce3      	ldrb	r3, [r4, r3]
    1da8:	3201      	adds	r2, #1
}

static uint8 crc7(uint8 crc, const uint8 *buffer, uint32 len)
{
	while (len--)
    1daa:	4295      	cmp	r5, r2
    1dac:	d1f8      	bne.n	1da0 <spi_cmd+0xf8>
		break;
	}

	if (result) {
		if (!gu8Crc_off)
			bc[len-1] = (crc7(0x7f, (const uint8 *)&bc[0], len-1)) << 1;
    1dae:	005b      	lsls	r3, r3, #1
    1db0:	aa01      	add	r2, sp, #4
    1db2:	5593      	strb	r3, [r2, r6]
    1db4:	e001      	b.n	1dba <spi_cmd+0x112>
		else
			len-=1;
    1db6:	3901      	subs	r1, #1
    1db8:	b2c9      	uxtb	r1, r1

		if (M2M_SUCCESS != nmi_spi_write(bc, len)) {
    1dba:	b289      	uxth	r1, r1
    1dbc:	a801      	add	r0, sp, #4
    1dbe:	4b12      	ldr	r3, [pc, #72]	; (1e08 <spi_cmd+0x160>)
    1dc0:	4798      	blx	r3
    1dc2:	2301      	movs	r3, #1
    1dc4:	2800      	cmp	r0, #0
    1dc6:	d01a      	beq.n	1dfe <spi_cmd+0x156>
			M2M_ERR("[nmi spi]: Failed cmd write, bus error...\n");
    1dc8:	2228      	movs	r2, #40	; 0x28
    1dca:	32ff      	adds	r2, #255	; 0xff
    1dcc:	490f      	ldr	r1, [pc, #60]	; (1e0c <spi_cmd+0x164>)
    1dce:	4810      	ldr	r0, [pc, #64]	; (1e10 <spi_cmd+0x168>)
    1dd0:	4b10      	ldr	r3, [pc, #64]	; (1e14 <spi_cmd+0x16c>)
    1dd2:	4798      	blx	r3
    1dd4:	4810      	ldr	r0, [pc, #64]	; (1e18 <spi_cmd+0x170>)
    1dd6:	4b11      	ldr	r3, [pc, #68]	; (1e1c <spi_cmd+0x174>)
    1dd8:	4798      	blx	r3
    1dda:	200d      	movs	r0, #13
    1ddc:	4b10      	ldr	r3, [pc, #64]	; (1e20 <spi_cmd+0x178>)
    1dde:	4798      	blx	r3
			result = N_FAIL;
    1de0:	2300      	movs	r3, #0
    1de2:	e00c      	b.n	1dfe <spi_cmd+0x156>
	uint8 bc[9];
	uint8 len = 5;
	sint8 result = N_OK;

	bc[0] = cmd;
	switch (cmd) {
    1de4:	2300      	movs	r3, #0
    1de6:	e00a      	b.n	1dfe <spi_cmd+0x156>
		break;
	}

	if (result) {
		if (!gu8Crc_off)
			bc[len-1] = (crc7(0x7f, (const uint8 *)&bc[0], len-1)) << 1;
    1de8:	1e4e      	subs	r6, r1, #1
    1dea:	aa01      	add	r2, sp, #4
    1dec:	1995      	adds	r5, r2, r6
    1dee:	237f      	movs	r3, #127	; 0x7f
};


static uint8 crc7_byte(uint8 crc, uint8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
    1df0:	4c0c      	ldr	r4, [pc, #48]	; (1e24 <spi_cmd+0x17c>)
    1df2:	e7d5      	b.n	1da0 <spi_cmd+0xf8>
		result = N_FAIL;
		break;
	}

	if (result) {
		if (!gu8Crc_off)
    1df4:	4b0c      	ldr	r3, [pc, #48]	; (1e28 <spi_cmd+0x180>)
    1df6:	781b      	ldrb	r3, [r3, #0]
    1df8:	2b00      	cmp	r3, #0
    1dfa:	d1dc      	bne.n	1db6 <spi_cmd+0x10e>
    1dfc:	e7f4      	b.n	1de8 <spi_cmd+0x140>
			result = N_FAIL;
		}
	}

	return result;
}
    1dfe:	0018      	movs	r0, r3
    1e00:	b004      	add	sp, #16
    1e02:	bd70      	pop	{r4, r5, r6, pc}
    1e04:	0000c124 	.word	0x0000c124
    1e08:	00001c89 	.word	0x00001c89
    1e0c:	0000c190 	.word	0x0000c190
    1e10:	0000b8b4 	.word	0x0000b8b4
    1e14:	0000a771 	.word	0x0000a771
    1e18:	0000c1b8 	.word	0x0000c1b8
    1e1c:	0000a891 	.word	0x0000a891
    1e20:	0000a7a5 	.word	0x0000a7a5
    1e24:	0000c728 	.word	0x0000c728
    1e28:	20000160 	.word	0x20000160

00001e2c <nmi_spi_read>:
#define DATA_PKT_SZ				DATA_PKT_SZ_8K

static uint8 	gu8Crc_off	=   0;

static sint8 nmi_spi_read(uint8* b, uint16 sz)
{
    1e2c:	b500      	push	{lr}
    1e2e:	b085      	sub	sp, #20
	tstrNmSpiRw spi;
	spi.pu8InBuf = NULL;
    1e30:	ab01      	add	r3, sp, #4
    1e32:	2200      	movs	r2, #0
    1e34:	9201      	str	r2, [sp, #4]
	spi.pu8OutBuf = b;
    1e36:	9002      	str	r0, [sp, #8]
	spi.u16Sz = sz;
    1e38:	8119      	strh	r1, [r3, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
    1e3a:	0019      	movs	r1, r3
    1e3c:	2003      	movs	r0, #3
    1e3e:	4b02      	ldr	r3, [pc, #8]	; (1e48 <nmi_spi_read+0x1c>)
    1e40:	4798      	blx	r3
}
    1e42:	b005      	add	sp, #20
    1e44:	bd00      	pop	{pc}
    1e46:	46c0      	nop			; (mov r8, r8)
    1e48:	00000381 	.word	0x00000381

00001e4c <spi_cmd_rsp>:

	return result;
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
    1e4c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1e4e:	b083      	sub	sp, #12
    1e50:	1e06      	subs	r6, r0, #0
	sint8 s8RetryCnt;

	/**
		Command/Control response
	**/
	if ((cmd == CMD_RESET) ||
    1e52:	2ecf      	cmp	r6, #207	; 0xcf
    1e54:	d004      	beq.n	1e60 <spi_cmd_rsp+0x14>
    1e56:	0003      	movs	r3, r0
    1e58:	333b      	adds	r3, #59	; 0x3b
    1e5a:	b2db      	uxtb	r3, r3
    1e5c:	2b01      	cmp	r3, #1
    1e5e:	d807      	bhi.n	1e70 <spi_cmd_rsp+0x24>
		 (cmd == CMD_TERMINATE) ||
		 (cmd == CMD_REPEAT)) {
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    1e60:	2101      	movs	r1, #1
    1e62:	466b      	mov	r3, sp
    1e64:	1dd8      	adds	r0, r3, #7
    1e66:	4b24      	ldr	r3, [pc, #144]	; (1ef8 <spi_cmd_rsp+0xac>)
    1e68:	4798      	blx	r3
			result = N_FAIL;
    1e6a:	2300      	movs	r3, #0
		Command/Control response
	**/
	if ((cmd == CMD_RESET) ||
		 (cmd == CMD_TERMINATE) ||
		 (cmd == CMD_REPEAT)) {
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    1e6c:	2800      	cmp	r0, #0
    1e6e:	d140      	bne.n	1ef2 <spi_cmd_rsp+0xa6>

	return result;
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
    1e70:	240b      	movs	r4, #11

	/* wait for response */
	s8RetryCnt = SPI_RESP_RETRY_COUNT;
	do
	{
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    1e72:	466b      	mov	r3, sp
    1e74:	1ddd      	adds	r5, r3, #7
    1e76:	4f20      	ldr	r7, [pc, #128]	; (1ef8 <spi_cmd_rsp+0xac>)
    1e78:	2101      	movs	r1, #1
    1e7a:	0028      	movs	r0, r5
    1e7c:	47b8      	blx	r7
    1e7e:	2800      	cmp	r0, #0
    1e80:	d00d      	beq.n	1e9e <spi_cmd_rsp+0x52>
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
    1e82:	22b1      	movs	r2, #177	; 0xb1
    1e84:	0052      	lsls	r2, r2, #1
    1e86:	491d      	ldr	r1, [pc, #116]	; (1efc <spi_cmd_rsp+0xb0>)
    1e88:	481d      	ldr	r0, [pc, #116]	; (1f00 <spi_cmd_rsp+0xb4>)
    1e8a:	4b1e      	ldr	r3, [pc, #120]	; (1f04 <spi_cmd_rsp+0xb8>)
    1e8c:	4798      	blx	r3
    1e8e:	481e      	ldr	r0, [pc, #120]	; (1f08 <spi_cmd_rsp+0xbc>)
    1e90:	4b1e      	ldr	r3, [pc, #120]	; (1f0c <spi_cmd_rsp+0xc0>)
    1e92:	4798      	blx	r3
    1e94:	200d      	movs	r0, #13
    1e96:	4b1e      	ldr	r3, [pc, #120]	; (1f10 <spi_cmd_rsp+0xc4>)
    1e98:	4798      	blx	r3
			result = N_FAIL;
    1e9a:	2300      	movs	r3, #0
			goto _fail_;
    1e9c:	e029      	b.n	1ef2 <spi_cmd_rsp+0xa6>
		}
	} while((rsp != cmd) && (s8RetryCnt-- >0));
    1e9e:	782b      	ldrb	r3, [r5, #0]
    1ea0:	42b3      	cmp	r3, r6
    1ea2:	d005      	beq.n	1eb0 <spi_cmd_rsp+0x64>
    1ea4:	3c01      	subs	r4, #1
    1ea6:	b2e4      	uxtb	r4, r4
    1ea8:	2c00      	cmp	r4, #0
    1eaa:	d1e5      	bne.n	1e78 <spi_cmd_rsp+0x2c>
    1eac:	340b      	adds	r4, #11
    1eae:	e000      	b.n	1eb2 <spi_cmd_rsp+0x66>
    1eb0:	240b      	movs	r4, #11
	**/
	/* wait for response */
	s8RetryCnt = SPI_RESP_RETRY_COUNT;
	do
	{
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    1eb2:	466b      	mov	r3, sp
    1eb4:	1ddd      	adds	r5, r3, #7
    1eb6:	4e10      	ldr	r6, [pc, #64]	; (1ef8 <spi_cmd_rsp+0xac>)
    1eb8:	2101      	movs	r1, #1
    1eba:	0028      	movs	r0, r5
    1ebc:	47b0      	blx	r6
    1ebe:	2800      	cmp	r0, #0
    1ec0:	d00d      	beq.n	1ede <spi_cmd_rsp+0x92>
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
    1ec2:	22b8      	movs	r2, #184	; 0xb8
    1ec4:	0052      	lsls	r2, r2, #1
    1ec6:	490d      	ldr	r1, [pc, #52]	; (1efc <spi_cmd_rsp+0xb0>)
    1ec8:	480d      	ldr	r0, [pc, #52]	; (1f00 <spi_cmd_rsp+0xb4>)
    1eca:	4b0e      	ldr	r3, [pc, #56]	; (1f04 <spi_cmd_rsp+0xb8>)
    1ecc:	4798      	blx	r3
    1ece:	480e      	ldr	r0, [pc, #56]	; (1f08 <spi_cmd_rsp+0xbc>)
    1ed0:	4b0e      	ldr	r3, [pc, #56]	; (1f0c <spi_cmd_rsp+0xc0>)
    1ed2:	4798      	blx	r3
    1ed4:	200d      	movs	r0, #13
    1ed6:	4b0e      	ldr	r3, [pc, #56]	; (1f10 <spi_cmd_rsp+0xc4>)
    1ed8:	4798      	blx	r3
			result = N_FAIL;
    1eda:	2300      	movs	r3, #0
			goto _fail_;
    1edc:	e009      	b.n	1ef2 <spi_cmd_rsp+0xa6>
		}
	} while((rsp != 0x00) && (s8RetryCnt-- >0));
    1ede:	782b      	ldrb	r3, [r5, #0]
    1ee0:	2b00      	cmp	r3, #0
    1ee2:	d005      	beq.n	1ef0 <spi_cmd_rsp+0xa4>
    1ee4:	3c01      	subs	r4, #1
    1ee6:	b2e4      	uxtb	r4, r4
    1ee8:	2c00      	cmp	r4, #0
    1eea:	d1e5      	bne.n	1eb8 <spi_cmd_rsp+0x6c>
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
	uint8 rsp;
	sint8 result = N_OK;
    1eec:	2301      	movs	r3, #1
    1eee:	e000      	b.n	1ef2 <spi_cmd_rsp+0xa6>
    1ef0:	2301      	movs	r3, #1
	} while((rsp != 0x00) && (s8RetryCnt-- >0));

_fail_:

	return result;
}
    1ef2:	0018      	movs	r0, r3
    1ef4:	b003      	add	sp, #12
    1ef6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1ef8:	00001e2d 	.word	0x00001e2d
    1efc:	0000c6fc 	.word	0x0000c6fc
    1f00:	0000b8b4 	.word	0x0000b8b4
    1f04:	0000a771 	.word	0x0000a771
    1f08:	0000c1e4 	.word	0x0000c1e4
    1f0c:	0000a891 	.word	0x0000a891
    1f10:	0000a7a5 	.word	0x0000a7a5

00001f14 <spi_data_read>:
_error_:
	return result;
}
#endif
static sint8 spi_data_read(uint8 *b, uint16 sz,uint8 clockless)
{
    1f14:	b5f0      	push	{r4, r5, r6, r7, lr}
    1f16:	465f      	mov	r7, fp
    1f18:	4656      	mov	r6, sl
    1f1a:	464d      	mov	r5, r9
    1f1c:	4644      	mov	r4, r8
    1f1e:	b4f0      	push	{r4, r5, r6, r7}
    1f20:	b083      	sub	sp, #12
    1f22:	4682      	mov	sl, r0
    1f24:	4689      	mov	r9, r1
    1f26:	4693      	mov	fp, r2
	uint8 rsp;

	/**
		Data
	**/
	ix = 0;
    1f28:	2300      	movs	r3, #0
    1f2a:	4698      	mov	r8, r3
		/**
			Data Respnose header
		**/
		retry = SPI_RESP_RETRY_COUNT;
		do {
			if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    1f2c:	4f3c      	ldr	r7, [pc, #240]	; (2020 <STACK_SIZE+0x20>)
	/**
		Data
	**/
	ix = 0;
	do {
		if (sz <= DATA_PKT_SZ)
    1f2e:	2380      	movs	r3, #128	; 0x80
    1f30:	019b      	lsls	r3, r3, #6
    1f32:	4599      	cmp	r9, r3
    1f34:	d802      	bhi.n	1f3c <spi_data_read+0x28>
			nbytes = sz;
    1f36:	464b      	mov	r3, r9
    1f38:	b21e      	sxth	r6, r3
    1f3a:	e001      	b.n	1f40 <spi_data_read+0x2c>
		else
			nbytes = DATA_PKT_SZ;
    1f3c:	2680      	movs	r6, #128	; 0x80
    1f3e:	01b6      	lsls	r6, r6, #6

		/**
			Data Respnose header
		**/
		retry = SPI_RESP_RETRY_COUNT;
    1f40:	240a      	movs	r4, #10
		do {
			if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    1f42:	466b      	mov	r3, sp
    1f44:	1cdd      	adds	r5, r3, #3
    1f46:	2101      	movs	r1, #1
    1f48:	0028      	movs	r0, r5
    1f4a:	47b8      	blx	r7
    1f4c:	2800      	cmp	r0, #0
    1f4e:	d00c      	beq.n	1f6a <spi_data_read+0x56>
				M2M_ERR("[nmi spi]: Failed data response read, bus error...\n");
    1f50:	4a34      	ldr	r2, [pc, #208]	; (2024 <STACK_SIZE+0x24>)
    1f52:	4935      	ldr	r1, [pc, #212]	; (2028 <STACK_SIZE+0x28>)
    1f54:	4835      	ldr	r0, [pc, #212]	; (202c <STACK_SIZE+0x2c>)
    1f56:	4b36      	ldr	r3, [pc, #216]	; (2030 <STACK_SIZE+0x30>)
    1f58:	4798      	blx	r3
    1f5a:	4836      	ldr	r0, [pc, #216]	; (2034 <STACK_SIZE+0x34>)
    1f5c:	4b36      	ldr	r3, [pc, #216]	; (2038 <STACK_SIZE+0x38>)
    1f5e:	4798      	blx	r3
    1f60:	200d      	movs	r0, #13
    1f62:	4b36      	ldr	r3, [pc, #216]	; (203c <STACK_SIZE+0x3c>)
    1f64:	4798      	blx	r3
    1f66:	2000      	movs	r0, #0
    1f68:	e053      	b.n	2012 <STACK_SIZE+0x12>
				result = N_FAIL;
				break;
			}
			if (((rsp >> 4) & 0xf) == 0xf)
    1f6a:	782b      	ldrb	r3, [r5, #0]
    1f6c:	091b      	lsrs	r3, r3, #4
    1f6e:	2b0f      	cmp	r3, #15
    1f70:	d004      	beq.n	1f7c <spi_data_read+0x68>
    1f72:	3c01      	subs	r4, #1
    1f74:	b224      	sxth	r4, r4
				break;
		} while (retry--);
    1f76:	1c63      	adds	r3, r4, #1
    1f78:	d1e5      	bne.n	1f46 <spi_data_read+0x32>
    1f7a:	e001      	b.n	1f80 <spi_data_read+0x6c>

		if (result == N_FAIL)
			break;

		if (retry <= 0) {
    1f7c:	2c00      	cmp	r4, #0
    1f7e:	dc0d      	bgt.n	1f9c <spi_data_read+0x88>
			M2M_ERR("[nmi spi]: Failed data response read...(%02x)\n", rsp);
    1f80:	4a2f      	ldr	r2, [pc, #188]	; (2040 <STACK_SIZE+0x40>)
    1f82:	4929      	ldr	r1, [pc, #164]	; (2028 <STACK_SIZE+0x28>)
    1f84:	4829      	ldr	r0, [pc, #164]	; (202c <STACK_SIZE+0x2c>)
    1f86:	4c2a      	ldr	r4, [pc, #168]	; (2030 <STACK_SIZE+0x30>)
    1f88:	47a0      	blx	r4
    1f8a:	466b      	mov	r3, sp
    1f8c:	78d9      	ldrb	r1, [r3, #3]
    1f8e:	482d      	ldr	r0, [pc, #180]	; (2044 <STACK_SIZE+0x44>)
    1f90:	47a0      	blx	r4
    1f92:	200d      	movs	r0, #13
    1f94:	4b29      	ldr	r3, [pc, #164]	; (203c <STACK_SIZE+0x3c>)
    1f96:	4798      	blx	r3
			result = N_FAIL;
    1f98:	2000      	movs	r0, #0
			break;
    1f9a:	e03a      	b.n	2012 <STACK_SIZE+0x12>
		}

		/**
			Read bytes
		**/
		if (M2M_SUCCESS != nmi_spi_read(&b[ix], nbytes)) {
    1f9c:	b2b6      	uxth	r6, r6
    1f9e:	4650      	mov	r0, sl
    1fa0:	4440      	add	r0, r8
    1fa2:	0031      	movs	r1, r6
    1fa4:	4b1e      	ldr	r3, [pc, #120]	; (2020 <STACK_SIZE+0x20>)
    1fa6:	4798      	blx	r3
    1fa8:	2800      	cmp	r0, #0
    1faa:	d00d      	beq.n	1fc8 <spi_data_read+0xb4>
			M2M_ERR("[nmi spi]: Failed data block read, bus error...\n");
    1fac:	22c5      	movs	r2, #197	; 0xc5
    1fae:	0092      	lsls	r2, r2, #2
    1fb0:	491d      	ldr	r1, [pc, #116]	; (2028 <STACK_SIZE+0x28>)
    1fb2:	481e      	ldr	r0, [pc, #120]	; (202c <STACK_SIZE+0x2c>)
    1fb4:	4b1e      	ldr	r3, [pc, #120]	; (2030 <STACK_SIZE+0x30>)
    1fb6:	4798      	blx	r3
    1fb8:	4823      	ldr	r0, [pc, #140]	; (2048 <STACK_SIZE+0x48>)
    1fba:	4b1f      	ldr	r3, [pc, #124]	; (2038 <STACK_SIZE+0x38>)
    1fbc:	4798      	blx	r3
    1fbe:	200d      	movs	r0, #13
    1fc0:	4b1e      	ldr	r3, [pc, #120]	; (203c <STACK_SIZE+0x3c>)
    1fc2:	4798      	blx	r3
			result = N_FAIL;
    1fc4:	2000      	movs	r0, #0
			break;
    1fc6:	e024      	b.n	2012 <STACK_SIZE+0x12>
		}
		if(!clockless)
    1fc8:	465b      	mov	r3, fp
    1fca:	2b00      	cmp	r3, #0
    1fcc:	d116      	bne.n	1ffc <spi_data_read+0xe8>
		{
			/**
			Read Crc
			**/
			if (!gu8Crc_off) {
    1fce:	4b1f      	ldr	r3, [pc, #124]	; (204c <STACK_SIZE+0x4c>)
    1fd0:	781b      	ldrb	r3, [r3, #0]
    1fd2:	2b00      	cmp	r3, #0
    1fd4:	d112      	bne.n	1ffc <spi_data_read+0xe8>
				if (M2M_SUCCESS != nmi_spi_read(crc, 2)) {
    1fd6:	2102      	movs	r1, #2
    1fd8:	a801      	add	r0, sp, #4
    1fda:	4b11      	ldr	r3, [pc, #68]	; (2020 <STACK_SIZE+0x20>)
    1fdc:	4798      	blx	r3
    1fde:	2800      	cmp	r0, #0
    1fe0:	d00c      	beq.n	1ffc <spi_data_read+0xe8>
					M2M_ERR("[nmi spi]: Failed data block crc read, bus error...\n");
    1fe2:	4a1b      	ldr	r2, [pc, #108]	; (2050 <STACK_SIZE+0x50>)
    1fe4:	4910      	ldr	r1, [pc, #64]	; (2028 <STACK_SIZE+0x28>)
    1fe6:	4811      	ldr	r0, [pc, #68]	; (202c <STACK_SIZE+0x2c>)
    1fe8:	4b11      	ldr	r3, [pc, #68]	; (2030 <STACK_SIZE+0x30>)
    1fea:	4798      	blx	r3
    1fec:	4819      	ldr	r0, [pc, #100]	; (2054 <STACK_SIZE+0x54>)
    1fee:	4b12      	ldr	r3, [pc, #72]	; (2038 <STACK_SIZE+0x38>)
    1ff0:	4798      	blx	r3
    1ff2:	200d      	movs	r0, #13
    1ff4:	4b11      	ldr	r3, [pc, #68]	; (203c <STACK_SIZE+0x3c>)
    1ff6:	4798      	blx	r3
					result = N_FAIL;
    1ff8:	2000      	movs	r0, #0
					break;
    1ffa:	e00a      	b.n	2012 <STACK_SIZE+0x12>
				}
			}
		}
		ix += nbytes;
    1ffc:	4643      	mov	r3, r8
    1ffe:	18f3      	adds	r3, r6, r3
    2000:	b21b      	sxth	r3, r3
    2002:	4698      	mov	r8, r3
		sz -= nbytes;
    2004:	464b      	mov	r3, r9
    2006:	1b9e      	subs	r6, r3, r6
    2008:	b2b3      	uxth	r3, r6
    200a:	4699      	mov	r9, r3

	} while (sz);
    200c:	2b00      	cmp	r3, #0
    200e:	d18e      	bne.n	1f2e <spi_data_read+0x1a>
    2010:	2001      	movs	r0, #1

	return result;
}
    2012:	b003      	add	sp, #12
    2014:	bc3c      	pop	{r2, r3, r4, r5}
    2016:	4690      	mov	r8, r2
    2018:	4699      	mov	r9, r3
    201a:	46a2      	mov	sl, r4
    201c:	46ab      	mov	fp, r5
    201e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2020:	00001e2d 	.word	0x00001e2d
    2024:	000002ff 	.word	0x000002ff
    2028:	0000c718 	.word	0x0000c718
    202c:	0000b8b4 	.word	0x0000b8b4
    2030:	0000a771 	.word	0x0000a771
    2034:	0000c218 	.word	0x0000c218
    2038:	0000a891 	.word	0x0000a891
    203c:	0000a7a5 	.word	0x0000a7a5
    2040:	0000030b 	.word	0x0000030b
    2044:	0000c24c 	.word	0x0000c24c
    2048:	0000c27c 	.word	0x0000c27c
    204c:	20000160 	.word	0x20000160
    2050:	0000031f 	.word	0x0000031f
    2054:	0000c2ac 	.word	0x0000c2ac

00002058 <spi_write_reg>:
	Spi interfaces

********************************************/

static sint8 spi_write_reg(uint32 addr, uint32 u32data)
{
    2058:	b5f0      	push	{r4, r5, r6, r7, lr}
    205a:	4657      	mov	r7, sl
    205c:	464e      	mov	r6, r9
    205e:	4645      	mov	r5, r8
    2060:	b4e0      	push	{r5, r6, r7}
    2062:	b086      	sub	sp, #24
    2064:	9003      	str	r0, [sp, #12]
    2066:	9104      	str	r1, [sp, #16]
    2068:	2830      	cmp	r0, #48	; 0x30
    206a:	d802      	bhi.n	2072 <spi_write_reg+0x1a>
    206c:	4b30      	ldr	r3, [pc, #192]	; (2130 <spi_write_reg+0xd8>)
    206e:	781f      	ldrb	r7, [r3, #0]
    2070:	e001      	b.n	2076 <spi_write_reg+0x1e>
    2072:	4b30      	ldr	r3, [pc, #192]	; (2134 <spi_write_reg+0xdc>)
    2074:	781f      	ldrb	r7, [r3, #0]
    2076:	b2fb      	uxtb	r3, r7
    2078:	9305      	str	r3, [sp, #20]
    207a:	2300      	movs	r3, #0
    207c:	2230      	movs	r2, #48	; 0x30
    207e:	9903      	ldr	r1, [sp, #12]
    2080:	428a      	cmp	r2, r1
    2082:	415b      	adcs	r3, r3
    2084:	b2db      	uxtb	r3, r3
    2086:	469a      	mov	sl, r3
    2088:	250a      	movs	r5, #10
		cmd = CMD_SINGLE_WRITE;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, u32data, 4, clockless);
    208a:	4b2b      	ldr	r3, [pc, #172]	; (2138 <spi_write_reg+0xe0>)
    208c:	4698      	mov	r8, r3
		goto _FAIL_;
	}

	result = spi_cmd_rsp(cmd);
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed cmd response, write reg (%08x)...\n", (unsigned int)addr);
    208e:	46d1      	mov	r9, sl
		cmd = CMD_SINGLE_WRITE;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, u32data, 4, clockless);
    2090:	464b      	mov	r3, r9
    2092:	9300      	str	r3, [sp, #0]
    2094:	2304      	movs	r3, #4
    2096:	9a04      	ldr	r2, [sp, #16]
    2098:	9f03      	ldr	r7, [sp, #12]
    209a:	0039      	movs	r1, r7
    209c:	9805      	ldr	r0, [sp, #20]
    209e:	47c0      	blx	r8
    20a0:	1e04      	subs	r4, r0, #0
	if (result != N_OK) {
    20a2:	2c01      	cmp	r4, #1
    20a4:	d00b      	beq.n	20be <spi_write_reg+0x66>
		M2M_ERR("[nmi spi]: Failed cmd, write reg (%08x)...\n", (unsigned int)addr);
    20a6:	4a25      	ldr	r2, [pc, #148]	; (213c <spi_write_reg+0xe4>)
    20a8:	4925      	ldr	r1, [pc, #148]	; (2140 <spi_write_reg+0xe8>)
    20aa:	4826      	ldr	r0, [pc, #152]	; (2144 <spi_write_reg+0xec>)
    20ac:	4e26      	ldr	r6, [pc, #152]	; (2148 <spi_write_reg+0xf0>)
    20ae:	47b0      	blx	r6
    20b0:	0039      	movs	r1, r7
    20b2:	4826      	ldr	r0, [pc, #152]	; (214c <spi_write_reg+0xf4>)
    20b4:	47b0      	blx	r6
    20b6:	200d      	movs	r0, #13
    20b8:	4b25      	ldr	r3, [pc, #148]	; (2150 <spi_write_reg+0xf8>)
    20ba:	4798      	blx	r3
		goto _FAIL_;
    20bc:	e011      	b.n	20e2 <spi_write_reg+0x8a>
	}

	result = spi_cmd_rsp(cmd);
    20be:	9805      	ldr	r0, [sp, #20]
    20c0:	4b24      	ldr	r3, [pc, #144]	; (2154 <spi_write_reg+0xfc>)
    20c2:	4798      	blx	r3
    20c4:	1e04      	subs	r4, r0, #0
	if (result != N_OK) {
    20c6:	2c01      	cmp	r4, #1
    20c8:	d02a      	beq.n	2120 <spi_write_reg+0xc8>
		M2M_ERR("[nmi spi]: Failed cmd response, write reg (%08x)...\n", (unsigned int)addr);
    20ca:	22e7      	movs	r2, #231	; 0xe7
    20cc:	0092      	lsls	r2, r2, #2
    20ce:	491c      	ldr	r1, [pc, #112]	; (2140 <spi_write_reg+0xe8>)
    20d0:	481c      	ldr	r0, [pc, #112]	; (2144 <spi_write_reg+0xec>)
    20d2:	4e1d      	ldr	r6, [pc, #116]	; (2148 <spi_write_reg+0xf0>)
    20d4:	47b0      	blx	r6
    20d6:	9903      	ldr	r1, [sp, #12]
    20d8:	481f      	ldr	r0, [pc, #124]	; (2158 <spi_write_reg+0x100>)
    20da:	47b0      	blx	r6
    20dc:	200d      	movs	r0, #13
    20de:	4b1c      	ldr	r3, [pc, #112]	; (2150 <spi_write_reg+0xf8>)
    20e0:	4798      	blx	r3

#endif
_FAIL_:
	if(result != N_OK)
	{
		nm_bsp_sleep(1);
    20e2:	2001      	movs	r0, #1
    20e4:	4e1d      	ldr	r6, [pc, #116]	; (215c <spi_write_reg+0x104>)
    20e6:	47b0      	blx	r6
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    20e8:	2300      	movs	r3, #0
    20ea:	9300      	str	r3, [sp, #0]
    20ec:	2200      	movs	r2, #0
    20ee:	2100      	movs	r1, #0
    20f0:	20cf      	movs	r0, #207	; 0xcf
    20f2:	4f11      	ldr	r7, [pc, #68]	; (2138 <spi_write_reg+0xe0>)
    20f4:	47b8      	blx	r7
		spi_cmd_rsp(CMD_RESET);
    20f6:	20cf      	movs	r0, #207	; 0xcf
    20f8:	4b16      	ldr	r3, [pc, #88]	; (2154 <spi_write_reg+0xfc>)
    20fa:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx %lx\n",retry,addr,u32data);
    20fc:	4a18      	ldr	r2, [pc, #96]	; (2160 <spi_write_reg+0x108>)
    20fe:	4910      	ldr	r1, [pc, #64]	; (2140 <spi_write_reg+0xe8>)
    2100:	4810      	ldr	r0, [pc, #64]	; (2144 <spi_write_reg+0xec>)
    2102:	4f11      	ldr	r7, [pc, #68]	; (2148 <spi_write_reg+0xf0>)
    2104:	47b8      	blx	r7
    2106:	9b04      	ldr	r3, [sp, #16]
    2108:	9a03      	ldr	r2, [sp, #12]
    210a:	0029      	movs	r1, r5
    210c:	4815      	ldr	r0, [pc, #84]	; (2164 <spi_write_reg+0x10c>)
    210e:	47b8      	blx	r7
    2110:	200d      	movs	r0, #13
    2112:	4b0f      	ldr	r3, [pc, #60]	; (2150 <spi_write_reg+0xf8>)
    2114:	4798      	blx	r3
		nm_bsp_sleep(1);
    2116:	2001      	movs	r0, #1
    2118:	47b0      	blx	r6
    211a:	3d01      	subs	r5, #1
		retry--;
		if(retry) goto _RETRY_;
    211c:	2d00      	cmp	r5, #0
    211e:	d1b7      	bne.n	2090 <spi_write_reg+0x38>
	}

	return result;
}
    2120:	0020      	movs	r0, r4
    2122:	b006      	add	sp, #24
    2124:	bc1c      	pop	{r2, r3, r4}
    2126:	4690      	mov	r8, r2
    2128:	4699      	mov	r9, r3
    212a:	46a2      	mov	sl, r4
    212c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    212e:	46c0      	nop			; (mov r8, r8)
    2130:	0000c160 	.word	0x0000c160
    2134:	0000c161 	.word	0x0000c161
    2138:	00001ca9 	.word	0x00001ca9
    213c:	00000396 	.word	0x00000396
    2140:	0000c180 	.word	0x0000c180
    2144:	0000b8b4 	.word	0x0000b8b4
    2148:	0000a771 	.word	0x0000a771
    214c:	0000c2e0 	.word	0x0000c2e0
    2150:	0000a7a5 	.word	0x0000a7a5
    2154:	00001e4d 	.word	0x00001e4d
    2158:	0000c30c 	.word	0x0000c30c
    215c:	00000129 	.word	0x00000129
    2160:	000003af 	.word	0x000003af
    2164:	0000c344 	.word	0x0000c344

00002168 <spi_read_reg>:

	return result;
}

static sint8 spi_read_reg(uint32 addr, uint32 *u32data)
{
    2168:	b5f0      	push	{r4, r5, r6, r7, lr}
    216a:	465f      	mov	r7, fp
    216c:	4656      	mov	r6, sl
    216e:	464d      	mov	r5, r9
    2170:	4644      	mov	r4, r8
    2172:	b4f0      	push	{r4, r5, r6, r7}
    2174:	b087      	sub	sp, #28
    2176:	9002      	str	r0, [sp, #8]
    2178:	468b      	mov	fp, r1
    217a:	28ff      	cmp	r0, #255	; 0xff
    217c:	d802      	bhi.n	2184 <spi_read_reg+0x1c>
    217e:	4b41      	ldr	r3, [pc, #260]	; (2284 <spi_read_reg+0x11c>)
    2180:	781f      	ldrb	r7, [r3, #0]
    2182:	e001      	b.n	2188 <spi_read_reg+0x20>
    2184:	4b40      	ldr	r3, [pc, #256]	; (2288 <spi_read_reg+0x120>)
    2186:	781f      	ldrb	r7, [r3, #0]
    2188:	b2fb      	uxtb	r3, r7
    218a:	9303      	str	r3, [sp, #12]
    218c:	2300      	movs	r3, #0
    218e:	22ff      	movs	r2, #255	; 0xff
    2190:	9902      	ldr	r1, [sp, #8]
    2192:	428a      	cmp	r2, r1
    2194:	415b      	adcs	r3, r3
    2196:	b2db      	uxtb	r3, r3
    2198:	469a      	mov	sl, r3
    219a:	250a      	movs	r5, #10
		cmd = CMD_SINGLE_READ;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, 4, clockless);
    219c:	4b3b      	ldr	r3, [pc, #236]	; (228c <spi_read_reg+0x124>)
    219e:	4698      	mov	r8, r3
		M2M_ERR("[nmi spi]: Failed cmd response, read reg (%08x)...\n", (unsigned int)addr);
		goto _FAIL_;
	}

	/* to avoid endianess issues */
	result = spi_data_read(&tmp[0], 4, clockless);
    21a0:	46d1      	mov	r9, sl
		cmd = CMD_SINGLE_READ;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, 4, clockless);
    21a2:	464b      	mov	r3, r9
    21a4:	9300      	str	r3, [sp, #0]
    21a6:	2304      	movs	r3, #4
    21a8:	2200      	movs	r2, #0
    21aa:	9f02      	ldr	r7, [sp, #8]
    21ac:	0039      	movs	r1, r7
    21ae:	9803      	ldr	r0, [sp, #12]
    21b0:	47c0      	blx	r8
    21b2:	1e04      	subs	r4, r0, #0
	if (result != N_OK) {
    21b4:	2c01      	cmp	r4, #1
    21b6:	d00b      	beq.n	21d0 <spi_read_reg+0x68>
		M2M_ERR("[nmi spi]: Failed cmd, read reg (%08x)...\n", (unsigned int)addr);
    21b8:	4a35      	ldr	r2, [pc, #212]	; (2290 <spi_read_reg+0x128>)
    21ba:	4936      	ldr	r1, [pc, #216]	; (2294 <spi_read_reg+0x12c>)
    21bc:	4836      	ldr	r0, [pc, #216]	; (2298 <spi_read_reg+0x130>)
    21be:	4e37      	ldr	r6, [pc, #220]	; (229c <spi_read_reg+0x134>)
    21c0:	47b0      	blx	r6
    21c2:	0039      	movs	r1, r7
    21c4:	4836      	ldr	r0, [pc, #216]	; (22a0 <spi_read_reg+0x138>)
    21c6:	47b0      	blx	r6
    21c8:	200d      	movs	r0, #13
    21ca:	4b36      	ldr	r3, [pc, #216]	; (22a4 <spi_read_reg+0x13c>)
    21cc:	4798      	blx	r3
		goto _FAIL_;
    21ce:	e033      	b.n	2238 <spi_read_reg+0xd0>
	}

	result = spi_cmd_rsp(cmd);
    21d0:	9803      	ldr	r0, [sp, #12]
    21d2:	4b35      	ldr	r3, [pc, #212]	; (22a8 <spi_read_reg+0x140>)
    21d4:	4798      	blx	r3
    21d6:	1e04      	subs	r4, r0, #0
	if (result != N_OK) {
    21d8:	2c01      	cmp	r4, #1
    21da:	d00b      	beq.n	21f4 <spi_read_reg+0x8c>
		M2M_ERR("[nmi spi]: Failed cmd response, read reg (%08x)...\n", (unsigned int)addr);
    21dc:	4a33      	ldr	r2, [pc, #204]	; (22ac <spi_read_reg+0x144>)
    21de:	492d      	ldr	r1, [pc, #180]	; (2294 <spi_read_reg+0x12c>)
    21e0:	482d      	ldr	r0, [pc, #180]	; (2298 <spi_read_reg+0x130>)
    21e2:	4e2e      	ldr	r6, [pc, #184]	; (229c <spi_read_reg+0x134>)
    21e4:	47b0      	blx	r6
    21e6:	9902      	ldr	r1, [sp, #8]
    21e8:	4831      	ldr	r0, [pc, #196]	; (22b0 <spi_read_reg+0x148>)
    21ea:	47b0      	blx	r6
    21ec:	200d      	movs	r0, #13
    21ee:	4b2d      	ldr	r3, [pc, #180]	; (22a4 <spi_read_reg+0x13c>)
    21f0:	4798      	blx	r3
		goto _FAIL_;
    21f2:	e021      	b.n	2238 <spi_read_reg+0xd0>
	}

	/* to avoid endianess issues */
	result = spi_data_read(&tmp[0], 4, clockless);
    21f4:	464a      	mov	r2, r9
    21f6:	2104      	movs	r1, #4
    21f8:	a805      	add	r0, sp, #20
    21fa:	4b2e      	ldr	r3, [pc, #184]	; (22b4 <spi_read_reg+0x14c>)
    21fc:	4798      	blx	r3
    21fe:	1e04      	subs	r4, r0, #0
	if (result != N_OK) {
    2200:	2c01      	cmp	r4, #1
    2202:	d00b      	beq.n	221c <spi_read_reg+0xb4>
		M2M_ERR("[nmi spi]: Failed data read...\n");
    2204:	4a2c      	ldr	r2, [pc, #176]	; (22b8 <spi_read_reg+0x150>)
    2206:	4923      	ldr	r1, [pc, #140]	; (2294 <spi_read_reg+0x12c>)
    2208:	4823      	ldr	r0, [pc, #140]	; (2298 <spi_read_reg+0x130>)
    220a:	4b24      	ldr	r3, [pc, #144]	; (229c <spi_read_reg+0x134>)
    220c:	4798      	blx	r3
    220e:	482b      	ldr	r0, [pc, #172]	; (22bc <spi_read_reg+0x154>)
    2210:	4b2b      	ldr	r3, [pc, #172]	; (22c0 <spi_read_reg+0x158>)
    2212:	4798      	blx	r3
    2214:	200d      	movs	r0, #13
    2216:	4b23      	ldr	r3, [pc, #140]	; (22a4 <spi_read_reg+0x13c>)
    2218:	4798      	blx	r3
		goto _FAIL_;
    221a:	e00d      	b.n	2238 <spi_read_reg+0xd0>
	}

#endif

	*u32data = tmp[0] |
		((uint32)tmp[1] << 8) |
    221c:	aa05      	add	r2, sp, #20
		goto _FAIL_;
	}

#endif

	*u32data = tmp[0] |
    221e:	7853      	ldrb	r3, [r2, #1]
    2220:	0219      	lsls	r1, r3, #8
    2222:	7893      	ldrb	r3, [r2, #2]
    2224:	041b      	lsls	r3, r3, #16
    2226:	430b      	orrs	r3, r1
    2228:	7811      	ldrb	r1, [r2, #0]
    222a:	430b      	orrs	r3, r1
    222c:	78d2      	ldrb	r2, [r2, #3]
    222e:	0612      	lsls	r2, r2, #24
    2230:	4313      	orrs	r3, r2
    2232:	465a      	mov	r2, fp
    2234:	6013      	str	r3, [r2, #0]
    2236:	e01d      	b.n	2274 <spi_read_reg+0x10c>
		
_FAIL_:
	if(result != N_OK)
	{
		
		nm_bsp_sleep(1);
    2238:	2001      	movs	r0, #1
    223a:	4e22      	ldr	r6, [pc, #136]	; (22c4 <spi_read_reg+0x15c>)
    223c:	47b0      	blx	r6
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    223e:	2300      	movs	r3, #0
    2240:	9300      	str	r3, [sp, #0]
    2242:	2200      	movs	r2, #0
    2244:	2100      	movs	r1, #0
    2246:	20cf      	movs	r0, #207	; 0xcf
    2248:	4f10      	ldr	r7, [pc, #64]	; (228c <spi_read_reg+0x124>)
    224a:	47b8      	blx	r7
		spi_cmd_rsp(CMD_RESET);
    224c:	20cf      	movs	r0, #207	; 0xcf
    224e:	4b16      	ldr	r3, [pc, #88]	; (22a8 <spi_read_reg+0x140>)
    2250:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx\n",retry,addr);
    2252:	4a1d      	ldr	r2, [pc, #116]	; (22c8 <spi_read_reg+0x160>)
    2254:	490f      	ldr	r1, [pc, #60]	; (2294 <spi_read_reg+0x12c>)
    2256:	4810      	ldr	r0, [pc, #64]	; (2298 <spi_read_reg+0x130>)
    2258:	4f10      	ldr	r7, [pc, #64]	; (229c <spi_read_reg+0x134>)
    225a:	47b8      	blx	r7
    225c:	9a02      	ldr	r2, [sp, #8]
    225e:	0029      	movs	r1, r5
    2260:	481a      	ldr	r0, [pc, #104]	; (22cc <spi_read_reg+0x164>)
    2262:	47b8      	blx	r7
    2264:	200d      	movs	r0, #13
    2266:	4b0f      	ldr	r3, [pc, #60]	; (22a4 <spi_read_reg+0x13c>)
    2268:	4798      	blx	r3
		nm_bsp_sleep(1);
    226a:	2001      	movs	r0, #1
    226c:	47b0      	blx	r6
    226e:	3d01      	subs	r5, #1
		retry--;
		if(retry) goto _RETRY_;
    2270:	2d00      	cmp	r5, #0
    2272:	d196      	bne.n	21a2 <spi_read_reg+0x3a>
	}
		
	return result;
}
    2274:	0020      	movs	r0, r4
    2276:	b007      	add	sp, #28
    2278:	bc3c      	pop	{r2, r3, r4, r5}
    227a:	4690      	mov	r8, r2
    227c:	4699      	mov	r9, r3
    227e:	46a2      	mov	sl, r4
    2280:	46ab      	mov	fp, r5
    2282:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2284:	0000c162 	.word	0x0000c162
    2288:	0000c163 	.word	0x0000c163
    228c:	00001ca9 	.word	0x00001ca9
    2290:	00000417 	.word	0x00000417
    2294:	0000c708 	.word	0x0000c708
    2298:	0000b8b4 	.word	0x0000b8b4
    229c:	0000a771 	.word	0x0000a771
    22a0:	0000c360 	.word	0x0000c360
    22a4:	0000a7a5 	.word	0x0000a7a5
    22a8:	00001e4d 	.word	0x00001e4d
    22ac:	0000041d 	.word	0x0000041d
    22b0:	0000c38c 	.word	0x0000c38c
    22b4:	00001f15 	.word	0x00001f15
    22b8:	00000424 	.word	0x00000424
    22bc:	0000c3c0 	.word	0x0000c3c0
    22c0:	0000a891 	.word	0x0000a891
    22c4:	00000129 	.word	0x00000129
    22c8:	0000043c 	.word	0x0000043c
    22cc:	0000c3e0 	.word	0x0000c3e0

000022d0 <nm_spi_reset>:
	}
	nm_spi_write_reg(SPI_BASE+0x24, val32);
}

sint8 nm_spi_reset(void)
{
    22d0:	b510      	push	{r4, lr}
    22d2:	b082      	sub	sp, #8
	spi_cmd(CMD_RESET, 0, 0, 0, 0);
    22d4:	2300      	movs	r3, #0
    22d6:	9300      	str	r3, [sp, #0]
    22d8:	2200      	movs	r2, #0
    22da:	2100      	movs	r1, #0
    22dc:	20cf      	movs	r0, #207	; 0xcf
    22de:	4c04      	ldr	r4, [pc, #16]	; (22f0 <nm_spi_reset+0x20>)
    22e0:	47a0      	blx	r4
	spi_cmd_rsp(CMD_RESET);
    22e2:	20cf      	movs	r0, #207	; 0xcf
    22e4:	4b03      	ldr	r3, [pc, #12]	; (22f4 <nm_spi_reset+0x24>)
    22e6:	4798      	blx	r3
	return M2M_SUCCESS;
}
    22e8:	2000      	movs	r0, #0
    22ea:	b002      	add	sp, #8
    22ec:	bd10      	pop	{r4, pc}
    22ee:	46c0      	nop			; (mov r8, r8)
    22f0:	00001ca9 	.word	0x00001ca9
    22f4:	00001e4d 	.word	0x00001e4d

000022f8 <nm_spi_deinit>:
*	@date	27 Feb 2015
*	@version	1.0
*/ 
sint8 nm_spi_deinit(void)
{
	gu8Crc_off = 0;
    22f8:	2200      	movs	r2, #0
    22fa:	4b02      	ldr	r3, [pc, #8]	; (2304 <nm_spi_deinit+0xc>)
    22fc:	701a      	strb	r2, [r3, #0]
	return M2M_SUCCESS;
}
    22fe:	2000      	movs	r0, #0
    2300:	4770      	bx	lr
    2302:	46c0      	nop			; (mov r8, r8)
    2304:	20000160 	.word	0x20000160

00002308 <nm_spi_read_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
uint32 nm_spi_read_reg(uint32 u32Addr)
{
    2308:	b500      	push	{lr}
    230a:	b083      	sub	sp, #12
	uint32 u32Val;

	spi_read_reg(u32Addr, &u32Val);
    230c:	a901      	add	r1, sp, #4
    230e:	4b02      	ldr	r3, [pc, #8]	; (2318 <nm_spi_read_reg+0x10>)
    2310:	4798      	blx	r3

	return u32Val;
}
    2312:	9801      	ldr	r0, [sp, #4]
    2314:	b003      	add	sp, #12
    2316:	bd00      	pop	{pc}
    2318:	00002169 	.word	0x00002169

0000231c <nm_spi_read_reg_with_ret>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
{
    231c:	b510      	push	{r4, lr}
	sint8 s8Ret;

	s8Ret = spi_read_reg(u32Addr,pu32RetVal);
    231e:	4b04      	ldr	r3, [pc, #16]	; (2330 <nm_spi_read_reg_with_ret+0x14>)
    2320:	4798      	blx	r3

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    2322:	2300      	movs	r3, #0
    2324:	2801      	cmp	r0, #1
    2326:	d000      	beq.n	232a <nm_spi_read_reg_with_ret+0xe>
	else s8Ret = M2M_ERR_BUS_FAIL;
    2328:	3b06      	subs	r3, #6

	return s8Ret;
}
    232a:	0018      	movs	r0, r3
    232c:	bd10      	pop	{r4, pc}
    232e:	46c0      	nop			; (mov r8, r8)
    2330:	00002169 	.word	0x00002169

00002334 <nm_spi_write_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_write_reg(uint32 u32Addr, uint32 u32Val)
{
    2334:	b510      	push	{r4, lr}
	sint8 s8Ret;

	s8Ret = spi_write_reg(u32Addr, u32Val);
    2336:	4b04      	ldr	r3, [pc, #16]	; (2348 <nm_spi_write_reg+0x14>)
    2338:	4798      	blx	r3

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    233a:	2300      	movs	r3, #0
    233c:	2801      	cmp	r0, #1
    233e:	d000      	beq.n	2342 <nm_spi_write_reg+0xe>
	else s8Ret = M2M_ERR_BUS_FAIL;
    2340:	3b06      	subs	r3, #6

	return s8Ret;
}
    2342:	0018      	movs	r0, r3
    2344:	bd10      	pop	{r4, pc}
    2346:	46c0      	nop			; (mov r8, r8)
    2348:	00002059 	.word	0x00002059

0000234c <nm_spi_init>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_init(void)
{
    234c:	b510      	push	{r4, lr}
    234e:	b082      	sub	sp, #8
	uint32 chipid;
	uint32 reg = 0;
    2350:	2300      	movs	r3, #0
    2352:	9300      	str	r3, [sp, #0]
	

	/**
		configure protocol
	**/
	gu8Crc_off = 0;
    2354:	4a35      	ldr	r2, [pc, #212]	; (242c <nm_spi_init+0xe0>)
    2356:	7013      	strb	r3, [r2, #0]

	// TODO: We can remove the CRC trials if there is a definite way to reset
	// the SPI to it's initial value.
	if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)) {
    2358:	4669      	mov	r1, sp
    235a:	4835      	ldr	r0, [pc, #212]	; (2430 <nm_spi_init+0xe4>)
    235c:	4b35      	ldr	r3, [pc, #212]	; (2434 <nm_spi_init+0xe8>)
    235e:	4798      	blx	r3
    2360:	2800      	cmp	r0, #0
    2362:	d11f      	bne.n	23a4 <nm_spi_init+0x58>
		/* Read failed. Try with CRC off. This might happen when module
		is removed but chip isn't reset*/
		gu8Crc_off = 1;
    2364:	2201      	movs	r2, #1
    2366:	4b31      	ldr	r3, [pc, #196]	; (242c <nm_spi_init+0xe0>)
    2368:	701a      	strb	r2, [r3, #0]
		M2M_ERR("[nmi spi]: Failed internal read protocol with CRC on, retyring with CRC off...\n");
    236a:	4a33      	ldr	r2, [pc, #204]	; (2438 <nm_spi_init+0xec>)
    236c:	4933      	ldr	r1, [pc, #204]	; (243c <nm_spi_init+0xf0>)
    236e:	4834      	ldr	r0, [pc, #208]	; (2440 <nm_spi_init+0xf4>)
    2370:	4b34      	ldr	r3, [pc, #208]	; (2444 <nm_spi_init+0xf8>)
    2372:	4798      	blx	r3
    2374:	4834      	ldr	r0, [pc, #208]	; (2448 <nm_spi_init+0xfc>)
    2376:	4b35      	ldr	r3, [pc, #212]	; (244c <nm_spi_init+0x100>)
    2378:	4798      	blx	r3
    237a:	200d      	movs	r0, #13
    237c:	4b34      	ldr	r3, [pc, #208]	; (2450 <nm_spi_init+0x104>)
    237e:	4798      	blx	r3
		if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)){
    2380:	4669      	mov	r1, sp
    2382:	482b      	ldr	r0, [pc, #172]	; (2430 <nm_spi_init+0xe4>)
    2384:	4b2b      	ldr	r3, [pc, #172]	; (2434 <nm_spi_init+0xe8>)
    2386:	4798      	blx	r3
    2388:	1e04      	subs	r4, r0, #0
    238a:	d10b      	bne.n	23a4 <nm_spi_init+0x58>
			// Reaad failed with both CRC on and off, something went bad
			M2M_ERR( "[nmi spi]: Failed internal read protocol...\n");
    238c:	4a31      	ldr	r2, [pc, #196]	; (2454 <nm_spi_init+0x108>)
    238e:	492b      	ldr	r1, [pc, #172]	; (243c <nm_spi_init+0xf0>)
    2390:	482b      	ldr	r0, [pc, #172]	; (2440 <nm_spi_init+0xf4>)
    2392:	4b2c      	ldr	r3, [pc, #176]	; (2444 <nm_spi_init+0xf8>)
    2394:	4798      	blx	r3
    2396:	4830      	ldr	r0, [pc, #192]	; (2458 <nm_spi_init+0x10c>)
    2398:	4b2c      	ldr	r3, [pc, #176]	; (244c <nm_spi_init+0x100>)
    239a:	4798      	blx	r3
    239c:	200d      	movs	r0, #13
    239e:	4b2c      	ldr	r3, [pc, #176]	; (2450 <nm_spi_init+0x104>)
    23a0:	4798      	blx	r3
			return 0;
    23a2:	e03f      	b.n	2424 <nm_spi_init+0xd8>
		}
	}
	if(gu8Crc_off == 0)
    23a4:	4b21      	ldr	r3, [pc, #132]	; (242c <nm_spi_init+0xe0>)
    23a6:	781b      	ldrb	r3, [r3, #0]
    23a8:	2b00      	cmp	r3, #0
    23aa:	d119      	bne.n	23e0 <nm_spi_init+0x94>
	{
		reg &= ~0xc;	/* disable crc checking */
		reg &= ~0x70;
		reg |= (0x5 << 4);
    23ac:	337c      	adds	r3, #124	; 0x7c
    23ae:	9900      	ldr	r1, [sp, #0]
    23b0:	4399      	bics	r1, r3
    23b2:	3b2c      	subs	r3, #44	; 0x2c
    23b4:	4319      	orrs	r1, r3
    23b6:	9100      	str	r1, [sp, #0]
		if (!spi_write_reg(NMI_SPI_PROTOCOL_CONFIG, reg)) {
    23b8:	481d      	ldr	r0, [pc, #116]	; (2430 <nm_spi_init+0xe4>)
    23ba:	4b28      	ldr	r3, [pc, #160]	; (245c <nm_spi_init+0x110>)
    23bc:	4798      	blx	r3
    23be:	1e04      	subs	r4, r0, #0
    23c0:	d10b      	bne.n	23da <nm_spi_init+0x8e>
			M2M_ERR( "[nmi spi]: Failed internal write protocol reg...\n");
    23c2:	4a27      	ldr	r2, [pc, #156]	; (2460 <nm_spi_init+0x114>)
    23c4:	491d      	ldr	r1, [pc, #116]	; (243c <nm_spi_init+0xf0>)
    23c6:	481e      	ldr	r0, [pc, #120]	; (2440 <nm_spi_init+0xf4>)
    23c8:	4b1e      	ldr	r3, [pc, #120]	; (2444 <nm_spi_init+0xf8>)
    23ca:	4798      	blx	r3
    23cc:	4825      	ldr	r0, [pc, #148]	; (2464 <nm_spi_init+0x118>)
    23ce:	4b1f      	ldr	r3, [pc, #124]	; (244c <nm_spi_init+0x100>)
    23d0:	4798      	blx	r3
    23d2:	200d      	movs	r0, #13
    23d4:	4b1e      	ldr	r3, [pc, #120]	; (2450 <nm_spi_init+0x104>)
    23d6:	4798      	blx	r3
			return 0;
    23d8:	e024      	b.n	2424 <nm_spi_init+0xd8>
		}
		gu8Crc_off = 1;
    23da:	2201      	movs	r2, #1
    23dc:	4b13      	ldr	r3, [pc, #76]	; (242c <nm_spi_init+0xe0>)
    23de:	701a      	strb	r2, [r3, #0]
	}

	/**
		make sure can read back chip id correctly
	**/
	if (!spi_read_reg(0x1000, &chipid)) {
    23e0:	a901      	add	r1, sp, #4
    23e2:	2080      	movs	r0, #128	; 0x80
    23e4:	0140      	lsls	r0, r0, #5
    23e6:	4b13      	ldr	r3, [pc, #76]	; (2434 <nm_spi_init+0xe8>)
    23e8:	4798      	blx	r3
    23ea:	2800      	cmp	r0, #0
    23ec:	d10d      	bne.n	240a <nm_spi_init+0xbe>
		M2M_ERR("[nmi spi]: Fail cmd read chip id...\n");
    23ee:	4a1e      	ldr	r2, [pc, #120]	; (2468 <nm_spi_init+0x11c>)
    23f0:	4912      	ldr	r1, [pc, #72]	; (243c <nm_spi_init+0xf0>)
    23f2:	4813      	ldr	r0, [pc, #76]	; (2440 <nm_spi_init+0xf4>)
    23f4:	4b13      	ldr	r3, [pc, #76]	; (2444 <nm_spi_init+0xf8>)
    23f6:	4798      	blx	r3
    23f8:	481c      	ldr	r0, [pc, #112]	; (246c <nm_spi_init+0x120>)
    23fa:	4b14      	ldr	r3, [pc, #80]	; (244c <nm_spi_init+0x100>)
    23fc:	4798      	blx	r3
    23fe:	200d      	movs	r0, #13
    2400:	4b13      	ldr	r3, [pc, #76]	; (2450 <nm_spi_init+0x104>)
    2402:	4798      	blx	r3
		return M2M_ERR_BUS_FAIL;
    2404:	2406      	movs	r4, #6
    2406:	4264      	negs	r4, r4
    2408:	e00c      	b.n	2424 <nm_spi_init+0xd8>
static void spi_init_pkt_sz(void)
{
	uint32 val32;

	/* Make sure SPI max. packet size fits the defined DATA_PKT_SZ.  */
	val32 = nm_spi_read_reg(SPI_BASE+0x24);
    240a:	4c09      	ldr	r4, [pc, #36]	; (2430 <nm_spi_init+0xe4>)
    240c:	0020      	movs	r0, r4
    240e:	4b18      	ldr	r3, [pc, #96]	; (2470 <nm_spi_init+0x124>)
    2410:	4798      	blx	r3
	val32 &= ~(0x7 << 4);
    2412:	2370      	movs	r3, #112	; 0x70
    2414:	0001      	movs	r1, r0
    2416:	4399      	bics	r1, r3
	case 2048: val32 |= (3 << 4); break;
	case 4096: val32 |= (4 << 4); break;
	case 8192: val32 |= (5 << 4); break;

	}
	nm_spi_write_reg(SPI_BASE+0x24, val32);
    2418:	3b20      	subs	r3, #32
    241a:	4319      	orrs	r1, r3
    241c:	0020      	movs	r0, r4
    241e:	4b15      	ldr	r3, [pc, #84]	; (2474 <nm_spi_init+0x128>)
    2420:	4798      	blx	r3

	M2M_DBG("[nmi spi]: chipid (%08x)\n", (unsigned int)chipid);
	spi_init_pkt_sz();


	return M2M_SUCCESS;
    2422:	2400      	movs	r4, #0
}
    2424:	0020      	movs	r0, r4
    2426:	b002      	add	sp, #8
    2428:	bd10      	pop	{r4, pc}
    242a:	46c0      	nop			; (mov r8, r8)
    242c:	20000160 	.word	0x20000160
    2430:	0000e824 	.word	0x0000e824
    2434:	00002169 	.word	0x00002169
    2438:	000004c7 	.word	0x000004c7
    243c:	0000c828 	.word	0x0000c828
    2440:	0000b8b4 	.word	0x0000b8b4
    2444:	0000a771 	.word	0x0000a771
    2448:	0000c3f8 	.word	0x0000c3f8
    244c:	0000a891 	.word	0x0000a891
    2450:	0000a7a5 	.word	0x0000a7a5
    2454:	000004ca 	.word	0x000004ca
    2458:	0000c448 	.word	0x0000c448
    245c:	00002059 	.word	0x00002059
    2460:	000004d4 	.word	0x000004d4
    2464:	0000c474 	.word	0x0000c474
    2468:	000004de 	.word	0x000004de
    246c:	0000c4a8 	.word	0x0000c4a8
    2470:	00002309 	.word	0x00002309
    2474:	00002335 	.word	0x00002335

00002478 <nm_spi_read_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
    2478:	b5f0      	push	{r4, r5, r6, r7, lr}
    247a:	465f      	mov	r7, fp
    247c:	4656      	mov	r6, sl
    247e:	464d      	mov	r5, r9
    2480:	4644      	mov	r4, r8
    2482:	b4f0      	push	{r4, r5, r6, r7}
    2484:	b087      	sub	sp, #28
    2486:	9002      	str	r0, [sp, #8]
    2488:	9103      	str	r1, [sp, #12]
    248a:	0016      	movs	r6, r2
    248c:	250a      	movs	r5, #10
	uint8 cmd = CMD_DMA_EXT_READ;
	sint8 result;
	uint8 retry = SPI_RETRY_COUNT;
#if defined USE_OLD_SPI_SW
	uint8 tmp[2];
	uint8 single_byte_workaround = 0;
    248e:	2300      	movs	r3, #0
    2490:	469b      	mov	fp, r3
	{
		//Workaround hardware problem with single byte transfers over SPI bus
		size = 2;
		single_byte_workaround = 1;
	}
	result = spi_cmd(cmd, addr, 0, size,0);
    2492:	2400      	movs	r4, #0
    2494:	4b3e      	ldr	r3, [pc, #248]	; (2590 <nm_spi_read_block+0x118>)
    2496:	4698      	mov	r8, r3
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed cmd, read block (%08x)...\n", (unsigned int)addr);
		goto _FAIL_;
	}

	result = spi_cmd_rsp(cmd);
    2498:	46a9      	mov	r9, r5

	/**
		Command
	**/
#if defined USE_OLD_SPI_SW
	if (size == 1)
    249a:	2e01      	cmp	r6, #1
    249c:	d102      	bne.n	24a4 <nm_spi_read_block+0x2c>
	{
		//Workaround hardware problem with single byte transfers over SPI bus
		size = 2;
		single_byte_workaround = 1;
    249e:	2301      	movs	r3, #1
    24a0:	469b      	mov	fp, r3
	**/
#if defined USE_OLD_SPI_SW
	if (size == 1)
	{
		//Workaround hardware problem with single byte transfers over SPI bus
		size = 2;
    24a2:	3601      	adds	r6, #1
		single_byte_workaround = 1;
	}
	result = spi_cmd(cmd, addr, 0, size,0);
    24a4:	9400      	str	r4, [sp, #0]
    24a6:	0033      	movs	r3, r6
    24a8:	0022      	movs	r2, r4
    24aa:	9d02      	ldr	r5, [sp, #8]
    24ac:	0029      	movs	r1, r5
    24ae:	20c8      	movs	r0, #200	; 0xc8
    24b0:	47c0      	blx	r8
	if (result != N_OK) {
    24b2:	2801      	cmp	r0, #1
    24b4:	d00b      	beq.n	24ce <nm_spi_read_block+0x56>
		M2M_ERR("[nmi spi]: Failed cmd, read block (%08x)...\n", (unsigned int)addr);
    24b6:	4a37      	ldr	r2, [pc, #220]	; (2594 <nm_spi_read_block+0x11c>)
    24b8:	4937      	ldr	r1, [pc, #220]	; (2598 <nm_spi_read_block+0x120>)
    24ba:	4838      	ldr	r0, [pc, #224]	; (259c <nm_spi_read_block+0x124>)
    24bc:	4f38      	ldr	r7, [pc, #224]	; (25a0 <nm_spi_read_block+0x128>)
    24be:	47b8      	blx	r7
    24c0:	0029      	movs	r1, r5
    24c2:	4838      	ldr	r0, [pc, #224]	; (25a4 <nm_spi_read_block+0x12c>)
    24c4:	47b8      	blx	r7
    24c6:	200d      	movs	r0, #13
    24c8:	4b37      	ldr	r3, [pc, #220]	; (25a8 <nm_spi_read_block+0x130>)
    24ca:	4798      	blx	r3
    24cc:	e032      	b.n	2534 <nm_spi_read_block+0xbc>
		goto _FAIL_;
	}

	result = spi_cmd_rsp(cmd);
    24ce:	20c8      	movs	r0, #200	; 0xc8
    24d0:	4b36      	ldr	r3, [pc, #216]	; (25ac <nm_spi_read_block+0x134>)
    24d2:	4798      	blx	r3
	if (result != N_OK) {
    24d4:	2801      	cmp	r0, #1
    24d6:	d00b      	beq.n	24f0 <nm_spi_read_block+0x78>
		M2M_ERR("[nmi spi]: Failed cmd response, read block (%08x)...\n", (unsigned int)addr);
    24d8:	4a35      	ldr	r2, [pc, #212]	; (25b0 <nm_spi_read_block+0x138>)
    24da:	492f      	ldr	r1, [pc, #188]	; (2598 <nm_spi_read_block+0x120>)
    24dc:	482f      	ldr	r0, [pc, #188]	; (259c <nm_spi_read_block+0x124>)
    24de:	4f30      	ldr	r7, [pc, #192]	; (25a0 <nm_spi_read_block+0x128>)
    24e0:	47b8      	blx	r7
    24e2:	9902      	ldr	r1, [sp, #8]
    24e4:	4833      	ldr	r0, [pc, #204]	; (25b4 <nm_spi_read_block+0x13c>)
    24e6:	47b8      	blx	r7
    24e8:	200d      	movs	r0, #13
    24ea:	4b2f      	ldr	r3, [pc, #188]	; (25a8 <nm_spi_read_block+0x130>)
    24ec:	4798      	blx	r3
    24ee:	e021      	b.n	2534 <nm_spi_read_block+0xbc>
	}

	/**
		Data
	**/
	if (single_byte_workaround)
    24f0:	465b      	mov	r3, fp
    24f2:	2b00      	cmp	r3, #0
    24f4:	d009      	beq.n	250a <nm_spi_read_block+0x92>
	{
		result = spi_data_read(tmp, size,0);
    24f6:	af05      	add	r7, sp, #20
    24f8:	0022      	movs	r2, r4
    24fa:	0031      	movs	r1, r6
    24fc:	0038      	movs	r0, r7
    24fe:	4b2e      	ldr	r3, [pc, #184]	; (25b8 <nm_spi_read_block+0x140>)
    2500:	4798      	blx	r3
		buf[0] = tmp[0];
    2502:	783b      	ldrb	r3, [r7, #0]
    2504:	9a03      	ldr	r2, [sp, #12]
    2506:	7013      	strb	r3, [r2, #0]
    2508:	e004      	b.n	2514 <nm_spi_read_block+0x9c>
	}
	else
		result = spi_data_read(buf, size,0);
    250a:	0022      	movs	r2, r4
    250c:	0031      	movs	r1, r6
    250e:	9803      	ldr	r0, [sp, #12]
    2510:	4b29      	ldr	r3, [pc, #164]	; (25b8 <nm_spi_read_block+0x140>)
    2512:	4798      	blx	r3

	if (result != N_OK) {
    2514:	2801      	cmp	r0, #1
    2516:	d00b      	beq.n	2530 <nm_spi_read_block+0xb8>
		M2M_ERR("[nmi spi]: Failed block data read...\n");
    2518:	4a28      	ldr	r2, [pc, #160]	; (25bc <nm_spi_read_block+0x144>)
    251a:	491f      	ldr	r1, [pc, #124]	; (2598 <nm_spi_read_block+0x120>)
    251c:	481f      	ldr	r0, [pc, #124]	; (259c <nm_spi_read_block+0x124>)
    251e:	4b20      	ldr	r3, [pc, #128]	; (25a0 <nm_spi_read_block+0x128>)
    2520:	4798      	blx	r3
    2522:	4827      	ldr	r0, [pc, #156]	; (25c0 <nm_spi_read_block+0x148>)
    2524:	4b27      	ldr	r3, [pc, #156]	; (25c4 <nm_spi_read_block+0x14c>)
    2526:	4798      	blx	r3
    2528:	200d      	movs	r0, #13
    252a:	4b1f      	ldr	r3, [pc, #124]	; (25a8 <nm_spi_read_block+0x130>)
    252c:	4798      	blx	r3
    252e:	e001      	b.n	2534 <nm_spi_read_block+0xbc>
{
	sint8 s8Ret;

	s8Ret = nm_spi_read(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    2530:	2000      	movs	r0, #0
    2532:	e025      	b.n	2580 <nm_spi_read_block+0x108>
#endif

_FAIL_:
	if(result != N_OK)
	{
		nm_bsp_sleep(1);
    2534:	2001      	movs	r0, #1
    2536:	4f24      	ldr	r7, [pc, #144]	; (25c8 <nm_spi_read_block+0x150>)
    2538:	47b8      	blx	r7
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    253a:	9400      	str	r4, [sp, #0]
    253c:	0023      	movs	r3, r4
    253e:	0022      	movs	r2, r4
    2540:	0021      	movs	r1, r4
    2542:	20cf      	movs	r0, #207	; 0xcf
    2544:	4d12      	ldr	r5, [pc, #72]	; (2590 <nm_spi_read_block+0x118>)
    2546:	47a8      	blx	r5
		spi_cmd_rsp(CMD_RESET);
    2548:	20cf      	movs	r0, #207	; 0xcf
    254a:	4b18      	ldr	r3, [pc, #96]	; (25ac <nm_spi_read_block+0x134>)
    254c:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx %d\n",retry,addr,size);
    254e:	4a1f      	ldr	r2, [pc, #124]	; (25cc <nm_spi_read_block+0x154>)
    2550:	4911      	ldr	r1, [pc, #68]	; (2598 <nm_spi_read_block+0x120>)
    2552:	4812      	ldr	r0, [pc, #72]	; (259c <nm_spi_read_block+0x124>)
    2554:	4b12      	ldr	r3, [pc, #72]	; (25a0 <nm_spi_read_block+0x128>)
    2556:	469a      	mov	sl, r3
    2558:	4798      	blx	r3
    255a:	0033      	movs	r3, r6
    255c:	9a02      	ldr	r2, [sp, #8]
    255e:	4649      	mov	r1, r9
    2560:	481b      	ldr	r0, [pc, #108]	; (25d0 <nm_spi_read_block+0x158>)
    2562:	47d0      	blx	sl
    2564:	200d      	movs	r0, #13
    2566:	4b10      	ldr	r3, [pc, #64]	; (25a8 <nm_spi_read_block+0x130>)
    2568:	4798      	blx	r3
		nm_bsp_sleep(1);
    256a:	2001      	movs	r0, #1
    256c:	47b8      	blx	r7
    256e:	2301      	movs	r3, #1
    2570:	425b      	negs	r3, r3
    2572:	469c      	mov	ip, r3
    2574:	44e1      	add	r9, ip
		retry--;
		if(retry) goto _RETRY_;
    2576:	464b      	mov	r3, r9
    2578:	2b00      	cmp	r3, #0
    257a:	d18e      	bne.n	249a <nm_spi_read_block+0x22>
	sint8 s8Ret;

	s8Ret = nm_spi_read(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
	else s8Ret = M2M_ERR_BUS_FAIL;
    257c:	2006      	movs	r0, #6
    257e:	4240      	negs	r0, r0

	return s8Ret;
}
    2580:	b007      	add	sp, #28
    2582:	bc3c      	pop	{r2, r3, r4, r5}
    2584:	4690      	mov	r8, r2
    2586:	4699      	mov	r9, r3
    2588:	46a2      	mov	sl, r4
    258a:	46ab      	mov	fp, r5
    258c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    258e:	46c0      	nop			; (mov r8, r8)
    2590:	00001ca9 	.word	0x00001ca9
    2594:	0000045d 	.word	0x0000045d
    2598:	0000c164 	.word	0x0000c164
    259c:	0000b8b4 	.word	0x0000b8b4
    25a0:	0000a771 	.word	0x0000a771
    25a4:	0000c4cc 	.word	0x0000c4cc
    25a8:	0000a7a5 	.word	0x0000a7a5
    25ac:	00001e4d 	.word	0x00001e4d
    25b0:	00000463 	.word	0x00000463
    25b4:	0000c4fc 	.word	0x0000c4fc
    25b8:	00001f15 	.word	0x00001f15
    25bc:	00000473 	.word	0x00000473
    25c0:	0000c534 	.word	0x0000c534
    25c4:	0000a891 	.word	0x0000a891
    25c8:	00000129 	.word	0x00000129
    25cc:	00000484 	.word	0x00000484
    25d0:	0000c55c 	.word	0x0000c55c

000025d4 <nm_spi_write_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
    25d4:	b5f0      	push	{r4, r5, r6, r7, lr}
    25d6:	465f      	mov	r7, fp
    25d8:	4656      	mov	r6, sl
    25da:	464d      	mov	r5, r9
    25dc:	4644      	mov	r4, r8
    25de:	b4f0      	push	{r4, r5, r6, r7}
    25e0:	b089      	sub	sp, #36	; 0x24
    25e2:	9004      	str	r0, [sp, #16]
    25e4:	4688      	mov	r8, r1
    25e6:	9203      	str	r2, [sp, #12]
    25e8:	270a      	movs	r7, #10
#if defined USE_OLD_SPI_SW
	//Workaround hardware problem with single byte transfers over SPI bus
	if (size == 1)
		size = 2;

	result = spi_cmd(cmd, addr, 0, size,0);
    25ea:	2600      	movs	r6, #0
    25ec:	4b89      	ldr	r3, [pc, #548]	; (2814 <nm_spi_write_block+0x240>)
    25ee:	469a      	mov	sl, r3
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed cmd, write block (%08x)...\n", (unsigned int)addr);
		goto _FAIL_;
	}

	result = spi_cmd_rsp(cmd);
    25f0:	46b9      	mov	r9, r7
	/**
		Command
	**/
#if defined USE_OLD_SPI_SW
	//Workaround hardware problem with single byte transfers over SPI bus
	if (size == 1)
    25f2:	9b03      	ldr	r3, [sp, #12]
    25f4:	2b01      	cmp	r3, #1
    25f6:	d101      	bne.n	25fc <nm_spi_write_block+0x28>
		size = 2;
    25f8:	3301      	adds	r3, #1
    25fa:	9303      	str	r3, [sp, #12]

	result = spi_cmd(cmd, addr, 0, size,0);
    25fc:	9600      	str	r6, [sp, #0]
    25fe:	9b03      	ldr	r3, [sp, #12]
    2600:	0032      	movs	r2, r6
    2602:	9d04      	ldr	r5, [sp, #16]
    2604:	0029      	movs	r1, r5
    2606:	20c7      	movs	r0, #199	; 0xc7
    2608:	47d0      	blx	sl
	if (result != N_OK) {
    260a:	2801      	cmp	r0, #1
    260c:	d00b      	beq.n	2626 <nm_spi_write_block+0x52>
		M2M_ERR("[nmi spi]: Failed cmd, write block (%08x)...\n", (unsigned int)addr);
    260e:	4a82      	ldr	r2, [pc, #520]	; (2818 <nm_spi_write_block+0x244>)
    2610:	4982      	ldr	r1, [pc, #520]	; (281c <nm_spi_write_block+0x248>)
    2612:	4883      	ldr	r0, [pc, #524]	; (2820 <nm_spi_write_block+0x24c>)
    2614:	4c83      	ldr	r4, [pc, #524]	; (2824 <nm_spi_write_block+0x250>)
    2616:	47a0      	blx	r4
    2618:	0029      	movs	r1, r5
    261a:	4883      	ldr	r0, [pc, #524]	; (2828 <nm_spi_write_block+0x254>)
    261c:	47a0      	blx	r4
    261e:	200d      	movs	r0, #13
    2620:	4b82      	ldr	r3, [pc, #520]	; (282c <nm_spi_write_block+0x258>)
    2622:	4798      	blx	r3
    2624:	e0c9      	b.n	27ba <nm_spi_write_block+0x1e6>
		goto _FAIL_;
	}

	result = spi_cmd_rsp(cmd);
    2626:	20c7      	movs	r0, #199	; 0xc7
    2628:	4b81      	ldr	r3, [pc, #516]	; (2830 <nm_spi_write_block+0x25c>)
    262a:	4798      	blx	r3
	if (result != N_OK) {
    262c:	2801      	cmp	r0, #1
    262e:	d00c      	beq.n	264a <nm_spi_write_block+0x76>
		M2M_ERR("[nmi spi ]: Failed cmd response, write block (%08x)...\n", (unsigned int)addr);
    2630:	22f4      	movs	r2, #244	; 0xf4
    2632:	0092      	lsls	r2, r2, #2
    2634:	4979      	ldr	r1, [pc, #484]	; (281c <nm_spi_write_block+0x248>)
    2636:	487a      	ldr	r0, [pc, #488]	; (2820 <nm_spi_write_block+0x24c>)
    2638:	4c7a      	ldr	r4, [pc, #488]	; (2824 <nm_spi_write_block+0x250>)
    263a:	47a0      	blx	r4
    263c:	9904      	ldr	r1, [sp, #16]
    263e:	487d      	ldr	r0, [pc, #500]	; (2834 <nm_spi_write_block+0x260>)
    2640:	47a0      	blx	r4
    2642:	200d      	movs	r0, #13
    2644:	4b79      	ldr	r3, [pc, #484]	; (282c <nm_spi_write_block+0x258>)
    2646:	4798      	blx	r3
    2648:	e0b7      	b.n	27ba <nm_spi_write_block+0x1e6>
static sint8 spi_data_write(uint8 *b, uint16 sz)
{
	sint16 ix;
	uint16 nbytes;
	sint8 result = 1;
	uint8 cmd, order, crc[2] = {0};
    264a:	ab07      	add	r3, sp, #28
    264c:	801e      	strh	r6, [r3, #0]
    264e:	9c03      	ldr	r4, [sp, #12]
	//uint8 rsp;

	/**
		Data
	**/
	ix = 0;
    2650:	0037      	movs	r7, r6
    2652:	2380      	movs	r3, #128	; 0x80
    2654:	019b      	lsls	r3, r3, #6
    2656:	469b      	mov	fp, r3
    2658:	466a      	mov	r2, sp
    265a:	82d3      	strh	r3, [r2, #22]
    265c:	1c25      	adds	r5, r4, #0
    265e:	455c      	cmp	r4, fp
    2660:	d901      	bls.n	2666 <nm_spi_write_block+0x92>
    2662:	466b      	mov	r3, sp
    2664:	8add      	ldrh	r5, [r3, #22]
    2666:	b2ad      	uxth	r5, r5

		/**
			Write command
		**/
		cmd = 0xf0;
		if (ix == 0)  {
    2668:	2f00      	cmp	r7, #0
    266a:	d104      	bne.n	2676 <nm_spi_write_block+0xa2>
			if (sz <= DATA_PKT_SZ)
				order = 0x3;
    266c:	2303      	movs	r3, #3
		/**
			Write command
		**/
		cmd = 0xf0;
		if (ix == 0)  {
			if (sz <= DATA_PKT_SZ)
    266e:	455c      	cmp	r4, fp
    2670:	d906      	bls.n	2680 <nm_spi_write_block+0xac>
				order = 0x3;
			else
				order = 0x1;
    2672:	3b02      	subs	r3, #2
    2674:	e004      	b.n	2680 <nm_spi_write_block+0xac>
		} else {
			if (sz <= DATA_PKT_SZ)
				order = 0x3;
			else
				order = 0x2;
    2676:	0033      	movs	r3, r6
    2678:	465a      	mov	r2, fp
    267a:	42a2      	cmp	r2, r4
    267c:	4173      	adcs	r3, r6
    267e:	3302      	adds	r3, #2
		}
		cmd |= order;
    2680:	200b      	movs	r0, #11
    2682:	aa04      	add	r2, sp, #16
    2684:	4694      	mov	ip, r2
    2686:	4460      	add	r0, ip
    2688:	2210      	movs	r2, #16
    268a:	4252      	negs	r2, r2
    268c:	4313      	orrs	r3, r2
    268e:	7003      	strb	r3, [r0, #0]
		if (M2M_SUCCESS != nmi_spi_write(&cmd, 1)) {
    2690:	2101      	movs	r1, #1
    2692:	4b69      	ldr	r3, [pc, #420]	; (2838 <nm_spi_write_block+0x264>)
    2694:	4798      	blx	r3
    2696:	2800      	cmp	r0, #0
    2698:	d00c      	beq.n	26b4 <nm_spi_write_block+0xe0>
			M2M_ERR("[nmi spi]: Failed data block cmd write, bus error...\n");
    269a:	22d4      	movs	r2, #212	; 0xd4
    269c:	0092      	lsls	r2, r2, #2
    269e:	4967      	ldr	r1, [pc, #412]	; (283c <nm_spi_write_block+0x268>)
    26a0:	485f      	ldr	r0, [pc, #380]	; (2820 <nm_spi_write_block+0x24c>)
    26a2:	4b60      	ldr	r3, [pc, #384]	; (2824 <nm_spi_write_block+0x250>)
    26a4:	4798      	blx	r3
    26a6:	4866      	ldr	r0, [pc, #408]	; (2840 <nm_spi_write_block+0x26c>)
    26a8:	4b66      	ldr	r3, [pc, #408]	; (2844 <nm_spi_write_block+0x270>)
    26aa:	4798      	blx	r3
    26ac:	200d      	movs	r0, #13
    26ae:	4b5f      	ldr	r3, [pc, #380]	; (282c <nm_spi_write_block+0x258>)
    26b0:	4798      	blx	r3
    26b2:	e059      	b.n	2768 <nm_spi_write_block+0x194>
		}

		/**
			Write data
		**/
		if (M2M_SUCCESS != nmi_spi_write(&b[ix], nbytes)) {
    26b4:	4643      	mov	r3, r8
    26b6:	19d8      	adds	r0, r3, r7
    26b8:	0029      	movs	r1, r5
    26ba:	4b5f      	ldr	r3, [pc, #380]	; (2838 <nm_spi_write_block+0x264>)
    26bc:	4798      	blx	r3
    26be:	2800      	cmp	r0, #0
    26c0:	d00b      	beq.n	26da <nm_spi_write_block+0x106>
			M2M_ERR("[nmi spi]: Failed data block write, bus error...\n");
    26c2:	4a61      	ldr	r2, [pc, #388]	; (2848 <nm_spi_write_block+0x274>)
    26c4:	495d      	ldr	r1, [pc, #372]	; (283c <nm_spi_write_block+0x268>)
    26c6:	4856      	ldr	r0, [pc, #344]	; (2820 <nm_spi_write_block+0x24c>)
    26c8:	4b56      	ldr	r3, [pc, #344]	; (2824 <nm_spi_write_block+0x250>)
    26ca:	4798      	blx	r3
    26cc:	485f      	ldr	r0, [pc, #380]	; (284c <nm_spi_write_block+0x278>)
    26ce:	4b5d      	ldr	r3, [pc, #372]	; (2844 <nm_spi_write_block+0x270>)
    26d0:	4798      	blx	r3
    26d2:	200d      	movs	r0, #13
    26d4:	4b55      	ldr	r3, [pc, #340]	; (282c <nm_spi_write_block+0x258>)
    26d6:	4798      	blx	r3
    26d8:	e046      	b.n	2768 <nm_spi_write_block+0x194>
		}

		/**
			Write Crc
		**/
		if (!gu8Crc_off) {
    26da:	4b5d      	ldr	r3, [pc, #372]	; (2850 <nm_spi_write_block+0x27c>)
    26dc:	781b      	ldrb	r3, [r3, #0]
    26de:	2b00      	cmp	r3, #0
    26e0:	d111      	bne.n	2706 <nm_spi_write_block+0x132>
			if (M2M_SUCCESS != nmi_spi_write(crc, 2)) {
    26e2:	2102      	movs	r1, #2
    26e4:	a807      	add	r0, sp, #28
    26e6:	4b54      	ldr	r3, [pc, #336]	; (2838 <nm_spi_write_block+0x264>)
    26e8:	4798      	blx	r3
    26ea:	2800      	cmp	r0, #0
    26ec:	d00b      	beq.n	2706 <nm_spi_write_block+0x132>
				M2M_ERR("[nmi spi]: Failed data block crc write, bus error...\n");
    26ee:	4a59      	ldr	r2, [pc, #356]	; (2854 <nm_spi_write_block+0x280>)
    26f0:	4952      	ldr	r1, [pc, #328]	; (283c <nm_spi_write_block+0x268>)
    26f2:	484b      	ldr	r0, [pc, #300]	; (2820 <nm_spi_write_block+0x24c>)
    26f4:	4b4b      	ldr	r3, [pc, #300]	; (2824 <nm_spi_write_block+0x250>)
    26f6:	4798      	blx	r3
    26f8:	4857      	ldr	r0, [pc, #348]	; (2858 <nm_spi_write_block+0x284>)
    26fa:	4b52      	ldr	r3, [pc, #328]	; (2844 <nm_spi_write_block+0x270>)
    26fc:	4798      	blx	r3
    26fe:	200d      	movs	r0, #13
    2700:	4b4a      	ldr	r3, [pc, #296]	; (282c <nm_spi_write_block+0x258>)
    2702:	4798      	blx	r3
    2704:	e030      	b.n	2768 <nm_spi_write_block+0x194>
				result = N_FAIL;
				break;
			}
		}

		ix += nbytes;
    2706:	19ef      	adds	r7, r5, r7
    2708:	b23f      	sxth	r7, r7
		sz -= nbytes;
    270a:	1b64      	subs	r4, r4, r5
    270c:	b2a4      	uxth	r4, r4
	} while (sz);
    270e:	2c00      	cmp	r4, #0
    2710:	d1a4      	bne.n	265c <nm_spi_write_block+0x88>
    2712:	e036      	b.n	2782 <nm_spi_write_block+0x1ae>
		len = 2;
	else
		len = 3;

	if (M2M_SUCCESS != nmi_spi_read(&rsp[0], len)) {
		M2M_ERR("[nmi spi]: Failed bus error...\n");
    2714:	223c      	movs	r2, #60	; 0x3c
    2716:	32ff      	adds	r2, #255	; 0xff
    2718:	4950      	ldr	r1, [pc, #320]	; (285c <nm_spi_write_block+0x288>)
    271a:	4841      	ldr	r0, [pc, #260]	; (2820 <nm_spi_write_block+0x24c>)
    271c:	4b41      	ldr	r3, [pc, #260]	; (2824 <nm_spi_write_block+0x250>)
    271e:	4798      	blx	r3
    2720:	484f      	ldr	r0, [pc, #316]	; (2860 <nm_spi_write_block+0x28c>)
    2722:	4b48      	ldr	r3, [pc, #288]	; (2844 <nm_spi_write_block+0x270>)
    2724:	4798      	blx	r3
    2726:	200d      	movs	r0, #13
    2728:	4b40      	ldr	r3, [pc, #256]	; (282c <nm_spi_write_block+0x258>)
    272a:	4798      	blx	r3
    272c:	e036      	b.n	279c <nm_spi_write_block+0x1c8>
		result = N_FAIL;
		goto _fail_;
	}
		
	if((rsp[len-1] != 0)||(rsp[len-2] != 0xC3))
    272e:	ab08      	add	r3, sp, #32
    2730:	191b      	adds	r3, r3, r4
    2732:	3b05      	subs	r3, #5
    2734:	781b      	ldrb	r3, [r3, #0]
    2736:	2b00      	cmp	r3, #0
    2738:	d106      	bne.n	2748 <nm_spi_write_block+0x174>
    273a:	ab08      	add	r3, sp, #32
    273c:	469c      	mov	ip, r3
    273e:	4464      	add	r4, ip
    2740:	3c06      	subs	r4, #6
    2742:	7823      	ldrb	r3, [r4, #0]
    2744:	2bc3      	cmp	r3, #195	; 0xc3
    2746:	d036      	beq.n	27b6 <nm_spi_write_block+0x1e2>
	{
		M2M_ERR("[nmi spi]: Failed data response read, %x %x %x\n",rsp[0],rsp[1],rsp[2]);
    2748:	22a1      	movs	r2, #161	; 0xa1
    274a:	0052      	lsls	r2, r2, #1
    274c:	4943      	ldr	r1, [pc, #268]	; (285c <nm_spi_write_block+0x288>)
    274e:	4834      	ldr	r0, [pc, #208]	; (2820 <nm_spi_write_block+0x24c>)
    2750:	4c34      	ldr	r4, [pc, #208]	; (2824 <nm_spi_write_block+0x250>)
    2752:	47a0      	blx	r4
    2754:	a907      	add	r1, sp, #28
    2756:	788b      	ldrb	r3, [r1, #2]
    2758:	784a      	ldrb	r2, [r1, #1]
    275a:	7809      	ldrb	r1, [r1, #0]
    275c:	4841      	ldr	r0, [pc, #260]	; (2864 <nm_spi_write_block+0x290>)
    275e:	47a0      	blx	r4
    2760:	200d      	movs	r0, #13
    2762:	4b32      	ldr	r3, [pc, #200]	; (282c <nm_spi_write_block+0x258>)
    2764:	4798      	blx	r3
    2766:	e019      	b.n	279c <nm_spi_write_block+0x1c8>
	/**
		Data
	**/
	result = spi_data_write(buf, size);
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed block data write...\n");
    2768:	22f8      	movs	r2, #248	; 0xf8
    276a:	0092      	lsls	r2, r2, #2
    276c:	492b      	ldr	r1, [pc, #172]	; (281c <nm_spi_write_block+0x248>)
    276e:	482c      	ldr	r0, [pc, #176]	; (2820 <nm_spi_write_block+0x24c>)
    2770:	4b2c      	ldr	r3, [pc, #176]	; (2824 <nm_spi_write_block+0x250>)
    2772:	4798      	blx	r3
    2774:	483c      	ldr	r0, [pc, #240]	; (2868 <nm_spi_write_block+0x294>)
    2776:	4b33      	ldr	r3, [pc, #204]	; (2844 <nm_spi_write_block+0x270>)
    2778:	4798      	blx	r3
    277a:	200d      	movs	r0, #13
    277c:	4b2b      	ldr	r3, [pc, #172]	; (282c <nm_spi_write_block+0x258>)
    277e:	4798      	blx	r3
    2780:	e01b      	b.n	27ba <nm_spi_write_block+0x1e6>
{
	uint8 len;
	uint8 rsp[3];
	sint8 result = N_OK;

    if (!gu8Crc_off)
    2782:	4b33      	ldr	r3, [pc, #204]	; (2850 <nm_spi_write_block+0x27c>)
    2784:	781c      	ldrb	r4, [r3, #0]
		len = 2;
	else
		len = 3;
    2786:	4263      	negs	r3, r4
    2788:	4163      	adcs	r3, r4
    278a:	2403      	movs	r4, #3
    278c:	1ae4      	subs	r4, r4, r3

	if (M2M_SUCCESS != nmi_spi_read(&rsp[0], len)) {
    278e:	b2a1      	uxth	r1, r4
    2790:	a807      	add	r0, sp, #28
    2792:	4b36      	ldr	r3, [pc, #216]	; (286c <nm_spi_write_block+0x298>)
    2794:	4798      	blx	r3
    2796:	2800      	cmp	r0, #0
    2798:	d0c9      	beq.n	272e <nm_spi_write_block+0x15a>
    279a:	e7bb      	b.n	2714 <nm_spi_write_block+0x140>
	/**
		Data RESP
	**/
	result = spi_data_rsp(cmd);
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed block data write...\n");
    279c:	22fa      	movs	r2, #250	; 0xfa
    279e:	0092      	lsls	r2, r2, #2
    27a0:	491e      	ldr	r1, [pc, #120]	; (281c <nm_spi_write_block+0x248>)
    27a2:	481f      	ldr	r0, [pc, #124]	; (2820 <nm_spi_write_block+0x24c>)
    27a4:	4b1f      	ldr	r3, [pc, #124]	; (2824 <nm_spi_write_block+0x250>)
    27a6:	4798      	blx	r3
    27a8:	482f      	ldr	r0, [pc, #188]	; (2868 <nm_spi_write_block+0x294>)
    27aa:	4b26      	ldr	r3, [pc, #152]	; (2844 <nm_spi_write_block+0x270>)
    27ac:	4798      	blx	r3
    27ae:	200d      	movs	r0, #13
    27b0:	4b1e      	ldr	r3, [pc, #120]	; (282c <nm_spi_write_block+0x258>)
    27b2:	4798      	blx	r3
    27b4:	e001      	b.n	27ba <nm_spi_write_block+0x1e6>
{
	sint8 s8Ret;

	s8Ret = nm_spi_write(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    27b6:	2000      	movs	r0, #0
    27b8:	e025      	b.n	2806 <nm_spi_write_block+0x232>
	}
	
_FAIL_:
	if(result != N_OK)
	{
		nm_bsp_sleep(1);
    27ba:	2001      	movs	r0, #1
    27bc:	4c2c      	ldr	r4, [pc, #176]	; (2870 <nm_spi_write_block+0x29c>)
    27be:	47a0      	blx	r4
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    27c0:	9600      	str	r6, [sp, #0]
    27c2:	0033      	movs	r3, r6
    27c4:	0032      	movs	r2, r6
    27c6:	0031      	movs	r1, r6
    27c8:	20cf      	movs	r0, #207	; 0xcf
    27ca:	4d12      	ldr	r5, [pc, #72]	; (2814 <nm_spi_write_block+0x240>)
    27cc:	47a8      	blx	r5
		spi_cmd_rsp(CMD_RESET);
    27ce:	20cf      	movs	r0, #207	; 0xcf
    27d0:	4b17      	ldr	r3, [pc, #92]	; (2830 <nm_spi_write_block+0x25c>)
    27d2:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx %d\n",retry,addr,size);
    27d4:	4a27      	ldr	r2, [pc, #156]	; (2874 <nm_spi_write_block+0x2a0>)
    27d6:	4911      	ldr	r1, [pc, #68]	; (281c <nm_spi_write_block+0x248>)
    27d8:	4811      	ldr	r0, [pc, #68]	; (2820 <nm_spi_write_block+0x24c>)
    27da:	4d12      	ldr	r5, [pc, #72]	; (2824 <nm_spi_write_block+0x250>)
    27dc:	47a8      	blx	r5
    27de:	9b03      	ldr	r3, [sp, #12]
    27e0:	9a04      	ldr	r2, [sp, #16]
    27e2:	4649      	mov	r1, r9
    27e4:	4824      	ldr	r0, [pc, #144]	; (2878 <nm_spi_write_block+0x2a4>)
    27e6:	47a8      	blx	r5
    27e8:	200d      	movs	r0, #13
    27ea:	4b10      	ldr	r3, [pc, #64]	; (282c <nm_spi_write_block+0x258>)
    27ec:	4798      	blx	r3
		nm_bsp_sleep(1);
    27ee:	2001      	movs	r0, #1
    27f0:	47a0      	blx	r4
    27f2:	2301      	movs	r3, #1
    27f4:	425b      	negs	r3, r3
    27f6:	469c      	mov	ip, r3
    27f8:	44e1      	add	r9, ip
		retry--;
		if(retry) goto _RETRY_;
    27fa:	464b      	mov	r3, r9
    27fc:	2b00      	cmp	r3, #0
    27fe:	d000      	beq.n	2802 <nm_spi_write_block+0x22e>
    2800:	e6f7      	b.n	25f2 <nm_spi_write_block+0x1e>
	sint8 s8Ret;

	s8Ret = nm_spi_write(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
	else s8Ret = M2M_ERR_BUS_FAIL;
    2802:	2006      	movs	r0, #6
    2804:	4240      	negs	r0, r0

	return s8Ret;
}
    2806:	b009      	add	sp, #36	; 0x24
    2808:	bc3c      	pop	{r2, r3, r4, r5}
    280a:	4690      	mov	r8, r2
    280c:	4699      	mov	r9, r3
    280e:	46a2      	mov	sl, r4
    2810:	46ab      	mov	fp, r5
    2812:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2814:	00001ca9 	.word	0x00001ca9
    2818:	000003ca 	.word	0x000003ca
    281c:	0000c1a8 	.word	0x0000c1a8
    2820:	0000b8b4 	.word	0x0000b8b4
    2824:	0000a771 	.word	0x0000a771
    2828:	0000c578 	.word	0x0000c578
    282c:	0000a7a5 	.word	0x0000a7a5
    2830:	00001e4d 	.word	0x00001e4d
    2834:	0000c5a8 	.word	0x0000c5a8
    2838:	00001c89 	.word	0x00001c89
    283c:	0000c170 	.word	0x0000c170
    2840:	0000c5e0 	.word	0x0000c5e0
    2844:	0000a891 	.word	0x0000a891
    2848:	00000359 	.word	0x00000359
    284c:	0000c618 	.word	0x0000c618
    2850:	20000160 	.word	0x20000160
    2854:	00000363 	.word	0x00000363
    2858:	0000c64c 	.word	0x0000c64c
    285c:	0000c198 	.word	0x0000c198
    2860:	0000c684 	.word	0x0000c684
    2864:	0000c6a4 	.word	0x0000c6a4
    2868:	0000c6d4 	.word	0x0000c6d4
    286c:	00001e2d 	.word	0x00001e2d
    2870:	00000129 	.word	0x00000129
    2874:	000003f2 	.word	0x000003f2
    2878:	0000c55c 	.word	0x0000c55c

0000287c <Socket_ReadSocketData>:
Date
		17 July 2012
*********************************************************************/
NMI_API void Socket_ReadSocketData(SOCKET sock, tstrSocketRecvMsg *pstrRecv,uint8 u8SocketMsg,
								  uint32 u32StartAddress,uint16 u16ReadCount)
{
    287c:	b5f0      	push	{r4, r5, r6, r7, lr}
    287e:	465f      	mov	r7, fp
    2880:	4656      	mov	r6, sl
    2882:	464d      	mov	r5, r9
    2884:	4644      	mov	r4, r8
    2886:	b4f0      	push	{r4, r5, r6, r7}
    2888:	b085      	sub	sp, #20
    288a:	9001      	str	r0, [sp, #4]
    288c:	000e      	movs	r6, r1
    288e:	9202      	str	r2, [sp, #8]
    2890:	001d      	movs	r5, r3
    2892:	ab0e      	add	r3, sp, #56	; 0x38
    2894:	881c      	ldrh	r4, [r3, #0]
	if((u16ReadCount > 0) && (gastrSockets[sock].pu8UserBuffer != NULL) && (gastrSockets[sock].u16UserBufferSize > 0) && (gastrSockets[sock].bIsUsed == 1))
    2896:	2c00      	cmp	r4, #0
    2898:	d062      	beq.n	2960 <Socket_ReadSocketData+0xe4>
    289a:	0103      	lsls	r3, r0, #4
    289c:	4934      	ldr	r1, [pc, #208]	; (2970 <Socket_ReadSocketData+0xf4>)
    289e:	585b      	ldr	r3, [r3, r1]
    28a0:	2b00      	cmp	r3, #0
    28a2:	d05d      	beq.n	2960 <Socket_ReadSocketData+0xe4>
    28a4:	0103      	lsls	r3, r0, #4
    28a6:	18cb      	adds	r3, r1, r3
    28a8:	889b      	ldrh	r3, [r3, #4]
    28aa:	b29b      	uxth	r3, r3
    28ac:	2b00      	cmp	r3, #0
    28ae:	d057      	beq.n	2960 <Socket_ReadSocketData+0xe4>
    28b0:	0103      	lsls	r3, r0, #4
    28b2:	18cb      	adds	r3, r1, r3
    28b4:	7a9b      	ldrb	r3, [r3, #10]
    28b6:	2b01      	cmp	r3, #1
    28b8:	d152      	bne.n	2960 <Socket_ReadSocketData+0xe4>
		uint32	u32Address = u32StartAddress;
		uint16	u16Read;
		sint16	s16Diff;
		uint8	u8SetRxDone;

		pstrRecv->u16RemainingSize = u16ReadCount;
    28ba:	80f4      	strh	r4, [r6, #6]
		do
		{
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
    28bc:	0107      	lsls	r7, r0, #4
    28be:	468b      	mov	fp, r1
    28c0:	44bb      	add	fp, r7
					gpfAppSocketCb(sock,u8SocketMsg, pstrRecv);

				u16ReadCount -= u16Read;
				u32Address += u16Read;

				if((!gastrSockets[sock].bIsUsed) && (u16ReadCount))
    28c2:	465b      	mov	r3, fp
    28c4:	220a      	movs	r2, #10
    28c6:	4690      	mov	r8, r2
    28c8:	44d8      	add	r8, fp
    28ca:	46ba      	mov	sl, r7
    28cc:	9500      	str	r5, [sp, #0]
    28ce:	9303      	str	r3, [sp, #12]
		pstrRecv->u16RemainingSize = u16ReadCount;
		do
		{
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
    28d0:	465b      	mov	r3, fp
    28d2:	889b      	ldrh	r3, [r3, #4]
			if(s16Diff > 0)
    28d4:	1ae3      	subs	r3, r4, r3
    28d6:	b21b      	sxth	r3, r3
    28d8:	2b00      	cmp	r3, #0
    28da:	dd04      	ble.n	28e6 <Socket_ReadSocketData+0x6a>
			{
				u8SetRxDone = 0;
				u16Read		= gastrSockets[sock].u16UserBufferSize;
    28dc:	9b03      	ldr	r3, [sp, #12]
    28de:	889d      	ldrh	r5, [r3, #4]
    28e0:	b2ad      	uxth	r5, r5
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
			if(s16Diff > 0)
			{
				u8SetRxDone = 0;
    28e2:	2300      	movs	r3, #0
    28e4:	e001      	b.n	28ea <Socket_ReadSocketData+0x6e>
    28e6:	0025      	movs	r5, r4
		uint8	u8SetRxDone;

		pstrRecv->u16RemainingSize = u16ReadCount;
		do
		{
			u8SetRxDone = 1;
    28e8:	2301      	movs	r3, #1
			{
				u8SetRxDone = 0;
				u16Read		= gastrSockets[sock].u16UserBufferSize;
			}
			
			if(hif_receive(u32Address, gastrSockets[sock].pu8UserBuffer, u16Read, u8SetRxDone) == M2M_SUCCESS)
    28ea:	4a21      	ldr	r2, [pc, #132]	; (2970 <Socket_ReadSocketData+0xf4>)
    28ec:	4651      	mov	r1, sl
    28ee:	5889      	ldr	r1, [r1, r2]
    28f0:	002a      	movs	r2, r5
    28f2:	9800      	ldr	r0, [sp, #0]
    28f4:	4f1f      	ldr	r7, [pc, #124]	; (2974 <Socket_ReadSocketData+0xf8>)
    28f6:	47b8      	blx	r7
    28f8:	2800      	cmp	r0, #0
    28fa:	d125      	bne.n	2948 <Socket_ReadSocketData+0xcc>
			{
				pstrRecv->pu8Buffer			= gastrSockets[sock].pu8UserBuffer;
    28fc:	4b1c      	ldr	r3, [pc, #112]	; (2970 <Socket_ReadSocketData+0xf4>)
    28fe:	4652      	mov	r2, sl
    2900:	58d3      	ldr	r3, [r2, r3]
    2902:	6033      	str	r3, [r6, #0]
				pstrRecv->s16BufferSize		= u16Read;
    2904:	80b5      	strh	r5, [r6, #4]
				pstrRecv->u16RemainingSize	-= u16Read;
    2906:	88f3      	ldrh	r3, [r6, #6]
    2908:	1b5b      	subs	r3, r3, r5
    290a:	80f3      	strh	r3, [r6, #6]

				if (gpfAppSocketCb)
    290c:	4b1a      	ldr	r3, [pc, #104]	; (2978 <Socket_ReadSocketData+0xfc>)
    290e:	681b      	ldr	r3, [r3, #0]
    2910:	2b00      	cmp	r3, #0
    2912:	d005      	beq.n	2920 <Socket_ReadSocketData+0xa4>
					gpfAppSocketCb(sock,u8SocketMsg, pstrRecv);
    2914:	4b18      	ldr	r3, [pc, #96]	; (2978 <Socket_ReadSocketData+0xfc>)
    2916:	681b      	ldr	r3, [r3, #0]
    2918:	0032      	movs	r2, r6
    291a:	9902      	ldr	r1, [sp, #8]
    291c:	9801      	ldr	r0, [sp, #4]
    291e:	4798      	blx	r3

				u16ReadCount -= u16Read;
    2920:	1b64      	subs	r4, r4, r5
    2922:	b2a4      	uxth	r4, r4
				u32Address += u16Read;
    2924:	9b00      	ldr	r3, [sp, #0]
    2926:	469c      	mov	ip, r3
    2928:	44ac      	add	ip, r5
    292a:	4663      	mov	r3, ip
    292c:	9300      	str	r3, [sp, #0]

				if((!gastrSockets[sock].bIsUsed) && (u16ReadCount))
    292e:	4643      	mov	r3, r8
    2930:	781b      	ldrb	r3, [r3, #0]
    2932:	2b00      	cmp	r3, #0
    2934:	d112      	bne.n	295c <Socket_ReadSocketData+0xe0>
    2936:	2c00      	cmp	r4, #0
    2938:	d012      	beq.n	2960 <Socket_ReadSocketData+0xe4>
				{
					M2M_DBG("Application Closed Socket While Rx Is not Complete\n");
					if(hif_receive(0, NULL, 0, 1) == M2M_SUCCESS)
    293a:	3301      	adds	r3, #1
    293c:	2200      	movs	r2, #0
    293e:	2100      	movs	r1, #0
    2940:	2000      	movs	r0, #0
    2942:	4c0c      	ldr	r4, [pc, #48]	; (2974 <Socket_ReadSocketData+0xf8>)
    2944:	47a0      	blx	r4
    2946:	e00b      	b.n	2960 <Socket_ReadSocketData+0xe4>
					break;
				}
			}
			else
			{
				M2M_INFO("(ERRR)Current <%d>\n", u16ReadCount);
    2948:	480c      	ldr	r0, [pc, #48]	; (297c <Socket_ReadSocketData+0x100>)
    294a:	4d0d      	ldr	r5, [pc, #52]	; (2980 <Socket_ReadSocketData+0x104>)
    294c:	47a8      	blx	r5
    294e:	0021      	movs	r1, r4
    2950:	480c      	ldr	r0, [pc, #48]	; (2984 <Socket_ReadSocketData+0x108>)
    2952:	47a8      	blx	r5
    2954:	200d      	movs	r0, #13
    2956:	4b0c      	ldr	r3, [pc, #48]	; (2988 <Socket_ReadSocketData+0x10c>)
    2958:	4798      	blx	r3
				break;
    295a:	e001      	b.n	2960 <Socket_ReadSocketData+0xe4>
			}
		}while(u16ReadCount != 0);
    295c:	2c00      	cmp	r4, #0
    295e:	d1b7      	bne.n	28d0 <Socket_ReadSocketData+0x54>
	}
}
    2960:	b005      	add	sp, #20
    2962:	bc3c      	pop	{r2, r3, r4, r5}
    2964:	4690      	mov	r8, r2
    2966:	4699      	mov	r9, r3
    2968:	46a2      	mov	sl, r4
    296a:	46ab      	mov	fp, r5
    296c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    296e:	46c0      	nop			; (mov r8, r8)
    2970:	20000d3c 	.word	0x20000d3c
    2974:	00000c4d 	.word	0x00000c4d
    2978:	20000dec 	.word	0x20000dec
    297c:	0000b928 	.word	0x0000b928
    2980:	0000a771 	.word	0x0000a771
    2984:	0000c834 	.word	0x0000c834
    2988:	0000a7a5 	.word	0x0000a7a5

0000298c <m2m_ip_cb>:

Date
		17 July 2012
*********************************************************************/
static void m2m_ip_cb(uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
{	
    298c:	b5f0      	push	{r4, r5, r6, r7, lr}
    298e:	464f      	mov	r7, r9
    2990:	4646      	mov	r6, r8
    2992:	b4c0      	push	{r6, r7}
    2994:	b09b      	sub	sp, #108	; 0x6c
    2996:	000d      	movs	r5, r1
    2998:	0014      	movs	r4, r2
	if((u8OpCode == SOCKET_CMD_BIND) || (u8OpCode == SOCKET_CMD_SSL_BIND))
    299a:	2841      	cmp	r0, #65	; 0x41
    299c:	d001      	beq.n	29a2 <m2m_ip_cb+0x16>
    299e:	2854      	cmp	r0, #84	; 0x54
    29a0:	d11a      	bne.n	29d8 <m2m_ip_cb+0x4c>
	{
		tstrBindReply		strBindReply;
		tstrSocketBindMsg	strBind;

		if(hif_receive(u32Address, (uint8*)&strBindReply, sizeof(tstrBindReply), 0) == M2M_SUCCESS)
    29a2:	2300      	movs	r3, #0
    29a4:	2204      	movs	r2, #4
    29a6:	a909      	add	r1, sp, #36	; 0x24
    29a8:	0020      	movs	r0, r4
    29aa:	4caf      	ldr	r4, [pc, #700]	; (2c68 <m2m_ip_cb+0x2dc>)
    29ac:	47a0      	blx	r4
    29ae:	2800      	cmp	r0, #0
    29b0:	d000      	beq.n	29b4 <m2m_ip_cb+0x28>
    29b2:	e153      	b.n	2c5c <m2m_ip_cb+0x2d0>
		{
			strBind.status = strBindReply.s8Status;
    29b4:	ab09      	add	r3, sp, #36	; 0x24
    29b6:	785a      	ldrb	r2, [r3, #1]
    29b8:	ab05      	add	r3, sp, #20
    29ba:	701a      	strb	r2, [r3, #0]
			if(gpfAppSocketCb)
    29bc:	4bab      	ldr	r3, [pc, #684]	; (2c6c <m2m_ip_cb+0x2e0>)
    29be:	681b      	ldr	r3, [r3, #0]
    29c0:	2b00      	cmp	r3, #0
    29c2:	d100      	bne.n	29c6 <m2m_ip_cb+0x3a>
    29c4:	e14a      	b.n	2c5c <m2m_ip_cb+0x2d0>
				gpfAppSocketCb(strBindReply.sock,SOCKET_MSG_BIND,&strBind);
    29c6:	4ba9      	ldr	r3, [pc, #676]	; (2c6c <m2m_ip_cb+0x2e0>)
    29c8:	681b      	ldr	r3, [r3, #0]
    29ca:	aa09      	add	r2, sp, #36	; 0x24
    29cc:	2000      	movs	r0, #0
    29ce:	5610      	ldrsb	r0, [r2, r0]
    29d0:	aa05      	add	r2, sp, #20
    29d2:	2101      	movs	r1, #1
    29d4:	4798      	blx	r3
		17 July 2012
*********************************************************************/
static void m2m_ip_cb(uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
{	
	if((u8OpCode == SOCKET_CMD_BIND) || (u8OpCode == SOCKET_CMD_SSL_BIND))
	{
    29d6:	e141      	b.n	2c5c <m2m_ip_cb+0x2d0>
			strBind.status = strBindReply.s8Status;
			if(gpfAppSocketCb)
				gpfAppSocketCb(strBindReply.sock,SOCKET_MSG_BIND,&strBind);
		}
	}
	else if(u8OpCode == SOCKET_CMD_LISTEN)
    29d8:	2842      	cmp	r0, #66	; 0x42
    29da:	d11a      	bne.n	2a12 <m2m_ip_cb+0x86>
	{
		tstrListenReply			strListenReply;
		tstrSocketListenMsg		strListen;
		if(hif_receive(u32Address, (uint8*)&strListenReply, sizeof(tstrListenReply), 0) == M2M_SUCCESS)
    29dc:	2300      	movs	r3, #0
    29de:	2204      	movs	r2, #4
    29e0:	a909      	add	r1, sp, #36	; 0x24
    29e2:	0020      	movs	r0, r4
    29e4:	4ca0      	ldr	r4, [pc, #640]	; (2c68 <m2m_ip_cb+0x2dc>)
    29e6:	47a0      	blx	r4
    29e8:	2800      	cmp	r0, #0
    29ea:	d000      	beq.n	29ee <m2m_ip_cb+0x62>
    29ec:	e136      	b.n	2c5c <m2m_ip_cb+0x2d0>
		{
			strListen.status = strListenReply.s8Status;
    29ee:	ab09      	add	r3, sp, #36	; 0x24
    29f0:	785a      	ldrb	r2, [r3, #1]
    29f2:	ab05      	add	r3, sp, #20
    29f4:	701a      	strb	r2, [r3, #0]
			if(gpfAppSocketCb)
    29f6:	4b9d      	ldr	r3, [pc, #628]	; (2c6c <m2m_ip_cb+0x2e0>)
    29f8:	681b      	ldr	r3, [r3, #0]
    29fa:	2b00      	cmp	r3, #0
    29fc:	d100      	bne.n	2a00 <m2m_ip_cb+0x74>
    29fe:	e12d      	b.n	2c5c <m2m_ip_cb+0x2d0>
				gpfAppSocketCb(strListenReply.sock,SOCKET_MSG_LISTEN, &strListen);
    2a00:	4b9a      	ldr	r3, [pc, #616]	; (2c6c <m2m_ip_cb+0x2e0>)
    2a02:	681b      	ldr	r3, [r3, #0]
    2a04:	aa09      	add	r2, sp, #36	; 0x24
    2a06:	2000      	movs	r0, #0
    2a08:	5610      	ldrsb	r0, [r2, r0]
    2a0a:	aa05      	add	r2, sp, #20
    2a0c:	2102      	movs	r1, #2
    2a0e:	4798      	blx	r3
    2a10:	e124      	b.n	2c5c <m2m_ip_cb+0x2d0>
		}
	}
	else if(u8OpCode == SOCKET_CMD_ACCEPT)
    2a12:	2843      	cmp	r0, #67	; 0x43
    2a14:	d149      	bne.n	2aaa <m2m_ip_cb+0x11e>
	{
		tstrAcceptReply			strAcceptReply;
		tstrSocketAcceptMsg		strAccept;
		if(hif_receive(u32Address, (uint8*)&strAcceptReply, sizeof(tstrAcceptReply), 0) == M2M_SUCCESS)
    2a16:	2300      	movs	r3, #0
    2a18:	220c      	movs	r2, #12
    2a1a:	a905      	add	r1, sp, #20
    2a1c:	0020      	movs	r0, r4
    2a1e:	4c92      	ldr	r4, [pc, #584]	; (2c68 <m2m_ip_cb+0x2dc>)
    2a20:	47a0      	blx	r4
    2a22:	2800      	cmp	r0, #0
    2a24:	d000      	beq.n	2a28 <m2m_ip_cb+0x9c>
    2a26:	e119      	b.n	2c5c <m2m_ip_cb+0x2d0>
		{
			if(strAcceptReply.sConnectedSock >= 0)
    2a28:	ab05      	add	r3, sp, #20
    2a2a:	2209      	movs	r2, #9
    2a2c:	569a      	ldrsb	r2, [r3, r2]
    2a2e:	2a00      	cmp	r2, #0
    2a30:	db24      	blt.n	2a7c <m2m_ip_cb+0xf0>
			{
				gastrSockets[strAcceptReply.sConnectedSock].u8SSLFlags 		= gastrSockets[strAcceptReply.sListenSock].u8SSLFlags;
    2a32:	0018      	movs	r0, r3
    2a34:	2108      	movs	r1, #8
    2a36:	5659      	ldrsb	r1, [r3, r1]
    2a38:	4c8d      	ldr	r4, [pc, #564]	; (2c70 <m2m_ip_cb+0x2e4>)
    2a3a:	0109      	lsls	r1, r1, #4
    2a3c:	1861      	adds	r1, r4, r1
    2a3e:	7ac9      	ldrb	r1, [r1, #11]
    2a40:	b2c9      	uxtb	r1, r1
    2a42:	0113      	lsls	r3, r2, #4
    2a44:	18e3      	adds	r3, r4, r3
    2a46:	72d9      	strb	r1, [r3, #11]
				gastrSockets[strAcceptReply.sConnectedSock].bIsUsed 		= 1;
    2a48:	2101      	movs	r1, #1
    2a4a:	7299      	strb	r1, [r3, #10]
				gastrSockets[strAcceptReply.sConnectedSock].u16DataOffset 	= strAcceptReply.u16AppDataOffset - M2M_HIF_HDR_OFFSET;
    2a4c:	8941      	ldrh	r1, [r0, #10]
    2a4e:	3908      	subs	r1, #8
    2a50:	b289      	uxth	r1, r1
    2a52:	8119      	strh	r1, [r3, #8]

				/* The session ID is used to distinguish different socket connections
					by comparing the assigned session ID to the one reported by the firmware*/
				++gu16SessionID;
    2a54:	4987      	ldr	r1, [pc, #540]	; (2c74 <m2m_ip_cb+0x2e8>)
    2a56:	880b      	ldrh	r3, [r1, #0]
    2a58:	3301      	adds	r3, #1
    2a5a:	b29b      	uxth	r3, r3
    2a5c:	800b      	strh	r3, [r1, #0]
				if(gu16SessionID == 0)
    2a5e:	880b      	ldrh	r3, [r1, #0]
    2a60:	b29b      	uxth	r3, r3
    2a62:	2b00      	cmp	r3, #0
    2a64:	d103      	bne.n	2a6e <m2m_ip_cb+0xe2>
					++gu16SessionID;
    2a66:	880b      	ldrh	r3, [r1, #0]
    2a68:	3301      	adds	r3, #1
    2a6a:	b29b      	uxth	r3, r3
    2a6c:	800b      	strh	r3, [r1, #0]

				gastrSockets[strAcceptReply.sConnectedSock].u16SessionID = gu16SessionID;
    2a6e:	4b81      	ldr	r3, [pc, #516]	; (2c74 <m2m_ip_cb+0x2e8>)
    2a70:	8819      	ldrh	r1, [r3, #0]
    2a72:	b289      	uxth	r1, r1
    2a74:	0113      	lsls	r3, r2, #4
    2a76:	487e      	ldr	r0, [pc, #504]	; (2c70 <m2m_ip_cb+0x2e4>)
    2a78:	18c3      	adds	r3, r0, r3
    2a7a:	80d9      	strh	r1, [r3, #6]
				M2M_DBG("Socket %d session ID = %d\r\n",strAcceptReply.sConnectedSock , gu16SessionID );		
			}
			strAccept.sock = strAcceptReply.sConnectedSock;
    2a7c:	ab09      	add	r3, sp, #36	; 0x24
    2a7e:	701a      	strb	r2, [r3, #0]
			strAccept.strAddr.sin_family		= AF_INET;
    2a80:	2202      	movs	r2, #2
    2a82:	809a      	strh	r2, [r3, #4]
			strAccept.strAddr.sin_port = strAcceptReply.strAddr.u16Port;
    2a84:	aa05      	add	r2, sp, #20
    2a86:	8851      	ldrh	r1, [r2, #2]
    2a88:	80d9      	strh	r1, [r3, #6]
			strAccept.strAddr.sin_addr.s_addr = strAcceptReply.strAddr.u32IPAddr;
    2a8a:	9a06      	ldr	r2, [sp, #24]
    2a8c:	920b      	str	r2, [sp, #44]	; 0x2c
			if(gpfAppSocketCb)
    2a8e:	4b77      	ldr	r3, [pc, #476]	; (2c6c <m2m_ip_cb+0x2e0>)
    2a90:	681b      	ldr	r3, [r3, #0]
    2a92:	2b00      	cmp	r3, #0
    2a94:	d100      	bne.n	2a98 <m2m_ip_cb+0x10c>
    2a96:	e0e1      	b.n	2c5c <m2m_ip_cb+0x2d0>
				gpfAppSocketCb(strAcceptReply.sListenSock, SOCKET_MSG_ACCEPT, &strAccept);
    2a98:	4b74      	ldr	r3, [pc, #464]	; (2c6c <m2m_ip_cb+0x2e0>)
    2a9a:	681b      	ldr	r3, [r3, #0]
    2a9c:	aa05      	add	r2, sp, #20
    2a9e:	2008      	movs	r0, #8
    2aa0:	5610      	ldrsb	r0, [r2, r0]
    2aa2:	aa09      	add	r2, sp, #36	; 0x24
    2aa4:	2104      	movs	r1, #4
    2aa6:	4798      	blx	r3
    2aa8:	e0d8      	b.n	2c5c <m2m_ip_cb+0x2d0>
		}
	}
	else if((u8OpCode == SOCKET_CMD_CONNECT) || (u8OpCode == SOCKET_CMD_SSL_CONNECT))
    2aaa:	2844      	cmp	r0, #68	; 0x44
    2aac:	d001      	beq.n	2ab2 <m2m_ip_cb+0x126>
    2aae:	284b      	cmp	r0, #75	; 0x4b
    2ab0:	d125      	bne.n	2afe <m2m_ip_cb+0x172>
	{
		tstrConnectReply		strConnectReply;
		tstrSocketConnectMsg	strConnMsg;
		if(hif_receive(u32Address, (uint8*)&strConnectReply, sizeof(tstrConnectReply), 0) == M2M_SUCCESS)
    2ab2:	2300      	movs	r3, #0
    2ab4:	2204      	movs	r2, #4
    2ab6:	a909      	add	r1, sp, #36	; 0x24
    2ab8:	0020      	movs	r0, r4
    2aba:	4c6b      	ldr	r4, [pc, #428]	; (2c68 <m2m_ip_cb+0x2dc>)
    2abc:	47a0      	blx	r4
    2abe:	2800      	cmp	r0, #0
    2ac0:	d000      	beq.n	2ac4 <m2m_ip_cb+0x138>
    2ac2:	e0cb      	b.n	2c5c <m2m_ip_cb+0x2d0>
		{
			strConnMsg.sock		= strConnectReply.sock;
    2ac4:	ab09      	add	r3, sp, #36	; 0x24
    2ac6:	2000      	movs	r0, #0
    2ac8:	5618      	ldrsb	r0, [r3, r0]
    2aca:	aa05      	add	r2, sp, #20
    2acc:	7010      	strb	r0, [r2, #0]
			strConnMsg.s8Error	= strConnectReply.s8Error;
    2ace:	785b      	ldrb	r3, [r3, #1]
    2ad0:	b25b      	sxtb	r3, r3
    2ad2:	7053      	strb	r3, [r2, #1]
			if(strConnectReply.s8Error == SOCK_ERR_NO_ERROR)
    2ad4:	2b00      	cmp	r3, #0
    2ad6:	d107      	bne.n	2ae8 <m2m_ip_cb+0x15c>
			{
				gastrSockets[strConnectReply.sock].u16DataOffset = strConnectReply.u16AppDataOffset - M2M_HIF_HDR_OFFSET;
    2ad8:	ab09      	add	r3, sp, #36	; 0x24
    2ada:	885a      	ldrh	r2, [r3, #2]
    2adc:	3a08      	subs	r2, #8
    2ade:	b292      	uxth	r2, r2
    2ae0:	0103      	lsls	r3, r0, #4
    2ae2:	4963      	ldr	r1, [pc, #396]	; (2c70 <m2m_ip_cb+0x2e4>)
    2ae4:	18cb      	adds	r3, r1, r3
    2ae6:	811a      	strh	r2, [r3, #8]
			}
			if(gpfAppSocketCb)
    2ae8:	4b60      	ldr	r3, [pc, #384]	; (2c6c <m2m_ip_cb+0x2e0>)
    2aea:	681b      	ldr	r3, [r3, #0]
    2aec:	2b00      	cmp	r3, #0
    2aee:	d100      	bne.n	2af2 <m2m_ip_cb+0x166>
    2af0:	e0b4      	b.n	2c5c <m2m_ip_cb+0x2d0>
				gpfAppSocketCb(strConnectReply.sock,SOCKET_MSG_CONNECT, &strConnMsg);
    2af2:	4b5e      	ldr	r3, [pc, #376]	; (2c6c <m2m_ip_cb+0x2e0>)
    2af4:	681b      	ldr	r3, [r3, #0]
    2af6:	aa05      	add	r2, sp, #20
    2af8:	2105      	movs	r1, #5
    2afa:	4798      	blx	r3
			if(gpfAppSocketCb)
				gpfAppSocketCb(strAcceptReply.sListenSock, SOCKET_MSG_ACCEPT, &strAccept);
		}
	}
	else if((u8OpCode == SOCKET_CMD_CONNECT) || (u8OpCode == SOCKET_CMD_SSL_CONNECT))
	{
    2afc:	e0ae      	b.n	2c5c <m2m_ip_cb+0x2d0>
			}
			if(gpfAppSocketCb)
				gpfAppSocketCb(strConnectReply.sock,SOCKET_MSG_CONNECT, &strConnMsg);
		}
	}
	else if(u8OpCode == SOCKET_CMD_DNS_RESOLVE)
    2afe:	284a      	cmp	r0, #74	; 0x4a
    2b00:	d115      	bne.n	2b2e <m2m_ip_cb+0x1a2>
	{
		tstrDnsReply	strDnsReply;
		if(hif_receive(u32Address, (uint8*)&strDnsReply, sizeof(tstrDnsReply), 0) == M2M_SUCCESS)
    2b02:	2300      	movs	r3, #0
    2b04:	2244      	movs	r2, #68	; 0x44
    2b06:	a909      	add	r1, sp, #36	; 0x24
    2b08:	0020      	movs	r0, r4
    2b0a:	4c57      	ldr	r4, [pc, #348]	; (2c68 <m2m_ip_cb+0x2dc>)
    2b0c:	47a0      	blx	r4
    2b0e:	2800      	cmp	r0, #0
    2b10:	d000      	beq.n	2b14 <m2m_ip_cb+0x188>
    2b12:	e0a3      	b.n	2c5c <m2m_ip_cb+0x2d0>
		{
			if(gpfAppResolveCb)
    2b14:	4b58      	ldr	r3, [pc, #352]	; (2c78 <m2m_ip_cb+0x2ec>)
    2b16:	681b      	ldr	r3, [r3, #0]
    2b18:	2b00      	cmp	r3, #0
    2b1a:	d100      	bne.n	2b1e <m2m_ip_cb+0x192>
    2b1c:	e09e      	b.n	2c5c <m2m_ip_cb+0x2d0>
				gpfAppResolveCb((uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
    2b1e:	4b56      	ldr	r3, [pc, #344]	; (2c78 <m2m_ip_cb+0x2ec>)
    2b20:	681b      	ldr	r3, [r3, #0]
    2b22:	9a19      	ldr	r2, [sp, #100]	; 0x64
    2b24:	9203      	str	r2, [sp, #12]
    2b26:	0011      	movs	r1, r2
    2b28:	a809      	add	r0, sp, #36	; 0x24
    2b2a:	4798      	blx	r3
    2b2c:	e096      	b.n	2c5c <m2m_ip_cb+0x2d0>
		}
	}
	else if((u8OpCode == SOCKET_CMD_RECV) || (u8OpCode == SOCKET_CMD_RECVFROM) || (u8OpCode == SOCKET_CMD_SSL_RECV))
    2b2e:	2846      	cmp	r0, #70	; 0x46
    2b30:	d005      	beq.n	2b3e <m2m_ip_cb+0x1b2>
    2b32:	2848      	cmp	r0, #72	; 0x48
    2b34:	d005      	beq.n	2b42 <m2m_ip_cb+0x1b6>
		SOCKET				sock;
		sint16				s16RecvStatus;
		tstrRecvReply		strRecvReply;
		uint16				u16ReadSize;
		tstrSocketRecvMsg	strRecvMsg;
		uint8				u8CallbackMsgID = SOCKET_MSG_RECV;
    2b36:	2606      	movs	r6, #6
		{
			if(gpfAppResolveCb)
				gpfAppResolveCb((uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
		}
	}
	else if((u8OpCode == SOCKET_CMD_RECV) || (u8OpCode == SOCKET_CMD_RECVFROM) || (u8OpCode == SOCKET_CMD_SSL_RECV))
    2b38:	284d      	cmp	r0, #77	; 0x4d
    2b3a:	d003      	beq.n	2b44 <m2m_ip_cb+0x1b8>
    2b3c:	e04c      	b.n	2bd8 <m2m_ip_cb+0x24c>
		SOCKET				sock;
		sint16				s16RecvStatus;
		tstrRecvReply		strRecvReply;
		uint16				u16ReadSize;
		tstrSocketRecvMsg	strRecvMsg;
		uint8				u8CallbackMsgID = SOCKET_MSG_RECV;
    2b3e:	2606      	movs	r6, #6
    2b40:	e000      	b.n	2b44 <m2m_ip_cb+0x1b8>
		uint16				u16DataOffset;

		if(u8OpCode == SOCKET_CMD_RECVFROM)
			u8CallbackMsgID = SOCKET_MSG_RECVFROM;
    2b42:	2609      	movs	r6, #9

		/* Read RECV REPLY data structure.
		*/
		u16ReadSize = sizeof(tstrRecvReply);
		if(hif_receive(u32Address, (uint8*)&strRecvReply, u16ReadSize, 0) == M2M_SUCCESS)
    2b44:	2300      	movs	r3, #0
    2b46:	2210      	movs	r2, #16
    2b48:	a905      	add	r1, sp, #20
    2b4a:	0020      	movs	r0, r4
    2b4c:	4f46      	ldr	r7, [pc, #280]	; (2c68 <m2m_ip_cb+0x2dc>)
    2b4e:	47b8      	blx	r7
    2b50:	2800      	cmp	r0, #0
    2b52:	d000      	beq.n	2b56 <m2m_ip_cb+0x1ca>
    2b54:	e082      	b.n	2c5c <m2m_ip_cb+0x2d0>
		{
			uint16 u16SessionID = 0;

			sock			= strRecvReply.sock;
    2b56:	aa05      	add	r2, sp, #20
    2b58:	200c      	movs	r0, #12
    2b5a:	5610      	ldrsb	r0, [r2, r0]
			u16SessionID = strRecvReply.u16SessionID;
    2b5c:	89d3      	ldrh	r3, [r2, #14]
    2b5e:	469c      	mov	ip, r3
			M2M_DBG("recv callback session ID = %d\r\n",u16SessionID);
			
			/* Reset the Socket RX Pending Flag.
			*/
			gastrSockets[sock].bIsRecvPending = 0;
    2b60:	0103      	lsls	r3, r0, #4
    2b62:	4943      	ldr	r1, [pc, #268]	; (2c70 <m2m_ip_cb+0x2e4>)
    2b64:	18c9      	adds	r1, r1, r3
    2b66:	2300      	movs	r3, #0
    2b68:	730b      	strb	r3, [r1, #12]

			s16RecvStatus	= NM_BSP_B_L_16(strRecvReply.s16RecvStatus);
    2b6a:	2708      	movs	r7, #8
    2b6c:	5fd3      	ldrsh	r3, [r2, r7]
    2b6e:	4698      	mov	r8, r3
			u16DataOffset	= NM_BSP_B_L_16(strRecvReply.u16DataOffset);
    2b70:	8953      	ldrh	r3, [r2, #10]
    2b72:	4699      	mov	r9, r3
			strRecvMsg.strRemoteAddr.sin_port 			= strRecvReply.strRemoteAddr.u16Port;
    2b74:	af09      	add	r7, sp, #36	; 0x24
    2b76:	8853      	ldrh	r3, [r2, #2]
    2b78:	817b      	strh	r3, [r7, #10]
			strRecvMsg.strRemoteAddr.sin_addr.s_addr 	= strRecvReply.strRemoteAddr.u32IPAddr;
    2b7a:	9b06      	ldr	r3, [sp, #24]
    2b7c:	930c      	str	r3, [sp, #48]	; 0x30

			if(u16SessionID == gastrSockets[sock].u16SessionID)
    2b7e:	88ca      	ldrh	r2, [r1, #6]
    2b80:	b292      	uxth	r2, r2
    2b82:	4594      	cmp	ip, r2
    2b84:	d11f      	bne.n	2bc6 <m2m_ip_cb+0x23a>
			{
				if((s16RecvStatus > 0) && (s16RecvStatus < u16BufferSize))
    2b86:	4643      	mov	r3, r8
    2b88:	2b00      	cmp	r3, #0
    2b8a:	dd0d      	ble.n	2ba8 <m2m_ip_cb+0x21c>
    2b8c:	45a8      	cmp	r8, r5
    2b8e:	da0b      	bge.n	2ba8 <m2m_ip_cb+0x21c>
					/* Read the Application data and deliver it to the application callback in
					the given application buffer. If the buffer is smaller than the received data,
					the data is passed to the application in chunks according to its buffer size.
					*/
					u16ReadSize = (uint16)s16RecvStatus;
					Socket_ReadSocketData(sock, &strRecvMsg, u8CallbackMsgID, u32Address, u16ReadSize);
    2b90:	0023      	movs	r3, r4
    2b92:	444b      	add	r3, r9
    2b94:	4642      	mov	r2, r8
    2b96:	4669      	mov	r1, sp
    2b98:	818a      	strh	r2, [r1, #12]
    2b9a:	898a      	ldrh	r2, [r1, #12]
    2b9c:	9200      	str	r2, [sp, #0]
    2b9e:	0032      	movs	r2, r6
    2ba0:	0039      	movs	r1, r7
    2ba2:	4c36      	ldr	r4, [pc, #216]	; (2c7c <m2m_ip_cb+0x2f0>)
    2ba4:	47a0      	blx	r4
    2ba6:	e059      	b.n	2c5c <m2m_ip_cb+0x2d0>
				}
				else
				{
					strRecvMsg.s16BufferSize	= s16RecvStatus;
    2ba8:	ab09      	add	r3, sp, #36	; 0x24
    2baa:	4642      	mov	r2, r8
    2bac:	809a      	strh	r2, [r3, #4]
					strRecvMsg.pu8Buffer		= NULL;
    2bae:	2300      	movs	r3, #0
    2bb0:	9309      	str	r3, [sp, #36]	; 0x24
					if(gpfAppSocketCb)
    2bb2:	4b2e      	ldr	r3, [pc, #184]	; (2c6c <m2m_ip_cb+0x2e0>)
    2bb4:	681b      	ldr	r3, [r3, #0]
    2bb6:	2b00      	cmp	r3, #0
    2bb8:	d050      	beq.n	2c5c <m2m_ip_cb+0x2d0>
						gpfAppSocketCb(sock,u8CallbackMsgID, &strRecvMsg);
    2bba:	4b2c      	ldr	r3, [pc, #176]	; (2c6c <m2m_ip_cb+0x2e0>)
    2bbc:	681b      	ldr	r3, [r3, #0]
    2bbe:	aa09      	add	r2, sp, #36	; 0x24
    2bc0:	0031      	movs	r1, r6
    2bc2:	4798      	blx	r3
    2bc4:	e04a      	b.n	2c5c <m2m_ip_cb+0x2d0>
				}
			}
			else
			{
				M2M_DBG("Discard recv callback %d %d \r\n",u16SessionID , gastrSockets[sock].u16SessionID);
				if(u16ReadSize < u16BufferSize)
    2bc6:	2d10      	cmp	r5, #16
    2bc8:	d948      	bls.n	2c5c <m2m_ip_cb+0x2d0>
				{
					if(hif_receive(0, NULL, 0, 1) == M2M_SUCCESS)
    2bca:	2301      	movs	r3, #1
    2bcc:	2200      	movs	r2, #0
    2bce:	2100      	movs	r1, #0
    2bd0:	2000      	movs	r0, #0
    2bd2:	4c25      	ldr	r4, [pc, #148]	; (2c68 <m2m_ip_cb+0x2dc>)
    2bd4:	47a0      	blx	r4
			if(gpfAppResolveCb)
				gpfAppResolveCb((uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
		}
	}
	else if((u8OpCode == SOCKET_CMD_RECV) || (u8OpCode == SOCKET_CMD_RECVFROM) || (u8OpCode == SOCKET_CMD_SSL_RECV))
	{
    2bd6:	e041      	b.n	2c5c <m2m_ip_cb+0x2d0>
						M2M_DBG("hif_receive Fail\n");
				}
			}
		}
	}
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
    2bd8:	2845      	cmp	r0, #69	; 0x45
    2bda:	d005      	beq.n	2be8 <m2m_ip_cb+0x25c>
    2bdc:	2847      	cmp	r0, #71	; 0x47
    2bde:	d005      	beq.n	2bec <m2m_ip_cb+0x260>
	{
		SOCKET			sock;
		sint16			s16Rcvd;
		tstrSendReply	strReply;
		uint8			u8CallbackMsgID = SOCKET_MSG_SEND;
    2be0:	2507      	movs	r5, #7
						M2M_DBG("hif_receive Fail\n");
				}
			}
		}
	}
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
    2be2:	284c      	cmp	r0, #76	; 0x4c
    2be4:	d003      	beq.n	2bee <m2m_ip_cb+0x262>
    2be6:	e022      	b.n	2c2e <m2m_ip_cb+0x2a2>
	{
		SOCKET			sock;
		sint16			s16Rcvd;
		tstrSendReply	strReply;
		uint8			u8CallbackMsgID = SOCKET_MSG_SEND;
    2be8:	2507      	movs	r5, #7
    2bea:	e000      	b.n	2bee <m2m_ip_cb+0x262>

		if(u8OpCode == SOCKET_CMD_SENDTO)
			u8CallbackMsgID = SOCKET_MSG_SENDTO;
    2bec:	2508      	movs	r5, #8

		if(hif_receive(u32Address, (uint8*)&strReply, sizeof(tstrSendReply), 0) == M2M_SUCCESS)
    2bee:	2300      	movs	r3, #0
    2bf0:	2208      	movs	r2, #8
    2bf2:	a909      	add	r1, sp, #36	; 0x24
    2bf4:	0020      	movs	r0, r4
    2bf6:	4c1c      	ldr	r4, [pc, #112]	; (2c68 <m2m_ip_cb+0x2dc>)
    2bf8:	47a0      	blx	r4
    2bfa:	2800      	cmp	r0, #0
    2bfc:	d12e      	bne.n	2c5c <m2m_ip_cb+0x2d0>
		{
			uint16 u16SessionID = 0;
			
			sock = strReply.sock;
    2bfe:	ab09      	add	r3, sp, #36	; 0x24
    2c00:	2000      	movs	r0, #0
    2c02:	5618      	ldrsb	r0, [r3, r0]
			u16SessionID = strReply.u16SessionID;
    2c04:	889a      	ldrh	r2, [r3, #4]
			M2M_DBG("send callback session ID = %d\r\n",u16SessionID);
			
			s16Rcvd = NM_BSP_B_L_16(strReply.s16SentBytes);
    2c06:	8859      	ldrh	r1, [r3, #2]
    2c08:	ab05      	add	r3, sp, #20
    2c0a:	8019      	strh	r1, [r3, #0]

			if(u16SessionID == gastrSockets[sock].u16SessionID)
    2c0c:	0103      	lsls	r3, r0, #4
    2c0e:	4918      	ldr	r1, [pc, #96]	; (2c70 <m2m_ip_cb+0x2e4>)
    2c10:	18cb      	adds	r3, r1, r3
    2c12:	88db      	ldrh	r3, [r3, #6]
    2c14:	b29b      	uxth	r3, r3
    2c16:	429a      	cmp	r2, r3
    2c18:	d120      	bne.n	2c5c <m2m_ip_cb+0x2d0>
			{
				if(gpfAppSocketCb)
    2c1a:	4b14      	ldr	r3, [pc, #80]	; (2c6c <m2m_ip_cb+0x2e0>)
    2c1c:	681b      	ldr	r3, [r3, #0]
    2c1e:	2b00      	cmp	r3, #0
    2c20:	d01c      	beq.n	2c5c <m2m_ip_cb+0x2d0>
					gpfAppSocketCb(sock,u8CallbackMsgID, &s16Rcvd);
    2c22:	4b12      	ldr	r3, [pc, #72]	; (2c6c <m2m_ip_cb+0x2e0>)
    2c24:	681b      	ldr	r3, [r3, #0]
    2c26:	aa05      	add	r2, sp, #20
    2c28:	0029      	movs	r1, r5
    2c2a:	4798      	blx	r3
				}
			}
		}
	}
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
	{
    2c2c:	e016      	b.n	2c5c <m2m_ip_cb+0x2d0>
			{
				M2M_DBG("Discard send callback %d %d \r\n",u16SessionID , gastrSockets[sock].u16SessionID);
			}
		}
	}
	else if(u8OpCode == SOCKET_CMD_PING)
    2c2e:	2852      	cmp	r0, #82	; 0x52
    2c30:	d114      	bne.n	2c5c <m2m_ip_cb+0x2d0>
	{
		tstrPingReply	strPingReply;
		if(hif_receive(u32Address, (uint8*)&strPingReply, sizeof(tstrPingReply), 1) == M2M_SUCCESS)
    2c32:	2301      	movs	r3, #1
    2c34:	2214      	movs	r2, #20
    2c36:	a909      	add	r1, sp, #36	; 0x24
    2c38:	0020      	movs	r0, r4
    2c3a:	4c0b      	ldr	r4, [pc, #44]	; (2c68 <m2m_ip_cb+0x2dc>)
    2c3c:	47a0      	blx	r4
    2c3e:	2800      	cmp	r0, #0
    2c40:	d10c      	bne.n	2c5c <m2m_ip_cb+0x2d0>
		{
			gfpPingCb = (void (*)(uint32 , uint32 , uint8))strPingReply.u32CmdPrivate;
    2c42:	4b0f      	ldr	r3, [pc, #60]	; (2c80 <m2m_ip_cb+0x2f4>)
    2c44:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    2c46:	601a      	str	r2, [r3, #0]
			if(gfpPingCb != NULL)
    2c48:	681b      	ldr	r3, [r3, #0]
    2c4a:	2b00      	cmp	r3, #0
    2c4c:	d006      	beq.n	2c5c <m2m_ip_cb+0x2d0>
			{
				gfpPingCb(strPingReply.u32IPAddr, strPingReply.u32RTT, strPingReply.u8ErrorCode);
    2c4e:	4b0c      	ldr	r3, [pc, #48]	; (2c80 <m2m_ip_cb+0x2f4>)
    2c50:	681c      	ldr	r4, [r3, #0]
    2c52:	ab09      	add	r3, sp, #36	; 0x24
    2c54:	7c1a      	ldrb	r2, [r3, #16]
    2c56:	990b      	ldr	r1, [sp, #44]	; 0x2c
    2c58:	9809      	ldr	r0, [sp, #36]	; 0x24
    2c5a:	47a0      	blx	r4
			}
		}
	}
}
    2c5c:	b01b      	add	sp, #108	; 0x6c
    2c5e:	bc0c      	pop	{r2, r3}
    2c60:	4690      	mov	r8, r2
    2c62:	4699      	mov	r9, r3
    2c64:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2c66:	46c0      	nop			; (mov r8, r8)
    2c68:	00000c4d 	.word	0x00000c4d
    2c6c:	20000dec 	.word	0x20000dec
    2c70:	20000d3c 	.word	0x20000d3c
    2c74:	20000164 	.word	0x20000164
    2c78:	20000df4 	.word	0x20000df4
    2c7c:	0000287d 	.word	0x0000287d
    2c80:	20000df0 	.word	0x20000df0

00002c84 <socketInit>:

Date
		4 June 2012
*********************************************************************/
void socketInit(void)
{
    2c84:	b510      	push	{r4, lr}
	if(gbSocketInit == 0)
    2c86:	4b0a      	ldr	r3, [pc, #40]	; (2cb0 <socketInit+0x2c>)
    2c88:	781b      	ldrb	r3, [r3, #0]
    2c8a:	2b00      	cmp	r3, #0
    2c8c:	d10e      	bne.n	2cac <socketInit+0x28>
	{
		m2m_memset((uint8*)gastrSockets, 0, MAX_SOCKET * sizeof(tstrSocket));
    2c8e:	22b0      	movs	r2, #176	; 0xb0
    2c90:	2100      	movs	r1, #0
    2c92:	4808      	ldr	r0, [pc, #32]	; (2cb4 <socketInit+0x30>)
    2c94:	4b08      	ldr	r3, [pc, #32]	; (2cb8 <socketInit+0x34>)
    2c96:	4798      	blx	r3
		hif_register_cb(M2M_REQ_GROUP_IP,m2m_ip_cb);
    2c98:	4908      	ldr	r1, [pc, #32]	; (2cbc <socketInit+0x38>)
    2c9a:	2002      	movs	r0, #2
    2c9c:	4b08      	ldr	r3, [pc, #32]	; (2cc0 <socketInit+0x3c>)
    2c9e:	4798      	blx	r3
		gbSocketInit	= 1;
    2ca0:	2201      	movs	r2, #1
    2ca2:	4b03      	ldr	r3, [pc, #12]	; (2cb0 <socketInit+0x2c>)
    2ca4:	701a      	strb	r2, [r3, #0]
		gu16SessionID	= 0;
    2ca6:	2200      	movs	r2, #0
    2ca8:	4b06      	ldr	r3, [pc, #24]	; (2cc4 <socketInit+0x40>)
    2caa:	801a      	strh	r2, [r3, #0]
	}
}
    2cac:	bd10      	pop	{r4, pc}
    2cae:	46c0      	nop			; (mov r8, r8)
    2cb0:	20000163 	.word	0x20000163
    2cb4:	20000d3c 	.word	0x20000d3c
    2cb8:	00000529 	.word	0x00000529
    2cbc:	0000298d 	.word	0x0000298d
    2cc0:	00000d39 	.word	0x00000d39
    2cc4:	20000164 	.word	0x20000164

00002cc8 <registerSocketCallback>:
Date
		4 June 2012
*********************************************************************/
void registerSocketCallback(tpfAppSocketCb pfAppSocketCb, tpfAppResolveCb pfAppResolveCb)
{
	gpfAppSocketCb = pfAppSocketCb;
    2cc8:	4b02      	ldr	r3, [pc, #8]	; (2cd4 <registerSocketCallback+0xc>)
    2cca:	6018      	str	r0, [r3, #0]
	gpfAppResolveCb = pfAppResolveCb;
    2ccc:	4b02      	ldr	r3, [pc, #8]	; (2cd8 <registerSocketCallback+0x10>)
    2cce:	6019      	str	r1, [r3, #0]
}
    2cd0:	4770      	bx	lr
    2cd2:	46c0      	nop			; (mov r8, r8)
    2cd4:	20000dec 	.word	0x20000dec
    2cd8:	20000df4 	.word	0x20000df4

00002cdc <socket>:

Date
		4 June 2012
*********************************************************************/
SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
{
    2cdc:	b5f0      	push	{r4, r5, r6, r7, lr}
    2cde:	4657      	mov	r7, sl
    2ce0:	464e      	mov	r6, r9
    2ce2:	b4c0      	push	{r6, r7}
    2ce4:	b089      	sub	sp, #36	; 0x24
    2ce6:	9205      	str	r2, [sp, #20]
	volatile tstrSocket		*pstrSock;
	static volatile uint8	u8NextTcpSock	= 0;
	static volatile uint8	u8NextUdpSock	= 0;

	/* The only supported family is the AF_INET for UDP and TCP transport layer protocols. */
	if(u16Domain == AF_INET)
    2ce8:	2802      	cmp	r0, #2
    2cea:	d000      	beq.n	2cee <socket+0x12>
    2cec:	e094      	b.n	2e18 <socket+0x13c>
	{
		if(u8Type == SOCK_STREAM)
    2cee:	2901      	cmp	r1, #1
    2cf0:	d133      	bne.n	2d5a <socket+0x7e>
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
			{
				u8SockID	= u8NextTcpSock;
    2cf2:	4c4f      	ldr	r4, [pc, #316]	; (2e30 <socket+0x154>)
    2cf4:	7825      	ldrb	r5, [r4, #0]
    2cf6:	b2ef      	uxtb	r7, r5
				pstrSock	= &gastrSockets[u8NextTcpSock];
    2cf8:	7823      	ldrb	r3, [r4, #0]
    2cfa:	b2de      	uxtb	r6, r3
				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
    2cfc:	7820      	ldrb	r0, [r4, #0]
    2cfe:	3001      	adds	r0, #1
    2d00:	3106      	adds	r1, #6
    2d02:	4b4c      	ldr	r3, [pc, #304]	; (2e34 <socket+0x158>)
    2d04:	4798      	blx	r3
    2d06:	b2c9      	uxtb	r1, r1
    2d08:	7021      	strb	r1, [r4, #0]
				if(!pstrSock->bIsUsed)
    2d0a:	0133      	lsls	r3, r6, #4
    2d0c:	4a4a      	ldr	r2, [pc, #296]	; (2e38 <socket+0x15c>)
    2d0e:	18d3      	adds	r3, r2, r3
    2d10:	7a9b      	ldrb	r3, [r3, #10]
    2d12:	2506      	movs	r5, #6
    2d14:	2b00      	cmp	r3, #0
    2d16:	d102      	bne.n	2d1e <socket+0x42>
		if(u8Type == SOCK_STREAM)
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
			{
				u8SockID	= u8NextTcpSock;
				pstrSock	= &gastrSockets[u8NextTcpSock];
    2d18:	0134      	lsls	r4, r6, #4
    2d1a:	18a4      	adds	r4, r4, r2
    2d1c:	e016      	b.n	2d4c <socket+0x70>
	{
		if(u8Type == SOCK_STREAM)
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
			{
				u8SockID	= u8NextTcpSock;
    2d1e:	4c44      	ldr	r4, [pc, #272]	; (2e30 <socket+0x154>)
				pstrSock	= &gastrSockets[u8NextTcpSock];
				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
    2d20:	4b44      	ldr	r3, [pc, #272]	; (2e34 <socket+0x158>)
    2d22:	469a      	mov	sl, r3
				if(!pstrSock->bIsUsed)
    2d24:	4b44      	ldr	r3, [pc, #272]	; (2e38 <socket+0x15c>)
    2d26:	4699      	mov	r9, r3
	{
		if(u8Type == SOCK_STREAM)
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
			{
				u8SockID	= u8NextTcpSock;
    2d28:	7827      	ldrb	r7, [r4, #0]
    2d2a:	b2ff      	uxtb	r7, r7
				pstrSock	= &gastrSockets[u8NextTcpSock];
    2d2c:	7823      	ldrb	r3, [r4, #0]
    2d2e:	b2de      	uxtb	r6, r3
				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
    2d30:	7820      	ldrb	r0, [r4, #0]
    2d32:	3001      	adds	r0, #1
    2d34:	2107      	movs	r1, #7
    2d36:	47d0      	blx	sl
    2d38:	b2c9      	uxtb	r1, r1
    2d3a:	7021      	strb	r1, [r4, #0]
				if(!pstrSock->bIsUsed)
    2d3c:	0133      	lsls	r3, r6, #4
    2d3e:	444b      	add	r3, r9
    2d40:	7a9b      	ldrb	r3, [r3, #10]
    2d42:	2b00      	cmp	r3, #0
    2d44:	d104      	bne.n	2d50 <socket+0x74>
		if(u8Type == SOCK_STREAM)
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
			{
				u8SockID	= u8NextTcpSock;
				pstrSock	= &gastrSockets[u8NextTcpSock];
    2d46:	0134      	lsls	r4, r6, #4
    2d48:	4b3b      	ldr	r3, [pc, #236]	; (2e38 <socket+0x15c>)
    2d4a:	18e4      	adds	r4, r4, r3
				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
				if(!pstrSock->bIsUsed)
				{
					sock = (SOCKET)u8SockID;
    2d4c:	b27d      	sxtb	r5, r7
					break;
    2d4e:	e02d      	b.n	2dac <socket+0xd0>
    2d50:	3d01      	subs	r5, #1
    2d52:	b2ed      	uxtb	r5, r5
	/* The only supported family is the AF_INET for UDP and TCP transport layer protocols. */
	if(u16Domain == AF_INET)
	{
		if(u8Type == SOCK_STREAM)
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
    2d54:	2d00      	cmp	r5, #0
    2d56:	d1e7      	bne.n	2d28 <socket+0x4c>
    2d58:	e061      	b.n	2e1e <socket+0x142>
					sock = (SOCKET)u8SockID;
					break;
				}
			}
		}
		else if(u8Type == SOCK_DGRAM)
    2d5a:	2902      	cmp	r1, #2
    2d5c:	d15f      	bne.n	2e1e <socket+0x142>
		{
			volatile tstrSocket	*pastrUDPSockets = &gastrSockets[TCP_SOCK_MAX];
			for(u8Count = 0; u8Count < UDP_SOCK_MAX; u8Count ++)
			{
				u8SockID		= u8NextUdpSock;
    2d5e:	4a37      	ldr	r2, [pc, #220]	; (2e3c <socket+0x160>)
    2d60:	7815      	ldrb	r5, [r2, #0]
    2d62:	b2ed      	uxtb	r5, r5
				pstrSock		= &pastrUDPSockets[u8NextUdpSock];
    2d64:	7814      	ldrb	r4, [r2, #0]
    2d66:	0124      	lsls	r4, r4, #4
    2d68:	4b35      	ldr	r3, [pc, #212]	; (2e40 <socket+0x164>)
    2d6a:	18e4      	adds	r4, r4, r3
				u8NextUdpSock	= (u8NextUdpSock + 1) % UDP_SOCK_MAX;
    2d6c:	7813      	ldrb	r3, [r2, #0]
    2d6e:	3301      	adds	r3, #1
    2d70:	3101      	adds	r1, #1
    2d72:	400b      	ands	r3, r1
    2d74:	7013      	strb	r3, [r2, #0]
				if(!pstrSock->bIsUsed)
    2d76:	7aa3      	ldrb	r3, [r4, #10]
    2d78:	2b00      	cmp	r3, #0
    2d7a:	d00f      	beq.n	2d9c <socket+0xc0>
    2d7c:	2203      	movs	r2, #3
		else if(u8Type == SOCK_DGRAM)
		{
			volatile tstrSocket	*pastrUDPSockets = &gastrSockets[TCP_SOCK_MAX];
			for(u8Count = 0; u8Count < UDP_SOCK_MAX; u8Count ++)
			{
				u8SockID		= u8NextUdpSock;
    2d7e:	492f      	ldr	r1, [pc, #188]	; (2e3c <socket+0x160>)
				pstrSock		= &pastrUDPSockets[u8NextUdpSock];
    2d80:	4f2f      	ldr	r7, [pc, #188]	; (2e40 <socket+0x164>)
				u8NextUdpSock	= (u8NextUdpSock + 1) % UDP_SOCK_MAX;
    2d82:	2003      	movs	r0, #3
		else if(u8Type == SOCK_DGRAM)
		{
			volatile tstrSocket	*pastrUDPSockets = &gastrSockets[TCP_SOCK_MAX];
			for(u8Count = 0; u8Count < UDP_SOCK_MAX; u8Count ++)
			{
				u8SockID		= u8NextUdpSock;
    2d84:	780d      	ldrb	r5, [r1, #0]
    2d86:	b2ed      	uxtb	r5, r5
				pstrSock		= &pastrUDPSockets[u8NextUdpSock];
    2d88:	780c      	ldrb	r4, [r1, #0]
    2d8a:	0124      	lsls	r4, r4, #4
    2d8c:	19e4      	adds	r4, r4, r7
				u8NextUdpSock	= (u8NextUdpSock + 1) % UDP_SOCK_MAX;
    2d8e:	780b      	ldrb	r3, [r1, #0]
    2d90:	3301      	adds	r3, #1
    2d92:	4003      	ands	r3, r0
    2d94:	700b      	strb	r3, [r1, #0]
				if(!pstrSock->bIsUsed)
    2d96:	7aa3      	ldrb	r3, [r4, #10]
    2d98:	2b00      	cmp	r3, #0
    2d9a:	d102      	bne.n	2da2 <socket+0xc6>
				{
					sock = (SOCKET)(u8SockID + TCP_SOCK_MAX);
    2d9c:	3507      	adds	r5, #7
    2d9e:	b26d      	sxtb	r5, r5
					break;
    2da0:	e004      	b.n	2dac <socket+0xd0>
    2da2:	3a01      	subs	r2, #1
    2da4:	b2d2      	uxtb	r2, r2
			}
		}
		else if(u8Type == SOCK_DGRAM)
		{
			volatile tstrSocket	*pastrUDPSockets = &gastrSockets[TCP_SOCK_MAX];
			for(u8Count = 0; u8Count < UDP_SOCK_MAX; u8Count ++)
    2da6:	2a00      	cmp	r2, #0
    2da8:	d1ec      	bne.n	2d84 <socket+0xa8>
    2daa:	e038      	b.n	2e1e <socket+0x142>
					break;
				}
			}
		}

		if(sock >= 0)
    2dac:	2d00      	cmp	r5, #0
    2dae:	db38      	blt.n	2e22 <socket+0x146>
		{
			m2m_memset((uint8*)pstrSock, 0, sizeof(tstrSocket));
    2db0:	2210      	movs	r2, #16
    2db2:	2100      	movs	r1, #0
    2db4:	0020      	movs	r0, r4
    2db6:	4b23      	ldr	r3, [pc, #140]	; (2e44 <socket+0x168>)
    2db8:	4798      	blx	r3
			pstrSock->bIsUsed = 1;
    2dba:	2301      	movs	r3, #1
    2dbc:	72a3      	strb	r3, [r4, #10]

			/* The session ID is used to distinguish different socket connections
				by comparing the assigned session ID to the one reported by the firmware*/
			++gu16SessionID;
    2dbe:	4a22      	ldr	r2, [pc, #136]	; (2e48 <socket+0x16c>)
    2dc0:	8813      	ldrh	r3, [r2, #0]
    2dc2:	3301      	adds	r3, #1
    2dc4:	b29b      	uxth	r3, r3
    2dc6:	8013      	strh	r3, [r2, #0]
			if(gu16SessionID == 0)
    2dc8:	8813      	ldrh	r3, [r2, #0]
    2dca:	b29b      	uxth	r3, r3
    2dcc:	2b00      	cmp	r3, #0
    2dce:	d103      	bne.n	2dd8 <socket+0xfc>
				++gu16SessionID;
    2dd0:	8813      	ldrh	r3, [r2, #0]
    2dd2:	3301      	adds	r3, #1
    2dd4:	b29b      	uxth	r3, r3
    2dd6:	8013      	strh	r3, [r2, #0]
				
			pstrSock->u16SessionID = gu16SessionID;
    2dd8:	4e1b      	ldr	r6, [pc, #108]	; (2e48 <socket+0x16c>)
    2dda:	8833      	ldrh	r3, [r6, #0]
    2ddc:	b29b      	uxth	r3, r3
    2dde:	80e3      	strh	r3, [r4, #6]
            M2M_INFO("Socket %d session ID = %d\r\n",sock, gu16SessionID );
    2de0:	481a      	ldr	r0, [pc, #104]	; (2e4c <socket+0x170>)
    2de2:	4f1b      	ldr	r7, [pc, #108]	; (2e50 <socket+0x174>)
    2de4:	47b8      	blx	r7
    2de6:	8832      	ldrh	r2, [r6, #0]
    2de8:	b292      	uxth	r2, r2
    2dea:	0029      	movs	r1, r5
    2dec:	4819      	ldr	r0, [pc, #100]	; (2e54 <socket+0x178>)
    2dee:	47b8      	blx	r7
    2df0:	200d      	movs	r0, #13
    2df2:	4b19      	ldr	r3, [pc, #100]	; (2e58 <socket+0x17c>)
    2df4:	4798      	blx	r3

			if(u8Flags & SOCKET_FLAGS_SSL)
    2df6:	9b05      	ldr	r3, [sp, #20]
    2df8:	07db      	lsls	r3, r3, #31
    2dfa:	d512      	bpl.n	2e22 <socket+0x146>
			{
				tstrSSLSocketCreateCmd	strSSLCreate;
				strSSLCreate.sslSock = sock;
    2dfc:	aa07      	add	r2, sp, #28
    2dfe:	7015      	strb	r5, [r2, #0]
				pstrSock->u8SSLFlags = SSL_FLAGS_ACTIVE | SSL_FLAGS_NO_TX_COPY;
    2e00:	2321      	movs	r3, #33	; 0x21
    2e02:	72e3      	strb	r3, [r4, #11]
				SOCKET_REQUEST(SOCKET_CMD_SSL_CREATE, (uint8*)&strSSLCreate, sizeof(tstrSSLSocketCreateCmd), 0, 0, 0);
    2e04:	2300      	movs	r3, #0
    2e06:	9302      	str	r3, [sp, #8]
    2e08:	9301      	str	r3, [sp, #4]
    2e0a:	9300      	str	r3, [sp, #0]
    2e0c:	3304      	adds	r3, #4
    2e0e:	2150      	movs	r1, #80	; 0x50
    2e10:	2002      	movs	r0, #2
    2e12:	4c12      	ldr	r4, [pc, #72]	; (2e5c <socket+0x180>)
    2e14:	47a0      	blx	r4
    2e16:	e004      	b.n	2e22 <socket+0x146>
Date
		4 June 2012
*********************************************************************/
SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
{
	SOCKET					sock = -1;
    2e18:	2501      	movs	r5, #1
    2e1a:	426d      	negs	r5, r5
    2e1c:	e001      	b.n	2e22 <socket+0x146>
    2e1e:	2501      	movs	r5, #1
    2e20:	426d      	negs	r5, r5
				SOCKET_REQUEST(SOCKET_CMD_SSL_CREATE, (uint8*)&strSSLCreate, sizeof(tstrSSLSocketCreateCmd), 0, 0, 0);
			}
		}
	}
	return sock;
}
    2e22:	0028      	movs	r0, r5
    2e24:	b009      	add	sp, #36	; 0x24
    2e26:	bc0c      	pop	{r2, r3}
    2e28:	4691      	mov	r9, r2
    2e2a:	469a      	mov	sl, r3
    2e2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2e2e:	46c0      	nop			; (mov r8, r8)
    2e30:	20000161 	.word	0x20000161
    2e34:	0000a66d 	.word	0x0000a66d
    2e38:	20000d3c 	.word	0x20000d3c
    2e3c:	20000162 	.word	0x20000162
    2e40:	20000dac 	.word	0x20000dac
    2e44:	00000529 	.word	0x00000529
    2e48:	20000164 	.word	0x20000164
    2e4c:	0000b928 	.word	0x0000b928
    2e50:	0000a771 	.word	0x0000a771
    2e54:	0000c848 	.word	0x0000c848
    2e58:	0000a7a5 	.word	0x0000a7a5
    2e5c:	00000639 	.word	0x00000639

00002e60 <connect>:

Date
		5 June 2012
*********************************************************************/
sint8 connect(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
    2e60:	b570      	push	{r4, r5, r6, lr}
    2e62:	b088      	sub	sp, #32
    2e64:	1e04      	subs	r4, r0, #0
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if((sock >= 0) && (pstrAddr != NULL) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
    2e66:	db2f      	blt.n	2ec8 <connect+0x68>
    2e68:	2900      	cmp	r1, #0
    2e6a:	d030      	beq.n	2ece <connect+0x6e>
    2e6c:	0103      	lsls	r3, r0, #4
    2e6e:	481d      	ldr	r0, [pc, #116]	; (2ee4 <connect+0x84>)
    2e70:	18c3      	adds	r3, r0, r3
    2e72:	7a9b      	ldrb	r3, [r3, #10]
    2e74:	2b01      	cmp	r3, #1
    2e76:	d12d      	bne.n	2ed4 <connect+0x74>
    2e78:	2a00      	cmp	r2, #0
    2e7a:	d02e      	beq.n	2eda <connect+0x7a>
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
    2e7c:	0123      	lsls	r3, r4, #4
    2e7e:	18c3      	adds	r3, r0, r3
    2e80:	7adb      	ldrb	r3, [r3, #11]
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if((sock >= 0) && (pstrAddr != NULL) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
    2e82:	2644      	movs	r6, #68	; 0x44
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
    2e84:	07db      	lsls	r3, r3, #31
    2e86:	d505      	bpl.n	2e94 <connect+0x34>
		{
			u8Cmd = SOCKET_CMD_SSL_CONNECT;
			strConnect.u8SslFlags = gastrSockets[sock].u8SSLFlags;
    2e88:	0123      	lsls	r3, r4, #4
    2e8a:	18c3      	adds	r3, r0, r3
    2e8c:	7ada      	ldrb	r2, [r3, #11]
    2e8e:	ab05      	add	r3, sp, #20
    2e90:	725a      	strb	r2, [r3, #9]
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
		{
			u8Cmd = SOCKET_CMD_SSL_CONNECT;
    2e92:	3607      	adds	r6, #7
			strConnect.u8SslFlags = gastrSockets[sock].u8SSLFlags;
		}
		strConnect.sock = sock;
    2e94:	ad05      	add	r5, sp, #20
    2e96:	722c      	strb	r4, [r5, #8]
		m2m_memcpy((uint8 *)&strConnect.strAddr, (uint8 *)pstrAddr, sizeof(tstrSockAddr));
    2e98:	2208      	movs	r2, #8
    2e9a:	0028      	movs	r0, r5
    2e9c:	4b12      	ldr	r3, [pc, #72]	; (2ee8 <connect+0x88>)
    2e9e:	4798      	blx	r3

		strConnect.u16SessionID		= gastrSockets[sock].u16SessionID;
    2ea0:	0124      	lsls	r4, r4, #4
    2ea2:	4b10      	ldr	r3, [pc, #64]	; (2ee4 <connect+0x84>)
    2ea4:	191c      	adds	r4, r3, r4
    2ea6:	88e3      	ldrh	r3, [r4, #6]
    2ea8:	816b      	strh	r3, [r5, #10]
		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strConnect,sizeof(tstrConnectCmd), NULL, 0, 0);
    2eaa:	2300      	movs	r3, #0
    2eac:	9302      	str	r3, [sp, #8]
    2eae:	9301      	str	r3, [sp, #4]
    2eb0:	9300      	str	r3, [sp, #0]
    2eb2:	330c      	adds	r3, #12
    2eb4:	002a      	movs	r2, r5
    2eb6:	0031      	movs	r1, r6
    2eb8:	2002      	movs	r0, #2
    2eba:	4c0c      	ldr	r4, [pc, #48]	; (2eec <connect+0x8c>)
    2ebc:	47a0      	blx	r4
		if(s8Ret != SOCK_ERR_NO_ERROR)
    2ebe:	2800      	cmp	r0, #0
    2ec0:	d00d      	beq.n	2ede <connect+0x7e>
		{
			s8Ret = SOCK_ERR_INVALID;
    2ec2:	2009      	movs	r0, #9
    2ec4:	4240      	negs	r0, r0
    2ec6:	e00a      	b.n	2ede <connect+0x7e>
Date
		5 June 2012
*********************************************************************/
sint8 connect(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    2ec8:	2006      	movs	r0, #6
    2eca:	4240      	negs	r0, r0
    2ecc:	e007      	b.n	2ede <connect+0x7e>
    2ece:	2006      	movs	r0, #6
    2ed0:	4240      	negs	r0, r0
    2ed2:	e004      	b.n	2ede <connect+0x7e>
    2ed4:	2006      	movs	r0, #6
    2ed6:	4240      	negs	r0, r0
    2ed8:	e001      	b.n	2ede <connect+0x7e>
    2eda:	2006      	movs	r0, #6
    2edc:	4240      	negs	r0, r0
		{
			s8Ret = SOCK_ERR_INVALID;
		}
	}
	return s8Ret;
}
    2ede:	b008      	add	sp, #32
    2ee0:	bd70      	pop	{r4, r5, r6, pc}
    2ee2:	46c0      	nop			; (mov r8, r8)
    2ee4:	20000d3c 	.word	0x20000d3c
    2ee8:	00000515 	.word	0x00000515
    2eec:	00000639 	.word	0x00000639

00002ef0 <send>:

Date
		5 June 2012
*********************************************************************/
sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags)
{
    2ef0:	b530      	push	{r4, r5, lr}
    2ef2:	b089      	sub	sp, #36	; 0x24
    2ef4:	000c      	movs	r4, r1
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvSendBuffer != NULL) && (u16SendLength <= SOCKET_BUFFER_MAX_LENGTH) && (gastrSockets[sock].bIsUsed == 1))
    2ef6:	2800      	cmp	r0, #0
    2ef8:	db33      	blt.n	2f62 <send+0x72>
    2efa:	2900      	cmp	r1, #0
    2efc:	d034      	beq.n	2f68 <send+0x78>
    2efe:	23af      	movs	r3, #175	; 0xaf
    2f00:	00db      	lsls	r3, r3, #3
    2f02:	429a      	cmp	r2, r3
    2f04:	d833      	bhi.n	2f6e <send+0x7e>
    2f06:	0103      	lsls	r3, r0, #4
    2f08:	491d      	ldr	r1, [pc, #116]	; (2f80 <send+0x90>)
    2f0a:	18cb      	adds	r3, r1, r3
    2f0c:	7a9b      	ldrb	r3, [r3, #10]
    2f0e:	2b01      	cmp	r3, #1
    2f10:	d130      	bne.n	2f74 <send+0x84>
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
		u16DataOffset	= TCP_TX_PACKET_OFFSET;

		strSend.sock			= sock;
    2f12:	a904      	add	r1, sp, #16
    2f14:	7008      	strb	r0, [r1, #0]
		strSend.u16DataSize		= NM_BSP_B_L_16(u16SendLength);
    2f16:	804a      	strh	r2, [r1, #2]
		strSend.u16SessionID	= gastrSockets[sock].u16SessionID;
    2f18:	0103      	lsls	r3, r0, #4
    2f1a:	4d19      	ldr	r5, [pc, #100]	; (2f80 <send+0x90>)
    2f1c:	18eb      	adds	r3, r5, r3
    2f1e:	88db      	ldrh	r3, [r3, #6]
    2f20:	818b      	strh	r3, [r1, #12]
		uint16			u16DataOffset;
		tstrSendCmd		strSend;
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
		u16DataOffset	= TCP_TX_PACKET_OFFSET;
    2f22:	2550      	movs	r5, #80	; 0x50

		strSend.sock			= sock;
		strSend.u16DataSize		= NM_BSP_B_L_16(u16SendLength);
		strSend.u16SessionID	= gastrSockets[sock].u16SessionID;

		if(sock >= TCP_SOCK_MAX)
    2f24:	2806      	cmp	r0, #6
    2f26:	dd00      	ble.n	2f2a <send+0x3a>
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
    2f28:	3d0c      	subs	r5, #12
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    2f2a:	0103      	lsls	r3, r0, #4
    2f2c:	4914      	ldr	r1, [pc, #80]	; (2f80 <send+0x90>)
    2f2e:	18cb      	adds	r3, r1, r3
    2f30:	7adb      	ldrb	r3, [r3, #11]
	{
		uint16			u16DataOffset;
		tstrSendCmd		strSend;
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
    2f32:	2145      	movs	r1, #69	; 0x45

		if(sock >= TCP_SOCK_MAX)
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    2f34:	07db      	lsls	r3, r3, #31
    2f36:	d505      	bpl.n	2f44 <send+0x54>
		{
			u8Cmd			= SOCKET_CMD_SSL_SEND;
			u16DataOffset	= gastrSockets[sock].u16DataOffset;
    2f38:	0100      	lsls	r0, r0, #4
    2f3a:	4b11      	ldr	r3, [pc, #68]	; (2f80 <send+0x90>)
    2f3c:	1818      	adds	r0, r3, r0
    2f3e:	8905      	ldrh	r5, [r0, #8]
    2f40:	b2ad      	uxth	r5, r5
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
		{
			u8Cmd			= SOCKET_CMD_SSL_SEND;
    2f42:	3107      	adds	r1, #7
			u16DataOffset	= gastrSockets[sock].u16DataOffset;
		}

		s16Ret =  SOCKET_REQUEST(u8Cmd|M2M_REQ_DATA_PKT, (uint8*)&strSend, sizeof(tstrSendCmd), pvSendBuffer, u16SendLength, u16DataOffset);
    2f44:	2380      	movs	r3, #128	; 0x80
    2f46:	4319      	orrs	r1, r3
    2f48:	9502      	str	r5, [sp, #8]
    2f4a:	9201      	str	r2, [sp, #4]
    2f4c:	9400      	str	r4, [sp, #0]
    2f4e:	3b70      	subs	r3, #112	; 0x70
    2f50:	aa04      	add	r2, sp, #16
    2f52:	2002      	movs	r0, #2
    2f54:	4c0b      	ldr	r4, [pc, #44]	; (2f84 <send+0x94>)
    2f56:	47a0      	blx	r4
    2f58:	2300      	movs	r3, #0
		if(s16Ret != SOCK_ERR_NO_ERROR)
    2f5a:	2800      	cmp	r0, #0
    2f5c:	d00c      	beq.n	2f78 <send+0x88>
		{
			s16Ret = SOCK_ERR_BUFFER_FULL;
    2f5e:	3b0e      	subs	r3, #14
    2f60:	e00a      	b.n	2f78 <send+0x88>
Date
		5 June 2012
*********************************************************************/
sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags)
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
    2f62:	2306      	movs	r3, #6
    2f64:	425b      	negs	r3, r3
    2f66:	e007      	b.n	2f78 <send+0x88>
    2f68:	2306      	movs	r3, #6
    2f6a:	425b      	negs	r3, r3
    2f6c:	e004      	b.n	2f78 <send+0x88>
    2f6e:	2306      	movs	r3, #6
    2f70:	425b      	negs	r3, r3
    2f72:	e001      	b.n	2f78 <send+0x88>
    2f74:	2306      	movs	r3, #6
    2f76:	425b      	negs	r3, r3
		{
			s16Ret = SOCK_ERR_BUFFER_FULL;
		}
	}
	return s16Ret;
}
    2f78:	0018      	movs	r0, r3
    2f7a:	b009      	add	sp, #36	; 0x24
    2f7c:	bd30      	pop	{r4, r5, pc}
    2f7e:	46c0      	nop			; (mov r8, r8)
    2f80:	20000d3c 	.word	0x20000d3c
    2f84:	00000639 	.word	0x00000639

00002f88 <recv>:

Date
		5 June 2012
*********************************************************************/
sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
{
    2f88:	b530      	push	{r4, r5, lr}
    2f8a:	b087      	sub	sp, #28
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (gastrSockets[sock].bIsUsed == 1))
    2f8c:	2800      	cmp	r0, #0
    2f8e:	db33      	blt.n	2ff8 <recv+0x70>
    2f90:	2900      	cmp	r1, #0
    2f92:	d034      	beq.n	2ffe <recv+0x76>
    2f94:	2a00      	cmp	r2, #0
    2f96:	d035      	beq.n	3004 <recv+0x7c>
    2f98:	0104      	lsls	r4, r0, #4
    2f9a:	4d1e      	ldr	r5, [pc, #120]	; (3014 <recv+0x8c>)
    2f9c:	192c      	adds	r4, r5, r4
    2f9e:	7aa4      	ldrb	r4, [r4, #10]
    2fa0:	2c01      	cmp	r4, #1
    2fa2:	d132      	bne.n	300a <recv+0x82>
	{
		s16Ret = SOCK_ERR_NO_ERROR;
		gastrSockets[sock].pu8UserBuffer 		= (uint8*)pvRecvBuf;
    2fa4:	0104      	lsls	r4, r0, #4
    2fa6:	5161      	str	r1, [r4, r5]
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;
    2fa8:	1929      	adds	r1, r5, r4
    2faa:	808a      	strh	r2, [r1, #4]

		if(!gastrSockets[sock].bIsRecvPending)
    2fac:	7b09      	ldrb	r1, [r1, #12]
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (gastrSockets[sock].bIsUsed == 1))
	{
		s16Ret = SOCK_ERR_NO_ERROR;
    2fae:	2200      	movs	r2, #0
		gastrSockets[sock].pu8UserBuffer 		= (uint8*)pvRecvBuf;
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;

		if(!gastrSockets[sock].bIsRecvPending)
    2fb0:	2900      	cmp	r1, #0
    2fb2:	d12c      	bne.n	300e <recv+0x86>
		{
			tstrRecvCmd	strRecv;
			uint8		u8Cmd = SOCKET_CMD_RECV;

			gastrSockets[sock].bIsRecvPending = 1;
    2fb4:	192a      	adds	r2, r5, r4
    2fb6:	2101      	movs	r1, #1
    2fb8:	7311      	strb	r1, [r2, #12]
			if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    2fba:	7ad2      	ldrb	r2, [r2, #11]
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;

		if(!gastrSockets[sock].bIsRecvPending)
		{
			tstrRecvCmd	strRecv;
			uint8		u8Cmd = SOCKET_CMD_RECV;
    2fbc:	3145      	adds	r1, #69	; 0x45

			gastrSockets[sock].bIsRecvPending = 1;
			if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    2fbe:	07d2      	lsls	r2, r2, #31
    2fc0:	d500      	bpl.n	2fc4 <recv+0x3c>
			{
				u8Cmd = SOCKET_CMD_SSL_RECV;
    2fc2:	3107      	adds	r1, #7
			}

			/* Check the timeout value. */
			if(u32Timeoutmsec == 0)
    2fc4:	2b00      	cmp	r3, #0
    2fc6:	d102      	bne.n	2fce <recv+0x46>
				strRecv.u32Timeoutmsec = 0xFFFFFFFF;
    2fc8:	3b01      	subs	r3, #1
    2fca:	9304      	str	r3, [sp, #16]
    2fcc:	e000      	b.n	2fd0 <recv+0x48>
			else
				strRecv.u32Timeoutmsec = NM_BSP_B_L_32(u32Timeoutmsec);
    2fce:	9304      	str	r3, [sp, #16]
			strRecv.sock = sock;
    2fd0:	aa04      	add	r2, sp, #16
    2fd2:	7110      	strb	r0, [r2, #4]
			strRecv.u16SessionID		= gastrSockets[sock].u16SessionID;
    2fd4:	0100      	lsls	r0, r0, #4
    2fd6:	4b0f      	ldr	r3, [pc, #60]	; (3014 <recv+0x8c>)
    2fd8:	1818      	adds	r0, r3, r0
    2fda:	88c3      	ldrh	r3, [r0, #6]
    2fdc:	80d3      	strh	r3, [r2, #6]
		
			s16Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strRecv, sizeof(tstrRecvCmd), NULL , 0, 0);
    2fde:	2300      	movs	r3, #0
    2fe0:	9302      	str	r3, [sp, #8]
    2fe2:	9301      	str	r3, [sp, #4]
    2fe4:	9300      	str	r3, [sp, #0]
    2fe6:	3308      	adds	r3, #8
    2fe8:	2002      	movs	r0, #2
    2fea:	4c0b      	ldr	r4, [pc, #44]	; (3018 <recv+0x90>)
    2fec:	47a0      	blx	r4
    2fee:	2200      	movs	r2, #0
			if(s16Ret != SOCK_ERR_NO_ERROR)
    2ff0:	2800      	cmp	r0, #0
    2ff2:	d00c      	beq.n	300e <recv+0x86>
			{
				s16Ret = SOCK_ERR_BUFFER_FULL;
    2ff4:	3a0e      	subs	r2, #14
    2ff6:	e00a      	b.n	300e <recv+0x86>
Date
		5 June 2012
*********************************************************************/
sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
    2ff8:	2206      	movs	r2, #6
    2ffa:	4252      	negs	r2, r2
    2ffc:	e007      	b.n	300e <recv+0x86>
    2ffe:	2206      	movs	r2, #6
    3000:	4252      	negs	r2, r2
    3002:	e004      	b.n	300e <recv+0x86>
    3004:	2206      	movs	r2, #6
    3006:	4252      	negs	r2, r2
    3008:	e001      	b.n	300e <recv+0x86>
    300a:	2206      	movs	r2, #6
    300c:	4252      	negs	r2, r2
				s16Ret = SOCK_ERR_BUFFER_FULL;
			}
		}
	}
	return s16Ret;
}
    300e:	0010      	movs	r0, r2
    3010:	b007      	add	sp, #28
    3012:	bd30      	pop	{r4, r5, pc}
    3014:	20000d3c 	.word	0x20000d3c
    3018:	00000639 	.word	0x00000639

0000301c <close>:

Date
		4 June 2012
*********************************************************************/
sint8 close(SOCKET sock)
{
    301c:	b530      	push	{r4, r5, lr}
    301e:	b087      	sub	sp, #28
    3020:	0004      	movs	r4, r0
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    M2M_INFO("Sock to delete <%d>\n", sock);
    3022:	481e      	ldr	r0, [pc, #120]	; (309c <close+0x80>)
    3024:	4d1e      	ldr	r5, [pc, #120]	; (30a0 <close+0x84>)
    3026:	47a8      	blx	r5
    3028:	0021      	movs	r1, r4
    302a:	481e      	ldr	r0, [pc, #120]	; (30a4 <close+0x88>)
    302c:	47a8      	blx	r5
    302e:	200d      	movs	r0, #13
    3030:	4b1d      	ldr	r3, [pc, #116]	; (30a8 <close+0x8c>)
    3032:	4798      	blx	r3
	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))
    3034:	2c00      	cmp	r4, #0
    3036:	db29      	blt.n	308c <close+0x70>
    3038:	0123      	lsls	r3, r4, #4
    303a:	4a1c      	ldr	r2, [pc, #112]	; (30ac <close+0x90>)
    303c:	18d3      	adds	r3, r2, r3
    303e:	7a9b      	ldrb	r3, [r3, #10]
    3040:	2b01      	cmp	r3, #1
    3042:	d126      	bne.n	3092 <close+0x76>
	{
		uint8	u8Cmd = SOCKET_CMD_CLOSE;
		tstrCloseCmd strclose;
		strclose.sock = sock; 
    3044:	a905      	add	r1, sp, #20
    3046:	700c      	strb	r4, [r1, #0]
		strclose.u16SessionID		= gastrSockets[sock].u16SessionID;
    3048:	0122      	lsls	r2, r4, #4
    304a:	4b18      	ldr	r3, [pc, #96]	; (30ac <close+0x90>)
    304c:	189b      	adds	r3, r3, r2
    304e:	88da      	ldrh	r2, [r3, #6]
    3050:	804a      	strh	r2, [r1, #2]
		
		gastrSockets[sock].bIsUsed = 0;
    3052:	2200      	movs	r2, #0
    3054:	729a      	strb	r2, [r3, #10]
		gastrSockets[sock].u16SessionID =0;
    3056:	80da      	strh	r2, [r3, #6]
		
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    3058:	7adb      	ldrb	r3, [r3, #11]
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    M2M_INFO("Sock to delete <%d>\n", sock);
	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))
	{
		uint8	u8Cmd = SOCKET_CMD_CLOSE;
    305a:	2149      	movs	r1, #73	; 0x49
		strclose.u16SessionID		= gastrSockets[sock].u16SessionID;
		
		gastrSockets[sock].bIsUsed = 0;
		gastrSockets[sock].u16SessionID =0;
		
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    305c:	07db      	lsls	r3, r3, #31
    305e:	d500      	bpl.n	3062 <close+0x46>
		{
			u8Cmd = SOCKET_CMD_SSL_CLOSE;
    3060:	3105      	adds	r1, #5
		}
		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strclose, sizeof(tstrCloseCmd), NULL,0, 0);
    3062:	2300      	movs	r3, #0
    3064:	9302      	str	r3, [sp, #8]
    3066:	9301      	str	r3, [sp, #4]
    3068:	9300      	str	r3, [sp, #0]
    306a:	3304      	adds	r3, #4
    306c:	aa05      	add	r2, sp, #20
    306e:	2002      	movs	r0, #2
    3070:	4d0f      	ldr	r5, [pc, #60]	; (30b0 <close+0x94>)
    3072:	47a8      	blx	r5
    3074:	1e05      	subs	r5, r0, #0
		if(s8Ret != SOCK_ERR_NO_ERROR)
    3076:	d001      	beq.n	307c <close+0x60>
		{
			s8Ret = SOCK_ERR_INVALID;
    3078:	2509      	movs	r5, #9
    307a:	426d      	negs	r5, r5
		}
		m2m_memset((uint8*)&gastrSockets[sock], 0, sizeof(tstrSocket));
    307c:	0124      	lsls	r4, r4, #4
    307e:	480b      	ldr	r0, [pc, #44]	; (30ac <close+0x90>)
    3080:	1820      	adds	r0, r4, r0
    3082:	2210      	movs	r2, #16
    3084:	2100      	movs	r1, #0
    3086:	4b0b      	ldr	r3, [pc, #44]	; (30b4 <close+0x98>)
    3088:	4798      	blx	r3
    308a:	e004      	b.n	3096 <close+0x7a>
Date
		4 June 2012
*********************************************************************/
sint8 close(SOCKET sock)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    308c:	2506      	movs	r5, #6
    308e:	426d      	negs	r5, r5
    3090:	e001      	b.n	3096 <close+0x7a>
    3092:	2506      	movs	r5, #6
    3094:	426d      	negs	r5, r5
			s8Ret = SOCK_ERR_INVALID;
		}
		m2m_memset((uint8*)&gastrSockets[sock], 0, sizeof(tstrSocket));
	}
	return s8Ret;
}
    3096:	0028      	movs	r0, r5
    3098:	b007      	add	sp, #28
    309a:	bd30      	pop	{r4, r5, pc}
    309c:	0000b928 	.word	0x0000b928
    30a0:	0000a771 	.word	0x0000a771
    30a4:	0000c864 	.word	0x0000c864
    30a8:	0000a7a5 	.word	0x0000a7a5
    30ac:	20000d3c 	.word	0x20000d3c
    30b0:	00000639 	.word	0x00000639
    30b4:	00000529 	.word	0x00000529

000030b8 <spi_flash_enable>:
 *	@brief	Enable spi flash operations
 *	@author	M. Abdelmawla
 *	@version	1.0
 */
sint8 spi_flash_enable(uint8 enable)
{
    30b8:	b570      	push	{r4, r5, r6, lr}
    30ba:	b082      	sub	sp, #8
    30bc:	0004      	movs	r4, r0
	sint8 s8Ret = M2M_SUCCESS;
	if(REV(nmi_get_chipid()) >= REV_3A0) {		
    30be:	4b29      	ldr	r3, [pc, #164]	; (3164 <spi_flash_enable+0xac>)
    30c0:	4798      	blx	r3
    30c2:	0500      	lsls	r0, r0, #20
    30c4:	0d00      	lsrs	r0, r0, #20
 *	@author	M. Abdelmawla
 *	@version	1.0
 */
sint8 spi_flash_enable(uint8 enable)
{
	sint8 s8Ret = M2M_SUCCESS;
    30c6:	2500      	movs	r5, #0
	if(REV(nmi_get_chipid()) >= REV_3A0) {		
    30c8:	4b27      	ldr	r3, [pc, #156]	; (3168 <spi_flash_enable+0xb0>)
    30ca:	4298      	cmp	r0, r3
    30cc:	d947      	bls.n	315e <spi_flash_enable+0xa6>
		uint32 u32Val;
		
		/* Enable pinmux to SPI flash. */
		s8Ret = nm_read_reg_with_ret(0x1410, &u32Val);
    30ce:	a901      	add	r1, sp, #4
    30d0:	4826      	ldr	r0, [pc, #152]	; (316c <spi_flash_enable+0xb4>)
    30d2:	4b27      	ldr	r3, [pc, #156]	; (3170 <spi_flash_enable+0xb8>)
    30d4:	4798      	blx	r3
    30d6:	1e05      	subs	r5, r0, #0
		if(s8Ret != M2M_SUCCESS) {
    30d8:	d141      	bne.n	315e <spi_flash_enable+0xa6>
			goto ERR1;
		}
		/* GPIO15/16/17/18 */
		u32Val &= ~((0x7777ul) << 12);
		u32Val |= ((0x1111ul) << 12);
    30da:	4926      	ldr	r1, [pc, #152]	; (3174 <spi_flash_enable+0xbc>)
    30dc:	9b01      	ldr	r3, [sp, #4]
    30de:	4019      	ands	r1, r3
    30e0:	4b25      	ldr	r3, [pc, #148]	; (3178 <spi_flash_enable+0xc0>)
    30e2:	4319      	orrs	r1, r3
    30e4:	9101      	str	r1, [sp, #4]
		nm_write_reg(0x1410, u32Val);
    30e6:	4821      	ldr	r0, [pc, #132]	; (316c <spi_flash_enable+0xb4>)
    30e8:	4b24      	ldr	r3, [pc, #144]	; (317c <spi_flash_enable+0xc4>)
    30ea:	4798      	blx	r3
		if(enable) {
    30ec:	2c00      	cmp	r4, #0
    30ee:	d016      	beq.n	311e <spi_flash_enable+0x66>
	volatile unsigned long tmp;
	unsigned char* cmd = (unsigned char*) &tmp;

	cmd[0] = 0xab;

	nm_write_reg(SPI_FLASH_DATA_CNT, 0);
    30f0:	2100      	movs	r1, #0
    30f2:	4823      	ldr	r0, [pc, #140]	; (3180 <spi_flash_enable+0xc8>)
    30f4:	4c21      	ldr	r4, [pc, #132]	; (317c <spi_flash_enable+0xc4>)
    30f6:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
    30f8:	21ab      	movs	r1, #171	; 0xab
    30fa:	4822      	ldr	r0, [pc, #136]	; (3184 <spi_flash_enable+0xcc>)
    30fc:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF_DIR, 0x1);
    30fe:	2101      	movs	r1, #1
    3100:	4821      	ldr	r0, [pc, #132]	; (3188 <spi_flash_enable+0xd0>)
    3102:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
    3104:	2100      	movs	r1, #0
    3106:	4821      	ldr	r0, [pc, #132]	; (318c <spi_flash_enable+0xd4>)
    3108:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_CMD_CNT,  1 | (1 << 7));
    310a:	2181      	movs	r1, #129	; 0x81
    310c:	4820      	ldr	r0, [pc, #128]	; (3190 <spi_flash_enable+0xd8>)
    310e:	47a0      	blx	r4
	while(nm_read_reg(SPI_FLASH_TR_DONE) != 1);
    3110:	4e20      	ldr	r6, [pc, #128]	; (3194 <spi_flash_enable+0xdc>)
    3112:	4c21      	ldr	r4, [pc, #132]	; (3198 <spi_flash_enable+0xe0>)
    3114:	0030      	movs	r0, r6
    3116:	47a0      	blx	r4
    3118:	2801      	cmp	r0, #1
    311a:	d1fb      	bne.n	3114 <spi_flash_enable+0x5c>
    311c:	e015      	b.n	314a <spi_flash_enable+0x92>
	volatile unsigned long tmp;
	unsigned char* cmd = (unsigned char*) &tmp;

	cmd[0] = 0xb9;

	nm_write_reg(SPI_FLASH_DATA_CNT, 0);
    311e:	2100      	movs	r1, #0
    3120:	4817      	ldr	r0, [pc, #92]	; (3180 <spi_flash_enable+0xc8>)
    3122:	4c16      	ldr	r4, [pc, #88]	; (317c <spi_flash_enable+0xc4>)
    3124:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
    3126:	21b9      	movs	r1, #185	; 0xb9
    3128:	4816      	ldr	r0, [pc, #88]	; (3184 <spi_flash_enable+0xcc>)
    312a:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF_DIR, 0x1);
    312c:	2101      	movs	r1, #1
    312e:	4816      	ldr	r0, [pc, #88]	; (3188 <spi_flash_enable+0xd0>)
    3130:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
    3132:	2100      	movs	r1, #0
    3134:	4815      	ldr	r0, [pc, #84]	; (318c <spi_flash_enable+0xd4>)
    3136:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_CMD_CNT, 1 | (1 << 7));
    3138:	2181      	movs	r1, #129	; 0x81
    313a:	4815      	ldr	r0, [pc, #84]	; (3190 <spi_flash_enable+0xd8>)
    313c:	47a0      	blx	r4
	while(nm_read_reg(SPI_FLASH_TR_DONE) != 1);
    313e:	4e15      	ldr	r6, [pc, #84]	; (3194 <spi_flash_enable+0xdc>)
    3140:	4c15      	ldr	r4, [pc, #84]	; (3198 <spi_flash_enable+0xe0>)
    3142:	0030      	movs	r0, r6
    3144:	47a0      	blx	r4
    3146:	2801      	cmp	r0, #1
    3148:	d1fb      	bne.n	3142 <spi_flash_enable+0x8a>
		} else {
			spi_flash_enter_low_power_mode();
		}
		/* Disable pinmux to SPI flash to minimize leakage. */
		u32Val &= ~((0x7777ul) << 12);
		u32Val |= ((0x0010ul) << 12);
    314a:	490a      	ldr	r1, [pc, #40]	; (3174 <spi_flash_enable+0xbc>)
    314c:	9b01      	ldr	r3, [sp, #4]
    314e:	4019      	ands	r1, r3
    3150:	2380      	movs	r3, #128	; 0x80
    3152:	025b      	lsls	r3, r3, #9
    3154:	4319      	orrs	r1, r3
    3156:	9101      	str	r1, [sp, #4]
		nm_write_reg(0x1410, u32Val);
    3158:	4804      	ldr	r0, [pc, #16]	; (316c <spi_flash_enable+0xb4>)
    315a:	4b08      	ldr	r3, [pc, #32]	; (317c <spi_flash_enable+0xc4>)
    315c:	4798      	blx	r3
	}
ERR1:
	return s8Ret;
}
    315e:	0028      	movs	r0, r5
    3160:	b002      	add	sp, #8
    3162:	bd70      	pop	{r4, r5, r6, pc}
    3164:	000014fd 	.word	0x000014fd
    3168:	0000039f 	.word	0x0000039f
    316c:	00001410 	.word	0x00001410
    3170:	00001945 	.word	0x00001945
    3174:	f8888fff 	.word	0xf8888fff
    3178:	01111000 	.word	0x01111000
    317c:	00001951 	.word	0x00001951
    3180:	00010208 	.word	0x00010208
    3184:	0001020c 	.word	0x0001020c
    3188:	00010214 	.word	0x00010214
    318c:	0001021c 	.word	0x0001021c
    3190:	00010204 	.word	0x00010204
    3194:	00010218 	.word	0x00010218
    3198:	00001939 	.word	0x00001939

0000319c <spi_init>:
 */
enum status_code spi_init(
		struct spi_module *const module,
		Sercom *const hw,
		const struct spi_config *const config)
{
    319c:	b5f0      	push	{r4, r5, r6, r7, lr}
    319e:	b08b      	sub	sp, #44	; 0x2c
    31a0:	0005      	movs	r5, r0
    31a2:	000c      	movs	r4, r1
    31a4:	0016      	movs	r6, r2
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize device instance */
	module->hw = hw;
    31a6:	6029      	str	r1, [r5, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    31a8:	680b      	ldr	r3, [r1, #0]
#  if SPI_CALLBACK_MODE == false
		/* Check if config is valid */
		return _spi_check_config(module, config);
#  else
		return STATUS_ERR_DENIED;
    31aa:	201c      	movs	r0, #28
	module->hw = hw;

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    31ac:	079b      	lsls	r3, r3, #30
    31ae:	d500      	bpl.n	31b2 <spi_init+0x16>
    31b0:	e0e7      	b.n	3382 <spi_init+0x1e6>
		return STATUS_ERR_DENIED;
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    31b2:	680b      	ldr	r3, [r1, #0]
		return STATUS_BUSY;
    31b4:	3817      	subs	r0, #23
		return STATUS_ERR_DENIED;
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    31b6:	07db      	lsls	r3, r3, #31
    31b8:	d500      	bpl.n	31bc <spi_init+0x20>
    31ba:	e0e2      	b.n	3382 <spi_init+0x1e6>
		return STATUS_BUSY;
	}

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    31bc:	0008      	movs	r0, r1
    31be:	4b72      	ldr	r3, [pc, #456]	; (3388 <spi_init+0x1ec>)
    31c0:	4798      	blx	r3
	uint32_t pm_index, gclk_index;
#if (SAML21)
	if (sercom_index == 5) {
    31c2:	2805      	cmp	r0, #5
    31c4:	d100      	bne.n	31c8 <spi_init+0x2c>
    31c6:	e0d5      	b.n	3374 <spi_init+0x1d8>
#  else
		return STATUS_ERR_INVALID_ARG;
#  endif
	} else {
		pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
		gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    31c8:	0003      	movs	r3, r0
    31ca:	3312      	adds	r3, #18
		case SYSTEM_CLOCK_APB_APBB:
			MCLK->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			MCLK->APBCMASK.reg |= mask;
    31cc:	4f6f      	ldr	r7, [pc, #444]	; (338c <spi_init+0x1f0>)
    31ce:	69f9      	ldr	r1, [r7, #28]
    31d0:	2201      	movs	r2, #1
    31d2:	4082      	lsls	r2, r0
    31d4:	430a      	orrs	r2, r1
    31d6:	61fa      	str	r2, [r7, #28]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    31d8:	a909      	add	r1, sp, #36	; 0x24
    31da:	2724      	movs	r7, #36	; 0x24
    31dc:	5df2      	ldrb	r2, [r6, r7]
    31de:	700a      	strb	r2, [r1, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    31e0:	b2db      	uxtb	r3, r3
    31e2:	9301      	str	r3, [sp, #4]
    31e4:	0018      	movs	r0, r3
    31e6:	4b6a      	ldr	r3, [pc, #424]	; (3390 <spi_init+0x1f4>)
    31e8:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    31ea:	9801      	ldr	r0, [sp, #4]
    31ec:	4b69      	ldr	r3, [pc, #420]	; (3394 <spi_init+0x1f8>)
    31ee:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    31f0:	5df0      	ldrb	r0, [r6, r7]
    31f2:	2100      	movs	r1, #0
    31f4:	4b68      	ldr	r3, [pc, #416]	; (3398 <spi_init+0x1fc>)
    31f6:	4798      	blx	r3

#  if CONF_SPI_MASTER_ENABLE == true
	if (config->mode == SPI_MODE_MASTER) {
    31f8:	7833      	ldrb	r3, [r6, #0]
    31fa:	2b01      	cmp	r3, #1
    31fc:	d103      	bne.n	3206 <spi_init+0x6a>
		/* Set the SERCOM in SPI master mode */
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x3);
    31fe:	6822      	ldr	r2, [r4, #0]
    3200:	330b      	adds	r3, #11
    3202:	4313      	orrs	r3, r2
    3204:	6023      	str	r3, [r4, #0]
	}
#  endif

#  if CONF_SPI_SLAVE_ENABLE == true
	if (config->mode == SPI_MODE_SLAVE) {
    3206:	7833      	ldrb	r3, [r6, #0]
    3208:	2b00      	cmp	r3, #0
    320a:	d103      	bne.n	3214 <spi_init+0x78>
		/* Set the SERCOM in SPI slave mode */
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x2);
    320c:	6822      	ldr	r2, [r4, #0]
    320e:	3308      	adds	r3, #8
    3210:	4313      	orrs	r3, r2
    3212:	6023      	str	r3, [r4, #0]
    3214:	002b      	movs	r3, r5
    3216:	330c      	adds	r3, #12
    3218:	0029      	movs	r1, r5
    321a:	3128      	adds	r1, #40	; 0x28
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
		module->callback[i]        = NULL;
    321c:	2200      	movs	r2, #0
    321e:	c304      	stmia	r3!, {r2}
	/* Temporary variables */
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
    3220:	4299      	cmp	r1, r3
    3222:	d1fc      	bne.n	321e <spi_init+0x82>
		module->callback[i]        = NULL;
	}
	module->tx_buffer_ptr              = NULL;
    3224:	2300      	movs	r3, #0
    3226:	62eb      	str	r3, [r5, #44]	; 0x2c
	module->rx_buffer_ptr              = NULL;
    3228:	62ab      	str	r3, [r5, #40]	; 0x28
	module->remaining_tx_buffer_length = 0x0000;
    322a:	2400      	movs	r4, #0
    322c:	86ab      	strh	r3, [r5, #52]	; 0x34
	module->remaining_rx_buffer_length = 0x0000;
    322e:	862b      	strh	r3, [r5, #48]	; 0x30
	module->registered_callback        = 0x00;
    3230:	3336      	adds	r3, #54	; 0x36
    3232:	54ec      	strb	r4, [r5, r3]
	module->enabled_callback           = 0x00;
    3234:	3301      	adds	r3, #1
    3236:	54ec      	strb	r4, [r5, r3]
	module->status                     = STATUS_OK;
    3238:	3301      	adds	r3, #1
    323a:	54ec      	strb	r4, [r5, r3]
	module->dir                        = SPI_DIRECTION_IDLE;
    323c:	3b35      	subs	r3, #53	; 0x35
    323e:	726b      	strb	r3, [r5, #9]
	module->locked                     = false;
    3240:	712c      	strb	r4, [r5, #4]
	/*
	 * Set interrupt handler and register SPI software module struct in
	 * look-up table
	 */
	instance_index = _sercom_get_sercom_inst_index(module->hw);
    3242:	6828      	ldr	r0, [r5, #0]
    3244:	4b50      	ldr	r3, [pc, #320]	; (3388 <spi_init+0x1ec>)
    3246:	4798      	blx	r3
    3248:	0007      	movs	r7, r0
	_sercom_set_handler(instance_index, _spi_interrupt_handler);
    324a:	4954      	ldr	r1, [pc, #336]	; (339c <spi_init+0x200>)
    324c:	4b54      	ldr	r3, [pc, #336]	; (33a0 <spi_init+0x204>)
    324e:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    3250:	00b8      	lsls	r0, r7, #2
    3252:	4b54      	ldr	r3, [pc, #336]	; (33a4 <spi_init+0x208>)
    3254:	50c5      	str	r5, [r0, r3]
	/* Sanity check arguments */
	Assert(module);
	Assert(config);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    3256:	682f      	ldr	r7, [r5, #0]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    3258:	ab04      	add	r3, sp, #16
    325a:	2280      	movs	r2, #128	; 0x80
    325c:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    325e:	705c      	strb	r4, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    3260:	3a7f      	subs	r2, #127	; 0x7f
    3262:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    3264:	70dc      	strb	r4, [r3, #3]
	Sercom *const hw = module->hw;

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	if(config->mode == SPI_MODE_SLAVE) {
    3266:	7833      	ldrb	r3, [r6, #0]
    3268:	2b00      	cmp	r3, #0
    326a:	d102      	bne.n	3272 <spi_init+0xd6>
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    326c:	2200      	movs	r2, #0
    326e:	ab04      	add	r3, sp, #16
    3270:	709a      	strb	r2, [r3, #2]
	}

	uint32_t pad_pinmuxes[] = {
    3272:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    3274:	9305      	str	r3, [sp, #20]
    3276:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    3278:	9306      	str	r3, [sp, #24]
    327a:	6b33      	ldr	r3, [r6, #48]	; 0x30
    327c:	9307      	str	r3, [sp, #28]
    327e:	6b73      	ldr	r3, [r6, #52]	; 0x34
    3280:	9308      	str	r3, [sp, #32]
    3282:	2400      	movs	r4, #0
    3284:	b2e1      	uxtb	r1, r4
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    3286:	00a3      	lsls	r3, r4, #2
    3288:	aa05      	add	r2, sp, #20
    328a:	5898      	ldr	r0, [r3, r2]

		if (current_pinmux == PINMUX_DEFAULT) {
    328c:	2800      	cmp	r0, #0
    328e:	d102      	bne.n	3296 <spi_init+0xfa>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    3290:	0038      	movs	r0, r7
    3292:	4b45      	ldr	r3, [pc, #276]	; (33a8 <spi_init+0x20c>)
    3294:	4798      	blx	r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
    3296:	1c43      	adds	r3, r0, #1
    3298:	d006      	beq.n	32a8 <spi_init+0x10c>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    329a:	ab02      	add	r3, sp, #8
    329c:	7218      	strb	r0, [r3, #8]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    329e:	0c00      	lsrs	r0, r0, #16
    32a0:	b2c0      	uxtb	r0, r0
    32a2:	a904      	add	r1, sp, #16
    32a4:	4b41      	ldr	r3, [pc, #260]	; (33ac <spi_init+0x210>)
    32a6:	4798      	blx	r3
    32a8:	3401      	adds	r4, #1
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    32aa:	2c04      	cmp	r4, #4
    32ac:	d1ea      	bne.n	3284 <spi_init+0xe8>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
		}
	}

	module->mode             = config->mode;
    32ae:	7833      	ldrb	r3, [r6, #0]
    32b0:	716b      	strb	r3, [r5, #5]
	module->character_size   = config->character_size;
    32b2:	7c33      	ldrb	r3, [r6, #16]
    32b4:	71ab      	strb	r3, [r5, #6]
	module->receiver_enabled = config->receiver_enable;
    32b6:	7cb3      	ldrb	r3, [r6, #18]
    32b8:	71eb      	strb	r3, [r5, #7]
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	module->master_slave_select_enable = config->master_slave_select_enable;
    32ba:	7d33      	ldrb	r3, [r6, #20]
    32bc:	722b      	strb	r3, [r5, #8]
#  endif

#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to write to BAUD register */
	uint16_t baud = 0;
    32be:	2200      	movs	r2, #0
    32c0:	ab02      	add	r3, sp, #8
    32c2:	80da      	strh	r2, [r3, #6]
	/* Value to write to CTRLB register */
	uint32_t ctrlb = 0;

# if CONF_SPI_MASTER_ENABLE == true
	/* Find baud value and write it */
	if (config->mode == SPI_MODE_MASTER) {
    32c4:	7833      	ldrb	r3, [r6, #0]
    32c6:	2b01      	cmp	r3, #1
    32c8:	d114      	bne.n	32f4 <spi_init+0x158>
		/* Find frequency of the internal SERCOMi_GCLK_ID_CORE */
		uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    32ca:	6828      	ldr	r0, [r5, #0]
    32cc:	4b2e      	ldr	r3, [pc, #184]	; (3388 <spi_init+0x1ec>)
    32ce:	4798      	blx	r3
		uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
		uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
    32d0:	3012      	adds	r0, #18
    32d2:	b2c0      	uxtb	r0, r0
    32d4:	4b36      	ldr	r3, [pc, #216]	; (33b0 <spi_init+0x214>)
    32d6:	4798      	blx	r3
    32d8:	0001      	movs	r1, r0

		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
    32da:	ab02      	add	r3, sp, #8
    32dc:	1d9a      	adds	r2, r3, #6
    32de:	69b0      	ldr	r0, [r6, #24]
    32e0:	4b34      	ldr	r3, [pc, #208]	; (33b4 <spi_init+0x218>)
    32e2:	4798      	blx	r3
    32e4:	0003      	movs	r3, r0
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
    32e6:	2017      	movs	r0, #23
		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
    32e8:	2b00      	cmp	r3, #0
    32ea:	d14a      	bne.n	3382 <spi_init+0x1e6>
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
		}

		spi_module->BAUD.reg = (uint8_t)baud;
    32ec:	ab02      	add	r3, sp, #8
    32ee:	3306      	adds	r3, #6
    32f0:	781b      	ldrb	r3, [r3, #0]
    32f2:	733b      	strb	r3, [r7, #12]
	}
# endif
# if CONF_SPI_SLAVE_ENABLE == true
	if (config->mode == SPI_MODE_SLAVE) {
    32f4:	7833      	ldrb	r3, [r6, #0]
    32f6:	2b00      	cmp	r3, #0
    32f8:	d10f      	bne.n	331a <spi_init+0x17e>
		/* Set frame format */
		ctrla = config->mode_specific.slave.frame_format;
    32fa:	69b0      	ldr	r0, [r6, #24]

		/* Set address mode */
		ctrlb = config->mode_specific.slave.address_mode;
    32fc:	8bb3      	ldrh	r3, [r6, #28]

		/* Set address and address mask*/
		spi_module->ADDR.reg |=
    32fe:	6a79      	ldr	r1, [r7, #36]	; 0x24
    3300:	7ff2      	ldrb	r2, [r6, #31]
    3302:	0412      	lsls	r2, r2, #16
    3304:	7fb4      	ldrb	r4, [r6, #30]
    3306:	4322      	orrs	r2, r4
    3308:	430a      	orrs	r2, r1
    330a:	627a      	str	r2, [r7, #36]	; 0x24
				(config->mode_specific.slave.address      << SERCOM_SPI_ADDR_ADDR_Pos) |
				(config->mode_specific.slave.address_mask << SERCOM_SPI_ADDR_ADDRMASK_Pos);

		if (config->mode_specific.slave.preload_enable) {
    330c:	2220      	movs	r2, #32
    330e:	5cb2      	ldrb	r2, [r6, r2]
    3310:	2a00      	cmp	r2, #0
    3312:	d004      	beq.n	331e <spi_init+0x182>
			/* Enable pre-loading of shift register */
			ctrlb |= SERCOM_SPI_CTRLB_PLOADEN;
    3314:	2140      	movs	r1, #64	; 0x40
    3316:	430b      	orrs	r3, r1
    3318:	e001      	b.n	331e <spi_init+0x182>
	uint16_t baud = 0;
#  endif
	/* Value to write to CTRLA register */
	uint32_t ctrla = 0;
	/* Value to write to CTRLB register */
	uint32_t ctrlb = 0;
    331a:	2300      	movs	r3, #0
#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to write to BAUD register */
	uint16_t baud = 0;
#  endif
	/* Value to write to CTRLA register */
	uint32_t ctrla = 0;
    331c:	2000      	movs	r0, #0

	/* Set clock polarity and clock phase */
	ctrla |= config->transfer_mode;

	/* Set MUX setting */
	ctrla |= config->mux_setting;
    331e:	6872      	ldr	r2, [r6, #4]
    3320:	68b1      	ldr	r1, [r6, #8]
    3322:	430a      	orrs	r2, r1
    3324:	68f1      	ldr	r1, [r6, #12]
    3326:	430a      	orrs	r2, r1
    3328:	4302      	orrs	r2, r0

	/* Set SPI character size */
	ctrlb |= config->character_size;
    332a:	7c31      	ldrb	r1, [r6, #16]
    332c:	430b      	orrs	r3, r1

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    332e:	7c71      	ldrb	r1, [r6, #17]
    3330:	2900      	cmp	r1, #0
    3332:	d103      	bne.n	333c <spi_init+0x1a0>
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
    3334:	4920      	ldr	r1, [pc, #128]	; (33b8 <spi_init+0x21c>)
    3336:	7889      	ldrb	r1, [r1, #2]
    3338:	0789      	lsls	r1, r1, #30
    333a:	d501      	bpl.n	3340 <spi_init+0x1a4>
		ctrla |= SERCOM_SPI_CTRLA_RUNSTDBY;
    333c:	2180      	movs	r1, #128	; 0x80
    333e:	430a      	orrs	r2, r1
	}

	if (config->receiver_enable) {
    3340:	7cb1      	ldrb	r1, [r6, #18]
    3342:	2900      	cmp	r1, #0
    3344:	d002      	beq.n	334c <spi_init+0x1b0>
		/* Enable receiver */
		ctrlb |= SERCOM_SPI_CTRLB_RXEN;
    3346:	2180      	movs	r1, #128	; 0x80
    3348:	0289      	lsls	r1, r1, #10
    334a:	430b      	orrs	r3, r1
	}
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	if (config->select_slave_low_detect_enable) {
    334c:	7cf1      	ldrb	r1, [r6, #19]
    334e:	2900      	cmp	r1, #0
    3350:	d002      	beq.n	3358 <spi_init+0x1bc>
		/* Enable Slave Select Low Detect */
		ctrlb |= SERCOM_SPI_CTRLB_SSDE;
    3352:	2180      	movs	r1, #128	; 0x80
    3354:	0089      	lsls	r1, r1, #2
    3356:	430b      	orrs	r3, r1
	}
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if (config->master_slave_select_enable) {
    3358:	7d31      	ldrb	r1, [r6, #20]
    335a:	2900      	cmp	r1, #0
    335c:	d002      	beq.n	3364 <spi_init+0x1c8>
		/* Enable Master Slave Select */
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
    335e:	2180      	movs	r1, #128	; 0x80
    3360:	0189      	lsls	r1, r1, #6
    3362:	430b      	orrs	r3, r1
	}
#  endif
	/* Write CTRLA register */
	spi_module->CTRLA.reg |= ctrla;
    3364:	6839      	ldr	r1, [r7, #0]
    3366:	430a      	orrs	r2, r1
    3368:	603a      	str	r2, [r7, #0]

	/* Write CTRLB register */
	spi_module->CTRLB.reg |= ctrlb;
    336a:	687a      	ldr	r2, [r7, #4]
    336c:	4313      	orrs	r3, r2
    336e:	607b      	str	r3, [r7, #4]

	return STATUS_OK;
    3370:	2000      	movs	r0, #0
    3372:	e006      	b.n	3382 <spi_init+0x1e6>
			break;
		case SYSTEM_CLOCK_APB_APBD:
			MCLK->APBDMASK.reg |= mask;
    3374:	4a05      	ldr	r2, [pc, #20]	; (338c <spi_init+0x1f0>)
    3376:	6a11      	ldr	r1, [r2, #32]
    3378:	2302      	movs	r3, #2
    337a:	430b      	orrs	r3, r1
    337c:	6213      	str	r3, [r2, #32]
	uint32_t pm_index, gclk_index;
#if (SAML21)
	if (sercom_index == 5) {
#  ifdef ID_SERCOM5
		pm_index     = MCLK_APBDMASK_SERCOM5_Pos;
		gclk_index   =  SERCOM5_GCLK_ID_CORE;
    337e:	2318      	movs	r3, #24
    3380:	e72a      	b.n	31d8 <spi_init+0x3c>
	_sercom_instances[instance_index] = module;
#endif

	/* Write configuration to module and return status code */
	return _spi_set_config(module, config);
}
    3382:	b00b      	add	sp, #44	; 0x2c
    3384:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3386:	46c0      	nop			; (mov r8, r8)
    3388:	00006965 	.word	0x00006965
    338c:	40000400 	.word	0x40000400
    3390:	00007715 	.word	0x00007715
    3394:	000076a5 	.word	0x000076a5
    3398:	00006795 	.word	0x00006795
    339c:	000034b1 	.word	0x000034b1
    33a0:	000069a5 	.word	0x000069a5
    33a4:	20001344 	.word	0x20001344
    33a8:	000067e1 	.word	0x000067e1
    33ac:	00007811 	.word	0x00007811
    33b0:	00007739 	.word	0x00007739
    33b4:	000065a5 	.word	0x000065a5
    33b8:	41002000 	.word	0x41002000

000033bc <spi_select_slave>:
 */
enum status_code spi_select_slave(
		struct spi_module *const module,
		struct spi_slave_inst *const slave,
		const bool select)
{
    33bc:	b510      	push	{r4, lr}
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
    33be:	7944      	ldrb	r4, [r0, #5]
		return STATUS_ERR_UNSUPPORTED_DEV;
    33c0:	2315      	movs	r3, #21
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
    33c2:	2c01      	cmp	r4, #1
    33c4:	d170      	bne.n	34a8 <spi_select_slave+0xec>
		return STATUS_ERR_UNSUPPORTED_DEV;
	}
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if(!(module->master_slave_select_enable))
    33c6:	7a04      	ldrb	r4, [r0, #8]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    33c8:	2300      	movs	r3, #0
	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
		return STATUS_ERR_UNSUPPORTED_DEV;
	}
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if(!(module->master_slave_select_enable))
    33ca:	2c00      	cmp	r4, #0
    33cc:	d16c      	bne.n	34a8 <spi_select_slave+0xec>
#  endif
	{
		if (select) {
    33ce:	2a00      	cmp	r2, #0
    33d0:	d05a      	beq.n	3488 <spi_select_slave+0xcc>
			/* Check if address recognition is enabled */
			if (slave->address_enabled) {
    33d2:	784b      	ldrb	r3, [r1, #1]
    33d4:	2b00      	cmp	r3, #0
    33d6:	d046      	beq.n	3466 <spi_select_slave+0xaa>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    33d8:	6803      	ldr	r3, [r0, #0]
    33da:	7e1b      	ldrb	r3, [r3, #24]
				/* Check if the module is ready to write the address */
				if (!spi_is_ready_to_write(module)) {
    33dc:	07db      	lsls	r3, r3, #31
    33de:	d410      	bmi.n	3402 <spi_select_slave+0x46>
					/* Not ready, do not select slave and return */
					port_pin_set_output_level(slave->ss_pin, true);
    33e0:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    33e2:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    33e4:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    33e6:	2900      	cmp	r1, #0
    33e8:	d104      	bne.n	33f4 <spi_select_slave+0x38>
		return &(ports[port_index]->Group[group_index]);
    33ea:	095a      	lsrs	r2, r3, #5
    33ec:	01d2      	lsls	r2, r2, #7
    33ee:	492f      	ldr	r1, [pc, #188]	; (34ac <spi_select_slave+0xf0>)
    33f0:	468c      	mov	ip, r1
    33f2:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    33f4:	211f      	movs	r1, #31
    33f6:	400b      	ands	r3, r1
    33f8:	391e      	subs	r1, #30
    33fa:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    33fc:	6191      	str	r1, [r2, #24]
					return STATUS_BUSY;
    33fe:	2305      	movs	r3, #5
    3400:	e052      	b.n	34a8 <spi_select_slave+0xec>
				}

				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
    3402:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    3404:	09dc      	lsrs	r4, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    3406:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    3408:	2c00      	cmp	r4, #0
    340a:	d104      	bne.n	3416 <spi_select_slave+0x5a>
		return &(ports[port_index]->Group[group_index]);
    340c:	095a      	lsrs	r2, r3, #5
    340e:	01d2      	lsls	r2, r2, #7
    3410:	4c26      	ldr	r4, [pc, #152]	; (34ac <spi_select_slave+0xf0>)
    3412:	46a4      	mov	ip, r4
    3414:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    3416:	241f      	movs	r4, #31
    3418:	4023      	ands	r3, r4
    341a:	3c1e      	subs	r4, #30
    341c:	409c      	lsls	r4, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    341e:	6154      	str	r4, [r2, #20]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    3420:	6803      	ldr	r3, [r0, #0]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    3422:	7e1a      	ldrb	r2, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    3424:	07d2      	lsls	r2, r2, #31
    3426:	d501      	bpl.n	342c <spi_select_slave+0x70>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    3428:	788a      	ldrb	r2, [r1, #2]
    342a:	629a      	str	r2, [r3, #40]	; 0x28

				/* Write address to slave */
				spi_write(module, slave->address);

				if (!(module->receiver_enabled)) {
    342c:	79c2      	ldrb	r2, [r0, #7]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    342e:	2300      	movs	r3, #0
				port_pin_set_output_level(slave->ss_pin, false);

				/* Write address to slave */
				spi_write(module, slave->address);

				if (!(module->receiver_enabled)) {
    3430:	2a00      	cmp	r2, #0
    3432:	d139      	bne.n	34a8 <spi_select_slave+0xec>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    3434:	6802      	ldr	r2, [r0, #0]
					/* Flush contents of shift register shifted back from slave */
					while (!spi_is_ready_to_read(module)) {
    3436:	2104      	movs	r1, #4

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    3438:	7e13      	ldrb	r3, [r2, #24]
    343a:	420b      	tst	r3, r1
    343c:	d0fc      	beq.n	3438 <spi_select_slave+0x7c>
    343e:	7e11      	ldrb	r1, [r2, #24]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    3440:	2300      	movs	r3, #0
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    3442:	0749      	lsls	r1, r1, #29
    3444:	d530      	bpl.n	34a8 <spi_select_slave+0xec>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    3446:	8b53      	ldrh	r3, [r2, #26]
    3448:	075b      	lsls	r3, r3, #29
    344a:	d503      	bpl.n	3454 <spi_select_slave+0x98>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    344c:	8b51      	ldrh	r1, [r2, #26]
    344e:	2304      	movs	r3, #4
    3450:	430b      	orrs	r3, r1
    3452:	8353      	strh	r3, [r2, #26]
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    3454:	7983      	ldrb	r3, [r0, #6]
    3456:	2b01      	cmp	r3, #1
    3458:	d102      	bne.n	3460 <spi_select_slave+0xa4>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    345a:	6a93      	ldr	r3, [r2, #40]	; 0x28
    345c:	2300      	movs	r3, #0
    345e:	e023      	b.n	34a8 <spi_select_slave+0xec>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    3460:	6a93      	ldr	r3, [r2, #40]	; 0x28
    3462:	2300      	movs	r3, #0
    3464:	e020      	b.n	34a8 <spi_select_slave+0xec>
					uint16_t flush = 0;
					spi_read(module, &flush);
				}
			} else {
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
    3466:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    3468:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    346a:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    346c:	2900      	cmp	r1, #0
    346e:	d104      	bne.n	347a <spi_select_slave+0xbe>
		return &(ports[port_index]->Group[group_index]);
    3470:	095a      	lsrs	r2, r3, #5
    3472:	01d2      	lsls	r2, r2, #7
    3474:	490d      	ldr	r1, [pc, #52]	; (34ac <spi_select_slave+0xf0>)
    3476:	468c      	mov	ip, r1
    3478:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    347a:	211f      	movs	r1, #31
    347c:	400b      	ands	r3, r1
    347e:	391e      	subs	r1, #30
    3480:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    3482:	6151      	str	r1, [r2, #20]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    3484:	2300      	movs	r3, #0
    3486:	e00f      	b.n	34a8 <spi_select_slave+0xec>
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
			}
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
    3488:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    348a:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    348c:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    348e:	2900      	cmp	r1, #0
    3490:	d104      	bne.n	349c <spi_select_slave+0xe0>
		return &(ports[port_index]->Group[group_index]);
    3492:	095a      	lsrs	r2, r3, #5
    3494:	01d2      	lsls	r2, r2, #7
    3496:	4905      	ldr	r1, [pc, #20]	; (34ac <spi_select_slave+0xf0>)
    3498:	468c      	mov	ip, r1
    349a:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    349c:	211f      	movs	r1, #31
    349e:	400b      	ands	r3, r1
    34a0:	391e      	subs	r1, #30
    34a2:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    34a4:	6191      	str	r1, [r2, #24]
		}
	}
	return STATUS_OK;
    34a6:	2300      	movs	r3, #0
}
    34a8:	0018      	movs	r0, r3
    34aa:	bd10      	pop	{r4, pc}
    34ac:	40002800 	.word	0x40002800

000034b0 <_spi_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _spi_interrupt_handler(
		uint8_t instance)
{
    34b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Get device instance from the look-up table */
	struct spi_module *module
    34b2:	0080      	lsls	r0, r0, #2
    34b4:	4b7b      	ldr	r3, [pc, #492]	; (36a4 <_spi_interrupt_handler+0x1f4>)
    34b6:	58c4      	ldr	r4, [r0, r3]
		= (struct spi_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    34b8:	6826      	ldr	r6, [r4, #0]

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
			module->enabled_callback & module->registered_callback;
    34ba:	2337      	movs	r3, #55	; 0x37

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
    34bc:	5ce3      	ldrb	r3, [r4, r3]
    34be:	2236      	movs	r2, #54	; 0x36
    34c0:	5ca7      	ldrb	r7, [r4, r2]
    34c2:	401f      	ands	r7, r3
			module->enabled_callback & module->registered_callback;

	/* Read and mask interrupt flag register */
	uint16_t interrupt_status = spi_hw->INTFLAG.reg;
    34c4:	7e33      	ldrb	r3, [r6, #24]
	interrupt_status &= spi_hw->INTENSET.reg;
    34c6:	7db5      	ldrb	r5, [r6, #22]
    34c8:	401d      	ands	r5, r3

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
    34ca:	07eb      	lsls	r3, r5, #31
    34cc:	d543      	bpl.n	3556 <_spi_interrupt_handler+0xa6>
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    34ce:	7963      	ldrb	r3, [r4, #5]
    34d0:	2b01      	cmp	r3, #1
    34d2:	d116      	bne.n	3502 <_spi_interrupt_handler+0x52>
			(module->dir == SPI_DIRECTION_READ)) {
    34d4:	7a63      	ldrb	r3, [r4, #9]
	interrupt_status &= spi_hw->INTENSET.reg;

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    34d6:	2b00      	cmp	r3, #0
    34d8:	d10f      	bne.n	34fa <_spi_interrupt_handler+0x4a>
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Write dummy byte */
	spi_hw->DATA.reg = dummy_write;
    34da:	4b73      	ldr	r3, [pc, #460]	; (36a8 <_spi_interrupt_handler+0x1f8>)
    34dc:	881b      	ldrh	r3, [r3, #0]
    34de:	62b3      	str	r3, [r6, #40]	; 0x28

	/* Decrement remaining dummy buffer length */
	module->remaining_dummy_buffer_length--;
    34e0:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    34e2:	3b01      	subs	r3, #1
    34e4:	b29b      	uxth	r3, r3
    34e6:	8663      	strh	r3, [r4, #50]	; 0x32
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
			(module->dir == SPI_DIRECTION_READ)) {
			/* Send dummy byte when reading in master mode */
			_spi_write_dummy(module);
			if (module->remaining_dummy_buffer_length == 0) {
    34e8:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    34ea:	b29b      	uxth	r3, r3
    34ec:	2b00      	cmp	r3, #0
    34ee:	d101      	bne.n	34f4 <_spi_interrupt_handler+0x44>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
    34f0:	3301      	adds	r3, #1
    34f2:	7533      	strb	r3, [r6, #20]
		}
#  endif

		if (0
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
    34f4:	7963      	ldrb	r3, [r4, #5]
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
			}
		}
#  endif

		if (0
    34f6:	2b01      	cmp	r3, #1
    34f8:	d103      	bne.n	3502 <_spi_interrupt_handler+0x52>
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
			(module->dir != SPI_DIRECTION_READ))
    34fa:	7a63      	ldrb	r3, [r4, #9]
		}
#  endif

		if (0
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
    34fc:	2b00      	cmp	r3, #0
    34fe:	d105      	bne.n	350c <_spi_interrupt_handler+0x5c>
    3500:	e029      	b.n	3556 <_spi_interrupt_handler+0xa6>
			(module->dir != SPI_DIRECTION_READ))
#  endif
#  if CONF_SPI_SLAVE_ENABLE == true
		|| ((module->mode == SPI_MODE_SLAVE) &&
    3502:	2b00      	cmp	r3, #0
    3504:	d127      	bne.n	3556 <_spi_interrupt_handler+0xa6>
			(module->dir != SPI_DIRECTION_READ))
    3506:	7a63      	ldrb	r3, [r4, #9]
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
			(module->dir != SPI_DIRECTION_READ))
#  endif
#  if CONF_SPI_SLAVE_ENABLE == true
		|| ((module->mode == SPI_MODE_SLAVE) &&
    3508:	2b00      	cmp	r3, #0
    350a:	d024      	beq.n	3556 <_spi_interrupt_handler+0xa6>
 */
static void _spi_write(
		struct spi_module *const module)
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    350c:	6820      	ldr	r0, [r4, #0]

	/* Write value will be at least 8-bits long */
	uint16_t data_to_send = *(module->tx_buffer_ptr);
    350e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    3510:	780b      	ldrb	r3, [r1, #0]
    3512:	b2da      	uxtb	r2, r3
	/* Increment 8-bit pointer */
	(module->tx_buffer_ptr)++;
    3514:	1c4b      	adds	r3, r1, #1
    3516:	62e3      	str	r3, [r4, #44]	; 0x2c

	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    3518:	79a3      	ldrb	r3, [r4, #6]
    351a:	2b01      	cmp	r3, #1
    351c:	d001      	beq.n	3522 <_spi_interrupt_handler+0x72>
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Write value will be at least 8-bits long */
	uint16_t data_to_send = *(module->tx_buffer_ptr);
    351e:	b293      	uxth	r3, r2
    3520:	e004      	b.n	352c <_spi_interrupt_handler+0x7c>
	/* Increment 8-bit pointer */
	(module->tx_buffer_ptr)++;

	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
		data_to_send |= ((*(module->tx_buffer_ptr)) << 8);
    3522:	784b      	ldrb	r3, [r1, #1]
    3524:	021b      	lsls	r3, r3, #8
    3526:	4313      	orrs	r3, r2
		/* Increment 8-bit pointer */
		(module->tx_buffer_ptr)++;
    3528:	3102      	adds	r1, #2
    352a:	62e1      	str	r1, [r4, #44]	; 0x2c
	}

	/* Write the data to send*/
	spi_hw->DATA.reg = data_to_send & SERCOM_SPI_DATA_MASK;
    352c:	05db      	lsls	r3, r3, #23
    352e:	0ddb      	lsrs	r3, r3, #23
    3530:	6283      	str	r3, [r0, #40]	; 0x28

	/* Decrement remaining buffer length */
	(module->remaining_tx_buffer_length)--;
    3532:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
    3534:	3b01      	subs	r3, #1
    3536:	b29b      	uxth	r3, r3
    3538:	86a3      	strh	r3, [r4, #52]	; 0x34
			(module->dir != SPI_DIRECTION_READ))
#  endif
		) {
			/* Write next byte from buffer */
			_spi_write(module);
			if (module->remaining_tx_buffer_length == 0) {
    353a:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
    353c:	b29b      	uxth	r3, r3
    353e:	2b00      	cmp	r3, #0
    3540:	d109      	bne.n	3556 <_spi_interrupt_handler+0xa6>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
    3542:	3301      	adds	r3, #1
    3544:	7533      	strb	r3, [r6, #20]

				if (module->dir == SPI_DIRECTION_WRITE &&
    3546:	7a63      	ldrb	r3, [r4, #9]
    3548:	2b01      	cmp	r3, #1
    354a:	d104      	bne.n	3556 <_spi_interrupt_handler+0xa6>
    354c:	79e3      	ldrb	r3, [r4, #7]
    354e:	2b00      	cmp	r3, #0
    3550:	d101      	bne.n	3556 <_spi_interrupt_handler+0xa6>
						!(module->receiver_enabled)) {
					/* Enable the Data Register transmit complete Interrupt */
					spi_hw->INTENSET.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    3552:	3302      	adds	r3, #2
    3554:	75b3      	strb	r3, [r6, #22]
			}
		}
	}

	/* Receive complete interrupt*/
	if (interrupt_status & SPI_INTERRUPT_FLAG_RX_COMPLETE) {
    3556:	076b      	lsls	r3, r5, #29
    3558:	d561      	bpl.n	361e <_spi_interrupt_handler+0x16e>
		/* Check for overflow */
		if (spi_hw->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    355a:	8b73      	ldrh	r3, [r6, #26]
    355c:	075b      	lsls	r3, r3, #29
    355e:	d514      	bpl.n	358a <_spi_interrupt_handler+0xda>
			if (module->dir != SPI_DIRECTION_WRITE) {
    3560:	7a63      	ldrb	r3, [r4, #9]
    3562:	2b01      	cmp	r3, #1
    3564:	d00b      	beq.n	357e <_spi_interrupt_handler+0xce>
				/* Store the error code */
				module->status = STATUS_ERR_OVERFLOW;
    3566:	221e      	movs	r2, #30
    3568:	2338      	movs	r3, #56	; 0x38
    356a:	54e2      	strb	r2, [r4, r3]

				/* End transaction */
				module->dir = SPI_DIRECTION_IDLE;
    356c:	3b35      	subs	r3, #53	; 0x35
    356e:	7263      	strb	r3, [r4, #9]

				spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE |
    3570:	3302      	adds	r3, #2
    3572:	7533      	strb	r3, [r6, #20]
						SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
				/* Run callback if registered and enabled */
				if (callback_mask & (1 << SPI_CALLBACK_ERROR)) {
    3574:	073b      	lsls	r3, r7, #28
    3576:	d502      	bpl.n	357e <_spi_interrupt_handler+0xce>
					(module->callback[SPI_CALLBACK_ERROR])(module);
    3578:	0020      	movs	r0, r4
    357a:	69a3      	ldr	r3, [r4, #24]
    357c:	4798      	blx	r3
				}
			}
			/* Flush */
			uint16_t flush = spi_hw->DATA.reg;
    357e:	6ab3      	ldr	r3, [r6, #40]	; 0x28
			UNUSED(flush);
			/* Clear overflow flag */
			spi_hw->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    3580:	8b72      	ldrh	r2, [r6, #26]
    3582:	2304      	movs	r3, #4
    3584:	4313      	orrs	r3, r2
    3586:	8373      	strh	r3, [r6, #26]
    3588:	e049      	b.n	361e <_spi_interrupt_handler+0x16e>
		} else {
			if (module->dir == SPI_DIRECTION_WRITE) {
    358a:	7a63      	ldrb	r3, [r4, #9]
    358c:	2b01      	cmp	r3, #1
    358e:	d116      	bne.n	35be <_spi_interrupt_handler+0x10e>
 */
static void _spi_read_dummy(
		struct spi_module *const module)
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    3590:	6823      	ldr	r3, [r4, #0]
	uint16_t flush = 0;

	/* Read dummy byte */
	flush = spi_hw->DATA.reg;
    3592:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	UNUSED(flush);

	/* Decrement remaining dummy buffer length */
	module->remaining_dummy_buffer_length--;
    3594:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    3596:	3b01      	subs	r3, #1
    3598:	b29b      	uxth	r3, r3
    359a:	8663      	strh	r3, [r4, #50]	; 0x32
			spi_hw->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
		} else {
			if (module->dir == SPI_DIRECTION_WRITE) {
				/* Flush receive buffer when writing */
				_spi_read_dummy(module);
				if (module->remaining_dummy_buffer_length == 0) {
    359c:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    359e:	b29b      	uxth	r3, r3
    35a0:	2b00      	cmp	r3, #0
    35a2:	d13c      	bne.n	361e <_spi_interrupt_handler+0x16e>
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
    35a4:	3304      	adds	r3, #4
    35a6:	7533      	strb	r3, [r6, #20]
					module->status = STATUS_OK;
    35a8:	2200      	movs	r2, #0
    35aa:	3334      	adds	r3, #52	; 0x34
    35ac:	54e2      	strb	r2, [r4, r3]
					module->dir = SPI_DIRECTION_IDLE;
    35ae:	3b35      	subs	r3, #53	; 0x35
    35b0:	7263      	strb	r3, [r4, #9]
					/* Run callback if registered and enabled */
					if (callback_mask &
    35b2:	07fb      	lsls	r3, r7, #31
    35b4:	d533      	bpl.n	361e <_spi_interrupt_handler+0x16e>
							(1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
						(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])(module);
    35b6:	0020      	movs	r0, r4
    35b8:	68e3      	ldr	r3, [r4, #12]
    35ba:	4798      	blx	r3
    35bc:	e02f      	b.n	361e <_spi_interrupt_handler+0x16e>
 */
static void _spi_read(
		struct spi_module *const module)
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    35be:	6823      	ldr	r3, [r4, #0]

	uint16_t received_data = (spi_hw->DATA.reg & SERCOM_SPI_DATA_MASK);
    35c0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    35c2:	05db      	lsls	r3, r3, #23
    35c4:	0ddb      	lsrs	r3, r3, #23

	/* Read value will be at least 8-bits long */
	*(module->rx_buffer_ptr) = received_data;
    35c6:	b2da      	uxtb	r2, r3
    35c8:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    35ca:	700a      	strb	r2, [r1, #0]
	/* Increment 8-bit pointer */
	module->rx_buffer_ptr += 1;
    35cc:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    35ce:	1c51      	adds	r1, r2, #1
    35d0:	62a1      	str	r1, [r4, #40]	; 0x28

	if(module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    35d2:	79a1      	ldrb	r1, [r4, #6]
    35d4:	2901      	cmp	r1, #1
    35d6:	d104      	bne.n	35e2 <_spi_interrupt_handler+0x132>
		/* 9-bit data, write next received byte to the buffer */
		*(module->rx_buffer_ptr) = (received_data >> 8);
    35d8:	0a1b      	lsrs	r3, r3, #8
    35da:	7053      	strb	r3, [r2, #1]
		/* Increment 8-bit pointer */
		module->rx_buffer_ptr += 1;
    35dc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    35de:	3301      	adds	r3, #1
    35e0:	62a3      	str	r3, [r4, #40]	; 0x28
	}

	/* Decrement length of the remaining buffer */
	module->remaining_rx_buffer_length--;
    35e2:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    35e4:	3b01      	subs	r3, #1
    35e6:	b29b      	uxth	r3, r3
    35e8:	8623      	strh	r3, [r4, #48]	; 0x30
			} else {
				/* Read data register */
				_spi_read(module);

				/* Check if the last character have been received */
				if (module->remaining_rx_buffer_length == 0) {
    35ea:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    35ec:	b29b      	uxth	r3, r3
    35ee:	2b00      	cmp	r3, #0
    35f0:	d115      	bne.n	361e <_spi_interrupt_handler+0x16e>
					module->status = STATUS_OK;
    35f2:	2200      	movs	r2, #0
    35f4:	3338      	adds	r3, #56	; 0x38
    35f6:	54e2      	strb	r2, [r4, r3]
					/* Disable RX Complete Interrupt and set status */
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
    35f8:	3b34      	subs	r3, #52	; 0x34
    35fa:	7533      	strb	r3, [r6, #20]
					if(module->dir == SPI_DIRECTION_BOTH) {
    35fc:	7a63      	ldrb	r3, [r4, #9]
    35fe:	2b02      	cmp	r3, #2
    3600:	d105      	bne.n	360e <_spi_interrupt_handler+0x15e>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSCEIVED)) {
    3602:	077b      	lsls	r3, r7, #29
    3604:	d50b      	bpl.n	361e <_spi_interrupt_handler+0x16e>
							(module->callback[SPI_CALLBACK_BUFFER_TRANSCEIVED])(module);
    3606:	0020      	movs	r0, r4
    3608:	6963      	ldr	r3, [r4, #20]
    360a:	4798      	blx	r3
    360c:	e007      	b.n	361e <_spi_interrupt_handler+0x16e>
						}
					} else if (module->dir == SPI_DIRECTION_READ) {
    360e:	7a63      	ldrb	r3, [r4, #9]
    3610:	2b00      	cmp	r3, #0
    3612:	d104      	bne.n	361e <_spi_interrupt_handler+0x16e>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_RECEIVED)) {
    3614:	07bb      	lsls	r3, r7, #30
    3616:	d502      	bpl.n	361e <_spi_interrupt_handler+0x16e>
							(module->callback[SPI_CALLBACK_BUFFER_RECEIVED])(module);
    3618:	0020      	movs	r0, r4
    361a:	6923      	ldr	r3, [r4, #16]
    361c:	4798      	blx	r3
			}
		}
	}

	/* Transmit complete */
	if (interrupt_status & SPI_INTERRUPT_FLAG_TX_COMPLETE) {
    361e:	07ab      	lsls	r3, r5, #30
    3620:	d528      	bpl.n	3674 <_spi_interrupt_handler+0x1c4>
#  if CONF_SPI_SLAVE_ENABLE == true
		if (module->mode == SPI_MODE_SLAVE) {
    3622:	7963      	ldrb	r3, [r4, #5]
    3624:	2b00      	cmp	r3, #0
    3626:	d110      	bne.n	364a <_spi_interrupt_handler+0x19a>
			/* Transaction ended by master */

			/* Disable interrupts */
			spi_hw->INTENCLR.reg =
    3628:	3307      	adds	r3, #7
    362a:	7533      	strb	r3, [r6, #20]
					SPI_INTERRUPT_FLAG_TX_COMPLETE |
					SPI_INTERRUPT_FLAG_RX_COMPLETE |
					SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
			/* Clear interrupt flag */
			spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    362c:	3b05      	subs	r3, #5
    362e:	7633      	strb	r3, [r6, #24]


			/* Reset all status information */
			module->dir = SPI_DIRECTION_IDLE;
    3630:	3301      	adds	r3, #1
    3632:	7263      	strb	r3, [r4, #9]
			module->remaining_tx_buffer_length = 0;
    3634:	2300      	movs	r3, #0
    3636:	86a3      	strh	r3, [r4, #52]	; 0x34
			module->remaining_rx_buffer_length = 0;
    3638:	8623      	strh	r3, [r4, #48]	; 0x30
			module->status = STATUS_OK;
    363a:	3338      	adds	r3, #56	; 0x38
    363c:	2200      	movs	r2, #0
    363e:	54e2      	strb	r2, [r4, r3]

			if (callback_mask &
    3640:	06fb      	lsls	r3, r7, #27
    3642:	d502      	bpl.n	364a <_spi_interrupt_handler+0x19a>
					(1 << SPI_CALLBACK_SLAVE_TRANSMISSION_COMPLETE)) {
			(module->callback[SPI_CALLBACK_SLAVE_TRANSMISSION_COMPLETE])
    3644:	0020      	movs	r0, r4
    3646:	69e3      	ldr	r3, [r4, #28]
    3648:	4798      	blx	r3
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    364a:	7963      	ldrb	r3, [r4, #5]
    364c:	2b01      	cmp	r3, #1
    364e:	d111      	bne.n	3674 <_spi_interrupt_handler+0x1c4>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
    3650:	7a63      	ldrb	r3, [r4, #9]
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    3652:	2b01      	cmp	r3, #1
    3654:	d11b      	bne.n	368e <_spi_interrupt_handler+0x1de>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
    3656:	79e3      	ldrb	r3, [r4, #7]
    3658:	2b00      	cmp	r3, #0
    365a:	d118      	bne.n	368e <_spi_interrupt_handler+0x1de>
		  	/* Clear interrupt flag */
		 	spi_hw->INTENCLR.reg
					= SPI_INTERRUPT_FLAG_TX_COMPLETE;
    365c:	3302      	adds	r3, #2
    365e:	7533      	strb	r3, [r6, #20]
			/* Buffer sent with receiver disabled */
			module->dir = SPI_DIRECTION_IDLE;
    3660:	3301      	adds	r3, #1
    3662:	7263      	strb	r3, [r4, #9]
			module->status = STATUS_OK;
    3664:	2200      	movs	r2, #0
    3666:	3335      	adds	r3, #53	; 0x35
    3668:	54e2      	strb	r2, [r4, r3]
			/* Run callback if registered and enabled */
			if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
    366a:	07fb      	lsls	r3, r7, #31
    366c:	d502      	bpl.n	3674 <_spi_interrupt_handler+0x1c4>
				(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])
    366e:	0020      	movs	r0, r4
    3670:	68e3      	ldr	r3, [r4, #12]
    3672:	4798      	blx	r3
	}

#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
#  if CONF_SPI_SLAVE_ENABLE == true
		/* When a high to low transition is detected on the _SS pin in slave mode */
		if (interrupt_status & SPI_INTERRUPT_FLAG_SLAVE_SELECT_LOW) {
    3674:	072b      	lsls	r3, r5, #28
    3676:	d50a      	bpl.n	368e <_spi_interrupt_handler+0x1de>
			if (module->mode == SPI_MODE_SLAVE) {
    3678:	7963      	ldrb	r3, [r4, #5]
    367a:	2b00      	cmp	r3, #0
    367c:	d107      	bne.n	368e <_spi_interrupt_handler+0x1de>
				/* Disable interrupts */
				spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_SLAVE_SELECT_LOW;
    367e:	3308      	adds	r3, #8
    3680:	7533      	strb	r3, [r6, #20]
				/* Clear interrupt flag */
				spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_SLAVE_SELECT_LOW;
    3682:	7633      	strb	r3, [r6, #24]

				if (callback_mask & (1 << SPI_CALLBACK_SLAVE_SELECT_LOW)) {
    3684:	06bb      	lsls	r3, r7, #26
    3686:	d502      	bpl.n	368e <_spi_interrupt_handler+0x1de>
					(module->callback[SPI_CALLBACK_SLAVE_SELECT_LOW])(module);
    3688:	0020      	movs	r0, r4
    368a:	6a23      	ldr	r3, [r4, #32]
    368c:	4798      	blx	r3
#  endif
#  endif

#  ifdef FEATURE_SPI_ERROR_INTERRUPT
	/* When combined error happen */
	if (interrupt_status & SPI_INTERRUPT_FLAG_COMBINED_ERROR) {
    368e:	09ed      	lsrs	r5, r5, #7
    3690:	d007      	beq.n	36a2 <_spi_interrupt_handler+0x1f2>
		/* Disable interrupts */
		spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
    3692:	2380      	movs	r3, #128	; 0x80
    3694:	7533      	strb	r3, [r6, #20]
		/* Clear interrupt flag */
		spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
    3696:	7633      	strb	r3, [r6, #24]

		if (callback_mask & (1 << SPI_CALLBACK_COMBINED_ERROR)) {
    3698:	067b      	lsls	r3, r7, #25
    369a:	d502      	bpl.n	36a2 <_spi_interrupt_handler+0x1f2>
			(module->callback[SPI_CALLBACK_COMBINED_ERROR])(module);
    369c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    369e:	0020      	movs	r0, r4
    36a0:	4798      	blx	r3
		}
	}
#  endif
}
    36a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    36a4:	20001344 	.word	0x20001344
    36a8:	20000df8 	.word	0x20000df8

000036ac <adc_window_hit_callback>:
 *
 */
void adc_window_hit_callback(struct adc_module *const module)
{
	uint16_t adc_result_hex = 0;
	adc_result_hex = ADC->RESULT.reg;
    36ac:	4b07      	ldr	r3, [pc, #28]	; (36cc <adc_window_hit_callback+0x20>)
    36ae:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
	low_battery_status = true;
    36b0:	2101      	movs	r1, #1
    36b2:	4a07      	ldr	r2, [pc, #28]	; (36d0 <adc_window_hit_callback+0x24>)
    36b4:	7011      	strb	r1, [r2, #0]
	adc_result_mV = (ADC_REF_mV * (adc_result_hex - 0x82) / (ADC_2POWER_12BIT_RES));
    36b6:	3b82      	subs	r3, #130	; 0x82
    36b8:	4a06      	ldr	r2, [pc, #24]	; (36d4 <adc_window_hit_callback+0x28>)
    36ba:	4353      	muls	r3, r2
    36bc:	17da      	asrs	r2, r3, #31
    36be:	0512      	lsls	r2, r2, #20
    36c0:	0d12      	lsrs	r2, r2, #20
    36c2:	18d3      	adds	r3, r2, r3
    36c4:	131b      	asrs	r3, r3, #12
    36c6:	4a04      	ldr	r2, [pc, #16]	; (36d8 <adc_window_hit_callback+0x2c>)
    36c8:	8013      	strh	r3, [r2, #0]
}
    36ca:	4770      	bx	lr
    36cc:	43000c00 	.word	0x43000c00
    36d0:	20000168 	.word	0x20000168
    36d4:	0000076c 	.word	0x0000076c
    36d8:	20000166 	.word	0x20000166

000036dc <configure_adc>:

/*! \brief configure adc
 *
 */
void configure_adc(void)
{
    36dc:	b530      	push	{r4, r5, lr}
    36de:	b08d      	sub	sp, #52	; 0x34
	uint16_t adc_threshold = 0;
	
	struct adc_config config_adc;
	adc_get_config_defaults(&config_adc);
    36e0:	ac01      	add	r4, sp, #4
    36e2:	0020      	movs	r0, r4
    36e4:	4b1e      	ldr	r3, [pc, #120]	; (3760 <configure_adc+0x84>)
    36e6:	4798      	blx	r3
	
	//calculate threshold value
	adc_threshold = (VBAT_THRESHOLD_mV * ADC_2POWER_12BIT_RES) / ADC_REF_mV;
	adc_threshold /= 2;

	config_adc.clock_source					= GCLK_GENERATOR_1;
    36e8:	2301      	movs	r3, #1
    36ea:	7023      	strb	r3, [r4, #0]
	config_adc.clock_prescaler				= ADC_CLOCK_PRESCALER_DIV16;
    36ec:	3302      	adds	r3, #2
    36ee:	70a3      	strb	r3, [r4, #2]
	config_adc.reference					= ADC_REFERENCE_INTVCC2;
    36f0:	3302      	adds	r3, #2
    36f2:	7063      	strb	r3, [r4, #1]
	config_adc.positive_input				= ADC_POSITIVE_INPUT_PIN0;
    36f4:	2300      	movs	r3, #0
    36f6:	7123      	strb	r3, [r4, #4]
	config_adc.resolution					= ADC_RESOLUTION_CUSTOM;
    36f8:	3334      	adds	r3, #52	; 0x34
    36fa:	70e3      	strb	r3, [r4, #3]
	config_adc.window.window_mode			= ADC_WINDOW_MODE_BELOW_UPPER;
    36fc:	33cd      	adds	r3, #205	; 0xcd
    36fe:	33ff      	adds	r3, #255	; 0xff
    3700:	8323      	strh	r3, [r4, #24]
	config_adc.window.window_upper_value	= adc_threshold + 0x82;//0x8D0;
    3702:	4b18      	ldr	r3, [pc, #96]	; (3764 <configure_adc+0x88>)
    3704:	6223      	str	r3, [r4, #32]
	config_adc.accumulate_samples			= ADC_ACCUMULATE_SAMPLES_512;
    3706:	2309      	movs	r3, #9
    3708:	7223      	strb	r3, [r4, #8]
	config_adc.divide_result				= ADC_DIVIDE_RESULT_16;
    370a:	3b05      	subs	r3, #5
    370c:	7263      	strb	r3, [r4, #9]

	adc_init(&adc_instance, ADC, &config_adc);
    370e:	4d16      	ldr	r5, [pc, #88]	; (3768 <configure_adc+0x8c>)
    3710:	0022      	movs	r2, r4
    3712:	4916      	ldr	r1, [pc, #88]	; (376c <configure_adc+0x90>)
    3714:	0028      	movs	r0, r5
    3716:	4b16      	ldr	r3, [pc, #88]	; (3770 <configure_adc+0x94>)
    3718:	4798      	blx	r3
		struct adc_module *const module_inst)
{
	Assert(module_inst);
	Assert(module_inst->hw);

	Adc *const adc_module = module_inst->hw;
    371a:	682a      	ldr	r2, [r5, #0]
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;

	if (adc_module->SYNCBUSY.reg) {
    371c:	8c13      	ldrh	r3, [r2, #32]
    371e:	b29b      	uxth	r3, r3

	while (adc_is_syncing(module_inst)) {
    3720:	2b00      	cmp	r3, #0
    3722:	d1fb      	bne.n	371c <configure_adc+0x40>
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    3724:	2180      	movs	r1, #128	; 0x80
    3726:	03c9      	lsls	r1, r1, #15
    3728:	4b12      	ldr	r3, [pc, #72]	; (3774 <configure_adc+0x98>)
    372a:	6019      	str	r1, [r3, #0]
#	else
		system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_ADC);
#   endif
#endif

	adc_module->CTRLA.reg |= ADC_CTRLA_ENABLE;
    372c:	7811      	ldrb	r1, [r2, #0]
    372e:	2302      	movs	r3, #2
    3730:	430b      	orrs	r3, r1
    3732:	7013      	strb	r3, [r2, #0]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    3734:	4b0c      	ldr	r3, [pc, #48]	; (3768 <configure_adc+0x8c>)
    3736:	681a      	ldr	r2, [r3, #0]

	if (adc_module->SYNCBUSY.reg) {
    3738:	8c13      	ldrh	r3, [r2, #32]
    373a:	b29b      	uxth	r3, r3

	while (adc_is_syncing(module_inst)) {
    373c:	2b00      	cmp	r3, #0
    373e:	d1fb      	bne.n	3738 <configure_adc+0x5c>
	adc_enable(&adc_instance);
	adc_register_callback(&adc_instance,adc_window_hit_callback, ADC_CALLBACK_WINDOW);
    3740:	4c09      	ldr	r4, [pc, #36]	; (3768 <configure_adc+0x8c>)
    3742:	2201      	movs	r2, #1
    3744:	490c      	ldr	r1, [pc, #48]	; (3778 <configure_adc+0x9c>)
    3746:	0020      	movs	r0, r4
    3748:	4b0c      	ldr	r3, [pc, #48]	; (377c <configure_adc+0xa0>)
    374a:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(module);

	/* Enable callback */
	module->enabled_callback_mask |= (1 << callback_type);
    374c:	7ee2      	ldrb	r2, [r4, #27]
    374e:	2302      	movs	r3, #2
    3750:	4313      	orrs	r3, r2
    3752:	76e3      	strb	r3, [r4, #27]
{
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	Adc *const adc_module = module_inst->hw;
    3754:	6823      	ldr	r3, [r4, #0]
	/* Enable interrupt */
	adc_module->INTENSET.reg = interrupt;
    3756:	2204      	movs	r2, #4
    3758:	715a      	strb	r2, [r3, #5]
	adc_enable_callback(&adc_instance, ADC_CALLBACK_WINDOW);
}
    375a:	b00d      	add	sp, #52	; 0x34
    375c:	bd30      	pop	{r4, r5, pc}
    375e:	46c0      	nop			; (mov r8, r8)
    3760:	0000455d 	.word	0x0000455d
    3764:	00000b08 	.word	0x00000b08
    3768:	20000e10 	.word	0x20000e10
    376c:	43000c00 	.word	0x43000c00
    3770:	000045a1 	.word	0x000045a1
    3774:	e000e100 	.word	0xe000e100
    3778:	000036ad 	.word	0x000036ad
    377c:	00004a31 	.word	0x00004a31

00003780 <sensors_callback>:

/*! \brief bhi sensor callback
 *
 */
void sensors_callback(bhy_data_generic_t * sensor_data, bhy_virtual_sensor_t sensor_id)
{
    3780:	b570      	push	{r4, r5, r6, lr}
	s16 tempx,tempy, tempz;
	switch (sensor_id)
    3782:	2912      	cmp	r1, #18
    3784:	d86f      	bhi.n	3866 <sensors_callback+0xe6>
    3786:	0089      	lsls	r1, r1, #2
    3788:	4b37      	ldr	r3, [pc, #220]	; (3868 <sensors_callback+0xe8>)
    378a:	585b      	ldr	r3, [r3, r1]
    378c:	469f      	mov	pc, r3
	{
		case VS_ID_GAME_ROTATION_VECTOR:
			quaternion_data.x = sensor_data->data_quaternion.x;
    378e:	4b37      	ldr	r3, [pc, #220]	; (386c <sensors_callback+0xec>)
    3790:	8842      	ldrh	r2, [r0, #2]
    3792:	801a      	strh	r2, [r3, #0]
			quaternion_data.y = sensor_data->data_quaternion.y;
    3794:	8882      	ldrh	r2, [r0, #4]
    3796:	805a      	strh	r2, [r3, #2]
			quaternion_data.z = sensor_data->data_quaternion.z;
    3798:	88c2      	ldrh	r2, [r0, #6]
    379a:	809a      	strh	r2, [r3, #4]
			quaternion_data.w = sensor_data->data_quaternion.w;
    379c:	8902      	ldrh	r2, [r0, #8]
    379e:	80da      	strh	r2, [r3, #6]
		break;
    37a0:	e061      	b.n	3866 <sensors_callback+0xe6>

		case VS_ID_ACCELEROMETER:
			acc_data.x_pos = sensor_data->data_vector.x;
    37a2:	4b33      	ldr	r3, [pc, #204]	; (3870 <sensors_callback+0xf0>)
    37a4:	8842      	ldrh	r2, [r0, #2]
    37a6:	801a      	strh	r2, [r3, #0]
			acc_data.y_pos = sensor_data->data_vector.y;
    37a8:	8882      	ldrh	r2, [r0, #4]
    37aa:	805a      	strh	r2, [r3, #2]
			acc_data.z_pos = sensor_data->data_vector.z;
    37ac:	88c2      	ldrh	r2, [r0, #6]
    37ae:	809a      	strh	r2, [r3, #4]
		break;
    37b0:	e059      	b.n	3866 <sensors_callback+0xe6>

		case VS_ID_GYROSCOPE:
			gyro_data.x_pos = sensor_data->data_vector.x/16;
    37b2:	4930      	ldr	r1, [pc, #192]	; (3874 <sensors_callback+0xf4>)
    37b4:	2302      	movs	r3, #2
    37b6:	5ec2      	ldrsh	r2, [r0, r3]
    37b8:	17d3      	asrs	r3, r2, #31
    37ba:	240f      	movs	r4, #15
    37bc:	4023      	ands	r3, r4
    37be:	189a      	adds	r2, r3, r2
    37c0:	1112      	asrs	r2, r2, #4
    37c2:	800a      	strh	r2, [r1, #0]
			gyro_data.y_pos = sensor_data->data_vector.y/16;
    37c4:	2304      	movs	r3, #4
    37c6:	5ec2      	ldrsh	r2, [r0, r3]
    37c8:	17d3      	asrs	r3, r2, #31
    37ca:	4023      	ands	r3, r4
    37cc:	189a      	adds	r2, r3, r2
    37ce:	1112      	asrs	r2, r2, #4
    37d0:	804a      	strh	r2, [r1, #2]
			gyro_data.z_pos = sensor_data->data_vector.z/16;
    37d2:	2206      	movs	r2, #6
    37d4:	5e83      	ldrsh	r3, [r0, r2]
    37d6:	17da      	asrs	r2, r3, #31
    37d8:	4022      	ands	r2, r4
    37da:	18d3      	adds	r3, r2, r3
    37dc:	111b      	asrs	r3, r3, #4
    37de:	808b      	strh	r3, [r1, #4]
		break;
    37e0:	e041      	b.n	3866 <sensors_callback+0xe6>

		case VS_ID_STEP_DETECTOR:
			step_detected = true;
    37e2:	2201      	movs	r2, #1
    37e4:	4b24      	ldr	r3, [pc, #144]	; (3878 <sensors_callback+0xf8>)
    37e6:	701a      	strb	r2, [r3, #0]
		break;
    37e8:	e03d      	b.n	3866 <sensors_callback+0xe6>

		case VS_ID_GRAVITY:
			gra_x_data = sensor_data->data_vector.x;
    37ea:	2302      	movs	r3, #2
    37ec:	5ec5      	ldrsh	r5, [r0, r3]
    37ee:	4b23      	ldr	r3, [pc, #140]	; (387c <sensors_callback+0xfc>)
    37f0:	801d      	strh	r5, [r3, #0]
			gra_y_data = sensor_data->data_vector.y;
    37f2:	2304      	movs	r3, #4
    37f4:	5ec4      	ldrsh	r4, [r0, r3]
    37f6:	4b22      	ldr	r3, [pc, #136]	; (3880 <sensors_callback+0x100>)
    37f8:	801c      	strh	r4, [r3, #0]
			gra_z_data = sensor_data->data_vector.z;
    37fa:	2306      	movs	r3, #6
    37fc:	5ec0      	ldrsh	r0, [r0, r3]
    37fe:	4b21      	ldr	r3, [pc, #132]	; (3884 <sensors_callback+0x104>)
    3800:	8018      	strh	r0, [r3, #0]

			if((gra_x_data) > (gra_x_data_prev))
    3802:	4b21      	ldr	r3, [pc, #132]	; (3888 <sensors_callback+0x108>)
    3804:	2200      	movs	r2, #0
    3806:	5e9b      	ldrsh	r3, [r3, r2]
    3808:	429d      	cmp	r5, r3
    380a:	dd02      	ble.n	3812 <sensors_callback+0x92>
			tempx = (gra_x_data) - (gra_x_data_prev);
    380c:	1aeb      	subs	r3, r5, r3
    380e:	b219      	sxth	r1, r3
    3810:	e001      	b.n	3816 <sensors_callback+0x96>
			else
			tempx = (gra_x_data_prev) - (gra_x_data);
    3812:	1b5b      	subs	r3, r3, r5
    3814:	b219      	sxth	r1, r3

			if((gra_y_data) > (gra_y_data_prev))
    3816:	4b1d      	ldr	r3, [pc, #116]	; (388c <sensors_callback+0x10c>)
    3818:	2200      	movs	r2, #0
    381a:	5e9b      	ldrsh	r3, [r3, r2]
    381c:	429c      	cmp	r4, r3
    381e:	dd02      	ble.n	3826 <sensors_callback+0xa6>
			tempy = (gra_y_data) - (gra_y_data_prev);
    3820:	1ae3      	subs	r3, r4, r3
    3822:	b21b      	sxth	r3, r3
    3824:	e001      	b.n	382a <sensors_callback+0xaa>
			else
			tempy = (gra_y_data_prev) - (gra_y_data);
    3826:	1b1b      	subs	r3, r3, r4
    3828:	b21b      	sxth	r3, r3

			if((gra_z_data) > (gra_z_data_prev))
    382a:	4a19      	ldr	r2, [pc, #100]	; (3890 <sensors_callback+0x110>)
    382c:	2600      	movs	r6, #0
    382e:	5f92      	ldrsh	r2, [r2, r6]
    3830:	4290      	cmp	r0, r2
    3832:	dd02      	ble.n	383a <sensors_callback+0xba>
			tempz = (gra_z_data) - (gra_z_data_prev);
    3834:	1a82      	subs	r2, r0, r2
    3836:	b212      	sxth	r2, r2
    3838:	e001      	b.n	383e <sensors_callback+0xbe>
			else
			tempz = (gra_z_data_prev) - (gra_z_data);
    383a:	1a12      	subs	r2, r2, r0
    383c:	b212      	sxth	r2, r2

			if ((tempx >ACC_GRAVITY_THRESHOLD_X) ||  \
    383e:	26c8      	movs	r6, #200	; 0xc8
    3840:	00b6      	lsls	r6, r6, #2
    3842:	42b1      	cmp	r1, r6
    3844:	dc05      	bgt.n	3852 <sensors_callback+0xd2>
    3846:	42b3      	cmp	r3, r6
    3848:	dc03      	bgt.n	3852 <sensors_callback+0xd2>
			    (tempy >ACC_GRAVITY_THRESHOLD_Y) ||  \
    384a:	23af      	movs	r3, #175	; 0xaf
    384c:	009b      	lsls	r3, r3, #2
    384e:	429a      	cmp	r2, r3
    3850:	dd03      	ble.n	385a <sensors_callback+0xda>
				(tempz >ACC_GRAVITY_THRESHOLD_Z))
			{
				device_drop_detected++;
    3852:	4a10      	ldr	r2, [pc, #64]	; (3894 <sensors_callback+0x114>)
    3854:	8813      	ldrh	r3, [r2, #0]
    3856:	3301      	adds	r3, #1
    3858:	8013      	strh	r3, [r2, #0]
			}

			gra_x_data_prev = gra_x_data;
    385a:	4b0b      	ldr	r3, [pc, #44]	; (3888 <sensors_callback+0x108>)
    385c:	801d      	strh	r5, [r3, #0]
			gra_y_data_prev = gra_y_data;
    385e:	4b0b      	ldr	r3, [pc, #44]	; (388c <sensors_callback+0x10c>)
    3860:	801c      	strh	r4, [r3, #0]
			gra_z_data_prev = gra_z_data;
    3862:	4b0b      	ldr	r3, [pc, #44]	; (3890 <sensors_callback+0x110>)
    3864:	8018      	strh	r0, [r3, #0]
		break;
		default:
		break;
	}

}
    3866:	bd70      	pop	{r4, r5, r6, pc}
    3868:	0000c8c4 	.word	0x0000c8c4
    386c:	20000e9c 	.word	0x20000e9c
    3870:	20000e58 	.word	0x20000e58
    3874:	20000e94 	.word	0x20000e94
    3878:	20000177 	.word	0x20000177
    387c:	20000e4a 	.word	0x20000e4a
    3880:	20000e46 	.word	0x20000e46
    3884:	20000e44 	.word	0x20000e44
    3888:	20000f9e 	.word	0x20000f9e
    388c:	20000fa0 	.word	0x20000fa0
    3890:	20000e48 	.word	0x20000e48
    3894:	20000174 	.word	0x20000174

00003898 <process_motion_sensor_data>:

/*! \brief process motion sensor data
 *
 */
void process_motion_sensor_data(void)
{
    3898:	b570      	push	{r4, r5, r6, lr}
    389a:	b088      	sub	sp, #32
	u8 bytes_left_in_fifo=0;
	u16 bytes_remaining = 0;
    389c:	2300      	movs	r3, #0
    389e:	221e      	movs	r2, #30
    38a0:	446a      	add	r2, sp
    38a2:	8013      	strh	r3, [r2, #0]
	u16 bytes_read = 0;
    38a4:	aa07      	add	r2, sp, #28
    38a6:	8013      	strh	r3, [r2, #0]
	BHY_RETURN_FUNCTION_TYPE result;

	/* enable i2c */
	//enable_i2c();

	if(acc_sens_stat || gyro_sens_stat || rot_sens_stat ||	gra_sens_stat || stp_sens_stat)
    38a8:	4b28      	ldr	r3, [pc, #160]	; (394c <process_motion_sensor_data+0xb4>)
    38aa:	781b      	ldrb	r3, [r3, #0]
    38ac:	2b00      	cmp	r3, #0
    38ae:	d10f      	bne.n	38d0 <process_motion_sensor_data+0x38>
    38b0:	4b27      	ldr	r3, [pc, #156]	; (3950 <process_motion_sensor_data+0xb8>)
    38b2:	781b      	ldrb	r3, [r3, #0]
    38b4:	2b00      	cmp	r3, #0
    38b6:	d10b      	bne.n	38d0 <process_motion_sensor_data+0x38>
    38b8:	4b26      	ldr	r3, [pc, #152]	; (3954 <process_motion_sensor_data+0xbc>)
    38ba:	781b      	ldrb	r3, [r3, #0]
    38bc:	2b00      	cmp	r3, #0
    38be:	d107      	bne.n	38d0 <process_motion_sensor_data+0x38>
    38c0:	4b25      	ldr	r3, [pc, #148]	; (3958 <process_motion_sensor_data+0xc0>)
    38c2:	781b      	ldrb	r3, [r3, #0]
    38c4:	2b00      	cmp	r3, #0
    38c6:	d103      	bne.n	38d0 <process_motion_sensor_data+0x38>
    38c8:	4b24      	ldr	r3, [pc, #144]	; (395c <process_motion_sensor_data+0xc4>)
    38ca:	781b      	ldrb	r3, [r3, #0]
    38cc:	2b00      	cmp	r3, #0
    38ce:	d03b      	beq.n	3948 <process_motion_sensor_data+0xb0>
	{
		//while (!port_pin_get_input_level(BHI_SENSOR_INT_PIN) /*&& !bytes_remaining*/) ;
		if(bhy_read_fifo(array+bytes_left_in_fifo, ARRAYSIZE-bytes_left_in_fifo, &bytes_read, &bytes_remaining) == BHY_SUCCESS)
    38d0:	231e      	movs	r3, #30
    38d2:	446b      	add	r3, sp
    38d4:	aa07      	add	r2, sp, #28
    38d6:	21fa      	movs	r1, #250	; 0xfa
    38d8:	4821      	ldr	r0, [pc, #132]	; (3960 <process_motion_sensor_data+0xc8>)
    38da:	4c22      	ldr	r4, [pc, #136]	; (3964 <process_motion_sensor_data+0xcc>)
    38dc:	47a0      	blx	r4
    38de:	2800      	cmp	r0, #0
    38e0:	d132      	bne.n	3948 <process_motion_sensor_data+0xb0>
		{
			bytes_read += bytes_left_in_fifo;

			fifoptr = array;
    38e2:	4a1f      	ldr	r2, [pc, #124]	; (3960 <process_motion_sensor_data+0xc8>)
    38e4:	4b20      	ldr	r3, [pc, #128]	; (3968 <process_motion_sensor_data+0xd0>)
    38e6:	601a      	str	r2, [r3, #0]
			packet_type = BHY_DATA_TYPE_PADDING;
    38e8:	2200      	movs	r2, #0
    38ea:	466b      	mov	r3, sp
    38ec:	71da      	strb	r2, [r3, #7]

			do {
				/* this function will call callbacks that are registered */
				result = bhy_parse_next_fifo_packet( &fifoptr, &bytes_read, &fifo_packet, &packet_type );
    38ee:	4c1e      	ldr	r4, [pc, #120]	; (3968 <process_motion_sensor_data+0xd0>)
    38f0:	4d1e      	ldr	r5, [pc, #120]	; (396c <process_motion_sensor_data+0xd4>)
    38f2:	466b      	mov	r3, sp
    38f4:	3307      	adds	r3, #7
    38f6:	aa02      	add	r2, sp, #8
    38f8:	a907      	add	r1, sp, #28
    38fa:	0020      	movs	r0, r4
    38fc:	47a8      	blx	r5
				/* the logic here is that if doing a partial parsing of the fifo, then we should not parse	*/
				/* the last 18 bytes (max length of a packet) so that we don't try to parse an incomplete	*/
				/* packet																					*/
			} while ( (result == BHY_SUCCESS) && (bytes_read > (bytes_remaining ? 18 : 0)) );
    38fe:	2800      	cmp	r0, #0
    3900:	d10b      	bne.n	391a <process_motion_sensor_data+0x82>
    3902:	ab07      	add	r3, sp, #28
    3904:	8819      	ldrh	r1, [r3, #0]
    3906:	231e      	movs	r3, #30
    3908:	446b      	add	r3, sp
    390a:	881b      	ldrh	r3, [r3, #0]
    390c:	2212      	movs	r2, #18
    390e:	1e58      	subs	r0, r3, #1
    3910:	4183      	sbcs	r3, r0
    3912:	425b      	negs	r3, r3
    3914:	401a      	ands	r2, r3
    3916:	428a      	cmp	r2, r1
    3918:	dbeb      	blt.n	38f2 <process_motion_sensor_data+0x5a>
			bytes_left_in_fifo = 0;

			if (bytes_remaining) {
    391a:	231e      	movs	r3, #30
    391c:	446b      	add	r3, sp
    391e:	881b      	ldrh	r3, [r3, #0]
    3920:	2b00      	cmp	r3, #0
    3922:	d011      	beq.n	3948 <process_motion_sensor_data+0xb0>
				/* shifts the remaining bytes to the beginning of the buffer */
				while (bytes_left_in_fifo < bytes_read)
    3924:	ab07      	add	r3, sp, #28
    3926:	881d      	ldrh	r5, [r3, #0]
    3928:	2d00      	cmp	r5, #0
    392a:	d00d      	beq.n	3948 <process_motion_sensor_data+0xb0>
    392c:	2200      	movs	r2, #0
				array[bytes_left_in_fifo++] = *(fifoptr++);
    392e:	480e      	ldr	r0, [pc, #56]	; (3968 <process_motion_sensor_data+0xd0>)
    3930:	4e0b      	ldr	r6, [pc, #44]	; (3960 <process_motion_sensor_data+0xc8>)
    3932:	1c53      	adds	r3, r2, #1
    3934:	b2db      	uxtb	r3, r3
    3936:	6801      	ldr	r1, [r0, #0]
    3938:	1c4c      	adds	r4, r1, #1
    393a:	6004      	str	r4, [r0, #0]
    393c:	7809      	ldrb	r1, [r1, #0]
    393e:	54b1      	strb	r1, [r6, r2]
    3940:	001a      	movs	r2, r3
			} while ( (result == BHY_SUCCESS) && (bytes_read > (bytes_remaining ? 18 : 0)) );
			bytes_left_in_fifo = 0;

			if (bytes_remaining) {
				/* shifts the remaining bytes to the beginning of the buffer */
				while (bytes_left_in_fifo < bytes_read)
    3942:	b29b      	uxth	r3, r3
    3944:	42ab      	cmp	r3, r5
    3946:	d3f4      	bcc.n	3932 <process_motion_sensor_data+0x9a>
		}
	}

	/* disable i2c */
	//disable_i2c();
}
    3948:	b008      	add	sp, #32
    394a:	bd70      	pop	{r4, r5, r6, pc}
    394c:	20000170 	.word	0x20000170
    3950:	20000169 	.word	0x20000169
    3954:	20000172 	.word	0x20000172
    3958:	20000176 	.word	0x20000176
    395c:	20000171 	.word	0x20000171
    3960:	20000ea4 	.word	0x20000ea4
    3964:	0000400d 	.word	0x0000400d
    3968:	2000016c 	.word	0x2000016c
    396c:	000040c5 	.word	0x000040c5

00003970 <enable_accelerometer>:

/*! \brief enable accelerometer
 *
 */
void enable_accelerometer(void)
{
    3970:	b510      	push	{r4, lr}
    3972:	b084      	sub	sp, #16
	if(bhy_enable_virtual_sensor(VS_TYPE_ACCELEROMETER, VS_NON_WAKEUP, SAMPLE_DATA_RATE, 0, VS_FLUSH_NONE, 0, 0) != BHY_SUCCESS)
    3974:	2300      	movs	r3, #0
    3976:	9302      	str	r3, [sp, #8]
    3978:	9301      	str	r3, [sp, #4]
    397a:	9300      	str	r3, [sp, #0]
    397c:	22c8      	movs	r2, #200	; 0xc8
    397e:	2100      	movs	r1, #0
    3980:	2001      	movs	r0, #1
    3982:	4c07      	ldr	r4, [pc, #28]	; (39a0 <enable_accelerometer+0x30>)
    3984:	47a0      	blx	r4
    3986:	2800      	cmp	r0, #0
    3988:	d000      	beq.n	398c <enable_accelerometer+0x1c>
    398a:	e7fe      	b.n	398a <enable_accelerometer+0x1a>
	{
		while(1);
	}
	bhy_install_sensor_callback(VS_TYPE_ACCELEROMETER, VS_NON_WAKEUP, sensors_callback);
    398c:	4a05      	ldr	r2, [pc, #20]	; (39a4 <enable_accelerometer+0x34>)
    398e:	2100      	movs	r1, #0
    3990:	2001      	movs	r0, #1
    3992:	4b05      	ldr	r3, [pc, #20]	; (39a8 <enable_accelerometer+0x38>)
    3994:	4798      	blx	r3
	acc_sens_stat = true;
    3996:	2201      	movs	r2, #1
    3998:	4b04      	ldr	r3, [pc, #16]	; (39ac <enable_accelerometer+0x3c>)
    399a:	701a      	strb	r2, [r3, #0]
}
    399c:	b004      	add	sp, #16
    399e:	bd10      	pop	{r4, pc}
    39a0:	00003f59 	.word	0x00003f59
    39a4:	00003781 	.word	0x00003781
    39a8:	000043c1 	.word	0x000043c1
    39ac:	20000170 	.word	0x20000170

000039b0 <bhy_init>:
 *	affect the reference value of the parameter
 *	(Better case don't change the reference value of the parameter)
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_init(struct bhy_t *bhy)
{
    39b0:	b570      	push	{r4, r5, r6, lr}
    39b2:	b082      	sub	sp, #8
    39b4:	0003      	movs	r3, r0
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
    39b6:	466a      	mov	r2, sp
    39b8:	1dd4      	adds	r4, r2, #7
    39ba:	2200      	movs	r2, #0
    39bc:	7022      	strb	r2, [r4, #0]
	/* assign bhy ptr */
	p_bhy = bhy;
    39be:	4d06      	ldr	r5, [pc, #24]	; (39d8 <bhy_init+0x28>)
    39c0:	6028      	str	r0, [r5, #0]
	com_rslt =
    39c2:	7840      	ldrb	r0, [r0, #1]
    39c4:	689e      	ldr	r6, [r3, #8]
    39c6:	2301      	movs	r3, #1
    39c8:	0022      	movs	r2, r4
    39ca:	2190      	movs	r1, #144	; 0x90
    39cc:	47b0      	blx	r6
	p_bhy->BHY_BUS_READ_FUNC(p_bhy->device_addr,
	BHY_I2C_REG_PRODUCT_ID_ADDR,
	&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
	/* read product Id */
	p_bhy->product_id = v_data_u8;
    39ce:	7822      	ldrb	r2, [r4, #0]
    39d0:	682b      	ldr	r3, [r5, #0]
    39d2:	701a      	strb	r2, [r3, #0]
	return com_rslt;
}
    39d4:	b002      	add	sp, #8
    39d6:	bd70      	pop	{r4, r5, r6, pc}
    39d8:	20000180 	.word	0x20000180

000039dc <bhy_write_reg>:
 *
 *
 */
BHY_RETURN_FUNCTION_TYPE bhy_write_reg(u8 v_addr_u8,
u8 *v_data_u8, u16 v_len_u16)
{
    39dc:	b570      	push	{r4, r5, r6, lr}
    39de:	0005      	movs	r5, r0
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	/* check the p_bhy structure as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    39e0:	4c06      	ldr	r4, [pc, #24]	; (39fc <bhy_write_reg+0x20>)
    39e2:	6824      	ldr	r4, [r4, #0]
    39e4:	2c00      	cmp	r4, #0
    39e6:	d006      	beq.n	39f6 <bhy_write_reg+0x1a>
		com_rslt =  BHY_NULL;
		} else {
			/* write data from register*/
			com_rslt =
    39e8:	7860      	ldrb	r0, [r4, #1]
    39ea:	6864      	ldr	r4, [r4, #4]
    39ec:	0013      	movs	r3, r2
    39ee:	000a      	movs	r2, r1
    39f0:	0029      	movs	r1, r5
    39f2:	47a0      	blx	r4
    39f4:	e000      	b.n	39f8 <bhy_write_reg+0x1c>
{
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	/* check the p_bhy structure as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    39f6:	2000      	movs	r0, #0
			com_rslt =
			p_bhy->BHY_BUS_WRITE_FUNC(p_bhy->device_addr,
			v_addr_u8, v_data_u8, v_len_u16);
		}
	return com_rslt;
}
    39f8:	bd70      	pop	{r4, r5, r6, pc}
    39fa:	46c0      	nop			; (mov r8, r8)
    39fc:	20000180 	.word	0x20000180

00003a00 <bhy_read_reg>:
 *
 *
 */
BHY_RETURN_FUNCTION_TYPE bhy_read_reg(u8 v_addr_u8,
u8 *v_data_u8, u16 v_len_u16)
{
    3a00:	b570      	push	{r4, r5, r6, lr}
    3a02:	0005      	movs	r5, r0
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	/* check the p_bhy structure as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    3a04:	4c06      	ldr	r4, [pc, #24]	; (3a20 <bhy_read_reg+0x20>)
    3a06:	6824      	ldr	r4, [r4, #0]
    3a08:	2c00      	cmp	r4, #0
    3a0a:	d006      	beq.n	3a1a <bhy_read_reg+0x1a>
		com_rslt =  BHY_NULL;
		} else {
			/* Read data from register*/
			com_rslt =
    3a0c:	7860      	ldrb	r0, [r4, #1]
    3a0e:	68a4      	ldr	r4, [r4, #8]
    3a10:	0013      	movs	r3, r2
    3a12:	000a      	movs	r2, r1
    3a14:	0029      	movs	r1, r5
    3a16:	47a0      	blx	r4
    3a18:	e000      	b.n	3a1c <bhy_read_reg+0x1c>
{
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	/* check the p_bhy structure as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    3a1a:	2000      	movs	r0, #0
			com_rslt =
			p_bhy->BHY_BUS_READ_FUNC(p_bhy->device_addr,
			v_addr_u8, v_data_u8, v_len_u16);
		}
	return com_rslt;
}
    3a1c:	bd70      	pop	{r4, r5, r6, pc}
    3a1e:	46c0      	nop			; (mov r8, r8)
    3a20:	20000180 	.word	0x20000180

00003a24 <bhy_set_fifo_flush>:
 *	@retval 0 -> Success
 *	@retval -1 -> Error
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_set_fifo_flush(u8 v_fifo_flush_u8)
{
    3a24:	b530      	push	{r4, r5, lr}
    3a26:	b083      	sub	sp, #12
    3a28:	0004      	movs	r4, r0
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
    3a2a:	2200      	movs	r2, #0
    3a2c:	466b      	mov	r3, sp
    3a2e:	71da      	strb	r2, [r3, #7]

	if (BHY_NULL_PTR == p_bhy) {
    3a30:	4b0d      	ldr	r3, [pc, #52]	; (3a68 <bhy_set_fifo_flush+0x44>)
    3a32:	681b      	ldr	r3, [r3, #0]
    3a34:	2b00      	cmp	r3, #0
    3a36:	d013      	beq.n	3a60 <bhy_set_fifo_flush+0x3c>
		com_rslt = BHY_NULL;
		} else {
		com_rslt =
    3a38:	7858      	ldrb	r0, [r3, #1]
    3a3a:	689d      	ldr	r5, [r3, #8]
    3a3c:	2301      	movs	r3, #1
    3a3e:	466a      	mov	r2, sp
    3a40:	3207      	adds	r2, #7
    3a42:	2132      	movs	r1, #50	; 0x32
    3a44:	47a8      	blx	r5
		p_bhy->BHY_BUS_READ_FUNC(p_bhy->device_addr,
		BHY_I2C_REG_FIFO_FLUSH__REG,
		&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
		if (BHY_SUCCESS == com_rslt) {
    3a46:	2800      	cmp	r0, #0
    3a48:	d10b      	bne.n	3a62 <bhy_set_fifo_flush+0x3e>
			v_data_u8 = BHY_SET_BITSLICE(v_data_u8,
    3a4a:	466b      	mov	r3, sp
    3a4c:	1dda      	adds	r2, r3, #7
    3a4e:	7014      	strb	r4, [r2, #0]
			BHY_I2C_REG_FIFO_FLUSH,
			v_fifo_flush_u8);
			com_rslt += p_bhy->BHY_BUS_WRITE_FUNC
    3a50:	4b05      	ldr	r3, [pc, #20]	; (3a68 <bhy_set_fifo_flush+0x44>)
    3a52:	681b      	ldr	r3, [r3, #0]
    3a54:	7858      	ldrb	r0, [r3, #1]
    3a56:	685c      	ldr	r4, [r3, #4]
    3a58:	2301      	movs	r3, #1
    3a5a:	2132      	movs	r1, #50	; 0x32
    3a5c:	47a0      	blx	r4
    3a5e:	e000      	b.n	3a62 <bhy_set_fifo_flush+0x3e>
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;

	if (BHY_NULL_PTR == p_bhy) {
		com_rslt = BHY_NULL;
    3a60:	2000      	movs	r0, #0
			BHY_I2C_REG_FIFO_FLUSH__REG,
			&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
		}
	}
	return com_rslt;
}
    3a62:	b003      	add	sp, #12
    3a64:	bd30      	pop	{r4, r5, pc}
    3a66:	46c0      	nop			; (mov r8, r8)
    3a68:	20000180 	.word	0x20000180

00003a6c <bhy_read_bytes_remaining>:
 *
 *
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_read_bytes_remaining(u16 *v_bytes_remaining_u16)
{
    3a6c:	b570      	push	{r4, r5, r6, lr}
    3a6e:	b082      	sub	sp, #8
    3a70:	0005      	movs	r5, r0
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	/* Array contains the bytes reaming of FIFO lSB and MSB data
		v_data_u8[LSB_ZERO] - LSB
		v_data_u8[MSB_ONE] - MSB*/
	u8 v_data_u8[BHY_BYTES_REMAINING_SIZE] = {BHY_INIT_VALUE,
    3a72:	ab01      	add	r3, sp, #4
    3a74:	2200      	movs	r2, #0
    3a76:	701a      	strb	r2, [r3, #0]
    3a78:	705a      	strb	r2, [r3, #1]
	BHY_INIT_VALUE};
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    3a7a:	4b0a      	ldr	r3, [pc, #40]	; (3aa4 <bhy_read_bytes_remaining+0x38>)
    3a7c:	681b      	ldr	r3, [r3, #0]
    3a7e:	2b00      	cmp	r3, #0
    3a80:	d00c      	beq.n	3a9c <bhy_read_bytes_remaining+0x30>
		com_rslt = BHY_NULL;
		} else {
			/* read bytes remaining data */
			com_rslt =
    3a82:	ac01      	add	r4, sp, #4
    3a84:	7858      	ldrb	r0, [r3, #1]
    3a86:	689e      	ldr	r6, [r3, #8]
    3a88:	2302      	movs	r3, #2
    3a8a:	0022      	movs	r2, r4
    3a8c:	2138      	movs	r1, #56	; 0x38
    3a8e:	47b0      	blx	r6
			p_bhy->BHY_BUS_READ_FUNC(p_bhy->device_addr,
			BHY_I2C_REG_BYTES_REMAINING_LSB_ADDR,
			v_data_u8, BHY_BYTES_REMAINING_LENGTH);
			/* get the bytes remaining data*/
			*v_bytes_remaining_u16 = (u16)
    3a90:	7863      	ldrb	r3, [r4, #1]
    3a92:	021b      	lsls	r3, r3, #8
    3a94:	7822      	ldrb	r2, [r4, #0]
    3a96:	4313      	orrs	r3, r2
    3a98:	802b      	strh	r3, [r5, #0]
    3a9a:	e000      	b.n	3a9e <bhy_read_bytes_remaining+0x32>
		v_data_u8[MSB_ONE] - MSB*/
	u8 v_data_u8[BHY_BYTES_REMAINING_SIZE] = {BHY_INIT_VALUE,
	BHY_INIT_VALUE};
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt = BHY_NULL;
    3a9c:	2000      	movs	r0, #0
			((v_data_u8[BHY_BYTES_REMAINING_MSB]
			<< BHY_SHIFT_BIT_POSITION_BY_08_BITS)
			| (v_data_u8[BHY_BYTES_REMAINING_LSB]));
		}
	return com_rslt;
}
    3a9e:	b002      	add	sp, #8
    3aa0:	bd70      	pop	{r4, r5, r6, pc}
    3aa2:	46c0      	nop			; (mov r8, r8)
    3aa4:	20000180 	.word	0x20000180

00003aa8 <bhy_get_parameter_acknowledge>:
 *
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_get_parameter_acknowledge(
u8 *v_parameter_acknowledge_u8)
{
    3aa8:	b570      	push	{r4, r5, r6, lr}
    3aaa:	b082      	sub	sp, #8
    3aac:	0005      	movs	r5, r0
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
    3aae:	2200      	movs	r2, #0
    3ab0:	466b      	mov	r3, sp
    3ab2:	71da      	strb	r2, [r3, #7]
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    3ab4:	4b08      	ldr	r3, [pc, #32]	; (3ad8 <bhy_get_parameter_acknowledge+0x30>)
    3ab6:	681b      	ldr	r3, [r3, #0]
    3ab8:	2b00      	cmp	r3, #0
    3aba:	d00a      	beq.n	3ad2 <bhy_get_parameter_acknowledge+0x2a>
		com_rslt =  BHY_NULL;
		} else {
			/* read the parameter acknowledgement*/
			com_rslt =
    3abc:	466a      	mov	r2, sp
    3abe:	1dd4      	adds	r4, r2, #7
    3ac0:	7858      	ldrb	r0, [r3, #1]
    3ac2:	689e      	ldr	r6, [r3, #8]
    3ac4:	2301      	movs	r3, #1
    3ac6:	0022      	movs	r2, r4
    3ac8:	213a      	movs	r1, #58	; 0x3a
    3aca:	47b0      	blx	r6
			p_bhy->BHY_BUS_READ_FUNC(p_bhy->device_addr,
			BHY_I2C_REG_PARAMETER_ACKNOWLEDGE_ADDR,
			&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
			*v_parameter_acknowledge_u8 = v_data_u8;
    3acc:	7823      	ldrb	r3, [r4, #0]
    3ace:	702b      	strb	r3, [r5, #0]
    3ad0:	e000      	b.n	3ad4 <bhy_get_parameter_acknowledge+0x2c>
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    3ad2:	2000      	movs	r0, #0
			BHY_I2C_REG_PARAMETER_ACKNOWLEDGE_ADDR,
			&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
			*v_parameter_acknowledge_u8 = v_data_u8;
		}
	return com_rslt;
}
    3ad4:	b002      	add	sp, #8
    3ad6:	bd70      	pop	{r4, r5, r6, pc}
    3ad8:	20000180 	.word	0x20000180

00003adc <bhy_set_parameter_page_select>:
 *
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_set_parameter_page_select(
u8 v_page_select_u8)
{
    3adc:	b510      	push	{r4, lr}
    3ade:	b082      	sub	sp, #8
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    3ae0:	4b07      	ldr	r3, [pc, #28]	; (3b00 <bhy_set_parameter_page_select+0x24>)
    3ae2:	681b      	ldr	r3, [r3, #0]
    3ae4:	2b00      	cmp	r3, #0
    3ae6:	d008      	beq.n	3afa <bhy_set_parameter_page_select+0x1e>
		com_rslt =  BHY_NULL;
		} else {
			v_data_u8 = v_page_select_u8;
    3ae8:	466a      	mov	r2, sp
    3aea:	3207      	adds	r2, #7
    3aec:	7010      	strb	r0, [r2, #0]
			/* read the parameter page information*/
			com_rslt = p_bhy->BHY_BUS_WRITE_FUNC
    3aee:	7858      	ldrb	r0, [r3, #1]
    3af0:	685c      	ldr	r4, [r3, #4]
    3af2:	2301      	movs	r3, #1
    3af4:	2154      	movs	r1, #84	; 0x54
    3af6:	47a0      	blx	r4
    3af8:	e000      	b.n	3afc <bhy_set_parameter_page_select+0x20>
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    3afa:	2000      	movs	r0, #0
			(p_bhy->device_addr,
			BHY_I2C_REG_PARAMETER_PAGE_SELECT__REG,
			&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
			}
			return com_rslt;
		}
    3afc:	b002      	add	sp, #8
    3afe:	bd10      	pop	{r4, pc}
    3b00:	20000180 	.word	0x20000180

00003b04 <bhy_set_parameter_request>:
 *
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_set_parameter_request(
u8 v_parameter_request_u8)
{
    3b04:	b510      	push	{r4, lr}
    3b06:	b082      	sub	sp, #8
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    3b08:	4b07      	ldr	r3, [pc, #28]	; (3b28 <bhy_set_parameter_request+0x24>)
    3b0a:	681b      	ldr	r3, [r3, #0]
    3b0c:	2b00      	cmp	r3, #0
    3b0e:	d008      	beq.n	3b22 <bhy_set_parameter_request+0x1e>
		com_rslt =  BHY_NULL;
		} else {
			/* write load parameter request*/
			 v_data_u8 = v_parameter_request_u8;
    3b10:	466a      	mov	r2, sp
    3b12:	3207      	adds	r2, #7
    3b14:	7010      	strb	r0, [r2, #0]
			com_rslt = p_bhy->BHY_BUS_WRITE_FUNC
    3b16:	7858      	ldrb	r0, [r3, #1]
    3b18:	685c      	ldr	r4, [r3, #4]
    3b1a:	2301      	movs	r3, #1
    3b1c:	2164      	movs	r1, #100	; 0x64
    3b1e:	47a0      	blx	r4
    3b20:	e000      	b.n	3b24 <bhy_set_parameter_request+0x20>
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    3b22:	2000      	movs	r0, #0
			(p_bhy->device_addr,
			BHY_I2C_REG_LOAD_PARAMETER_REQUEST__REG,
			&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
		}
	return com_rslt;
}
    3b24:	b002      	add	sp, #8
    3b26:	bd10      	pop	{r4, pc}
    3b28:	20000180 	.word	0x20000180

00003b2c <bhy_get_crc_host>:
 *	@retval -1 -> Error
 *
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_get_crc_host(u32 *v_crc_host_u32)
{
    3b2c:	b570      	push	{r4, r5, r6, lr}
    3b2e:	b082      	sub	sp, #8
    3b30:	0005      	movs	r5, r0
	a_data_u8[0] - crc HOST
	a_data_u8[1] - crc HOST
	a_data_u8[2] - crc HOST
	a_data_u8[3] - crc HOST
	*/
	u8 a_data_u8[BHY_CRC_HOST_SIZE] = {BHY_INIT_VALUE,
    3b32:	2300      	movs	r3, #0
    3b34:	9301      	str	r3, [sp, #4]
	BHY_INIT_VALUE, BHY_INIT_VALUE, BHY_INIT_VALUE};
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    3b36:	4b0d      	ldr	r3, [pc, #52]	; (3b6c <bhy_get_crc_host+0x40>)
    3b38:	681b      	ldr	r3, [r3, #0]
    3b3a:	2b00      	cmp	r3, #0
    3b3c:	d012      	beq.n	3b64 <bhy_get_crc_host+0x38>
		com_rslt =  BHY_NULL;
		} else {
			com_rslt =
    3b3e:	ac01      	add	r4, sp, #4
    3b40:	7858      	ldrb	r0, [r3, #1]
    3b42:	689e      	ldr	r6, [r3, #8]
    3b44:	2304      	movs	r3, #4
    3b46:	0022      	movs	r2, r4
    3b48:	2197      	movs	r1, #151	; 0x97
    3b4a:	47b0      	blx	r6
			p_bhy->BHY_BUS_READ_FUNC(p_bhy->device_addr,
			BHY_I2C_REG_CRC_HOST_ADDR,
			a_data_u8, BHY_CRC_HOST_LENGTH);
			*v_crc_host_u32 = (u32)
    3b4c:	78e3      	ldrb	r3, [r4, #3]
    3b4e:	061a      	lsls	r2, r3, #24
    3b50:	78a3      	ldrb	r3, [r4, #2]
    3b52:	041b      	lsls	r3, r3, #16
    3b54:	4313      	orrs	r3, r2
    3b56:	7822      	ldrb	r2, [r4, #0]
    3b58:	4313      	orrs	r3, r2
    3b5a:	7862      	ldrb	r2, [r4, #1]
    3b5c:	0212      	lsls	r2, r2, #8
    3b5e:	4313      	orrs	r3, r2
    3b60:	602b      	str	r3, [r5, #0]
    3b62:	e000      	b.n	3b66 <bhy_get_crc_host+0x3a>
	*/
	u8 a_data_u8[BHY_CRC_HOST_SIZE] = {BHY_INIT_VALUE,
	BHY_INIT_VALUE, BHY_INIT_VALUE, BHY_INIT_VALUE};
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    3b64:	2000      	movs	r0, #0
			|(a_data_u8[BHY_CRC_HOST_XLSB]
			<< BHY_SHIFT_BIT_POSITION_BY_08_BITS)
			| (a_data_u8[BHY_CRC_HOST_LSB]));
		}
	return com_rslt;
}
    3b66:	b002      	add	sp, #8
    3b68:	bd70      	pop	{r4, r5, r6, pc}
    3b6a:	46c0      	nop			; (mov r8, r8)
    3b6c:	20000180 	.word	0x20000180

00003b70 <bhy_set_reset_request>:
 *	@retval -1 -> Error
 *
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_set_reset_request(u8 v_reset_request_u8)
{
    3b70:	b510      	push	{r4, lr}
    3b72:	b082      	sub	sp, #8
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    3b74:	4b07      	ldr	r3, [pc, #28]	; (3b94 <bhy_set_reset_request+0x24>)
    3b76:	681b      	ldr	r3, [r3, #0]
    3b78:	2b00      	cmp	r3, #0
    3b7a:	d008      	beq.n	3b8e <bhy_set_reset_request+0x1e>
		com_rslt =  BHY_NULL;
		} else {
			v_data_u8 = v_reset_request_u8;
    3b7c:	466a      	mov	r2, sp
    3b7e:	3207      	adds	r2, #7
    3b80:	7010      	strb	r0, [r2, #0]
			/* write load parameter request*/
			com_rslt = p_bhy->BHY_BUS_WRITE_FUNC
    3b82:	7858      	ldrb	r0, [r3, #1]
    3b84:	685c      	ldr	r4, [r3, #4]
    3b86:	2301      	movs	r3, #1
    3b88:	219b      	movs	r1, #155	; 0x9b
    3b8a:	47a0      	blx	r4
    3b8c:	e000      	b.n	3b90 <bhy_set_reset_request+0x20>
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_data_u8 = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    3b8e:	2000      	movs	r0, #0
			(p_bhy->device_addr,
			BHY_I2C_REG_RESET_REQUEST__REG,
			&v_data_u8, BHY_GEN_READ_WRITE_LENGTH);
		}
	return com_rslt;
}
    3b90:	b002      	add	sp, #8
    3b92:	bd10      	pop	{r4, pc}
    3b94:	20000180 	.word	0x20000180

00003b98 <bhy_initialize_from_rom>:
		}
		return com_rslt;
}
BHY_RETURN_FUNCTION_TYPE bhy_initialize_from_rom(
const u8 *memory, const u32 v_file_length_u32)
{
    3b98:	b5f0      	push	{r4, r5, r6, r7, lr}
    3b9a:	465f      	mov	r7, fp
    3b9c:	4656      	mov	r6, sl
    3b9e:	464d      	mov	r5, r9
    3ba0:	4644      	mov	r4, r8
    3ba2:	b4f0      	push	{r4, r5, r6, r7}
    3ba4:	b095      	sub	sp, #84	; 0x54
    3ba6:	0005      	movs	r5, r0
    3ba8:	000c      	movs	r4, r1
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_upload_addr = BHY_UPLOAD_DATA;
    3baa:	2300      	movs	r3, #0
    3bac:	223f      	movs	r2, #63	; 0x3f
    3bae:	a904      	add	r1, sp, #16
    3bb0:	468c      	mov	ip, r1
    3bb2:	4462      	add	r2, ip
    3bb4:	7013      	strb	r3, [r2, #0]
	u8 v_chip_control_u8 = BHY_CHIP_CTRL_ENABLE_1;
    3bb6:	2102      	movs	r1, #2
    3bb8:	223e      	movs	r2, #62	; 0x3e
    3bba:	4462      	add	r2, ip
    3bbc:	7011      	strb	r1, [r2, #0]
	u32 v_crc_from_memory_u32 = BHY_INIT_VALUE;
	u32 v_crc_host_u32 = BHY_INIT_VALUE;
    3bbe:	9312      	str	r3, [sp, #72]	; 0x48
    3bc0:	ab0d      	add	r3, sp, #52	; 0x34
    3bc2:	3133      	adds	r1, #51	; 0x33
    3bc4:	4461      	add	r1, ip
	u32 data_to_process = BHY_INIT_VALUE;
	u32 packet_length = BHY_INIT_VALUE;;
	u8 i = BHY_INIT_VALUE;
	/* initialize the array*/
	for (; i < BHY_SIGNATURE_MEM_LEN; i++)
	data_from_mem[i] = BHY_INIT_VALUE;
    3bc6:	2200      	movs	r2, #0
    3bc8:	701a      	strb	r2, [r3, #0]
    3bca:	3301      	adds	r3, #1
	u32 write_length = BHY_INIT_VALUE;
	u32 data_to_process = BHY_INIT_VALUE;
	u32 packet_length = BHY_INIT_VALUE;;
	u8 i = BHY_INIT_VALUE;
	/* initialize the array*/
	for (; i < BHY_SIGNATURE_MEM_LEN; i++)
    3bcc:	428b      	cmp	r3, r1
    3bce:	d1fb      	bne.n	3bc8 <bhy_initialize_from_rom+0x30>
	data_from_mem[i] = BHY_INIT_VALUE;
	for (i = BHY_INIT_VALUE; i < BHY_RAM_WRITE_LENGTH; i++)
	data_byte[i] = BHY_INIT_VALUE;
    3bd0:	ab05      	add	r3, sp, #20
    3bd2:	2200      	movs	r2, #0
    3bd4:	701a      	strb	r2, [r3, #0]
    3bd6:	705a      	strb	r2, [r3, #1]
    3bd8:	709a      	strb	r2, [r3, #2]
    3bda:	70da      	strb	r2, [r3, #3]
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
    3bdc:	4b4b      	ldr	r3, [pc, #300]	; (3d0c <bhy_initialize_from_rom+0x174>)
    3bde:	681b      	ldr	r3, [r3, #0]
    3be0:	2b00      	cmp	r3, #0
    3be2:	d100      	bne.n	3be6 <bhy_initialize_from_rom+0x4e>
    3be4:	e08a      	b.n	3cfc <bhy_initialize_from_rom+0x164>
    3be6:	2300      	movs	r3, #0
    3be8:	0028      	movs	r0, r5
		com_rslt =  BHY_NULL;
		} else {
		/* Assign the memory data into the local array*/
		for (read_index_u8 = BHY_INIT_VALUE;
		read_index_u8 <= BHY_SIGNATURE_LENGTH; read_index_u8++) {
			data_from_mem[read_index_u8] = *(memory+read_index_u8);
    3bea:	5cc1      	ldrb	r1, [r0, r3]
    3bec:	aa0d      	add	r2, sp, #52	; 0x34
    3bee:	5499      	strb	r1, [r3, r2]
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
		} else {
		/* Assign the memory data into the local array*/
		for (read_index_u8 = BHY_INIT_VALUE;
		read_index_u8 <= BHY_SIGNATURE_LENGTH; read_index_u8++) {
    3bf0:	3301      	adds	r3, #1
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
		} else {
		/* Assign the memory data into the local array*/
		for (read_index_u8 = BHY_INIT_VALUE;
    3bf2:	2b11      	cmp	r3, #17
    3bf4:	d1f9      	bne.n	3bea <bhy_initialize_from_rom+0x52>
			com_rslt = BHY_SUCCESS;
			} else {
			com_rslt = BHY_ERROR;
		}
		/* read the CRC data from memory */
		v_crc_from_memory_u32 = (u32)
    3bf6:	79d3      	ldrb	r3, [r2, #7]
    3bf8:	0619      	lsls	r1, r3, #24
    3bfa:	7993      	ldrb	r3, [r2, #6]
    3bfc:	041b      	lsls	r3, r3, #16
    3bfe:	430b      	orrs	r3, r1
    3c00:	7911      	ldrb	r1, [r2, #4]
    3c02:	430b      	orrs	r3, r1
    3c04:	7952      	ldrb	r2, [r2, #5]
    3c06:	0212      	lsls	r2, r2, #8
    3c08:	4313      	orrs	r3, r2
    3c0a:	9302      	str	r3, [sp, #8]
		| (data_from_mem[BHY_CRC_HOST_FILE_LSB]));
		/* Remove the first 16 bytes*/
		data_to_process = v_file_length_u32 - BHY_SIGNATURE_LENGTH;

		/* set the reset as 0x01*/
		com_rslt = bhy_set_reset_request(BHY_RESET_ENABLE);
    3c0c:	2001      	movs	r0, #1
    3c0e:	4b40      	ldr	r3, [pc, #256]	; (3d10 <bhy_initialize_from_rom+0x178>)
    3c10:	4798      	blx	r3
    3c12:	0006      	movs	r6, r0
		com_rslt += bhy_write_reg(BHY_I2C_REG_CHIP_CONTROL_ADDR,
    3c14:	2201      	movs	r2, #1
    3c16:	213e      	movs	r1, #62	; 0x3e
    3c18:	ab04      	add	r3, sp, #16
    3c1a:	469c      	mov	ip, r3
    3c1c:	4461      	add	r1, ip
    3c1e:	2034      	movs	r0, #52	; 0x34
    3c20:	4f3c      	ldr	r7, [pc, #240]	; (3d14 <bhy_initialize_from_rom+0x17c>)
    3c22:	47b8      	blx	r7
    3c24:	1986      	adds	r6, r0, r6
    3c26:	b2f6      	uxtb	r6, r6
		&v_chip_control_u8, BHY_GEN_READ_WRITE_LENGTH);
		/* set the upload data*/
		com_rslt += bhy_write_reg(BHY_I2C_REG_UPLOAD_0_ADDR,
    3c28:	2201      	movs	r2, #1
    3c2a:	233f      	movs	r3, #63	; 0x3f
    3c2c:	a904      	add	r1, sp, #16
    3c2e:	468c      	mov	ip, r1
    3c30:	4463      	add	r3, ip
    3c32:	0019      	movs	r1, r3
    3c34:	2094      	movs	r0, #148	; 0x94
    3c36:	47b8      	blx	r7
    3c38:	1830      	adds	r0, r6, r0
    3c3a:	b2c6      	uxtb	r6, r0
		&v_upload_addr, BHY_GEN_READ_WRITE_LENGTH);
		com_rslt += bhy_write_reg(BHY_I2C_REG_UPLOAD_1_ADDR,
    3c3c:	2201      	movs	r2, #1
    3c3e:	233f      	movs	r3, #63	; 0x3f
    3c40:	a904      	add	r1, sp, #16
    3c42:	468c      	mov	ip, r1
    3c44:	4463      	add	r3, ip
    3c46:	0019      	movs	r1, r3
    3c48:	2095      	movs	r0, #149	; 0x95
    3c4a:	47b8      	blx	r7


		/* write the memory of data */
		/*skips first 16 bytes*/
		write_data += 16;
		if (com_rslt == BHY_SUCCESS) {
    3c4c:	1830      	adds	r0, r6, r0
    3c4e:	b2c3      	uxtb	r3, r0
    3c50:	2b00      	cmp	r3, #0
    3c52:	d13b      	bne.n	3ccc <bhy_initialize_from_rom+0x134>
		<< BHY_SHIFT_BIT_POSITION_BY_16_BITS)
		|(data_from_mem[BHY_CRC_HOST_FILE_XLSB]
		<< BHY_SHIFT_BIT_POSITION_BY_08_BITS)
		| (data_from_mem[BHY_CRC_HOST_FILE_LSB]));
		/* Remove the first 16 bytes*/
		data_to_process = v_file_length_u32 - BHY_SIGNATURE_LENGTH;
    3c54:	3c10      	subs	r4, #16
		com_rslt += bhy_write_reg(BHY_I2C_REG_UPLOAD_0_ADDR,
		&v_upload_addr, BHY_GEN_READ_WRITE_LENGTH);
		com_rslt += bhy_write_reg(BHY_I2C_REG_UPLOAD_1_ADDR,
		&v_upload_addr, BHY_GEN_READ_WRITE_LENGTH);
		/* write the chip control register as 0x02*/
		write_length =
    3c56:	0963      	lsrs	r3, r4, #5
    3c58:	4698      	mov	r8, r3
			for (read_index_u8 = BHY_INIT_VALUE;
			read_index_u8 <=
			write_length; read_index_u8++) {

				packet_length = read_index_u8 == write_length ?
				(data_to_process % BHY_RAM_WRITE_LENGTH_API) / BHY_RAM_WRITE_LENGTH :
    3c5a:	06e4      	lsls	r4, r4, #27
    3c5c:	0f63      	lsrs	r3, r4, #29
    3c5e:	9303      	str	r3, [sp, #12]
    3c60:	2300      	movs	r3, #0
    3c62:	469b      	mov	fp, r3
    3c64:	3310      	adds	r3, #16
    3c66:	469a      	mov	sl, r3
						- (reverse_index_u32+1));
						}
					}

				com_rslt +=
				bhy_write_reg(BHY_I2C_REG_UPLOAD_DATA_ADDR,
    3c68:	4b2a      	ldr	r3, [pc, #168]	; (3d14 <bhy_initialize_from_rom+0x17c>)
    3c6a:	4699      	mov	r9, r3
    3c6c:	465b      	mov	r3, fp
    3c6e:	9301      	str	r3, [sp, #4]
    3c70:	46d3      	mov	fp, sl
    3c72:	46c2      	mov	sl, r8
    3c74:	46a8      	mov	r8, r5
			for (read_index_u8 = BHY_INIT_VALUE;
			read_index_u8 <=
			write_length; read_index_u8++) {

				packet_length = read_index_u8 == write_length ?
				(data_to_process % BHY_RAM_WRITE_LENGTH_API) / BHY_RAM_WRITE_LENGTH :
    3c76:	2408      	movs	r4, #8
    3c78:	9b01      	ldr	r3, [sp, #4]
    3c7a:	459a      	cmp	sl, r3
    3c7c:	d111      	bne.n	3ca2 <bhy_initialize_from_rom+0x10a>
				BHY_RAM_WRITE_LENGTH_API / BHY_RAM_WRITE_LENGTH;

				/*reverse the data*/
				for (reverse_block_index_u32 = 1 ; reverse_block_index_u32 <=
    3c7e:	9b03      	ldr	r3, [sp, #12]
    3c80:	2b00      	cmp	r3, #0
    3c82:	d10d      	bne.n	3ca0 <bhy_initialize_from_rom+0x108>
			for (read_index_u8 = BHY_INIT_VALUE;
			read_index_u8 <=
			write_length; read_index_u8++) {

				packet_length = read_index_u8 == write_length ?
				(data_to_process % BHY_RAM_WRITE_LENGTH_API) / BHY_RAM_WRITE_LENGTH :
    3c84:	001c      	movs	r4, r3
    3c86:	e016      	b.n	3cb6 <bhy_initialize_from_rom+0x11e>
				for (reverse_block_index_u32 = 1 ; reverse_block_index_u32 <=
					packet_length ;
					reverse_block_index_u32++) {
					for (reverse_index_u32 = 0; reverse_index_u32 <
						BHY_RAM_WRITE_LENGTH; reverse_index_u32++) {
						data_byte[reverse_index_u32 + ((reverse_block_index_u32-1)*BHY_RAM_WRITE_LENGTH)] =
    3c88:	7819      	ldrb	r1, [r3, #0]
    3c8a:	7011      	strb	r1, [r2, #0]
    3c8c:	3b01      	subs	r3, #1
    3c8e:	3201      	adds	r2, #1

				/*reverse the data*/
				for (reverse_block_index_u32 = 1 ; reverse_block_index_u32 <=
					packet_length ;
					reverse_block_index_u32++) {
					for (reverse_index_u32 = 0; reverse_index_u32 <
    3c90:	4283      	cmp	r3, r0
    3c92:	d1f9      	bne.n	3c88 <bhy_initialize_from_rom+0xf0>
				BHY_RAM_WRITE_LENGTH_API / BHY_RAM_WRITE_LENGTH;

				/*reverse the data*/
				for (reverse_block_index_u32 = 1 ; reverse_block_index_u32 <=
					packet_length ;
					reverse_block_index_u32++) {
    3c94:	3701      	adds	r7, #1
    3c96:	3504      	adds	r5, #4
    3c98:	3604      	adds	r6, #4
				packet_length = read_index_u8 == write_length ?
				(data_to_process % BHY_RAM_WRITE_LENGTH_API) / BHY_RAM_WRITE_LENGTH :
				BHY_RAM_WRITE_LENGTH_API / BHY_RAM_WRITE_LENGTH;

				/*reverse the data*/
				for (reverse_block_index_u32 = 1 ; reverse_block_index_u32 <=
    3c9a:	42bc      	cmp	r4, r7
    3c9c:	d207      	bcs.n	3cae <bhy_initialize_from_rom+0x116>
    3c9e:	e00a      	b.n	3cb6 <bhy_initialize_from_rom+0x11e>
			for (read_index_u8 = BHY_INIT_VALUE;
			read_index_u8 <=
			write_length; read_index_u8++) {

				packet_length = read_index_u8 == write_length ?
				(data_to_process % BHY_RAM_WRITE_LENGTH_API) / BHY_RAM_WRITE_LENGTH :
    3ca0:	9c03      	ldr	r4, [sp, #12]
    3ca2:	465b      	mov	r3, fp
    3ca4:	3303      	adds	r3, #3
    3ca6:	4443      	add	r3, r8
    3ca8:	001d      	movs	r5, r3
    3caa:	ae05      	add	r6, sp, #20
    3cac:	2701      	movs	r7, #1
    3cae:	1f28      	subs	r0, r5, #4
    3cb0:	0032      	movs	r2, r6
    3cb2:	002b      	movs	r3, r5
    3cb4:	e7e8      	b.n	3c88 <bhy_initialize_from_rom+0xf0>
						- (reverse_index_u32+1));
						}
					}

				com_rslt +=
				bhy_write_reg(BHY_I2C_REG_UPLOAD_DATA_ADDR,
    3cb6:	00a2      	lsls	r2, r4, #2
    3cb8:	a905      	add	r1, sp, #20
    3cba:	2096      	movs	r0, #150	; 0x96
    3cbc:	47c8      	blx	r9
				data_byte,
				packet_length * BHY_RAM_WRITE_LENGTH);
				write_data = write_data
    3cbe:	00a4      	lsls	r4, r4, #2
    3cc0:	44a3      	add	fp, r4
		/*skips first 16 bytes*/
		write_data += 16;
		if (com_rslt == BHY_SUCCESS) {
			for (read_index_u8 = BHY_INIT_VALUE;
			read_index_u8 <=
			write_length; read_index_u8++) {
    3cc2:	9b01      	ldr	r3, [sp, #4]
    3cc4:	3301      	adds	r3, #1
    3cc6:	9301      	str	r3, [sp, #4]

		/* write the memory of data */
		/*skips first 16 bytes*/
		write_data += 16;
		if (com_rslt == BHY_SUCCESS) {
			for (read_index_u8 = BHY_INIT_VALUE;
    3cc8:	459a      	cmp	sl, r3
    3cca:	d2d4      	bcs.n	3c76 <bhy_initialize_from_rom+0xde>
				+ (packet_length * BHY_RAM_WRITE_LENGTH);
			}
		}

		/* Check the CRC success*/
		com_rslt = bhy_get_crc_host(&v_crc_host_u32);
    3ccc:	a812      	add	r0, sp, #72	; 0x48
    3cce:	4b12      	ldr	r3, [pc, #72]	; (3d18 <bhy_initialize_from_rom+0x180>)
    3cd0:	4798      	blx	r3
		if (v_crc_from_memory_u32 == v_crc_host_u32)
    3cd2:	9b02      	ldr	r3, [sp, #8]
    3cd4:	9a12      	ldr	r2, [sp, #72]	; 0x48
    3cd6:	4293      	cmp	r3, r2
    3cd8:	d002      	beq.n	3ce0 <bhy_initialize_from_rom+0x148>
		com_rslt = BHY_SUCCESS;
		else
		com_rslt = BHY_ERROR;
    3cda:	2403      	movs	r4, #3
    3cdc:	4264      	negs	r4, r4
    3cde:	e000      	b.n	3ce2 <bhy_initialize_from_rom+0x14a>
		}

		/* Check the CRC success*/
		com_rslt = bhy_get_crc_host(&v_crc_host_u32);
		if (v_crc_from_memory_u32 == v_crc_host_u32)
		com_rslt = BHY_SUCCESS;
    3ce0:	2400      	movs	r4, #0
		else
		com_rslt = BHY_ERROR;
		/* disable upload mode*/
		v_chip_control_u8 = BHY_CHIP_CTRL_ENABLE_2;
    3ce2:	213e      	movs	r1, #62	; 0x3e
    3ce4:	ab04      	add	r3, sp, #16
    3ce6:	469c      	mov	ip, r3
    3ce8:	4461      	add	r1, ip
    3cea:	2301      	movs	r3, #1
    3cec:	700b      	strb	r3, [r1, #0]
		/* write the chip control register as 0x02*/
		com_rslt += bhy_write_reg(BHY_I2C_REG_CHIP_CONTROL_ADDR,
    3cee:	2201      	movs	r2, #1
    3cf0:	2034      	movs	r0, #52	; 0x34
    3cf2:	4b08      	ldr	r3, [pc, #32]	; (3d14 <bhy_initialize_from_rom+0x17c>)
    3cf4:	4798      	blx	r3
    3cf6:	1900      	adds	r0, r0, r4
    3cf8:	b240      	sxtb	r0, r0
    3cfa:	e000      	b.n	3cfe <bhy_initialize_from_rom+0x166>
	data_from_mem[i] = BHY_INIT_VALUE;
	for (i = BHY_INIT_VALUE; i < BHY_RAM_WRITE_LENGTH; i++)
	data_byte[i] = BHY_INIT_VALUE;
	/* check the p_bhy pointer as NULL*/
	if (BHY_NULL_PTR == p_bhy) {
		com_rslt =  BHY_NULL;
    3cfc:	2000      	movs	r0, #0
		com_rslt += bhy_write_reg(BHY_I2C_REG_CHIP_CONTROL_ADDR,
		&v_chip_control_u8, BHY_GEN_READ_WRITE_LENGTH);

	}
	return com_rslt;
}
    3cfe:	b015      	add	sp, #84	; 0x54
    3d00:	bc3c      	pop	{r2, r3, r4, r5}
    3d02:	4690      	mov	r8, r2
    3d04:	4699      	mov	r9, r3
    3d06:	46a2      	mov	sl, r4
    3d08:	46ab      	mov	fp, r5
    3d0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3d0c:	20000180 	.word	0x20000180
    3d10:	00003b71 	.word	0x00003b71
    3d14:	000039dd 	.word	0x000039dd
    3d18:	00003b2d 	.word	0x00003b2d

00003d1c <bhy_write_parameter_bytes>:
 *
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_write_parameter_bytes(
u8 v_page_select_u8, u8 v_parameter_request_u8)
{
    3d1c:	b5f0      	push	{r4, r5, r6, r7, lr}
    3d1e:	4657      	mov	r7, sl
    3d20:	464e      	mov	r6, r9
    3d22:	4645      	mov	r5, r8
    3d24:	b4e0      	push	{r5, r6, r7}
    3d26:	b084      	sub	sp, #16
    3d28:	0004      	movs	r4, r0
    3d2a:	468a      	mov	sl, r1
/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	u8 v_parameter_ack_u8 = BHY_INIT_VALUE;
    3d2c:	2200      	movs	r2, #0
    3d2e:	230f      	movs	r3, #15
    3d30:	446b      	add	r3, sp
    3d32:	701a      	strb	r2, [r3, #0]
    3d34:	2300      	movs	r3, #0
	u8 v_parameter_ack_check_u8 = BHY_INIT_VALUE;
	u8 v_write_parameter_byte_u8[BHY_WRITE_BUFFER_SIZE];
	u8 init_array_data = BHY_INIT_VALUE;

	for (; init_array_data < BHY_WRITE_BUFFER_SIZE; init_array_data++)
		v_write_parameter_byte_u8[init_array_data] = BHY_INIT_VALUE;
    3d36:	2100      	movs	r1, #0
    3d38:	aa01      	add	r2, sp, #4
    3d3a:	5499      	strb	r1, [r3, r2]
    3d3c:	3301      	adds	r3, #1
	u8 v_parameter_ack_u8 = BHY_INIT_VALUE;
	u8 v_parameter_ack_check_u8 = BHY_INIT_VALUE;
	u8 v_write_parameter_byte_u8[BHY_WRITE_BUFFER_SIZE];
	u8 init_array_data = BHY_INIT_VALUE;

	for (; init_array_data < BHY_WRITE_BUFFER_SIZE; init_array_data++)
    3d3e:	2b08      	cmp	r3, #8
    3d40:	d1fa      	bne.n	3d38 <bhy_write_parameter_bytes+0x1c>
		v_write_parameter_byte_u8[init_array_data] = BHY_INIT_VALUE;
	/* check the p_bhy structure as NULL*/
	if (p_bhy == BHY_NULL) {
    3d42:	4b26      	ldr	r3, [pc, #152]	; (3ddc <bhy_write_parameter_bytes+0xc0>)
    3d44:	6819      	ldr	r1, [r3, #0]
    3d46:	2900      	cmp	r1, #0
    3d48:	d03e      	beq.n	3dc8 <bhy_write_parameter_bytes+0xac>
		return BHY_NULL;
		} else {
		/* Assign the load parameters*/
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_1_REG]
		= write_buffer.write_parameter_byte1;
    3d4a:	4b25      	ldr	r3, [pc, #148]	; (3de0 <bhy_write_parameter_bytes+0xc4>)
    3d4c:	7818      	ldrb	r0, [r3, #0]
    3d4e:	7010      	strb	r0, [r2, #0]
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_2_REG]
		= write_buffer.write_parameter_byte2;
    3d50:	7858      	ldrb	r0, [r3, #1]
    3d52:	7050      	strb	r0, [r2, #1]
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_3_REG]
		= write_buffer.write_parameter_byte3;
    3d54:	7898      	ldrb	r0, [r3, #2]
    3d56:	7090      	strb	r0, [r2, #2]
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_4_REG]
		= write_buffer.write_parameter_byte4;
    3d58:	78d8      	ldrb	r0, [r3, #3]
    3d5a:	70d0      	strb	r0, [r2, #3]
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_5_REG]
		= write_buffer.write_parameter_byte5;
    3d5c:	7918      	ldrb	r0, [r3, #4]
    3d5e:	7110      	strb	r0, [r2, #4]
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_6_REG]
		= write_buffer.write_parameter_byte6;
    3d60:	7958      	ldrb	r0, [r3, #5]
    3d62:	7150      	strb	r0, [r2, #5]
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_7_REG]
		= write_buffer.write_parameter_byte7;
    3d64:	7998      	ldrb	r0, [r3, #6]
    3d66:	7190      	strb	r0, [r2, #6]
		v_write_parameter_byte_u8[BHY_WRITE_BUFFER_8_REG]
		= write_buffer.write_parameter_byte8;
    3d68:	79db      	ldrb	r3, [r3, #7]
    3d6a:	71d3      	strb	r3, [r2, #7]
		/* write values to the load address*/
		com_rslt = p_bhy->BHY_BUS_WRITE_FUNC
    3d6c:	7848      	ldrb	r0, [r1, #1]
    3d6e:	684d      	ldr	r5, [r1, #4]
    3d70:	2308      	movs	r3, #8
    3d72:	215c      	movs	r1, #92	; 0x5c
    3d74:	47a8      	blx	r5
    3d76:	0005      	movs	r5, r0
		(p_bhy->device_addr,
		BHY_I2C_REG_PARAMETER_WRITE_BUFFER_ZERO,
		&v_write_parameter_byte_u8[BHY_WRITE_BUFFER_1_REG],
		BHY_WRITE_BUFFER_SIZE);
		/* select the page*/
		com_rslt += bhy_set_parameter_page_select(v_page_select_u8);
    3d78:	0020      	movs	r0, r4
    3d7a:	4b1a      	ldr	r3, [pc, #104]	; (3de4 <bhy_write_parameter_bytes+0xc8>)
    3d7c:	4798      	blx	r3
    3d7e:	1945      	adds	r5, r0, r5
    3d80:	b2ec      	uxtb	r4, r5
		/* select the parameter*/
		com_rslt += bhy_set_parameter_request(v_parameter_request_u8);
    3d82:	4650      	mov	r0, sl
    3d84:	4b18      	ldr	r3, [pc, #96]	; (3de8 <bhy_write_parameter_bytes+0xcc>)
    3d86:	4798      	blx	r3
    3d88:	1824      	adds	r4, r4, r0
    3d8a:	b267      	sxtb	r7, r4
    3d8c:	2614      	movs	r6, #20
		for (v_parameter_ack_check_u8 = BHY_INIT_VALUE;
		v_parameter_ack_check_u8 < BHY_PARAMETER_ACK_LENGTH;
		v_parameter_ack_check_u8++) {
			/* read the acknowledgement*/
			com_rslt += bhy_get_parameter_acknowledge(
    3d8e:	250f      	movs	r5, #15
    3d90:	446d      	add	r5, sp
    3d92:	4b16      	ldr	r3, [pc, #88]	; (3dec <bhy_write_parameter_bytes+0xd0>)
    3d94:	4698      	mov	r8, r3
			if (v_parameter_ack_u8 == v_parameter_request_u8) {
				com_rslt += BHY_SUCCESS;
				break;
			} else if (v_parameter_ack_u8
			== BHY_PARAMETER_ACK_CHECK) {
				p_bhy->delay_msec(BHY_PARAMETER_ACK_DELAY);
    3d96:	4b11      	ldr	r3, [pc, #68]	; (3ddc <bhy_write_parameter_bytes+0xc0>)
    3d98:	4699      	mov	r9, r3
		com_rslt += bhy_set_parameter_request(v_parameter_request_u8);
		for (v_parameter_ack_check_u8 = BHY_INIT_VALUE;
		v_parameter_ack_check_u8 < BHY_PARAMETER_ACK_LENGTH;
		v_parameter_ack_check_u8++) {
			/* read the acknowledgement*/
			com_rslt += bhy_get_parameter_acknowledge(
    3d9a:	0028      	movs	r0, r5
    3d9c:	47c0      	blx	r8
    3d9e:	19c0      	adds	r0, r0, r7
    3da0:	b2c4      	uxtb	r4, r0
    3da2:	b267      	sxtb	r7, r4
			&v_parameter_ack_u8);
			if (v_parameter_ack_u8 == v_parameter_request_u8) {
    3da4:	782b      	ldrb	r3, [r5, #0]
    3da6:	459a      	cmp	sl, r3
    3da8:	d010      	beq.n	3dcc <bhy_write_parameter_bytes+0xb0>
				com_rslt += BHY_SUCCESS;
				break;
			} else if (v_parameter_ack_u8
    3daa:	2b80      	cmp	r3, #128	; 0x80
    3dac:	d106      	bne.n	3dbc <bhy_write_parameter_bytes+0xa0>
			== BHY_PARAMETER_ACK_CHECK) {
				p_bhy->delay_msec(BHY_PARAMETER_ACK_DELAY);
    3dae:	464b      	mov	r3, r9
    3db0:	681b      	ldr	r3, [r3, #0]
    3db2:	691b      	ldr	r3, [r3, #16]
    3db4:	2032      	movs	r0, #50	; 0x32
    3db6:	4798      	blx	r3
				com_rslt += BHY_ERROR;
    3db8:	3c03      	subs	r4, #3
    3dba:	b267      	sxtb	r7, r4
    3dbc:	3e01      	subs	r6, #1
    3dbe:	b2f6      	uxtb	r6, r6
		BHY_WRITE_BUFFER_SIZE);
		/* select the page*/
		com_rslt += bhy_set_parameter_page_select(v_page_select_u8);
		/* select the parameter*/
		com_rslt += bhy_set_parameter_request(v_parameter_request_u8);
		for (v_parameter_ack_check_u8 = BHY_INIT_VALUE;
    3dc0:	2e00      	cmp	r6, #0
    3dc2:	d1ea      	bne.n	3d9a <bhy_write_parameter_bytes+0x7e>
    3dc4:	0038      	movs	r0, r7
    3dc6:	e002      	b.n	3dce <bhy_write_parameter_bytes+0xb2>

	for (; init_array_data < BHY_WRITE_BUFFER_SIZE; init_array_data++)
		v_write_parameter_byte_u8[init_array_data] = BHY_INIT_VALUE;
	/* check the p_bhy structure as NULL*/
	if (p_bhy == BHY_NULL) {
		return BHY_NULL;
    3dc8:	2000      	movs	r0, #0
    3dca:	e000      	b.n	3dce <bhy_write_parameter_bytes+0xb2>
		com_rslt += bhy_set_parameter_request(v_parameter_request_u8);
		for (v_parameter_ack_check_u8 = BHY_INIT_VALUE;
		v_parameter_ack_check_u8 < BHY_PARAMETER_ACK_LENGTH;
		v_parameter_ack_check_u8++) {
			/* read the acknowledgement*/
			com_rslt += bhy_get_parameter_acknowledge(
    3dcc:	0038      	movs	r0, r7
			}
		}

	}
	return com_rslt;
}
    3dce:	b004      	add	sp, #16
    3dd0:	bc1c      	pop	{r2, r3, r4}
    3dd2:	4690      	mov	r8, r2
    3dd4:	4699      	mov	r9, r3
    3dd6:	46a2      	mov	sl, r4
    3dd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3dda:	46c0      	nop			; (mov r8, r8)
    3ddc:	20000180 	.word	0x20000180
    3de0:	20000178 	.word	0x20000178
    3de4:	00003add 	.word	0x00003add
    3de8:	00003b05 	.word	0x00003b05
    3dec:	00003aa9 	.word	0x00003aa9

00003df0 <bhy_set_non_wakeup_sensor_configuration>:
 *
*/
BHY_RETURN_FUNCTION_TYPE bhy_set_non_wakeup_sensor_configuration(
struct sensor_configuration_non_wakeup_t *sensor_configuration,
u8 v_parameter_request_u8)
{
    3df0:	b510      	push	{r4, lr}
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	/* write sample rate*/
	write_buffer.write_parameter_byte1 = (u8)(
	sensor_configuration->non_wakeup_sample_rate & BHY_MASK_LSB_DATA);
    3df2:	8802      	ldrh	r2, [r0, #0]
u8 v_parameter_request_u8)
{
	/* variable used for return the status of communication result*/
	BHY_RETURN_FUNCTION_TYPE com_rslt = BHY_COMM_RES;
	/* write sample rate*/
	write_buffer.write_parameter_byte1 = (u8)(
    3df4:	4b09      	ldr	r3, [pc, #36]	; (3e1c <bhy_set_non_wakeup_sensor_configuration+0x2c>)
    3df6:	701a      	strb	r2, [r3, #0]
	sensor_configuration->non_wakeup_sample_rate & BHY_MASK_LSB_DATA);
	write_buffer.write_parameter_byte2 = (u8)
    3df8:	0a12      	lsrs	r2, r2, #8
    3dfa:	705a      	strb	r2, [r3, #1]
	(sensor_configuration->non_wakeup_sample_rate
	>> BHY_SHIFT_BIT_POSITION_BY_08_BITS);
	/* write maximum report latency*/
	write_buffer.write_parameter_byte3 = (u8)(
	sensor_configuration->non_wakeup_max_report_latency
    3dfc:	8842      	ldrh	r2, [r0, #2]
	sensor_configuration->non_wakeup_sample_rate & BHY_MASK_LSB_DATA);
	write_buffer.write_parameter_byte2 = (u8)
	(sensor_configuration->non_wakeup_sample_rate
	>> BHY_SHIFT_BIT_POSITION_BY_08_BITS);
	/* write maximum report latency*/
	write_buffer.write_parameter_byte3 = (u8)(
    3dfe:	709a      	strb	r2, [r3, #2]
	sensor_configuration->non_wakeup_max_report_latency
	& BHY_MASK_LSB_DATA);
	write_buffer.write_parameter_byte4 = (u8)
    3e00:	0a12      	lsrs	r2, r2, #8
    3e02:	70da      	strb	r2, [r3, #3]
	(sensor_configuration->non_wakeup_max_report_latency
	>> BHY_SHIFT_BIT_POSITION_BY_08_BITS);
	/* write sensitivity*/
	write_buffer.write_parameter_byte5 = (u8)(
	sensor_configuration->non_wakeup_change_sensitivity
    3e04:	8882      	ldrh	r2, [r0, #4]
	& BHY_MASK_LSB_DATA);
	write_buffer.write_parameter_byte4 = (u8)
	(sensor_configuration->non_wakeup_max_report_latency
	>> BHY_SHIFT_BIT_POSITION_BY_08_BITS);
	/* write sensitivity*/
	write_buffer.write_parameter_byte5 = (u8)(
    3e06:	711a      	strb	r2, [r3, #4]
	sensor_configuration->non_wakeup_change_sensitivity
	 & BHY_MASK_LSB_DATA);
	write_buffer.write_parameter_byte6 = (u8)
    3e08:	0a12      	lsrs	r2, r2, #8
    3e0a:	715a      	strb	r2, [r3, #5]
	(sensor_configuration->non_wakeup_change_sensitivity
	>> BHY_SHIFT_BIT_POSITION_BY_08_BITS);
	/* write dynamic range*/
	write_buffer.write_parameter_byte7 = (u8)(
	sensor_configuration->non_wakeup_dynamic_range & BHY_MASK_LSB_DATA);
    3e0c:	88c2      	ldrh	r2, [r0, #6]
	 & BHY_MASK_LSB_DATA);
	write_buffer.write_parameter_byte6 = (u8)
	(sensor_configuration->non_wakeup_change_sensitivity
	>> BHY_SHIFT_BIT_POSITION_BY_08_BITS);
	/* write dynamic range*/
	write_buffer.write_parameter_byte7 = (u8)(
    3e0e:	719a      	strb	r2, [r3, #6]
	sensor_configuration->non_wakeup_dynamic_range & BHY_MASK_LSB_DATA);
	write_buffer.write_parameter_byte8 = (u8)
    3e10:	0a12      	lsrs	r2, r2, #8
    3e12:	71da      	strb	r2, [r3, #7]
	(sensor_configuration->non_wakeup_dynamic_range
	>> BHY_SHIFT_BIT_POSITION_BY_08_BITS);
	/* load the parameter of non wakeup sensor configuration*/
	com_rslt = bhy_write_parameter_bytes(
    3e14:	2003      	movs	r0, #3
    3e16:	4b02      	ldr	r3, [pc, #8]	; (3e20 <bhy_set_non_wakeup_sensor_configuration+0x30>)
    3e18:	4798      	blx	r3
	BHY_PAGE_3, v_parameter_request_u8);

	return com_rslt;
}
    3e1a:	bd10      	pop	{r4, pc}
    3e1c:	20000178 	.word	0x20000178
    3e20:	00003d1d 	.word	0x00003d1d

00003e24 <bhy_i2c_write>:
}



int8_t bhy_i2c_write(uint8_t dev_addr, uint8_t reg_addr, uint8_t *reg_data, uint16_t length)
{
    3e24:	b5b0      	push	{r4, r5, r7, lr}
    3e26:	af00      	add	r7, sp, #0
	enum status_code bhy_write_stat = STATUS_BUSY;

    uint8_t i, buffer[length + REG_ADDR_LENGTH_BYTE];
    3e28:	001c      	movs	r4, r3
    3e2a:	3408      	adds	r4, #8
    3e2c:	08e4      	lsrs	r4, r4, #3
    3e2e:	00e4      	lsls	r4, r4, #3
    3e30:	466d      	mov	r5, sp
    3e32:	1b2c      	subs	r4, r5, r4
    3e34:	46a5      	mov	sp, r4
    3e36:	466d      	mov	r5, sp


    buffer[0] = reg_addr;
    3e38:	7029      	strb	r1, [r5, #0]

	for (i=1; i<=length; i++)
    3e3a:	2b00      	cmp	r3, #0
    3e3c:	d008      	beq.n	3e50 <bhy_i2c_write+0x2c>
    3e3e:	2101      	movs	r1, #1
	{
		buffer[i] = *reg_data++;
    3e40:	7814      	ldrb	r4, [r2, #0]
    3e42:	546c      	strb	r4, [r5, r1]
    uint8_t i, buffer[length + REG_ADDR_LENGTH_BYTE];


    buffer[0] = reg_addr;

	for (i=1; i<=length; i++)
    3e44:	3101      	adds	r1, #1
    3e46:	b2c9      	uxtb	r1, r1
    3e48:	3201      	adds	r2, #1
    3e4a:	b28c      	uxth	r4, r1
    3e4c:	42a3      	cmp	r3, r4
    3e4e:	d2f7      	bcs.n	3e40 <bhy_i2c_write+0x1c>
	{
		buffer[i] = *reg_data++;
	}

 	bhy_i2c_wr_pkt.address	   = dev_addr;	//i2c slave address
    3e50:	4908      	ldr	r1, [pc, #32]	; (3e74 <bhy_i2c_write+0x50>)
    3e52:	8008      	strh	r0, [r1, #0]
	bhy_i2c_wr_pkt.data	       = buffer; //&reg_addr; // send register address
    3e54:	604d      	str	r5, [r1, #4]
	bhy_i2c_wr_pkt.data_length = length + REG_ADDR_LENGTH_BYTE; //REG_ADDR_LENGTH_BYTE; // address length always one byte
    3e56:	3301      	adds	r3, #1
    3e58:	804b      	strh	r3, [r1, #2]
	bhy_i2c_wr_pkt.ten_bit_address = false;
    3e5a:	2300      	movs	r3, #0
    3e5c:	720b      	strb	r3, [r1, #8]
	bhy_i2c_wr_pkt.high_speed = false;
    3e5e:	724b      	strb	r3, [r1, #9]
	bhy_write_stat = i2c_master_write_packet_wait(&i2c_master_instance, &bhy_i2c_wr_pkt);
    3e60:	4805      	ldr	r0, [pc, #20]	; (3e78 <bhy_i2c_write+0x54>)
    3e62:	4b06      	ldr	r3, [pc, #24]	; (3e7c <bhy_i2c_write+0x58>)
    3e64:	4798      	blx	r3


	if (bhy_write_stat != STATUS_OK){
    3e66:	2800      	cmp	r0, #0
    3e68:	d001      	beq.n	3e6e <bhy_i2c_write+0x4a>
		return BHY_ERROR;
    3e6a:	2003      	movs	r0, #3
    3e6c:	4240      	negs	r0, r0
	}
	return BHY_SUCCESS;
}
    3e6e:	46bd      	mov	sp, r7
    3e70:	bdb0      	pop	{r4, r5, r7, pc}
    3e72:	46c0      	nop			; (mov r8, r8)
    3e74:	20000e4c 	.word	0x20000e4c
    3e78:	20000e6c 	.word	0x20000e6c
    3e7c:	00004f75 	.word	0x00004f75

00003e80 <bhy_i2c_read>:


int8_t bhy_i2c_read(uint8_t dev_addr, uint8_t reg_addr, uint8_t *rx_data, uint16_t length)
{
    3e80:	b570      	push	{r4, r5, r6, lr}
    3e82:	b082      	sub	sp, #8
    3e84:	0016      	movs	r6, r2
    3e86:	001d      	movs	r5, r3
    3e88:	466b      	mov	r3, sp
    3e8a:	71d9      	strb	r1, [r3, #7]
    3e8c:	3307      	adds	r3, #7
	enum status_code bhy_read_stat = STATUS_BUSY, bhy_write_stat = STATUS_BUSY;

	bhy_i2c_wr_pkt.address	   = dev_addr;	//i2c slave address
    3e8e:	b284      	uxth	r4, r0
    3e90:	4910      	ldr	r1, [pc, #64]	; (3ed4 <bhy_i2c_read+0x54>)
    3e92:	800c      	strh	r4, [r1, #0]
	bhy_i2c_wr_pkt.data	       = &reg_addr; // send register address
    3e94:	604b      	str	r3, [r1, #4]
	bhy_i2c_wr_pkt.data_length = REG_ADDR_LENGTH_BYTE; // address length always one byte
    3e96:	2301      	movs	r3, #1
    3e98:	804b      	strh	r3, [r1, #2]
	bhy_i2c_wr_pkt.ten_bit_address = false;
    3e9a:	2300      	movs	r3, #0
    3e9c:	720b      	strb	r3, [r1, #8]
	bhy_i2c_wr_pkt.high_speed = false;
    3e9e:	724b      	strb	r3, [r1, #9]
	bhy_write_stat = i2c_master_write_packet_wait_no_stop(&i2c_master_instance, &bhy_i2c_wr_pkt);
    3ea0:	480d      	ldr	r0, [pc, #52]	; (3ed8 <bhy_i2c_read+0x58>)
    3ea2:	4b0e      	ldr	r3, [pc, #56]	; (3edc <bhy_i2c_read+0x5c>)
    3ea4:	4798      	blx	r3

	if (bhy_write_stat != STATUS_OK){
    3ea6:	2800      	cmp	r0, #0
    3ea8:	d10c      	bne.n	3ec4 <bhy_i2c_read+0x44>
		return BHY_ERROR;
	}

	bhy_i2c_rd_pkt.address	   = dev_addr;	//i2c slave address
    3eaa:	490d      	ldr	r1, [pc, #52]	; (3ee0 <bhy_i2c_read+0x60>)
    3eac:	800c      	strh	r4, [r1, #0]
	bhy_i2c_rd_pkt.data	       = rx_data; // send register address
    3eae:	604e      	str	r6, [r1, #4]
	bhy_i2c_rd_pkt.data_length = length; // address length always one byte
    3eb0:	804d      	strh	r5, [r1, #2]
	bhy_i2c_rd_pkt.ten_bit_address = false;
    3eb2:	2300      	movs	r3, #0
    3eb4:	720b      	strb	r3, [r1, #8]
	bhy_i2c_rd_pkt.high_speed = false;
    3eb6:	724b      	strb	r3, [r1, #9]
	bhy_read_stat = i2c_master_read_packet_wait(&i2c_master_instance, &bhy_i2c_rd_pkt);
    3eb8:	4807      	ldr	r0, [pc, #28]	; (3ed8 <bhy_i2c_read+0x58>)
    3eba:	4b0a      	ldr	r3, [pc, #40]	; (3ee4 <bhy_i2c_read+0x64>)
    3ebc:	4798      	blx	r3

	if (bhy_read_stat != STATUS_OK){
    3ebe:	2800      	cmp	r0, #0
    3ec0:	d103      	bne.n	3eca <bhy_i2c_read+0x4a>
    3ec2:	e004      	b.n	3ece <bhy_i2c_read+0x4e>
	bhy_i2c_wr_pkt.ten_bit_address = false;
	bhy_i2c_wr_pkt.high_speed = false;
	bhy_write_stat = i2c_master_write_packet_wait_no_stop(&i2c_master_instance, &bhy_i2c_wr_pkt);

	if (bhy_write_stat != STATUS_OK){
		return BHY_ERROR;
    3ec4:	2003      	movs	r0, #3
    3ec6:	4240      	negs	r0, r0
    3ec8:	e001      	b.n	3ece <bhy_i2c_read+0x4e>
	bhy_i2c_rd_pkt.ten_bit_address = false;
	bhy_i2c_rd_pkt.high_speed = false;
	bhy_read_stat = i2c_master_read_packet_wait(&i2c_master_instance, &bhy_i2c_rd_pkt);

	if (bhy_read_stat != STATUS_OK){
		return BHY_ERROR;
    3eca:	2003      	movs	r0, #3
    3ecc:	4240      	negs	r0, r0
	}

	return BHY_SUCCESS;
}
    3ece:	b002      	add	sp, #8
    3ed0:	bd70      	pop	{r4, r5, r6, pc}
    3ed2:	46c0      	nop			; (mov r8, r8)
    3ed4:	20000e4c 	.word	0x20000e4c
    3ed8:	20000e6c 	.word	0x20000e6c
    3edc:	00004f95 	.word	0x00004f95
    3ee0:	20000e60 	.word	0x20000e60
    3ee4:	00004f55 	.word	0x00004f55

00003ee8 <bhy_delay_msec>:


void bhy_delay_msec(u32 msec)
{
    3ee8:	b510      	push	{r4, lr}
	//mdelay(msec);
	delay_ms(msec);
    3eea:	4b01      	ldr	r3, [pc, #4]	; (3ef0 <bhy_delay_msec+0x8>)
    3eec:	4798      	blx	r3
}
    3eee:	bd10      	pop	{r4, pc}
    3ef0:	000062b1 	.word	0x000062b1

00003ef4 <bhy_reset>:


void bhy_reset(void)
{
    3ef4:	b510      	push	{r4, lr}
	bhy_set_reset_request(BHY_RESET_ENABLE);
    3ef6:	2001      	movs	r0, #1
    3ef8:	4b01      	ldr	r3, [pc, #4]	; (3f00 <bhy_reset+0xc>)
    3efa:	4798      	blx	r3
}
    3efc:	bd10      	pop	{r4, pc}
    3efe:	46c0      	nop			; (mov r8, r8)
    3f00:	00003b71 	.word	0x00003b71

00003f04 <bhy_initialize_support>:


extern void mdelay(uint32_t ul_dly_ticks);

void bhy_initialize_support(void)
{
    3f04:	b510      	push	{r4, lr}
	bhy.bus_write = &bhy_i2c_write;
    3f06:	4c07      	ldr	r4, [pc, #28]	; (3f24 <bhy_initialize_support+0x20>)
    3f08:	4b07      	ldr	r3, [pc, #28]	; (3f28 <bhy_initialize_support+0x24>)
    3f0a:	6063      	str	r3, [r4, #4]
	bhy.bus_read = &bhy_i2c_read;
    3f0c:	4b07      	ldr	r3, [pc, #28]	; (3f2c <bhy_initialize_support+0x28>)
    3f0e:	60a3      	str	r3, [r4, #8]
	bhy.delay_msec = &bhy_delay_msec;
    3f10:	4b07      	ldr	r3, [pc, #28]	; (3f30 <bhy_initialize_support+0x2c>)
    3f12:	6123      	str	r3, [r4, #16]
	bhy.device_addr = BHY_I2C_SLAVE_ADDRESS;
    3f14:	2328      	movs	r3, #40	; 0x28
    3f16:	7063      	strb	r3, [r4, #1]

	bhy_reset();
    3f18:	4b06      	ldr	r3, [pc, #24]	; (3f34 <bhy_initialize_support+0x30>)
    3f1a:	4798      	blx	r3

	bhy_init(&bhy);
    3f1c:	0020      	movs	r0, r4
    3f1e:	4b06      	ldr	r3, [pc, #24]	; (3f38 <bhy_initialize_support+0x34>)
    3f20:	4798      	blx	r3
}
    3f22:	bd10      	pop	{r4, pc}
    3f24:	20000e30 	.word	0x20000e30
    3f28:	00003e25 	.word	0x00003e25
    3f2c:	00003e81 	.word	0x00003e81
    3f30:	00003ee9 	.word	0x00003ee9
    3f34:	00003ef5 	.word	0x00003ef5
    3f38:	000039b1 	.word	0x000039b1

00003f3c <bhy_driver_init>:


/* initializes the driver, the API and loads the ram patch into the sensor */
BHY_RETURN_FUNCTION_TYPE bhy_driver_init(
	const u8 *bhy_fw_data, const u32 bhy_fw_len)
{
    3f3c:	b570      	push	{r4, r5, r6, lr}
    3f3e:	0004      	movs	r4, r0
    3f40:	000d      	movs	r5, r1
	BHY_RETURN_FUNCTION_TYPE result= BHY_SUCCESS;

	bhy_initialize_support();
    3f42:	4b03      	ldr	r3, [pc, #12]	; (3f50 <bhy_driver_init+0x14>)
    3f44:	4798      	blx	r3

	/* downloads the ram patch to the BHy */
	result += bhy_initialize_from_rom(bhy_fw_data, bhy_fw_len);
    3f46:	0029      	movs	r1, r5
    3f48:	0020      	movs	r0, r4
    3f4a:	4b02      	ldr	r3, [pc, #8]	; (3f54 <bhy_driver_init+0x18>)
    3f4c:	4798      	blx	r3

	return result;
}
    3f4e:	bd70      	pop	{r4, r5, r6, pc}
    3f50:	00003f05 	.word	0x00003f05
    3f54:	00003b99 	.word	0x00003b99

00003f58 <bhy_enable_virtual_sensor>:

/* this functions enables the selected virtual sensor */
BHY_RETURN_FUNCTION_TYPE bhy_enable_virtual_sensor
	(	bhy_virtual_sensor_t sensor_id, u8 wakeup_status, u16 sample_rate,
		u16 max_report_latency_ms, u8 flush_sensor, u16 change_sensitivity,
		u16 dynamic_range ) {
    3f58:	b5f0      	push	{r4, r5, r6, r7, lr}
    3f5a:	4657      	mov	r7, sl
    3f5c:	b480      	push	{r7}
    3f5e:	b084      	sub	sp, #16
    3f60:	000f      	movs	r7, r1
    3f62:	9200      	str	r2, [sp, #0]
    3f64:	9301      	str	r3, [sp, #4]
    3f66:	ab0a      	add	r3, sp, #40	; 0x28
    3f68:	781b      	ldrb	r3, [r3, #0]
    3f6a:	aa0b      	add	r2, sp, #44	; 0x2c
    3f6c:	8816      	ldrh	r6, [r2, #0]
    3f6e:	aa0c      	add	r2, sp, #48	; 0x30
    3f70:	8815      	ldrh	r5, [r2, #0]
		struct sensor_configuration_wakeup_t sensor_configuration_wakeup;
		struct sensor_configuration_non_wakeup_t sensor_configuration_non_wakeup;
	} sensor_configuration;

	/* checks if sensor id is in range */
	if (sensor_id >= 32)
    3f72:	281f      	cmp	r0, #31
    3f74:	d839      	bhi.n	3fea <bhy_enable_virtual_sensor+0x92>
		return BHY_OUT_OF_RANGE;

	/*computes the sensor id */
	sensor_id += wakeup_status;
    3f76:	1840      	adds	r0, r0, r1
    3f78:	b2c4      	uxtb	r4, r0

	/* flush the fifo if requested */
	switch (flush_sensor) {
    3f7a:	2b01      	cmp	r3, #1
    3f7c:	d004      	beq.n	3f88 <bhy_enable_virtual_sensor+0x30>
    3f7e:	2b00      	cmp	r3, #0
    3f80:	d00c      	beq.n	3f9c <bhy_enable_virtual_sensor+0x44>
    3f82:	2bff      	cmp	r3, #255	; 0xff
    3f84:	d005      	beq.n	3f92 <bhy_enable_virtual_sensor+0x3a>
    3f86:	e033      	b.n	3ff0 <bhy_enable_virtual_sensor+0x98>
		case VS_FLUSH_SINGLE:
			result += bhy_set_fifo_flush(sensor_id);
    3f88:	0020      	movs	r0, r4
    3f8a:	4b1e      	ldr	r3, [pc, #120]	; (4004 <bhy_enable_virtual_sensor+0xac>)
    3f8c:	4798      	blx	r3
    3f8e:	4682      	mov	sl, r0
			break;
    3f90:	e006      	b.n	3fa0 <bhy_enable_virtual_sensor+0x48>
		case VS_FLUSH_ALL:
			result += bhy_set_fifo_flush(VS_FLUSH_ALL);
    3f92:	20ff      	movs	r0, #255	; 0xff
    3f94:	4b1b      	ldr	r3, [pc, #108]	; (4004 <bhy_enable_virtual_sensor+0xac>)
    3f96:	4798      	blx	r3
    3f98:	4682      	mov	sl, r0
			break;
    3f9a:	e001      	b.n	3fa0 <bhy_enable_virtual_sensor+0x48>
BHY_RETURN_FUNCTION_TYPE bhy_enable_virtual_sensor
	(	bhy_virtual_sensor_t sensor_id, u8 wakeup_status, u16 sample_rate,
		u16 max_report_latency_ms, u8 flush_sensor, u16 change_sensitivity,
		u16 dynamic_range ) {

	BHY_RETURN_FUNCTION_TYPE result= BHY_SUCCESS;
    3f9c:	2300      	movs	r3, #0
    3f9e:	469a      	mov	sl, r3
		default:
			return BHY_OUT_OF_RANGE;
	}

	/* computes the param page as sensor_id + 0xC0 (sensor parameter write)*/
	sensor_id+= 0xC0;
    3fa0:	3c40      	subs	r4, #64	; 0x40
    3fa2:	b2e1      	uxtb	r1, r4

	/*calls the right function */
	switch (wakeup_status) {
    3fa4:	2f00      	cmp	r7, #0
    3fa6:	d002      	beq.n	3fae <bhy_enable_virtual_sensor+0x56>
    3fa8:	2f20      	cmp	r7, #32
    3faa:	d00f      	beq.n	3fcc <bhy_enable_virtual_sensor+0x74>
    3fac:	e023      	b.n	3ff6 <bhy_enable_virtual_sensor+0x9e>
		case VS_NON_WAKEUP:
		sensor_configuration.sensor_configuration_non_wakeup.non_wakeup_sample_rate = sample_rate;
    3fae:	ab02      	add	r3, sp, #8
    3fb0:	466a      	mov	r2, sp
    3fb2:	8812      	ldrh	r2, [r2, #0]
    3fb4:	801a      	strh	r2, [r3, #0]
		sensor_configuration.sensor_configuration_non_wakeup.non_wakeup_max_report_latency = max_report_latency_ms;
    3fb6:	466a      	mov	r2, sp
    3fb8:	8892      	ldrh	r2, [r2, #4]
    3fba:	805a      	strh	r2, [r3, #2]
		sensor_configuration.sensor_configuration_non_wakeup.non_wakeup_change_sensitivity = change_sensitivity;
    3fbc:	809e      	strh	r6, [r3, #4]
		sensor_configuration.sensor_configuration_non_wakeup.non_wakeup_dynamic_range = dynamic_range;
    3fbe:	80dd      	strh	r5, [r3, #6]
		result += bhy_set_non_wakeup_sensor_configuration( &sensor_configuration.sensor_configuration_non_wakeup, sensor_id);
    3fc0:	0018      	movs	r0, r3
    3fc2:	4b11      	ldr	r3, [pc, #68]	; (4008 <bhy_enable_virtual_sensor+0xb0>)
    3fc4:	4798      	blx	r3
    3fc6:	4450      	add	r0, sl
    3fc8:	b240      	sxtb	r0, r0
		return result;
    3fca:	e016      	b.n	3ffa <bhy_enable_virtual_sensor+0xa2>

		case VS_WAKEUP:
		sensor_configuration.sensor_configuration_wakeup.wakeup_sample_rate = sample_rate;
    3fcc:	ab02      	add	r3, sp, #8
    3fce:	466a      	mov	r2, sp
    3fd0:	8812      	ldrh	r2, [r2, #0]
    3fd2:	801a      	strh	r2, [r3, #0]
		sensor_configuration.sensor_configuration_wakeup.wakeup_max_report_latency = max_report_latency_ms;
    3fd4:	466a      	mov	r2, sp
    3fd6:	8892      	ldrh	r2, [r2, #4]
    3fd8:	805a      	strh	r2, [r3, #2]
		sensor_configuration.sensor_configuration_wakeup.wakeup_change_sensitivity = change_sensitivity;
    3fda:	809e      	strh	r6, [r3, #4]
		sensor_configuration.sensor_configuration_wakeup.wakeup_dynamic_range = dynamic_range;
    3fdc:	80dd      	strh	r5, [r3, #6]
		result += bhy_set_non_wakeup_sensor_configuration( &sensor_configuration.sensor_configuration_non_wakeup, sensor_id);
    3fde:	0018      	movs	r0, r3
    3fe0:	4b09      	ldr	r3, [pc, #36]	; (4008 <bhy_enable_virtual_sensor+0xb0>)
    3fe2:	4798      	blx	r3
    3fe4:	4450      	add	r0, sl
    3fe6:	b240      	sxtb	r0, r0
		return result;
    3fe8:	e007      	b.n	3ffa <bhy_enable_virtual_sensor+0xa2>
		struct sensor_configuration_non_wakeup_t sensor_configuration_non_wakeup;
	} sensor_configuration;

	/* checks if sensor id is in range */
	if (sensor_id >= 32)
		return BHY_OUT_OF_RANGE;
    3fea:	2002      	movs	r0, #2
    3fec:	4240      	negs	r0, r0
    3fee:	e004      	b.n	3ffa <bhy_enable_virtual_sensor+0xa2>
			result += bhy_set_fifo_flush(VS_FLUSH_ALL);
			break;
		case VS_FLUSH_NONE:
			break;
		default:
			return BHY_OUT_OF_RANGE;
    3ff0:	2002      	movs	r0, #2
    3ff2:	4240      	negs	r0, r0
    3ff4:	e001      	b.n	3ffa <bhy_enable_virtual_sensor+0xa2>
		sensor_configuration.sensor_configuration_wakeup.wakeup_dynamic_range = dynamic_range;
		result += bhy_set_non_wakeup_sensor_configuration( &sensor_configuration.sensor_configuration_non_wakeup, sensor_id);
		return result;

		default:
		return BHY_OUT_OF_RANGE;
    3ff6:	2002      	movs	r0, #2
    3ff8:	4240      	negs	r0, r0
	}
}
    3ffa:	b004      	add	sp, #16
    3ffc:	bc04      	pop	{r2}
    3ffe:	4692      	mov	sl, r2
    4000:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4002:	46c0      	nop			; (mov r8, r8)
    4004:	00003a25 	.word	0x00003a25
    4008:	00003df1 	.word	0x00003df1

0000400c <bhy_read_fifo>:
}

/* retrieves the fifo data. it needs a buffer of at least 51 bytes to work */
/* it outputs the data into the variable buffer. the number of bytes read */
/* into bytes_read  and the bytes remaining in the fifo into bytes_left */
BHY_RETURN_FUNCTION_TYPE bhy_read_fifo(u8 * buffer, const u16 buffer_size, u16 * bytes_read, u16 * bytes_left) {
    400c:	b5f0      	push	{r4, r5, r6, r7, lr}
    400e:	464f      	mov	r7, r9
    4010:	b480      	push	{r7}
    4012:	b082      	sub	sp, #8
    4014:	9001      	str	r0, [sp, #4]
    4016:	000c      	movs	r4, r1
    4018:	0016      	movs	r6, r2
    401a:	001d      	movs	r5, r3
	BHY_RETURN_FUNCTION_TYPE result = BHY_SUCCESS;
	static u16 current_index = 0;
	static u16 current_transaction_size = 0;

	if (buffer_size <= 50)
    401c:	2932      	cmp	r1, #50	; 0x32
    401e:	d940      	bls.n	40a2 <bhy_read_fifo+0x96>
		return BHY_OUT_OF_RANGE;

	/* gets the number of bytes left in the fifo either from memory of from */
	/* the register															*/
	if (current_transaction_size == 0)
    4020:	4b23      	ldr	r3, [pc, #140]	; (40b0 <bhy_read_fifo+0xa4>)
    4022:	881b      	ldrh	r3, [r3, #0]

/* retrieves the fifo data. it needs a buffer of at least 51 bytes to work */
/* it outputs the data into the variable buffer. the number of bytes read */
/* into bytes_read  and the bytes remaining in the fifo into bytes_left */
BHY_RETURN_FUNCTION_TYPE bhy_read_fifo(u8 * buffer, const u16 buffer_size, u16 * bytes_read, u16 * bytes_left) {
	BHY_RETURN_FUNCTION_TYPE result = BHY_SUCCESS;
    4024:	2700      	movs	r7, #0
	if (buffer_size <= 50)
		return BHY_OUT_OF_RANGE;

	/* gets the number of bytes left in the fifo either from memory of from */
	/* the register															*/
	if (current_transaction_size == 0)
    4026:	2b00      	cmp	r3, #0
    4028:	d109      	bne.n	403e <bhy_read_fifo+0x32>
		result = bhy_read_bytes_remaining(&current_transaction_size);
    402a:	4b21      	ldr	r3, [pc, #132]	; (40b0 <bhy_read_fifo+0xa4>)
    402c:	4699      	mov	r9, r3
    402e:	0018      	movs	r0, r3
    4030:	4b20      	ldr	r3, [pc, #128]	; (40b4 <bhy_read_fifo+0xa8>)
    4032:	4798      	blx	r3
    4034:	0007      	movs	r7, r0

	/* if there are bytes in the fifo to read */
	if (current_transaction_size) {
    4036:	464b      	mov	r3, r9
    4038:	881b      	ldrh	r3, [r3, #0]
    403a:	2b00      	cmp	r3, #0
    403c:	d02d      	beq.n	409a <bhy_read_fifo+0x8e>

		/* calculates the number of bytes to read. either the number of 	*/
		/* bytes left, or the buffer size, or just enough so the last page 	*/
		/* does not get turned												*/
		if (buffer_size >= current_transaction_size-current_index)
    403e:	4a1e      	ldr	r2, [pc, #120]	; (40b8 <bhy_read_fifo+0xac>)
    4040:	8810      	ldrh	r0, [r2, #0]
    4042:	1a1a      	subs	r2, r3, r0
    4044:	4294      	cmp	r4, r2
    4046:	db01      	blt.n	404c <bhy_read_fifo+0x40>
			*bytes_read = current_transaction_size-current_index;
    4048:	8032      	strh	r2, [r6, #0]
    404a:	e008      	b.n	405e <bhy_read_fifo+0x52>

		else if (current_transaction_size - (current_index+buffer_size) <= 50)
    404c:	1822      	adds	r2, r4, r0
    404e:	1a9a      	subs	r2, r3, r2
    4050:	2a32      	cmp	r2, #50	; 0x32
    4052:	dc03      	bgt.n	405c <bhy_read_fifo+0x50>
			*bytes_read = (current_transaction_size-51) - current_index;
    4054:	1a1b      	subs	r3, r3, r0
    4056:	3b33      	subs	r3, #51	; 0x33
    4058:	8033      	strh	r3, [r6, #0]
    405a:	e000      	b.n	405e <bhy_read_fifo+0x52>

		else
			*bytes_read = buffer_size;
    405c:	8034      	strh	r4, [r6, #0]

		result += bhy_read_reg(current_index%50, buffer, *bytes_read );
    405e:	8834      	ldrh	r4, [r6, #0]
    4060:	2132      	movs	r1, #50	; 0x32
    4062:	4b16      	ldr	r3, [pc, #88]	; (40bc <bhy_read_fifo+0xb0>)
    4064:	4798      	blx	r3
    4066:	b2c8      	uxtb	r0, r1
    4068:	0022      	movs	r2, r4
    406a:	9901      	ldr	r1, [sp, #4]
    406c:	4b14      	ldr	r3, [pc, #80]	; (40c0 <bhy_read_fifo+0xb4>)
    406e:	4798      	blx	r3
    4070:	19c7      	adds	r7, r0, r7
    4072:	b27b      	sxtb	r3, r7

		current_index += *bytes_read;
    4074:	4910      	ldr	r1, [pc, #64]	; (40b8 <bhy_read_fifo+0xac>)
    4076:	8830      	ldrh	r0, [r6, #0]
    4078:	880a      	ldrh	r2, [r1, #0]
    407a:	1882      	adds	r2, r0, r2
    407c:	b292      	uxth	r2, r2
    407e:	800a      	strh	r2, [r1, #0]

		*bytes_left = current_transaction_size-current_index;
    4080:	490b      	ldr	r1, [pc, #44]	; (40b0 <bhy_read_fifo+0xa4>)
    4082:	8809      	ldrh	r1, [r1, #0]
    4084:	1a8a      	subs	r2, r1, r2
    4086:	b292      	uxth	r2, r2
    4088:	802a      	strh	r2, [r5, #0]
		*bytes_read=0;
		*bytes_left=0;
		return result;
	}

	return result;
    408a:	0018      	movs	r0, r3

		current_index += *bytes_read;

		*bytes_left = current_transaction_size-current_index;

		if (*bytes_left == 0) {
    408c:	2a00      	cmp	r2, #0
    408e:	d10a      	bne.n	40a6 <bhy_read_fifo+0x9a>
			current_index = 0;
    4090:	4909      	ldr	r1, [pc, #36]	; (40b8 <bhy_read_fifo+0xac>)
    4092:	800a      	strh	r2, [r1, #0]
			current_transaction_size = 0;
    4094:	4906      	ldr	r1, [pc, #24]	; (40b0 <bhy_read_fifo+0xa4>)
    4096:	800a      	strh	r2, [r1, #0]
    4098:	e005      	b.n	40a6 <bhy_read_fifo+0x9a>
		}

	} else {
		*bytes_read=0;
    409a:	2300      	movs	r3, #0
    409c:	8033      	strh	r3, [r6, #0]
		*bytes_left=0;
    409e:	802b      	strh	r3, [r5, #0]
		return result;
    40a0:	e001      	b.n	40a6 <bhy_read_fifo+0x9a>
	BHY_RETURN_FUNCTION_TYPE result = BHY_SUCCESS;
	static u16 current_index = 0;
	static u16 current_transaction_size = 0;

	if (buffer_size <= 50)
		return BHY_OUT_OF_RANGE;
    40a2:	2002      	movs	r0, #2
    40a4:	4240      	negs	r0, r0
		*bytes_left=0;
		return result;
	}

	return result;
}
    40a6:	b002      	add	sp, #8
    40a8:	bc04      	pop	{r2}
    40aa:	4691      	mov	r9, r2
    40ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    40ae:	46c0      	nop			; (mov r8, r8)
    40b0:	200002ce 	.word	0x200002ce
    40b4:	00003a6d 	.word	0x00003a6d
    40b8:	200002cc 	.word	0x200002cc
    40bc:	0000a499 	.word	0x0000a499
    40c0:	00003a01 	.word	0x00003a01

000040c4 <bhy_parse_next_fifo_packet>:

BHY_RETURN_FUNCTION_TYPE bhy_parse_next_fifo_packet
	(u8 **fifo_buffer, u16 *fifo_buffer_length,
	bhy_data_generic_t * fifo_data_output, bhy_data_type_t * fifo_data_type) {
    40c4:	b570      	push	{r4, r5, r6, lr}
    40c6:	0004      	movs	r4, r0
    40c8:	000d      	movs	r5, r1
    40ca:	001e      	movs	r6, r3

	if (*fifo_buffer_length == 0)
    40cc:	880b      	ldrh	r3, [r1, #0]
		/* there are no more bytes in the fifo buffer to read */
		return BHY_SUCCESS;
    40ce:	2000      	movs	r0, #0

BHY_RETURN_FUNCTION_TYPE bhy_parse_next_fifo_packet
	(u8 **fifo_buffer, u16 *fifo_buffer_length,
	bhy_data_generic_t * fifo_data_output, bhy_data_type_t * fifo_data_type) {

	if (*fifo_buffer_length == 0)
    40d0:	2b00      	cmp	r3, #0
    40d2:	d100      	bne.n	40d6 <bhy_parse_next_fifo_packet+0x12>
    40d4:	e169      	b.n	43aa <bhy_parse_next_fifo_packet+0x2e6>
		/* there are no more bytes in the fifo buffer to read */
		return BHY_SUCCESS;

	/* the first fifo byte should be a known virtual sensor ID */
	switch (**fifo_buffer) {
    40d6:	6821      	ldr	r1, [r4, #0]
    40d8:	7808      	ldrb	r0, [r1, #0]
    40da:	28fe      	cmp	r0, #254	; 0xfe
    40dc:	d900      	bls.n	40e0 <bhy_parse_next_fifo_packet+0x1c>
    40de:	e147      	b.n	4370 <bhy_parse_next_fifo_packet+0x2ac>
    40e0:	0081      	lsls	r1, r0, #2
    40e2:	48b2      	ldr	r0, [pc, #712]	; (43ac <bhy_parse_next_fifo_packet+0x2e8>)
    40e4:	5841      	ldr	r1, [r0, r1]
    40e6:	468f      	mov	pc, r1

		case VS_ID_PADDING:
			*fifo_data_type = BHY_DATA_TYPE_PADDING;
    40e8:	2300      	movs	r3, #0
    40ea:	7033      	strb	r3, [r6, #0]

			fifo_data_output->data_padding.sensor_id = **fifo_buffer;
    40ec:	6823      	ldr	r3, [r4, #0]
    40ee:	781b      	ldrb	r3, [r3, #0]
    40f0:	7013      	strb	r3, [r2, #0]

			break;
    40f2:	e100      	b.n	42f6 <bhy_parse_next_fifo_packet+0x232>
		case VS_ID_ROTATION_VECTOR_WAKEUP:
		case VS_ID_GAME_ROTATION_VECTOR:
		case VS_ID_GAME_ROTATION_VECTOR_WAKEUP:
		case VS_ID_GEOMAGNETIC_ROTATION_VECTOR:
		case VS_ID_GEOMAGNETIC_ROTATION_VECTOR_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_QUATERNION])
    40f4:	2b0a      	cmp	r3, #10
    40f6:	d800      	bhi.n	40fa <bhy_parse_next_fifo_packet+0x36>
    40f8:	e13d      	b.n	4376 <bhy_parse_next_fifo_packet+0x2b2>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_QUATERNION;
    40fa:	2301      	movs	r3, #1
    40fc:	7033      	strb	r3, [r6, #0]

			fifo_data_output->data_quaternion.sensor_id = **fifo_buffer;
    40fe:	6823      	ldr	r3, [r4, #0]
    4100:	781b      	ldrb	r3, [r3, #0]
    4102:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_quaternion.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
    4104:	6821      	ldr	r1, [r4, #0]
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_QUATERNION;

			fifo_data_output->data_quaternion.sensor_id = **fifo_buffer;
			fifo_data_output->data_quaternion.x =
    4106:	788b      	ldrb	r3, [r1, #2]
    4108:	021b      	lsls	r3, r3, #8
    410a:	7849      	ldrb	r1, [r1, #1]
    410c:	430b      	orrs	r3, r1
    410e:	8053      	strh	r3, [r2, #2]
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_quaternion.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
    4110:	6821      	ldr	r1, [r4, #0]
			*fifo_data_type = BHY_DATA_TYPE_QUATERNION;

			fifo_data_output->data_quaternion.sensor_id = **fifo_buffer;
			fifo_data_output->data_quaternion.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_quaternion.y =
    4112:	790b      	ldrb	r3, [r1, #4]
    4114:	021b      	lsls	r3, r3, #8
    4116:	78c9      	ldrb	r1, [r1, #3]
    4118:	430b      	orrs	r3, r1
    411a:	8093      	strh	r3, [r2, #4]
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_quaternion.z =
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
    411c:	6821      	ldr	r1, [r4, #0]
			fifo_data_output->data_quaternion.sensor_id = **fifo_buffer;
			fifo_data_output->data_quaternion.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_quaternion.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_quaternion.z =
    411e:	798b      	ldrb	r3, [r1, #6]
    4120:	021b      	lsls	r3, r3, #8
    4122:	7949      	ldrb	r1, [r1, #5]
    4124:	430b      	orrs	r3, r1
    4126:	80d3      	strh	r3, [r2, #6]
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_quaternion.w =
			(s16)( ((u16)*(*fifo_buffer+7)) | ((u16)*(*fifo_buffer+8) << 8));
    4128:	6821      	ldr	r1, [r4, #0]
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_quaternion.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_quaternion.z =
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_quaternion.w =
    412a:	7a0b      	ldrb	r3, [r1, #8]
    412c:	021b      	lsls	r3, r3, #8
    412e:	79c9      	ldrb	r1, [r1, #7]
    4130:	430b      	orrs	r3, r1
    4132:	8113      	strh	r3, [r2, #8]
			(s16)( ((u16)*(*fifo_buffer+7)) | ((u16)*(*fifo_buffer+8) << 8));
			fifo_data_output->data_quaternion.estimated_accuracy =
			(s16)( ((u16)*(*fifo_buffer+9)) | ((u16)*(*fifo_buffer+10) << 8));
    4134:	6821      	ldr	r1, [r4, #0]
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_quaternion.z =
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_quaternion.w =
			(s16)( ((u16)*(*fifo_buffer+7)) | ((u16)*(*fifo_buffer+8) << 8));
			fifo_data_output->data_quaternion.estimated_accuracy =
    4136:	7a8b      	ldrb	r3, [r1, #10]
    4138:	021b      	lsls	r3, r3, #8
    413a:	7a49      	ldrb	r1, [r1, #9]
    413c:	430b      	orrs	r3, r1
    413e:	8153      	strh	r3, [r2, #10]
			(s16)( ((u16)*(*fifo_buffer+9)) | ((u16)*(*fifo_buffer+10) << 8));

			break;
    4140:	e0d9      	b.n	42f6 <bhy_parse_next_fifo_packet+0x232>
		case VS_ID_GYROSCOPE_WAKEUP:
		case VS_ID_GRAVITY:
		case VS_ID_GRAVITY_WAKEUP:
		case VS_ID_LINEAR_ACCELERATION:
		case VS_ID_LINEAR_ACCELERATION_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_VECTOR])
    4142:	2b07      	cmp	r3, #7
    4144:	d800      	bhi.n	4148 <bhy_parse_next_fifo_packet+0x84>
    4146:	e119      	b.n	437c <bhy_parse_next_fifo_packet+0x2b8>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_VECTOR;
    4148:	2302      	movs	r3, #2
    414a:	7033      	strb	r3, [r6, #0]

			fifo_data_output->data_vector.sensor_id = **fifo_buffer;
    414c:	6823      	ldr	r3, [r4, #0]
    414e:	781b      	ldrb	r3, [r3, #0]
    4150:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_vector.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
    4152:	6821      	ldr	r1, [r4, #0]
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_VECTOR;

			fifo_data_output->data_vector.sensor_id = **fifo_buffer;
			fifo_data_output->data_vector.x =
    4154:	788b      	ldrb	r3, [r1, #2]
    4156:	021b      	lsls	r3, r3, #8
    4158:	7849      	ldrb	r1, [r1, #1]
    415a:	430b      	orrs	r3, r1
    415c:	8053      	strh	r3, [r2, #2]
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_vector.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
    415e:	6821      	ldr	r1, [r4, #0]
			*fifo_data_type = BHY_DATA_TYPE_VECTOR;

			fifo_data_output->data_vector.sensor_id = **fifo_buffer;
			fifo_data_output->data_vector.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_vector.y =
    4160:	790b      	ldrb	r3, [r1, #4]
    4162:	021b      	lsls	r3, r3, #8
    4164:	78c9      	ldrb	r1, [r1, #3]
    4166:	430b      	orrs	r3, r1
    4168:	8093      	strh	r3, [r2, #4]
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_vector.z =
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
    416a:	6821      	ldr	r1, [r4, #0]
			fifo_data_output->data_vector.sensor_id = **fifo_buffer;
			fifo_data_output->data_vector.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_vector.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_vector.z =
    416c:	798b      	ldrb	r3, [r1, #6]
    416e:	021b      	lsls	r3, r3, #8
    4170:	7949      	ldrb	r1, [r1, #5]
    4172:	430b      	orrs	r3, r1
    4174:	80d3      	strh	r3, [r2, #6]
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_vector.status = *(*fifo_buffer+7);
    4176:	6823      	ldr	r3, [r4, #0]
    4178:	79db      	ldrb	r3, [r3, #7]
    417a:	7213      	strb	r3, [r2, #8]

			break;
    417c:	e0bb      	b.n	42f6 <bhy_parse_next_fifo_packet+0x232>

		case VS_ID_HEART_RATE:
		case VS_ID_HEART_RATE_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U8])
    417e:	2b01      	cmp	r3, #1
    4180:	d800      	bhi.n	4184 <bhy_parse_next_fifo_packet+0xc0>
    4182:	e0fe      	b.n	4382 <bhy_parse_next_fifo_packet+0x2be>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_SCALAR_U8;
    4184:	2303      	movs	r3, #3
    4186:	7033      	strb	r3, [r6, #0]
			fifo_data_output->data_scalar_u8.sensor_id = **fifo_buffer;
    4188:	6823      	ldr	r3, [r4, #0]
    418a:	781b      	ldrb	r3, [r3, #0]
    418c:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_scalar_u8.data = *(*fifo_buffer+1);
    418e:	6823      	ldr	r3, [r4, #0]
    4190:	785b      	ldrb	r3, [r3, #1]
    4192:	7053      	strb	r3, [r2, #1]

			break;
    4194:	e0af      	b.n	42f6 <bhy_parse_next_fifo_packet+0x232>
		case VS_ID_ACTIVITY_WAKEUP:
		case VS_ID_TIMESTAMP_LSW:
		case VS_ID_TIMESTAMP_LSW_WAKEUP:
		case VS_ID_TIMESTAMP_MSW:
		case VS_ID_TIMESTAMP_MSW_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U16])
    4196:	2b02      	cmp	r3, #2
    4198:	d800      	bhi.n	419c <bhy_parse_next_fifo_packet+0xd8>
    419a:	e0f5      	b.n	4388 <bhy_parse_next_fifo_packet+0x2c4>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_SCALAR_U16;
    419c:	2304      	movs	r3, #4
    419e:	7033      	strb	r3, [r6, #0]
			fifo_data_output->data_scalar_u16.sensor_id = **fifo_buffer;
    41a0:	6823      	ldr	r3, [r4, #0]
    41a2:	781b      	ldrb	r3, [r3, #0]
    41a4:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_scalar_u16.data =
			(u16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
    41a6:	6821      	ldr	r1, [r4, #0]
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U16])
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_SCALAR_U16;
			fifo_data_output->data_scalar_u16.sensor_id = **fifo_buffer;
			fifo_data_output->data_scalar_u16.data =
    41a8:	788b      	ldrb	r3, [r1, #2]
    41aa:	021b      	lsls	r3, r3, #8
    41ac:	7849      	ldrb	r1, [r1, #1]
    41ae:	430b      	orrs	r3, r1
    41b0:	8053      	strh	r3, [r2, #2]
			(u16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));

			break;
    41b2:	e0a0      	b.n	42f6 <bhy_parse_next_fifo_packet+0x232>

		case VS_ID_TEMPERATURE:
		case VS_ID_TEMPERATURE_WAKEUP:
		case VS_ID_AMBIENT_TEMPERATURE:
		case VS_ID_AMBIENT_TEMPERATURE_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_S16])
    41b4:	2b02      	cmp	r3, #2
    41b6:	d800      	bhi.n	41ba <bhy_parse_next_fifo_packet+0xf6>
    41b8:	e0e9      	b.n	438e <bhy_parse_next_fifo_packet+0x2ca>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_SCALAR_S16;
    41ba:	2305      	movs	r3, #5
    41bc:	7033      	strb	r3, [r6, #0]
			fifo_data_output->data_scalar_s16.sensor_id = **fifo_buffer;
    41be:	6823      	ldr	r3, [r4, #0]
    41c0:	781b      	ldrb	r3, [r3, #0]
    41c2:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_scalar_s16.data =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
    41c4:	6821      	ldr	r1, [r4, #0]
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_S16])
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_SCALAR_S16;
			fifo_data_output->data_scalar_s16.sensor_id = **fifo_buffer;
			fifo_data_output->data_scalar_s16.data =
    41c6:	788b      	ldrb	r3, [r1, #2]
    41c8:	021b      	lsls	r3, r3, #8
    41ca:	7849      	ldrb	r1, [r1, #1]
    41cc:	430b      	orrs	r3, r1
    41ce:	8053      	strh	r3, [r2, #2]
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));

			break;
    41d0:	e091      	b.n	42f6 <bhy_parse_next_fifo_packet+0x232>

		case VS_ID_BAROMETER:
		case VS_ID_BAROMETER_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U24])
    41d2:	2b03      	cmp	r3, #3
    41d4:	d800      	bhi.n	41d8 <bhy_parse_next_fifo_packet+0x114>
    41d6:	e0dd      	b.n	4394 <bhy_parse_next_fifo_packet+0x2d0>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_SCALAR_U24;
    41d8:	2306      	movs	r3, #6
    41da:	7033      	strb	r3, [r6, #0]
			fifo_data_output->data_scalar_u24.sensor_id = **fifo_buffer;
    41dc:	6823      	ldr	r3, [r4, #0]
    41de:	781b      	ldrb	r3, [r3, #0]
    41e0:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_scalar_u24.data =
			(u32)( ((u32)*(*fifo_buffer+1)) | ((u32)*(*fifo_buffer+2) << 8) |
    41e2:	6821      	ldr	r1, [r4, #0]
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U24])
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_SCALAR_U24;
			fifo_data_output->data_scalar_u24.sensor_id = **fifo_buffer;
			fifo_data_output->data_scalar_u24.data =
    41e4:	788b      	ldrb	r3, [r1, #2]
    41e6:	0218      	lsls	r0, r3, #8
    41e8:	78cb      	ldrb	r3, [r1, #3]
    41ea:	041b      	lsls	r3, r3, #16
    41ec:	4303      	orrs	r3, r0
    41ee:	7849      	ldrb	r1, [r1, #1]
    41f0:	430b      	orrs	r3, r1
    41f2:	6053      	str	r3, [r2, #4]
			(u32)( ((u32)*(*fifo_buffer+1)) | ((u32)*(*fifo_buffer+2) << 8) |
					((u32)*(*fifo_buffer+3) << 16));

			break;
    41f4:	e07f      	b.n	42f6 <bhy_parse_next_fifo_packet+0x232>
		case VS_ID_WAKE_GESTURE_WAKEUP:
		case VS_ID_GLANCE_GESTURE:
		case VS_ID_GLANCE_GESTURE_WAKEUP:
		case VS_ID_PICKUP_GESTURE:
		case VS_ID_PICKUP_GESTURE_WAKEUP:
			*fifo_data_type = BHY_DATA_TYPE_SENSOR_EVENT;
    41f6:	2307      	movs	r3, #7
    41f8:	7033      	strb	r3, [r6, #0]

			fifo_data_output->data_sensor_event.sensor_id = **fifo_buffer;
    41fa:	6823      	ldr	r3, [r4, #0]
    41fc:	781b      	ldrb	r3, [r3, #0]
    41fe:	7013      	strb	r3, [r2, #0]

			break;
    4200:	e079      	b.n	42f6 <bhy_parse_next_fifo_packet+0x232>
		case VS_ID_UNCALIBRATED_MAGNETOMETER:
		case VS_ID_UNCALIBRATED_MAGNETOMETER_WAKEUP:
		case VS_ID_UNCALIBRATED_GYROSCOPE:
		case VS_ID_UNCALIBRATED_GYROSCOPE_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_UNCALIB_VECTOR])
    4202:	2b0d      	cmp	r3, #13
    4204:	d800      	bhi.n	4208 <bhy_parse_next_fifo_packet+0x144>
    4206:	e0c8      	b.n	439a <bhy_parse_next_fifo_packet+0x2d6>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_UNCALIB_VECTOR;
    4208:	2308      	movs	r3, #8
    420a:	7033      	strb	r3, [r6, #0]
			fifo_data_output->data_uncalib_vector.sensor_id = **fifo_buffer;
    420c:	6823      	ldr	r3, [r4, #0]
    420e:	781b      	ldrb	r3, [r3, #0]
    4210:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_uncalib_vector.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
    4212:	6821      	ldr	r1, [r4, #0]
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_UNCALIB_VECTOR])
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_UNCALIB_VECTOR;
			fifo_data_output->data_uncalib_vector.sensor_id = **fifo_buffer;
			fifo_data_output->data_uncalib_vector.x =
    4214:	788b      	ldrb	r3, [r1, #2]
    4216:	021b      	lsls	r3, r3, #8
    4218:	7849      	ldrb	r1, [r1, #1]
    421a:	430b      	orrs	r3, r1
    421c:	8053      	strh	r3, [r2, #2]
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_uncalib_vector.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
    421e:	6821      	ldr	r1, [r4, #0]

			*fifo_data_type = BHY_DATA_TYPE_UNCALIB_VECTOR;
			fifo_data_output->data_uncalib_vector.sensor_id = **fifo_buffer;
			fifo_data_output->data_uncalib_vector.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_uncalib_vector.y =
    4220:	790b      	ldrb	r3, [r1, #4]
    4222:	021b      	lsls	r3, r3, #8
    4224:	78c9      	ldrb	r1, [r1, #3]
    4226:	430b      	orrs	r3, r1
    4228:	8093      	strh	r3, [r2, #4]
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_uncalib_vector.z =
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
    422a:	6821      	ldr	r1, [r4, #0]
			fifo_data_output->data_uncalib_vector.sensor_id = **fifo_buffer;
			fifo_data_output->data_uncalib_vector.x =
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_uncalib_vector.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_uncalib_vector.z =
    422c:	798b      	ldrb	r3, [r1, #6]
    422e:	021b      	lsls	r3, r3, #8
    4230:	7949      	ldrb	r1, [r1, #5]
    4232:	430b      	orrs	r3, r1
    4234:	80d3      	strh	r3, [r2, #6]
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_uncalib_vector.x_bias =
			(s16)( ((u16)*(*fifo_buffer+7)) | ((u16)*(*fifo_buffer+8) << 8));
    4236:	6821      	ldr	r1, [r4, #0]
			(s16)( ((u16)*(*fifo_buffer+1)) | ((u16)*(*fifo_buffer+2) << 8));
			fifo_data_output->data_uncalib_vector.y =
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_uncalib_vector.z =
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_uncalib_vector.x_bias =
    4238:	7a0b      	ldrb	r3, [r1, #8]
    423a:	021b      	lsls	r3, r3, #8
    423c:	79c9      	ldrb	r1, [r1, #7]
    423e:	430b      	orrs	r3, r1
    4240:	8113      	strh	r3, [r2, #8]
			(s16)( ((u16)*(*fifo_buffer+7)) | ((u16)*(*fifo_buffer+8) << 8));
			fifo_data_output->data_uncalib_vector.y_bias =
			(s16)( ((u16)*(*fifo_buffer+9)) | ((u16)*(*fifo_buffer+10) << 8));
    4242:	6821      	ldr	r1, [r4, #0]
			(s16)( ((u16)*(*fifo_buffer+3)) | ((u16)*(*fifo_buffer+4) << 8));
			fifo_data_output->data_uncalib_vector.z =
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_uncalib_vector.x_bias =
			(s16)( ((u16)*(*fifo_buffer+7)) | ((u16)*(*fifo_buffer+8) << 8));
			fifo_data_output->data_uncalib_vector.y_bias =
    4244:	7a8b      	ldrb	r3, [r1, #10]
    4246:	021b      	lsls	r3, r3, #8
    4248:	7a49      	ldrb	r1, [r1, #9]
    424a:	430b      	orrs	r3, r1
    424c:	8153      	strh	r3, [r2, #10]
			(s16)( ((u16)*(*fifo_buffer+9)) | ((u16)*(*fifo_buffer+10) << 8));
			fifo_data_output->data_uncalib_vector.z_bias =
			(s16)( ((u16)*(*fifo_buffer+11)) | ((u16)*(*fifo_buffer+12) << 8));
    424e:	6821      	ldr	r1, [r4, #0]
			(s16)( ((u16)*(*fifo_buffer+5)) | ((u16)*(*fifo_buffer+6) << 8));
			fifo_data_output->data_uncalib_vector.x_bias =
			(s16)( ((u16)*(*fifo_buffer+7)) | ((u16)*(*fifo_buffer+8) << 8));
			fifo_data_output->data_uncalib_vector.y_bias =
			(s16)( ((u16)*(*fifo_buffer+9)) | ((u16)*(*fifo_buffer+10) << 8));
			fifo_data_output->data_uncalib_vector.z_bias =
    4250:	7b0b      	ldrb	r3, [r1, #12]
    4252:	021b      	lsls	r3, r3, #8
    4254:	7ac9      	ldrb	r1, [r1, #11]
    4256:	430b      	orrs	r3, r1
    4258:	8193      	strh	r3, [r2, #12]
			(s16)( ((u16)*(*fifo_buffer+11)) | ((u16)*(*fifo_buffer+12) << 8));
			fifo_data_output->data_uncalib_vector.status = *(*fifo_buffer+13);
    425a:	6823      	ldr	r3, [r4, #0]
    425c:	7b5b      	ldrb	r3, [r3, #13]
    425e:	7393      	strb	r3, [r2, #14]
			break;
    4260:	e049      	b.n	42f6 <bhy_parse_next_fifo_packet+0x232>

		case VS_ID_META_EVENT:
		case VS_ID_META_EVENT_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_META_EVENT])
    4262:	2b03      	cmp	r3, #3
    4264:	d800      	bhi.n	4268 <bhy_parse_next_fifo_packet+0x1a4>
    4266:	e09b      	b.n	43a0 <bhy_parse_next_fifo_packet+0x2dc>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_META_EVENT;
    4268:	2309      	movs	r3, #9
    426a:	7033      	strb	r3, [r6, #0]
			fifo_data_output->data_meta_event.meta_event_id =	**fifo_buffer;
    426c:	6823      	ldr	r3, [r4, #0]
    426e:	781b      	ldrb	r3, [r3, #0]
    4270:	7013      	strb	r3, [r2, #0]
			fifo_data_output->data_meta_event.event_number =	(bhy_meta_event_type_t)(*(*fifo_buffer+1));
    4272:	6823      	ldr	r3, [r4, #0]
    4274:	785b      	ldrb	r3, [r3, #1]
    4276:	7053      	strb	r3, [r2, #1]
			fifo_data_output->data_meta_event.sensor_type =		*(*fifo_buffer+2);
    4278:	6823      	ldr	r3, [r4, #0]
    427a:	789b      	ldrb	r3, [r3, #2]
    427c:	7093      	strb	r3, [r2, #2]
			fifo_data_output->data_meta_event.event_specific =	*(*fifo_buffer+3);
    427e:	6823      	ldr	r3, [r4, #0]
    4280:	78db      	ldrb	r3, [r3, #3]
    4282:	70d3      	strb	r3, [r2, #3]

			break;
    4284:	e037      	b.n	42f6 <bhy_parse_next_fifo_packet+0x232>
#endif

		case VS_ID_BSX_C:
		case VS_ID_BSX_B:
		case VS_ID_BSX_A:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_BSX])
    4286:	2b10      	cmp	r3, #16
    4288:	d800      	bhi.n	428c <bhy_parse_next_fifo_packet+0x1c8>
    428a:	e08c      	b.n	43a6 <bhy_parse_next_fifo_packet+0x2e2>
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_BSX;
    428c:	230a      	movs	r3, #10
    428e:	7033      	strb	r3, [r6, #0]
			fifo_data_output->data_bsx.sensor_id =	**fifo_buffer;
    4290:	6823      	ldr	r3, [r4, #0]
    4292:	781b      	ldrb	r3, [r3, #0]
    4294:	7013      	strb	r3, [r2, #0]

			fifo_data_output->data_bsx.x =
			(u32)( ((u32)*(*fifo_buffer+1)) | ((u32)*(*fifo_buffer+2) << 8) |
    4296:	6821      	ldr	r1, [r4, #0]
				return BHY_OUT_OF_RANGE;

			*fifo_data_type = BHY_DATA_TYPE_BSX;
			fifo_data_output->data_bsx.sensor_id =	**fifo_buffer;

			fifo_data_output->data_bsx.x =
    4298:	788b      	ldrb	r3, [r1, #2]
    429a:	0218      	lsls	r0, r3, #8
    429c:	78cb      	ldrb	r3, [r1, #3]
    429e:	041b      	lsls	r3, r3, #16
    42a0:	4303      	orrs	r3, r0
    42a2:	7848      	ldrb	r0, [r1, #1]
    42a4:	4303      	orrs	r3, r0
    42a6:	7909      	ldrb	r1, [r1, #4]
    42a8:	0609      	lsls	r1, r1, #24
    42aa:	430b      	orrs	r3, r1
    42ac:	6053      	str	r3, [r2, #4]
			(u32)( ((u32)*(*fifo_buffer+1)) | ((u32)*(*fifo_buffer+2) << 8) |
					((u32)*(*fifo_buffer+3) << 16) | ((u32)*(*fifo_buffer+4) << 24));

			fifo_data_output->data_bsx.y =
			(u32)( ((u32)*(*fifo_buffer+5)) | ((u32)*(*fifo_buffer+6) << 8) |
    42ae:	6821      	ldr	r1, [r4, #0]

			fifo_data_output->data_bsx.x =
			(u32)( ((u32)*(*fifo_buffer+1)) | ((u32)*(*fifo_buffer+2) << 8) |
					((u32)*(*fifo_buffer+3) << 16) | ((u32)*(*fifo_buffer+4) << 24));

			fifo_data_output->data_bsx.y =
    42b0:	798b      	ldrb	r3, [r1, #6]
    42b2:	0218      	lsls	r0, r3, #8
    42b4:	79cb      	ldrb	r3, [r1, #7]
    42b6:	041b      	lsls	r3, r3, #16
    42b8:	4303      	orrs	r3, r0
    42ba:	7948      	ldrb	r0, [r1, #5]
    42bc:	4303      	orrs	r3, r0
    42be:	7a09      	ldrb	r1, [r1, #8]
    42c0:	0609      	lsls	r1, r1, #24
    42c2:	430b      	orrs	r3, r1
    42c4:	6093      	str	r3, [r2, #8]
			(u32)( ((u32)*(*fifo_buffer+5)) | ((u32)*(*fifo_buffer+6) << 8) |
					((u32)*(*fifo_buffer+7) << 16) | ((u32)*(*fifo_buffer+8) << 24));

			fifo_data_output->data_bsx.z =
			(u32)( ((u32)*(*fifo_buffer+9)) | ((u32)*(*fifo_buffer+10) << 8) |
    42c6:	6821      	ldr	r1, [r4, #0]

			fifo_data_output->data_bsx.y =
			(u32)( ((u32)*(*fifo_buffer+5)) | ((u32)*(*fifo_buffer+6) << 8) |
					((u32)*(*fifo_buffer+7) << 16) | ((u32)*(*fifo_buffer+8) << 24));

			fifo_data_output->data_bsx.z =
    42c8:	7a8b      	ldrb	r3, [r1, #10]
    42ca:	0218      	lsls	r0, r3, #8
    42cc:	7acb      	ldrb	r3, [r1, #11]
    42ce:	041b      	lsls	r3, r3, #16
    42d0:	4303      	orrs	r3, r0
    42d2:	7a48      	ldrb	r0, [r1, #9]
    42d4:	4303      	orrs	r3, r0
    42d6:	7b09      	ldrb	r1, [r1, #12]
    42d8:	0609      	lsls	r1, r1, #24
    42da:	430b      	orrs	r3, r1
    42dc:	60d3      	str	r3, [r2, #12]
			(u32)( ((u32)*(*fifo_buffer+9)) | ((u32)*(*fifo_buffer+10) << 8) |
					((u32)*(*fifo_buffer+11) << 16) | ((u32)*(*fifo_buffer+12) << 24));

			fifo_data_output->data_bsx.timestamp =
			(u32)( ((u32)*(*fifo_buffer+13)) | ((u32)*(*fifo_buffer+14) << 8) |
    42de:	6821      	ldr	r1, [r4, #0]

			fifo_data_output->data_bsx.z =
			(u32)( ((u32)*(*fifo_buffer+9)) | ((u32)*(*fifo_buffer+10) << 8) |
					((u32)*(*fifo_buffer+11) << 16) | ((u32)*(*fifo_buffer+12) << 24));

			fifo_data_output->data_bsx.timestamp =
    42e0:	7b8b      	ldrb	r3, [r1, #14]
    42e2:	0218      	lsls	r0, r3, #8
    42e4:	7bcb      	ldrb	r3, [r1, #15]
    42e6:	041b      	lsls	r3, r3, #16
    42e8:	4303      	orrs	r3, r0
    42ea:	7b48      	ldrb	r0, [r1, #13]
    42ec:	4303      	orrs	r3, r0
    42ee:	7c09      	ldrb	r1, [r1, #16]
    42f0:	0609      	lsls	r1, r1, #24
    42f2:	430b      	orrs	r3, r1
    42f4:	6113      	str	r3, [r2, #16]




#if BHY_CALLBACK_MODE
	if( (**fifo_buffer) < 0x40 ) {
    42f6:	6823      	ldr	r3, [r4, #0]
    42f8:	7819      	ldrb	r1, [r3, #0]
    42fa:	293f      	cmp	r1, #63	; 0x3f
    42fc:	d807      	bhi.n	430e <bhy_parse_next_fifo_packet+0x24a>
		if (g_sensor_callback_list[(**fifo_buffer)] != 0) {
    42fe:	008b      	lsls	r3, r1, #2
    4300:	482b      	ldr	r0, [pc, #172]	; (43b0 <bhy_parse_next_fifo_packet+0x2ec>)
    4302:	581b      	ldr	r3, [r3, r0]
    4304:	2b00      	cmp	r3, #0
    4306:	d025      	beq.n	4354 <bhy_parse_next_fifo_packet+0x290>
			g_sensor_callback_list[(**fifo_buffer)](fifo_data_output, (**fifo_buffer));
    4308:	0010      	movs	r0, r2
    430a:	4798      	blx	r3
    430c:	e022      	b.n	4354 <bhy_parse_next_fifo_packet+0x290>
		}
	} else if ( (**fifo_buffer) == VS_ID_TIMESTAMP_LSW ||
    430e:	1d0b      	adds	r3, r1, #4
    4310:	b2db      	uxtb	r3, r3
    4312:	2b01      	cmp	r3, #1
    4314:	d806      	bhi.n	4324 <bhy_parse_next_fifo_packet+0x260>
				(**fifo_buffer) == VS_ID_TIMESTAMP_MSW ) {
		if ( g_timestamp_callback_list[0] != 0 ) {
    4316:	4b27      	ldr	r3, [pc, #156]	; (43b4 <bhy_parse_next_fifo_packet+0x2f0>)
    4318:	681b      	ldr	r3, [r3, #0]
    431a:	2b00      	cmp	r3, #0
    431c:	d01a      	beq.n	4354 <bhy_parse_next_fifo_packet+0x290>
			g_timestamp_callback_list[0](&fifo_data_output->data_scalar_u16);
    431e:	0010      	movs	r0, r2
    4320:	4798      	blx	r3
    4322:	e017      	b.n	4354 <bhy_parse_next_fifo_packet+0x290>
		}
	} else if ( (**fifo_buffer) == VS_ID_TIMESTAMP_LSW_WAKEUP ||
    4324:	000b      	movs	r3, r1
    4326:	330a      	adds	r3, #10
    4328:	b2db      	uxtb	r3, r3
    432a:	2b01      	cmp	r3, #1
    432c:	d806      	bhi.n	433c <bhy_parse_next_fifo_packet+0x278>
				(**fifo_buffer) == VS_ID_TIMESTAMP_MSW_WAKEUP ) {
		if ( g_timestamp_callback_list[1] != 0 ) {
    432e:	4b21      	ldr	r3, [pc, #132]	; (43b4 <bhy_parse_next_fifo_packet+0x2f0>)
    4330:	685b      	ldr	r3, [r3, #4]
    4332:	2b00      	cmp	r3, #0
    4334:	d00e      	beq.n	4354 <bhy_parse_next_fifo_packet+0x290>
			g_timestamp_callback_list[1](&fifo_data_output->data_scalar_u16);
    4336:	0010      	movs	r0, r2
    4338:	4798      	blx	r3
    433a:	e00b      	b.n	4354 <bhy_parse_next_fifo_packet+0x290>
		}
	} else if ( (**fifo_buffer) == VS_ID_META_EVENT ||
    433c:	29fe      	cmp	r1, #254	; 0xfe
    433e:	d001      	beq.n	4344 <bhy_parse_next_fifo_packet+0x280>
    4340:	29f8      	cmp	r1, #248	; 0xf8
    4342:	d107      	bne.n	4354 <bhy_parse_next_fifo_packet+0x290>
				(**fifo_buffer) == VS_ID_META_EVENT_WAKEUP ) {
		if ( g_meta_event_callback_list[fifo_data_output->data_meta_event.event_number] != 0) {
    4344:	7851      	ldrb	r1, [r2, #1]
    4346:	0088      	lsls	r0, r1, #2
    4348:	4b1b      	ldr	r3, [pc, #108]	; (43b8 <bhy_parse_next_fifo_packet+0x2f4>)
    434a:	58c3      	ldr	r3, [r0, r3]
    434c:	2b00      	cmp	r3, #0
    434e:	d001      	beq.n	4354 <bhy_parse_next_fifo_packet+0x290>
			g_meta_event_callback_list[fifo_data_output->data_meta_event.event_number](&fifo_data_output->data_meta_event, fifo_data_output->data_meta_event.event_number);
    4350:	0010      	movs	r0, r2
    4352:	4798      	blx	r3
		}
	}

#endif

	(*fifo_buffer) += _fifoSizes[*fifo_data_type];
    4354:	4a19      	ldr	r2, [pc, #100]	; (43bc <bhy_parse_next_fifo_packet+0x2f8>)
    4356:	7833      	ldrb	r3, [r6, #0]
    4358:	5cd3      	ldrb	r3, [r2, r3]
    435a:	6821      	ldr	r1, [r4, #0]
    435c:	468c      	mov	ip, r1
    435e:	4463      	add	r3, ip
    4360:	6023      	str	r3, [r4, #0]
	*fifo_buffer_length -= _fifoSizes[*fifo_data_type];
    4362:	7833      	ldrb	r3, [r6, #0]
    4364:	5cd2      	ldrb	r2, [r2, r3]
    4366:	882b      	ldrh	r3, [r5, #0]
    4368:	1a9b      	subs	r3, r3, r2
    436a:	802b      	strh	r3, [r5, #0]

	return BHY_SUCCESS;
    436c:	2000      	movs	r0, #0
    436e:	e01c      	b.n	43aa <bhy_parse_next_fifo_packet+0x2e6>

		/* the VS sensor ID is unknown. Either the sync has been lost or the */
		/* ram patch implements a new sensor ID that this driver doesn't yet */
		/* support															 */
		default:
		return BHY_OUT_OF_RANGE;
    4370:	2002      	movs	r0, #2
    4372:	4240      	negs	r0, r0
    4374:	e019      	b.n	43aa <bhy_parse_next_fifo_packet+0x2e6>
		case VS_ID_GAME_ROTATION_VECTOR:
		case VS_ID_GAME_ROTATION_VECTOR_WAKEUP:
		case VS_ID_GEOMAGNETIC_ROTATION_VECTOR:
		case VS_ID_GEOMAGNETIC_ROTATION_VECTOR_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_QUATERNION])
				return BHY_OUT_OF_RANGE;
    4376:	2002      	movs	r0, #2
    4378:	4240      	negs	r0, r0
    437a:	e016      	b.n	43aa <bhy_parse_next_fifo_packet+0x2e6>
		case VS_ID_GRAVITY:
		case VS_ID_GRAVITY_WAKEUP:
		case VS_ID_LINEAR_ACCELERATION:
		case VS_ID_LINEAR_ACCELERATION_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_VECTOR])
				return BHY_OUT_OF_RANGE;
    437c:	2002      	movs	r0, #2
    437e:	4240      	negs	r0, r0
    4380:	e013      	b.n	43aa <bhy_parse_next_fifo_packet+0x2e6>
			break;

		case VS_ID_HEART_RATE:
		case VS_ID_HEART_RATE_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U8])
				return BHY_OUT_OF_RANGE;
    4382:	2002      	movs	r0, #2
    4384:	4240      	negs	r0, r0
    4386:	e010      	b.n	43aa <bhy_parse_next_fifo_packet+0x2e6>
		case VS_ID_TIMESTAMP_LSW:
		case VS_ID_TIMESTAMP_LSW_WAKEUP:
		case VS_ID_TIMESTAMP_MSW:
		case VS_ID_TIMESTAMP_MSW_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U16])
				return BHY_OUT_OF_RANGE;
    4388:	2002      	movs	r0, #2
    438a:	4240      	negs	r0, r0
    438c:	e00d      	b.n	43aa <bhy_parse_next_fifo_packet+0x2e6>
		case VS_ID_TEMPERATURE:
		case VS_ID_TEMPERATURE_WAKEUP:
		case VS_ID_AMBIENT_TEMPERATURE:
		case VS_ID_AMBIENT_TEMPERATURE_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_S16])
				return BHY_OUT_OF_RANGE;
    438e:	2002      	movs	r0, #2
    4390:	4240      	negs	r0, r0
    4392:	e00a      	b.n	43aa <bhy_parse_next_fifo_packet+0x2e6>
			break;

		case VS_ID_BAROMETER:
		case VS_ID_BAROMETER_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_SCALAR_U24])
				return BHY_OUT_OF_RANGE;
    4394:	2002      	movs	r0, #2
    4396:	4240      	negs	r0, r0
    4398:	e007      	b.n	43aa <bhy_parse_next_fifo_packet+0x2e6>
		case VS_ID_UNCALIBRATED_MAGNETOMETER:
		case VS_ID_UNCALIBRATED_MAGNETOMETER_WAKEUP:
		case VS_ID_UNCALIBRATED_GYROSCOPE:
		case VS_ID_UNCALIBRATED_GYROSCOPE_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_UNCALIB_VECTOR])
				return BHY_OUT_OF_RANGE;
    439a:	2002      	movs	r0, #2
    439c:	4240      	negs	r0, r0
    439e:	e004      	b.n	43aa <bhy_parse_next_fifo_packet+0x2e6>
			break;

		case VS_ID_META_EVENT:
		case VS_ID_META_EVENT_WAKEUP:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_META_EVENT])
				return BHY_OUT_OF_RANGE;
    43a0:	2002      	movs	r0, #2
    43a2:	4240      	negs	r0, r0
    43a4:	e001      	b.n	43aa <bhy_parse_next_fifo_packet+0x2e6>

		case VS_ID_BSX_C:
		case VS_ID_BSX_B:
		case VS_ID_BSX_A:
			if (*fifo_buffer_length < _fifoSizes[BHY_DATA_TYPE_BSX])
				return BHY_OUT_OF_RANGE;
    43a6:	2002      	movs	r0, #2
    43a8:	4240      	negs	r0, r0

	(*fifo_buffer) += _fifoSizes[*fifo_data_type];
	*fifo_buffer_length -= _fifoSizes[*fifo_data_type];

	return BHY_SUCCESS;
};
    43aa:	bd70      	pop	{r4, r5, r6, pc}
    43ac:	00012ddc 	.word	0x00012ddc
    43b0:	200001c8 	.word	0x200001c8
    43b4:	200002c4 	.word	0x200002c4
    43b8:	20000184 	.word	0x20000184
    43bc:	000131d8 	.word	0x000131d8

000043c0 <bhy_install_sensor_callback>:
#endif

#if BHY_CALLBACK_MODE

BHY_RETURN_FUNCTION_TYPE bhy_install_sensor_callback ( bhy_virtual_sensor_t sensor_id, u8 wakeup_status, void (*sensor_callback)(bhy_data_generic_t *, bhy_virtual_sensor_t) ){
	if (sensor_id > 0x3F) {
    43c0:	283f      	cmp	r0, #63	; 0x3f
    43c2:	d80c      	bhi.n	43de <bhy_install_sensor_callback+0x1e>
		/* Invalid sensor ID */
		return BHY_OUT_OF_RANGE;
	}
	sensor_id = (sensor_id&0x1F) + wakeup_status;
    43c4:	231f      	movs	r3, #31
    43c6:	4018      	ands	r0, r3
	if (g_sensor_callback_list[sensor_id] != 0) {
    43c8:	1841      	adds	r1, r0, r1
    43ca:	b2c9      	uxtb	r1, r1
    43cc:	0088      	lsls	r0, r1, #2
    43ce:	4b07      	ldr	r3, [pc, #28]	; (43ec <bhy_install_sensor_callback+0x2c>)
    43d0:	58c3      	ldr	r3, [r0, r3]
    43d2:	2b00      	cmp	r3, #0
    43d4:	d106      	bne.n	43e4 <bhy_install_sensor_callback+0x24>
		/* There is already a callback installed */
		return BHY_OUT_OF_RANGE;
	} else {
		g_sensor_callback_list[sensor_id] = sensor_callback;
    43d6:	4b05      	ldr	r3, [pc, #20]	; (43ec <bhy_install_sensor_callback+0x2c>)
    43d8:	50c2      	str	r2, [r0, r3]
		return BHY_SUCCESS;
    43da:	2000      	movs	r0, #0
    43dc:	e004      	b.n	43e8 <bhy_install_sensor_callback+0x28>
#if BHY_CALLBACK_MODE

BHY_RETURN_FUNCTION_TYPE bhy_install_sensor_callback ( bhy_virtual_sensor_t sensor_id, u8 wakeup_status, void (*sensor_callback)(bhy_data_generic_t *, bhy_virtual_sensor_t) ){
	if (sensor_id > 0x3F) {
		/* Invalid sensor ID */
		return BHY_OUT_OF_RANGE;
    43de:	2002      	movs	r0, #2
    43e0:	4240      	negs	r0, r0
    43e2:	e001      	b.n	43e8 <bhy_install_sensor_callback+0x28>
	}
	sensor_id = (sensor_id&0x1F) + wakeup_status;
	if (g_sensor_callback_list[sensor_id] != 0) {
		/* There is already a callback installed */
		return BHY_OUT_OF_RANGE;
    43e4:	2002      	movs	r0, #2
    43e6:	4240      	negs	r0, r0
	} else {
		g_sensor_callback_list[sensor_id] = sensor_callback;
		return BHY_SUCCESS;
	}
}
    43e8:	4770      	bx	lr
    43ea:	46c0      	nop			; (mov r8, r8)
    43ec:	200001c8 	.word	0x200001c8

000043f0 <_i2c_master_wait_for_sync>:
{
	/* Sanity check */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_hw = &(module->hw->I2CM);
    43f0:	6801      	ldr	r1, [r0, #0]
		const struct i2c_master_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
    43f2:	2207      	movs	r2, #7
	SercomI2cm *const i2c_hw = &(module->hw->I2CM);

#if defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_1)
	return (i2c_hw->STATUS.reg & SERCOM_I2CM_STATUS_SYNCBUSY);
#elif defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_2)
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
    43f4:	69cb      	ldr	r3, [r1, #28]
		const struct i2c_master_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
    43f6:	421a      	tst	r2, r3
    43f8:	d1fc      	bne.n	43f4 <_i2c_master_wait_for_sync+0x4>
		/* Wait for I2C module to sync. */
	}
}
    43fa:	4770      	bx	lr

000043fc <configure_sensor_i2c>:

/*! \brief Configure I2C peripheral
 *
 */
void configure_sensor_i2c(void)
{
    43fc:	b530      	push	{r4, r5, lr}
    43fe:	b08f      	sub	sp, #60	; 0x3c
static inline void i2c_master_get_config_defaults(
		struct i2c_master_config *const config)
{
	/*Sanity check argument */
	Assert(config);
	config->baud_rate        = I2C_MASTER_BAUD_RATE_100KHZ;
    4400:	ab01      	add	r3, sp, #4
    4402:	2264      	movs	r2, #100	; 0x64
    4404:	9201      	str	r2, [sp, #4]
#ifdef FEATURE_I2C_FAST_MODE_PLUS_AND_HIGH_SPEED
	config->baud_rate_high_speed = I2C_MASTER_BAUD_RATE_3400KHZ;
    4406:	4a22      	ldr	r2, [pc, #136]	; (4490 <configure_sensor_i2c+0x94>)
    4408:	9202      	str	r2, [sp, #8]
	config->transfer_speed       = I2C_MASTER_SPEED_STANDARD_AND_FAST;
    440a:	2200      	movs	r2, #0
    440c:	9203      	str	r2, [sp, #12]
#endif
	config->generator_source = GCLK_GENERATOR_0;
    440e:	731a      	strb	r2, [r3, #12]
	config->run_in_standby   = false;
    4410:	761a      	strb	r2, [r3, #24]
	config->start_hold_time  = I2C_MASTER_START_HOLD_TIME_300NS_600NS;
    4412:	2180      	movs	r1, #128	; 0x80
    4414:	0389      	lsls	r1, r1, #14
    4416:	9105      	str	r1, [sp, #20]
	config->buffer_timeout   = 65535;
    4418:	2101      	movs	r1, #1
    441a:	4249      	negs	r1, r1
    441c:	82d9      	strh	r1, [r3, #22]
	config->unknown_bus_state_timeout = 65535;
    441e:	8299      	strh	r1, [r3, #20]
	config->pinmux_pad0      = PINMUX_DEFAULT;
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->scl_low_timeout  = false;
    4420:	3125      	adds	r1, #37	; 0x25
    4422:	545a      	strb	r2, [r3, r1]
	config->inactive_timeout = I2C_MASTER_INACTIVE_TIMEOUT_DISABLED;
    4424:	920b      	str	r2, [sp, #44]	; 0x2c
#ifdef FEATURE_I2C_SCL_STRETCH_MODE
	config->scl_stretch_only_after_ack_bit = false;
    4426:	3108      	adds	r1, #8
    4428:	545a      	strb	r2, [r3, r1]
#endif
#ifdef FEATURE_I2C_SCL_EXTEND_TIMEOUT
	config->slave_scl_low_extend_timeout   = false;
    442a:	3101      	adds	r1, #1
    442c:	545a      	strb	r2, [r3, r1]
	config->master_scl_low_extend_timeout  = false;
    442e:	3101      	adds	r1, #1
    4430:	545a      	strb	r2, [r3, r1]
#endif
	/* The typical value is 215ns */
	config->sda_scl_rise_time_ns = 215;
    4432:	32d7      	adds	r2, #215	; 0xd7
    4434:	861a      	strh	r2, [r3, #48]	; 0x30
	/* Initialize config structure and software module */

	struct i2c_master_config config_i2c_master;
	i2c_master_get_config_defaults(&config_i2c_master);
	
	config_i2c_master.pinmux_pad0 = SENSOR_I2C_PINMUX_PAD0;
    4436:	4a17      	ldr	r2, [pc, #92]	; (4494 <configure_sensor_i2c+0x98>)
    4438:	9208      	str	r2, [sp, #32]
	config_i2c_master.pinmux_pad1 = SENSOR_I2C_PINMUX_PAD1;
    443a:	4a17      	ldr	r2, [pc, #92]	; (4498 <configure_sensor_i2c+0x9c>)
    443c:	9209      	str	r2, [sp, #36]	; 0x24
	//config_i2c_master.generator_source = GCLK_GENERATOR_1;
	//config_i2c_master.generator_source = GCLK_GENERATOR_2;
	/* Initialize and enable device with config */
	while(i2c_master_init(&i2c_master_instance, SENSOR_I2C, &config_i2c_master)     \
    443e:	4d17      	ldr	r5, [pc, #92]	; (449c <configure_sensor_i2c+0xa0>)
    4440:	4c17      	ldr	r4, [pc, #92]	; (44a0 <configure_sensor_i2c+0xa4>)
    4442:	aa01      	add	r2, sp, #4
    4444:	4917      	ldr	r1, [pc, #92]	; (44a4 <configure_sensor_i2c+0xa8>)
    4446:	0028      	movs	r0, r5
    4448:	47a0      	blx	r4
    444a:	2800      	cmp	r0, #0
    444c:	d1f9      	bne.n	4442 <configure_sensor_i2c+0x46>
{
	/* Sanity check of arguments */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    444e:	4d13      	ldr	r5, [pc, #76]	; (449c <configure_sensor_i2c+0xa0>)
    4450:	682c      	ldr	r4, [r5, #0]

	/* Timeout counter used to force bus state */
	uint32_t timeout_counter = 0;

	/* Wait for module to sync */
	_i2c_master_wait_for_sync(module);
    4452:	0028      	movs	r0, r5
    4454:	4b14      	ldr	r3, [pc, #80]	; (44a8 <configure_sensor_i2c+0xac>)
    4456:	4798      	blx	r3

	/* Enable module */
	i2c_module->CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
    4458:	6822      	ldr	r2, [r4, #0]
    445a:	2302      	movs	r3, #2
    445c:	4313      	orrs	r3, r2
    445e:	6023      	str	r3, [r4, #0]

#if I2C_MASTER_CALLBACK_MODE == true
	/* Enable module interrupts */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    4460:	6828      	ldr	r0, [r5, #0]
    4462:	4b12      	ldr	r3, [pc, #72]	; (44ac <configure_sensor_i2c+0xb0>)
    4464:	4798      	blx	r3
    4466:	231f      	movs	r3, #31
    4468:	4018      	ands	r0, r3
    446a:	3b1e      	subs	r3, #30
    446c:	4083      	lsls	r3, r0
    446e:	4a10      	ldr	r2, [pc, #64]	; (44b0 <configure_sensor_i2c+0xb4>)
    4470:	6013      	str	r3, [r2, #0]
#endif
	/* Start timeout if bus state is unknown */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
		timeout_counter++;
		if(timeout_counter >= (module->unknown_bus_state_timeout)) {
    4472:	88e8      	ldrh	r0, [r5, #6]
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Timeout counter used to force bus state */
	uint32_t timeout_counter = 0;
    4474:	2300      	movs	r3, #0
#if I2C_MASTER_CALLBACK_MODE == true
	/* Enable module interrupts */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#endif
	/* Start timeout if bus state is unknown */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
    4476:	2110      	movs	r1, #16
    4478:	e005      	b.n	4486 <configure_sensor_i2c+0x8a>
		timeout_counter++;
    447a:	3301      	adds	r3, #1
		if(timeout_counter >= (module->unknown_bus_state_timeout)) {
    447c:	4283      	cmp	r3, r0
    447e:	d302      	bcc.n	4486 <configure_sensor_i2c+0x8a>
			/* Timeout, force bus state to idle */
			i2c_module->STATUS.reg = SERCOM_I2CM_STATUS_BUSSTATE(1);
    4480:	2310      	movs	r3, #16
    4482:	8363      	strh	r3, [r4, #26]
    4484:	e002      	b.n	448c <configure_sensor_i2c+0x90>
#if I2C_MASTER_CALLBACK_MODE == true
	/* Enable module interrupts */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#endif
	/* Start timeout if bus state is unknown */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
    4486:	8b62      	ldrh	r2, [r4, #26]
    4488:	420a      	tst	r2, r1
    448a:	d0f6      	beq.n	447a <configure_sensor_i2c+0x7e>
	!= STATUS_OK);

	i2c_master_enable(&i2c_master_instance);
}
    448c:	b00f      	add	sp, #60	; 0x3c
    448e:	bd30      	pop	{r4, r5, pc}
    4490:	00000d48 	.word	0x00000d48
    4494:	000c0003 	.word	0x000c0003
    4498:	000d0003 	.word	0x000d0003
    449c:	20000e6c 	.word	0x20000e6c
    44a0:	00004a51 	.word	0x00004a51
    44a4:	42001000 	.word	0x42001000
    44a8:	000043f1 	.word	0x000043f1
    44ac:	000069e1 	.word	0x000069e1
    44b0:	e000e100 	.word	0xe000e100

000044b4 <veml6080_init>:
#include "conf_sensor.h"



enum status_code veml6080_init(void)
{
    44b4:	b500      	push	{lr}
    44b6:	b085      	sub	sp, #20
	
	uint8_t buffer[3];
	buffer[0] = VEML6080_CONFIG_CMD_CODE;
    44b8:	aa03      	add	r2, sp, #12
    44ba:	2300      	movs	r3, #0
    44bc:	7013      	strb	r3, [r2, #0]
	buffer[1] = VEML6080_INIT_VALUE;  //Config LSB value
    44be:	7053      	strb	r3, [r2, #1]
	buffer[2] = VEML6080_INIT_VALUE;
    44c0:	7093      	strb	r3, [r2, #2]
	
	enum status_code sensor_wr_status = STATUS_BUSY;
	
	/* Set up internal EEPROM addr write */
	struct i2c_master_packet sensor_wr_packet = {
    44c2:	2110      	movs	r1, #16
    44c4:	4668      	mov	r0, sp
    44c6:	8001      	strh	r1, [r0, #0]
    44c8:	390d      	subs	r1, #13
    44ca:	8041      	strh	r1, [r0, #2]
    44cc:	9201      	str	r2, [sp, #4]
    44ce:	7203      	strb	r3, [r0, #8]
    44d0:	7243      	strb	r3, [r0, #9]
    44d2:	7283      	strb	r3, [r0, #10]
		.ten_bit_address = false,
		.high_speed      = false,
		.hs_master_code  = 0x0,
	};
	
	sensor_wr_status = i2c_master_write_packet_wait(&i2c_master_instance,&sensor_wr_packet);
    44d4:	4669      	mov	r1, sp
    44d6:	4802      	ldr	r0, [pc, #8]	; (44e0 <veml6080_init+0x2c>)
    44d8:	4b02      	ldr	r3, [pc, #8]	; (44e4 <veml6080_init+0x30>)
    44da:	4798      	blx	r3
	

	return sensor_wr_status;
}
    44dc:	b005      	add	sp, #20
    44de:	bd00      	pop	{pc}
    44e0:	20000e6c 	.word	0x20000e6c
    44e4:	00004f75 	.word	0x00004f75

000044e8 <veml6080_read_alsdata>:

/*---------------------------------------------*/
/*Function to read the ALS data from veml6080*/
/*---------------------------------------------*/
enum status_code veml6080_read_alsdata (uint16_t *als_data)
{
    44e8:	b510      	push	{r4, lr}
    44ea:	b088      	sub	sp, #32
    44ec:	0004      	movs	r4, r0
	
	enum status_code sensor_wr_status = STATUS_BUSY;
	enum status_code sensor_rd_status = STATUS_BUSY;
	uint8_t cmd = VEML6080_ALSDATA_CMD_CODE;
    44ee:	231f      	movs	r3, #31
    44f0:	446b      	add	r3, sp
    44f2:	2208      	movs	r2, #8
    44f4:	701a      	strb	r2, [r3, #0]
	uint8_t buffer[2] = {0};
    44f6:	2100      	movs	r1, #0
    44f8:	aa07      	add	r2, sp, #28
    44fa:	8011      	strh	r1, [r2, #0]
	uint16_t temp = 0;
	
	/* Set up internal EEPROM addr write */
	struct i2c_master_packet sensor_wr_packet = {
    44fc:	a904      	add	r1, sp, #16
    44fe:	2210      	movs	r2, #16
    4500:	800a      	strh	r2, [r1, #0]
    4502:	3a0f      	subs	r2, #15
    4504:	804a      	strh	r2, [r1, #2]
    4506:	604b      	str	r3, [r1, #4]
    4508:	2300      	movs	r3, #0
    450a:	2200      	movs	r2, #0
    450c:	720a      	strb	r2, [r1, #8]
    450e:	724b      	strb	r3, [r1, #9]
    4510:	728b      	strb	r3, [r1, #10]
		.ten_bit_address = false,
		.high_speed      = false,
		.hs_master_code  = 0x0,
	};
	
	sensor_wr_status = i2c_master_write_packet_wait_no_stop(&i2c_master_instance,
    4512:	480e      	ldr	r0, [pc, #56]	; (454c <veml6080_read_alsdata+0x64>)
    4514:	4b0e      	ldr	r3, [pc, #56]	; (4550 <veml6080_read_alsdata+0x68>)
    4516:	4798      	blx	r3
    4518:	1e03      	subs	r3, r0, #0
	&sensor_wr_packet);
	
	if (sensor_wr_status != STATUS_OK){
    451a:	d115      	bne.n	4548 <veml6080_read_alsdata+0x60>
		return sensor_wr_status;
	}
	
	/* Set up internal EEPROM addr write */
	struct i2c_master_packet sensor_rd_packet = {
    451c:	a901      	add	r1, sp, #4
    451e:	3310      	adds	r3, #16
    4520:	800b      	strh	r3, [r1, #0]
    4522:	3b0e      	subs	r3, #14
    4524:	804b      	strh	r3, [r1, #2]
    4526:	ab07      	add	r3, sp, #28
    4528:	604b      	str	r3, [r1, #4]
    452a:	2300      	movs	r3, #0
    452c:	720b      	strb	r3, [r1, #8]
    452e:	724b      	strb	r3, [r1, #9]
    4530:	728b      	strb	r3, [r1, #10]
		.ten_bit_address = false,
		.high_speed      = false,
		.hs_master_code  = 0x0,
	};
	
	sensor_rd_status = i2c_master_read_packet_wait(&i2c_master_instance,&sensor_rd_packet);
    4532:	4806      	ldr	r0, [pc, #24]	; (454c <veml6080_read_alsdata+0x64>)
    4534:	4b07      	ldr	r3, [pc, #28]	; (4554 <veml6080_read_alsdata+0x6c>)
    4536:	4798      	blx	r3
	
	if (sensor_rd_status != STATUS_OK){
    4538:	2800      	cmp	r0, #0
    453a:	d105      	bne.n	4548 <veml6080_read_alsdata+0x60>
		return sensor_rd_status;
	}
	
	temp = ((buffer[1] << 8) | buffer[0]);
    453c:	a907      	add	r1, sp, #28
	
	*als_data = temp;
    453e:	784b      	ldrb	r3, [r1, #1]
    4540:	021b      	lsls	r3, r3, #8
    4542:	7809      	ldrb	r1, [r1, #0]
    4544:	430b      	orrs	r3, r1
    4546:	8023      	strh	r3, [r4, #0]
	
	return STATUS_OK;
	
    4548:	b008      	add	sp, #32
    454a:	bd10      	pop	{r4, pc}
    454c:	20000e6c 	.word	0x20000e6c
    4550:	00004f95 	.word	0x00004f95
    4554:	00004f55 	.word	0x00004f55

00004558 <_adc_get_inst_index>:
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
}
    4558:	2000      	movs	r0, #0
    455a:	4770      	bx	lr

0000455c <adc_get_config_defaults>:
 *
 * \param[out] config  Pointer to configuration struct to initialize to
 *                     default values
 */
void adc_get_config_defaults(struct adc_config *const config)
{
    455c:	b510      	push	{r4, lr}
	Assert(config);
	config->clock_source                  = GCLK_GENERATOR_0;
    455e:	2300      	movs	r3, #0
    4560:	2200      	movs	r2, #0
    4562:	7003      	strb	r3, [r0, #0]
	config->reference                     = ADC_REFERENCE_INTREF;
    4564:	7043      	strb	r3, [r0, #1]
	config->clock_prescaler               = ADC_CLOCK_PRESCALER_DIV2;
    4566:	7083      	strb	r3, [r0, #2]
	config->resolution                    = ADC_RESOLUTION_12BIT;
    4568:	70c3      	strb	r3, [r0, #3]
	config->window.window_mode            = ADC_WINDOW_MODE_DISABLE;
    456a:	2100      	movs	r1, #0
    456c:	8303      	strh	r3, [r0, #24]
	config->window.window_upper_value     = 0;
    456e:	6203      	str	r3, [r0, #32]
	config->window.window_lower_value     = 0;
    4570:	61c3      	str	r3, [r0, #28]
	config->positive_input                = ADC_POSITIVE_INPUT_PIN1;
    4572:	2401      	movs	r4, #1
    4574:	7104      	strb	r4, [r0, #4]
	config->negative_input                = ADC_NEGATIVE_INPUT_GND;
    4576:	24c0      	movs	r4, #192	; 0xc0
    4578:	0164      	lsls	r4, r4, #5
    457a:	80c4      	strh	r4, [r0, #6]
	config->accumulate_samples            = ADC_ACCUMULATE_DISABLE;
    457c:	7201      	strb	r1, [r0, #8]
	config->divide_result                 = ADC_DIVIDE_RESULT_DISABLE;
    457e:	7242      	strb	r2, [r0, #9]
	config->left_adjust                   = false;
    4580:	7282      	strb	r2, [r0, #10]
	config->differential_mode             = false;
    4582:	72c2      	strb	r2, [r0, #11]
	config->freerunning                   = false;
    4584:	7302      	strb	r2, [r0, #12]
	config->event_action                  = ADC_EVENT_ACTION_DISABLED;
    4586:	242a      	movs	r4, #42	; 0x2a
    4588:	5502      	strb	r2, [r0, r4]
	config->run_in_standby                = false;
    458a:	7342      	strb	r2, [r0, #13]
	config->on_demand                     = false;
    458c:	7382      	strb	r2, [r0, #14]
	config->sampling_time_compensation_enable  = false;
    458e:	73c2      	strb	r2, [r0, #15]
	config->positive_input_sequence_mask_enable = 0;
    4590:	6103      	str	r3, [r0, #16]
	config->reference_compensation_enable = false;
    4592:	7502      	strb	r2, [r0, #20]
	config->correction.correction_enable  = false;
    4594:	3c06      	subs	r4, #6
    4596:	5502      	strb	r2, [r0, r4]
	config->correction.gain_correction    = ADC_GAINCORR_RESETVALUE;
    4598:	84c3      	strh	r3, [r0, #38]	; 0x26
	config->correction.offset_correction  = ADC_OFFSETCORR_RESETVALUE;
    459a:	8503      	strh	r3, [r0, #40]	; 0x28
	config->sample_length                 = 0;
    459c:	7541      	strb	r1, [r0, #21]
}
    459e:	bd10      	pop	{r4, pc}

000045a0 <adc_init>:
 */
enum status_code adc_init(
		struct adc_module *const module_inst,
		Adc *hw,
		struct adc_config *config)
{
    45a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    45a2:	464f      	mov	r7, r9
    45a4:	b480      	push	{r7}
    45a6:	b09a      	sub	sp, #104	; 0x68
    45a8:	0005      	movs	r5, r0
    45aa:	000c      	movs	r4, r1
    45ac:	0016      	movs	r6, r2
	Assert(module_inst);
	Assert(hw);
	Assert(config);

	/* Temporary variable to hold ADC instance number */
	uint8_t instance = _adc_get_inst_index(hw);
    45ae:	0008      	movs	r0, r1
    45b0:	4ba9      	ldr	r3, [pc, #676]	; (4858 <adc_init+0x2b8>)
    45b2:	4798      	blx	r3

	/* Associate the software module instance with the hardware module */
	module_inst->hw = hw;
    45b4:	602c      	str	r4, [r5, #0]
    45b6:	4aa9      	ldr	r2, [pc, #676]	; (485c <adc_init+0x2bc>)
    45b8:	6a11      	ldr	r1, [r2, #32]
    45ba:	2308      	movs	r3, #8
    45bc:	430b      	orrs	r3, r1
    45be:	6213      	str	r3, [r2, #32]
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, MCLK_APBDMASK_ADC);
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, _adc_apbcmasks[instance]);
#endif

	if (hw->CTRLA.reg & ADC_CTRLA_SWRST) {
    45c0:	7822      	ldrb	r2, [r4, #0]
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
    45c2:	2305      	movs	r3, #5
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, MCLK_APBDMASK_ADC);
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, _adc_apbcmasks[instance]);
#endif

	if (hw->CTRLA.reg & ADC_CTRLA_SWRST) {
    45c4:	07d2      	lsls	r2, r2, #31
    45c6:	d500      	bpl.n	45ca <adc_init+0x2a>
    45c8:	e1c9      	b.n	495e <adc_init+0x3be>
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    45ca:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    45cc:	8c13      	ldrh	r3, [r2, #32]
    45ce:	b29b      	uxth	r3, r3
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
	}

	while (adc_is_syncing(module_inst)) {
    45d0:	2b00      	cmp	r3, #0
    45d2:	d1fb      	bne.n	45cc <adc_init+0x2c>
		/* Wait for synchronization */
	}

	if (hw->CTRLA.reg & ADC_CTRLA_ENABLE) {
    45d4:	7822      	ldrb	r2, [r4, #0]
		/* Module must be disabled before initialization. Abort. */
		return STATUS_ERR_DENIED;
    45d6:	331c      	adds	r3, #28

	while (adc_is_syncing(module_inst)) {
		/* Wait for synchronization */
	}

	if (hw->CTRLA.reg & ADC_CTRLA_ENABLE) {
    45d8:	0792      	lsls	r2, r2, #30
    45da:	d500      	bpl.n	45de <adc_init+0x3e>
    45dc:	e1bf      	b.n	495e <adc_init+0x3be>
		/* Module must be disabled before initialization. Abort. */
		return STATUS_ERR_DENIED;
	}

	/* Store the selected reference for later use */
	module_inst->reference = config->reference;
    45de:	7873      	ldrb	r3, [r6, #1]
    45e0:	712b      	strb	r3, [r5, #4]

	/* Make sure the voltage reference is enabled if requested by the config */
	if (module_inst->reference == ADC_REFERENCE_INTREF) {
    45e2:	2b00      	cmp	r3, #0
    45e4:	d104      	bne.n	45f0 <adc_init+0x50>
	switch (vref) {
		case SYSTEM_VOLTAGE_REFERENCE_TEMPSENSE:
			SUPC->VREF.reg |= SUPC_VREF_TSEN;
			break;
		case SYSTEM_VOLTAGE_REFERENCE_OUTPUT:
			SUPC->VREF.reg |= SUPC_VREF_VREFOE;
    45e6:	4a9e      	ldr	r2, [pc, #632]	; (4860 <adc_init+0x2c0>)
    45e8:	69d1      	ldr	r1, [r2, #28]
    45ea:	3304      	adds	r3, #4
    45ec:	430b      	orrs	r3, r1
    45ee:	61d3      	str	r3, [r2, #28]
		system_voltage_reference_enable(SYSTEM_VOLTAGE_REFERENCE_OUTPUT);
	}

#if ADC_CALLBACK_MODE == true
	for (uint8_t i = 0; i < ADC_CALLBACK_N; i++) {
		module_inst->callback[i] = NULL;
    45f0:	2300      	movs	r3, #0
    45f2:	60ab      	str	r3, [r5, #8]
    45f4:	60eb      	str	r3, [r5, #12]
    45f6:	612b      	str	r3, [r5, #16]
	};

	module_inst->registered_callback_mask = 0;
    45f8:	76ab      	strb	r3, [r5, #26]
	module_inst->enabled_callback_mask = 0;
    45fa:	76eb      	strb	r3, [r5, #27]
	module_inst->remaining_conversions = 0;
    45fc:	832b      	strh	r3, [r5, #24]
	module_inst->job_status = STATUS_OK;
    45fe:	772b      	strb	r3, [r5, #28]

	_adc_instances[instance] = module_inst;
    4600:	0080      	lsls	r0, r0, #2
    4602:	4b98      	ldr	r3, [pc, #608]	; (4864 <adc_init+0x2c4>)
    4604:	50c5      	str	r5, [r0, r3]

	if (config->event_action == ADC_EVENT_ACTION_DISABLED &&
    4606:	232a      	movs	r3, #42	; 0x2a
    4608:	5cf3      	ldrb	r3, [r6, r3]
    460a:	2b00      	cmp	r3, #0
    460c:	d105      	bne.n	461a <adc_init+0x7a>
    460e:	7b33      	ldrb	r3, [r6, #12]
    4610:	2b00      	cmp	r3, #0
    4612:	d102      	bne.n	461a <adc_init+0x7a>
			!config->freerunning) {
		module_inst->software_trigger = true;
    4614:	3301      	adds	r3, #1
    4616:	776b      	strb	r3, [r5, #29]
    4618:	e001      	b.n	461e <adc_init+0x7e>
	} else {
		module_inst->software_trigger = false;
    461a:	2300      	movs	r3, #0
    461c:	776b      	strb	r3, [r5, #29]
	uint8_t adjres = 0;
	uint32_t resolution = ADC_RESOLUTION_16BIT;
	enum adc_accumulate_samples accumulate = ADC_ACCUMULATE_DISABLE;

	/* Get the hardware module pointer */
	Adc *const adc_module = module_inst->hw;
    461e:	682f      	ldr	r7, [r5, #0]

	/* Configure GCLK channel and enable clock */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->clock_source;
    4620:	7833      	ldrb	r3, [r6, #0]
    4622:	466a      	mov	r2, sp
    4624:	7013      	strb	r3, [r2, #0]
	system_gclk_chan_set_config(_adc_gclk_ids[index], &gclk_chan_conf);
    4626:	4669      	mov	r1, sp
    4628:	201e      	movs	r0, #30
    462a:	4b8f      	ldr	r3, [pc, #572]	; (4868 <adc_init+0x2c8>)
    462c:	4798      	blx	r3
	system_gclk_chan_enable(_adc_gclk_ids[index]);
    462e:	201e      	movs	r0, #30
    4630:	4b8e      	ldr	r3, [pc, #568]	; (486c <adc_init+0x2cc>)
    4632:	4798      	blx	r3

	/* Setup pinmuxing for analog inputs */
	_adc_configure_ain_pin(index, config->positive_input);
    4634:	7934      	ldrb	r4, [r6, #4]
{
#define PIN_INVALID_ADC_AIN    0xFFFFUL

	/* Pinmapping table for AINxx -> GPIO pin number */
#if (SAML21) || (SAML22)
	const uint32_t pinmapping[] = {
    4636:	2260      	movs	r2, #96	; 0x60
    4638:	498d      	ldr	r1, [pc, #564]	; (4870 <adc_init+0x2d0>)
    463a:	a802      	add	r0, sp, #8
    463c:	4b8d      	ldr	r3, [pc, #564]	; (4874 <adc_init+0x2d4>)
    463e:	4798      	blx	r3
	Assert(pinmapping);
#endif

	uint32_t pin_map_result = PIN_INVALID_ADC_AIN;

	if (pin <= _adc_extchannel_msb[index]) {
    4640:	2c13      	cmp	r4, #19
    4642:	d80c      	bhi.n	465e <adc_init+0xbe>
		pin_map_result = pinmapping[pin >> ADC_INPUTCTRL_MUXPOS_Pos];
    4644:	00a4      	lsls	r4, r4, #2
    4646:	ab02      	add	r3, sp, #8
    4648:	58e0      	ldr	r0, [r4, r3]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    464a:	a901      	add	r1, sp, #4
    464c:	2300      	movs	r3, #0
    464e:	704b      	strb	r3, [r1, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    4650:	70cb      	strb	r3, [r1, #3]

		struct system_pinmux_config config;
		system_pinmux_get_config_defaults(&config);

		/* Analog functions are all on MUX setting B */
		config.input_pull   = SYSTEM_PINMUX_PIN_PULL_NONE;
    4652:	708b      	strb	r3, [r1, #2]
		config.mux_position = 1;
    4654:	3301      	adds	r3, #1
    4656:	700b      	strb	r3, [r1, #0]

		system_pinmux_pin_set_config(pin_map_result, &config);
    4658:	b2c0      	uxtb	r0, r0
    465a:	4b87      	ldr	r3, [pc, #540]	; (4878 <adc_init+0x2d8>)
    465c:	4798      	blx	r3
	system_gclk_chan_set_config(_adc_gclk_ids[index], &gclk_chan_conf);
	system_gclk_chan_enable(_adc_gclk_ids[index]);

	/* Setup pinmuxing for analog inputs */
	_adc_configure_ain_pin(index, config->positive_input);
	_adc_configure_ain_pin(index, config->negative_input);
    465e:	88f4      	ldrh	r4, [r6, #6]
{
#define PIN_INVALID_ADC_AIN    0xFFFFUL

	/* Pinmapping table for AINxx -> GPIO pin number */
#if (SAML21) || (SAML22)
	const uint32_t pinmapping[] = {
    4660:	2260      	movs	r2, #96	; 0x60
    4662:	4983      	ldr	r1, [pc, #524]	; (4870 <adc_init+0x2d0>)
    4664:	a802      	add	r0, sp, #8
    4666:	4b83      	ldr	r3, [pc, #524]	; (4874 <adc_init+0x2d4>)
    4668:	4798      	blx	r3
	Assert(pinmapping);
#endif

	uint32_t pin_map_result = PIN_INVALID_ADC_AIN;

	if (pin <= _adc_extchannel_msb[index]) {
    466a:	2c13      	cmp	r4, #19
    466c:	d80c      	bhi.n	4688 <adc_init+0xe8>
		pin_map_result = pinmapping[pin >> ADC_INPUTCTRL_MUXPOS_Pos];
    466e:	00a4      	lsls	r4, r4, #2
    4670:	ab02      	add	r3, sp, #8
    4672:	58e0      	ldr	r0, [r4, r3]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    4674:	a901      	add	r1, sp, #4
    4676:	2300      	movs	r3, #0
    4678:	704b      	strb	r3, [r1, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    467a:	70cb      	strb	r3, [r1, #3]

		struct system_pinmux_config config;
		system_pinmux_get_config_defaults(&config);

		/* Analog functions are all on MUX setting B */
		config.input_pull   = SYSTEM_PINMUX_PIN_PULL_NONE;
    467c:	708b      	strb	r3, [r1, #2]
		config.mux_position = 1;
    467e:	3301      	adds	r3, #1
    4680:	700b      	strb	r3, [r1, #0]

		system_pinmux_pin_set_config(pin_map_result, &config);
    4682:	b2c0      	uxtb	r0, r0
    4684:	4b7c      	ldr	r3, [pc, #496]	; (4878 <adc_init+0x2d8>)
    4686:	4798      	blx	r3
    4688:	2400      	movs	r4, #0
{
#define PIN_INVALID_ADC_AIN    0xFFFFUL

	/* Pinmapping table for AINxx -> GPIO pin number */
#if (SAML21) || (SAML22)
	const uint32_t pinmapping[] = {
    468a:	4b7a      	ldr	r3, [pc, #488]	; (4874 <adc_init+0x2d4>)
    468c:	4699      	mov	r9, r3
	_adc_configure_ain_pin(index, config->positive_input);
	_adc_configure_ain_pin(index, config->negative_input);

	/* Set pinmux for positive input sequence*/
	for(uint8_t i=0;i <= _adc_extchannel_msb[index];i++){
		if(config->positive_input_sequence_mask_enable & (1 << i)){
    468e:	2301      	movs	r3, #1
    4690:	40a3      	lsls	r3, r4
    4692:	6932      	ldr	r2, [r6, #16]
    4694:	421a      	tst	r2, r3
    4696:	d012      	beq.n	46be <adc_init+0x11e>
{
#define PIN_INVALID_ADC_AIN    0xFFFFUL

	/* Pinmapping table for AINxx -> GPIO pin number */
#if (SAML21) || (SAML22)
	const uint32_t pinmapping[] = {
    4698:	2260      	movs	r2, #96	; 0x60
    469a:	4975      	ldr	r1, [pc, #468]	; (4870 <adc_init+0x2d0>)
    469c:	a802      	add	r0, sp, #8
    469e:	47c8      	blx	r9
	Assert(pinmapping);
#endif

	uint32_t pin_map_result = PIN_INVALID_ADC_AIN;

	if (pin <= _adc_extchannel_msb[index]) {
    46a0:	2c13      	cmp	r4, #19
    46a2:	d80c      	bhi.n	46be <adc_init+0x11e>
		pin_map_result = pinmapping[pin >> ADC_INPUTCTRL_MUXPOS_Pos];
    46a4:	00a3      	lsls	r3, r4, #2
    46a6:	aa02      	add	r2, sp, #8
    46a8:	5898      	ldr	r0, [r3, r2]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    46aa:	a901      	add	r1, sp, #4
    46ac:	2300      	movs	r3, #0
    46ae:	704b      	strb	r3, [r1, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    46b0:	70cb      	strb	r3, [r1, #3]

		struct system_pinmux_config config;
		system_pinmux_get_config_defaults(&config);

		/* Analog functions are all on MUX setting B */
		config.input_pull   = SYSTEM_PINMUX_PIN_PULL_NONE;
    46b2:	708b      	strb	r3, [r1, #2]
		config.mux_position = 1;
    46b4:	3301      	adds	r3, #1
    46b6:	700b      	strb	r3, [r1, #0]

		system_pinmux_pin_set_config(pin_map_result, &config);
    46b8:	b2c0      	uxtb	r0, r0
    46ba:	4b6f      	ldr	r3, [pc, #444]	; (4878 <adc_init+0x2d8>)
    46bc:	4798      	blx	r3
    46be:	3401      	adds	r4, #1
	/* Setup pinmuxing for analog inputs */
	_adc_configure_ain_pin(index, config->positive_input);
	_adc_configure_ain_pin(index, config->negative_input);

	/* Set pinmux for positive input sequence*/
	for(uint8_t i=0;i <= _adc_extchannel_msb[index];i++){
    46c0:	2c14      	cmp	r4, #20
    46c2:	d1e4      	bne.n	468e <adc_init+0xee>
			_adc_configure_ain_pin(index, i);
		}
	}

	/* Configure run in standby and on demand */
	adc_module->CTRLA.reg = ((config->run_in_standby << ADC_CTRLA_RUNSTDBY_Pos)
    46c4:	7b73      	ldrb	r3, [r6, #13]
    46c6:	019a      	lsls	r2, r3, #6
    46c8:	7bb3      	ldrb	r3, [r6, #14]
    46ca:	01db      	lsls	r3, r3, #7
    46cc:	4313      	orrs	r3, r2
    46ce:	b2db      	uxtb	r3, r3
    46d0:	703b      	strb	r3, [r7, #0]
						    | (config->on_demand << ADC_CTRLA_ONDEMAND_Pos)) ;

	/* Configure reference */
	adc_module->REFCTRL.reg =
    46d2:	7d33      	ldrb	r3, [r6, #20]
    46d4:	01db      	lsls	r3, r3, #7
    46d6:	7872      	ldrb	r2, [r6, #1]
    46d8:	4313      	orrs	r3, r2
    46da:	b2db      	uxtb	r3, r3
    46dc:	70bb      	strb	r3, [r7, #2]
			(config->reference_compensation_enable << ADC_REFCTRL_REFCOMP_Pos)
			| (config->reference);

	/* Set adjusting result and number of samples */
	switch (config->resolution) {
    46de:	78f3      	ldrb	r3, [r6, #3]
    46e0:	2b34      	cmp	r3, #52	; 0x34
    46e2:	d900      	bls.n	46e6 <adc_init+0x146>
    46e4:	e13a      	b.n	495c <adc_init+0x3bc>
    46e6:	009b      	lsls	r3, r3, #2
    46e8:	4a64      	ldr	r2, [pc, #400]	; (487c <adc_init+0x2dc>)
    46ea:	58d3      	ldr	r3, [r2, r3]
    46ec:	469f      	mov	pc, r3
		break;

	case ADC_RESOLUTION_14BIT:
		/* Increase resolution by 2 bit */
		adjres = ADC_DIVIDE_RESULT_4;
		accumulate = ADC_ACCUMULATE_SAMPLES_16;
    46ee:	2004      	movs	r0, #4
		/* 16-bit result register */
		resolution = ADC_RESOLUTION_16BIT;
    46f0:	2110      	movs	r1, #16
		resolution = ADC_RESOLUTION_16BIT;
		break;

	case ADC_RESOLUTION_14BIT:
		/* Increase resolution by 2 bit */
		adjres = ADC_DIVIDE_RESULT_4;
    46f2:	2202      	movs	r2, #2
    46f4:	e01a      	b.n	472c <adc_init+0x18c>

	/* Set adjusting result and number of samples */
	switch (config->resolution) {

	case ADC_RESOLUTION_CUSTOM:
		adjres = config->divide_result;
    46f6:	7a72      	ldrb	r2, [r6, #9]
		accumulate = config->accumulate_samples;
    46f8:	7a30      	ldrb	r0, [r6, #8]
		/* 16-bit result register */
		resolution = ADC_RESOLUTION_16BIT;
    46fa:	2110      	movs	r1, #16
    46fc:	e016      	b.n	472c <adc_init+0x18c>
		resolution = ADC_RESOLUTION_16BIT;
		break;
	case ADC_RESOLUTION_15BIT:
		/* Increase resolution by 3 bit */
		adjres = ADC_DIVIDE_RESULT_2;
		accumulate = ADC_ACCUMULATE_SAMPLES_64;
    46fe:	2006      	movs	r0, #6
		/* 16-bit result register */
		resolution = ADC_RESOLUTION_16BIT;
    4700:	2110      	movs	r1, #16
		/* 16-bit result register */
		resolution = ADC_RESOLUTION_16BIT;
		break;
	case ADC_RESOLUTION_15BIT:
		/* Increase resolution by 3 bit */
		adjres = ADC_DIVIDE_RESULT_2;
    4702:	2201      	movs	r2, #1
    4704:	e012      	b.n	472c <adc_init+0x18c>
		break;

	case ADC_RESOLUTION_16BIT:
		/* Increase resolution by 4 bit */
		adjres = ADC_DIVIDE_RESULT_DISABLE;
		accumulate = ADC_ACCUMULATE_SAMPLES_256;
    4706:	2008      	movs	r0, #8
		/* 16-bit result register */
		resolution = ADC_RESOLUTION_16BIT;
    4708:	2110      	movs	r1, #16
		resolution = ADC_RESOLUTION_16BIT;
		break;

	case ADC_RESOLUTION_16BIT:
		/* Increase resolution by 4 bit */
		adjres = ADC_DIVIDE_RESULT_DISABLE;
    470a:	2200      	movs	r2, #0
    470c:	e00e      	b.n	472c <adc_init+0x18c>
		struct adc_module *const module_inst,
		struct adc_config *const config)
{
	uint8_t adjres = 0;
	uint32_t resolution = ADC_RESOLUTION_16BIT;
	enum adc_accumulate_samples accumulate = ADC_ACCUMULATE_DISABLE;
    470e:	2000      	movs	r0, #0
		/* 16-bit result register */
		resolution = ADC_RESOLUTION_16BIT;
		break;
	case ADC_RESOLUTION_8BIT:
		/* 8-bit result register */
		resolution = ADC_RESOLUTION_8BIT;
    4710:	2130      	movs	r1, #48	; 0x30
static enum status_code _adc_set_config(
		uint8_t index,
		struct adc_module *const module_inst,
		struct adc_config *const config)
{
	uint8_t adjres = 0;
    4712:	2200      	movs	r2, #0
    4714:	e00a      	b.n	472c <adc_init+0x18c>
	uint32_t resolution = ADC_RESOLUTION_16BIT;
	enum adc_accumulate_samples accumulate = ADC_ACCUMULATE_DISABLE;
    4716:	2000      	movs	r0, #0
		/* 8-bit result register */
		resolution = ADC_RESOLUTION_8BIT;
		break;
	case ADC_RESOLUTION_10BIT:
		/* 10-bit result register */
		resolution = ADC_RESOLUTION_10BIT;
    4718:	2120      	movs	r1, #32
static enum status_code _adc_set_config(
		uint8_t index,
		struct adc_module *const module_inst,
		struct adc_config *const config)
{
	uint8_t adjres = 0;
    471a:	2200      	movs	r2, #0
    471c:	e006      	b.n	472c <adc_init+0x18c>
	uint32_t resolution = ADC_RESOLUTION_16BIT;
	enum adc_accumulate_samples accumulate = ADC_ACCUMULATE_DISABLE;
    471e:	2000      	movs	r0, #0
		/* 10-bit result register */
		resolution = ADC_RESOLUTION_10BIT;
		break;
	case ADC_RESOLUTION_12BIT:
		/* 12-bit result register */
		resolution = ADC_RESOLUTION_12BIT;
    4720:	2100      	movs	r1, #0
static enum status_code _adc_set_config(
		uint8_t index,
		struct adc_module *const module_inst,
		struct adc_config *const config)
{
	uint8_t adjres = 0;
    4722:	2200      	movs	r2, #0
    4724:	e002      	b.n	472c <adc_init+0x18c>
		break;

	case ADC_RESOLUTION_13BIT:
		/* Increase resolution by 1 bit */
		adjres = ADC_DIVIDE_RESULT_2;
		accumulate = ADC_ACCUMULATE_SAMPLES_4;
    4726:	2002      	movs	r0, #2
		/* 16-bit result register */
		resolution = ADC_RESOLUTION_16BIT;
    4728:	2110      	movs	r1, #16
		resolution = ADC_RESOLUTION_16BIT;
		break;

	case ADC_RESOLUTION_13BIT:
		/* Increase resolution by 1 bit */
		adjres = ADC_DIVIDE_RESULT_2;
    472a:	2201      	movs	r2, #1
	default:
		/* Unknown. Abort. */
		return STATUS_ERR_INVALID_ARG;
	}

	adc_module->AVGCTRL.reg = ADC_AVGCTRL_ADJRES(adjres) | accumulate;
    472c:	0112      	lsls	r2, r2, #4
    472e:	2370      	movs	r3, #112	; 0x70
    4730:	4013      	ands	r3, r2
    4732:	4303      	orrs	r3, r0
    4734:	733b      	strb	r3, [r7, #12]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    4736:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    4738:	8c13      	ldrh	r3, [r2, #32]
    473a:	b29b      	uxth	r3, r3

	while (adc_is_syncing(module_inst)) {
    473c:	2b00      	cmp	r3, #0
    473e:	d1fb      	bne.n	4738 <adc_init+0x198>
		/* Wait for synchronization */
	}

	/* Check validity of sample length value */
	if (config->sample_length > 63) {
    4740:	7d72      	ldrb	r2, [r6, #21]
		return STATUS_ERR_INVALID_ARG;
    4742:	3317      	adds	r3, #23
	while (adc_is_syncing(module_inst)) {
		/* Wait for synchronization */
	}

	/* Check validity of sample length value */
	if (config->sample_length > 63) {
    4744:	2a3f      	cmp	r2, #63	; 0x3f
    4746:	d900      	bls.n	474a <adc_init+0x1aa>
    4748:	e109      	b.n	495e <adc_init+0x3be>
		return STATUS_ERR_INVALID_ARG;
	} else {
		/* Configure sample length */
		adc_module->SAMPCTRL.reg =
    474a:	7bf3      	ldrb	r3, [r6, #15]
    474c:	01db      	lsls	r3, r3, #7
    474e:	431a      	orrs	r2, r3
    4750:	b2d2      	uxtb	r2, r2
    4752:	737a      	strb	r2, [r7, #13]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    4754:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    4756:	8c13      	ldrh	r3, [r2, #32]
    4758:	b29b      	uxth	r3, r3
				(config->sample_length << ADC_SAMPCTRL_SAMPLEN_Pos)
				| (config->sampling_time_compensation_enable << ADC_SAMPCTRL_OFFCOMP_Pos);
	}

	while (adc_is_syncing(module_inst)) {
    475a:	2b00      	cmp	r3, #0
    475c:	d1fb      	bne.n	4756 <adc_init+0x1b6>
		/* Wait for synchronization */
	}

	/* Configure CTRLB */
	adc_module->CTRLB.reg =
			config->clock_prescaler;
    475e:	78b3      	ldrb	r3, [r6, #2]
	while (adc_is_syncing(module_inst)) {
		/* Wait for synchronization */
	}

	/* Configure CTRLB */
	adc_module->CTRLB.reg =
    4760:	707b      	strb	r3, [r7, #1]
			config->clock_prescaler;
	adc_module->CTRLC.reg =
			resolution |
			(config->correction.correction_enable << ADC_CTRLC_CORREN_Pos) |
    4762:	2324      	movs	r3, #36	; 0x24
	}

	/* Configure CTRLB */
	adc_module->CTRLB.reg =
			config->clock_prescaler;
	adc_module->CTRLC.reg =
    4764:	5cf2      	ldrb	r2, [r6, r3]
    4766:	00d2      	lsls	r2, r2, #3
    4768:	7b33      	ldrb	r3, [r6, #12]
    476a:	009b      	lsls	r3, r3, #2
    476c:	4313      	orrs	r3, r2
    476e:	7af2      	ldrb	r2, [r6, #11]
    4770:	431a      	orrs	r2, r3
    4772:	7ab3      	ldrb	r3, [r6, #10]
    4774:	005b      	lsls	r3, r3, #1
    4776:	4313      	orrs	r3, r2
    4778:	430b      	orrs	r3, r1
    477a:	817b      	strh	r3, [r7, #10]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    477c:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    477e:	8c13      	ldrh	r3, [r2, #32]
    4780:	b29b      	uxth	r3, r3
			(config->correction.correction_enable << ADC_CTRLC_CORREN_Pos) |
			(config->freerunning << ADC_CTRLC_FREERUN_Pos) |
			(config->left_adjust << ADC_CTRLC_LEFTADJ_Pos) |
			(config->differential_mode << ADC_CTRLC_DIFFMODE_Pos);

	while (adc_is_syncing(module_inst)) {
    4782:	2b00      	cmp	r3, #0
    4784:	d1fb      	bne.n	477e <adc_init+0x1de>
		/* Wait for synchronization */
	}

	/* Check validity of window thresholds */
	if (config->window.window_mode != ADC_WINDOW_MODE_DISABLE) {
    4786:	8b32      	ldrh	r2, [r6, #24]
    4788:	2a00      	cmp	r2, #0
    478a:	d100      	bne.n	478e <adc_init+0x1ee>
    478c:	e098      	b.n	48c0 <adc_init+0x320>
		switch (resolution) {
    478e:	2910      	cmp	r1, #16
    4790:	d07a      	beq.n	4888 <adc_init+0x2e8>
    4792:	d802      	bhi.n	479a <adc_init+0x1fa>
    4794:	2900      	cmp	r1, #0
    4796:	d03e      	beq.n	4816 <adc_init+0x276>
    4798:	e092      	b.n	48c0 <adc_init+0x320>
    479a:	2920      	cmp	r1, #32
    479c:	d01a      	beq.n	47d4 <adc_init+0x234>
    479e:	2930      	cmp	r1, #48	; 0x30
    47a0:	d000      	beq.n	47a4 <adc_init+0x204>
    47a2:	e08d      	b.n	48c0 <adc_init+0x320>
		case ADC_RESOLUTION_8BIT:
			if (config->differential_mode &&
    47a4:	7af3      	ldrb	r3, [r6, #11]
    47a6:	2b00      	cmp	r3, #0
    47a8:	d00a      	beq.n	47c0 <adc_init+0x220>
    47aa:	69f1      	ldr	r1, [r6, #28]
    47ac:	3180      	adds	r1, #128	; 0x80
					(config->window.window_lower_value > 127 ||
					config->window.window_lower_value < -128 ||
					config->window.window_upper_value > 127 ||
					config->window.window_upper_value < -128)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    47ae:	2317      	movs	r3, #23

	/* Check validity of window thresholds */
	if (config->window.window_mode != ADC_WINDOW_MODE_DISABLE) {
		switch (resolution) {
		case ADC_RESOLUTION_8BIT:
			if (config->differential_mode &&
    47b0:	29ff      	cmp	r1, #255	; 0xff
    47b2:	d900      	bls.n	47b6 <adc_init+0x216>
    47b4:	e0d3      	b.n	495e <adc_init+0x3be>
					(config->window.window_lower_value > 127 ||
					config->window.window_lower_value < -128 ||
    47b6:	6a31      	ldr	r1, [r6, #32]
    47b8:	3180      	adds	r1, #128	; 0x80
    47ba:	29ff      	cmp	r1, #255	; 0xff
    47bc:	d900      	bls.n	47c0 <adc_init+0x220>
    47be:	e0ce      	b.n	495e <adc_init+0x3be>
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 255 ||
					config->window.window_upper_value > 255){
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    47c0:	2317      	movs	r3, #23
					config->window.window_lower_value < -128 ||
					config->window.window_upper_value > 127 ||
					config->window.window_upper_value < -128)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 255 ||
    47c2:	69f1      	ldr	r1, [r6, #28]
    47c4:	29ff      	cmp	r1, #255	; 0xff
    47c6:	dd00      	ble.n	47ca <adc_init+0x22a>
    47c8:	e0c9      	b.n	495e <adc_init+0x3be>
    47ca:	6a31      	ldr	r1, [r6, #32]
    47cc:	29ff      	cmp	r1, #255	; 0xff
    47ce:	dd00      	ble.n	47d2 <adc_init+0x232>
    47d0:	e0c5      	b.n	495e <adc_init+0x3be>
    47d2:	e075      	b.n	48c0 <adc_init+0x320>
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			}
			break;
		case ADC_RESOLUTION_10BIT:
			if (config->differential_mode &&
    47d4:	7af3      	ldrb	r3, [r6, #11]
    47d6:	2b00      	cmp	r3, #0
    47d8:	d012      	beq.n	4800 <adc_init+0x260>
    47da:	69f3      	ldr	r3, [r6, #28]
    47dc:	2080      	movs	r0, #128	; 0x80
    47de:	0080      	lsls	r0, r0, #2
    47e0:	4684      	mov	ip, r0
    47e2:	4463      	add	r3, ip
    47e4:	0019      	movs	r1, r3
					(config->window.window_lower_value > 511 ||
					config->window.window_lower_value < -512 ||
					config->window.window_upper_value > 511 ||
					config->window.window_upper_value < -512)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    47e6:	2317      	movs	r3, #23
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			}
			break;
		case ADC_RESOLUTION_10BIT:
			if (config->differential_mode &&
    47e8:	4825      	ldr	r0, [pc, #148]	; (4880 <adc_init+0x2e0>)
    47ea:	4281      	cmp	r1, r0
    47ec:	d900      	bls.n	47f0 <adc_init+0x250>
    47ee:	e0b6      	b.n	495e <adc_init+0x3be>
					(config->window.window_lower_value > 511 ||
					config->window.window_lower_value < -512 ||
    47f0:	6a33      	ldr	r3, [r6, #32]
    47f2:	4463      	add	r3, ip
    47f4:	0019      	movs	r1, r3
					config->window.window_upper_value > 511 ||
					config->window.window_upper_value < -512)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    47f6:	2317      	movs	r3, #23
			}
			break;
		case ADC_RESOLUTION_10BIT:
			if (config->differential_mode &&
					(config->window.window_lower_value > 511 ||
					config->window.window_lower_value < -512 ||
    47f8:	4821      	ldr	r0, [pc, #132]	; (4880 <adc_init+0x2e0>)
    47fa:	4281      	cmp	r1, r0
    47fc:	d900      	bls.n	4800 <adc_init+0x260>
    47fe:	e0ae      	b.n	495e <adc_init+0x3be>
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 1023 ||
					config->window.window_upper_value > 1023){
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    4800:	2317      	movs	r3, #23
					config->window.window_lower_value < -512 ||
					config->window.window_upper_value > 511 ||
					config->window.window_upper_value < -512)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 1023 ||
    4802:	491f      	ldr	r1, [pc, #124]	; (4880 <adc_init+0x2e0>)
    4804:	69f0      	ldr	r0, [r6, #28]
    4806:	4288      	cmp	r0, r1
    4808:	dd00      	ble.n	480c <adc_init+0x26c>
    480a:	e0a8      	b.n	495e <adc_init+0x3be>
    480c:	6a30      	ldr	r0, [r6, #32]
    480e:	4288      	cmp	r0, r1
    4810:	dd00      	ble.n	4814 <adc_init+0x274>
    4812:	e0a4      	b.n	495e <adc_init+0x3be>
    4814:	e054      	b.n	48c0 <adc_init+0x320>
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			}
			break;
		case ADC_RESOLUTION_12BIT:
			if (config->differential_mode &&
    4816:	7af3      	ldrb	r3, [r6, #11]
    4818:	2b00      	cmp	r3, #0
    481a:	d012      	beq.n	4842 <adc_init+0x2a2>
    481c:	69f3      	ldr	r3, [r6, #28]
    481e:	2080      	movs	r0, #128	; 0x80
    4820:	0100      	lsls	r0, r0, #4
    4822:	4684      	mov	ip, r0
    4824:	4463      	add	r3, ip
    4826:	0019      	movs	r1, r3
					(config->window.window_lower_value > 2047 ||
					config->window.window_lower_value < -2048 ||
					config->window.window_upper_value > 2047 ||
					config->window.window_upper_value < -2048)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    4828:	2317      	movs	r3, #23
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			}
			break;
		case ADC_RESOLUTION_12BIT:
			if (config->differential_mode &&
    482a:	4816      	ldr	r0, [pc, #88]	; (4884 <adc_init+0x2e4>)
    482c:	4281      	cmp	r1, r0
    482e:	d900      	bls.n	4832 <adc_init+0x292>
    4830:	e095      	b.n	495e <adc_init+0x3be>
					(config->window.window_lower_value > 2047 ||
					config->window.window_lower_value < -2048 ||
    4832:	6a33      	ldr	r3, [r6, #32]
    4834:	4463      	add	r3, ip
    4836:	0019      	movs	r1, r3
					config->window.window_upper_value > 2047 ||
					config->window.window_upper_value < -2048)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    4838:	2317      	movs	r3, #23
			}
			break;
		case ADC_RESOLUTION_12BIT:
			if (config->differential_mode &&
					(config->window.window_lower_value > 2047 ||
					config->window.window_lower_value < -2048 ||
    483a:	4812      	ldr	r0, [pc, #72]	; (4884 <adc_init+0x2e4>)
    483c:	4281      	cmp	r1, r0
    483e:	d900      	bls.n	4842 <adc_init+0x2a2>
    4840:	e08d      	b.n	495e <adc_init+0x3be>
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 4095 ||
					config->window.window_upper_value > 4095){
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    4842:	2317      	movs	r3, #23
					config->window.window_lower_value < -2048 ||
					config->window.window_upper_value > 2047 ||
					config->window.window_upper_value < -2048)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 4095 ||
    4844:	490f      	ldr	r1, [pc, #60]	; (4884 <adc_init+0x2e4>)
    4846:	69f0      	ldr	r0, [r6, #28]
    4848:	4288      	cmp	r0, r1
    484a:	dd00      	ble.n	484e <adc_init+0x2ae>
    484c:	e087      	b.n	495e <adc_init+0x3be>
    484e:	6a30      	ldr	r0, [r6, #32]
    4850:	4288      	cmp	r0, r1
    4852:	dd00      	ble.n	4856 <adc_init+0x2b6>
    4854:	e083      	b.n	495e <adc_init+0x3be>
    4856:	e033      	b.n	48c0 <adc_init+0x320>
    4858:	00004559 	.word	0x00004559
    485c:	40000400 	.word	0x40000400
    4860:	40001400 	.word	0x40001400
    4864:	20000fa4 	.word	0x20000fa4
    4868:	00007715 	.word	0x00007715
    486c:	000076a5 	.word	0x000076a5
    4870:	000132b8 	.word	0x000132b8
    4874:	0000a74d 	.word	0x0000a74d
    4878:	00007811 	.word	0x00007811
    487c:	000131e4 	.word	0x000131e4
    4880:	000003ff 	.word	0x000003ff
    4884:	00000fff 	.word	0x00000fff
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			}
			break;
		case ADC_RESOLUTION_16BIT:
			if (config->differential_mode &&
    4888:	7af3      	ldrb	r3, [r6, #11]
    488a:	2b00      	cmp	r3, #0
    488c:	d010      	beq.n	48b0 <adc_init+0x310>
    488e:	69f3      	ldr	r3, [r6, #28]
    4890:	2080      	movs	r0, #128	; 0x80
    4892:	0200      	lsls	r0, r0, #8
    4894:	4684      	mov	ip, r0
    4896:	4463      	add	r3, ip
    4898:	0019      	movs	r1, r3
					(config->window.window_lower_value > 32767 ||
					config->window.window_lower_value < -32768 ||
					config->window.window_upper_value > 32767 ||
					config->window.window_upper_value < -32768)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    489a:	2317      	movs	r3, #23
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			}
			break;
		case ADC_RESOLUTION_16BIT:
			if (config->differential_mode &&
    489c:	4832      	ldr	r0, [pc, #200]	; (4968 <adc_init+0x3c8>)
    489e:	4281      	cmp	r1, r0
    48a0:	d85d      	bhi.n	495e <adc_init+0x3be>
					(config->window.window_lower_value > 32767 ||
					config->window.window_lower_value < -32768 ||
    48a2:	6a33      	ldr	r3, [r6, #32]
    48a4:	4463      	add	r3, ip
    48a6:	0019      	movs	r1, r3
					config->window.window_upper_value > 32767 ||
					config->window.window_upper_value < -32768)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    48a8:	2317      	movs	r3, #23
			}
			break;
		case ADC_RESOLUTION_16BIT:
			if (config->differential_mode &&
					(config->window.window_lower_value > 32767 ||
					config->window.window_lower_value < -32768 ||
    48aa:	482f      	ldr	r0, [pc, #188]	; (4968 <adc_init+0x3c8>)
    48ac:	4281      	cmp	r1, r0
    48ae:	d856      	bhi.n	495e <adc_init+0x3be>
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 65535 ||
					config->window.window_upper_value > 65535){
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
    48b0:	2317      	movs	r3, #23
					config->window.window_lower_value < -32768 ||
					config->window.window_upper_value > 32767 ||
					config->window.window_upper_value < -32768)) {
				/* Invalid value */
				return STATUS_ERR_INVALID_ARG;
			} else if (config->window.window_lower_value > 65535 ||
    48b2:	492d      	ldr	r1, [pc, #180]	; (4968 <adc_init+0x3c8>)
    48b4:	69f0      	ldr	r0, [r6, #28]
    48b6:	4288      	cmp	r0, r1
    48b8:	dc51      	bgt.n	495e <adc_init+0x3be>
    48ba:	6a30      	ldr	r0, [r6, #32]
    48bc:	4288      	cmp	r0, r1
    48be:	dc4e      	bgt.n	495e <adc_init+0x3be>
			break;
		}
	}

	/* Configure window mode */
	adc_module->CTRLC.reg |= config->window.window_mode;
    48c0:	897b      	ldrh	r3, [r7, #10]
    48c2:	431a      	orrs	r2, r3
    48c4:	817a      	strh	r2, [r7, #10]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    48c6:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    48c8:	8c13      	ldrh	r3, [r2, #32]
    48ca:	b29b      	uxth	r3, r3

	while (adc_is_syncing(module_inst)) {
    48cc:	2b00      	cmp	r3, #0
    48ce:	d1fb      	bne.n	48c8 <adc_init+0x328>
		/* Wait for synchronization */
	}

	/* Configure lower threshold */
	adc_module->WINLT.reg =
    48d0:	8bb3      	ldrh	r3, [r6, #28]
    48d2:	81fb      	strh	r3, [r7, #14]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    48d4:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    48d6:	8c13      	ldrh	r3, [r2, #32]
    48d8:	b29b      	uxth	r3, r3
			config->window.window_lower_value << ADC_WINLT_WINLT_Pos;

	while (adc_is_syncing(module_inst)) {
    48da:	2b00      	cmp	r3, #0
    48dc:	d1fb      	bne.n	48d6 <adc_init+0x336>
		/* Wait for synchronization */
	}

	/* Configure lower threshold */
	adc_module->WINUT.reg = config->window.window_upper_value <<
    48de:	8c33      	ldrh	r3, [r6, #32]
    48e0:	823b      	strh	r3, [r7, #16]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    48e2:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    48e4:	8c13      	ldrh	r3, [r2, #32]
    48e6:	b29b      	uxth	r3, r3
			ADC_WINUT_WINUT_Pos;

	while (adc_is_syncing(module_inst)) {
    48e8:	2b00      	cmp	r3, #0
    48ea:	d1fb      	bne.n	48e4 <adc_init+0x344>
		/* Wait for synchronization */
	}

	/* Configure pin scan mode and positive and negative input pins */
	adc_module->INPUTCTRL.reg =
    48ec:	7932      	ldrb	r2, [r6, #4]
    48ee:	88f3      	ldrh	r3, [r6, #6]
    48f0:	4313      	orrs	r3, r2
    48f2:	813b      	strh	r3, [r7, #8]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    48f4:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    48f6:	8c13      	ldrh	r3, [r2, #32]
    48f8:	b29b      	uxth	r3, r3
			config->negative_input |
			config->positive_input;

	while (adc_is_syncing(module_inst)) {
    48fa:	2b00      	cmp	r3, #0
    48fc:	d1fb      	bne.n	48f6 <adc_init+0x356>
		/* Wait for synchronization */
	}

	/* Configure events */
	adc_module->EVCTRL.reg = config->event_action;
    48fe:	332a      	adds	r3, #42	; 0x2a
    4900:	5cf3      	ldrb	r3, [r6, r3]
    4902:	70fb      	strb	r3, [r7, #3]

	/* Disable all interrupts */
	adc_module->INTENCLR.reg =
    4904:	2307      	movs	r3, #7
    4906:	713b      	strb	r3, [r7, #4]
			(1 << ADC_INTENCLR_WINMON_Pos) |(1 << ADC_INTENCLR_OVERRUN_Pos)
			| (1 << ADC_INTENCLR_RESRDY_Pos);

	if (config->correction.correction_enable){
    4908:	331d      	adds	r3, #29
    490a:	5cf3      	ldrb	r3, [r6, r3]
    490c:	2b00      	cmp	r3, #0
    490e:	d019      	beq.n	4944 <adc_init+0x3a4>
		/* Make sure gain_correction value is valid */
		if (config->correction.gain_correction > ADC_GAINCORR_GAINCORR_Msk) {
    4910:	8cf2      	ldrh	r2, [r6, #38]	; 0x26
			return STATUS_ERR_INVALID_ARG;
    4912:	2317      	movs	r3, #23
			(1 << ADC_INTENCLR_WINMON_Pos) |(1 << ADC_INTENCLR_OVERRUN_Pos)
			| (1 << ADC_INTENCLR_RESRDY_Pos);

	if (config->correction.correction_enable){
		/* Make sure gain_correction value is valid */
		if (config->correction.gain_correction > ADC_GAINCORR_GAINCORR_Msk) {
    4914:	4915      	ldr	r1, [pc, #84]	; (496c <adc_init+0x3cc>)
    4916:	428a      	cmp	r2, r1
    4918:	d821      	bhi.n	495e <adc_init+0x3be>
			return STATUS_ERR_INVALID_ARG;
		} else {
			/* Set gain correction value */
			adc_module->GAINCORR.reg = config->correction.gain_correction <<
    491a:	827a      	strh	r2, [r7, #18]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    491c:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    491e:	8c13      	ldrh	r3, [r2, #32]
    4920:	b29b      	uxth	r3, r3
					ADC_GAINCORR_GAINCORR_Pos;
		}

		while (adc_is_syncing(module_inst)) {
    4922:	2b00      	cmp	r3, #0
    4924:	d1fb      	bne.n	491e <adc_init+0x37e>
			/* Wait for synchronization */
		}

		/* Make sure offset correction value is valid */
		if (config->correction.offset_correction > 2047 ||
    4926:	8d31      	ldrh	r1, [r6, #40]	; 0x28
    4928:	2380      	movs	r3, #128	; 0x80
    492a:	011b      	lsls	r3, r3, #4
    492c:	18ca      	adds	r2, r1, r3
    492e:	b292      	uxth	r2, r2
				config->correction.offset_correction < -2048) {
			return STATUS_ERR_INVALID_ARG;
    4930:	2317      	movs	r3, #23
		while (adc_is_syncing(module_inst)) {
			/* Wait for synchronization */
		}

		/* Make sure offset correction value is valid */
		if (config->correction.offset_correction > 2047 ||
    4932:	480e      	ldr	r0, [pc, #56]	; (496c <adc_init+0x3cc>)
    4934:	4282      	cmp	r2, r0
    4936:	d812      	bhi.n	495e <adc_init+0x3be>
				config->correction.offset_correction < -2048) {
			return STATUS_ERR_INVALID_ARG;
		} else {
			/* Set offset correction value */
			adc_module->OFFSETCORR.reg = config->correction.offset_correction <<
    4938:	82b9      	strh	r1, [r7, #20]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    493a:	682a      	ldr	r2, [r5, #0]

	if (adc_module->SYNCBUSY.reg) {
    493c:	8c13      	ldrh	r3, [r2, #32]
    493e:	b29b      	uxth	r3, r3
					ADC_OFFSETCORR_OFFSETCORR_Pos;
		}

		while (adc_is_syncing(module_inst)) {
    4940:	2b00      	cmp	r3, #0
    4942:	d1fb      	bne.n	493c <adc_init+0x39c>
		}
	}

	/* Load in the fixed device ADC calibration constants */
	adc_module->CALIB.reg =
			ADC_CALIB_BIASREFBUF(
    4944:	4b0a      	ldr	r3, [pc, #40]	; (4970 <adc_init+0x3d0>)
    4946:	681b      	ldr	r3, [r3, #0]
			/* Wait for synchronization */
		}
	}

	/* Load in the fixed device ADC calibration constants */
	adc_module->CALIB.reg =
    4948:	0219      	lsls	r1, r3, #8
    494a:	22e0      	movs	r2, #224	; 0xe0
    494c:	00d2      	lsls	r2, r2, #3
    494e:	400a      	ands	r2, r1
    4950:	069b      	lsls	r3, r3, #26
    4952:	0f5b      	lsrs	r3, r3, #29
    4954:	4313      	orrs	r3, r2
    4956:	85bb      	strh	r3, [r7, #44]	; 0x2c
			) |
			ADC_CALIB_BIASCOMP(
				(*(uint32_t *)_adc_biascomp_addr[index] >> _adc_biascomp_pos[index])
			);

	return STATUS_OK;
    4958:	2300      	movs	r3, #0
    495a:	e000      	b.n	495e <adc_init+0x3be>
		resolution = ADC_RESOLUTION_12BIT;
		break;

	default:
		/* Unknown. Abort. */
		return STATUS_ERR_INVALID_ARG;
    495c:	2317      	movs	r3, #23
	}
#endif

	/* Write configuration to module */
	return _adc_set_config(instance, module_inst, config);
}
    495e:	0018      	movs	r0, r3
    4960:	b01a      	add	sp, #104	; 0x68
    4962:	bc04      	pop	{r2}
    4964:	4691      	mov	r9, r2
    4966:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4968:	0000ffff 	.word	0x0000ffff
    496c:	00000fff 	.word	0x00000fff
    4970:	00806020 	.word	0x00806020

00004974 <ADC_Handler>:
		}

	MREPEAT(ADC_INST_NUM, _ADC_INTERRUPT_HANDLER, 0)
#else
void ADC_Handler(void)
{
    4974:	b570      	push	{r4, r5, r6, lr}

struct adc_module *_adc_instances[ADC_INST_NUM];

static void _adc_interrupt_handler(const uint8_t instance)
{
	struct adc_module *module = _adc_instances[instance];
    4976:	4b2d      	ldr	r3, [pc, #180]	; (4a2c <ADC_Handler+0xb8>)
    4978:	681c      	ldr	r4, [r3, #0]

	/* get interrupt flags and mask out enabled callbacks */
	uint32_t flags = module->hw->INTFLAG.reg;
    497a:	6823      	ldr	r3, [r4, #0]
    497c:	799d      	ldrb	r5, [r3, #6]
    497e:	b2ed      	uxtb	r5, r5

	if (flags & ADC_INTFLAG_RESRDY) {
    4980:	07ea      	lsls	r2, r5, #31
    4982:	d535      	bpl.n	49f0 <ADC_Handler+0x7c>
		if ((module->enabled_callback_mask & (1 << ADC_CALLBACK_READ_BUFFER)) &&
    4984:	7ee2      	ldrb	r2, [r4, #27]
    4986:	07d2      	lsls	r2, r2, #31
    4988:	d532      	bpl.n	49f0 <ADC_Handler+0x7c>
    498a:	7ea2      	ldrb	r2, [r4, #26]
    498c:	07d2      	lsls	r2, r2, #31
    498e:	d52f      	bpl.n	49f0 <ADC_Handler+0x7c>
				(module->registered_callback_mask & (1 << ADC_CALLBACK_READ_BUFFER))) {
			/* clear interrupt flag */
			module->hw->INTFLAG.reg = ADC_INTFLAG_RESRDY;
    4990:	2201      	movs	r2, #1
    4992:	719a      	strb	r2, [r3, #6]

			/* store ADC result in job buffer */
			*(module->job_buffer++) = module->hw->RESULT.reg;
    4994:	6962      	ldr	r2, [r4, #20]
    4996:	1c93      	adds	r3, r2, #2
    4998:	6163      	str	r3, [r4, #20]
    499a:	6823      	ldr	r3, [r4, #0]
    499c:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    499e:	b29b      	uxth	r3, r3
    49a0:	8013      	strh	r3, [r2, #0]

			if (--module->remaining_conversions > 0) {
    49a2:	8b23      	ldrh	r3, [r4, #24]
    49a4:	3b01      	subs	r3, #1
    49a6:	b29b      	uxth	r3, r3
    49a8:	8323      	strh	r3, [r4, #24]
    49aa:	2b00      	cmp	r3, #0
    49ac:	d015      	beq.n	49da <ADC_Handler+0x66>
				if (module->software_trigger == true
    49ae:	7f63      	ldrb	r3, [r4, #29]
    49b0:	2b00      	cmp	r3, #0
    49b2:	d01d      	beq.n	49f0 <ADC_Handler+0x7c>
					&& (!(module->hw->SEQSTATUS.reg & ADC_SEQSTATUS_SEQBUSY))) {
    49b4:	6822      	ldr	r2, [r4, #0]
    49b6:	79d3      	ldrb	r3, [r2, #7]
    49b8:	b25b      	sxtb	r3, r3
    49ba:	2b00      	cmp	r3, #0
    49bc:	db18      	blt.n	49f0 <ADC_Handler+0x7c>
    49be:	8c13      	ldrh	r3, [r2, #32]
    49c0:	b29b      	uxth	r3, r3
	Assert(module_inst);
	Assert(module_inst->hw);

	Adc *const adc_module = module_inst->hw;

	while (adc_is_syncing(module_inst)) {
    49c2:	2b00      	cmp	r3, #0
    49c4:	d1fb      	bne.n	49be <ADC_Handler+0x4a>
		/* Wait for synchronization */
	}

	adc_module->SWTRIG.reg |= ADC_SWTRIG_START;
    49c6:	7e11      	ldrb	r1, [r2, #24]
    49c8:	3302      	adds	r3, #2
    49ca:	430b      	orrs	r3, r1
    49cc:	7613      	strb	r3, [r2, #24]
	struct adc_module *const module_inst)
{
	/* Sanity check arguments */
	Assert(module_inst);

	Adc *const adc_module = module_inst->hw;
    49ce:	6822      	ldr	r2, [r4, #0]

	if (adc_module->SYNCBUSY.reg) {
    49d0:	8c13      	ldrh	r3, [r2, #32]
    49d2:	b29b      	uxth	r3, r3

	while (adc_is_syncing(module_inst)) {
    49d4:	2b00      	cmp	r3, #0
    49d6:	d1fb      	bne.n	49d0 <ADC_Handler+0x5c>
    49d8:	e00a      	b.n	49f0 <ADC_Handler+0x7c>
					adc_start_conversion(module);
				}
			} else {
				if (module->job_status == STATUS_BUSY) {
    49da:	7f23      	ldrb	r3, [r4, #28]
    49dc:	2b05      	cmp	r3, #5
    49de:	d107      	bne.n	49f0 <ADC_Handler+0x7c>
					/* job is complete. update status,disable interrupt
					 *and call callback */
					module->job_status = STATUS_OK;
    49e0:	2300      	movs	r3, #0
    49e2:	7723      	strb	r3, [r4, #28]
	Assert(module_inst);
	Assert(module_inst->hw);

	Adc *const adc_module = module_inst->hw;
	/* Enable interrupt */
	adc_module->INTENCLR.reg = interrupt;
    49e4:	3301      	adds	r3, #1
    49e6:	6822      	ldr	r2, [r4, #0]
    49e8:	7113      	strb	r3, [r2, #4]
					adc_disable_interrupt(module, ADC_INTERRUPT_RESULT_READY);
					(module->callback[ADC_CALLBACK_READ_BUFFER])(module);
    49ea:	0020      	movs	r0, r4
    49ec:	68a3      	ldr	r3, [r4, #8]
    49ee:	4798      	blx	r3
				}
			}
		}
	}

	if (flags & ADC_INTFLAG_WINMON) {
    49f0:	076b      	lsls	r3, r5, #29
    49f2:	d50b      	bpl.n	4a0c <ADC_Handler+0x98>
		module->hw->INTFLAG.reg = ADC_INTFLAG_WINMON;
    49f4:	2304      	movs	r3, #4
    49f6:	6822      	ldr	r2, [r4, #0]
    49f8:	7193      	strb	r3, [r2, #6]
		if ((module->enabled_callback_mask & (1 << ADC_CALLBACK_WINDOW)) &&
    49fa:	7ee3      	ldrb	r3, [r4, #27]
    49fc:	079b      	lsls	r3, r3, #30
    49fe:	d505      	bpl.n	4a0c <ADC_Handler+0x98>
    4a00:	7ea3      	ldrb	r3, [r4, #26]
    4a02:	079b      	lsls	r3, r3, #30
    4a04:	d502      	bpl.n	4a0c <ADC_Handler+0x98>
				(module->registered_callback_mask & (1 << ADC_CALLBACK_WINDOW))) {
			(module->callback[ADC_CALLBACK_WINDOW])(module);
    4a06:	0020      	movs	r0, r4
    4a08:	68e3      	ldr	r3, [r4, #12]
    4a0a:	4798      	blx	r3
		}

	}

	if (flags & ADC_INTFLAG_OVERRUN) {
    4a0c:	07ab      	lsls	r3, r5, #30
    4a0e:	d50b      	bpl.n	4a28 <ADC_Handler+0xb4>
		module->hw->INTFLAG.reg = ADC_INTFLAG_OVERRUN;
    4a10:	2302      	movs	r3, #2
    4a12:	6822      	ldr	r2, [r4, #0]
    4a14:	7193      	strb	r3, [r2, #6]
		if ((module->enabled_callback_mask & (1 << ADC_CALLBACK_ERROR)) &&
    4a16:	7ee3      	ldrb	r3, [r4, #27]
    4a18:	075b      	lsls	r3, r3, #29
    4a1a:	d505      	bpl.n	4a28 <ADC_Handler+0xb4>
    4a1c:	7ea3      	ldrb	r3, [r4, #26]
    4a1e:	075b      	lsls	r3, r3, #29
    4a20:	d502      	bpl.n	4a28 <ADC_Handler+0xb4>
				(module->registered_callback_mask & (1 << ADC_CALLBACK_ERROR))) {
			(module->callback[ADC_CALLBACK_ERROR])(module);
    4a22:	6923      	ldr	r3, [r4, #16]
    4a24:	0020      	movs	r0, r4
    4a26:	4798      	blx	r3
	MREPEAT(ADC_INST_NUM, _ADC_INTERRUPT_HANDLER, 0)
#else
void ADC_Handler(void)
{
	_adc_interrupt_handler(0);
}
    4a28:	bd70      	pop	{r4, r5, r6, pc}
    4a2a:	46c0      	nop			; (mov r8, r8)
    4a2c:	20000fa4 	.word	0x20000fa4

00004a30 <adc_register_callback>:
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
    4a30:	1c93      	adds	r3, r2, #2
    4a32:	009b      	lsls	r3, r3, #2
    4a34:	5019      	str	r1, [r3, r0]

	/* Set the bit corresponding to the callback_type */
	module->registered_callback_mask |= (1 << callback_type);
    4a36:	2301      	movs	r3, #1
    4a38:	4093      	lsls	r3, r2
    4a3a:	7e82      	ldrb	r2, [r0, #26]
    4a3c:	4313      	orrs	r3, r2
    4a3e:	7683      	strb	r3, [r0, #26]
}
    4a40:	4770      	bx	lr
    4a42:	46c0      	nop			; (mov r8, r8)

00004a44 <_i2c_master_wait_for_sync>:
{
	/* Sanity check */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_hw = &(module->hw->I2CM);
    4a44:	6801      	ldr	r1, [r0, #0]
		const struct i2c_master_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
    4a46:	2207      	movs	r2, #7
	SercomI2cm *const i2c_hw = &(module->hw->I2CM);

#if defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_1)
	return (i2c_hw->STATUS.reg & SERCOM_I2CM_STATUS_SYNCBUSY);
#elif defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_2)
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
    4a48:	69cb      	ldr	r3, [r1, #28]
		const struct i2c_master_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
    4a4a:	421a      	tst	r2, r3
    4a4c:	d1fc      	bne.n	4a48 <_i2c_master_wait_for_sync+0x4>
		/* Wait for I2C module to sync. */
	}
}
    4a4e:	4770      	bx	lr

00004a50 <i2c_master_init>:
 */
enum status_code i2c_master_init(
		struct i2c_master_module *const module,
		Sercom *const hw,
		const struct i2c_master_config *const config)
{
    4a50:	b5f0      	push	{r4, r5, r6, r7, lr}
    4a52:	464f      	mov	r7, r9
    4a54:	4646      	mov	r6, r8
    4a56:	b4c0      	push	{r6, r7}
    4a58:	b083      	sub	sp, #12
    4a5a:	0007      	movs	r7, r0
    4a5c:	000d      	movs	r5, r1
    4a5e:	0016      	movs	r6, r2
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize software module */
	module->hw = hw;
    4a60:	6039      	str	r1, [r7, #0]

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    4a62:	0008      	movs	r0, r1
    4a64:	4b71      	ldr	r3, [pc, #452]	; (4c2c <i2c_master_init+0x1dc>)
    4a66:	4798      	blx	r3

#if (SAML22) || (SAMC20)
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#elif (SAML21)
	if (sercom_index == 5) {
    4a68:	2805      	cmp	r0, #5
    4a6a:	d100      	bne.n	4a6e <i2c_master_init+0x1e>
    4a6c:	e0c6      	b.n	4bfc <i2c_master_init+0x1ac>
		pm_index     = MCLK_APBDMASK_SERCOM5_Pos;
		gclk_index   = SERCOM5_GCLK_ID_CORE;
	} else {
		pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
		gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    4a6e:	0004      	movs	r4, r0
    4a70:	3412      	adds	r4, #18
		case SYSTEM_CLOCK_APB_APBB:
			MCLK->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			MCLK->APBCMASK.reg |= mask;
    4a72:	496f      	ldr	r1, [pc, #444]	; (4c30 <i2c_master_init+0x1e0>)
    4a74:	69ca      	ldr	r2, [r1, #28]
    4a76:	2301      	movs	r3, #1
    4a78:	4083      	lsls	r3, r0
    4a7a:	4313      	orrs	r3, r2
    4a7c:	61cb      	str	r3, [r1, #28]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    4a7e:	a901      	add	r1, sp, #4
    4a80:	7b33      	ldrb	r3, [r6, #12]
    4a82:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    4a84:	b2e4      	uxtb	r4, r4
    4a86:	0020      	movs	r0, r4
    4a88:	4b6a      	ldr	r3, [pc, #424]	; (4c34 <i2c_master_init+0x1e4>)
    4a8a:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    4a8c:	0020      	movs	r0, r4
    4a8e:	4b6a      	ldr	r3, [pc, #424]	; (4c38 <i2c_master_init+0x1e8>)
    4a90:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    4a92:	7b30      	ldrb	r0, [r6, #12]
    4a94:	2100      	movs	r1, #0
    4a96:	4b69      	ldr	r3, [pc, #420]	; (4c3c <i2c_master_init+0x1ec>)
    4a98:	4798      	blx	r3

	/* Check if module is enabled. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_ENABLE) {
    4a9a:	682b      	ldr	r3, [r5, #0]
		return STATUS_ERR_DENIED;
    4a9c:	201c      	movs	r0, #28
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
	system_gclk_chan_enable(gclk_index);
	sercom_set_gclk_generator(config->generator_source, false);

	/* Check if module is enabled. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_ENABLE) {
    4a9e:	079b      	lsls	r3, r3, #30
    4aa0:	d500      	bpl.n	4aa4 <i2c_master_init+0x54>
    4aa2:	e0bd      	b.n	4c20 <i2c_master_init+0x1d0>
		return STATUS_ERR_DENIED;
	}

	/* Check if reset is in progress. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_SWRST) {
    4aa4:	682b      	ldr	r3, [r5, #0]
		return STATUS_BUSY;
    4aa6:	3817      	subs	r0, #23
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_ENABLE) {
		return STATUS_ERR_DENIED;
	}

	/* Check if reset is in progress. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_SWRST) {
    4aa8:	07db      	lsls	r3, r3, #31
    4aaa:	d500      	bpl.n	4aae <i2c_master_init+0x5e>
    4aac:	e0b8      	b.n	4c20 <i2c_master_init+0x1d0>
		return STATUS_BUSY;
	}

#if I2C_MASTER_CALLBACK_MODE == true
	/* Get sercom instance index and register callback. */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
    4aae:	6838      	ldr	r0, [r7, #0]
    4ab0:	4b5e      	ldr	r3, [pc, #376]	; (4c2c <i2c_master_init+0x1dc>)
    4ab2:	4698      	mov	r8, r3
    4ab4:	4798      	blx	r3
    4ab6:	0004      	movs	r4, r0
	_sercom_set_handler(instance_index, _i2c_master_interrupt_handler);
    4ab8:	4961      	ldr	r1, [pc, #388]	; (4c40 <i2c_master_init+0x1f0>)
    4aba:	4b62      	ldr	r3, [pc, #392]	; (4c44 <i2c_master_init+0x1f4>)
    4abc:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    4abe:	00a4      	lsls	r4, r4, #2
    4ac0:	4b61      	ldr	r3, [pc, #388]	; (4c48 <i2c_master_init+0x1f8>)
    4ac2:	50e7      	str	r7, [r4, r3]

	/* Initialize values in module. */
	module->registered_callback = 0;
    4ac4:	2300      	movs	r3, #0
    4ac6:	763b      	strb	r3, [r7, #24]
	module->enabled_callback = 0;
    4ac8:	767b      	strb	r3, [r7, #25]
	module->buffer_length = 0;
    4aca:	2400      	movs	r4, #0
    4acc:	837b      	strh	r3, [r7, #26]
	module->buffer_remaining = 0;
    4ace:	83bb      	strh	r3, [r7, #28]

	module->status = STATUS_OK;
    4ad0:	2225      	movs	r2, #37	; 0x25
    4ad2:	54bc      	strb	r4, [r7, r2]
	module->buffer = NULL;
    4ad4:	623b      	str	r3, [r7, #32]
#endif

	/* Set sercom module to operate in I2C master mode. */
	i2c_module->CTRLA.reg = SERCOM_I2CM_CTRLA_MODE(0x5);
    4ad6:	3314      	adds	r3, #20
    4ad8:	602b      	str	r3, [r5, #0]
	uint32_t tmp_ctrla;
	int32_t tmp_baud;
	int32_t tmp_baud_hs;
	enum status_code tmp_status_code = STATUS_OK;

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    4ada:	683d      	ldr	r5, [r7, #0]
	Sercom *const sercom_hw = module->hw;

	uint8_t sercom_index = _sercom_get_sercom_inst_index(sercom_hw);
    4adc:	0028      	movs	r0, r5
    4ade:	47c0      	blx	r8
    4ae0:	4680      	mov	r8, r0
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    4ae2:	2380      	movs	r3, #128	; 0x80
    4ae4:	466a      	mov	r2, sp
    4ae6:	7013      	strb	r3, [r2, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    4ae8:	7054      	strb	r4, [r2, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    4aea:	2301      	movs	r3, #1
    4aec:	7093      	strb	r3, [r2, #2]
	config->powersave    = false;
    4aee:	70d4      	strb	r4, [r2, #3]

	/* Pin configuration */
	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);

	uint32_t pad0 = config->pinmux_pad0;
    4af0:	69f0      	ldr	r0, [r6, #28]
	uint32_t pad1 = config->pinmux_pad1;
    4af2:	6a34      	ldr	r4, [r6, #32]

	/* SERCOM PAD0 - SDA */
	if (pad0 == PINMUX_DEFAULT) {
    4af4:	2800      	cmp	r0, #0
    4af6:	d103      	bne.n	4b00 <i2c_master_init+0xb0>
		pad0 = _sercom_get_default_pad(sercom_hw, 0);
    4af8:	2100      	movs	r1, #0
    4afa:	0028      	movs	r0, r5
    4afc:	4b53      	ldr	r3, [pc, #332]	; (4c4c <i2c_master_init+0x1fc>)
    4afe:	4798      	blx	r3
	}
	pin_conf.mux_position = pad0 & 0xFFFF;
    4b00:	466b      	mov	r3, sp
    4b02:	7018      	strb	r0, [r3, #0]
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
    4b04:	2302      	movs	r3, #2
    4b06:	466a      	mov	r2, sp
    4b08:	7053      	strb	r3, [r2, #1]
	system_pinmux_pin_set_config(pad0 >> 16, &pin_conf);
    4b0a:	0c00      	lsrs	r0, r0, #16
    4b0c:	b2c0      	uxtb	r0, r0
    4b0e:	4669      	mov	r1, sp
    4b10:	4b4f      	ldr	r3, [pc, #316]	; (4c50 <i2c_master_init+0x200>)
    4b12:	4798      	blx	r3

	/* SERCOM PAD1 - SCL */
	if (pad1 == PINMUX_DEFAULT) {
    4b14:	2c00      	cmp	r4, #0
    4b16:	d104      	bne.n	4b22 <i2c_master_init+0xd2>
		pad1 = _sercom_get_default_pad(sercom_hw, 1);
    4b18:	2101      	movs	r1, #1
    4b1a:	0028      	movs	r0, r5
    4b1c:	4b4b      	ldr	r3, [pc, #300]	; (4c4c <i2c_master_init+0x1fc>)
    4b1e:	4798      	blx	r3
    4b20:	0004      	movs	r4, r0
	}
	pin_conf.mux_position = pad1 & 0xFFFF;
    4b22:	466b      	mov	r3, sp
    4b24:	701c      	strb	r4, [r3, #0]
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
    4b26:	2302      	movs	r3, #2
    4b28:	466a      	mov	r2, sp
    4b2a:	7053      	strb	r3, [r2, #1]
	system_pinmux_pin_set_config(pad1 >> 16, &pin_conf);
    4b2c:	0c20      	lsrs	r0, r4, #16
    4b2e:	b2c0      	uxtb	r0, r0
    4b30:	4669      	mov	r1, sp
    4b32:	4b47      	ldr	r3, [pc, #284]	; (4c50 <i2c_master_init+0x200>)
    4b34:	4798      	blx	r3

	/* Save timeout on unknown bus state in software module. */
	module->unknown_bus_state_timeout = config->unknown_bus_state_timeout;
    4b36:	8ab3      	ldrh	r3, [r6, #20]
    4b38:	80fb      	strh	r3, [r7, #6]

	/* Save timeout on buffer write. */
	module->buffer_timeout = config->buffer_timeout;
    4b3a:	8af3      	ldrh	r3, [r6, #22]
    4b3c:	813b      	strh	r3, [r7, #8]

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    4b3e:	7e32      	ldrb	r2, [r6, #24]
		tmp_ctrla = SERCOM_I2CM_CTRLA_RUNSTDBY;
    4b40:	2380      	movs	r3, #128	; 0x80

	/* Save timeout on buffer write. */
	module->buffer_timeout = config->buffer_timeout;

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    4b42:	2a00      	cmp	r2, #0
    4b44:	d104      	bne.n	4b50 <i2c_master_init+0x100>
    4b46:	4b43      	ldr	r3, [pc, #268]	; (4c54 <i2c_master_init+0x204>)
    4b48:	789b      	ldrb	r3, [r3, #2]
    4b4a:	079b      	lsls	r3, r3, #30
		tmp_ctrla = SERCOM_I2CM_CTRLA_RUNSTDBY;
    4b4c:	0fdb      	lsrs	r3, r3, #31
    4b4e:	01db      	lsls	r3, r3, #7
	if (config->start_hold_time != I2C_MASTER_START_HOLD_TIME_DISABLED) {
		tmp_ctrla |= config->start_hold_time;
	}

	/* Check and set transfer speed */
	tmp_ctrla |= config->transfer_speed;
    4b50:	6932      	ldr	r2, [r6, #16]
    4b52:	68b1      	ldr	r1, [r6, #8]
    4b54:	430a      	orrs	r2, r1
    4b56:	4313      	orrs	r3, r2

	/* Check and set SCL low timeout. */
	if (config->scl_low_timeout) {
    4b58:	2224      	movs	r2, #36	; 0x24
    4b5a:	5cb2      	ldrb	r2, [r6, r2]
    4b5c:	2a00      	cmp	r2, #0
    4b5e:	d002      	beq.n	4b66 <i2c_master_init+0x116>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_LOWTOUTEN;
    4b60:	2280      	movs	r2, #128	; 0x80
    4b62:	05d2      	lsls	r2, r2, #23
    4b64:	4313      	orrs	r3, r2
	}

	/* Check and set inactive bus timeout. */
	if (config->inactive_timeout != I2C_MASTER_INACTIVE_TIMEOUT_DISABLED) {
		tmp_ctrla |= config->inactive_timeout;
    4b66:	6ab2      	ldr	r2, [r6, #40]	; 0x28
    4b68:	4313      	orrs	r3, r2
	}

	/* Check and set SCL clock stretch mode. */
	if (config->scl_stretch_only_after_ack_bit) {
    4b6a:	222c      	movs	r2, #44	; 0x2c
    4b6c:	5cb2      	ldrb	r2, [r6, r2]
    4b6e:	2a00      	cmp	r2, #0
    4b70:	d002      	beq.n	4b78 <i2c_master_init+0x128>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_SCLSM;
    4b72:	2280      	movs	r2, #128	; 0x80
    4b74:	0512      	lsls	r2, r2, #20
    4b76:	4313      	orrs	r3, r2
	}

	/* Check and set slave SCL low extend timeout. */
	if (config->slave_scl_low_extend_timeout) {
    4b78:	222d      	movs	r2, #45	; 0x2d
    4b7a:	5cb2      	ldrb	r2, [r6, r2]
    4b7c:	2a00      	cmp	r2, #0
    4b7e:	d002      	beq.n	4b86 <i2c_master_init+0x136>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_SEXTTOEN;
    4b80:	2280      	movs	r2, #128	; 0x80
    4b82:	0412      	lsls	r2, r2, #16
    4b84:	4313      	orrs	r3, r2
	}

	/* Check and set master SCL low extend timeout. */
	if (config->master_scl_low_extend_timeout) {
    4b86:	222e      	movs	r2, #46	; 0x2e
    4b88:	5cb2      	ldrb	r2, [r6, r2]
    4b8a:	2a00      	cmp	r2, #0
    4b8c:	d002      	beq.n	4b94 <i2c_master_init+0x144>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_MEXTTOEN;
    4b8e:	2280      	movs	r2, #128	; 0x80
    4b90:	03d2      	lsls	r2, r2, #15
    4b92:	4313      	orrs	r3, r2
	}

	/* Write config to register CTRLA. */
	i2c_module->CTRLA.reg |= tmp_ctrla;
    4b94:	682a      	ldr	r2, [r5, #0]
    4b96:	4313      	orrs	r3, r2
    4b98:	602b      	str	r3, [r5, #0]

	/* Set configurations in CTRLB. */
	i2c_module->CTRLB.reg = SERCOM_I2CM_CTRLB_SMEN;
    4b9a:	2380      	movs	r3, #128	; 0x80
    4b9c:	005b      	lsls	r3, r3, #1
    4b9e:	606b      	str	r3, [r5, #4]

	/* Find and set baudrate, considering sda/scl rise time */
	uint32_t fgclk       = system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index);
    4ba0:	4644      	mov	r4, r8
    4ba2:	3412      	adds	r4, #18
    4ba4:	b2e3      	uxtb	r3, r4
    4ba6:	4698      	mov	r8, r3
    4ba8:	0018      	movs	r0, r3
    4baa:	4b2b      	ldr	r3, [pc, #172]	; (4c58 <i2c_master_init+0x208>)
    4bac:	4798      	blx	r3
    4bae:	0004      	movs	r4, r0
	uint32_t fscl        = 1000*config->baud_rate;
    4bb0:	20fa      	movs	r0, #250	; 0xfa
    4bb2:	0080      	lsls	r0, r0, #2
    4bb4:	6833      	ldr	r3, [r6, #0]
    4bb6:	4343      	muls	r3, r0
    4bb8:	4699      	mov	r9, r3
	uint32_t trise       = config->sda_scl_rise_time_ns;
	int32_t  numerator   = fgclk - fscl*(10 + fgclk*trise/1000000000);
	int32_t  denominator = 2*fscl;
    4bba:	005f      	lsls	r7, r3, #1
	/* For more accurate result, can use round div. */
	tmp_baud = (int32_t)(div_ceil(numerator, denominator));

	/* Check that baudrate is supported at current speed. */
	if (tmp_baud > 255 || tmp_baud < 0) {
    4bbc:	8e30      	ldrh	r0, [r6, #48]	; 0x30
    4bbe:	4360      	muls	r0, r4
    4bc0:	4926      	ldr	r1, [pc, #152]	; (4c5c <i2c_master_init+0x20c>)
    4bc2:	4b27      	ldr	r3, [pc, #156]	; (4c60 <i2c_master_init+0x210>)
    4bc4:	4798      	blx	r3
    4bc6:	300a      	adds	r0, #10
    4bc8:	464b      	mov	r3, r9
    4bca:	4358      	muls	r0, r3
    4bcc:	1a20      	subs	r0, r4, r0
    4bce:	19c0      	adds	r0, r0, r7
    4bd0:	3801      	subs	r0, #1
    4bd2:	0039      	movs	r1, r7
    4bd4:	4b23      	ldr	r3, [pc, #140]	; (4c64 <i2c_master_init+0x214>)
    4bd6:	4798      	blx	r3
    4bd8:	1e04      	subs	r4, r0, #0
    4bda:	2cff      	cmp	r4, #255	; 0xff
    4bdc:	d81f      	bhi.n	4c1e <i2c_master_init+0x1ce>
		/* Baud rate not supported. */
		tmp_status_code = STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		/* Find baudrate for high speed */
		tmp_baud_hs = (int32_t)(div_ceil(
    4bde:	4640      	mov	r0, r8
    4be0:	4b1d      	ldr	r3, [pc, #116]	; (4c58 <i2c_master_init+0x208>)
    4be2:	4798      	blx	r3
    4be4:	6871      	ldr	r1, [r6, #4]
    4be6:	23fa      	movs	r3, #250	; 0xfa
    4be8:	00db      	lsls	r3, r3, #3
    4bea:	4359      	muls	r1, r3
				system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index),
				(2000*(config->baud_rate_high_speed))) - 1);
    4bec:	1e4b      	subs	r3, r1, #1
    4bee:	1818      	adds	r0, r3, r0
    4bf0:	4b1b      	ldr	r3, [pc, #108]	; (4c60 <i2c_master_init+0x210>)
    4bf2:	4798      	blx	r3
    4bf4:	3801      	subs	r0, #1

		/* Check that baudrate is supported at current speed. */
		if (tmp_baud_hs > 255 || tmp_baud_hs < 0) {
    4bf6:	28ff      	cmp	r0, #255	; 0xff
    4bf8:	d811      	bhi.n	4c1e <i2c_master_init+0x1ce>
    4bfa:	e006      	b.n	4c0a <i2c_master_init+0x1ba>
			break;
		case SYSTEM_CLOCK_APB_APBD:
			MCLK->APBDMASK.reg |= mask;
    4bfc:	4a0c      	ldr	r2, [pc, #48]	; (4c30 <i2c_master_init+0x1e0>)
    4bfe:	6a11      	ldr	r1, [r2, #32]
    4c00:	2302      	movs	r3, #2
    4c02:	430b      	orrs	r3, r1
    4c04:	6213      	str	r3, [r2, #32]
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#elif (SAML21)
	if (sercom_index == 5) {
		pm_index     = MCLK_APBDMASK_SERCOM5_Pos;
		gclk_index   = SERCOM5_GCLK_ID_CORE;
    4c06:	2418      	movs	r4, #24
    4c08:	e739      	b.n	4a7e <i2c_master_init+0x2e>
			tmp_status_code = STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
	}
	if (tmp_status_code != STATUS_ERR_BAUDRATE_UNAVAILABLE) {
		/* Baud rate acceptable. */
		i2c_module->BAUD.reg = SERCOM_I2CM_BAUD_BAUD(tmp_baud) |
    4c0a:	0400      	lsls	r0, r0, #16
    4c0c:	23ff      	movs	r3, #255	; 0xff
    4c0e:	041b      	lsls	r3, r3, #16
    4c10:	4018      	ands	r0, r3
    4c12:	23ff      	movs	r3, #255	; 0xff
    4c14:	401c      	ands	r4, r3
    4c16:	4304      	orrs	r4, r0
    4c18:	60ec      	str	r4, [r5, #12]

	/* Temporary variables. */
	uint32_t tmp_ctrla;
	int32_t tmp_baud;
	int32_t tmp_baud_hs;
	enum status_code tmp_status_code = STATUS_OK;
    4c1a:	2000      	movs	r0, #0
    4c1c:	e000      	b.n	4c20 <i2c_master_init+0x1d0>
	/* Save timeout on buffer write. */
	module->buffer_timeout = config->buffer_timeout;

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
		tmp_ctrla = SERCOM_I2CM_CTRLA_RUNSTDBY;
    4c1e:	2040      	movs	r0, #64	; 0x40
	/* Set sercom module to operate in I2C master mode. */
	i2c_module->CTRLA.reg = SERCOM_I2CM_CTRLA_MODE(0x5);

	/* Set config and return status. */
	return _i2c_master_set_config(module, config);
}
    4c20:	b003      	add	sp, #12
    4c22:	bc0c      	pop	{r2, r3}
    4c24:	4690      	mov	r8, r2
    4c26:	4699      	mov	r9, r3
    4c28:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4c2a:	46c0      	nop			; (mov r8, r8)
    4c2c:	00006965 	.word	0x00006965
    4c30:	40000400 	.word	0x40000400
    4c34:	00007715 	.word	0x00007715
    4c38:	000076a5 	.word	0x000076a5
    4c3c:	00006795 	.word	0x00006795
    4c40:	00005081 	.word	0x00005081
    4c44:	000069a5 	.word	0x000069a5
    4c48:	20001344 	.word	0x20001344
    4c4c:	000067e1 	.word	0x000067e1
    4c50:	00007811 	.word	0x00007811
    4c54:	41002000 	.word	0x41002000
    4c58:	00007739 	.word	0x00007739
    4c5c:	3b9aca00 	.word	0x3b9aca00
    4c60:	0000a38d 	.word	0x0000a38d
    4c64:	0000a4a1 	.word	0x0000a4a1

00004c68 <_i2c_master_address_response>:
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    4c68:	6803      	ldr	r3, [r0, #0]

	/* Check for error and ignore bus-error; workaround for BUSSTATE stuck in
	 * BUSY */
	if (i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB) {
    4c6a:	7e1a      	ldrb	r2, [r3, #24]
    4c6c:	0792      	lsls	r2, r2, #30
    4c6e:	d507      	bpl.n	4c80 <_i2c_master_address_response+0x18>

		/* Clear write interrupt flag */
		i2c_module->INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    4c70:	2202      	movs	r2, #2
    4c72:	761a      	strb	r2, [r3, #24]

		/* Check arbitration. */
		if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_ARBLOST) {
    4c74:	8b5b      	ldrh	r3, [r3, #26]
    4c76:	079b      	lsls	r3, r3, #30
			/* Return packet collision. */
			return STATUS_ERR_PACKET_COLLISION;
    4c78:	2041      	movs	r0, #65	; 0x41

		/* Return bad address value. */
		return STATUS_ERR_BAD_ADDRESS;
	}

	return STATUS_OK;
    4c7a:	17db      	asrs	r3, r3, #31
    4c7c:	4018      	ands	r0, r3
    4c7e:	e00a      	b.n	4c96 <_i2c_master_address_response+0x2e>
		if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_ARBLOST) {
			/* Return packet collision. */
			return STATUS_ERR_PACKET_COLLISION;
		}
	/* Check that slave responded with ack. */
	} else if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK) {
    4c80:	8b5a      	ldrh	r2, [r3, #26]
    4c82:	0752      	lsls	r2, r2, #29
    4c84:	d506      	bpl.n	4c94 <_i2c_master_address_response+0x2c>
		/* Slave busy. Issue ack and stop command. */
		i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
    4c86:	685a      	ldr	r2, [r3, #4]
    4c88:	21c0      	movs	r1, #192	; 0xc0
    4c8a:	0289      	lsls	r1, r1, #10
    4c8c:	430a      	orrs	r2, r1
    4c8e:	605a      	str	r2, [r3, #4]

		/* Return bad address value. */
		return STATUS_ERR_BAD_ADDRESS;
    4c90:	2018      	movs	r0, #24
    4c92:	e000      	b.n	4c96 <_i2c_master_address_response+0x2e>
	}

	return STATUS_OK;
    4c94:	2000      	movs	r0, #0
}
    4c96:	4770      	bx	lr

00004c98 <_i2c_master_wait_for_bus>:
 * \retval STATUS_ERR_TIMEOUT  If no response was given within specified timeout
 *                             period
 */
enum status_code _i2c_master_wait_for_bus(
		struct i2c_master_module *const module)
{
    4c98:	b530      	push	{r4, r5, lr}
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    4c9a:	6802      	ldr	r2, [r0, #0]

	/* Wait for reply. */
	uint16_t timeout_counter = 0;
    4c9c:	2300      	movs	r3, #0
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
    4c9e:	2401      	movs	r4, #1
    4ca0:	2502      	movs	r5, #2
    4ca2:	e004      	b.n	4cae <_i2c_master_wait_for_bus+0x16>
			!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB)) {

		/* Check timeout condition. */
		if (++timeout_counter >= module->buffer_timeout) {
    4ca4:	3301      	adds	r3, #1
    4ca6:	b29b      	uxth	r3, r3
    4ca8:	8901      	ldrh	r1, [r0, #8]
    4caa:	4299      	cmp	r1, r3
    4cac:	d907      	bls.n	4cbe <_i2c_master_wait_for_bus+0x26>

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Wait for reply. */
	uint16_t timeout_counter = 0;
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
    4cae:	7e11      	ldrb	r1, [r2, #24]
    4cb0:	4221      	tst	r1, r4
    4cb2:	d106      	bne.n	4cc2 <_i2c_master_wait_for_bus+0x2a>
			!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB)) {
    4cb4:	7e11      	ldrb	r1, [r2, #24]

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Wait for reply. */
	uint16_t timeout_counter = 0;
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
    4cb6:	4229      	tst	r1, r5
    4cb8:	d0f4      	beq.n	4ca4 <_i2c_master_wait_for_bus+0xc>
		/* Check timeout condition. */
		if (++timeout_counter >= module->buffer_timeout) {
			return STATUS_ERR_TIMEOUT;
		}
	}
	return STATUS_OK;
    4cba:	2000      	movs	r0, #0
    4cbc:	e002      	b.n	4cc4 <_i2c_master_wait_for_bus+0x2c>
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
			!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB)) {

		/* Check timeout condition. */
		if (++timeout_counter >= module->buffer_timeout) {
			return STATUS_ERR_TIMEOUT;
    4cbe:	2012      	movs	r0, #18
    4cc0:	e000      	b.n	4cc4 <_i2c_master_wait_for_bus+0x2c>
		}
	}
	return STATUS_OK;
    4cc2:	2000      	movs	r0, #0
}
    4cc4:	bd30      	pop	{r4, r5, pc}
    4cc6:	46c0      	nop			; (mov r8, r8)

00004cc8 <_i2c_master_send_hs_master_code>:
 * \retval STATUS_OK           No error happen
 */
enum status_code _i2c_master_send_hs_master_code(
		struct i2c_master_module *const module,
		uint8_t hs_master_code)
{
    4cc8:	b510      	push	{r4, lr}
	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    4cca:	6804      	ldr	r4, [r0, #0]
	/* Return value. */
	enum status_code tmp_status;

	/* Set NACK for high speed code */
	i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    4ccc:	6863      	ldr	r3, [r4, #4]
    4cce:	2280      	movs	r2, #128	; 0x80
    4cd0:	02d2      	lsls	r2, r2, #11
    4cd2:	4313      	orrs	r3, r2
    4cd4:	6063      	str	r3, [r4, #4]
	/* Send high speed code */
	i2c_module->ADDR.reg = hs_master_code;
    4cd6:	6261      	str	r1, [r4, #36]	; 0x24
	/* Wait for response on bus. */
	tmp_status = _i2c_master_wait_for_bus(module);
    4cd8:	4b02      	ldr	r3, [pc, #8]	; (4ce4 <_i2c_master_send_hs_master_code+0x1c>)
    4cda:	4798      	blx	r3
	/* Clear write interrupt flag */
	i2c_module->INTFLAG.reg = SERCOM_I2CM_INTENCLR_MB;
    4cdc:	2301      	movs	r3, #1
    4cde:	7623      	strb	r3, [r4, #24]

	return tmp_status;
}
    4ce0:	bd10      	pop	{r4, pc}
    4ce2:	46c0      	nop			; (mov r8, r8)
    4ce4:	00004c99 	.word	0x00004c99

00004ce8 <_i2c_master_read_packet>:
 *
 */
static enum status_code _i2c_master_read_packet(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
    4ce8:	b5f0      	push	{r4, r5, r6, r7, lr}
    4cea:	465f      	mov	r7, fp
    4cec:	4656      	mov	r6, sl
    4cee:	464d      	mov	r5, r9
    4cf0:	4644      	mov	r4, r8
    4cf2:	b4f0      	push	{r4, r5, r6, r7}
    4cf4:	b083      	sub	sp, #12
    4cf6:	0006      	movs	r6, r0
    4cf8:	4689      	mov	r9, r1
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);
	Assert(packet);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    4cfa:	6805      	ldr	r5, [r0, #0]

	/* Return value. */
	enum status_code tmp_status;
	uint16_t tmp_data_length = packet->data_length;
    4cfc:	884c      	ldrh	r4, [r1, #2]

	/* Written buffer counter. */
	uint16_t counter = 0;

	bool sclsm_flag = i2c_module->CTRLA.bit.SCLSM;
    4cfe:	682b      	ldr	r3, [r5, #0]
    4d00:	011b      	lsls	r3, r3, #4
    4d02:	0fdb      	lsrs	r3, r3, #31
    4d04:	469a      	mov	sl, r3

	/* Switch to high speed mode */
	if (packet->high_speed) {
    4d06:	7a4b      	ldrb	r3, [r1, #9]
    4d08:	2b00      	cmp	r3, #0
    4d0a:	d002      	beq.n	4d12 <_i2c_master_read_packet+0x2a>
		_i2c_master_send_hs_master_code(module, packet->hs_master_code);
    4d0c:	7a89      	ldrb	r1, [r1, #10]
    4d0e:	4b4f      	ldr	r3, [pc, #316]	; (4e4c <_i2c_master_read_packet+0x164>)
    4d10:	4798      	blx	r3
	}

	/* Set action to ACK. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    4d12:	686a      	ldr	r2, [r5, #4]
    4d14:	4b4e      	ldr	r3, [pc, #312]	; (4e50 <_i2c_master_read_packet+0x168>)
    4d16:	4013      	ands	r3, r2
    4d18:	606b      	str	r3, [r5, #4]

	/* Set address and direction bit. Will send start command on bus. */
	if (packet->ten_bit_address) {
    4d1a:	464b      	mov	r3, r9
    4d1c:	7a1b      	ldrb	r3, [r3, #8]
    4d1e:	2b00      	cmp	r3, #0
    4d20:	d026      	beq.n	4d70 <_i2c_master_read_packet+0x88>
		/*
		 * Write ADDR.ADDR[10:1] with the 10-bit address. ADDR.TENBITEN must
		 * be set and read/write bit (ADDR.ADDR[0]) equal to 0.
		 */
		i2c_module->ADDR.reg = (packet->address << 1) |
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
    4d22:	464b      	mov	r3, r9
    4d24:	881b      	ldrh	r3, [r3, #0]
    4d26:	005a      	lsls	r2, r3, #1
    4d28:	464b      	mov	r3, r9
    4d2a:	7a5b      	ldrb	r3, [r3, #9]
    4d2c:	039b      	lsls	r3, r3, #14
    4d2e:	4313      	orrs	r3, r2
    4d30:	2280      	movs	r2, #128	; 0x80
    4d32:	0212      	lsls	r2, r2, #8
    4d34:	4313      	orrs	r3, r2
	if (packet->ten_bit_address) {
		/*
		 * Write ADDR.ADDR[10:1] with the 10-bit address. ADDR.TENBITEN must
		 * be set and read/write bit (ADDR.ADDR[0]) equal to 0.
		 */
		i2c_module->ADDR.reg = (packet->address << 1) |
    4d36:	626b      	str	r3, [r5, #36]	; 0x24
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
			SERCOM_I2CM_ADDR_TENBITEN;

		/* Wait for response on bus. */
		tmp_status = _i2c_master_wait_for_bus(module);
    4d38:	0030      	movs	r0, r6
    4d3a:	4b46      	ldr	r3, [pc, #280]	; (4e54 <_i2c_master_read_packet+0x16c>)
    4d3c:	4798      	blx	r3

		/* Set action to ack. */
		i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    4d3e:	686a      	ldr	r2, [r5, #4]
    4d40:	4b43      	ldr	r3, [pc, #268]	; (4e50 <_i2c_master_read_packet+0x168>)
    4d42:	4013      	ands	r3, r2
    4d44:	606b      	str	r3, [r5, #4]
		i2c_module->ADDR.reg = (packet->address << 1) |
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
			SERCOM_I2CM_ADDR_TENBITEN;

		/* Wait for response on bus. */
		tmp_status = _i2c_master_wait_for_bus(module);
    4d46:	1e03      	subs	r3, r0, #0
		/* Set action to ack. */
		i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;

		/* Check for address response error unless previous error is
		 * detected. */
		if (tmp_status == STATUS_OK) {
    4d48:	d178      	bne.n	4e3c <_i2c_master_read_packet+0x154>
			tmp_status = _i2c_master_address_response(module);
    4d4a:	0030      	movs	r0, r6
    4d4c:	4b42      	ldr	r3, [pc, #264]	; (4e58 <_i2c_master_read_packet+0x170>)
    4d4e:	4798      	blx	r3
    4d50:	1e03      	subs	r3, r0, #0
		}

		if (tmp_status == STATUS_OK) {
    4d52:	d173      	bne.n	4e3c <_i2c_master_read_packet+0x154>
			/*
			 * Write ADDR[7:0] register to "11110 address[9:8] 1"
			 * ADDR.TENBITEN must be cleared
			 */
			i2c_module->ADDR.reg = (((packet->address >> 8) | 0x78) << 1) |
    4d54:	464b      	mov	r3, r9
    4d56:	881b      	ldrh	r3, [r3, #0]
    4d58:	0a1b      	lsrs	r3, r3, #8
    4d5a:	2278      	movs	r2, #120	; 0x78
    4d5c:	4313      	orrs	r3, r2
    4d5e:	0059      	lsls	r1, r3, #1
    4d60:	464b      	mov	r3, r9
    4d62:	7a5b      	ldrb	r3, [r3, #9]
    4d64:	039b      	lsls	r3, r3, #14
    4d66:	3a77      	subs	r2, #119	; 0x77
    4d68:	4313      	orrs	r3, r2
    4d6a:	430b      	orrs	r3, r1
    4d6c:	626b      	str	r3, [r5, #36]	; 0x24
    4d6e:	e009      	b.n	4d84 <_i2c_master_read_packet+0x9c>
				I2C_TRANSFER_READ;
		} else {
			return tmp_status;
		}
	} else {
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_READ |
    4d70:	464b      	mov	r3, r9
    4d72:	881b      	ldrh	r3, [r3, #0]
    4d74:	005a      	lsls	r2, r3, #1
    4d76:	464b      	mov	r3, r9
    4d78:	7a5b      	ldrb	r3, [r3, #9]
    4d7a:	039b      	lsls	r3, r3, #14
    4d7c:	4313      	orrs	r3, r2
    4d7e:	2201      	movs	r2, #1
    4d80:	4313      	orrs	r3, r2
    4d82:	626b      	str	r3, [r5, #36]	; 0x24
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos);
	}

	/* Wait for response on bus. */
	tmp_status = _i2c_master_wait_for_bus(module);
    4d84:	0030      	movs	r0, r6
    4d86:	4b33      	ldr	r3, [pc, #204]	; (4e54 <_i2c_master_read_packet+0x16c>)
    4d88:	4798      	blx	r3

	/* Set action to ack. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    4d8a:	686a      	ldr	r2, [r5, #4]
    4d8c:	4b30      	ldr	r3, [pc, #192]	; (4e50 <_i2c_master_read_packet+0x168>)
    4d8e:	4013      	ands	r3, r2
    4d90:	606b      	str	r3, [r5, #4]
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_READ |
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos);
	}

	/* Wait for response on bus. */
	tmp_status = _i2c_master_wait_for_bus(module);
    4d92:	1e03      	subs	r3, r0, #0
	/* Set action to ack. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;

	/* Check for address response error unless previous error is
	 * detected. */
	if (tmp_status == STATUS_OK) {
    4d94:	d152      	bne.n	4e3c <_i2c_master_read_packet+0x154>
		tmp_status = _i2c_master_address_response(module);
    4d96:	0030      	movs	r0, r6
    4d98:	4b2f      	ldr	r3, [pc, #188]	; (4e58 <_i2c_master_read_packet+0x170>)
    4d9a:	4798      	blx	r3
    4d9c:	9001      	str	r0, [sp, #4]
    4d9e:	1e03      	subs	r3, r0, #0
	}

	/* Check that no error has occurred. */
	if (tmp_status == STATUS_OK) {
    4da0:	d14c      	bne.n	4e3c <_i2c_master_read_packet+0x154>
    4da2:	3c01      	subs	r4, #1
    4da4:	b2a4      	uxth	r4, r4
    4da6:	2300      	movs	r3, #0
    4da8:	4698      	mov	r8, r3
		/* Read data buffer. */
		while (tmp_data_length--) {
    4daa:	4b2c      	ldr	r3, [pc, #176]	; (4e5c <_i2c_master_read_packet+0x174>)
    4dac:	469b      	mov	fp, r3
    4dae:	e029      	b.n	4e04 <_i2c_master_read_packet+0x11c>
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
    4db0:	8b6b      	ldrh	r3, [r5, #26]
    4db2:	069b      	lsls	r3, r3, #26
    4db4:	d541      	bpl.n	4e3a <_i2c_master_read_packet+0x152>
				return STATUS_ERR_PACKET_COLLISION;
			}

			if (module->send_nack && (((!sclsm_flag) && (tmp_data_length == 0)) ||
    4db6:	7af3      	ldrb	r3, [r6, #11]
    4db8:	2b00      	cmp	r3, #0
    4dba:	d00f      	beq.n	4ddc <_i2c_master_read_packet+0xf4>
    4dbc:	4653      	mov	r3, sl
    4dbe:	2b00      	cmp	r3, #0
    4dc0:	d102      	bne.n	4dc8 <_i2c_master_read_packet+0xe0>
    4dc2:	2c00      	cmp	r4, #0
    4dc4:	d002      	beq.n	4dcc <_i2c_master_read_packet+0xe4>
    4dc6:	e009      	b.n	4ddc <_i2c_master_read_packet+0xf4>
					((sclsm_flag) && (tmp_data_length == 1)))) {
    4dc8:	2c01      	cmp	r4, #1
    4dca:	d107      	bne.n	4ddc <_i2c_master_read_packet+0xf4>
				/* Set action to NACK */
				i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    4dcc:	686b      	ldr	r3, [r5, #4]
    4dce:	2280      	movs	r2, #128	; 0x80
    4dd0:	02d2      	lsls	r2, r2, #11
    4dd2:	4313      	orrs	r3, r2
    4dd4:	606b      	str	r3, [r5, #4]
    4dd6:	3c01      	subs	r4, #1
    4dd8:	b2a4      	uxth	r4, r4
    4dda:	e013      	b.n	4e04 <_i2c_master_read_packet+0x11c>
			} else {
				/* Save data to buffer. */
				_i2c_master_wait_for_sync(module);
    4ddc:	0030      	movs	r0, r6
    4dde:	4b20      	ldr	r3, [pc, #128]	; (4e60 <_i2c_master_read_packet+0x178>)
    4de0:	4798      	blx	r3
				packet->data[counter++] = i2c_module->DATA.reg;
    4de2:	4643      	mov	r3, r8
    4de4:	1c5f      	adds	r7, r3, #1
    4de6:	b2bf      	uxth	r7, r7
    4de8:	2328      	movs	r3, #40	; 0x28
    4dea:	5ceb      	ldrb	r3, [r5, r3]
    4dec:	464a      	mov	r2, r9
    4dee:	6852      	ldr	r2, [r2, #4]
    4df0:	4641      	mov	r1, r8
    4df2:	5453      	strb	r3, [r2, r1]
				/* Wait for response. */
				tmp_status = _i2c_master_wait_for_bus(module);
    4df4:	0030      	movs	r0, r6
    4df6:	4b17      	ldr	r3, [pc, #92]	; (4e54 <_i2c_master_read_packet+0x16c>)
    4df8:	4798      	blx	r3
    4dfa:	3c01      	subs	r4, #1
    4dfc:	b2a4      	uxth	r4, r4
			}

			/* Check for error. */
			if (tmp_status != STATUS_OK) {
    4dfe:	2800      	cmp	r0, #0
    4e00:	d103      	bne.n	4e0a <_i2c_master_read_packet+0x122>
				/* Set action to NACK */
				i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
			} else {
				/* Save data to buffer. */
				_i2c_master_wait_for_sync(module);
				packet->data[counter++] = i2c_module->DATA.reg;
    4e02:	46b8      	mov	r8, r7
	}

	/* Check that no error has occurred. */
	if (tmp_status == STATUS_OK) {
		/* Read data buffer. */
		while (tmp_data_length--) {
    4e04:	455c      	cmp	r4, fp
    4e06:	d1d3      	bne.n	4db0 <_i2c_master_read_packet+0xc8>
    4e08:	e001      	b.n	4e0e <_i2c_master_read_packet+0x126>
				/* Set action to NACK */
				i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
			} else {
				/* Save data to buffer. */
				_i2c_master_wait_for_sync(module);
				packet->data[counter++] = i2c_module->DATA.reg;
    4e0a:	46b8      	mov	r8, r7
				/* Wait for response. */
				tmp_status = _i2c_master_wait_for_bus(module);
    4e0c:	9001      	str	r0, [sp, #4]
			if (tmp_status != STATUS_OK) {
				break;
			}
		}

		if (module->send_stop) {
    4e0e:	7ab3      	ldrb	r3, [r6, #10]
    4e10:	2b00      	cmp	r3, #0
    4e12:	d007      	beq.n	4e24 <_i2c_master_read_packet+0x13c>
			/* Send stop command unless arbitration is lost. */
			_i2c_master_wait_for_sync(module);
    4e14:	0030      	movs	r0, r6
    4e16:	4b12      	ldr	r3, [pc, #72]	; (4e60 <_i2c_master_read_packet+0x178>)
    4e18:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
    4e1a:	686b      	ldr	r3, [r5, #4]
    4e1c:	22c0      	movs	r2, #192	; 0xc0
    4e1e:	0292      	lsls	r2, r2, #10
    4e20:	4313      	orrs	r3, r2
    4e22:	606b      	str	r3, [r5, #4]
		}

		/* Save last data to buffer. */
		_i2c_master_wait_for_sync(module);
    4e24:	0030      	movs	r0, r6
    4e26:	4b0e      	ldr	r3, [pc, #56]	; (4e60 <_i2c_master_read_packet+0x178>)
    4e28:	4798      	blx	r3
		packet->data[counter] = i2c_module->DATA.reg;
    4e2a:	2328      	movs	r3, #40	; 0x28
    4e2c:	5cea      	ldrb	r2, [r5, r3]
    4e2e:	464b      	mov	r3, r9
    4e30:	685b      	ldr	r3, [r3, #4]
    4e32:	4641      	mov	r1, r8
    4e34:	545a      	strb	r2, [r3, r1]
    4e36:	9b01      	ldr	r3, [sp, #4]
    4e38:	e000      	b.n	4e3c <_i2c_master_read_packet+0x154>
	if (tmp_status == STATUS_OK) {
		/* Read data buffer. */
		while (tmp_data_length--) {
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
				return STATUS_ERR_PACKET_COLLISION;
    4e3a:	2341      	movs	r3, #65	; 0x41
		_i2c_master_wait_for_sync(module);
		packet->data[counter] = i2c_module->DATA.reg;
	}

	return tmp_status;
}
    4e3c:	0018      	movs	r0, r3
    4e3e:	b003      	add	sp, #12
    4e40:	bc3c      	pop	{r2, r3, r4, r5}
    4e42:	4690      	mov	r8, r2
    4e44:	4699      	mov	r9, r3
    4e46:	46a2      	mov	sl, r4
    4e48:	46ab      	mov	fp, r5
    4e4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4e4c:	00004cc9 	.word	0x00004cc9
    4e50:	fffbffff 	.word	0xfffbffff
    4e54:	00004c99 	.word	0x00004c99
    4e58:	00004c69 	.word	0x00004c69
    4e5c:	0000ffff 	.word	0x0000ffff
    4e60:	00004a45 	.word	0x00004a45

00004e64 <_i2c_master_write_packet>:
 *                                      acknowledged the address
 */
static enum status_code _i2c_master_write_packet(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
    4e64:	b5f0      	push	{r4, r5, r6, r7, lr}
    4e66:	465f      	mov	r7, fp
    4e68:	4656      	mov	r6, sl
    4e6a:	464d      	mov	r5, r9
    4e6c:	4644      	mov	r4, r8
    4e6e:	b4f0      	push	{r4, r5, r6, r7}
    4e70:	b083      	sub	sp, #12
    4e72:	0006      	movs	r6, r0
    4e74:	000f      	movs	r7, r1
	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    4e76:	6805      	ldr	r5, [r0, #0]

	/* Return value. */
	enum status_code tmp_status;
	uint16_t tmp_data_length = packet->data_length;
    4e78:	884c      	ldrh	r4, [r1, #2]

	_i2c_master_wait_for_sync(module);
    4e7a:	4b31      	ldr	r3, [pc, #196]	; (4f40 <_i2c_master_write_packet+0xdc>)
    4e7c:	4798      	blx	r3

	/* Switch to high speed mode */
	if (packet->high_speed) {
    4e7e:	7a7b      	ldrb	r3, [r7, #9]
    4e80:	2b00      	cmp	r3, #0
    4e82:	d003      	beq.n	4e8c <_i2c_master_write_packet+0x28>
		_i2c_master_send_hs_master_code(module, packet->hs_master_code);
    4e84:	7ab9      	ldrb	r1, [r7, #10]
    4e86:	0030      	movs	r0, r6
    4e88:	4b2e      	ldr	r3, [pc, #184]	; (4f44 <_i2c_master_write_packet+0xe0>)
    4e8a:	4798      	blx	r3
	}

	/* Set action to ACK. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    4e8c:	686a      	ldr	r2, [r5, #4]
    4e8e:	4b2e      	ldr	r3, [pc, #184]	; (4f48 <_i2c_master_write_packet+0xe4>)
    4e90:	4013      	ands	r3, r2
    4e92:	606b      	str	r3, [r5, #4]

	/* Set address and direction bit. Will send start command on bus. */
	if (packet->ten_bit_address) {
    4e94:	7a3b      	ldrb	r3, [r7, #8]
    4e96:	2b00      	cmp	r3, #0
    4e98:	d009      	beq.n	4eae <_i2c_master_write_packet+0x4a>
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
    4e9a:	883b      	ldrh	r3, [r7, #0]
    4e9c:	005a      	lsls	r2, r3, #1
    4e9e:	7a7b      	ldrb	r3, [r7, #9]
    4ea0:	039b      	lsls	r3, r3, #14
    4ea2:	4313      	orrs	r3, r2
    4ea4:	2280      	movs	r2, #128	; 0x80
    4ea6:	0212      	lsls	r2, r2, #8
    4ea8:	4313      	orrs	r3, r2
	/* Set action to ACK. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;

	/* Set address and direction bit. Will send start command on bus. */
	if (packet->ten_bit_address) {
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
    4eaa:	626b      	str	r3, [r5, #36]	; 0x24
    4eac:	e005      	b.n	4eba <_i2c_master_write_packet+0x56>
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
			SERCOM_I2CM_ADDR_TENBITEN;
	} else {
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
    4eae:	883b      	ldrh	r3, [r7, #0]
    4eb0:	005a      	lsls	r2, r3, #1
    4eb2:	7a7b      	ldrb	r3, [r7, #9]
    4eb4:	039b      	lsls	r3, r3, #14
    4eb6:	4313      	orrs	r3, r2
    4eb8:	626b      	str	r3, [r5, #36]	; 0x24
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos);
	}
	/* Wait for response on bus. */
	tmp_status = _i2c_master_wait_for_bus(module);
    4eba:	0030      	movs	r0, r6
    4ebc:	4b23      	ldr	r3, [pc, #140]	; (4f4c <_i2c_master_write_packet+0xe8>)
    4ebe:	4798      	blx	r3

	/* Check for address response error unless previous error is
	 * detected. */
	if (tmp_status == STATUS_OK) {
    4ec0:	2800      	cmp	r0, #0
    4ec2:	d136      	bne.n	4f32 <_i2c_master_write_packet+0xce>
		tmp_status = _i2c_master_address_response(module);
    4ec4:	0030      	movs	r0, r6
    4ec6:	4b22      	ldr	r3, [pc, #136]	; (4f50 <_i2c_master_write_packet+0xec>)
    4ec8:	4798      	blx	r3
    4eca:	1e03      	subs	r3, r0, #0
    4ecc:	9001      	str	r0, [sp, #4]
	}

	/* Check that no error has occurred. */
	if (tmp_status == STATUS_OK) {
    4ece:	d130      	bne.n	4f32 <_i2c_master_write_packet+0xce>
    4ed0:	46a0      	mov	r8, r4
    4ed2:	2400      	movs	r4, #0
		uint16_t buffer_counter = 0;

		/* Write data buffer. */
		while (tmp_data_length--) {
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
    4ed4:	3320      	adds	r3, #32
    4ed6:	4699      	mov	r9, r3
				return STATUS_ERR_PACKET_COLLISION;
			}

			/* Write byte to slave. */
			_i2c_master_wait_for_sync(module);
    4ed8:	4b19      	ldr	r3, [pc, #100]	; (4f40 <_i2c_master_write_packet+0xdc>)
    4eda:	469b      	mov	fp, r3
			i2c_module->DATA.reg = packet->data[buffer_counter++];

			/* Wait for response. */
			tmp_status = _i2c_master_wait_for_bus(module);
    4edc:	4b1b      	ldr	r3, [pc, #108]	; (4f4c <_i2c_master_write_packet+0xe8>)
    4ede:	469a      	mov	sl, r3
    4ee0:	e011      	b.n	4f06 <_i2c_master_write_packet+0xa2>
		uint16_t buffer_counter = 0;

		/* Write data buffer. */
		while (tmp_data_length--) {
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
    4ee2:	8b6b      	ldrh	r3, [r5, #26]
    4ee4:	464a      	mov	r2, r9
    4ee6:	4213      	tst	r3, r2
    4ee8:	d022      	beq.n	4f30 <_i2c_master_write_packet+0xcc>
				return STATUS_ERR_PACKET_COLLISION;
			}

			/* Write byte to slave. */
			_i2c_master_wait_for_sync(module);
    4eea:	0030      	movs	r0, r6
    4eec:	47d8      	blx	fp
			i2c_module->DATA.reg = packet->data[buffer_counter++];
    4eee:	687b      	ldr	r3, [r7, #4]
    4ef0:	5d1a      	ldrb	r2, [r3, r4]
    4ef2:	2328      	movs	r3, #40	; 0x28
    4ef4:	54ea      	strb	r2, [r5, r3]

			/* Wait for response. */
			tmp_status = _i2c_master_wait_for_bus(module);
    4ef6:	0030      	movs	r0, r6
    4ef8:	47d0      	blx	sl

			/* Check for error. */
			if (tmp_status != STATUS_OK) {
    4efa:	2800      	cmp	r0, #0
    4efc:	d106      	bne.n	4f0c <_i2c_master_write_packet+0xa8>
				break;
			}

			/* Check for NACK from slave. */
			if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK) {
    4efe:	8b6b      	ldrh	r3, [r5, #26]
    4f00:	3401      	adds	r4, #1
    4f02:	075b      	lsls	r3, r3, #29
    4f04:	d404      	bmi.n	4f10 <_i2c_master_write_packet+0xac>
	if (tmp_status == STATUS_OK) {
		/* Buffer counter. */
		uint16_t buffer_counter = 0;

		/* Write data buffer. */
		while (tmp_data_length--) {
    4f06:	45a0      	cmp	r8, r4
    4f08:	d1eb      	bne.n	4ee2 <_i2c_master_write_packet+0x7e>
    4f0a:	e003      	b.n	4f14 <_i2c_master_write_packet+0xb0>
			/* Write byte to slave. */
			_i2c_master_wait_for_sync(module);
			i2c_module->DATA.reg = packet->data[buffer_counter++];

			/* Wait for response. */
			tmp_status = _i2c_master_wait_for_bus(module);
    4f0c:	9001      	str	r0, [sp, #4]
    4f0e:	e001      	b.n	4f14 <_i2c_master_write_packet+0xb0>
			}

			/* Check for NACK from slave. */
			if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK) {
				/* Return bad data value. */
				tmp_status = STATUS_ERR_OVERFLOW;
    4f10:	231e      	movs	r3, #30
    4f12:	9301      	str	r3, [sp, #4]
				break;
			}
		}

		if (module->send_stop) {
    4f14:	7ab3      	ldrb	r3, [r6, #10]
    4f16:	9801      	ldr	r0, [sp, #4]
    4f18:	2b00      	cmp	r3, #0
    4f1a:	d00a      	beq.n	4f32 <_i2c_master_write_packet+0xce>
			/* Stop command */
			_i2c_master_wait_for_sync(module);
    4f1c:	0030      	movs	r0, r6
    4f1e:	4b08      	ldr	r3, [pc, #32]	; (4f40 <_i2c_master_write_packet+0xdc>)
    4f20:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
    4f22:	686b      	ldr	r3, [r5, #4]
    4f24:	22c0      	movs	r2, #192	; 0xc0
    4f26:	0292      	lsls	r2, r2, #10
    4f28:	4313      	orrs	r3, r2
    4f2a:	606b      	str	r3, [r5, #4]
    4f2c:	9801      	ldr	r0, [sp, #4]
    4f2e:	e000      	b.n	4f32 <_i2c_master_write_packet+0xce>

		/* Write data buffer. */
		while (tmp_data_length--) {
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
				return STATUS_ERR_PACKET_COLLISION;
    4f30:	2041      	movs	r0, #65	; 0x41
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
		}
	}

	return tmp_status;
}
    4f32:	b003      	add	sp, #12
    4f34:	bc3c      	pop	{r2, r3, r4, r5}
    4f36:	4690      	mov	r8, r2
    4f38:	4699      	mov	r9, r3
    4f3a:	46a2      	mov	sl, r4
    4f3c:	46ab      	mov	fp, r5
    4f3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4f40:	00004a45 	.word	0x00004a45
    4f44:	00004cc9 	.word	0x00004cc9
    4f48:	fffbffff 	.word	0xfffbffff
    4f4c:	00004c99 	.word	0x00004c99
    4f50:	00004c69 	.word	0x00004c69

00004f54 <i2c_master_read_packet_wait>:
 *                                      acknowledged the address
 */
enum status_code i2c_master_read_packet_wait(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
    4f54:	b510      	push	{r4, lr}
	Assert(module->hw);
	Assert(packet);

#if I2C_MASTER_CALLBACK_MODE == true
	/* Check if the I2C module is busy with a job. */
	if (module->buffer_remaining > 0) {
    4f56:	8b83      	ldrh	r3, [r0, #28]
    4f58:	b29b      	uxth	r3, r3
		return STATUS_BUSY;
    4f5a:	2205      	movs	r2, #5
	Assert(module->hw);
	Assert(packet);

#if I2C_MASTER_CALLBACK_MODE == true
	/* Check if the I2C module is busy with a job. */
	if (module->buffer_remaining > 0) {
    4f5c:	2b00      	cmp	r3, #0
    4f5e:	d105      	bne.n	4f6c <i2c_master_read_packet_wait+0x18>
		return STATUS_BUSY;
	}
#endif

	module->send_stop = true;
    4f60:	3301      	adds	r3, #1
    4f62:	7283      	strb	r3, [r0, #10]
	module->send_nack = true;
    4f64:	72c3      	strb	r3, [r0, #11]

	return _i2c_master_read_packet(module, packet);
    4f66:	4b02      	ldr	r3, [pc, #8]	; (4f70 <i2c_master_read_packet_wait+0x1c>)
    4f68:	4798      	blx	r3
    4f6a:	0002      	movs	r2, r0
}
    4f6c:	0010      	movs	r0, r2
    4f6e:	bd10      	pop	{r4, pc}
    4f70:	00004ce9 	.word	0x00004ce9

00004f74 <i2c_master_write_packet_wait>:
 *                                      last data sent
 */
enum status_code i2c_master_write_packet_wait(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
    4f74:	b510      	push	{r4, lr}
	Assert(module->hw);
	Assert(packet);

#if I2C_MASTER_CALLBACK_MODE == true
	/* Check if the I2C module is busy with a job */
	if (module->buffer_remaining > 0) {
    4f76:	8b83      	ldrh	r3, [r0, #28]
    4f78:	b29b      	uxth	r3, r3
		return STATUS_BUSY;
    4f7a:	2205      	movs	r2, #5
	Assert(module->hw);
	Assert(packet);

#if I2C_MASTER_CALLBACK_MODE == true
	/* Check if the I2C module is busy with a job */
	if (module->buffer_remaining > 0) {
    4f7c:	2b00      	cmp	r3, #0
    4f7e:	d105      	bne.n	4f8c <i2c_master_write_packet_wait+0x18>
		return STATUS_BUSY;
	}
#endif

	module->send_stop = true;
    4f80:	3301      	adds	r3, #1
    4f82:	7283      	strb	r3, [r0, #10]
	module->send_nack = true;
    4f84:	72c3      	strb	r3, [r0, #11]

	return _i2c_master_write_packet(module, packet);
    4f86:	4b02      	ldr	r3, [pc, #8]	; (4f90 <i2c_master_write_packet_wait+0x1c>)
    4f88:	4798      	blx	r3
    4f8a:	0002      	movs	r2, r0
}
    4f8c:	0010      	movs	r0, r2
    4f8e:	bd10      	pop	{r4, pc}
    4f90:	00004e65 	.word	0x00004e65

00004f94 <i2c_master_write_packet_wait_no_stop>:
 *                                      more data
 */
enum status_code i2c_master_write_packet_wait_no_stop(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
    4f94:	b510      	push	{r4, lr}
	Assert(module->hw);
	Assert(packet);

#if I2C_MASTER_CALLBACK_MODE == true
	/* Check if the I2C module is busy with a job */
	if (module->buffer_remaining > 0) {
    4f96:	8b83      	ldrh	r3, [r0, #28]
    4f98:	b29b      	uxth	r3, r3
		return STATUS_BUSY;
    4f9a:	2205      	movs	r2, #5
	Assert(module->hw);
	Assert(packet);

#if I2C_MASTER_CALLBACK_MODE == true
	/* Check if the I2C module is busy with a job */
	if (module->buffer_remaining > 0) {
    4f9c:	2b00      	cmp	r3, #0
    4f9e:	d105      	bne.n	4fac <i2c_master_write_packet_wait_no_stop+0x18>
		return STATUS_BUSY;
	}
#endif

	module->send_stop = false;
    4fa0:	7283      	strb	r3, [r0, #10]
	module->send_nack = true;
    4fa2:	3301      	adds	r3, #1
    4fa4:	72c3      	strb	r3, [r0, #11]

	return _i2c_master_write_packet(module, packet);
    4fa6:	4b02      	ldr	r3, [pc, #8]	; (4fb0 <i2c_master_write_packet_wait_no_stop+0x1c>)
    4fa8:	4798      	blx	r3
    4faa:	0002      	movs	r2, r0
}
    4fac:	0010      	movs	r0, r2
    4fae:	bd10      	pop	{r4, pc}
    4fb0:	00004e65 	.word	0x00004e65

00004fb4 <_i2c_master_wait_for_sync>:
{
	/* Sanity check */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_hw = &(module->hw->I2CM);
    4fb4:	6801      	ldr	r1, [r0, #0]
		const struct i2c_master_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
    4fb6:	2207      	movs	r2, #7
	SercomI2cm *const i2c_hw = &(module->hw->I2CM);

#if defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_1)
	return (i2c_hw->STATUS.reg & SERCOM_I2CM_STATUS_SYNCBUSY);
#elif defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_2)
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
    4fb8:	69cb      	ldr	r3, [r1, #28]
		const struct i2c_master_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
    4fba:	421a      	tst	r2, r3
    4fbc:	d1fc      	bne.n	4fb8 <_i2c_master_wait_for_sync+0x4>
		/* Wait for I2C module to sync. */
	}
}
    4fbe:	4770      	bx	lr

00004fc0 <_i2c_master_read>:
 *
 * \param[in,out] module  Pointer to software module structure
 */
static void _i2c_master_read(
		struct i2c_master_module *const module)
{
    4fc0:	b570      	push	{r4, r5, r6, lr}
    4fc2:	0004      	movs	r4, r0
	/* Sanity check arguments. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    4fc4:	6806      	ldr	r6, [r0, #0]
	bool sclsm_flag = i2c_module->CTRLA.bit.SCLSM;
    4fc6:	6832      	ldr	r2, [r6, #0]

	/* Find index to save next value in buffer */
	uint16_t buffer_index = module->buffer_length;
    4fc8:	8b43      	ldrh	r3, [r0, #26]
	buffer_index -= module->buffer_remaining;
    4fca:	8b85      	ldrh	r5, [r0, #28]
    4fcc:	1b5d      	subs	r5, r3, r5
    4fce:	b2ad      	uxth	r5, r5

	module->buffer_remaining--;
    4fd0:	8b83      	ldrh	r3, [r0, #28]
    4fd2:	3b01      	subs	r3, #1
    4fd4:	b29b      	uxth	r3, r3
    4fd6:	8383      	strh	r3, [r0, #28]

	if (sclsm_flag) {
    4fd8:	0113      	lsls	r3, r2, #4
    4fda:	d50c      	bpl.n	4ff6 <_i2c_master_read+0x36>
		if (module->send_nack && module->buffer_remaining == 1) {
    4fdc:	7ac3      	ldrb	r3, [r0, #11]
    4fde:	2b00      	cmp	r3, #0
    4fe0:	d015      	beq.n	500e <_i2c_master_read+0x4e>
    4fe2:	8b83      	ldrh	r3, [r0, #28]
    4fe4:	b29b      	uxth	r3, r3
    4fe6:	2b01      	cmp	r3, #1
    4fe8:	d111      	bne.n	500e <_i2c_master_read+0x4e>
			/* Set action to NACK. */
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    4fea:	6873      	ldr	r3, [r6, #4]
    4fec:	2280      	movs	r2, #128	; 0x80
    4fee:	02d2      	lsls	r2, r2, #11
    4ff0:	4313      	orrs	r3, r2
    4ff2:	6073      	str	r3, [r6, #4]
    4ff4:	e00b      	b.n	500e <_i2c_master_read+0x4e>
		}
	} else {
		if (module->send_nack && module->buffer_remaining == 0) {
    4ff6:	7ac3      	ldrb	r3, [r0, #11]
    4ff8:	2b00      	cmp	r3, #0
    4ffa:	d008      	beq.n	500e <_i2c_master_read+0x4e>
    4ffc:	8b83      	ldrh	r3, [r0, #28]
    4ffe:	b29b      	uxth	r3, r3
    5000:	2b00      	cmp	r3, #0
    5002:	d104      	bne.n	500e <_i2c_master_read+0x4e>
			/* Set action to NACK. */
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    5004:	6873      	ldr	r3, [r6, #4]
    5006:	2280      	movs	r2, #128	; 0x80
    5008:	02d2      	lsls	r2, r2, #11
    500a:	4313      	orrs	r3, r2
    500c:	6073      	str	r3, [r6, #4]
		}
	}

	if (module->buffer_remaining == 0) {
    500e:	8ba3      	ldrh	r3, [r4, #28]
    5010:	b29b      	uxth	r3, r3
    5012:	2b00      	cmp	r3, #0
    5014:	d10a      	bne.n	502c <_i2c_master_read+0x6c>
		if (module->send_stop) {
    5016:	7aa3      	ldrb	r3, [r4, #10]
    5018:	2b00      	cmp	r3, #0
    501a:	d007      	beq.n	502c <_i2c_master_read+0x6c>
			/* Send stop condition */
			_i2c_master_wait_for_sync(module);
    501c:	0020      	movs	r0, r4
    501e:	4b08      	ldr	r3, [pc, #32]	; (5040 <_i2c_master_read+0x80>)
    5020:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
    5022:	6873      	ldr	r3, [r6, #4]
    5024:	22c0      	movs	r2, #192	; 0xc0
    5026:	0292      	lsls	r2, r2, #10
    5028:	4313      	orrs	r3, r2
    502a:	6073      	str	r3, [r6, #4]
		}
	}
	
	/* Read byte from slave and put in buffer */
	_i2c_master_wait_for_sync(module);
    502c:	0020      	movs	r0, r4
    502e:	4b04      	ldr	r3, [pc, #16]	; (5040 <_i2c_master_read+0x80>)
    5030:	4798      	blx	r3
	module->buffer[buffer_index] = i2c_module->DATA.reg;
    5032:	6a23      	ldr	r3, [r4, #32]
    5034:	195d      	adds	r5, r3, r5
    5036:	2328      	movs	r3, #40	; 0x28
    5038:	5cf3      	ldrb	r3, [r6, r3]
    503a:	b2db      	uxtb	r3, r3
    503c:	702b      	strb	r3, [r5, #0]
}
    503e:	bd70      	pop	{r4, r5, r6, pc}
    5040:	00004fb5 	.word	0x00004fb5

00005044 <_i2c_master_write>:
 * Write next data. Used by interrupt handler to send next data byte to slave.
 *
 * \param[in,out] module  Pointer to software module structure
 */
static void _i2c_master_write(struct i2c_master_module *const module)
{
    5044:	b570      	push	{r4, r5, r6, lr}
    5046:	0004      	movs	r4, r0
	/* Sanity check arguments. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    5048:	6806      	ldr	r6, [r0, #0]

	/* Check for ack from slave */
	if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK)
    504a:	8b73      	ldrh	r3, [r6, #26]
    504c:	075b      	lsls	r3, r3, #29
    504e:	d503      	bpl.n	5058 <_i2c_master_write+0x14>
	{
		/* Set status */
		module->status = STATUS_ERR_OVERFLOW;
    5050:	221e      	movs	r2, #30
    5052:	2325      	movs	r3, #37	; 0x25
    5054:	54c2      	strb	r2, [r0, r3]
		/* Do not write more data */
		return;
    5056:	e00f      	b.n	5078 <_i2c_master_write+0x34>
	}

	/* Find index to get next byte in buffer */
	uint16_t buffer_index = module->buffer_length;
    5058:	8b43      	ldrh	r3, [r0, #26]
	buffer_index -= module->buffer_remaining;
    505a:	8b85      	ldrh	r5, [r0, #28]
    505c:	1b5d      	subs	r5, r3, r5
    505e:	b2ad      	uxth	r5, r5

	module->buffer_remaining--;
    5060:	8b83      	ldrh	r3, [r0, #28]
    5062:	3b01      	subs	r3, #1
    5064:	b29b      	uxth	r3, r3
    5066:	8383      	strh	r3, [r0, #28]

	/* Write byte from buffer to slave */
	_i2c_master_wait_for_sync(module);
    5068:	4b04      	ldr	r3, [pc, #16]	; (507c <_i2c_master_write+0x38>)
    506a:	4798      	blx	r3
	i2c_module->DATA.reg = module->buffer[buffer_index];
    506c:	6a23      	ldr	r3, [r4, #32]
    506e:	195d      	adds	r5, r3, r5
    5070:	782b      	ldrb	r3, [r5, #0]
    5072:	b2db      	uxtb	r3, r3
    5074:	2228      	movs	r2, #40	; 0x28
    5076:	54b3      	strb	r3, [r6, r2]
}
    5078:	bd70      	pop	{r4, r5, r6, pc}
    507a:	46c0      	nop			; (mov r8, r8)
    507c:	00004fb5 	.word	0x00004fb5

00005080 <_i2c_master_interrupt_handler>:
 *
 * \param[in] instance  SERCOM instance that triggered the interrupt
 */
void _i2c_master_interrupt_handler(
		uint8_t instance)
{
    5080:	b570      	push	{r4, r5, r6, lr}
	/* Get software module for callback handling */
	struct i2c_master_module *module =
    5082:	0080      	lsls	r0, r0, #2
    5084:	4b6f      	ldr	r3, [pc, #444]	; (5244 <_i2c_master_interrupt_handler+0x1c4>)
    5086:	58c4      	ldr	r4, [r0, r3]
			(struct i2c_master_module*)_sercom_instances[instance];

	Assert(module);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
    5088:	6825      	ldr	r5, [r4, #0]
	bool sclsm_flag = i2c_module->CTRLA.bit.SCLSM;
    508a:	682b      	ldr	r3, [r5, #0]
    508c:	011b      	lsls	r3, r3, #4
    508e:	0fda      	lsrs	r2, r3, #31

	/* Combine callback registered and enabled masks */
	uint8_t callback_mask = module->enabled_callback;
    5090:	7e63      	ldrb	r3, [r4, #25]
	callback_mask &= module->registered_callback;
    5092:	7e26      	ldrb	r6, [r4, #24]
    5094:	401e      	ands	r6, r3

	/* Check if the module should respond to address ack */
	if ((module->buffer_length <= 0) && (module->buffer_remaining > 0)) {
    5096:	8b63      	ldrh	r3, [r4, #26]
    5098:	b29b      	uxth	r3, r3
    509a:	2b00      	cmp	r3, #0
    509c:	d135      	bne.n	510a <_i2c_master_interrupt_handler+0x8a>
    509e:	8ba3      	ldrh	r3, [r4, #28]
    50a0:	b29b      	uxth	r3, r3
    50a2:	2b00      	cmp	r3, #0
    50a4:	d031      	beq.n	510a <_i2c_master_interrupt_handler+0x8a>
	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Check for error. Ignore bus-error; workaround for bus state stuck in
	 * BUSY.
	 */
	if (i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB)
    50a6:	7e2b      	ldrb	r3, [r5, #24]
    50a8:	07db      	lsls	r3, r3, #31
    50aa:	d508      	bpl.n	50be <_i2c_master_interrupt_handler+0x3e>
	{
		/* Clear write interrupt flag */
		i2c_module->INTFLAG.reg = SERCOM_I2CM_INTENCLR_MB;
    50ac:	2301      	movs	r3, #1
    50ae:	762b      	strb	r3, [r5, #24]

		/* Check arbitration */
		if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_ARBLOST) {
    50b0:	8b6b      	ldrh	r3, [r5, #26]
    50b2:	079b      	lsls	r3, r3, #30
    50b4:	d516      	bpl.n	50e4 <_i2c_master_interrupt_handler+0x64>
			/* Return busy */
			module->status = STATUS_ERR_PACKET_COLLISION;
    50b6:	2241      	movs	r2, #65	; 0x41
    50b8:	2325      	movs	r3, #37	; 0x25
    50ba:	54e2      	strb	r2, [r4, r3]
    50bc:	e012      	b.n	50e4 <_i2c_master_interrupt_handler+0x64>
		}
	} else if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK) {
    50be:	8b6b      	ldrh	r3, [r5, #26]
    50c0:	075b      	lsls	r3, r3, #29
    50c2:	d50f      	bpl.n	50e4 <_i2c_master_interrupt_handler+0x64>
		/* Return bad address value */
		module->status           = STATUS_ERR_BAD_ADDRESS;
    50c4:	2218      	movs	r2, #24
    50c6:	2325      	movs	r3, #37	; 0x25
    50c8:	54e2      	strb	r2, [r4, r3]
		module->buffer_remaining = 0;
    50ca:	2300      	movs	r3, #0
    50cc:	83a3      	strh	r3, [r4, #28]

		if (module->send_stop) {
    50ce:	7aa3      	ldrb	r3, [r4, #10]
    50d0:	2b00      	cmp	r3, #0
    50d2:	d007      	beq.n	50e4 <_i2c_master_interrupt_handler+0x64>
			/* Send stop condition */
			_i2c_master_wait_for_sync(module);
    50d4:	0020      	movs	r0, r4
    50d6:	4b5c      	ldr	r3, [pc, #368]	; (5248 <_i2c_master_interrupt_handler+0x1c8>)
    50d8:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
    50da:	686b      	ldr	r3, [r5, #4]
    50dc:	22c0      	movs	r2, #192	; 0xc0
    50de:	0292      	lsls	r2, r2, #10
    50e0:	4313      	orrs	r3, r2
    50e2:	606b      	str	r3, [r5, #4]
		}
	}

	module->buffer_length = module->buffer_remaining;
    50e4:	8ba3      	ldrh	r3, [r4, #28]
    50e6:	b29b      	uxth	r3, r3
    50e8:	8363      	strh	r3, [r4, #26]

	/* Check for status OK. */
	if (module->status == STATUS_BUSY) {
    50ea:	2325      	movs	r3, #37	; 0x25
    50ec:	5ce3      	ldrb	r3, [r4, r3]
    50ee:	2b05      	cmp	r3, #5
    50f0:	d156      	bne.n	51a0 <_i2c_master_interrupt_handler+0x120>
		/* Call function based on transfer direction. */
		if (module->transfer_direction == I2C_TRANSFER_WRITE) {
    50f2:	331f      	adds	r3, #31
    50f4:	5ce3      	ldrb	r3, [r4, r3]
    50f6:	2b00      	cmp	r3, #0
    50f8:	d103      	bne.n	5102 <_i2c_master_interrupt_handler+0x82>
			_i2c_master_write(module);
    50fa:	0020      	movs	r0, r4
    50fc:	4b53      	ldr	r3, [pc, #332]	; (524c <_i2c_master_interrupt_handler+0x1cc>)
    50fe:	4798      	blx	r3
    5100:	e04e      	b.n	51a0 <_i2c_master_interrupt_handler+0x120>
		} else {
			_i2c_master_read(module);
    5102:	0020      	movs	r0, r4
    5104:	4b52      	ldr	r3, [pc, #328]	; (5250 <_i2c_master_interrupt_handler+0x1d0>)
    5106:	4798      	blx	r3
    5108:	e04a      	b.n	51a0 <_i2c_master_interrupt_handler+0x120>
	if ((module->buffer_length <= 0) && (module->buffer_remaining > 0)) {
		/* Call function for address response */
		_i2c_master_async_address_response(module);

	/* Check if buffer write is done */
	} else if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
    510a:	8b63      	ldrh	r3, [r4, #26]
    510c:	b29b      	uxth	r3, r3
    510e:	2b00      	cmp	r3, #0
    5110:	d026      	beq.n	5160 <_i2c_master_interrupt_handler+0xe0>
    5112:	8ba3      	ldrh	r3, [r4, #28]
    5114:	b29b      	uxth	r3, r3
    5116:	2b00      	cmp	r3, #0
    5118:	d122      	bne.n	5160 <_i2c_master_interrupt_handler+0xe0>
			(module->status == STATUS_BUSY) &&
    511a:	3325      	adds	r3, #37	; 0x25
    511c:	5ce3      	ldrb	r3, [r4, r3]
	if ((module->buffer_length <= 0) && (module->buffer_remaining > 0)) {
		/* Call function for address response */
		_i2c_master_async_address_response(module);

	/* Check if buffer write is done */
	} else if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
    511e:	2b05      	cmp	r3, #5
    5120:	d11e      	bne.n	5160 <_i2c_master_interrupt_handler+0xe0>
			(module->status == STATUS_BUSY) &&
			(module->transfer_direction == I2C_TRANSFER_WRITE)) {
    5122:	331f      	adds	r3, #31
    5124:	5ce3      	ldrb	r3, [r4, r3]
		/* Call function for address response */
		_i2c_master_async_address_response(module);

	/* Check if buffer write is done */
	} else if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
			(module->status == STATUS_BUSY) &&
    5126:	2b00      	cmp	r3, #0
    5128:	d11a      	bne.n	5160 <_i2c_master_interrupt_handler+0xe0>
			(module->transfer_direction == I2C_TRANSFER_WRITE)) {
		/* Stop packet operation */
		i2c_module->INTENCLR.reg =
    512a:	3303      	adds	r3, #3
    512c:	752b      	strb	r3, [r5, #20]
				SERCOM_I2CM_INTENCLR_MB | SERCOM_I2CM_INTENCLR_SB;

		module->buffer_length = 0;
    512e:	2300      	movs	r3, #0
    5130:	8363      	strh	r3, [r4, #26]
		module->status        = STATUS_OK;
    5132:	3325      	adds	r3, #37	; 0x25
    5134:	2200      	movs	r2, #0
    5136:	54e2      	strb	r2, [r4, r3]

		if (module->send_stop) {
    5138:	7aa3      	ldrb	r3, [r4, #10]
    513a:	2b00      	cmp	r3, #0
    513c:	d008      	beq.n	5150 <_i2c_master_interrupt_handler+0xd0>
			/* Send stop condition */
			_i2c_master_wait_for_sync(module);
    513e:	0020      	movs	r0, r4
    5140:	4b41      	ldr	r3, [pc, #260]	; (5248 <_i2c_master_interrupt_handler+0x1c8>)
    5142:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
    5144:	686b      	ldr	r3, [r5, #4]
    5146:	22c0      	movs	r2, #192	; 0xc0
    5148:	0292      	lsls	r2, r2, #10
    514a:	4313      	orrs	r3, r2
    514c:	606b      	str	r3, [r5, #4]
    514e:	e001      	b.n	5154 <_i2c_master_interrupt_handler+0xd4>
		} else {
			/* Clear write interrupt flag */
			i2c_module->INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    5150:	2301      	movs	r3, #1
    5152:	762b      	strb	r3, [r5, #24]
		}
		
		if (callback_mask & (1 << I2C_MASTER_CALLBACK_WRITE_COMPLETE)) {
    5154:	07f3      	lsls	r3, r6, #31
    5156:	d523      	bpl.n	51a0 <_i2c_master_interrupt_handler+0x120>
			module->callbacks[I2C_MASTER_CALLBACK_WRITE_COMPLETE](module);
    5158:	68e3      	ldr	r3, [r4, #12]
    515a:	0020      	movs	r0, r4
    515c:	4798      	blx	r3
    515e:	e01f      	b.n	51a0 <_i2c_master_interrupt_handler+0x120>
		}

	/* Continue buffer write/read */
	} else if ((module->buffer_length > 0) && (module->buffer_remaining > 0)){
    5160:	8b63      	ldrh	r3, [r4, #26]
    5162:	b29b      	uxth	r3, r3
    5164:	2b00      	cmp	r3, #0
    5166:	d01b      	beq.n	51a0 <_i2c_master_interrupt_handler+0x120>
    5168:	8ba3      	ldrh	r3, [r4, #28]
    516a:	b29b      	uxth	r3, r3
    516c:	2b00      	cmp	r3, #0
    516e:	d017      	beq.n	51a0 <_i2c_master_interrupt_handler+0x120>
		/* Check that bus ownership is not lost */
		if ((!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) &&
    5170:	8b6b      	ldrh	r3, [r5, #26]
    5172:	069b      	lsls	r3, r3, #26
    5174:	d409      	bmi.n	518a <_i2c_master_interrupt_handler+0x10a>
    5176:	2a00      	cmp	r2, #0
    5178:	d003      	beq.n	5182 <_i2c_master_interrupt_handler+0x102>
				(!(sclsm_flag && (module->buffer_remaining == 1))))	{
    517a:	8ba3      	ldrh	r3, [r4, #28]
    517c:	b29b      	uxth	r3, r3
    517e:	2b01      	cmp	r3, #1
    5180:	d003      	beq.n	518a <_i2c_master_interrupt_handler+0x10a>
			module->status = STATUS_ERR_PACKET_COLLISION;
    5182:	2241      	movs	r2, #65	; 0x41
    5184:	2325      	movs	r3, #37	; 0x25
    5186:	54e2      	strb	r2, [r4, r3]
    5188:	e00a      	b.n	51a0 <_i2c_master_interrupt_handler+0x120>
		} else if (module->transfer_direction == I2C_TRANSFER_WRITE) {
    518a:	2324      	movs	r3, #36	; 0x24
    518c:	5ce3      	ldrb	r3, [r4, r3]
    518e:	2b00      	cmp	r3, #0
    5190:	d103      	bne.n	519a <_i2c_master_interrupt_handler+0x11a>
			_i2c_master_write(module);
    5192:	0020      	movs	r0, r4
    5194:	4b2d      	ldr	r3, [pc, #180]	; (524c <_i2c_master_interrupt_handler+0x1cc>)
    5196:	4798      	blx	r3
    5198:	e002      	b.n	51a0 <_i2c_master_interrupt_handler+0x120>
		} else {
			_i2c_master_read(module);
    519a:	0020      	movs	r0, r4
    519c:	4b2c      	ldr	r3, [pc, #176]	; (5250 <_i2c_master_interrupt_handler+0x1d0>)
    519e:	4798      	blx	r3
		}
	}

	/* Check if read buffer transfer is complete */
	if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
    51a0:	8b63      	ldrh	r3, [r4, #26]
    51a2:	b29b      	uxth	r3, r3
    51a4:	2b00      	cmp	r3, #0
    51a6:	d02a      	beq.n	51fe <_i2c_master_interrupt_handler+0x17e>
    51a8:	8ba3      	ldrh	r3, [r4, #28]
    51aa:	b29b      	uxth	r3, r3
    51ac:	2b00      	cmp	r3, #0
    51ae:	d126      	bne.n	51fe <_i2c_master_interrupt_handler+0x17e>
			(module->status == STATUS_BUSY) &&
    51b0:	3325      	adds	r3, #37	; 0x25
    51b2:	5ce3      	ldrb	r3, [r4, r3]
			_i2c_master_read(module);
		}
	}

	/* Check if read buffer transfer is complete */
	if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
    51b4:	2b05      	cmp	r3, #5
    51b6:	d122      	bne.n	51fe <_i2c_master_interrupt_handler+0x17e>
			(module->status == STATUS_BUSY) &&
			(module->transfer_direction == I2C_TRANSFER_READ)) {
    51b8:	331f      	adds	r3, #31
    51ba:	5ce3      	ldrb	r3, [r4, r3]
		}
	}

	/* Check if read buffer transfer is complete */
	if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
			(module->status == STATUS_BUSY) &&
    51bc:	2b01      	cmp	r3, #1
    51be:	d11e      	bne.n	51fe <_i2c_master_interrupt_handler+0x17e>
			(module->transfer_direction == I2C_TRANSFER_READ)) {
		
		/* Clear read interrupt flag */
		if (i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB) {
    51c0:	7e2b      	ldrb	r3, [r5, #24]
    51c2:	079b      	lsls	r3, r3, #30
    51c4:	d501      	bpl.n	51ca <_i2c_master_interrupt_handler+0x14a>
			i2c_module->INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    51c6:	2302      	movs	r3, #2
    51c8:	762b      	strb	r3, [r5, #24]
		}
		/* Stop packet operation */
		i2c_module->INTENCLR.reg =
    51ca:	2303      	movs	r3, #3
    51cc:	752b      	strb	r3, [r5, #20]
				SERCOM_I2CM_INTENCLR_MB | SERCOM_I2CM_INTENCLR_SB;
		module->buffer_length = 0;
    51ce:	2300      	movs	r3, #0
    51d0:	8363      	strh	r3, [r4, #26]
		module->status        = STATUS_OK;
    51d2:	3325      	adds	r3, #37	; 0x25
    51d4:	2200      	movs	r2, #0
    51d6:	54e2      	strb	r2, [r4, r3]

		/* Call appropriate callback if enabled and registered */
		if ((callback_mask & (1 << I2C_MASTER_CALLBACK_READ_COMPLETE))
    51d8:	07b3      	lsls	r3, r6, #30
    51da:	d507      	bpl.n	51ec <_i2c_master_interrupt_handler+0x16c>
				&& (module->transfer_direction == I2C_TRANSFER_READ)) {
    51dc:	2324      	movs	r3, #36	; 0x24
    51de:	5ce3      	ldrb	r3, [r4, r3]
    51e0:	2b01      	cmp	r3, #1
    51e2:	d103      	bne.n	51ec <_i2c_master_interrupt_handler+0x16c>
			module->callbacks[I2C_MASTER_CALLBACK_READ_COMPLETE](module);
    51e4:	6923      	ldr	r3, [r4, #16]
    51e6:	0020      	movs	r0, r4
    51e8:	4798      	blx	r3
    51ea:	e008      	b.n	51fe <_i2c_master_interrupt_handler+0x17e>
		} else if ((callback_mask & (1 << I2C_MASTER_CALLBACK_WRITE_COMPLETE))
    51ec:	07f3      	lsls	r3, r6, #31
    51ee:	d506      	bpl.n	51fe <_i2c_master_interrupt_handler+0x17e>
				&& (module->transfer_direction == I2C_TRANSFER_WRITE)) {
    51f0:	2324      	movs	r3, #36	; 0x24
    51f2:	5ce3      	ldrb	r3, [r4, r3]
    51f4:	2b00      	cmp	r3, #0
    51f6:	d102      	bne.n	51fe <_i2c_master_interrupt_handler+0x17e>
			module->callbacks[I2C_MASTER_CALLBACK_WRITE_COMPLETE](module);
    51f8:	68e3      	ldr	r3, [r4, #12]
    51fa:	0020      	movs	r0, r4
    51fc:	4798      	blx	r3
		}
	}

	/* Check for error */
	if ((module->status != STATUS_BUSY) && (module->status != STATUS_OK)) {
    51fe:	2325      	movs	r3, #37	; 0x25
    5200:	5ce3      	ldrb	r3, [r4, r3]
    5202:	2b05      	cmp	r3, #5
    5204:	d01c      	beq.n	5240 <_i2c_master_interrupt_handler+0x1c0>
    5206:	2325      	movs	r3, #37	; 0x25
    5208:	5ce3      	ldrb	r3, [r4, r3]
    520a:	2b00      	cmp	r3, #0
    520c:	d018      	beq.n	5240 <_i2c_master_interrupt_handler+0x1c0>
		/* Stop packet operation */
		i2c_module->INTENCLR.reg = SERCOM_I2CM_INTENCLR_MB |
    520e:	2303      	movs	r3, #3
    5210:	752b      	strb	r3, [r5, #20]
				SERCOM_I2CM_INTENCLR_SB;

		module->buffer_length = 0;
    5212:	2300      	movs	r3, #0
    5214:	8363      	strh	r3, [r4, #26]
		module->buffer_remaining = 0;
    5216:	83a3      	strh	r3, [r4, #28]

		/* Send nack and stop command unless arbitration is lost */
		if ((module->status != STATUS_ERR_PACKET_COLLISION) &&
    5218:	3325      	adds	r3, #37	; 0x25
    521a:	5ce3      	ldrb	r3, [r4, r3]
    521c:	2b41      	cmp	r3, #65	; 0x41
    521e:	d00a      	beq.n	5236 <_i2c_master_interrupt_handler+0x1b6>
    5220:	7aa3      	ldrb	r3, [r4, #10]
    5222:	2b00      	cmp	r3, #0
    5224:	d007      	beq.n	5236 <_i2c_master_interrupt_handler+0x1b6>
				module->send_stop) {
			_i2c_master_wait_for_sync(module);
    5226:	0020      	movs	r0, r4
    5228:	4b07      	ldr	r3, [pc, #28]	; (5248 <_i2c_master_interrupt_handler+0x1c8>)
    522a:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT |
    522c:	686b      	ldr	r3, [r5, #4]
    522e:	22e0      	movs	r2, #224	; 0xe0
    5230:	02d2      	lsls	r2, r2, #11
    5232:	4313      	orrs	r3, r2
    5234:	606b      	str	r3, [r5, #4]
					SERCOM_I2CM_CTRLB_CMD(3);
		}

		/* Call error callback if enabled and registered */
		if (callback_mask & (1 << I2C_MASTER_CALLBACK_ERROR)) {
    5236:	0773      	lsls	r3, r6, #29
    5238:	d502      	bpl.n	5240 <_i2c_master_interrupt_handler+0x1c0>
			module->callbacks[I2C_MASTER_CALLBACK_ERROR](module);
    523a:	6963      	ldr	r3, [r4, #20]
    523c:	0020      	movs	r0, r4
    523e:	4798      	blx	r3
		}
	}
}
    5240:	bd70      	pop	{r4, r5, r6, pc}
    5242:	46c0      	nop			; (mov r8, r8)
    5244:	20001344 	.word	0x20001344
    5248:	00004fb5 	.word	0x00004fb5
    524c:	00005045 	.word	0x00005045
    5250:	00004fc1 	.word	0x00004fc1

00005254 <WDT_Handler>:
	}
}

/** Handler for the WDT hardware module interrupt. */
void WDT_Handler(void)
{
    5254:	b510      	push	{r4, lr}
 */
static inline void wdt_clear_early_warning(void)
{
	Wdt *const WDT_module = WDT;

	WDT_module->INTFLAG.reg = WDT_INTFLAG_EW;
    5256:	2201      	movs	r2, #1
    5258:	4b03      	ldr	r3, [pc, #12]	; (5268 <WDT_Handler+0x14>)
    525a:	719a      	strb	r2, [r3, #6]
	wdt_clear_early_warning();

	if (wdt_early_warning_callback) {
    525c:	4b03      	ldr	r3, [pc, #12]	; (526c <WDT_Handler+0x18>)
    525e:	681b      	ldr	r3, [r3, #0]
    5260:	2b00      	cmp	r3, #0
    5262:	d000      	beq.n	5266 <WDT_Handler+0x12>
		wdt_early_warning_callback();
    5264:	4798      	blx	r3
	}
}
    5266:	bd10      	pop	{r4, pc}
    5268:	40001c00 	.word	0x40001c00
    526c:	20000fa8 	.word	0x20000fa8

00005270 <bme280_compensate_temperature_int32>:
 *
 *  @return Returns the actual temperature
 *
*/
s32 bme280_compensate_temperature_int32(s32 v_uncomp_temperature_s32)
{
    5270:	b510      	push	{r4, lr}

	/* calculate x1*/
	v_x1_u32r  =
	((((v_uncomp_temperature_s32
	>> BME280_SHIFT_BIT_POSITION_BY_03_BITS) -
	((s32)p_bme280->cal_param.dig_T1
    5272:	4b0c      	ldr	r3, [pc, #48]	; (52a4 <bme280_compensate_temperature_int32+0x34>)
    5274:	6819      	ldr	r1, [r3, #0]
    5276:	880a      	ldrh	r2, [r1, #0]
	BME280_SHIFT_BIT_POSITION_BY_11_BITS;
	/* calculate x2*/
	v_x2_u32r  = (((((v_uncomp_temperature_s32
	>> BME280_SHIFT_BIT_POSITION_BY_04_BITS) -
	((s32)p_bme280->cal_param.dig_T1))
	* ((v_uncomp_temperature_s32 >> BME280_SHIFT_BIT_POSITION_BY_04_BITS) -
    5278:	1103      	asrs	r3, r0, #4
    527a:	1a9b      	subs	r3, r3, r2
	((s32)p_bme280->cal_param.dig_T1)))
	>> BME280_SHIFT_BIT_POSITION_BY_12_BITS) *
	((s32)p_bme280->cal_param.dig_T3))
	>> BME280_SHIFT_BIT_POSITION_BY_14_BITS;
	/* calculate t_fine*/
	p_bme280->cal_param.t_fine = v_x1_u32r + v_x2_u32r;
    527c:	10c0      	asrs	r0, r0, #3
    527e:	0052      	lsls	r2, r2, #1
    5280:	1a80      	subs	r0, r0, r2
    5282:	2402      	movs	r4, #2
    5284:	5f0a      	ldrsh	r2, [r1, r4]
    5286:	4350      	muls	r0, r2
    5288:	12c0      	asrs	r0, r0, #11
    528a:	435b      	muls	r3, r3
    528c:	131b      	asrs	r3, r3, #12
    528e:	2404      	movs	r4, #4
    5290:	5f0a      	ldrsh	r2, [r1, r4]
    5292:	4353      	muls	r3, r2
    5294:	139b      	asrs	r3, r3, #14
    5296:	18c0      	adds	r0, r0, r3
    5298:	6248      	str	r0, [r1, #36]	; 0x24
	/* calculate temperature*/
	temperature  = (p_bme280->cal_param.t_fine * 5 + 128)
	>> BME280_SHIFT_BIT_POSITION_BY_08_BITS;
	return temperature;
    529a:	0083      	lsls	r3, r0, #2
    529c:	1818      	adds	r0, r3, r0
    529e:	3080      	adds	r0, #128	; 0x80
    52a0:	1200      	asrs	r0, r0, #8
}
    52a2:	bd10      	pop	{r4, pc}
    52a4:	200002d0 	.word	0x200002d0

000052a8 <bme280_compensate_pressure_int32>:
 *
 *  @return Return the actual pressure output as u32
 *
*/
u32 bme280_compensate_pressure_int32(s32 v_uncomp_pressure_s32)
{
    52a8:	b570      	push	{r4, r5, r6, lr}
	s32 v_x1_u32 = BME280_INIT_VALUE;
	s32 v_x2_u32 = BME280_INIT_VALUE;
	u32 v_pressure_u32 = BME280_INIT_VALUE;

	/* calculate x1*/
	v_x1_u32 = (((s32)p_bme280->cal_param.t_fine)
    52aa:	4b29      	ldr	r3, [pc, #164]	; (5350 <bme280_compensate_pressure_int32+0xa8>)
    52ac:	681c      	ldr	r4, [r3, #0]
    52ae:	6a63      	ldr	r3, [r4, #36]	; 0x24
    52b0:	105b      	asrs	r3, r3, #1
    52b2:	4a28      	ldr	r2, [pc, #160]	; (5354 <bme280_compensate_pressure_int32+0xac>)
    52b4:	4694      	mov	ip, r2
    52b6:	4463      	add	r3, ip
	>> BME280_SHIFT_BIT_POSITION_BY_01_BIT) - (s32)64000;
	/* calculate x2*/
	v_x2_u32 = (((v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_02_BITS)
	* (v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_02_BITS)
    52b8:	1099      	asrs	r1, r3, #2
    52ba:	4349      	muls	r1, r1

	/* calculate x1*/
	v_x1_u32 = (((s32)p_bme280->cal_param.t_fine)
	>> BME280_SHIFT_BIT_POSITION_BY_01_BIT) - (s32)64000;
	/* calculate x2*/
	v_x2_u32 = (((v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_02_BITS)
    52bc:	12cd      	asrs	r5, r1, #11
    52be:	2610      	movs	r6, #16
    52c0:	5fa2      	ldrsh	r2, [r4, r6]
    52c2:	4355      	muls	r5, r2
	/* calculate x2*/
	v_x2_u32 = v_x2_u32 + ((v_x1_u32 *
	((s32)p_bme280->cal_param.dig_P5))
	<< BME280_SHIFT_BIT_POSITION_BY_01_BIT);
	/* calculate x2*/
	v_x2_u32 = (v_x2_u32 >> BME280_SHIFT_BIT_POSITION_BY_02_BITS) +
    52c4:	260e      	movs	r6, #14
    52c6:	5fa2      	ldrsh	r2, [r4, r6]
    52c8:	435a      	muls	r2, r3
    52ca:	0052      	lsls	r2, r2, #1
    52cc:	1952      	adds	r2, r2, r5
    52ce:	1092      	asrs	r2, r2, #2
	/* calculate x1*/
	v_x1_u32 = (((p_bme280->cal_param.dig_P3 *
	(((v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_02_BITS) *
	(v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_02_BITS))
	>> BME280_SHIFT_BIT_POSITION_BY_13_BITS))
	>> BME280_SHIFT_BIT_POSITION_BY_03_BITS) +
    52d0:	260a      	movs	r6, #10
    52d2:	5fa5      	ldrsh	r5, [r4, r6]
    52d4:	1349      	asrs	r1, r1, #13
    52d6:	4369      	muls	r1, r5
    52d8:	10c9      	asrs	r1, r1, #3
    52da:	2608      	movs	r6, #8
    52dc:	5fa5      	ldrsh	r5, [r4, r6]
    52de:	436b      	muls	r3, r5
    52e0:	105b      	asrs	r3, r3, #1
    52e2:	18cb      	adds	r3, r1, r3
	((((s32)p_bme280->cal_param.dig_P2) *
	v_x1_u32) >> BME280_SHIFT_BIT_POSITION_BY_01_BIT))
	>> BME280_SHIFT_BIT_POSITION_BY_18_BITS;
	/* calculate x1*/
	v_x1_u32 = ((((32768 + v_x1_u32)) *
    52e4:	149b      	asrs	r3, r3, #18
    52e6:	2180      	movs	r1, #128	; 0x80
    52e8:	0209      	lsls	r1, r1, #8
    52ea:	468c      	mov	ip, r1
    52ec:	4463      	add	r3, ip
    52ee:	88e1      	ldrh	r1, [r4, #6]
    52f0:	4359      	muls	r1, r3
    52f2:	13c9      	asrs	r1, r1, #15
	((s32)p_bme280->cal_param.dig_P1))
	>> BME280_SHIFT_BIT_POSITION_BY_15_BITS);
	/* calculate pressure*/
	v_pressure_u32 =
    52f4:	4243      	negs	r3, r0
    52f6:	250c      	movs	r5, #12
    52f8:	5f60      	ldrsh	r0, [r4, r5]
    52fa:	0400      	lsls	r0, r0, #16
    52fc:	1880      	adds	r0, r0, r2
    52fe:	1300      	asrs	r0, r0, #12
    5300:	1a18      	subs	r0, r3, r0
    5302:	4d15      	ldr	r5, [pc, #84]	; (5358 <bme280_compensate_pressure_int32+0xb0>)
    5304:	4368      	muls	r0, r5
	(((u32)(((s32)1048576) - v_uncomp_pressure_s32)
	- (v_x2_u32 >> BME280_SHIFT_BIT_POSITION_BY_12_BITS))) * 3125;
	if (v_pressure_u32
    5306:	4b15      	ldr	r3, [pc, #84]	; (535c <bme280_compensate_pressure_int32+0xb4>)
    5308:	18c2      	adds	r2, r0, r3
    530a:	d406      	bmi.n	531a <bme280_compensate_pressure_int32+0x72>
			v_pressure_u32 =
			(v_pressure_u32
			<< BME280_SHIFT_BIT_POSITION_BY_01_BIT) /
			((u32)v_x1_u32);
		else
			return BME280_INVALID_DATA;
    530c:	2000      	movs	r0, #0
	(((u32)(((s32)1048576) - v_uncomp_pressure_s32)
	- (v_x2_u32 >> BME280_SHIFT_BIT_POSITION_BY_12_BITS))) * 3125;
	if (v_pressure_u32
	< 0x80000000)
		/* Avoid exception caused by division by zero */
		if (v_x1_u32 != BME280_INIT_VALUE)
    530e:	2900      	cmp	r1, #0
    5310:	d01c      	beq.n	534c <bme280_compensate_pressure_int32+0xa4>
			v_pressure_u32 =
			(v_pressure_u32
			<< BME280_SHIFT_BIT_POSITION_BY_01_BIT) /
    5312:	0050      	lsls	r0, r2, #1
	- (v_x2_u32 >> BME280_SHIFT_BIT_POSITION_BY_12_BITS))) * 3125;
	if (v_pressure_u32
	< 0x80000000)
		/* Avoid exception caused by division by zero */
		if (v_x1_u32 != BME280_INIT_VALUE)
			v_pressure_u32 =
    5314:	4b12      	ldr	r3, [pc, #72]	; (5360 <bme280_compensate_pressure_int32+0xb8>)
    5316:	4798      	blx	r3
    5318:	e006      	b.n	5328 <bme280_compensate_pressure_int32+0x80>
		/* Avoid exception caused by division by zero */
		if (v_x1_u32 != BME280_INIT_VALUE)
			v_pressure_u32 = (v_pressure_u32
			/ (u32)v_x1_u32) * 2;
		else
			return BME280_INVALID_DATA;
    531a:	2000      	movs	r0, #0
			((u32)v_x1_u32);
		else
			return BME280_INVALID_DATA;
	else
		/* Avoid exception caused by division by zero */
		if (v_x1_u32 != BME280_INIT_VALUE)
    531c:	2900      	cmp	r1, #0
    531e:	d015      	beq.n	534c <bme280_compensate_pressure_int32+0xa4>
			v_pressure_u32 = (v_pressure_u32
			/ (u32)v_x1_u32) * 2;
    5320:	0010      	movs	r0, r2
    5322:	4b0f      	ldr	r3, [pc, #60]	; (5360 <bme280_compensate_pressure_int32+0xb8>)
    5324:	4798      	blx	r3
		else
			return BME280_INVALID_DATA;
	else
		/* Avoid exception caused by division by zero */
		if (v_x1_u32 != BME280_INIT_VALUE)
			v_pressure_u32 = (v_pressure_u32
    5326:	0040      	lsls	r0, r0, #1
		else
			return BME280_INVALID_DATA;

		v_x1_u32 = (((s32)p_bme280->cal_param.dig_P9) *
		((s32)(((v_pressure_u32 >> BME280_SHIFT_BIT_POSITION_BY_03_BITS)
		* (v_pressure_u32 >> BME280_SHIFT_BIT_POSITION_BY_03_BITS))
    5328:	08c3      	lsrs	r3, r0, #3
		>> BME280_SHIFT_BIT_POSITION_BY_12_BITS;
		v_x2_u32 = (((s32)(v_pressure_u32
		>> BME280_SHIFT_BIT_POSITION_BY_02_BITS)) *
		((s32)p_bme280->cal_param.dig_P8))
		>> BME280_SHIFT_BIT_POSITION_BY_13_BITS;
		v_pressure_u32 = (u32)((s32)v_pressure_u32 +
    532a:	435b      	muls	r3, r3
    532c:	0b5b      	lsrs	r3, r3, #13
    532e:	2216      	movs	r2, #22
    5330:	5ea1      	ldrsh	r1, [r4, r2]
    5332:	434b      	muls	r3, r1
    5334:	1319      	asrs	r1, r3, #12
    5336:	0883      	lsrs	r3, r0, #2
    5338:	2514      	movs	r5, #20
    533a:	5f62      	ldrsh	r2, [r4, r5]
    533c:	4353      	muls	r3, r2
    533e:	135b      	asrs	r3, r3, #13
    5340:	18cb      	adds	r3, r1, r3
    5342:	2112      	movs	r1, #18
    5344:	5e62      	ldrsh	r2, [r4, r1]
    5346:	189b      	adds	r3, r3, r2
    5348:	111b      	asrs	r3, r3, #4
		((v_x1_u32 + v_x2_u32 + p_bme280->cal_param.dig_P7)
		>> BME280_SHIFT_BIT_POSITION_BY_04_BITS));

	return v_pressure_u32;
    534a:	1818      	adds	r0, r3, r0
}
    534c:	bd70      	pop	{r4, r5, r6, pc}
    534e:	46c0      	nop			; (mov r8, r8)
    5350:	200002d0 	.word	0x200002d0
    5354:	ffff0600 	.word	0xffff0600
    5358:	00000c35 	.word	0x00000c35
    535c:	c3500000 	.word	0xc3500000
    5360:	0000a38d 	.word	0x0000a38d

00005364 <bme280_compensate_humidity_int32>:
 *
 *  @return Return the actual relative humidity output as u32
 *
*/
u32 bme280_compensate_humidity_int32(s32 v_uncomp_humidity_s32)
{
    5364:	b510      	push	{r4, lr}
	s32 v_x1_u32 = BME280_INIT_VALUE;

	/* calculate x1*/
	v_x1_u32 = (p_bme280->cal_param.t_fine - ((s32)76800));
    5366:	4b20      	ldr	r3, [pc, #128]	; (53e8 <bme280_compensate_humidity_int32+0x84>)
    5368:	681c      	ldr	r4, [r3, #0]
    536a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    536c:	4a1f      	ldr	r2, [pc, #124]	; (53ec <bme280_compensate_humidity_int32+0x88>)
    536e:	4694      	mov	ip, r2
    5370:	4463      	add	r3, ip
	v_x1_u32 = (((((v_uncomp_humidity_s32
	<< BME280_SHIFT_BIT_POSITION_BY_14_BITS) -
	(((s32)p_bme280->cal_param.dig_H4)
	<< BME280_SHIFT_BIT_POSITION_BY_20_BITS) -
	(((s32)p_bme280->cal_param.dig_H5) * v_x1_u32)) +
	((s32)16384)) >> BME280_SHIFT_BIT_POSITION_BY_15_BITS)
    5372:	0380      	lsls	r0, r0, #14
    5374:	211e      	movs	r1, #30
    5376:	5e62      	ldrsh	r2, [r4, r1]
    5378:	0512      	lsls	r2, r2, #20
    537a:	1a80      	subs	r0, r0, r2
    537c:	2120      	movs	r1, #32
    537e:	5e62      	ldrsh	r2, [r4, r1]
    5380:	435a      	muls	r2, r3
    5382:	1a82      	subs	r2, r0, r2
    5384:	2180      	movs	r1, #128	; 0x80
    5386:	01c9      	lsls	r1, r1, #7
    5388:	468c      	mov	ip, r1
    538a:	4462      	add	r2, ip
    538c:	13d2      	asrs	r2, r2, #15
	((s32)p_bme280->cal_param.dig_H6))
	>> BME280_SHIFT_BIT_POSITION_BY_10_BITS) *
	(((v_x1_u32 * ((s32)p_bme280->cal_param.dig_H3))
	>> BME280_SHIFT_BIT_POSITION_BY_11_BITS) + ((s32)32768)))
	>> BME280_SHIFT_BIT_POSITION_BY_10_BITS) + ((s32)2097152)) *
	((s32)p_bme280->cal_param.dig_H2) + 8192) >> 14));
    538e:	7f20      	ldrb	r0, [r4, #28]
    5390:	4358      	muls	r0, r3
    5392:	12c0      	asrs	r0, r0, #11
    5394:	2180      	movs	r1, #128	; 0x80
    5396:	0209      	lsls	r1, r1, #8
    5398:	468c      	mov	ip, r1
    539a:	4460      	add	r0, ip
	(((s32)p_bme280->cal_param.dig_H4)
	<< BME280_SHIFT_BIT_POSITION_BY_20_BITS) -
	(((s32)p_bme280->cal_param.dig_H5) * v_x1_u32)) +
	((s32)16384)) >> BME280_SHIFT_BIT_POSITION_BY_15_BITS)
	* (((((((v_x1_u32 *
	((s32)p_bme280->cal_param.dig_H6))
    539c:	2122      	movs	r1, #34	; 0x22
	>> BME280_SHIFT_BIT_POSITION_BY_10_BITS) *
	(((v_x1_u32 * ((s32)p_bme280->cal_param.dig_H3))
	>> BME280_SHIFT_BIT_POSITION_BY_11_BITS) + ((s32)32768)))
	>> BME280_SHIFT_BIT_POSITION_BY_10_BITS) + ((s32)2097152)) *
	((s32)p_bme280->cal_param.dig_H2) + 8192) >> 14));
    539e:	5661      	ldrsb	r1, [r4, r1]
    53a0:	4359      	muls	r1, r3
    53a2:	1289      	asrs	r1, r1, #10
    53a4:	000b      	movs	r3, r1
    53a6:	4343      	muls	r3, r0
    53a8:	129b      	asrs	r3, r3, #10
    53aa:	2180      	movs	r1, #128	; 0x80
    53ac:	0389      	lsls	r1, r1, #14
    53ae:	468c      	mov	ip, r1
    53b0:	4463      	add	r3, ip
    53b2:	201a      	movs	r0, #26
    53b4:	5e21      	ldrsh	r1, [r4, r0]
    53b6:	434b      	muls	r3, r1
    53b8:	2180      	movs	r1, #128	; 0x80
    53ba:	0189      	lsls	r1, r1, #6
    53bc:	468c      	mov	ip, r1
    53be:	4463      	add	r3, ip
    53c0:	139b      	asrs	r3, r3, #14
	s32 v_x1_u32 = BME280_INIT_VALUE;

	/* calculate x1*/
	v_x1_u32 = (p_bme280->cal_param.t_fine - ((s32)76800));
	/* calculate x1*/
	v_x1_u32 = (((((v_uncomp_humidity_s32
    53c2:	435a      	muls	r2, r3
	>> BME280_SHIFT_BIT_POSITION_BY_11_BITS) + ((s32)32768)))
	>> BME280_SHIFT_BIT_POSITION_BY_10_BITS) + ((s32)2097152)) *
	((s32)p_bme280->cal_param.dig_H2) + 8192) >> 14));
	v_x1_u32 = (v_x1_u32 - (((((v_x1_u32
	>> BME280_SHIFT_BIT_POSITION_BY_15_BITS) *
	(v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_15_BITS))
    53c4:	13d3      	asrs	r3, r2, #15
	>> BME280_SHIFT_BIT_POSITION_BY_10_BITS) *
	(((v_x1_u32 * ((s32)p_bme280->cal_param.dig_H3))
	>> BME280_SHIFT_BIT_POSITION_BY_11_BITS) + ((s32)32768)))
	>> BME280_SHIFT_BIT_POSITION_BY_10_BITS) + ((s32)2097152)) *
	((s32)p_bme280->cal_param.dig_H2) + 8192) >> 14));
	v_x1_u32 = (v_x1_u32 - (((((v_x1_u32
    53c6:	435b      	muls	r3, r3
    53c8:	11db      	asrs	r3, r3, #7
    53ca:	7e20      	ldrb	r0, [r4, #24]
    53cc:	4343      	muls	r3, r0
    53ce:	111b      	asrs	r3, r3, #4
    53d0:	1ad3      	subs	r3, r2, r3
	>> BME280_SHIFT_BIT_POSITION_BY_15_BITS) *
	(v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_15_BITS))
	>> BME280_SHIFT_BIT_POSITION_BY_07_BITS) *
	((s32)p_bme280->cal_param.dig_H1))
	>> BME280_SHIFT_BIT_POSITION_BY_04_BITS));
	v_x1_u32 = (v_x1_u32 < 0 ? 0 : v_x1_u32);
    53d2:	43d8      	mvns	r0, r3
    53d4:	17c0      	asrs	r0, r0, #31
	v_x1_u32 = (v_x1_u32 > 419430400 ?
	419430400 : v_x1_u32);
	return (u32)(v_x1_u32 >> BME280_SHIFT_BIT_POSITION_BY_12_BITS);
    53d6:	4003      	ands	r3, r0
    53d8:	22c8      	movs	r2, #200	; 0xc8
    53da:	0552      	lsls	r2, r2, #21
    53dc:	4293      	cmp	r3, r2
    53de:	dd00      	ble.n	53e2 <bme280_compensate_humidity_int32+0x7e>
    53e0:	0013      	movs	r3, r2
    53e2:	1318      	asrs	r0, r3, #12
}
    53e4:	bd10      	pop	{r4, pc}
    53e6:	46c0      	nop			; (mov r8, r8)
    53e8:	200002d0 	.word	0x200002d0
    53ec:	fffed400 	.word	0xfffed400

000053f0 <bme280_read_uncomp_pressure_temperature_humidity>:
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_read_uncomp_pressure_temperature_humidity(
s32 *v_uncomp_pressure_s32,
s32 *v_uncomp_temperature_s32, s32 *v_uncomp_humidity_s32)
{
    53f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    53f2:	b083      	sub	sp, #12
    53f4:	0006      	movs	r6, r0
    53f6:	000d      	movs	r5, r1
    53f8:	0014      	movs	r4, r2
	a_data_u8[1] - Temperature LSB
	a_data_u8[1] - Temperature LSB
	a_data_u8[1] - Humidity MSB
	a_data_u8[1] - Humidity LSB
	*/
	u8 a_data_u8[BME280_DATA_FRAME_SIZE] = {
    53fa:	2208      	movs	r2, #8
    53fc:	2100      	movs	r1, #0
    53fe:	4668      	mov	r0, sp
    5400:	4b18      	ldr	r3, [pc, #96]	; (5464 <bme280_read_uncomp_pressure_temperature_humidity+0x74>)
    5402:	4798      	blx	r3
	BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE};
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    5404:	4b18      	ldr	r3, [pc, #96]	; (5468 <bme280_read_uncomp_pressure_temperature_humidity+0x78>)
    5406:	681b      	ldr	r3, [r3, #0]
    5408:	2b00      	cmp	r3, #0
    540a:	d026      	beq.n	545a <bme280_read_uncomp_pressure_temperature_humidity+0x6a>
		return E_BME280_NULL_PTR;
		} else {
			com_rslt = p_bme280->BME280_BUS_READ_FUNC(
    540c:	2229      	movs	r2, #41	; 0x29
    540e:	5c98      	ldrb	r0, [r3, r2]
    5410:	6b5f      	ldr	r7, [r3, #52]	; 0x34
    5412:	2308      	movs	r3, #8
    5414:	466a      	mov	r2, sp
    5416:	21f7      	movs	r1, #247	; 0xf7
    5418:	47b8      	blx	r7
			p_bme280->dev_addr,
			BME280_PRESSURE_MSB_REG,
			a_data_u8, BME280_ALL_DATA_FRAME_LENGTH);
			/*Pressure*/
			*v_uncomp_pressure_s32 = (s32)((
    541a:	466b      	mov	r3, sp
    541c:	781b      	ldrb	r3, [r3, #0]
    541e:	031a      	lsls	r2, r3, #12
    5420:	466b      	mov	r3, sp
    5422:	785b      	ldrb	r3, [r3, #1]
    5424:	011b      	lsls	r3, r3, #4
    5426:	4313      	orrs	r3, r2
    5428:	466a      	mov	r2, sp
    542a:	7892      	ldrb	r2, [r2, #2]
    542c:	0912      	lsrs	r2, r2, #4
    542e:	4313      	orrs	r3, r2
    5430:	6033      	str	r3, [r6, #0]
			((u32)a_data_u8[
			BME280_DATA_FRAME_PRESSURE_XLSB_BYTE] >>
			BME280_SHIFT_BIT_POSITION_BY_04_BITS));

			/* Temperature */
			*v_uncomp_temperature_s32 = (s32)(((
    5432:	466b      	mov	r3, sp
    5434:	78db      	ldrb	r3, [r3, #3]
    5436:	031a      	lsls	r2, r3, #12
    5438:	466b      	mov	r3, sp
    543a:	791b      	ldrb	r3, [r3, #4]
    543c:	011b      	lsls	r3, r3, #4
    543e:	4313      	orrs	r3, r2
    5440:	466a      	mov	r2, sp
    5442:	7952      	ldrb	r2, [r2, #5]
    5444:	0912      	lsrs	r2, r2, #4
    5446:	4313      	orrs	r3, r2
    5448:	602b      	str	r3, [r5, #0]
			| ((u32)a_data_u8[
			BME280_DATA_FRAME_TEMPERATURE_XLSB_BYTE]
			>> BME280_SHIFT_BIT_POSITION_BY_04_BITS));

			/*Humidity*/
			*v_uncomp_humidity_s32 = (s32)((
    544a:	466b      	mov	r3, sp
    544c:	799b      	ldrb	r3, [r3, #6]
    544e:	021b      	lsls	r3, r3, #8
    5450:	466a      	mov	r2, sp
    5452:	79d2      	ldrb	r2, [r2, #7]
    5454:	4313      	orrs	r3, r2
    5456:	6023      	str	r3, [r4, #0]
			BME280_DATA_FRAME_HUMIDITY_MSB_BYTE]))
			<< BME280_SHIFT_BIT_POSITION_BY_08_BITS)|
			((u32)(a_data_u8[
			BME280_DATA_FRAME_HUMIDITY_LSB_BYTE])));
		}
	return com_rslt;
    5458:	e001      	b.n	545e <bme280_read_uncomp_pressure_temperature_humidity+0x6e>
	BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE};
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    545a:	207f      	movs	r0, #127	; 0x7f
    545c:	4240      	negs	r0, r0
			<< BME280_SHIFT_BIT_POSITION_BY_08_BITS)|
			((u32)(a_data_u8[
			BME280_DATA_FRAME_HUMIDITY_LSB_BYTE])));
		}
	return com_rslt;
}
    545e:	b003      	add	sp, #12
    5460:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5462:	46c0      	nop			; (mov r8, r8)
    5464:	0000a75f 	.word	0x0000a75f
    5468:	200002d0 	.word	0x200002d0

0000546c <bme280_read_pressure_temperature_humidity>:
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_read_pressure_temperature_humidity(
u32 *v_pressure_u32, s32 *v_temperature_s32, u32 *v_humidity_u32)
{
    546c:	b5f0      	push	{r4, r5, r6, r7, lr}
    546e:	b085      	sub	sp, #20
    5470:	0006      	movs	r6, r0
    5472:	000f      	movs	r7, r1
    5474:	0015      	movs	r5, r2
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	s32 v_uncomp_pressure_s32 = BME280_INIT_VALUE;
    5476:	2300      	movs	r3, #0
    5478:	9303      	str	r3, [sp, #12]
	s32 v_uncom_temperature_s32 = BME280_INIT_VALUE;
    547a:	9302      	str	r3, [sp, #8]
	s32 v_uncom_humidity_s32 = BME280_INIT_VALUE;
    547c:	9301      	str	r3, [sp, #4]
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    547e:	4b0e      	ldr	r3, [pc, #56]	; (54b8 <bme280_read_pressure_temperature_humidity+0x4c>)
    5480:	681b      	ldr	r3, [r3, #0]
    5482:	2b00      	cmp	r3, #0
    5484:	d013      	beq.n	54ae <bme280_read_pressure_temperature_humidity+0x42>
		return E_BME280_NULL_PTR;
		} else {
			/* read the uncompensated pressure,
			temperature and humidity*/
			com_rslt =
    5486:	aa01      	add	r2, sp, #4
    5488:	a902      	add	r1, sp, #8
    548a:	a803      	add	r0, sp, #12
    548c:	4b0b      	ldr	r3, [pc, #44]	; (54bc <bme280_read_pressure_temperature_humidity+0x50>)
    548e:	4798      	blx	r3
    5490:	0004      	movs	r4, r0
			bme280_read_uncomp_pressure_temperature_humidity(
			&v_uncomp_pressure_s32, &v_uncom_temperature_s32,
			&v_uncom_humidity_s32);
			/* read the true pressure, temperature and humidity*/
			*v_temperature_s32 =
			bme280_compensate_temperature_int32(
    5492:	9802      	ldr	r0, [sp, #8]
    5494:	4b0a      	ldr	r3, [pc, #40]	; (54c0 <bme280_read_pressure_temperature_humidity+0x54>)
    5496:	4798      	blx	r3
			com_rslt =
			bme280_read_uncomp_pressure_temperature_humidity(
			&v_uncomp_pressure_s32, &v_uncom_temperature_s32,
			&v_uncom_humidity_s32);
			/* read the true pressure, temperature and humidity*/
			*v_temperature_s32 =
    5498:	6038      	str	r0, [r7, #0]
			bme280_compensate_temperature_int32(
			v_uncom_temperature_s32);
			*v_pressure_u32 = bme280_compensate_pressure_int32(
    549a:	9803      	ldr	r0, [sp, #12]
    549c:	4b09      	ldr	r3, [pc, #36]	; (54c4 <bme280_read_pressure_temperature_humidity+0x58>)
    549e:	4798      	blx	r3
    54a0:	6030      	str	r0, [r6, #0]
			v_uncomp_pressure_s32);
			*v_humidity_u32 = bme280_compensate_humidity_int32(
    54a2:	9801      	ldr	r0, [sp, #4]
    54a4:	4b08      	ldr	r3, [pc, #32]	; (54c8 <bme280_read_pressure_temperature_humidity+0x5c>)
    54a6:	4798      	blx	r3
    54a8:	6028      	str	r0, [r5, #0]
			v_uncom_humidity_s32);
		}
	return com_rslt;
    54aa:	0020      	movs	r0, r4
    54ac:	e001      	b.n	54b2 <bme280_read_pressure_temperature_humidity+0x46>
	s32 v_uncomp_pressure_s32 = BME280_INIT_VALUE;
	s32 v_uncom_temperature_s32 = BME280_INIT_VALUE;
	s32 v_uncom_humidity_s32 = BME280_INIT_VALUE;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    54ae:	207f      	movs	r0, #127	; 0x7f
    54b0:	4240      	negs	r0, r0
			v_uncomp_pressure_s32);
			*v_humidity_u32 = bme280_compensate_humidity_int32(
			v_uncom_humidity_s32);
		}
	return com_rslt;
}
    54b2:	b005      	add	sp, #20
    54b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    54b6:	46c0      	nop			; (mov r8, r8)
    54b8:	200002d0 	.word	0x200002d0
    54bc:	000053f1 	.word	0x000053f1
    54c0:	00005271 	.word	0x00005271
    54c4:	000052a9 	.word	0x000052a9
    54c8:	00005365 	.word	0x00005365

000054cc <bme280_get_calib_param>:
 *	@retval -1 -> Error
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_get_calib_param(void)
{
    54cc:	b5f0      	push	{r4, r5, r6, r7, lr}
    54ce:	b089      	sub	sp, #36	; 0x24
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 a_data_u8[BME280_CALIB_DATA_SIZE] = {
    54d0:	221a      	movs	r2, #26
    54d2:	2100      	movs	r1, #0
    54d4:	a801      	add	r0, sp, #4
    54d6:	4b40      	ldr	r3, [pc, #256]	; (55d8 <bme280_get_calib_param+0x10c>)
    54d8:	4798      	blx	r3
	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE};
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    54da:	4b40      	ldr	r3, [pc, #256]	; (55dc <bme280_get_calib_param+0x110>)
    54dc:	681b      	ldr	r3, [r3, #0]
    54de:	2b00      	cmp	r3, #0
    54e0:	d100      	bne.n	54e4 <bme280_get_calib_param+0x18>
    54e2:	e075      	b.n	55d0 <bme280_get_calib_param+0x104>
		return E_BME280_NULL_PTR;
		} else {
			com_rslt = p_bme280->BME280_BUS_READ_FUNC(
    54e4:	ac01      	add	r4, sp, #4
    54e6:	2629      	movs	r6, #41	; 0x29
    54e8:	5d98      	ldrb	r0, [r3, r6]
    54ea:	6b5d      	ldr	r5, [r3, #52]	; 0x34
    54ec:	231a      	movs	r3, #26
    54ee:	0022      	movs	r2, r4
    54f0:	2188      	movs	r1, #136	; 0x88
    54f2:	47a8      	blx	r5
    54f4:	0007      	movs	r7, r0
			p_bme280->dev_addr,
			BME280_TEMPERATURE_CALIB_DIG_T1_LSB_REG,
			a_data_u8,
			BME280_PRESSURE_TEMPERATURE_CALIB_DATA_LENGTH);

			p_bme280->cal_param.dig_T1 = (u16)(((
    54f6:	4d39      	ldr	r5, [pc, #228]	; (55dc <bme280_get_calib_param+0x110>)
    54f8:	682b      	ldr	r3, [r5, #0]
    54fa:	7862      	ldrb	r2, [r4, #1]
    54fc:	0212      	lsls	r2, r2, #8
    54fe:	7821      	ldrb	r1, [r4, #0]
    5500:	430a      	orrs	r2, r1
    5502:	801a      	strh	r2, [r3, #0]
			(u16)((u8)a_data_u8[
			BME280_TEMPERATURE_CALIB_DIG_T1_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_TEMPERATURE_CALIB_DIG_T1_LSB]);
			p_bme280->cal_param.dig_T2 = (s16)(((
    5504:	2203      	movs	r2, #3
    5506:	56a2      	ldrsb	r2, [r4, r2]
    5508:	0212      	lsls	r2, r2, #8
    550a:	78a1      	ldrb	r1, [r4, #2]
    550c:	430a      	orrs	r2, r1
    550e:	805a      	strh	r2, [r3, #2]
			(s16)((s8)a_data_u8[
			BME280_TEMPERATURE_CALIB_DIG_T2_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_TEMPERATURE_CALIB_DIG_T2_LSB]);
			p_bme280->cal_param.dig_T3 = (s16)(((
    5510:	2205      	movs	r2, #5
    5512:	56a2      	ldrsb	r2, [r4, r2]
    5514:	0212      	lsls	r2, r2, #8
    5516:	7921      	ldrb	r1, [r4, #4]
    5518:	430a      	orrs	r2, r1
    551a:	809a      	strh	r2, [r3, #4]
			(s16)((s8)a_data_u8[
			BME280_TEMPERATURE_CALIB_DIG_T3_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_TEMPERATURE_CALIB_DIG_T3_LSB]);
			p_bme280->cal_param.dig_P1 = (u16)(((
    551c:	79e2      	ldrb	r2, [r4, #7]
    551e:	0212      	lsls	r2, r2, #8
    5520:	79a1      	ldrb	r1, [r4, #6]
    5522:	430a      	orrs	r2, r1
    5524:	80da      	strh	r2, [r3, #6]
			(u16)((u8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P1_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P1_LSB]);
			p_bme280->cal_param.dig_P2 = (s16)(((
    5526:	2209      	movs	r2, #9
    5528:	56a2      	ldrsb	r2, [r4, r2]
    552a:	0212      	lsls	r2, r2, #8
    552c:	7a21      	ldrb	r1, [r4, #8]
    552e:	430a      	orrs	r2, r1
    5530:	811a      	strh	r2, [r3, #8]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P2_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P2_LSB]);
			p_bme280->cal_param.dig_P3 = (s16)(((
    5532:	220b      	movs	r2, #11
    5534:	56a2      	ldrsb	r2, [r4, r2]
    5536:	0212      	lsls	r2, r2, #8
    5538:	7aa1      	ldrb	r1, [r4, #10]
    553a:	430a      	orrs	r2, r1
    553c:	815a      	strh	r2, [r3, #10]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P3_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P3_LSB]);
			p_bme280->cal_param.dig_P4 = (s16)(((
    553e:	220d      	movs	r2, #13
    5540:	56a2      	ldrsb	r2, [r4, r2]
    5542:	0212      	lsls	r2, r2, #8
    5544:	7b21      	ldrb	r1, [r4, #12]
    5546:	430a      	orrs	r2, r1
    5548:	819a      	strh	r2, [r3, #12]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P4_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P4_LSB]);
			p_bme280->cal_param.dig_P5 = (s16)(((
    554a:	220f      	movs	r2, #15
    554c:	56a2      	ldrsb	r2, [r4, r2]
    554e:	0212      	lsls	r2, r2, #8
    5550:	7ba1      	ldrb	r1, [r4, #14]
    5552:	430a      	orrs	r2, r1
    5554:	81da      	strh	r2, [r3, #14]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P5_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P5_LSB]);
			p_bme280->cal_param.dig_P6 = (s16)(((
    5556:	2211      	movs	r2, #17
    5558:	56a2      	ldrsb	r2, [r4, r2]
    555a:	0212      	lsls	r2, r2, #8
    555c:	7c21      	ldrb	r1, [r4, #16]
    555e:	430a      	orrs	r2, r1
    5560:	821a      	strh	r2, [r3, #16]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P6_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P6_LSB]);
			p_bme280->cal_param.dig_P7 = (s16)(((
    5562:	2213      	movs	r2, #19
    5564:	56a2      	ldrsb	r2, [r4, r2]
    5566:	0212      	lsls	r2, r2, #8
    5568:	7ca1      	ldrb	r1, [r4, #18]
    556a:	430a      	orrs	r2, r1
    556c:	825a      	strh	r2, [r3, #18]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P7_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P7_LSB]);
			p_bme280->cal_param.dig_P8 = (s16)(((
    556e:	2215      	movs	r2, #21
    5570:	56a2      	ldrsb	r2, [r4, r2]
    5572:	0212      	lsls	r2, r2, #8
    5574:	7d21      	ldrb	r1, [r4, #20]
    5576:	430a      	orrs	r2, r1
    5578:	829a      	strh	r2, [r3, #20]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P8_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P8_LSB]);
			p_bme280->cal_param.dig_P9 = (s16)(((
    557a:	2217      	movs	r2, #23
    557c:	56a2      	ldrsb	r2, [r4, r2]
    557e:	0212      	lsls	r2, r2, #8
    5580:	7da1      	ldrb	r1, [r4, #22]
    5582:	430a      	orrs	r2, r1
    5584:	82da      	strh	r2, [r3, #22]
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P9_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P9_LSB]);
			p_bme280->cal_param.dig_H1 =
			a_data_u8[BME280_HUMIDITY_CALIB_DIG_H1];
    5586:	7e62      	ldrb	r2, [r4, #25]
			p_bme280->cal_param.dig_P9 = (s16)(((
			(s16)((s8)a_data_u8[
			BME280_PRESSURE_CALIB_DIG_P9_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_PRESSURE_CALIB_DIG_P9_LSB]);
			p_bme280->cal_param.dig_H1 =
    5588:	761a      	strb	r2, [r3, #24]
			a_data_u8[BME280_HUMIDITY_CALIB_DIG_H1];
			com_rslt += p_bme280->BME280_BUS_READ_FUNC(
    558a:	5d98      	ldrb	r0, [r3, r6]
    558c:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    558e:	2307      	movs	r3, #7
    5590:	0022      	movs	r2, r4
    5592:	21e1      	movs	r1, #225	; 0xe1
    5594:	47b0      	blx	r6
    5596:	19c0      	adds	r0, r0, r7
			p_bme280->dev_addr,
			BME280_HUMIDITY_CALIB_DIG_H2_LSB_REG, a_data_u8,
			BME280_HUMIDITY_CALIB_DATA_LENGTH);
			p_bme280->cal_param.dig_H2 = (s16)(((
    5598:	682b      	ldr	r3, [r5, #0]
    559a:	2201      	movs	r2, #1
    559c:	56a2      	ldrsb	r2, [r4, r2]
    559e:	0212      	lsls	r2, r2, #8
    55a0:	7821      	ldrb	r1, [r4, #0]
    55a2:	430a      	orrs	r2, r1
    55a4:	835a      	strh	r2, [r3, #26]
			(s16)((s8)a_data_u8[
			BME280_HUMIDITY_CALIB_DIG_H2_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_HUMIDITY_CALIB_DIG_H2_LSB]);
			p_bme280->cal_param.dig_H3 =
    55a6:	78a2      	ldrb	r2, [r4, #2]
    55a8:	771a      	strb	r2, [r3, #28]
			p_bme280->cal_param.dig_H4 = (s16)(((
			(s16)((s8)a_data_u8[
			BME280_HUMIDITY_CALIB_DIG_H4_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_04_BITS) |
			(((u8)BME280_MASK_DIG_H4) &
			a_data_u8[BME280_HUMIDITY_CALIB_DIG_H4_LSB]));
    55aa:	7922      	ldrb	r2, [r4, #4]
			BME280_HUMIDITY_CALIB_DIG_H2_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_08_BITS)
			| a_data_u8[BME280_HUMIDITY_CALIB_DIG_H2_LSB]);
			p_bme280->cal_param.dig_H3 =
			a_data_u8[BME280_HUMIDITY_CALIB_DIG_H3];
			p_bme280->cal_param.dig_H4 = (s16)(((
    55ac:	2103      	movs	r1, #3
    55ae:	5661      	ldrsb	r1, [r4, r1]
    55b0:	010d      	lsls	r5, r1, #4
    55b2:	210f      	movs	r1, #15
    55b4:	4011      	ands	r1, r2
    55b6:	4329      	orrs	r1, r5
    55b8:	83d9      	strh	r1, [r3, #30]
			(s16)((s8)a_data_u8[
			BME280_HUMIDITY_CALIB_DIG_H4_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_04_BITS) |
			(((u8)BME280_MASK_DIG_H4) &
			a_data_u8[BME280_HUMIDITY_CALIB_DIG_H4_LSB]));
			p_bme280->cal_param.dig_H5 = (s16)(((
    55ba:	2105      	movs	r1, #5
    55bc:	5661      	ldrsb	r1, [r4, r1]
    55be:	0109      	lsls	r1, r1, #4
    55c0:	0912      	lsrs	r2, r2, #4
    55c2:	430a      	orrs	r2, r1
    55c4:	841a      	strh	r2, [r3, #32]
			(s16)((s8)a_data_u8[
			BME280_HUMIDITY_CALIB_DIG_H5_MSB])) <<
			BME280_SHIFT_BIT_POSITION_BY_04_BITS) |
			(a_data_u8[BME280_HUMIDITY_CALIB_DIG_H4_LSB] >>
			BME280_SHIFT_BIT_POSITION_BY_04_BITS));
			p_bme280->cal_param.dig_H6 =
    55c6:	79a1      	ldrb	r1, [r4, #6]
    55c8:	2222      	movs	r2, #34	; 0x22
    55ca:	5499      	strb	r1, [r3, r2]
			(s8)a_data_u8[BME280_HUMIDITY_CALIB_DIG_H6];
		}
	return com_rslt;
    55cc:	b240      	sxtb	r0, r0
    55ce:	e001      	b.n	55d4 <bme280_get_calib_param+0x108>
	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE,
	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE};
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    55d0:	207f      	movs	r0, #127	; 0x7f
    55d2:	4240      	negs	r0, r0
			BME280_SHIFT_BIT_POSITION_BY_04_BITS));
			p_bme280->cal_param.dig_H6 =
			(s8)a_data_u8[BME280_HUMIDITY_CALIB_DIG_H6];
		}
	return com_rslt;
}
    55d4:	b009      	add	sp, #36	; 0x24
    55d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    55d8:	0000a75f 	.word	0x0000a75f
    55dc:	200002d0 	.word	0x200002d0

000055e0 <bme280_init>:
 *	@retval -1 -> Error
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_init(struct bme280_t *bme280)
{
    55e0:	b570      	push	{r4, r5, r6, lr}
    55e2:	b082      	sub	sp, #8
    55e4:	0003      	movs	r3, r0
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_data_u8 = BME280_INIT_VALUE;
    55e6:	466a      	mov	r2, sp
    55e8:	1dd5      	adds	r5, r2, #7
    55ea:	2200      	movs	r2, #0
    55ec:	702a      	strb	r2, [r5, #0]

	p_bme280 = bme280;
    55ee:	4e0a      	ldr	r6, [pc, #40]	; (5618 <bme280_init+0x38>)
    55f0:	6030      	str	r0, [r6, #0]
	/* assign BME280 ptr */
	com_rslt = p_bme280->BME280_BUS_READ_FUNC(p_bme280->dev_addr,
    55f2:	3229      	adds	r2, #41	; 0x29
    55f4:	5c80      	ldrb	r0, [r0, r2]
    55f6:	6b5c      	ldr	r4, [r3, #52]	; 0x34
    55f8:	2301      	movs	r3, #1
    55fa:	002a      	movs	r2, r5
    55fc:	21d0      	movs	r1, #208	; 0xd0
    55fe:	47a0      	blx	r4
    5600:	0004      	movs	r4, r0
	BME280_CHIP_ID_REG, &v_data_u8,
	BME280_GEN_READ_WRITE_DATA_LENGTH);
	/* read Chip Id */
	p_bme280->chip_id = v_data_u8;
    5602:	6832      	ldr	r2, [r6, #0]
    5604:	7829      	ldrb	r1, [r5, #0]
    5606:	2328      	movs	r3, #40	; 0x28
    5608:	54d1      	strb	r1, [r2, r3]

	com_rslt += bme280_get_calib_param();
    560a:	4b04      	ldr	r3, [pc, #16]	; (561c <bme280_init+0x3c>)
    560c:	4798      	blx	r3
    560e:	1904      	adds	r4, r0, r4
	/* readout bme280 calibparam structure */
	return com_rslt;
    5610:	b260      	sxtb	r0, r4
}
    5612:	b002      	add	sp, #8
    5614:	bd70      	pop	{r4, r5, r6, pc}
    5616:	46c0      	nop			; (mov r8, r8)
    5618:	200002d0 	.word	0x200002d0
    561c:	000054cd 	.word	0x000054cd

00005620 <bme280_get_power_mode>:
 *	@retval -1 -> Error
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_get_power_mode(u8 *v_power_mode_u8)
{
    5620:	b570      	push	{r4, r5, r6, lr}
    5622:	b082      	sub	sp, #8
    5624:	0005      	movs	r5, r0
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_mode_u8r = BME280_INIT_VALUE;
    5626:	2200      	movs	r2, #0
    5628:	466b      	mov	r3, sp
    562a:	71da      	strb	r2, [r3, #7]
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    562c:	4b0a      	ldr	r3, [pc, #40]	; (5658 <bme280_get_power_mode+0x38>)
    562e:	681b      	ldr	r3, [r3, #0]
    5630:	2b00      	cmp	r3, #0
    5632:	d00d      	beq.n	5650 <bme280_get_power_mode+0x30>
		return E_BME280_NULL_PTR;
		} else {
			com_rslt = p_bme280->BME280_BUS_READ_FUNC(
    5634:	466a      	mov	r2, sp
    5636:	1dd4      	adds	r4, r2, #7
    5638:	2229      	movs	r2, #41	; 0x29
    563a:	5c98      	ldrb	r0, [r3, r2]
    563c:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    563e:	2301      	movs	r3, #1
    5640:	0022      	movs	r2, r4
    5642:	21f4      	movs	r1, #244	; 0xf4
    5644:	47b0      	blx	r6
			p_bme280->dev_addr,
			BME280_CTRL_MEAS_REG_POWER_MODE__REG,
			&v_mode_u8r, BME280_GEN_READ_WRITE_DATA_LENGTH);
			*v_power_mode_u8 = BME280_GET_BITSLICE(v_mode_u8r,
    5646:	7823      	ldrb	r3, [r4, #0]
    5648:	2203      	movs	r2, #3
    564a:	4013      	ands	r3, r2
    564c:	702b      	strb	r3, [r5, #0]
			BME280_CTRL_MEAS_REG_POWER_MODE);
		}
	return com_rslt;
    564e:	e001      	b.n	5654 <bme280_get_power_mode+0x34>
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_mode_u8r = BME280_INIT_VALUE;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    5650:	207f      	movs	r0, #127	; 0x7f
    5652:	4240      	negs	r0, r0
			&v_mode_u8r, BME280_GEN_READ_WRITE_DATA_LENGTH);
			*v_power_mode_u8 = BME280_GET_BITSLICE(v_mode_u8r,
			BME280_CTRL_MEAS_REG_POWER_MODE);
		}
	return com_rslt;
}
    5654:	b002      	add	sp, #8
    5656:	bd70      	pop	{r4, r5, r6, pc}
    5658:	200002d0 	.word	0x200002d0

0000565c <bme280_set_soft_rst>:
 *	@retval -1 -> Error
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_set_soft_rst(void)
{
    565c:	b510      	push	{r4, lr}
    565e:	b082      	sub	sp, #8
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_data_u8 = BME280_SOFT_RESET_CODE;
    5660:	22b6      	movs	r2, #182	; 0xb6
    5662:	466b      	mov	r3, sp
    5664:	71da      	strb	r2, [r3, #7]
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    5666:	4b08      	ldr	r3, [pc, #32]	; (5688 <bme280_set_soft_rst+0x2c>)
    5668:	681b      	ldr	r3, [r3, #0]
    566a:	2b00      	cmp	r3, #0
    566c:	d008      	beq.n	5680 <bme280_set_soft_rst+0x24>
		return E_BME280_NULL_PTR;
		} else {
			com_rslt = p_bme280->BME280_BUS_WRITE_FUNC(
    566e:	3a8d      	subs	r2, #141	; 0x8d
    5670:	5c98      	ldrb	r0, [r3, r2]
    5672:	6b1c      	ldr	r4, [r3, #48]	; 0x30
    5674:	2301      	movs	r3, #1
    5676:	466a      	mov	r2, sp
    5678:	3207      	adds	r2, #7
    567a:	21e0      	movs	r1, #224	; 0xe0
    567c:	47a0      	blx	r4
			p_bme280->dev_addr,
			BME280_RST_REG, &v_data_u8,
			BME280_GEN_READ_WRITE_DATA_LENGTH);
		}
	return com_rslt;
    567e:	e001      	b.n	5684 <bme280_set_soft_rst+0x28>
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_data_u8 = BME280_SOFT_RESET_CODE;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    5680:	207f      	movs	r0, #127	; 0x7f
    5682:	4240      	negs	r0, r0
			p_bme280->dev_addr,
			BME280_RST_REG, &v_data_u8,
			BME280_GEN_READ_WRITE_DATA_LENGTH);
		}
	return com_rslt;
}
    5684:	b002      	add	sp, #8
    5686:	bd10      	pop	{r4, pc}
    5688:	200002d0 	.word	0x200002d0

0000568c <bme280_write_register>:
 *
 *
 */
BME280_RETURN_FUNCTION_TYPE bme280_write_register(u8 v_addr_u8,
u8 *v_data_u8, u8 v_len_u8)
{
    568c:	b570      	push	{r4, r5, r6, lr}
    568e:	0005      	movs	r5, r0
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    5690:	4c07      	ldr	r4, [pc, #28]	; (56b0 <bme280_write_register+0x24>)
    5692:	6824      	ldr	r4, [r4, #0]
    5694:	2c00      	cmp	r4, #0
    5696:	d007      	beq.n	56a8 <bme280_write_register+0x1c>
		return E_BME280_NULL_PTR;
		} else {
			com_rslt = p_bme280->BME280_BUS_WRITE_FUNC(
    5698:	2329      	movs	r3, #41	; 0x29
    569a:	5ce0      	ldrb	r0, [r4, r3]
    569c:	6b24      	ldr	r4, [r4, #48]	; 0x30
    569e:	0013      	movs	r3, r2
    56a0:	000a      	movs	r2, r1
    56a2:	0029      	movs	r1, r5
    56a4:	47a0      	blx	r4
			p_bme280->dev_addr,
			v_addr_u8, v_data_u8, v_len_u8);
		}
	return com_rslt;
    56a6:	e001      	b.n	56ac <bme280_write_register+0x20>
{
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    56a8:	207f      	movs	r0, #127	; 0x7f
    56aa:	4240      	negs	r0, r0
			com_rslt = p_bme280->BME280_BUS_WRITE_FUNC(
			p_bme280->dev_addr,
			v_addr_u8, v_data_u8, v_len_u8);
		}
	return com_rslt;
}
    56ac:	bd70      	pop	{r4, r5, r6, pc}
    56ae:	46c0      	nop			; (mov r8, r8)
    56b0:	200002d0 	.word	0x200002d0

000056b4 <bme280_read_register>:
 *
 *
 */
BME280_RETURN_FUNCTION_TYPE bme280_read_register(u8 v_addr_u8,
u8 *v_data_u8, u8 v_len_u8)
{
    56b4:	b570      	push	{r4, r5, r6, lr}
    56b6:	0005      	movs	r5, r0
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    56b8:	4c07      	ldr	r4, [pc, #28]	; (56d8 <bme280_read_register+0x24>)
    56ba:	6824      	ldr	r4, [r4, #0]
    56bc:	2c00      	cmp	r4, #0
    56be:	d007      	beq.n	56d0 <bme280_read_register+0x1c>
		return E_BME280_NULL_PTR;
		} else {
			com_rslt = p_bme280->BME280_BUS_READ_FUNC(
    56c0:	2329      	movs	r3, #41	; 0x29
    56c2:	5ce0      	ldrb	r0, [r4, r3]
    56c4:	6b64      	ldr	r4, [r4, #52]	; 0x34
    56c6:	0013      	movs	r3, r2
    56c8:	000a      	movs	r2, r1
    56ca:	0029      	movs	r1, r5
    56cc:	47a0      	blx	r4
			p_bme280->dev_addr,
			v_addr_u8, v_data_u8, v_len_u8);
		}
	return com_rslt;
    56ce:	e001      	b.n	56d4 <bme280_read_register+0x20>
{
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    56d0:	207f      	movs	r0, #127	; 0x7f
    56d2:	4240      	negs	r0, r0
			com_rslt = p_bme280->BME280_BUS_READ_FUNC(
			p_bme280->dev_addr,
			v_addr_u8, v_data_u8, v_len_u8);
		}
	return com_rslt;
}
    56d4:	bd70      	pop	{r4, r5, r6, pc}
    56d6:	46c0      	nop			; (mov r8, r8)
    56d8:	200002d0 	.word	0x200002d0

000056dc <bme280_set_oversamp_temperature>:
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_set_oversamp_temperature(
u8 v_value_u8)
{
    56dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    56de:	b083      	sub	sp, #12
    56e0:	0004      	movs	r4, r0
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_data_u8 = BME280_INIT_VALUE;
    56e2:	2300      	movs	r3, #0
    56e4:	466a      	mov	r2, sp
    56e6:	71d3      	strb	r3, [r2, #7]
	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;
    56e8:	466a      	mov	r2, sp
    56ea:	7193      	strb	r3, [r2, #6]
	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;
    56ec:	466a      	mov	r2, sp
    56ee:	7153      	strb	r3, [r2, #5]
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
    56f0:	aa01      	add	r2, sp, #4
    56f2:	7013      	strb	r3, [r2, #0]
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    56f4:	4b32      	ldr	r3, [pc, #200]	; (57c0 <bme280_set_oversamp_temperature+0xe4>)
    56f6:	681b      	ldr	r3, [r3, #0]
    56f8:	2b00      	cmp	r3, #0
    56fa:	d05d      	beq.n	57b8 <bme280_set_oversamp_temperature+0xdc>
		return E_BME280_NULL_PTR;
		} else {
			v_data_u8 = p_bme280->ctrl_meas_reg;
    56fc:	222e      	movs	r2, #46	; 0x2e
			v_data_u8 =
    56fe:	5c9b      	ldrb	r3, [r3, r2]
    5700:	3a0f      	subs	r2, #15
    5702:	4013      	ands	r3, r2
    5704:	0142      	lsls	r2, r0, #5
    5706:	4313      	orrs	r3, r2
    5708:	466a      	mov	r2, sp
    570a:	71d3      	strb	r3, [r2, #7]
			BME280_SET_BITSLICE(v_data_u8,
			BME280_CTRL_MEAS_REG_OVERSAMP_TEMPERATURE, v_value_u8);
			com_rslt = bme280_get_power_mode(&v_prev_pow_mode_u8);
    570c:	466b      	mov	r3, sp
    570e:	1d9d      	adds	r5, r3, #6
    5710:	0028      	movs	r0, r5
    5712:	4b2c      	ldr	r3, [pc, #176]	; (57c4 <bme280_set_oversamp_temperature+0xe8>)
    5714:	4798      	blx	r3
			if (v_prev_pow_mode_u8 != BME280_SLEEP_MODE) {
    5716:	782b      	ldrb	r3, [r5, #0]
    5718:	2b00      	cmp	r3, #0
    571a:	d01e      	beq.n	575a <bme280_set_oversamp_temperature+0x7e>
				com_rslt += bme280_set_soft_rst();
    571c:	4b2a      	ldr	r3, [pc, #168]	; (57c8 <bme280_set_oversamp_temperature+0xec>)
    571e:	4798      	blx	r3
				p_bme280->delay_msec(BME280_3MS_DELAY);
    5720:	4e27      	ldr	r6, [pc, #156]	; (57c0 <bme280_set_oversamp_temperature+0xe4>)
    5722:	6833      	ldr	r3, [r6, #0]
    5724:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    5726:	2003      	movs	r0, #3
    5728:	4798      	blx	r3
				/* write previous value
				of configuration register*/
				v_pre_config_value_u8 = p_bme280->config_reg;
    572a:	a901      	add	r1, sp, #4
    572c:	232f      	movs	r3, #47	; 0x2f
    572e:	6832      	ldr	r2, [r6, #0]
    5730:	5cd3      	ldrb	r3, [r2, r3]
    5732:	700b      	strb	r3, [r1, #0]
				com_rslt += bme280_write_register(
    5734:	2201      	movs	r2, #1
    5736:	20f5      	movs	r0, #245	; 0xf5
    5738:	4d24      	ldr	r5, [pc, #144]	; (57cc <bme280_set_oversamp_temperature+0xf0>)
    573a:	47a8      	blx	r5
					BME280_CONFIG_REG,
				&v_pre_config_value_u8,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous value
				of humidity oversampling*/
				v_pre_ctrl_hum_value_u8 =
    573c:	466b      	mov	r3, sp
    573e:	1d59      	adds	r1, r3, #5
				p_bme280->ctrl_hum_reg;
    5740:	6832      	ldr	r2, [r6, #0]
    5742:	232d      	movs	r3, #45	; 0x2d
					BME280_CONFIG_REG,
				&v_pre_config_value_u8,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous value
				of humidity oversampling*/
				v_pre_ctrl_hum_value_u8 =
    5744:	5cd3      	ldrb	r3, [r2, r3]
    5746:	700b      	strb	r3, [r1, #0]
				p_bme280->ctrl_hum_reg;
				com_rslt += bme280_write_register(
    5748:	2201      	movs	r2, #1
    574a:	20f2      	movs	r0, #242	; 0xf2
    574c:	47a8      	blx	r5
					BME280_CTRL_HUMIDITY_REG,
				&v_pre_ctrl_hum_value_u8,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous and updated value
				of configuration register*/
				com_rslt += bme280_write_register(
    574e:	2201      	movs	r2, #1
    5750:	466b      	mov	r3, sp
    5752:	1dd9      	adds	r1, r3, #7
    5754:	20f4      	movs	r0, #244	; 0xf4
    5756:	47a8      	blx	r5
    5758:	e009      	b.n	576e <bme280_set_oversamp_temperature+0x92>
					BME280_CTRL_MEAS_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			} else {
				com_rslt = p_bme280->BME280_BUS_WRITE_FUNC(
    575a:	4b19      	ldr	r3, [pc, #100]	; (57c0 <bme280_set_oversamp_temperature+0xe4>)
    575c:	681b      	ldr	r3, [r3, #0]
    575e:	2229      	movs	r2, #41	; 0x29
    5760:	5c98      	ldrb	r0, [r3, r2]
    5762:	6b1d      	ldr	r5, [r3, #48]	; 0x30
    5764:	2301      	movs	r3, #1
    5766:	466a      	mov	r2, sp
    5768:	3207      	adds	r2, #7
    576a:	21f4      	movs	r1, #244	; 0xf4
    576c:	47a8      	blx	r5
				p_bme280->dev_addr,
				BME280_CTRL_MEAS_REG_OVERSAMP_TEMPERATURE__REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			}
				p_bme280->oversamp_temperature = v_value_u8;
    576e:	4e14      	ldr	r6, [pc, #80]	; (57c0 <bme280_set_oversamp_temperature+0xe4>)
    5770:	232a      	movs	r3, #42	; 0x2a
    5772:	6832      	ldr	r2, [r6, #0]
    5774:	54d4      	strb	r4, [r2, r3]
				/* read the control measurement register value*/
				com_rslt = bme280_read_register(
    5776:	466b      	mov	r3, sp
    5778:	1ddc      	adds	r4, r3, #7
    577a:	2201      	movs	r2, #1
    577c:	0021      	movs	r1, r4
    577e:	20f4      	movs	r0, #244	; 0xf4
    5780:	4f13      	ldr	r7, [pc, #76]	; (57d0 <bme280_set_oversamp_temperature+0xf4>)
    5782:	47b8      	blx	r7
    5784:	0005      	movs	r5, r0
					BME280_CTRL_MEAS_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->ctrl_meas_reg = v_data_u8;
    5786:	7822      	ldrb	r2, [r4, #0]
    5788:	232e      	movs	r3, #46	; 0x2e
    578a:	6831      	ldr	r1, [r6, #0]
    578c:	54ca      	strb	r2, [r1, r3]
				/* read the control humidity register value*/
				com_rslt += bme280_read_register(
    578e:	2201      	movs	r2, #1
    5790:	0021      	movs	r1, r4
    5792:	20f2      	movs	r0, #242	; 0xf2
    5794:	47b8      	blx	r7
    5796:	1945      	adds	r5, r0, r5
    5798:	b2ed      	uxtb	r5, r5
					BME280_CTRL_HUMIDITY_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->ctrl_hum_reg = v_data_u8;
    579a:	7822      	ldrb	r2, [r4, #0]
    579c:	232d      	movs	r3, #45	; 0x2d
    579e:	6831      	ldr	r1, [r6, #0]
    57a0:	54ca      	strb	r2, [r1, r3]
				/* read the control
				configuration register value*/
				com_rslt += bme280_read_register(
    57a2:	2201      	movs	r2, #1
    57a4:	0021      	movs	r1, r4
    57a6:	20f5      	movs	r0, #245	; 0xf5
    57a8:	47b8      	blx	r7
    57aa:	1828      	adds	r0, r5, r0
					BME280_CONFIG_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->config_reg = v_data_u8;
    57ac:	6832      	ldr	r2, [r6, #0]
    57ae:	7821      	ldrb	r1, [r4, #0]
    57b0:	232f      	movs	r3, #47	; 0x2f
    57b2:	54d1      	strb	r1, [r2, r3]
		}
	return com_rslt;
    57b4:	b240      	sxtb	r0, r0
    57b6:	e001      	b.n	57bc <bme280_set_oversamp_temperature+0xe0>
	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;
	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    57b8:	207f      	movs	r0, #127	; 0x7f
    57ba:	4240      	negs	r0, r0
					BME280_CONFIG_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->config_reg = v_data_u8;
		}
	return com_rslt;
}
    57bc:	b003      	add	sp, #12
    57be:	bdf0      	pop	{r4, r5, r6, r7, pc}
    57c0:	200002d0 	.word	0x200002d0
    57c4:	00005621 	.word	0x00005621
    57c8:	0000565d 	.word	0x0000565d
    57cc:	0000568d 	.word	0x0000568d
    57d0:	000056b5 	.word	0x000056b5

000057d4 <bme280_set_oversamp_pressure>:
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_set_oversamp_pressure(
u8 v_value_u8)
{
    57d4:	b5f0      	push	{r4, r5, r6, r7, lr}
    57d6:	b083      	sub	sp, #12
    57d8:	0004      	movs	r4, r0
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_data_u8 = BME280_INIT_VALUE;
    57da:	2300      	movs	r3, #0
    57dc:	466a      	mov	r2, sp
    57de:	71d3      	strb	r3, [r2, #7]
	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;
    57e0:	466a      	mov	r2, sp
    57e2:	7193      	strb	r3, [r2, #6]
	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;
    57e4:	466a      	mov	r2, sp
    57e6:	7153      	strb	r3, [r2, #5]
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
    57e8:	aa01      	add	r2, sp, #4
    57ea:	7013      	strb	r3, [r2, #0]
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    57ec:	4b34      	ldr	r3, [pc, #208]	; (58c0 <bme280_set_oversamp_pressure+0xec>)
    57ee:	681b      	ldr	r3, [r3, #0]
    57f0:	2b00      	cmp	r3, #0
    57f2:	d060      	beq.n	58b6 <bme280_set_oversamp_pressure+0xe2>
		return E_BME280_NULL_PTR;
		} else {
			v_data_u8 = p_bme280->ctrl_meas_reg;
    57f4:	222e      	movs	r2, #46	; 0x2e
			v_data_u8 =
    57f6:	5c9b      	ldrb	r3, [r3, r2]
    57f8:	3a12      	subs	r2, #18
    57fa:	4393      	bics	r3, r2
    57fc:	0019      	movs	r1, r3
    57fe:	0082      	lsls	r2, r0, #2
    5800:	231c      	movs	r3, #28
    5802:	4013      	ands	r3, r2
    5804:	430b      	orrs	r3, r1
    5806:	466a      	mov	r2, sp
    5808:	71d3      	strb	r3, [r2, #7]
			BME280_SET_BITSLICE(v_data_u8,
			BME280_CTRL_MEAS_REG_OVERSAMP_PRESSURE, v_value_u8);
			com_rslt = bme280_get_power_mode(&v_prev_pow_mode_u8);
    580a:	466b      	mov	r3, sp
    580c:	1d9d      	adds	r5, r3, #6
    580e:	0028      	movs	r0, r5
    5810:	4b2c      	ldr	r3, [pc, #176]	; (58c4 <bme280_set_oversamp_pressure+0xf0>)
    5812:	4798      	blx	r3
			if (v_prev_pow_mode_u8 != BME280_SLEEP_MODE) {
    5814:	782b      	ldrb	r3, [r5, #0]
    5816:	2b00      	cmp	r3, #0
    5818:	d01e      	beq.n	5858 <bme280_set_oversamp_pressure+0x84>
				com_rslt += bme280_set_soft_rst();
    581a:	4b2b      	ldr	r3, [pc, #172]	; (58c8 <bme280_set_oversamp_pressure+0xf4>)
    581c:	4798      	blx	r3
				p_bme280->delay_msec(BME280_3MS_DELAY);
    581e:	4e28      	ldr	r6, [pc, #160]	; (58c0 <bme280_set_oversamp_pressure+0xec>)
    5820:	6833      	ldr	r3, [r6, #0]
    5822:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    5824:	2003      	movs	r0, #3
    5826:	4798      	blx	r3
				/* write previous value of
				configuration register*/
				v_pre_config_value_u8 = p_bme280->config_reg;
    5828:	a901      	add	r1, sp, #4
    582a:	232f      	movs	r3, #47	; 0x2f
    582c:	6832      	ldr	r2, [r6, #0]
    582e:	5cd3      	ldrb	r3, [r2, r3]
    5830:	700b      	strb	r3, [r1, #0]
				com_rslt = bme280_write_register(
    5832:	2201      	movs	r2, #1
    5834:	20f5      	movs	r0, #245	; 0xf5
    5836:	4d25      	ldr	r5, [pc, #148]	; (58cc <bme280_set_oversamp_pressure+0xf8>)
    5838:	47a8      	blx	r5
					BME280_CONFIG_REG,
				&v_pre_config_value_u8,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous value of
				humidity oversampling*/
				v_pre_ctrl_hum_value_u8 =
    583a:	466b      	mov	r3, sp
    583c:	1d59      	adds	r1, r3, #5
				p_bme280->ctrl_hum_reg;
    583e:	6832      	ldr	r2, [r6, #0]
    5840:	232d      	movs	r3, #45	; 0x2d
					BME280_CONFIG_REG,
				&v_pre_config_value_u8,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous value of
				humidity oversampling*/
				v_pre_ctrl_hum_value_u8 =
    5842:	5cd3      	ldrb	r3, [r2, r3]
    5844:	700b      	strb	r3, [r1, #0]
				p_bme280->ctrl_hum_reg;
				com_rslt += bme280_write_register(
    5846:	2201      	movs	r2, #1
    5848:	20f2      	movs	r0, #242	; 0xf2
    584a:	47a8      	blx	r5
					BME280_CTRL_HUMIDITY_REG,
				&v_pre_ctrl_hum_value_u8,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous and updated value of
				control measurement register*/
				bme280_write_register(
    584c:	2201      	movs	r2, #1
    584e:	466b      	mov	r3, sp
    5850:	1dd9      	adds	r1, r3, #7
    5852:	20f4      	movs	r0, #244	; 0xf4
    5854:	47a8      	blx	r5
    5856:	e009      	b.n	586c <bme280_set_oversamp_pressure+0x98>
					BME280_CTRL_MEAS_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			} else {
				com_rslt = p_bme280->BME280_BUS_WRITE_FUNC(
    5858:	4b19      	ldr	r3, [pc, #100]	; (58c0 <bme280_set_oversamp_pressure+0xec>)
    585a:	681b      	ldr	r3, [r3, #0]
    585c:	2229      	movs	r2, #41	; 0x29
    585e:	5c98      	ldrb	r0, [r3, r2]
    5860:	6b1d      	ldr	r5, [r3, #48]	; 0x30
    5862:	2301      	movs	r3, #1
    5864:	466a      	mov	r2, sp
    5866:	3207      	adds	r2, #7
    5868:	21f4      	movs	r1, #244	; 0xf4
    586a:	47a8      	blx	r5
				p_bme280->dev_addr,
				BME280_CTRL_MEAS_REG_OVERSAMP_PRESSURE__REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			}
				p_bme280->oversamp_pressure = v_value_u8;
    586c:	4e14      	ldr	r6, [pc, #80]	; (58c0 <bme280_set_oversamp_pressure+0xec>)
    586e:	232b      	movs	r3, #43	; 0x2b
    5870:	6832      	ldr	r2, [r6, #0]
    5872:	54d4      	strb	r4, [r2, r3]
				/* read the control measurement register value*/
				com_rslt = bme280_read_register(
    5874:	466b      	mov	r3, sp
    5876:	1ddc      	adds	r4, r3, #7
    5878:	2201      	movs	r2, #1
    587a:	0021      	movs	r1, r4
    587c:	20f4      	movs	r0, #244	; 0xf4
    587e:	4f14      	ldr	r7, [pc, #80]	; (58d0 <bme280_set_oversamp_pressure+0xfc>)
    5880:	47b8      	blx	r7
    5882:	0005      	movs	r5, r0
					BME280_CTRL_MEAS_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->ctrl_meas_reg = v_data_u8;
    5884:	7822      	ldrb	r2, [r4, #0]
    5886:	232e      	movs	r3, #46	; 0x2e
    5888:	6831      	ldr	r1, [r6, #0]
    588a:	54ca      	strb	r2, [r1, r3]
				/* read the control humidity register value*/
				com_rslt += bme280_read_register(
    588c:	2201      	movs	r2, #1
    588e:	0021      	movs	r1, r4
    5890:	20f2      	movs	r0, #242	; 0xf2
    5892:	47b8      	blx	r7
    5894:	1945      	adds	r5, r0, r5
    5896:	b2ed      	uxtb	r5, r5
					BME280_CTRL_HUMIDITY_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->ctrl_hum_reg = v_data_u8;
    5898:	7822      	ldrb	r2, [r4, #0]
    589a:	232d      	movs	r3, #45	; 0x2d
    589c:	6831      	ldr	r1, [r6, #0]
    589e:	54ca      	strb	r2, [r1, r3]
				/* read the control
				configuration register value*/
				com_rslt += bme280_read_register(
    58a0:	2201      	movs	r2, #1
    58a2:	0021      	movs	r1, r4
    58a4:	20f5      	movs	r0, #245	; 0xf5
    58a6:	47b8      	blx	r7
    58a8:	1828      	adds	r0, r5, r0
					BME280_CONFIG_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->config_reg = v_data_u8;
    58aa:	6832      	ldr	r2, [r6, #0]
    58ac:	7821      	ldrb	r1, [r4, #0]
    58ae:	232f      	movs	r3, #47	; 0x2f
    58b0:	54d1      	strb	r1, [r2, r3]
		}
	return com_rslt;
    58b2:	b240      	sxtb	r0, r0
    58b4:	e001      	b.n	58ba <bme280_set_oversamp_pressure+0xe6>
	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;
	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    58b6:	207f      	movs	r0, #127	; 0x7f
    58b8:	4240      	negs	r0, r0
					BME280_CONFIG_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->config_reg = v_data_u8;
		}
	return com_rslt;
}
    58ba:	b003      	add	sp, #12
    58bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    58be:	46c0      	nop			; (mov r8, r8)
    58c0:	200002d0 	.word	0x200002d0
    58c4:	00005621 	.word	0x00005621
    58c8:	0000565d 	.word	0x0000565d
    58cc:	0000568d 	.word	0x0000568d
    58d0:	000056b5 	.word	0x000056b5

000058d4 <bme280_set_oversamp_humidity>:
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_set_oversamp_humidity(
u8 v_value_u8)
{
    58d4:	b5f0      	push	{r4, r5, r6, r7, lr}
    58d6:	4647      	mov	r7, r8
    58d8:	b480      	push	{r7}
    58da:	b082      	sub	sp, #8
    58dc:	0007      	movs	r7, r0
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_data_u8 = BME280_INIT_VALUE;
    58de:	2300      	movs	r3, #0
    58e0:	466a      	mov	r2, sp
    58e2:	71d3      	strb	r3, [r2, #7]
	u8 pre_ctrl_meas_value = BME280_INIT_VALUE;
    58e4:	466a      	mov	r2, sp
    58e6:	7193      	strb	r3, [r2, #6]
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
    58e8:	466a      	mov	r2, sp
    58ea:	7153      	strb	r3, [r2, #5]
	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;
    58ec:	aa01      	add	r2, sp, #4
    58ee:	7013      	strb	r3, [r2, #0]
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    58f0:	4b40      	ldr	r3, [pc, #256]	; (59f4 <bme280_set_oversamp_humidity+0x120>)
    58f2:	681b      	ldr	r3, [r3, #0]
    58f4:	2b00      	cmp	r3, #0
    58f6:	d077      	beq.n	59e8 <bme280_set_oversamp_humidity+0x114>
		return E_BME280_NULL_PTR;
		} else {
			/* write humidity oversampling*/
			v_data_u8 = p_bme280->ctrl_hum_reg;
    58f8:	222d      	movs	r2, #45	; 0x2d
			v_data_u8 =
    58fa:	5c9b      	ldrb	r3, [r3, r2]
    58fc:	3a26      	subs	r2, #38	; 0x26
    58fe:	4393      	bics	r3, r2
    5900:	001a      	movs	r2, r3
    5902:	2307      	movs	r3, #7
    5904:	4003      	ands	r3, r0
    5906:	4313      	orrs	r3, r2
    5908:	466a      	mov	r2, sp
    590a:	71d3      	strb	r3, [r2, #7]
			BME280_SET_BITSLICE(v_data_u8,
			BME280_CTRL_HUMIDITY_REG_OVERSAMP_HUMIDITY, v_value_u8);
			com_rslt = bme280_get_power_mode(&v_prev_pow_mode_u8);
    590c:	ac01      	add	r4, sp, #4
    590e:	0020      	movs	r0, r4
    5910:	4b39      	ldr	r3, [pc, #228]	; (59f8 <bme280_set_oversamp_humidity+0x124>)
    5912:	4798      	blx	r3
    5914:	0005      	movs	r5, r0
			if (v_prev_pow_mode_u8 != BME280_SLEEP_MODE) {
    5916:	7823      	ldrb	r3, [r4, #0]
    5918:	2b00      	cmp	r3, #0
    591a:	d027      	beq.n	596c <bme280_set_oversamp_humidity+0x98>
				com_rslt += bme280_set_soft_rst();
    591c:	4b37      	ldr	r3, [pc, #220]	; (59fc <bme280_set_oversamp_humidity+0x128>)
    591e:	4798      	blx	r3
    5920:	4680      	mov	r8, r0
				p_bme280->delay_msec(BME280_3MS_DELAY);
    5922:	4c34      	ldr	r4, [pc, #208]	; (59f4 <bme280_set_oversamp_humidity+0x120>)
    5924:	6823      	ldr	r3, [r4, #0]
    5926:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    5928:	2003      	movs	r0, #3
    592a:	4798      	blx	r3
				/* write previous value of
				configuration register*/
				v_pre_config_value_u8 = p_bme280->config_reg;
    592c:	466b      	mov	r3, sp
    592e:	1d59      	adds	r1, r3, #5
    5930:	232f      	movs	r3, #47	; 0x2f
    5932:	6822      	ldr	r2, [r4, #0]
    5934:	5cd3      	ldrb	r3, [r2, r3]
    5936:	700b      	strb	r3, [r1, #0]
				com_rslt += bme280_write_register(
    5938:	2201      	movs	r2, #1
    593a:	20f5      	movs	r0, #245	; 0xf5
    593c:	4e30      	ldr	r6, [pc, #192]	; (5a00 <bme280_set_oversamp_humidity+0x12c>)
    593e:	47b0      	blx	r6
    5940:	4440      	add	r0, r8
    5942:	1945      	adds	r5, r0, r5
    5944:	b2ed      	uxtb	r5, r5
					BME280_CONFIG_REG,
				&v_pre_config_value_u8,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write the value of control humidity*/
				com_rslt += bme280_write_register(
    5946:	2201      	movs	r2, #1
    5948:	466b      	mov	r3, sp
    594a:	1dd9      	adds	r1, r3, #7
    594c:	20f2      	movs	r0, #242	; 0xf2
    594e:	47b0      	blx	r6
    5950:	182d      	adds	r5, r5, r0
    5952:	b2ed      	uxtb	r5, r5
					BME280_CTRL_HUMIDITY_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous value of
				control measurement register*/
				pre_ctrl_meas_value =
    5954:	466b      	mov	r3, sp
    5956:	1d99      	adds	r1, r3, #6
				p_bme280->ctrl_meas_reg;
    5958:	6822      	ldr	r2, [r4, #0]
    595a:	232e      	movs	r3, #46	; 0x2e
				com_rslt += bme280_write_register(
					BME280_CTRL_HUMIDITY_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* write previous value of
				control measurement register*/
				pre_ctrl_meas_value =
    595c:	5cd3      	ldrb	r3, [r2, r3]
    595e:	700b      	strb	r3, [r1, #0]
				p_bme280->ctrl_meas_reg;
				com_rslt += bme280_write_register(
    5960:	2201      	movs	r2, #1
    5962:	20f4      	movs	r0, #244	; 0xf4
    5964:	47b0      	blx	r6
    5966:	1828      	adds	r0, r5, r0
    5968:	b244      	sxtb	r4, r0
    596a:	e017      	b.n	599c <bme280_set_oversamp_humidity+0xc8>
					BME280_CTRL_MEAS_REG,
				&pre_ctrl_meas_value,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
			} else {
				com_rslt +=
				p_bme280->BME280_BUS_WRITE_FUNC(
    596c:	4e21      	ldr	r6, [pc, #132]	; (59f4 <bme280_set_oversamp_humidity+0x120>)
    596e:	6833      	ldr	r3, [r6, #0]
    5970:	2229      	movs	r2, #41	; 0x29
    5972:	5c98      	ldrb	r0, [r3, r2]
    5974:	6b1c      	ldr	r4, [r3, #48]	; 0x30
    5976:	2301      	movs	r3, #1
    5978:	466a      	mov	r2, sp
    597a:	3207      	adds	r2, #7
    597c:	21f2      	movs	r1, #242	; 0xf2
    597e:	47a0      	blx	r4
    5980:	0004      	movs	r4, r0
				p_bme280->dev_addr,
				BME280_CTRL_HUMIDITY_REG_OVERSAMP_HUMIDITY__REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* Control humidity write will effective only
				after the control measurement register*/
				pre_ctrl_meas_value =
    5982:	466b      	mov	r3, sp
    5984:	1d99      	adds	r1, r3, #6
				p_bme280->ctrl_meas_reg;
    5986:	6832      	ldr	r2, [r6, #0]
    5988:	232e      	movs	r3, #46	; 0x2e
				p_bme280->dev_addr,
				BME280_CTRL_HUMIDITY_REG_OVERSAMP_HUMIDITY__REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				/* Control humidity write will effective only
				after the control measurement register*/
				pre_ctrl_meas_value =
    598a:	5cd3      	ldrb	r3, [r2, r3]
    598c:	700b      	strb	r3, [r1, #0]
				p_bme280->ctrl_meas_reg;
				com_rslt += bme280_write_register(
    598e:	2201      	movs	r2, #1
    5990:	20f4      	movs	r0, #244	; 0xf4
    5992:	4b1b      	ldr	r3, [pc, #108]	; (5a00 <bme280_set_oversamp_humidity+0x12c>)
    5994:	4798      	blx	r3
    5996:	1824      	adds	r4, r4, r0
    5998:	1965      	adds	r5, r4, r5
    599a:	b26c      	sxtb	r4, r5
					BME280_CTRL_MEAS_REG,
				&pre_ctrl_meas_value,
				BME280_GEN_READ_WRITE_DATA_LENGTH);
			}
			p_bme280->oversamp_humidity = v_value_u8;
    599c:	4e15      	ldr	r6, [pc, #84]	; (59f4 <bme280_set_oversamp_humidity+0x120>)
    599e:	232c      	movs	r3, #44	; 0x2c
    59a0:	6832      	ldr	r2, [r6, #0]
    59a2:	54d7      	strb	r7, [r2, r3]
			/* read the control measurement register value*/
			com_rslt += bme280_read_register(BME280_CTRL_MEAS_REG,
    59a4:	466b      	mov	r3, sp
    59a6:	1ddd      	adds	r5, r3, #7
    59a8:	2201      	movs	r2, #1
    59aa:	0029      	movs	r1, r5
    59ac:	20f4      	movs	r0, #244	; 0xf4
    59ae:	4f15      	ldr	r7, [pc, #84]	; (5a04 <bme280_set_oversamp_humidity+0x130>)
    59b0:	47b8      	blx	r7
    59b2:	1904      	adds	r4, r0, r4
    59b4:	b2e4      	uxtb	r4, r4
			&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			p_bme280->ctrl_meas_reg = v_data_u8;
    59b6:	782a      	ldrb	r2, [r5, #0]
    59b8:	232e      	movs	r3, #46	; 0x2e
    59ba:	6831      	ldr	r1, [r6, #0]
    59bc:	54ca      	strb	r2, [r1, r3]
			/* read the control humidity register value*/
			com_rslt += bme280_read_register(
    59be:	2201      	movs	r2, #1
    59c0:	0029      	movs	r1, r5
    59c2:	20f2      	movs	r0, #242	; 0xf2
    59c4:	47b8      	blx	r7
    59c6:	1824      	adds	r4, r4, r0
    59c8:	b2e4      	uxtb	r4, r4
			BME280_CTRL_HUMIDITY_REG,
			&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			p_bme280->ctrl_hum_reg = v_data_u8;
    59ca:	782a      	ldrb	r2, [r5, #0]
    59cc:	232d      	movs	r3, #45	; 0x2d
    59ce:	6831      	ldr	r1, [r6, #0]
    59d0:	54ca      	strb	r2, [r1, r3]
			/* read the control configuration register value*/
			com_rslt += bme280_read_register(BME280_CONFIG_REG,
    59d2:	2201      	movs	r2, #1
    59d4:	0029      	movs	r1, r5
    59d6:	20f5      	movs	r0, #245	; 0xf5
    59d8:	47b8      	blx	r7
    59da:	1820      	adds	r0, r4, r0
			&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			p_bme280->config_reg = v_data_u8;
    59dc:	6832      	ldr	r2, [r6, #0]
    59de:	7829      	ldrb	r1, [r5, #0]
    59e0:	232f      	movs	r3, #47	; 0x2f
    59e2:	54d1      	strb	r1, [r2, r3]
		}
	return com_rslt;
    59e4:	b240      	sxtb	r0, r0
    59e6:	e001      	b.n	59ec <bme280_set_oversamp_humidity+0x118>
	u8 pre_ctrl_meas_value = BME280_INIT_VALUE;
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    59e8:	207f      	movs	r0, #127	; 0x7f
    59ea:	4240      	negs	r0, r0
			com_rslt += bme280_read_register(BME280_CONFIG_REG,
			&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
			p_bme280->config_reg = v_data_u8;
		}
	return com_rslt;
}
    59ec:	b002      	add	sp, #8
    59ee:	bc04      	pop	{r2}
    59f0:	4690      	mov	r8, r2
    59f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    59f4:	200002d0 	.word	0x200002d0
    59f8:	00005621 	.word	0x00005621
    59fc:	0000565d 	.word	0x0000565d
    5a00:	0000568d 	.word	0x0000568d
    5a04:	000056b5 	.word	0x000056b5

00005a08 <bme280_set_power_mode>:
 *	@retval -1 -> Error
 *
 *
*/
BME280_RETURN_FUNCTION_TYPE bme280_set_power_mode(u8 v_power_mode_u8)
{
    5a08:	b5f0      	push	{r4, r5, r6, r7, lr}
    5a0a:	b083      	sub	sp, #12
	/* used to return the communication result*/
	BME280_RETURN_FUNCTION_TYPE com_rslt = ERROR;
	u8 v_mode_u8r = BME280_INIT_VALUE;
    5a0c:	2300      	movs	r3, #0
    5a0e:	466a      	mov	r2, sp
    5a10:	71d3      	strb	r3, [r2, #7]
	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;
    5a12:	466a      	mov	r2, sp
    5a14:	7193      	strb	r3, [r2, #6]
	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;
    5a16:	466a      	mov	r2, sp
    5a18:	7153      	strb	r3, [r2, #5]
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
    5a1a:	aa01      	add	r2, sp, #4
    5a1c:	7013      	strb	r3, [r2, #0]
	u8 v_data_u8 = BME280_INIT_VALUE;
    5a1e:	466a      	mov	r2, sp
    5a20:	70d3      	strb	r3, [r2, #3]
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
    5a22:	4b34      	ldr	r3, [pc, #208]	; (5af4 <bme280_set_power_mode+0xec>)
    5a24:	681b      	ldr	r3, [r3, #0]
    5a26:	2b00      	cmp	r3, #0
    5a28:	d05c      	beq.n	5ae4 <bme280_set_power_mode+0xdc>
		return E_BME280_NULL_PTR;
		} else {
			if (v_power_mode_u8 <= BME280_NORMAL_MODE) {
    5a2a:	2803      	cmp	r0, #3
    5a2c:	d85d      	bhi.n	5aea <bme280_set_power_mode+0xe2>
				v_mode_u8r = p_bme280->ctrl_meas_reg;
    5a2e:	222e      	movs	r2, #46	; 0x2e
				v_mode_u8r =
    5a30:	5c9b      	ldrb	r3, [r3, r2]
    5a32:	3a2b      	subs	r2, #43	; 0x2b
    5a34:	4393      	bics	r3, r2
    5a36:	4010      	ands	r0, r2
    5a38:	4318      	orrs	r0, r3
    5a3a:	466b      	mov	r3, sp
    5a3c:	71d8      	strb	r0, [r3, #7]
				BME280_SET_BITSLICE(v_mode_u8r,
				BME280_CTRL_MEAS_REG_POWER_MODE,
				v_power_mode_u8);
				com_rslt = bme280_get_power_mode(
    5a3e:	466b      	mov	r3, sp
    5a40:	1d9c      	adds	r4, r3, #6
    5a42:	0020      	movs	r0, r4
    5a44:	4b2c      	ldr	r3, [pc, #176]	; (5af8 <bme280_set_power_mode+0xf0>)
    5a46:	4798      	blx	r3
					&v_prev_pow_mode_u8);
				if (v_prev_pow_mode_u8 != BME280_SLEEP_MODE) {
    5a48:	7823      	ldrb	r3, [r4, #0]
    5a4a:	2b00      	cmp	r3, #0
    5a4c:	d01e      	beq.n	5a8c <bme280_set_power_mode+0x84>
					com_rslt += bme280_set_soft_rst();
    5a4e:	4b2b      	ldr	r3, [pc, #172]	; (5afc <bme280_set_power_mode+0xf4>)
    5a50:	4798      	blx	r3
					p_bme280->delay_msec(BME280_3MS_DELAY);
    5a52:	4d28      	ldr	r5, [pc, #160]	; (5af4 <bme280_set_power_mode+0xec>)
    5a54:	682b      	ldr	r3, [r5, #0]
    5a56:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    5a58:	2003      	movs	r0, #3
    5a5a:	4798      	blx	r3
					/* write previous value of
					configuration register*/
					v_pre_config_value_u8 =
    5a5c:	a901      	add	r1, sp, #4
					p_bme280->config_reg;
    5a5e:	232f      	movs	r3, #47	; 0x2f
				if (v_prev_pow_mode_u8 != BME280_SLEEP_MODE) {
					com_rslt += bme280_set_soft_rst();
					p_bme280->delay_msec(BME280_3MS_DELAY);
					/* write previous value of
					configuration register*/
					v_pre_config_value_u8 =
    5a60:	682a      	ldr	r2, [r5, #0]
    5a62:	5cd3      	ldrb	r3, [r2, r3]
    5a64:	700b      	strb	r3, [r1, #0]
					p_bme280->config_reg;
					com_rslt = bme280_write_register(
    5a66:	2201      	movs	r2, #1
    5a68:	20f5      	movs	r0, #245	; 0xf5
    5a6a:	4c25      	ldr	r4, [pc, #148]	; (5b00 <bme280_set_power_mode+0xf8>)
    5a6c:	47a0      	blx	r4
						BME280_CONFIG_REG,
					&v_pre_config_value_u8,
					BME280_GEN_READ_WRITE_DATA_LENGTH);
					/* write previous value of
					humidity oversampling*/
					v_pre_ctrl_hum_value_u8 =
    5a6e:	466b      	mov	r3, sp
    5a70:	1d59      	adds	r1, r3, #5
					p_bme280->ctrl_hum_reg;
    5a72:	682a      	ldr	r2, [r5, #0]
    5a74:	232d      	movs	r3, #45	; 0x2d
						BME280_CONFIG_REG,
					&v_pre_config_value_u8,
					BME280_GEN_READ_WRITE_DATA_LENGTH);
					/* write previous value of
					humidity oversampling*/
					v_pre_ctrl_hum_value_u8 =
    5a76:	5cd3      	ldrb	r3, [r2, r3]
    5a78:	700b      	strb	r3, [r1, #0]
					p_bme280->ctrl_hum_reg;
					com_rslt += bme280_write_register(
    5a7a:	2201      	movs	r2, #1
    5a7c:	20f2      	movs	r0, #242	; 0xf2
    5a7e:	47a0      	blx	r4
					BME280_CTRL_HUMIDITY_REG,
					&v_pre_ctrl_hum_value_u8,
					BME280_GEN_READ_WRITE_DATA_LENGTH);
					/* write previous and updated value of
					control measurement register*/
					com_rslt += bme280_write_register(
    5a80:	2201      	movs	r2, #1
    5a82:	466b      	mov	r3, sp
    5a84:	1dd9      	adds	r1, r3, #7
    5a86:	20f4      	movs	r0, #244	; 0xf4
    5a88:	47a0      	blx	r4
    5a8a:	e009      	b.n	5aa0 <bme280_set_power_mode+0x98>
					BME280_CTRL_MEAS_REG,
					&v_mode_u8r,
					BME280_GEN_READ_WRITE_DATA_LENGTH);
				} else {
					com_rslt =
					p_bme280->BME280_BUS_WRITE_FUNC(
    5a8c:	4b19      	ldr	r3, [pc, #100]	; (5af4 <bme280_set_power_mode+0xec>)
    5a8e:	681b      	ldr	r3, [r3, #0]
    5a90:	2229      	movs	r2, #41	; 0x29
					com_rslt += bme280_write_register(
					BME280_CTRL_MEAS_REG,
					&v_mode_u8r,
					BME280_GEN_READ_WRITE_DATA_LENGTH);
				} else {
					com_rslt =
    5a92:	5c98      	ldrb	r0, [r3, r2]
    5a94:	6b1c      	ldr	r4, [r3, #48]	; 0x30
    5a96:	2301      	movs	r3, #1
    5a98:	466a      	mov	r2, sp
    5a9a:	3207      	adds	r2, #7
    5a9c:	21f4      	movs	r1, #244	; 0xf4
    5a9e:	47a0      	blx	r4
					BME280_CTRL_MEAS_REG_POWER_MODE__REG,
					&v_mode_u8r,
					BME280_GEN_READ_WRITE_DATA_LENGTH);
				}
				/* read the control measurement register value*/
				com_rslt = bme280_read_register(
    5aa0:	466b      	mov	r3, sp
    5aa2:	1cdc      	adds	r4, r3, #3
    5aa4:	2201      	movs	r2, #1
    5aa6:	0021      	movs	r1, r4
    5aa8:	20f4      	movs	r0, #244	; 0xf4
    5aaa:	4f16      	ldr	r7, [pc, #88]	; (5b04 <bme280_set_power_mode+0xfc>)
    5aac:	47b8      	blx	r7
    5aae:	0005      	movs	r5, r0
					BME280_CTRL_MEAS_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->ctrl_meas_reg = v_data_u8;
    5ab0:	4e10      	ldr	r6, [pc, #64]	; (5af4 <bme280_set_power_mode+0xec>)
    5ab2:	7822      	ldrb	r2, [r4, #0]
    5ab4:	232e      	movs	r3, #46	; 0x2e
    5ab6:	6831      	ldr	r1, [r6, #0]
    5ab8:	54ca      	strb	r2, [r1, r3]
				/* read the control humidity register value*/
				com_rslt += bme280_read_register(
    5aba:	2201      	movs	r2, #1
    5abc:	0021      	movs	r1, r4
    5abe:	20f2      	movs	r0, #242	; 0xf2
    5ac0:	47b8      	blx	r7
    5ac2:	1945      	adds	r5, r0, r5
    5ac4:	b2ed      	uxtb	r5, r5
					BME280_CTRL_HUMIDITY_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->ctrl_hum_reg = v_data_u8;
    5ac6:	7822      	ldrb	r2, [r4, #0]
    5ac8:	232d      	movs	r3, #45	; 0x2d
    5aca:	6831      	ldr	r1, [r6, #0]
    5acc:	54ca      	strb	r2, [r1, r3]
				/* read the config register value*/
				com_rslt += bme280_read_register(
    5ace:	2201      	movs	r2, #1
    5ad0:	0021      	movs	r1, r4
    5ad2:	20f5      	movs	r0, #245	; 0xf5
    5ad4:	47b8      	blx	r7
    5ad6:	1828      	adds	r0, r5, r0
					BME280_CONFIG_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->config_reg = v_data_u8;
    5ad8:	6832      	ldr	r2, [r6, #0]
    5ada:	7821      	ldrb	r1, [r4, #0]
    5adc:	232f      	movs	r3, #47	; 0x2f
    5ade:	54d1      	strb	r1, [r2, r3]
				com_rslt += bme280_read_register(
					BME280_CTRL_HUMIDITY_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->ctrl_hum_reg = v_data_u8;
				/* read the config register value*/
				com_rslt += bme280_read_register(
    5ae0:	b240      	sxtb	r0, r0
    5ae2:	e004      	b.n	5aee <bme280_set_power_mode+0xe6>
	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;
	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;
	u8 v_data_u8 = BME280_INIT_VALUE;
	/* check the p_bme280 structure pointer as NULL*/
	if (p_bme280 == BME280_NULL) {
		return E_BME280_NULL_PTR;
    5ae4:	207f      	movs	r0, #127	; 0x7f
    5ae6:	4240      	negs	r0, r0
    5ae8:	e001      	b.n	5aee <bme280_set_power_mode+0xe6>
				com_rslt += bme280_read_register(
					BME280_CONFIG_REG,
				&v_data_u8, BME280_GEN_READ_WRITE_DATA_LENGTH);
				p_bme280->config_reg = v_data_u8;
			} else {
			com_rslt = E_BME280_OUT_OF_RANGE;
    5aea:	2002      	movs	r0, #2
    5aec:	4240      	negs	r0, r0
			}
		}
	return com_rslt;
}
    5aee:	b003      	add	sp, #12
    5af0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5af2:	46c0      	nop			; (mov r8, r8)
    5af4:	200002d0 	.word	0x200002d0
    5af8:	00005621 	.word	0x00005621
    5afc:	0000565d 	.word	0x0000565d
    5b00:	0000568d 	.word	0x0000568d
    5b04:	000056b5 	.word	0x000056b5

00005b08 <BME280_I2C_bus_write>:
 *	\param reg_data : It is a value hold in the array,
 *		will be used for write the value into the register
 *	\param cnt : The no of byte of data to be write
 */
BME280_RETURN_FUNCTION_TYPE BME280_I2C_bus_write(uint8_t dev_addr, uint8_t reg_addr, uint8_t *reg_data, uint8_t cnt)
{
    5b08:	b510      	push	{r4, lr}
    5b0a:	b084      	sub	sp, #16
	uint8_t buffer[2];
	buffer[0] = reg_addr;
    5b0c:	ac03      	add	r4, sp, #12
    5b0e:	7021      	strb	r1, [r4, #0]
	buffer[1] = *reg_data;
    5b10:	7812      	ldrb	r2, [r2, #0]
    5b12:	7062      	strb	r2, [r4, #1]
	
	enum status_code sensor_wr_status = STATUS_BUSY;
	
	/* Set up internal EEPROM addr write */
	struct i2c_master_packet sensor_wr_packet = {
    5b14:	466a      	mov	r2, sp
    5b16:	8010      	strh	r0, [r2, #0]
    5b18:	3301      	adds	r3, #1
    5b1a:	8053      	strh	r3, [r2, #2]
    5b1c:	9401      	str	r4, [sp, #4]
    5b1e:	2300      	movs	r3, #0
    5b20:	7213      	strb	r3, [r2, #8]
    5b22:	7253      	strb	r3, [r2, #9]
    5b24:	7293      	strb	r3, [r2, #10]
		.ten_bit_address = false,
		.high_speed      = false,
		.hs_master_code  = 0x0,
	};
	
	sensor_wr_status = i2c_master_write_packet_wait(&i2c_master_instance,&sensor_wr_packet);
    5b26:	4669      	mov	r1, sp
    5b28:	4803      	ldr	r0, [pc, #12]	; (5b38 <BME280_I2C_bus_write+0x30>)
    5b2a:	4b04      	ldr	r3, [pc, #16]	; (5b3c <BME280_I2C_bus_write+0x34>)
    5b2c:	4798      	blx	r3
    5b2e:	1e43      	subs	r3, r0, #1
    5b30:	4198      	sbcs	r0, r3
    5b32:	4240      	negs	r0, r0
	if (sensor_wr_status != STATUS_OK){
		return ERROR;
	}
	
	return SUCCESS;
}
    5b34:	b004      	add	sp, #16
    5b36:	bd10      	pop	{r4, pc}
    5b38:	20000e6c 	.word	0x20000e6c
    5b3c:	00004f75 	.word	0x00004f75

00005b40 <BME280_I2C_bus_read>:
 *	\param reg_addr : Address of the first register, will data is going to be read
 *	\param reg_data : This data read from the sensor, which is hold in an array
 *	\param cnt : The no of data byte of to be read
 */
BME280_RETURN_FUNCTION_TYPE BME280_I2C_bus_read(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)
{
    5b40:	b570      	push	{r4, r5, r6, lr}
    5b42:	b088      	sub	sp, #32
    5b44:	0015      	movs	r5, r2
    5b46:	001e      	movs	r6, r3
    5b48:	466b      	mov	r3, sp
    5b4a:	71d9      	strb	r1, [r3, #7]
    5b4c:	3307      	adds	r3, #7

		enum status_code sensor_wr_status = STATUS_BUSY;
		enum status_code sensor_rd_status = STATUS_BUSY;
		
		/* Set up internal EEPROM addr write */
		struct i2c_master_packet sensor_wr_packet = {
    5b4e:	b284      	uxth	r4, r0
    5b50:	a905      	add	r1, sp, #20
    5b52:	800c      	strh	r4, [r1, #0]
    5b54:	2201      	movs	r2, #1
    5b56:	804a      	strh	r2, [r1, #2]
    5b58:	604b      	str	r3, [r1, #4]
    5b5a:	2300      	movs	r3, #0
    5b5c:	720b      	strb	r3, [r1, #8]
    5b5e:	724b      	strb	r3, [r1, #9]
    5b60:	728b      	strb	r3, [r1, #10]
			.ten_bit_address = false,
			.high_speed      = false,
			.hs_master_code  = 0x0,
		};
		
		sensor_wr_status = i2c_master_write_packet_wait_no_stop(&i2c_master_instance,
    5b62:	480c      	ldr	r0, [pc, #48]	; (5b94 <BME280_I2C_bus_read+0x54>)
    5b64:	4b0c      	ldr	r3, [pc, #48]	; (5b98 <BME280_I2C_bus_read+0x58>)
    5b66:	4798      	blx	r3
								&sensor_wr_packet);
								
		if (sensor_wr_status != STATUS_OK){
    5b68:	2800      	cmp	r0, #0
    5b6a:	d10e      	bne.n	5b8a <BME280_I2C_bus_read+0x4a>
			return ERROR;
		}
		
		/* Set up internal EEPROM addr write */
		struct i2c_master_packet sensor_rd_packet = {
    5b6c:	a902      	add	r1, sp, #8
    5b6e:	800c      	strh	r4, [r1, #0]
    5b70:	804e      	strh	r6, [r1, #2]
    5b72:	604d      	str	r5, [r1, #4]
    5b74:	2300      	movs	r3, #0
    5b76:	720b      	strb	r3, [r1, #8]
    5b78:	724b      	strb	r3, [r1, #9]
    5b7a:	728b      	strb	r3, [r1, #10]
			.ten_bit_address = false,
			.high_speed      = false,
			.hs_master_code  = 0x0,
		};
		
		sensor_rd_status = i2c_master_read_packet_wait(&i2c_master_instance,&sensor_rd_packet);
    5b7c:	4805      	ldr	r0, [pc, #20]	; (5b94 <BME280_I2C_bus_read+0x54>)
    5b7e:	4b07      	ldr	r3, [pc, #28]	; (5b9c <BME280_I2C_bus_read+0x5c>)
    5b80:	4798      	blx	r3
		
		if (sensor_rd_status != STATUS_OK){
    5b82:	1e43      	subs	r3, r0, #1
    5b84:	4198      	sbcs	r0, r3
    5b86:	4240      	negs	r0, r0
    5b88:	e001      	b.n	5b8e <BME280_I2C_bus_read+0x4e>
		
		sensor_wr_status = i2c_master_write_packet_wait_no_stop(&i2c_master_instance,
								&sensor_wr_packet);
								
		if (sensor_wr_status != STATUS_OK){
			return ERROR;
    5b8a:	2001      	movs	r0, #1
    5b8c:	4240      	negs	r0, r0
		}
		
		
		return SUCCESS;
	
}
    5b8e:	b008      	add	sp, #32
    5b90:	bd70      	pop	{r4, r5, r6, pc}
    5b92:	46c0      	nop			; (mov r8, r8)
    5b94:	20000e6c 	.word	0x20000e6c
    5b98:	00004f95 	.word	0x00004f95
    5b9c:	00004f55 	.word	0x00004f55

00005ba0 <BME280_delay_msek>:

/*	Brief : The delay routine
 *	\param : delay in ms
*/
void BME280_delay_msek(u32 msek)
{
    5ba0:	b510      	push	{r4, lr}
	/*Here you can write your own delay routine*/
	delay_ms(msek);
    5ba2:	4b01      	ldr	r3, [pc, #4]	; (5ba8 <BME280_delay_msek+0x8>)
    5ba4:	4798      	blx	r3
}
    5ba6:	bd10      	pop	{r4, pc}
    5ba8:	000062b1 	.word	0x000062b1

00005bac <I2C_routine>:
 *	Bus write function pointer: BME280_WR_FUNC_PTR
 *	Bus read function pointer: BME280_RD_FUNC_PTR
 *	Delay function pointer: delay_msec
 *	I2C address: dev_addr
 *--------------------------------------------------------------------------*/
	bme280_parameters.bus_write  = BME280_I2C_bus_write;
    5bac:	4b05      	ldr	r3, [pc, #20]	; (5bc4 <I2C_routine+0x18>)
    5bae:	4a06      	ldr	r2, [pc, #24]	; (5bc8 <I2C_routine+0x1c>)
    5bb0:	631a      	str	r2, [r3, #48]	; 0x30
	bme280_parameters.bus_read   = BME280_I2C_bus_read;
    5bb2:	4a06      	ldr	r2, [pc, #24]	; (5bcc <I2C_routine+0x20>)
    5bb4:	635a      	str	r2, [r3, #52]	; 0x34
	bme280_parameters.dev_addr   = BME280_I2C_ADDRESS2;
    5bb6:	2177      	movs	r1, #119	; 0x77
    5bb8:	2229      	movs	r2, #41	; 0x29
    5bba:	5499      	strb	r1, [r3, r2]
	bme280_parameters.delay_msec = BME280_delay_msek;
    5bbc:	4a04      	ldr	r2, [pc, #16]	; (5bd0 <I2C_routine+0x24>)
    5bbe:	639a      	str	r2, [r3, #56]	; 0x38
}
    5bc0:	4770      	bx	lr
    5bc2:	46c0      	nop			; (mov r8, r8)
    5bc4:	20000fac 	.word	0x20000fac
    5bc8:	00005b09 	.word	0x00005b09
    5bcc:	00005b41 	.word	0x00005b41
    5bd0:	00005ba1 	.word	0x00005ba1

00005bd4 <wearable_bme280_init>:
/* This function is an example for reading sensor data
 *	\param: None
 *	\return: communication result
 */
BME280_RETURN_FUNCTION_TYPE wearable_bme280_init(void)
{
    5bd4:	b510      	push	{r4, lr}

	/* result of communication results*/
	s32 com_rslt = ERROR;
		
	//Initialize I2C functions	
	I2C_routine();
    5bd6:	4b09      	ldr	r3, [pc, #36]	; (5bfc <wearable_bme280_init+0x28>)
    5bd8:	4798      	blx	r3
 *	I2C address
 *	Bus Write
 *	Bus read
 *	Chip id
*-------------------------------------------------------------------------*/
	com_rslt = bme280_init(&bme280_parameters);
    5bda:	4809      	ldr	r0, [pc, #36]	; (5c00 <wearable_bme280_init+0x2c>)
    5bdc:	4b09      	ldr	r3, [pc, #36]	; (5c04 <wearable_bme280_init+0x30>)
    5bde:	4798      	blx	r3
	/*	For initialization it is required to set the mode of
	 *	the sensor as "NORMAL"
	 *	data acquisition/read/write is possible in this mode
	 *	by using the below API able to set the power mode as NORMAL*/
	/* Set the power mode as NORMAL*/
	com_rslt = bme280_set_power_mode(BME280_FORCED_MODE);
    5be0:	2001      	movs	r0, #1
    5be2:	4b09      	ldr	r3, [pc, #36]	; (5c08 <wearable_bme280_init+0x34>)
    5be4:	4798      	blx	r3
	 * changes to this registers only become effective after a write operation to
	 * "BME280_CTRLMEAS_REG" register.
	 * In the code automated reading and writing of "BME280_CTRLHUM_REG_OSRSH"
	 * register first set the "BME280_CTRLHUM_REG_OSRSH" and then read and write
	 * the "BME280_CTRLMEAS_REG" register in the function*/
	com_rslt = bme280_set_oversamp_humidity(BME280_OVERSAMP_1X);
    5be6:	2001      	movs	r0, #1
    5be8:	4b08      	ldr	r3, [pc, #32]	; (5c0c <wearable_bme280_init+0x38>)
    5bea:	4798      	blx	r3
	/* set the pressure oversampling*/
	com_rslt = bme280_set_oversamp_pressure(BME280_OVERSAMP_1X);
    5bec:	2001      	movs	r0, #1
    5bee:	4b08      	ldr	r3, [pc, #32]	; (5c10 <wearable_bme280_init+0x3c>)
    5bf0:	4798      	blx	r3
	/* set the temperature oversampling*/
	com_rslt = bme280_set_oversamp_temperature(BME280_OVERSAMP_1X);
    5bf2:	2001      	movs	r0, #1
    5bf4:	4b07      	ldr	r3, [pc, #28]	; (5c14 <wearable_bme280_init+0x40>)
    5bf6:	4798      	blx	r3
// 	/* This API used to read back the written value of standby time*/
// 	com_rslt = bme280_get_standby_durn(&v_stand_by_time_u8);
	
	return com_rslt;

}
    5bf8:	bd10      	pop	{r4, pc}
    5bfa:	46c0      	nop			; (mov r8, r8)
    5bfc:	00005bad 	.word	0x00005bad
    5c00:	20000fac 	.word	0x20000fac
    5c04:	000055e1 	.word	0x000055e1
    5c08:	00005a09 	.word	0x00005a09
    5c0c:	000058d5 	.word	0x000058d5
    5c10:	000057d5 	.word	0x000057d5
    5c14:	000056dd 	.word	0x000056dd

00005c18 <touch_configure_ptc_clock>:
 *
 *
 *----------------------------------------------------------------------------*/

void touch_configure_ptc_clock(void)
{
    5c18:	b500      	push	{lr}
    5c1a:	b083      	sub	sp, #12
#if (!defined(__D1x_NONASF__))
	struct system_gclk_chan_config gclk_chan_conf;

	system_gclk_chan_get_config_defaults(&gclk_chan_conf);

	gclk_chan_conf.source_generator = GCLK_GENERATOR_1;
    5c1c:	a901      	add	r1, sp, #4
    5c1e:	2301      	movs	r3, #1
    5c20:	700b      	strb	r3, [r1, #0]

	system_gclk_chan_set_config(PTC_GCLK_ID, &gclk_chan_conf);
    5c22:	2021      	movs	r0, #33	; 0x21
    5c24:	4b05      	ldr	r3, [pc, #20]	; (5c3c <touch_configure_ptc_clock+0x24>)
    5c26:	4798      	blx	r3

	system_gclk_chan_enable(PTC_GCLK_ID);
    5c28:	2021      	movs	r0, #33	; 0x21
    5c2a:	4b05      	ldr	r3, [pc, #20]	; (5c40 <touch_configure_ptc_clock+0x28>)
    5c2c:	4798      	blx	r3
    5c2e:	4a05      	ldr	r2, [pc, #20]	; (5c44 <touch_configure_ptc_clock+0x2c>)
    5c30:	6a11      	ldr	r1, [r2, #32]
    5c32:	2320      	movs	r3, #32
    5c34:	430b      	orrs	r3, r1
    5c36:	6213      	str	r3, [r2, #32]
    system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, PM_APBCMASK_PTC);
    #endif
#else
	PM->APBCMASK.reg |= (1u << 11u);
#endif
}
    5c38:	b003      	add	sp, #12
    5c3a:	bd00      	pop	{pc}
    5c3c:	00007715 	.word	0x00007715
    5c40:	000076a5 	.word	0x000076a5
    5c44:	40000400 	.word	0x40000400

00005c48 <touch_sensors_init>:
/* ! [setup] */

/*! \brief Example application entry function.
 */
touch_ret_t touch_sensors_init(void)
{
    5c48:	b510      	push	{r4, lr}
    5c4a:	b086      	sub	sp, #24
	touch_ret_t touch_ret = TOUCH_SUCCESS;

	/* Setup and enable generic clock source for PTC module. */
	touch_configure_ptc_clock();
    5c4c:	4b26      	ldr	r3, [pc, #152]	; (5ce8 <touch_sensors_init+0xa0>)
    5c4e:	4798      	blx	r3

	touch_time.measurement_period_ms = DEF_TOUCH_MEASUREMENT_PERIOD_MS;
    5c50:	2214      	movs	r2, #20
    5c52:	4b26      	ldr	r3, [pc, #152]	; (5cec <touch_sensors_init+0xa4>)
    5c54:	801a      	strh	r2, [r3, #0]

	/* Initialize touch library for Self Cap operation. */
	touch_ret = touch_selfcap_sensors_init(&touch_config);
    5c56:	2300      	movs	r3, #0
    5c58:	9300      	str	r3, [sp, #0]
    5c5a:	2200      	movs	r2, #0
    5c5c:	2100      	movs	r1, #0
    5c5e:	4824      	ldr	r0, [pc, #144]	; (5cf0 <touch_sensors_init+0xa8>)
    5c60:	4c24      	ldr	r4, [pc, #144]	; (5cf4 <touch_sensors_init+0xac>)
    5c62:	47a0      	blx	r4
	if (touch_ret != TOUCH_SUCCESS) {
    5c64:	2800      	cmp	r0, #0
    5c66:	d000      	beq.n	5c6a <touch_sensors_init+0x22>
    5c68:	e7fe      	b.n	5c68 <touch_sensors_init+0x20>
touch_ret_t touch_sensors_config(void)
{
	touch_ret_t touch_ret = TOUCH_SUCCESS;
	sensor_id_t sensor_id;

	touch_ret = touch_selfcap_sensor_config(SENSOR_TYPE_KEY, CHANNEL_0,CHANNEL_0, NO_AKS_GROUP, 12u, HYST_25,RES_8_BIT, &sensor_id);
    5c6a:	2317      	movs	r3, #23
    5c6c:	446b      	add	r3, sp
    5c6e:	9303      	str	r3, [sp, #12]
    5c70:	2307      	movs	r3, #7
    5c72:	9302      	str	r3, [sp, #8]
    5c74:	3b06      	subs	r3, #6
    5c76:	9301      	str	r3, [sp, #4]
    5c78:	330b      	adds	r3, #11
    5c7a:	9300      	str	r3, [sp, #0]
    5c7c:	2300      	movs	r3, #0
    5c7e:	2200      	movs	r2, #0
    5c80:	2100      	movs	r1, #0
    5c82:	2001      	movs	r0, #1
    5c84:	4c1c      	ldr	r4, [pc, #112]	; (5cf8 <touch_sensors_init+0xb0>)
    5c86:	47a0      	blx	r4
	if (touch_ret != TOUCH_SUCCESS)
    5c88:	2800      	cmp	r0, #0
    5c8a:	d000      	beq.n	5c8e <touch_sensors_init+0x46>
    5c8c:	e7fe      	b.n	5c8c <touch_sensors_init+0x44>
	{
		while (1) ;
	}


	touch_ret = touch_selfcap_sensor_config(SENSOR_TYPE_KEY, CHANNEL_1,CHANNEL_1, NO_AKS_GROUP, 12u, HYST_25,RES_8_BIT, &sensor_id);
    5c8e:	2317      	movs	r3, #23
    5c90:	446b      	add	r3, sp
    5c92:	9303      	str	r3, [sp, #12]
    5c94:	2307      	movs	r3, #7
    5c96:	9302      	str	r3, [sp, #8]
    5c98:	3b06      	subs	r3, #6
    5c9a:	9301      	str	r3, [sp, #4]
    5c9c:	330b      	adds	r3, #11
    5c9e:	9300      	str	r3, [sp, #0]
    5ca0:	2300      	movs	r3, #0
    5ca2:	2201      	movs	r2, #1
    5ca4:	2101      	movs	r1, #1
    5ca6:	2001      	movs	r0, #1
    5ca8:	4c13      	ldr	r4, [pc, #76]	; (5cf8 <touch_sensors_init+0xb0>)
    5caa:	47a0      	blx	r4
	if (touch_ret != TOUCH_SUCCESS)
    5cac:	2800      	cmp	r0, #0
    5cae:	d000      	beq.n	5cb2 <touch_sensors_init+0x6a>
    5cb0:	e7fe      	b.n	5cb0 <touch_sensors_init+0x68>
	{
		while (1) ;
	}


	touch_ret = touch_selfcap_sensor_config(SENSOR_TYPE_LUMP, CHANNEL_2,CHANNEL_2, NO_AKS_GROUP, 12u, HYST_50,RES_8_BIT, &sensor_id);
    5cb2:	2317      	movs	r3, #23
    5cb4:	446b      	add	r3, sp
    5cb6:	9303      	str	r3, [sp, #12]
    5cb8:	2307      	movs	r3, #7
    5cba:	9302      	str	r3, [sp, #8]
    5cbc:	2300      	movs	r3, #0
    5cbe:	9301      	str	r3, [sp, #4]
    5cc0:	330c      	adds	r3, #12
    5cc2:	9300      	str	r3, [sp, #0]
    5cc4:	2300      	movs	r3, #0
    5cc6:	2202      	movs	r2, #2
    5cc8:	2102      	movs	r1, #2
    5cca:	2004      	movs	r0, #4
    5ccc:	4c0a      	ldr	r4, [pc, #40]	; (5cf8 <touch_sensors_init+0xb0>)
    5cce:	47a0      	blx	r4
	if (touch_ret != TOUCH_SUCCESS)
    5cd0:	2800      	cmp	r0, #0
    5cd2:	d000      	beq.n	5cd6 <touch_sensors_init+0x8e>
    5cd4:	e7fe      	b.n	5cd4 <touch_sensors_init+0x8c>
	 * the user defined values of PTC pre-scaler and series resistor is used
	 * for PTC operation as given in DEF_MUTLCAP_CLK_PRESCALE and
	 * DEF_MUTLCAP_SENSE_RESISTOR
	 *
	 */
	touch_ret = touch_selfcap_sensors_calibrate(DEF_SELF_AUTO_TUNE_VALUE);
    5cd6:	2000      	movs	r0, #0
    5cd8:	4b08      	ldr	r3, [pc, #32]	; (5cfc <touch_sensors_init+0xb4>)
    5cda:	4798      	blx	r3
	if (touch_ret != TOUCH_SUCCESS) {
    5cdc:	2800      	cmp	r0, #0
    5cde:	d000      	beq.n	5ce2 <touch_sensors_init+0x9a>
    5ce0:	e7fe      	b.n	5ce0 <touch_sensors_init+0x98>
		while (1u) {    /* Check API Error return code. */
		}
	}

	return (touch_ret);
}
    5ce2:	2000      	movs	r0, #0
    5ce4:	b006      	add	sp, #24
    5ce6:	bd10      	pop	{r4, pc}
    5ce8:	00005c19 	.word	0x00005c19
    5cec:	20000fe8 	.word	0x20000fe8
    5cf0:	20000008 	.word	0x20000008
    5cf4:	000087b5 	.word	0x000087b5
    5cf8:	00008b4d 	.word	0x00008b4d
    5cfc:	00008c11 	.word	0x00008c11

00005d00 <rtc_overflow_callback>:

/*! \brief RTC timer overflow callback
 *
 */
void rtc_overflow_callback(void)
{
    5d00:	b570      	push	{r4, r5, r6, lr}
	uint16_t power_led_period = POWER_LED_PERIOD;
	
	/* Do something on RTC overflow here */
	rtc_count_clear_compare_match(&rtc_instance,RTC_COUNT_COMPARE_0);
    5d02:	2100      	movs	r1, #0
    5d04:	484a      	ldr	r0, [pc, #296]	; (5e30 <rtc_overflow_callback+0x130>)
    5d06:	4b4b      	ldr	r3, [pc, #300]	; (5e34 <rtc_overflow_callback+0x134>)
    5d08:	4798      	blx	r3
	touch_time.time_to_measure_touch = 1u;
    5d0a:	2201      	movs	r2, #1
    5d0c:	4b4a      	ldr	r3, [pc, #296]	; (5e38 <rtc_overflow_callback+0x138>)
    5d0e:	711a      	strb	r2, [r3, #4]

	if(low_power_mode==0)
    5d10:	4b4a      	ldr	r3, [pc, #296]	; (5e3c <rtc_overflow_callback+0x13c>)
    5d12:	781b      	ldrb	r3, [r3, #0]
    5d14:	2b00      	cmp	r3, #0
    5d16:	d106      	bne.n	5d26 <rtc_overflow_callback+0x26>
	{
		touch_time.current_time_ms = touch_time.current_time_ms +
    5d18:	4a47      	ldr	r2, [pc, #284]	; (5e38 <rtc_overflow_callback+0x138>)
    5d1a:	8851      	ldrh	r1, [r2, #2]
    5d1c:	8813      	ldrh	r3, [r2, #0]
    5d1e:	18cb      	adds	r3, r1, r3
    5d20:	b29b      	uxth	r3, r3
    5d22:	8053      	strh	r3, [r2, #2]
    5d24:	e00b      	b.n	5d3e <rtc_overflow_callback+0x3e>
		touch_time.measurement_period_ms;
	}else if(low_power_mode==1)
    5d26:	2b01      	cmp	r3, #1
    5d28:	d109      	bne.n	5d3e <rtc_overflow_callback+0x3e>
	{
		touch_time.current_time_ms = touch_time.current_time_ms +
    5d2a:	4a43      	ldr	r2, [pc, #268]	; (5e38 <rtc_overflow_callback+0x138>)
    5d2c:	8853      	ldrh	r3, [r2, #2]
    5d2e:	4944      	ldr	r1, [pc, #272]	; (5e40 <rtc_overflow_callback+0x140>)
    5d30:	468c      	mov	ip, r1
    5d32:	4463      	add	r3, ip
    5d34:	b29b      	uxth	r3, r3
    5d36:	8053      	strh	r3, [r2, #2]
		DEF_LOWPOWER_SENSOR_DRIFT_PERIODICITY_MS;
		drift_wakeup=1;
    5d38:	2201      	movs	r2, #1
    5d3a:	4b42      	ldr	r3, [pc, #264]	; (5e44 <rtc_overflow_callback+0x144>)
    5d3c:	701a      	strb	r2, [r3, #0]
	}

	if(started_advertising == true)
    5d3e:	4b42      	ldr	r3, [pc, #264]	; (5e48 <rtc_overflow_callback+0x148>)
    5d40:	781d      	ldrb	r5, [r3, #0]
    5d42:	2d00      	cmp	r5, #0
    5d44:	d003      	beq.n	5d4e <rtc_overflow_callback+0x4e>
	{
		/* advertisement timer */
		advertisement_timer++;
    5d46:	4a41      	ldr	r2, [pc, #260]	; (5e4c <rtc_overflow_callback+0x14c>)
    5d48:	8813      	ldrh	r3, [r2, #0]
    5d4a:	3301      	adds	r3, #1
    5d4c:	8013      	strh	r3, [r2, #0]
	}
	
	/* 20ms tick */
	rtc_timer++;
    5d4e:	4b40      	ldr	r3, [pc, #256]	; (5e50 <rtc_overflow_callback+0x150>)
    5d50:	681a      	ldr	r2, [r3, #0]
    5d52:	1c54      	adds	r4, r2, #1
    5d54:	601c      	str	r4, [r3, #0]
	
	tick_bhi = 1;
    5d56:	2201      	movs	r2, #1
    5d58:	4b3e      	ldr	r3, [pc, #248]	; (5e54 <rtc_overflow_callback+0x154>)
    5d5a:	701a      	strb	r2, [r3, #0]
	
	if(rtc_timer % 3000 == 0)
    5d5c:	493e      	ldr	r1, [pc, #248]	; (5e58 <rtc_overflow_callback+0x158>)
    5d5e:	0020      	movs	r0, r4
    5d60:	4b3e      	ldr	r3, [pc, #248]	; (5e5c <rtc_overflow_callback+0x15c>)
    5d62:	4798      	blx	r3
    5d64:	2900      	cmp	r1, #0
    5d66:	d102      	bne.n	5d6e <rtc_overflow_callback+0x6e>
	{
		tick_60second = 1;
    5d68:	2201      	movs	r2, #1
    5d6a:	4b3d      	ldr	r3, [pc, #244]	; (5e60 <rtc_overflow_callback+0x160>)
    5d6c:	701a      	strb	r2, [r3, #0]
	if(rtc_timer % 500 == 0)
	{
		//tick_10second = 1;
	}	

	if(rtc_timer % env_sensor_period == 0)
    5d6e:	4b3d      	ldr	r3, [pc, #244]	; (5e64 <rtc_overflow_callback+0x164>)
    5d70:	7819      	ldrb	r1, [r3, #0]
    5d72:	0020      	movs	r0, r4
    5d74:	4b39      	ldr	r3, [pc, #228]	; (5e5c <rtc_overflow_callback+0x15c>)
    5d76:	4798      	blx	r3
    5d78:	2900      	cmp	r1, #0
    5d7a:	d102      	bne.n	5d82 <rtc_overflow_callback+0x82>
	{
		tick_env_sensor = 1;
    5d7c:	2201      	movs	r2, #1
    5d7e:	4b3a      	ldr	r3, [pc, #232]	; (5e68 <rtc_overflow_callback+0x168>)
    5d80:	701a      	strb	r2, [r3, #0]
	}
	if(rtc_timer % motion_sensor_period == 0)
    5d82:	4b3a      	ldr	r3, [pc, #232]	; (5e6c <rtc_overflow_callback+0x16c>)
    5d84:	7819      	ldrb	r1, [r3, #0]
    5d86:	0020      	movs	r0, r4
    5d88:	4b34      	ldr	r3, [pc, #208]	; (5e5c <rtc_overflow_callback+0x15c>)
    5d8a:	4798      	blx	r3
    5d8c:	2900      	cmp	r1, #0
    5d8e:	d102      	bne.n	5d96 <rtc_overflow_callback+0x96>
	{
		tick_motion_sensor = 1;
    5d90:	2201      	movs	r2, #1
    5d92:	4b37      	ldr	r3, [pc, #220]	; (5e70 <rtc_overflow_callback+0x170>)
    5d94:	701a      	strb	r2, [r3, #0]
	}
	
	if(rtc_timer % ble_event_task_period == 0)
    5d96:	4b37      	ldr	r3, [pc, #220]	; (5e74 <rtc_overflow_callback+0x174>)
    5d98:	7819      	ldrb	r1, [r3, #0]
    5d9a:	0020      	movs	r0, r4
    5d9c:	4b2f      	ldr	r3, [pc, #188]	; (5e5c <rtc_overflow_callback+0x15c>)
    5d9e:	4798      	blx	r3
    5da0:	2900      	cmp	r1, #0
    5da2:	d102      	bne.n	5daa <rtc_overflow_callback+0xaa>
	{
		tick_ble_event_task = 1;
    5da4:	2201      	movs	r2, #1
    5da6:	4b34      	ldr	r3, [pc, #208]	; (5e78 <rtc_overflow_callback+0x178>)
    5da8:	701a      	strb	r2, [r3, #0]
	}
	if(rtc_timer % 400 == 0)
	{
		//tick_2second = 1;
	}
	if(rtc_timer % 50 == 0)
    5daa:	2132      	movs	r1, #50	; 0x32
    5dac:	0020      	movs	r0, r4
    5dae:	4b2b      	ldr	r3, [pc, #172]	; (5e5c <rtc_overflow_callback+0x15c>)
    5db0:	4798      	blx	r3
    5db2:	2900      	cmp	r1, #0
    5db4:	d106      	bne.n	5dc4 <rtc_overflow_callback+0xc4>
	{
		tick_1second = 1;
    5db6:	2201      	movs	r2, #1
    5db8:	4b30      	ldr	r3, [pc, #192]	; (5e7c <rtc_overflow_callback+0x17c>)
    5dba:	701a      	strb	r2, [r3, #0]
		if(started_advertising == 1)
    5dbc:	2d00      	cmp	r5, #0
    5dbe:	d001      	beq.n	5dc4 <rtc_overflow_callback+0xc4>
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Toggle pin output level */
	port_base->OUTTGL.reg = pin_mask;
    5dc0:	4b2f      	ldr	r3, [pc, #188]	; (5e80 <rtc_overflow_callback+0x180>)
    5dc2:	61da      	str	r2, [r3, #28]
/* inline functions */

/* check ble connection established */
static inline bool is_ble_connection_established(void)
{
	return (connection_established_flag);
    5dc4:	4b2f      	ldr	r3, [pc, #188]	; (5e84 <rtc_overflow_callback+0x184>)
    5dc6:	781b      	ldrb	r3, [r3, #0]
			port_pin_toggle_output_level(BLE_LED);
		}
	}
	
	/* BLE active state LED handling */
	if(is_ble_connection_established())	
    5dc8:	2b00      	cmp	r3, #0
    5dca:	d012      	beq.n	5df2 <rtc_overflow_callback+0xf2>
	{
		ble_led_timer++;
    5dcc:	4a2e      	ldr	r2, [pc, #184]	; (5e88 <rtc_overflow_callback+0x188>)
    5dce:	7813      	ldrb	r3, [r2, #0]
    5dd0:	3301      	adds	r3, #1
    5dd2:	b2db      	uxtb	r3, r3
    5dd4:	7013      	strb	r3, [r2, #0]
		
		if(ble_led_timer > BLE_LED_PERIOD)
    5dd6:	2b32      	cmp	r3, #50	; 0x32
    5dd8:	d906      	bls.n	5de8 <rtc_overflow_callback+0xe8>
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    5dda:	2201      	movs	r2, #1
    5ddc:	4b28      	ldr	r3, [pc, #160]	; (5e80 <rtc_overflow_callback+0x180>)
    5dde:	619a      	str	r2, [r3, #24]
		{
			turn_off_ble_led();
			ble_led_timer = 0;
    5de0:	2200      	movs	r2, #0
    5de2:	4b29      	ldr	r3, [pc, #164]	; (5e88 <rtc_overflow_callback+0x188>)
    5de4:	701a      	strb	r2, [r3, #0]
    5de6:	e004      	b.n	5df2 <rtc_overflow_callback+0xf2>
		}		
		else if(ble_led_timer > (BLE_LED_PERIOD - 1))
    5de8:	2b31      	cmp	r3, #49	; 0x31
    5dea:	d902      	bls.n	5df2 <rtc_overflow_callback+0xf2>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    5dec:	2201      	movs	r2, #1
    5dee:	4b24      	ldr	r3, [pc, #144]	; (5e80 <rtc_overflow_callback+0x180>)
    5df0:	615a      	str	r2, [r3, #20]
			turn_on_ble_led();
		}
	}
	
	/* power LED handling */
	power_led_timer++;
    5df2:	4a26      	ldr	r2, [pc, #152]	; (5e8c <rtc_overflow_callback+0x18c>)
    5df4:	8813      	ldrh	r3, [r2, #0]
    5df6:	3301      	adds	r3, #1
    5df8:	b29b      	uxth	r3, r3
    5dfa:	8013      	strh	r3, [r2, #0]
	
	if(low_battery_flag == 1)
    5dfc:	4a24      	ldr	r2, [pc, #144]	; (5e90 <rtc_overflow_callback+0x190>)
    5dfe:	7812      	ldrb	r2, [r2, #0]
    5e00:	2a00      	cmp	r2, #0
    5e02:	d002      	beq.n	5e0a <rtc_overflow_callback+0x10a>
	{
		power_led_period = POWER_LED_LOW_BATTERY_PERIOD; 	
    5e04:	22fa      	movs	r2, #250	; 0xfa
    5e06:	0052      	lsls	r2, r2, #1
    5e08:	e000      	b.n	5e0c <rtc_overflow_callback+0x10c>
/*! \brief RTC timer overflow callback
 *
 */
void rtc_overflow_callback(void)
{
	uint16_t power_led_period = POWER_LED_PERIOD;
    5e0a:	4a13      	ldr	r2, [pc, #76]	; (5e58 <rtc_overflow_callback+0x158>)
	if(low_battery_flag == 1)
	{
		power_led_period = POWER_LED_LOW_BATTERY_PERIOD; 	
	}
	
	if(power_led_timer > power_led_period)
    5e0c:	429a      	cmp	r2, r3
    5e0e:	d207      	bcs.n	5e20 <rtc_overflow_callback+0x120>
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    5e10:	2280      	movs	r2, #128	; 0x80
    5e12:	0312      	lsls	r2, r2, #12
    5e14:	4b1a      	ldr	r3, [pc, #104]	; (5e80 <rtc_overflow_callback+0x180>)
    5e16:	619a      	str	r2, [r3, #24]
	{
		turn_off_power_led();
		power_led_timer = 0;
    5e18:	2200      	movs	r2, #0
    5e1a:	4b1c      	ldr	r3, [pc, #112]	; (5e8c <rtc_overflow_callback+0x18c>)
    5e1c:	801a      	strh	r2, [r3, #0]
    5e1e:	e006      	b.n	5e2e <rtc_overflow_callback+0x12e>
	}
	else if(power_led_timer > (power_led_period - 1))
    5e20:	3a01      	subs	r2, #1
    5e22:	4293      	cmp	r3, r2
    5e24:	dd03      	ble.n	5e2e <rtc_overflow_callback+0x12e>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    5e26:	2280      	movs	r2, #128	; 0x80
    5e28:	0312      	lsls	r2, r2, #12
    5e2a:	4b15      	ldr	r3, [pc, #84]	; (5e80 <rtc_overflow_callback+0x180>)
    5e2c:	615a      	str	r2, [r3, #20]
	{
		turn_on_power_led();
	}
}
    5e2e:	bd70      	pop	{r4, r5, r6, pc}
    5e30:	20000ff4 	.word	0x20000ff4
    5e34:	00006101 	.word	0x00006101
    5e38:	20000fe8 	.word	0x20000fe8
    5e3c:	200013d8 	.word	0x200013d8
    5e40:	00002710 	.word	0x00002710
    5e44:	20000388 	.word	0x20000388
    5e48:	200010e9 	.word	0x200010e9
    5e4c:	20001270 	.word	0x20001270
    5e50:	20001030 	.word	0x20001030
    5e54:	20001035 	.word	0x20001035
    5e58:	00000bb8 	.word	0x00000bb8
    5e5c:	0000a499 	.word	0x0000a499
    5e60:	20000ff0 	.word	0x20000ff0
    5e64:	200000a4 	.word	0x200000a4
    5e68:	20001039 	.word	0x20001039
    5e6c:	200000a5 	.word	0x200000a5
    5e70:	2000103d 	.word	0x2000103d
    5e74:	200000a6 	.word	0x200000a6
    5e78:	2000103c 	.word	0x2000103c
    5e7c:	20001036 	.word	0x20001036
    5e80:	40002800 	.word	0x40002800
    5e84:	20001300 	.word	0x20001300
    5e88:	2000103a 	.word	0x2000103a
    5e8c:	2000102c 	.word	0x2000102c
    5e90:	20000389 	.word	0x20000389

00005e94 <configure_rtc_callbacks>:

/*! \brief Configure the RTC timer callback
 *
 */
void configure_rtc_callbacks(void)
{
    5e94:	b510      	push	{r4, lr}
	/* register callback */
	rtc_count_register_callback(&rtc_instance,
    5e96:	4c05      	ldr	r4, [pc, #20]	; (5eac <configure_rtc_callbacks+0x18>)
    5e98:	2208      	movs	r2, #8
    5e9a:	4905      	ldr	r1, [pc, #20]	; (5eb0 <configure_rtc_callbacks+0x1c>)
    5e9c:	0020      	movs	r0, r4
    5e9e:	4b05      	ldr	r3, [pc, #20]	; (5eb4 <configure_rtc_callbacks+0x20>)
    5ea0:	4798      	blx	r3
			rtc_overflow_callback, RTC_COUNT_CALLBACK_COMPARE_0);
	/* Enable callback */
	rtc_count_enable_callback(&rtc_instance, RTC_COUNT_CALLBACK_COMPARE_0);
    5ea2:	2108      	movs	r1, #8
    5ea4:	0020      	movs	r0, r4
    5ea6:	4b04      	ldr	r3, [pc, #16]	; (5eb8 <configure_rtc_callbacks+0x24>)
    5ea8:	4798      	blx	r3
}
    5eaa:	bd10      	pop	{r4, pc}
    5eac:	20000ff4 	.word	0x20000ff4
    5eb0:	00005d01 	.word	0x00005d01
    5eb4:	00006135 	.word	0x00006135
    5eb8:	00006171 	.word	0x00006171

00005ebc <configure_rtc_count>:

/*! \brief Configure the RTC timer count after which interrupts comes
 *
 */
void configure_rtc_count(void)
{
    5ebc:	b530      	push	{r4, r5, lr}
    5ebe:	b089      	sub	sp, #36	; 0x24
	volatile uint16_t temp;
	
	struct rtc_count_events config_rtc_event
    5ec0:	ac04      	add	r4, sp, #16
    5ec2:	220b      	movs	r2, #11
    5ec4:	2100      	movs	r1, #0
    5ec6:	0020      	movs	r0, r4
    5ec8:	4b1c      	ldr	r3, [pc, #112]	; (5f3c <configure_rtc_count+0x80>)
    5eca:	4798      	blx	r3
    5ecc:	2301      	movs	r3, #1
    5ece:	7263      	strb	r3, [r4, #9]
	/* Sanity check argument */
	Assert(config);

	/* Set default into configuration structure */
	config->prescaler           = RTC_COUNT_PRESCALER_DIV_1024;
	config->mode                = RTC_COUNT_MODE_32BIT;
    5ed0:	466a      	mov	r2, sp
    5ed2:	7093      	strb	r3, [r2, #2]
	config->clear_on_match      = false;

#ifdef FEATURE_RTC_CONTINUOUSLY_UPDATED
	config->continuously_update = false;
    5ed4:	2200      	movs	r2, #0
    5ed6:	4669      	mov	r1, sp
    5ed8:	710a      	strb	r2, [r1, #4]
#if (SAML22)
	config->enable_read_sync    = true;
#endif

	for (uint8_t i = 0; i < RTC_NUM_OF_COMP16; i++) {
		config->compare_values[i] = 0;
    5eda:	9202      	str	r2, [sp, #8]
    5edc:	9203      	str	r2, [sp, #12]
		 = { .generate_event_on_periodic[DEF_LOWPOWER_SENSOR_EVENT_PERIODICITY_OFFSET] = true };
	struct rtc_count_config config_rtc_count;
	rtc_count_get_config_defaults(&config_rtc_count);

	config_rtc_count.prescaler           = RTC_MODE0_CTRLA_PRESCALER_DIV1;
    5ede:	3201      	adds	r2, #1
    5ee0:	32ff      	adds	r2, #255	; 0xff
    5ee2:	800a      	strh	r2, [r1, #0]
	config_rtc_count.mode                = RTC_COUNT_MODE_32BIT;
	config_rtc_count.clear_on_match =true;
    5ee4:	466a      	mov	r2, sp
    5ee6:	70cb      	strb	r3, [r1, #3]

	/* initialize rtc */
	rtc_count_init(&rtc_instance, RTC, &config_rtc_count);
    5ee8:	4c15      	ldr	r4, [pc, #84]	; (5f40 <configure_rtc_count+0x84>)
    5eea:	4916      	ldr	r1, [pc, #88]	; (5f44 <configure_rtc_count+0x88>)
    5eec:	0020      	movs	r0, r4
    5eee:	4b16      	ldr	r3, [pc, #88]	; (5f48 <configure_rtc_count+0x8c>)
    5ef0:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    5ef2:	6825      	ldr	r5, [r4, #0]
    5ef4:	2300      	movs	r3, #0
    5ef6:	2100      	movs	r1, #0
	}

	/* Check if the user has requested any periodic events */
	for (uint8_t i = 0; i < 8; i++) {
		if (events->generate_event_on_periodic[i]) {
			event_mask |= RTC_MODE0_EVCTRL_PEREO(1 << i);
    5ef8:	2401      	movs	r4, #1
    5efa:	20ff      	movs	r0, #255	; 0xff
		}
	}

	/* Check if the user has requested any periodic events */
	for (uint8_t i = 0; i < 8; i++) {
		if (events->generate_event_on_periodic[i]) {
    5efc:	aa04      	add	r2, sp, #16
    5efe:	18d2      	adds	r2, r2, r3
    5f00:	78d2      	ldrb	r2, [r2, #3]
    5f02:	2a00      	cmp	r2, #0
    5f04:	d003      	beq.n	5f0e <configure_rtc_count+0x52>
			event_mask |= RTC_MODE0_EVCTRL_PEREO(1 << i);
    5f06:	0022      	movs	r2, r4
    5f08:	409a      	lsls	r2, r3
    5f0a:	4002      	ands	r2, r0
    5f0c:	4311      	orrs	r1, r2
    5f0e:	3301      	adds	r3, #1
			event_mask |= RTC_MODE0_EVCTRL_CMPEO(1 << i);
		}
	}

	/* Check if the user has requested any periodic events */
	for (uint8_t i = 0; i < 8; i++) {
    5f10:	2b08      	cmp	r3, #8
    5f12:	d1f3      	bne.n	5efc <configure_rtc_count+0x40>
		event_mask |= RTC_MODE0_EVCTRL_TAMPEVEI;
	}
#endif

	/* Enable given event(s). */
	rtc_module->MODE0.EVCTRL.reg |= event_mask;
    5f14:	686b      	ldr	r3, [r5, #4]
    5f16:	4319      	orrs	r1, r3
    5f18:	6069      	str	r1, [r5, #4]
	/* Enable RTC events */
	config_rtc_event.generate_event_on_periodic[DEF_LOWPOWER_SENSOR_EVENT_PERIODICITY_OFFSET] = true;
	
	rtc_count_enable_events(&rtc_instance, &config_rtc_event);

	temp = TIME_PERIOD_1MSEC * DEF_TOUCH_MEASUREMENT_PERIOD_MS;
    5f1a:	231e      	movs	r3, #30
    5f1c:	446b      	add	r3, sp
    5f1e:	2214      	movs	r2, #20
    5f20:	801a      	strh	r2, [r3, #0]

	rtc_count_set_compare(&rtc_instance,temp,RTC_COUNT_COMPARE_0);
    5f22:	8819      	ldrh	r1, [r3, #0]
    5f24:	b289      	uxth	r1, r1
    5f26:	4c06      	ldr	r4, [pc, #24]	; (5f40 <configure_rtc_count+0x84>)
    5f28:	2200      	movs	r2, #0
    5f2a:	0020      	movs	r0, r4
    5f2c:	4b07      	ldr	r3, [pc, #28]	; (5f4c <configure_rtc_count+0x90>)
    5f2e:	4798      	blx	r3

	/* enable rtc */
	rtc_count_enable(&rtc_instance);
    5f30:	0020      	movs	r0, r4
    5f32:	4b07      	ldr	r3, [pc, #28]	; (5f50 <configure_rtc_count+0x94>)
    5f34:	4798      	blx	r3

}
    5f36:	b009      	add	sp, #36	; 0x24
    5f38:	bd30      	pop	{r4, r5, pc}
    5f3a:	46c0      	nop			; (mov r8, r8)
    5f3c:	0000a75f 	.word	0x0000a75f
    5f40:	20000ff4 	.word	0x20000ff4
    5f44:	40002000 	.word	0x40002000
    5f48:	00006069 	.word	0x00006069
    5f4c:	00006005 	.word	0x00006005
    5f50:	00005fd1 	.word	0x00005fd1

00005f54 <rtc_init>:

/*! \brief Initialize RTC timer
 *
 */
void rtc_init(void)
{
    5f54:	b510      	push	{r4, lr}
	/* Configure and enable RTC */
	configure_rtc_count();
    5f56:	4b02      	ldr	r3, [pc, #8]	; (5f60 <rtc_init+0xc>)
    5f58:	4798      	blx	r3

	/* Configure and enable callback */
	configure_rtc_callbacks();
    5f5a:	4b02      	ldr	r3, [pc, #8]	; (5f64 <rtc_init+0x10>)
    5f5c:	4798      	blx	r3
}
    5f5e:	bd10      	pop	{r4, pc}
    5f60:	00005ebd 	.word	0x00005ebd
    5f64:	00005e95 	.word	0x00005e95

00005f68 <EVSYS_Handler>:

	return STATUS_OK;
}

void EVSYS_Handler(void)
{
    5f68:	b510      	push	{r4, lr}
	struct events_hook *current_hook = _events_inst.hook_list;
    5f6a:	4b0c      	ldr	r3, [pc, #48]	; (5f9c <EVSYS_Handler+0x34>)
    5f6c:	691c      	ldr	r4, [r3, #16]
	uint32_t flag;

	/* Synch the interrupt flag buffer with the hardware register */
	flag = EVSYS->INTFLAG.reg;
    5f6e:	2186      	movs	r1, #134	; 0x86
    5f70:	05c9      	lsls	r1, r1, #23
    5f72:	6988      	ldr	r0, [r1, #24]
	_events_inst.interrupt_flag_buffer |= flag;
    5f74:	689a      	ldr	r2, [r3, #8]
    5f76:	4302      	orrs	r2, r0
    5f78:	609a      	str	r2, [r3, #8]
	/* Clear all hardware interrupt flags */
	EVSYS->INTFLAG.reg = _EVENTS_INTFLAGS_MASK;
    5f7a:	4b09      	ldr	r3, [pc, #36]	; (5fa0 <EVSYS_Handler+0x38>)
    5f7c:	618b      	str	r3, [r1, #24]

	/* Traverse the linked list */
	while (current_hook != NULL) {
    5f7e:	2c00      	cmp	r4, #0
    5f80:	d005      	beq.n	5f8e <EVSYS_Handler+0x26>
		current_hook->hook_func(current_hook->resource);
    5f82:	6820      	ldr	r0, [r4, #0]
    5f84:	6863      	ldr	r3, [r4, #4]
    5f86:	4798      	blx	r3
		current_hook = current_hook->next;
    5f88:	68a4      	ldr	r4, [r4, #8]
	_events_inst.interrupt_flag_buffer |= flag;
	/* Clear all hardware interrupt flags */
	EVSYS->INTFLAG.reg = _EVENTS_INTFLAGS_MASK;

	/* Traverse the linked list */
	while (current_hook != NULL) {
    5f8a:	2c00      	cmp	r4, #0
    5f8c:	d1f9      	bne.n	5f82 <EVSYS_Handler+0x1a>
		current_hook->hook_func(current_hook->resource);
		current_hook = current_hook->next;
	}

	/* Clear acknowledged interrupt sources from the interrupt flag buffer */
	flag = _events_inst.interrupt_flag_ack_buffer;
    5f8e:	4b03      	ldr	r3, [pc, #12]	; (5f9c <EVSYS_Handler+0x34>)
    5f90:	68d9      	ldr	r1, [r3, #12]
	_events_inst.interrupt_flag_buffer &= ~flag;
    5f92:	689a      	ldr	r2, [r3, #8]
    5f94:	438a      	bics	r2, r1
    5f96:	609a      	str	r2, [r3, #8]
}
    5f98:	bd10      	pop	{r4, pc}
    5f9a:	46c0      	nop			; (mov r8, r8)
    5f9c:	20000090 	.word	0x20000090
    5fa0:	0fff0fff 	.word	0x0fff0fff

00005fa4 <_system_events_init>:
    5fa4:	4906      	ldr	r1, [pc, #24]	; (5fc0 <_system_events_init+0x1c>)
    5fa6:	6a0b      	ldr	r3, [r1, #32]
    5fa8:	2201      	movs	r2, #1
    5faa:	4313      	orrs	r3, r2
    5fac:	620b      	str	r3, [r1, #32]
	/* Enable EVSYS register interface */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, MCLK_APBDMASK_EVSYS);
#endif

	/* Make sure the EVSYS module is properly reset */
	EVSYS->CTRLA.reg = EVSYS_CTRLA_SWRST;
    5fae:	2386      	movs	r3, #134	; 0x86
    5fb0:	05db      	lsls	r3, r3, #23
    5fb2:	701a      	strb	r2, [r3, #0]

	while (EVSYS->CTRLA.reg & EVSYS_CTRLA_SWRST) {
    5fb4:	0019      	movs	r1, r3
    5fb6:	780b      	ldrb	r3, [r1, #0]
    5fb8:	4213      	tst	r3, r2
    5fba:	d1fc      	bne.n	5fb6 <_system_events_init+0x12>
	}
}
    5fbc:	4770      	bx	lr
    5fbe:	46c0      	nop			; (mov r8, r8)
    5fc0:	40000400 	.word	0x40000400

00005fc4 <rtc_count_is_syncing>:
{
 	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    5fc4:	6803      	ldr	r3, [r0, #0]

	if (rtc_module->MODE0.SYNCBUSY.reg) {
    5fc6:	6918      	ldr	r0, [r3, #16]
    5fc8:	1e43      	subs	r3, r0, #1
    5fca:	4198      	sbcs	r0, r3
    5fcc:	b2c0      	uxtb	r0, r0
		return true;
	}

	return false;
}
    5fce:	4770      	bx	lr

00005fd0 <rtc_count_enable>:
 * module configuration parameters cannot be altered while the module is enabled.
 *
 * \param[in,out]  module  RTC hardware module
 */
void rtc_count_enable(struct rtc_module *const module)
{
    5fd0:	b570      	push	{r4, r5, r6, lr}
    5fd2:	0004      	movs	r4, r0
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    5fd4:	6806      	ldr	r6, [r0, #0]
    5fd6:	2204      	movs	r2, #4
    5fd8:	4b08      	ldr	r3, [pc, #32]	; (5ffc <rtc_count_enable+0x2c>)
    5fda:	601a      	str	r2, [r3, #0]

#if RTC_COUNT_ASYNC == true
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_RTC);
#endif

	while (rtc_count_is_syncing(module)) {
    5fdc:	4d08      	ldr	r5, [pc, #32]	; (6000 <rtc_count_enable+0x30>)
    5fde:	0020      	movs	r0, r4
    5fe0:	47a8      	blx	r5
    5fe2:	2800      	cmp	r0, #0
    5fe4:	d1fb      	bne.n	5fde <rtc_count_enable+0xe>
		/* Wait for synchronization */
	}

	/* Enable RTC module. */
	rtc_module->MODE0.CTRLA.reg |= RTC_MODE0_CTRLA_ENABLE;
    5fe6:	8832      	ldrh	r2, [r6, #0]
    5fe8:	2302      	movs	r3, #2
    5fea:	4313      	orrs	r3, r2
    5fec:	8033      	strh	r3, [r6, #0]

	while (rtc_count_is_syncing(module)) {
    5fee:	4d04      	ldr	r5, [pc, #16]	; (6000 <rtc_count_enable+0x30>)
    5ff0:	0020      	movs	r0, r4
    5ff2:	47a8      	blx	r5
    5ff4:	2800      	cmp	r0, #0
    5ff6:	d1fb      	bne.n	5ff0 <rtc_count_enable+0x20>
		/* Wait for synchronization */
	}
}
    5ff8:	bd70      	pop	{r4, r5, r6, pc}
    5ffa:	46c0      	nop			; (mov r8, r8)
    5ffc:	e000e100 	.word	0xe000e100
    6000:	00005fc5 	.word	0x00005fc5

00006004 <rtc_count_set_compare>:
 */
enum status_code rtc_count_set_compare(
		struct rtc_module *const module,
		const uint32_t comp_value,
		const enum rtc_count_compare comp_index)
{
    6004:	b5f0      	push	{r4, r5, r6, r7, lr}
    6006:	b083      	sub	sp, #12
    6008:	0004      	movs	r4, r0
    600a:	9101      	str	r1, [sp, #4]
    600c:	0015      	movs	r5, r2
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    600e:	6806      	ldr	r6, [r0, #0]

	while (rtc_count_is_syncing(module)) {
    6010:	4f13      	ldr	r7, [pc, #76]	; (6060 <rtc_count_set_compare+0x5c>)
    6012:	0020      	movs	r0, r4
    6014:	47b8      	blx	r7
    6016:	2800      	cmp	r0, #0
    6018:	d1fb      	bne.n	6012 <rtc_count_set_compare+0xe>
		/* Wait for synchronization */
	}

	/* Set compare values based on operation mode. */
	switch (module->mode) {
    601a:	7923      	ldrb	r3, [r4, #4]
    601c:	2b00      	cmp	r3, #0
    601e:	d009      	beq.n	6034 <rtc_count_set_compare+0x30>
    6020:	2b01      	cmp	r3, #1
    6022:	d119      	bne.n	6058 <rtc_count_set_compare+0x54>
		case RTC_COUNT_MODE_32BIT:
			/* Check sanity of comp_index. */
			if ((uint32_t)comp_index > RTC_COMP32_NUM) {
				return STATUS_ERR_INVALID_ARG;
    6024:	3017      	adds	r0, #23

	/* Set compare values based on operation mode. */
	switch (module->mode) {
		case RTC_COUNT_MODE_32BIT:
			/* Check sanity of comp_index. */
			if ((uint32_t)comp_index > RTC_COMP32_NUM) {
    6026:	2d01      	cmp	r5, #1
    6028:	d817      	bhi.n	605a <rtc_count_set_compare+0x56>
				return STATUS_ERR_INVALID_ARG;
			}

			/* Set compare value for COMP. */
			rtc_module->MODE0.COMP[comp_index].reg = comp_value;
    602a:	3508      	adds	r5, #8
    602c:	00ad      	lsls	r5, r5, #2
    602e:	9b01      	ldr	r3, [sp, #4]
    6030:	51ab      	str	r3, [r5, r6]

			break;
    6032:	e00b      	b.n	604c <rtc_count_set_compare+0x48>

		case RTC_COUNT_MODE_16BIT:
			/* Check sanity of comp_index. */
			if ((uint32_t)comp_index > RTC_NUM_OF_COMP16) {
				return STATUS_ERR_INVALID_ARG;
    6034:	2017      	movs	r0, #23

			break;

		case RTC_COUNT_MODE_16BIT:
			/* Check sanity of comp_index. */
			if ((uint32_t)comp_index > RTC_NUM_OF_COMP16) {
    6036:	2d02      	cmp	r5, #2
    6038:	d80f      	bhi.n	605a <rtc_count_set_compare+0x56>
				return STATUS_ERR_INVALID_ARG;
			}

			/* Check that 16-bit value is provided. */
			if (comp_value > 0xffff) {
    603a:	4b0a      	ldr	r3, [pc, #40]	; (6064 <rtc_count_set_compare+0x60>)
    603c:	9a01      	ldr	r2, [sp, #4]
    603e:	429a      	cmp	r2, r3
    6040:	d80b      	bhi.n	605a <rtc_count_set_compare+0x56>
				Assert(false);
				return STATUS_ERR_INVALID_ARG;
			}

			/* Set compare value for COMP. */
			rtc_module->MODE1.COMP[comp_index].reg = comp_value & 0xffff;
    6042:	466b      	mov	r3, sp
    6044:	889b      	ldrh	r3, [r3, #4]
    6046:	3510      	adds	r5, #16
    6048:	006d      	lsls	r5, r5, #1
    604a:	53ab      	strh	r3, [r5, r6]
		default:
			Assert(false);
			return STATUS_ERR_BAD_FORMAT;
	}

	while (rtc_count_is_syncing(module)) {
    604c:	4d04      	ldr	r5, [pc, #16]	; (6060 <rtc_count_set_compare+0x5c>)
    604e:	0020      	movs	r0, r4
    6050:	47a8      	blx	r5
    6052:	2800      	cmp	r0, #0
    6054:	d1fb      	bne.n	604e <rtc_count_set_compare+0x4a>
    6056:	e000      	b.n	605a <rtc_count_set_compare+0x56>

			break;

		default:
			Assert(false);
			return STATUS_ERR_BAD_FORMAT;
    6058:	201a      	movs	r0, #26
		/* Wait for synchronization */
	}

	/* Return status if everything is OK. */
	return STATUS_OK;
}
    605a:	b003      	add	sp, #12
    605c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    605e:	46c0      	nop			; (mov r8, r8)
    6060:	00005fc5 	.word	0x00005fc5
    6064:	0000ffff 	.word	0x0000ffff

00006068 <rtc_count_init>:
 */
enum status_code rtc_count_init(
		struct rtc_module *const module,
		Rtc *const hw,
		const struct rtc_count_config *const config)
{
    6068:	b570      	push	{r4, r5, r6, lr}
    606a:	0005      	movs	r5, r0
    606c:	0014      	movs	r4, r2
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize device instance */
	module->hw = hw;
    606e:	6001      	str	r1, [r0, #0]
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			MCLK->APBAMASK.reg |= mask;
    6070:	4a1f      	ldr	r2, [pc, #124]	; (60f0 <rtc_count_init+0x88>)
    6072:	6953      	ldr	r3, [r2, #20]
    6074:	2180      	movs	r1, #128	; 0x80
    6076:	0049      	lsls	r1, r1, #1
    6078:	430b      	orrs	r3, r1
    607a:	6153      	str	r3, [r2, #20]

	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, MCLK_APBAMASK_RTC);

	/* Select RTC clock */
	OSC32KCTRL->RTCCTRL.reg = RTC_CLOCK_SOURCE;
    607c:	2200      	movs	r2, #0
    607e:	4b1d      	ldr	r3, [pc, #116]	; (60f4 <rtc_count_init+0x8c>)
    6080:	611a      	str	r2, [r3, #16]
     */ 
	/* Reset module to hardware defaults. */
    /* rtc_count_reset(module); */

	/* Save conf_struct internally for continued use. */
	module->mode                = config->mode;
    6082:	78a3      	ldrb	r3, [r4, #2]
    6084:	7103      	strb	r3, [r0, #4]

#  if (RTC_INST_NUM == 1)
	_rtc_instance[0] = module;
    6086:	4b1c      	ldr	r3, [pc, #112]	; (60f8 <rtc_count_init+0x90>)
    6088:	6018      	str	r0, [r3, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    608a:	6801      	ldr	r1, [r0, #0]

#if SAML21
	rtc_module->MODE0.CTRLA.reg = RTC_MODE0_CTRLA_MODE(0)
    608c:	7963      	ldrb	r3, [r4, #5]
    608e:	03db      	lsls	r3, r3, #15
    6090:	8822      	ldrh	r2, [r4, #0]
    6092:	4313      	orrs	r3, r2
    6094:	b29b      	uxth	r3, r3
    6096:	800b      	strh	r3, [r1, #0]
	rtc_module->MODE0.CTRLA.reg = RTC_MODE0_CTRLA_MODE(0) | config->prescaler
			| (config->enable_read_sync << RTC_MODE0_CTRLA_COUNTSYNC_Pos);
#endif

	/* Set mode and clear on match if applicable. */
	switch (config->mode) {
    6098:	78a3      	ldrb	r3, [r4, #2]
    609a:	2b00      	cmp	r3, #0
    609c:	d013      	beq.n	60c6 <rtc_count_init+0x5e>
						(enum rtc_count_compare)i);
			}
			break;
		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    609e:	2017      	movs	r0, #23
	rtc_module->MODE0.CTRLA.reg = RTC_MODE0_CTRLA_MODE(0) | config->prescaler
			| (config->enable_read_sync << RTC_MODE0_CTRLA_COUNTSYNC_Pos);
#endif

	/* Set mode and clear on match if applicable. */
	switch (config->mode) {
    60a0:	2b01      	cmp	r3, #1
    60a2:	d123      	bne.n	60ec <rtc_count_init+0x84>
		case RTC_COUNT_MODE_32BIT:
			/* Set 32-bit mode and clear on match if applicable. */
			rtc_module->MODE0.CTRLA.reg |= RTC_MODE0_CTRLA_MODE(0);
    60a4:	880b      	ldrh	r3, [r1, #0]
    60a6:	b29b      	uxth	r3, r3
    60a8:	800b      	strh	r3, [r1, #0]

			/* Check if clear on compare match should be set. */
			if (config->clear_on_match) {
    60aa:	78e3      	ldrb	r3, [r4, #3]
    60ac:	2b00      	cmp	r3, #0
    60ae:	d003      	beq.n	60b8 <rtc_count_init+0x50>
				/* Set clear on match. */
				rtc_module->MODE0.CTRLA.reg |= RTC_MODE0_CTRLA_MATCHCLR;
    60b0:	880a      	ldrh	r2, [r1, #0]
    60b2:	2380      	movs	r3, #128	; 0x80
    60b4:	4313      	orrs	r3, r2
    60b6:	800b      	strh	r3, [r1, #0]
			}
			/* Set compare values. */
			for (uint8_t i = 0; i < RTC_COMP32_NUM; i++) {
				rtc_count_set_compare(module, config->compare_values[i],
    60b8:	68a1      	ldr	r1, [r4, #8]
    60ba:	2200      	movs	r2, #0
    60bc:	0028      	movs	r0, r5
    60be:	4b0f      	ldr	r3, [pc, #60]	; (60fc <rtc_count_init+0x94>)
    60c0:	4798      	blx	r3
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
	}

	/* Return status OK if everything was configured. */
	return STATUS_OK;
    60c2:	2000      	movs	r0, #0
    60c4:	e012      	b.n	60ec <rtc_count_init+0x84>
			}
			break;

		case RTC_COUNT_MODE_16BIT:
			/* Set 16bit mode. */
			rtc_module->MODE1.CTRLA.reg |= RTC_MODE1_CTRLA_MODE(1);
    60c6:	880a      	ldrh	r2, [r1, #0]
    60c8:	2304      	movs	r3, #4
    60ca:	4313      	orrs	r3, r2
    60cc:	800b      	strh	r3, [r1, #0]

			/* Check if match on clear is set, and return invalid
			 * argument if set. */
			if (config->clear_on_match) {
    60ce:	78e3      	ldrb	r3, [r4, #3]
				Assert(false);
				return STATUS_ERR_INVALID_ARG;
    60d0:	2017      	movs	r0, #23
			/* Set 16bit mode. */
			rtc_module->MODE1.CTRLA.reg |= RTC_MODE1_CTRLA_MODE(1);

			/* Check if match on clear is set, and return invalid
			 * argument if set. */
			if (config->clear_on_match) {
    60d2:	2b00      	cmp	r3, #0
    60d4:	d10a      	bne.n	60ec <rtc_count_init+0x84>
				Assert(false);
				return STATUS_ERR_INVALID_ARG;
			}
			/* Set compare values. */
			for (uint8_t i = 0; i < RTC_NUM_OF_COMP16; i++) {
				rtc_count_set_compare(module, config->compare_values[i],
    60d6:	2200      	movs	r2, #0
    60d8:	68a1      	ldr	r1, [r4, #8]
    60da:	0028      	movs	r0, r5
    60dc:	4e07      	ldr	r6, [pc, #28]	; (60fc <rtc_count_init+0x94>)
    60de:	47b0      	blx	r6
    60e0:	68e1      	ldr	r1, [r4, #12]
    60e2:	2201      	movs	r2, #1
    60e4:	0028      	movs	r0, r5
    60e6:	47b0      	blx	r6
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
	}

	/* Return status OK if everything was configured. */
	return STATUS_OK;
    60e8:	2000      	movs	r0, #0
    60ea:	e7ff      	b.n	60ec <rtc_count_init+0x84>
	_rtc_instance[_rtc_get_inst_index(hw)] = module;
#  endif

	/* Set config and return status. */
	return _rtc_count_set_config(module, config);
}
    60ec:	bd70      	pop	{r4, r5, r6, pc}
    60ee:	46c0      	nop			; (mov r8, r8)
    60f0:	40000400 	.word	0x40000400
    60f4:	40001000 	.word	0x40001000
    60f8:	20001040 	.word	0x20001040
    60fc:	00006005 	.word	0x00006005

00006100 <rtc_count_clear_compare_match>:
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;

	/* Check sanity. */
	switch (module->mode){
    6100:	7903      	ldrb	r3, [r0, #4]
    6102:	2b00      	cmp	r3, #0
    6104:	d005      	beq.n	6112 <rtc_count_clear_compare_match+0x12>
    6106:	2b01      	cmp	r3, #1
    6108:	d110      	bne.n	612c <rtc_count_clear_compare_match+0x2c>
		case RTC_COUNT_MODE_32BIT:
			/* Check sanity for 32-bit mode. */
			if (comp_index > RTC_COMP32_NUM) {
				return STATUS_ERR_INVALID_ARG;
    610a:	3316      	adds	r3, #22

	/* Check sanity. */
	switch (module->mode){
		case RTC_COUNT_MODE_32BIT:
			/* Check sanity for 32-bit mode. */
			if (comp_index > RTC_COMP32_NUM) {
    610c:	2901      	cmp	r1, #1
    610e:	d80e      	bhi.n	612e <rtc_count_clear_compare_match+0x2e>
    6110:	e002      	b.n	6118 <rtc_count_clear_compare_match+0x18>
			break;

		case RTC_COUNT_MODE_16BIT:
			/* Check sanity for 16-bit mode. */
			if (comp_index > RTC_NUM_OF_COMP16) {
				return STATUS_ERR_INVALID_ARG;
    6112:	2317      	movs	r3, #23

			break;

		case RTC_COUNT_MODE_16BIT:
			/* Check sanity for 16-bit mode. */
			if (comp_index > RTC_NUM_OF_COMP16) {
    6114:	2902      	cmp	r1, #2
    6116:	d80a      	bhi.n	612e <rtc_count_clear_compare_match+0x2e>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    6118:	6800      	ldr	r0, [r0, #0]
			Assert(false);
			return STATUS_ERR_BAD_FORMAT;
	}

	/* Clear INTFLAG. */
	rtc_module->MODE0.INTFLAG.reg = RTC_MODE1_INTFLAG_CMP(1 << comp_index);
    611a:	2380      	movs	r3, #128	; 0x80
    611c:	005b      	lsls	r3, r3, #1
    611e:	408b      	lsls	r3, r1
    6120:	22c0      	movs	r2, #192	; 0xc0
    6122:	0092      	lsls	r2, r2, #2
    6124:	4013      	ands	r3, r2
    6126:	8183      	strh	r3, [r0, #12]

	return STATUS_OK;
    6128:	2300      	movs	r3, #0
    612a:	e000      	b.n	612e <rtc_count_clear_compare_match+0x2e>

			break;

		default:
			Assert(false);
			return STATUS_ERR_BAD_FORMAT;
    612c:	231a      	movs	r3, #26

	/* Clear INTFLAG. */
	rtc_module->MODE0.INTFLAG.reg = RTC_MODE1_INTFLAG_CMP(1 << comp_index);

	return STATUS_OK;
}
    612e:	0018      	movs	r0, r3
    6130:	4770      	bx	lr
    6132:	46c0      	nop			; (mov r8, r8)

00006134 <rtc_count_register_callback>:
{

	enum status_code status = STATUS_OK;

	/* Overflow callback */
	if (callback_type == RTC_COUNT_CALLBACK_OVERFLOW
    6134:	2a0a      	cmp	r2, #10
    6136:	d00d      	beq.n	6154 <rtc_count_register_callback+0x20>
#ifdef FEATURE_RTC_TAMPER_DETECTION
		|| callback_type == RTC_COUNT_CALLBACK_TAMPER
#endif
		|| (callback_type >= RTC_COUNT_CALLBACK_PERIODIC_INTERVAL_0
    6138:	2a07      	cmp	r2, #7
    613a:	d90b      	bls.n	6154 <rtc_count_register_callback+0x20>
			&& callback_type <= RTC_COUNT_CALLBACK_PERIODIC_INTERVAL_7)) {
		status = STATUS_OK;
	} else {
		/* Make sure callback type can be registered */
		switch (module->mode) {
    613c:	7903      	ldrb	r3, [r0, #4]
    613e:	2b00      	cmp	r3, #0
    6140:	d005      	beq.n	614e <rtc_count_register_callback+0x1a>
    6142:	2b01      	cmp	r3, #1
    6144:	d111      	bne.n	616a <rtc_count_register_callback+0x36>
    6146:	3316      	adds	r3, #22
		case RTC_COUNT_MODE_32BIT:
			/* Check sanity for 32-bit mode. */
			if (callback_type > (RTC_COMP32_NUM + RTC_PER_NUM)) {
    6148:	2a09      	cmp	r2, #9
    614a:	d80f      	bhi.n	616c <rtc_count_register_callback+0x38>
    614c:	e002      	b.n	6154 <rtc_count_register_callback+0x20>
    614e:	2317      	movs	r3, #23
			}

			break;
		case RTC_COUNT_MODE_16BIT:
			/* Check sanity for 16-bit mode. */
			if (callback_type > (RTC_NUM_OF_COMP16 + RTC_PER_NUM)) {
    6150:	2a0a      	cmp	r2, #10
    6152:	d80b      	bhi.n	616c <rtc_count_register_callback+0x38>
		}
	}

	if (status == STATUS_OK) {
		/* Register callback */
		module->callbacks[callback_type] = callback;
    6154:	1c93      	adds	r3, r2, #2
    6156:	009b      	lsls	r3, r3, #2
    6158:	5019      	str	r1, [r3, r0]
		/* Set corresponding bit to set callback as registered */
		module->registered_callback |= (1 << callback_type);
    615a:	8e81      	ldrh	r1, [r0, #52]	; 0x34
    615c:	2301      	movs	r3, #1
    615e:	4093      	lsls	r3, r2
    6160:	430b      	orrs	r3, r1
    6162:	b29b      	uxth	r3, r3
    6164:	8683      	strh	r3, [r0, #52]	; 0x34
    6166:	2300      	movs	r3, #0
    6168:	e000      	b.n	616c <rtc_count_register_callback+0x38>
			if (callback_type > (RTC_NUM_OF_COMP16 + RTC_PER_NUM)) {
				status = STATUS_ERR_INVALID_ARG;
			}
			break;
		default:
			status = STATUS_ERR_INVALID_ARG;
    616a:	2317      	movs	r3, #23
		/* Set corresponding bit to set callback as registered */
		module->registered_callback |= (1 << callback_type);
	}

	return status;
}
    616c:	0018      	movs	r0, r3
    616e:	4770      	bx	lr

00006170 <rtc_count_enable_callback>:
 * \param[in]     callback_type Callback type to enable
 */
void rtc_count_enable_callback(
		struct rtc_module *const module,
		enum rtc_count_callback callback_type)
{
    6170:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    6172:	6803      	ldr	r3, [r0, #0]

	if (callback_type == RTC_COUNT_CALLBACK_OVERFLOW) {
    6174:	290a      	cmp	r1, #10
    6176:	d102      	bne.n	617e <rtc_count_enable_callback+0xe>
		rtc_module->MODE0.INTENSET.reg = RTC_MODE0_INTFLAG_OVF;
    6178:	4a0d      	ldr	r2, [pc, #52]	; (61b0 <rtc_count_enable_callback+0x40>)
    617a:	815a      	strh	r2, [r3, #10]
    617c:	e010      	b.n	61a0 <rtc_count_enable_callback+0x30>
#ifdef FEATURE_RTC_TAMPER_DETECTION
	} else if (callback_type == RTC_COUNT_CALLBACK_TAMPER) {
		rtc_module->MODE0.INTENSET.reg = RTC_MODE0_INTFLAG_TAMPER;
#endif
	} else if (callback_type >= RTC_COUNT_CALLBACK_PERIODIC_INTERVAL_0
    617e:	2907      	cmp	r1, #7
    6180:	d805      	bhi.n	618e <rtc_count_enable_callback+0x1e>
			&& callback_type <= RTC_COUNT_CALLBACK_PERIODIC_INTERVAL_7) {
		rtc_module->MODE0.INTENSET.reg = RTC_MODE1_INTFLAG_PER(1 << callback_type);
    6182:	2201      	movs	r2, #1
    6184:	408a      	lsls	r2, r1
    6186:	24ff      	movs	r4, #255	; 0xff
    6188:	4022      	ands	r2, r4
    618a:	815a      	strh	r2, [r3, #10]
    618c:	e008      	b.n	61a0 <rtc_count_enable_callback+0x30>
	}else {
		rtc_module->MODE0.INTENSET.reg = RTC_MODE1_INTFLAG_CMP(1 << (callback_type - RTC_PER_NUM));
    618e:	2280      	movs	r2, #128	; 0x80
    6190:	0052      	lsls	r2, r2, #1
    6192:	000c      	movs	r4, r1
    6194:	3c08      	subs	r4, #8
    6196:	40a2      	lsls	r2, r4
    6198:	24c0      	movs	r4, #192	; 0xc0
    619a:	00a4      	lsls	r4, r4, #2
    619c:	4022      	ands	r2, r4
    619e:	815a      	strh	r2, [r3, #10]
	}
	/* Mark callback as enabled. */
	module->enabled_callback |= (1 << callback_type);
    61a0:	8ec2      	ldrh	r2, [r0, #54]	; 0x36
    61a2:	2301      	movs	r3, #1
    61a4:	408b      	lsls	r3, r1
    61a6:	4313      	orrs	r3, r2
    61a8:	b29b      	uxth	r3, r3
    61aa:	86c3      	strh	r3, [r0, #54]	; 0x36
}
    61ac:	bd10      	pop	{r4, pc}
    61ae:	46c0      	nop			; (mov r8, r8)
    61b0:	ffff8000 	.word	0xffff8000

000061b4 <RTC_Handler>:
/**
 * \internal ISR handler for RTC
 */
#if (RTC_INST_NUM == 1)
void RTC_Handler(void)
{
    61b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    61b6:	465f      	mov	r7, fp
    61b8:	4656      	mov	r6, sl
    61ba:	464d      	mov	r5, r9
    61bc:	4644      	mov	r4, r8
    61be:	b4f0      	push	{r4, r5, r6, r7}
 *
 * \param [in] instance_index  Default value 0
 */
static void _rtc_interrupt_handler(const uint32_t instance_index)
{
	struct rtc_module *module = _rtc_instance[instance_index];
    61c0:	4b29      	ldr	r3, [pc, #164]	; (6268 <RTC_Handler+0xb4>)
    61c2:	681b      	ldr	r3, [r3, #0]
    61c4:	469a      	mov	sl, r3

	Rtc *const rtc_module = module->hw;
    61c6:	681e      	ldr	r6, [r3, #0]

	/* Combine callback registered and enabled masks */
	uint16_t callback_mask = module->enabled_callback;
    61c8:	8edb      	ldrh	r3, [r3, #54]	; 0x36
	callback_mask &= module->registered_callback;
    61ca:	4652      	mov	r2, sl
    61cc:	8e92      	ldrh	r2, [r2, #52]	; 0x34
    61ce:	401a      	ands	r2, r3
    61d0:	4690      	mov	r8, r2

	/* Read and mask interrupt flag register */
	uint16_t interrupt_status = rtc_module->MODE0.INTFLAG.reg;
    61d2:	89b3      	ldrh	r3, [r6, #12]
	interrupt_status &= rtc_module->MODE0.INTENSET.reg;
    61d4:	8972      	ldrh	r2, [r6, #10]
    61d6:	4013      	ands	r3, r2

	if (interrupt_status & RTC_MODE0_INTFLAG_OVF) {
    61d8:	b21a      	sxth	r2, r3
    61da:	2a00      	cmp	r2, #0
    61dc:	da08      	bge.n	61f0 <RTC_Handler+0x3c>
		/* Overflow interrupt */
		if (callback_mask & (1 << RTC_COUNT_CALLBACK_OVERFLOW)) {
    61de:	4643      	mov	r3, r8
    61e0:	055b      	lsls	r3, r3, #21
    61e2:	d502      	bpl.n	61ea <RTC_Handler+0x36>
			module->callbacks[RTC_COUNT_CALLBACK_OVERFLOW]();
    61e4:	4653      	mov	r3, sl
    61e6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    61e8:	4798      	blx	r3
		}

		/* Clear interrupt flag */
		rtc_module->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_OVF;
    61ea:	4b20      	ldr	r3, [pc, #128]	; (626c <RTC_Handler+0xb8>)
    61ec:	81b3      	strh	r3, [r6, #12]
    61ee:	e034      	b.n	625a <RTC_Handler+0xa6>
    61f0:	27ff      	movs	r7, #255	; 0xff
    61f2:	401f      	ands	r7, r3

		/* Clear interrupt flag */
		rtc_module->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_TAMPER;
#endif

	} else if (interrupt_status & RTC_MODE1_INTFLAG_PER(0xff)) {
    61f4:	d01a      	beq.n	622c <RTC_Handler+0x78>
    61f6:	2400      	movs	r4, #0
		uint8_t i  = 0;
		for ( i = 0;i < RTC_PER_NUM;i++) {
			if ((interrupt_status & RTC_MODE1_INTFLAG_PER(1 << i))
    61f8:	2301      	movs	r3, #1
    61fa:	4699      	mov	r9, r3
			  && (callback_mask & (1 << i))) {
				module->callbacks[i]();
			}

			/* Clear interrupt flag */
			rtc_module->MODE0.INTFLAG.reg = RTC_MODE1_INTFLAG_PER(1<<i);
    61fc:	33fe      	adds	r3, #254	; 0xfe
    61fe:	469b      	mov	fp, r3
#endif

	} else if (interrupt_status & RTC_MODE1_INTFLAG_PER(0xff)) {
		uint8_t i  = 0;
		for ( i = 0;i < RTC_PER_NUM;i++) {
			if ((interrupt_status & RTC_MODE1_INTFLAG_PER(1 << i))
    6200:	0023      	movs	r3, r4
    6202:	464d      	mov	r5, r9
    6204:	40a5      	lsls	r5, r4
    6206:	422f      	tst	r7, r5
    6208:	d009      	beq.n	621e <RTC_Handler+0x6a>
			  && (callback_mask & (1 << i))) {
    620a:	4642      	mov	r2, r8
    620c:	4122      	asrs	r2, r4
    620e:	4649      	mov	r1, r9
    6210:	4211      	tst	r1, r2
    6212:	d004      	beq.n	621e <RTC_Handler+0x6a>
				module->callbacks[i]();
    6214:	3302      	adds	r3, #2
    6216:	009b      	lsls	r3, r3, #2
    6218:	4652      	mov	r2, sl
    621a:	589b      	ldr	r3, [r3, r2]
    621c:	4798      	blx	r3
			}

			/* Clear interrupt flag */
			rtc_module->MODE0.INTFLAG.reg = RTC_MODE1_INTFLAG_PER(1<<i);
    621e:	465b      	mov	r3, fp
    6220:	401d      	ands	r5, r3
    6222:	81b5      	strh	r5, [r6, #12]
    6224:	3401      	adds	r4, #1
		rtc_module->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_TAMPER;
#endif

	} else if (interrupt_status & RTC_MODE1_INTFLAG_PER(0xff)) {
		uint8_t i  = 0;
		for ( i = 0;i < RTC_PER_NUM;i++) {
    6226:	2c08      	cmp	r4, #8
    6228:	d1ea      	bne.n	6200 <RTC_Handler+0x4c>
    622a:	e016      	b.n	625a <RTC_Handler+0xa6>
			}

			/* Clear interrupt flag */
			rtc_module->MODE0.INTFLAG.reg = RTC_MODE1_INTFLAG_PER(1<<i);
		}
	}else if (interrupt_status & RTC_MODE1_INTFLAG_CMP(1 << 0)) {
    622c:	05da      	lsls	r2, r3, #23
    622e:	d509      	bpl.n	6244 <RTC_Handler+0x90>
		/* Compare 0 interrupt */
		if (callback_mask & (1 << RTC_COUNT_CALLBACK_COMPARE_0)) {
    6230:	4643      	mov	r3, r8
    6232:	05db      	lsls	r3, r3, #23
    6234:	d502      	bpl.n	623c <RTC_Handler+0x88>
			module->callbacks[RTC_COUNT_CALLBACK_COMPARE_0]();
    6236:	4653      	mov	r3, sl
    6238:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    623a:	4798      	blx	r3
		}
		/* Clear interrupt flag */
		rtc_module->MODE0.INTFLAG.reg = RTC_MODE1_INTFLAG_CMP(1 << 0);
    623c:	2380      	movs	r3, #128	; 0x80
    623e:	005b      	lsls	r3, r3, #1
    6240:	81b3      	strh	r3, [r6, #12]
    6242:	e00a      	b.n	625a <RTC_Handler+0xa6>

	} else if (interrupt_status & RTC_MODE1_INTFLAG_CMP(1 << 1)) {
    6244:	059b      	lsls	r3, r3, #22
    6246:	d508      	bpl.n	625a <RTC_Handler+0xa6>
		#if (RTC_NUM_OF_COMP16 > 1) || defined(__DOXYGEN__)
		/* Compare 1 interrupt */
		if (callback_mask & (1 << RTC_COUNT_CALLBACK_COMPARE_1)) {
    6248:	4643      	mov	r3, r8
    624a:	059b      	lsls	r3, r3, #22
    624c:	d502      	bpl.n	6254 <RTC_Handler+0xa0>
			module->callbacks[RTC_COUNT_CALLBACK_COMPARE_1]();
    624e:	4653      	mov	r3, sl
    6250:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6252:	4798      	blx	r3
		}
		/* Clear interrupt flag */
		rtc_module->MODE0.INTFLAG.reg = RTC_MODE1_INTFLAG_CMP(1 << 1);
    6254:	2380      	movs	r3, #128	; 0x80
    6256:	009b      	lsls	r3, r3, #2
    6258:	81b3      	strh	r3, [r6, #12]
 */
#if (RTC_INST_NUM == 1)
void RTC_Handler(void)
{
	_rtc_interrupt_handler(0);
}
    625a:	bc3c      	pop	{r2, r3, r4, r5}
    625c:	4690      	mov	r8, r2
    625e:	4699      	mov	r9, r3
    6260:	46a2      	mov	sl, r4
    6262:	46ab      	mov	fp, r5
    6264:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6266:	46c0      	nop			; (mov r8, r8)
    6268:	20001040 	.word	0x20001040
    626c:	ffff8000 	.word	0xffff8000

00006270 <delay_init>:
 *
 * This must be called during start up to initialize the delay routine with
 * the current used main clock. It must run any time the main CPU clock is changed.
 */
void delay_init(void)
{
    6270:	b570      	push	{r4, r5, r6, lr}
	cycles_per_ms = system_gclk_gen_get_hz(0);
    6272:	2000      	movs	r0, #0
    6274:	4b08      	ldr	r3, [pc, #32]	; (6298 <delay_init+0x28>)
    6276:	4798      	blx	r3
    6278:	0005      	movs	r5, r0
	cycles_per_ms /= 1000;
    627a:	4c08      	ldr	r4, [pc, #32]	; (629c <delay_init+0x2c>)
    627c:	21fa      	movs	r1, #250	; 0xfa
    627e:	0089      	lsls	r1, r1, #2
    6280:	47a0      	blx	r4
    6282:	4b07      	ldr	r3, [pc, #28]	; (62a0 <delay_init+0x30>)
    6284:	6018      	str	r0, [r3, #0]
	cycles_per_us = cycles_per_ms / 1000;
    6286:	4907      	ldr	r1, [pc, #28]	; (62a4 <delay_init+0x34>)
    6288:	0028      	movs	r0, r5
    628a:	47a0      	blx	r4
    628c:	4b06      	ldr	r3, [pc, #24]	; (62a8 <delay_init+0x38>)
    628e:	6018      	str	r0, [r3, #0]

	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
    6290:	2205      	movs	r2, #5
    6292:	4b06      	ldr	r3, [pc, #24]	; (62ac <delay_init+0x3c>)
    6294:	601a      	str	r2, [r3, #0]
}
    6296:	bd70      	pop	{r4, r5, r6, pc}
    6298:	00007639 	.word	0x00007639
    629c:	0000a38d 	.word	0x0000a38d
    62a0:	200000ac 	.word	0x200000ac
    62a4:	000f4240 	.word	0x000f4240
    62a8:	200000a8 	.word	0x200000a8
    62ac:	e000e010 	.word	0xe000e010

000062b0 <delay_cycles_ms>:
 *
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
    62b0:	b530      	push	{r4, r5, lr}
	while (n--) {
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
    62b2:	4b08      	ldr	r3, [pc, #32]	; (62d4 <delay_cycles_ms+0x24>)
    62b4:	681c      	ldr	r4, [r3, #0]
 */
static inline void delay_cycles(
		const uint32_t n)
{
	if (n > 0) {
		SysTick->LOAD = n;
    62b6:	4a08      	ldr	r2, [pc, #32]	; (62d8 <delay_cycles_ms+0x28>)
		SysTick->VAL = 0;
    62b8:	2500      	movs	r5, #0

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
    62ba:	2180      	movs	r1, #128	; 0x80
    62bc:	0249      	lsls	r1, r1, #9
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
	while (n--) {
    62be:	e006      	b.n	62ce <delay_cycles_ms+0x1e>
 * \param n  Number of cycles to delay
 */
static inline void delay_cycles(
		const uint32_t n)
{
	if (n > 0) {
    62c0:	2c00      	cmp	r4, #0
    62c2:	d004      	beq.n	62ce <delay_cycles_ms+0x1e>
		SysTick->LOAD = n;
    62c4:	6054      	str	r4, [r2, #4]
		SysTick->VAL = 0;
    62c6:	6095      	str	r5, [r2, #8]

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
    62c8:	6813      	ldr	r3, [r2, #0]
    62ca:	420b      	tst	r3, r1
    62cc:	d0fc      	beq.n	62c8 <delay_cycles_ms+0x18>
    62ce:	3801      	subs	r0, #1
    62d0:	d2f6      	bcs.n	62c0 <delay_cycles_ms+0x10>
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
	}
}
    62d2:	bd30      	pop	{r4, r5, pc}
    62d4:	200000ac 	.word	0x200000ac
    62d8:	e000e010 	.word	0xe000e010

000062dc <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
    62dc:	4b0c      	ldr	r3, [pc, #48]	; (6310 <cpu_irq_enter_critical+0x34>)
    62de:	681b      	ldr	r3, [r3, #0]
    62e0:	2b00      	cmp	r3, #0
    62e2:	d110      	bne.n	6306 <cpu_irq_enter_critical+0x2a>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    62e4:	f3ef 8310 	mrs	r3, PRIMASK
		if (cpu_irq_is_enabled()) {
    62e8:	2b00      	cmp	r3, #0
    62ea:	d109      	bne.n	6300 <cpu_irq_enter_critical+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    62ec:	b672      	cpsid	i
    62ee:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    62f2:	2200      	movs	r2, #0
    62f4:	4b07      	ldr	r3, [pc, #28]	; (6314 <cpu_irq_enter_critical+0x38>)
    62f6:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
    62f8:	3201      	adds	r2, #1
    62fa:	4b07      	ldr	r3, [pc, #28]	; (6318 <cpu_irq_enter_critical+0x3c>)
    62fc:	701a      	strb	r2, [r3, #0]
    62fe:	e002      	b.n	6306 <cpu_irq_enter_critical+0x2a>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    6300:	2200      	movs	r2, #0
    6302:	4b05      	ldr	r3, [pc, #20]	; (6318 <cpu_irq_enter_critical+0x3c>)
    6304:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    6306:	4a02      	ldr	r2, [pc, #8]	; (6310 <cpu_irq_enter_critical+0x34>)
    6308:	6813      	ldr	r3, [r2, #0]
    630a:	3301      	adds	r3, #1
    630c:	6013      	str	r3, [r2, #0]
}
    630e:	4770      	bx	lr
    6310:	2000038c 	.word	0x2000038c
    6314:	200000b0 	.word	0x200000b0
    6318:	20000390 	.word	0x20000390

0000631c <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    631c:	4b08      	ldr	r3, [pc, #32]	; (6340 <cpu_irq_leave_critical+0x24>)
    631e:	681a      	ldr	r2, [r3, #0]
    6320:	3a01      	subs	r2, #1
    6322:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    6324:	681b      	ldr	r3, [r3, #0]
    6326:	2b00      	cmp	r3, #0
    6328:	d109      	bne.n	633e <cpu_irq_leave_critical+0x22>
    632a:	4b06      	ldr	r3, [pc, #24]	; (6344 <cpu_irq_leave_critical+0x28>)
    632c:	781b      	ldrb	r3, [r3, #0]
    632e:	2b00      	cmp	r3, #0
    6330:	d005      	beq.n	633e <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
    6332:	2201      	movs	r2, #1
    6334:	4b04      	ldr	r3, [pc, #16]	; (6348 <cpu_irq_leave_critical+0x2c>)
    6336:	701a      	strb	r2, [r3, #0]
    6338:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    633c:	b662      	cpsie	i
	}
}
    633e:	4770      	bx	lr
    6340:	2000038c 	.word	0x2000038c
    6344:	20000390 	.word	0x20000390
    6348:	200000b0 	.word	0x200000b0

0000634c <extint_register_callback>:
	/* Sanity check arguments */
	Assert(callback);

	if (type != EXTINT_CALLBACK_TYPE_DETECT) {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    634c:	2317      	movs	r3, #23
	const enum extint_callback_type type)
{
	/* Sanity check arguments */
	Assert(callback);

	if (type != EXTINT_CALLBACK_TYPE_DETECT) {
    634e:	2a00      	cmp	r2, #0
    6350:	d10d      	bne.n	636e <extint_register_callback+0x22>
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	if (_extint_dev.callbacks[channel] == NULL) {
    6352:	008b      	lsls	r3, r1, #2
    6354:	4a07      	ldr	r2, [pc, #28]	; (6374 <extint_register_callback+0x28>)
    6356:	589b      	ldr	r3, [r3, r2]
    6358:	2b00      	cmp	r3, #0
    635a:	d103      	bne.n	6364 <extint_register_callback+0x18>
		_extint_dev.callbacks[channel] = callback;
    635c:	0089      	lsls	r1, r1, #2
    635e:	5088      	str	r0, [r1, r2]
		return STATUS_OK;
    6360:	2300      	movs	r3, #0
    6362:	e004      	b.n	636e <extint_register_callback+0x22>
	} else if (_extint_dev.callbacks[channel] == callback) {
    6364:	4283      	cmp	r3, r0
    6366:	d001      	beq.n	636c <extint_register_callback+0x20>
		return STATUS_OK;
	}

	return STATUS_ERR_ALREADY_INITIALIZED;
    6368:	231d      	movs	r3, #29
    636a:	e000      	b.n	636e <extint_register_callback+0x22>

	if (_extint_dev.callbacks[channel] == NULL) {
		_extint_dev.callbacks[channel] = callback;
		return STATUS_OK;
	} else if (_extint_dev.callbacks[channel] == callback) {
		return STATUS_OK;
    636c:	2300      	movs	r3, #0
	}

	return STATUS_ERR_ALREADY_INITIALIZED;
}
    636e:	0018      	movs	r0, r3
    6370:	4770      	bx	lr
    6372:	46c0      	nop			; (mov r8, r8)
    6374:	20001304 	.word	0x20001304

00006378 <extint_chan_enable_callback>:

		eic->INTENSET.reg = (1UL << channel);
	}
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    6378:	2317      	movs	r3, #23
 */
enum status_code extint_chan_enable_callback(
	const uint8_t channel,
	const enum extint_callback_type type)
{
	if (type == EXTINT_CALLBACK_TYPE_DETECT) {
    637a:	2900      	cmp	r1, #0
    637c:	d107      	bne.n	638e <extint_chan_enable_callback+0x16>
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
	} else {
		Assert(false);
		return NULL;
    637e:	2200      	movs	r2, #0
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    6380:	281f      	cmp	r0, #31
    6382:	d800      	bhi.n	6386 <extint_chan_enable_callback+0xe>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    6384:	4a03      	ldr	r2, [pc, #12]	; (6394 <extint_chan_enable_callback+0x1c>)
		Eic *const eic = _extint_get_eic_from_channel(channel);

		eic->INTENSET.reg = (1UL << channel);
    6386:	2301      	movs	r3, #1
    6388:	4083      	lsls	r3, r0
    638a:	6113      	str	r3, [r2, #16]
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    638c:	2300      	movs	r3, #0
}
    638e:	0018      	movs	r0, r3
    6390:	4770      	bx	lr
    6392:	46c0      	nop			; (mov r8, r8)
    6394:	40002400 	.word	0x40002400

00006398 <extint_chan_disable_callback>:

		eic->INTENCLR.reg = (1UL << channel);
	}
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    6398:	2317      	movs	r3, #23
 */
enum status_code extint_chan_disable_callback(
	const uint8_t channel,
	const enum extint_callback_type type)
{
	if (type == EXTINT_CALLBACK_TYPE_DETECT) {
    639a:	2900      	cmp	r1, #0
    639c:	d107      	bne.n	63ae <extint_chan_disable_callback+0x16>
	} else {
		Assert(false);
		return NULL;
    639e:	2200      	movs	r2, #0
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    63a0:	281f      	cmp	r0, #31
    63a2:	d800      	bhi.n	63a6 <extint_chan_disable_callback+0xe>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    63a4:	4a03      	ldr	r2, [pc, #12]	; (63b4 <extint_chan_disable_callback+0x1c>)
		Eic *const eic = _extint_get_eic_from_channel(channel);

		eic->INTENCLR.reg = (1UL << channel);
    63a6:	2301      	movs	r3, #1
    63a8:	4083      	lsls	r3, r0
    63aa:	60d3      	str	r3, [r2, #12]
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    63ac:	2300      	movs	r3, #0
}
    63ae:	0018      	movs	r0, r3
    63b0:	4770      	bx	lr
    63b2:	46c0      	nop			; (mov r8, r8)
    63b4:	40002400 	.word	0x40002400

000063b8 <EIC_Handler>:
	return _current_channel;
}

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
    63b8:	b570      	push	{r4, r5, r6, lr}
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    63ba:	2200      	movs	r2, #0
    63bc:	4b15      	ldr	r3, [pc, #84]	; (6414 <EIC_Handler+0x5c>)
    63be:	701a      	strb	r2, [r3, #0]
    63c0:	2300      	movs	r3, #0
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
    63c2:	251f      	movs	r5, #31
		if (extint_chan_is_detected(_current_channel)) {
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
    63c4:	4e14      	ldr	r6, [pc, #80]	; (6418 <EIC_Handler+0x60>)

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    63c6:	4c13      	ldr	r4, [pc, #76]	; (6414 <EIC_Handler+0x5c>)
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    63c8:	2b1f      	cmp	r3, #31
    63ca:	d919      	bls.n	6400 <EIC_Handler+0x48>
    63cc:	e00f      	b.n	63ee <EIC_Handler+0x36>
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
	} else {
		Assert(false);
		return NULL;
    63ce:	2100      	movs	r1, #0
    63d0:	e000      	b.n	63d4 <EIC_Handler+0x1c>

	if (eic_index < EIC_INST_NUM) {
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    63d2:	4912      	ldr	r1, [pc, #72]	; (641c <EIC_Handler+0x64>)
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));

	eic_module->INTFLAG.reg = eic_mask;
    63d4:	614a      	str	r2, [r1, #20]
		if (extint_chan_is_detected(_current_channel)) {
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
    63d6:	009b      	lsls	r3, r3, #2
    63d8:	599b      	ldr	r3, [r3, r6]
    63da:	2b00      	cmp	r3, #0
    63dc:	d000      	beq.n	63e0 <EIC_Handler+0x28>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
    63de:	4798      	blx	r3

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    63e0:	7823      	ldrb	r3, [r4, #0]
    63e2:	3301      	adds	r3, #1
    63e4:	b2db      	uxtb	r3, r3
    63e6:	7023      	strb	r3, [r4, #0]
    63e8:	2b0f      	cmp	r3, #15
    63ea:	d9ed      	bls.n	63c8 <EIC_Handler+0x10>
    63ec:	e011      	b.n	6412 <EIC_Handler+0x5a>
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
    63ee:	0029      	movs	r1, r5
    63f0:	4019      	ands	r1, r3
    63f2:	2201      	movs	r2, #1
    63f4:	408a      	lsls	r2, r1

	return (eic_module->INTFLAG.reg & eic_mask);
    63f6:	2100      	movs	r1, #0
    63f8:	6949      	ldr	r1, [r1, #20]
		if (extint_chan_is_detected(_current_channel)) {
    63fa:	4211      	tst	r1, r2
    63fc:	d1e7      	bne.n	63ce <EIC_Handler+0x16>
    63fe:	e7ef      	b.n	63e0 <EIC_Handler+0x28>
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
    6400:	0029      	movs	r1, r5
    6402:	4019      	ands	r1, r3
    6404:	2201      	movs	r2, #1
    6406:	408a      	lsls	r2, r1

	return (eic_module->INTFLAG.reg & eic_mask);
    6408:	4904      	ldr	r1, [pc, #16]	; (641c <EIC_Handler+0x64>)
    640a:	6949      	ldr	r1, [r1, #20]
    640c:	4211      	tst	r1, r2
    640e:	d1e0      	bne.n	63d2 <EIC_Handler+0x1a>
    6410:	e7e6      	b.n	63e0 <EIC_Handler+0x28>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
			}
		}
	}
}
    6412:	bd70      	pop	{r4, r5, r6, pc}
    6414:	20001301 	.word	0x20001301
    6418:	20001304 	.word	0x20001304
    641c:	40002400 	.word	0x40002400

00006420 <_extint_enable>:
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRLA.reg |= EIC_CTRLA_ENABLE;
    6420:	4a06      	ldr	r2, [pc, #24]	; (643c <_extint_enable+0x1c>)
    6422:	7811      	ldrb	r1, [r2, #0]
    6424:	2302      	movs	r3, #2
    6426:	430b      	orrs	r3, r1
    6428:	7013      	strb	r3, [r2, #0]
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if((eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_ENABLE)
    642a:	2102      	movs	r1, #2
		 || (eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_SWRST)){
    642c:	2001      	movs	r0, #1
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if((eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_ENABLE)
    642e:	6853      	ldr	r3, [r2, #4]
    6430:	4219      	tst	r1, r3
    6432:	d1fc      	bne.n	642e <_extint_enable+0xe>
		 || (eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_SWRST)){
    6434:	6853      	ldr	r3, [r2, #4]
    6436:	4218      	tst	r0, r3
    6438:	d1f9      	bne.n	642e <_extint_enable+0xe>
	}

	while (extint_is_syncing()) {
		/* Wait for all hardware modules to complete synchronization */
	}
}
    643a:	4770      	bx	lr
    643c:	40002400 	.word	0x40002400

00006440 <_extint_disable>:
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	/* Disable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRLA.reg &= ~EIC_CTRLA_ENABLE;
    6440:	4a06      	ldr	r2, [pc, #24]	; (645c <_extint_disable+0x1c>)
    6442:	7813      	ldrb	r3, [r2, #0]
    6444:	2102      	movs	r1, #2
    6446:	438b      	bics	r3, r1
    6448:	7013      	strb	r3, [r2, #0]
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if((eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_ENABLE)
		 || (eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_SWRST)){
    644a:	2001      	movs	r0, #1
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if((eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_ENABLE)
    644c:	6853      	ldr	r3, [r2, #4]
    644e:	4219      	tst	r1, r3
    6450:	d1fc      	bne.n	644c <_extint_disable+0xc>
		 || (eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_SWRST)){
    6452:	6853      	ldr	r3, [r2, #4]
    6454:	4218      	tst	r0, r3
    6456:	d1f9      	bne.n	644c <_extint_disable+0xc>
	}

	while (extint_is_syncing()) {
		/* Wait for all hardware modules to complete synchronization */
	}
}
    6458:	4770      	bx	lr
    645a:	46c0      	nop			; (mov r8, r8)
    645c:	40002400 	.word	0x40002400

00006460 <_system_extint_init>:
 * \note When SYSTEM module is used, this function will be invoked by
 * \ref system_init() automatically if the module is included.
 */
void _system_extint_init(void);
void _system_extint_init(void)
{
    6460:	b500      	push	{lr}
    6462:	b083      	sub	sp, #12
    6464:	4a18      	ldr	r2, [pc, #96]	; (64c8 <_system_extint_init+0x68>)
    6466:	6953      	ldr	r3, [r2, #20]
    6468:	2180      	movs	r1, #128	; 0x80
    646a:	0089      	lsls	r1, r1, #2
    646c:	430b      	orrs	r3, r1
    646e:	6153      	str	r3, [r2, #20]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    6470:	a901      	add	r1, sp, #4
    6472:	2300      	movs	r3, #0
    6474:	700b      	strb	r3, [r1, #0]
#if (EXTINT_CLOCK_SELECTION == EXTINT_CLK_GCLK)
	/* Configure the generic clock for the module and enable it */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = EXTINT_CLOCK_SOURCE;
	system_gclk_chan_set_config(EIC_GCLK_ID, &gclk_chan_conf);
    6476:	2003      	movs	r0, #3
    6478:	4b14      	ldr	r3, [pc, #80]	; (64cc <_system_extint_init+0x6c>)
    647a:	4798      	blx	r3

	/* Enable the clock anyway, since when needed it will be requested
	 * by External Interrupt driver */
	system_gclk_chan_enable(EIC_GCLK_ID);
    647c:	2003      	movs	r0, #3
    647e:	4b14      	ldr	r3, [pc, #80]	; (64d0 <_system_extint_init+0x70>)
    6480:	4798      	blx	r3
#endif

	/* Reset all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRLA.reg |= EIC_CTRLA_SWRST;
    6482:	4a14      	ldr	r2, [pc, #80]	; (64d4 <_system_extint_init+0x74>)
    6484:	7811      	ldrb	r1, [r2, #0]
    6486:	2301      	movs	r3, #1
    6488:	430b      	orrs	r3, r1
    648a:	7013      	strb	r3, [r2, #0]
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if((eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_ENABLE)
    648c:	2102      	movs	r1, #2
		 || (eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_SWRST)){
    648e:	2001      	movs	r0, #1
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if((eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_ENABLE)
    6490:	6853      	ldr	r3, [r2, #4]
    6492:	4219      	tst	r1, r3
    6494:	d1fc      	bne.n	6490 <_system_extint_init+0x30>
		 || (eics[i]->SYNCBUSY.reg & EIC_SYNCBUSY_SWRST)){
    6496:	6853      	ldr	r3, [r2, #4]
    6498:	4218      	tst	r0, r3
    649a:	d009      	beq.n	64b0 <_system_extint_init+0x50>
    649c:	e7f8      	b.n	6490 <_system_extint_init+0x30>

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
		_extint_dev.callbacks[j] = NULL;
    649e:	c304      	stmia	r3!, {r2}
#endif

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
    64a0:	428b      	cmp	r3, r1
    64a2:	d1fc      	bne.n	649e <_system_extint_init+0x3e>
    64a4:	2208      	movs	r2, #8
    64a6:	4b0c      	ldr	r3, [pc, #48]	; (64d8 <_system_extint_init+0x78>)
    64a8:	601a      	str	r2, [r3, #0]
	}
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_EIC);
#endif

	/* Enables the driver for further use */
	_extint_enable();
    64aa:	4b0c      	ldr	r3, [pc, #48]	; (64dc <_system_extint_init+0x7c>)
    64ac:	4798      	blx	r3
}
    64ae:	e009      	b.n	64c4 <_system_extint_init+0x64>
		/* Wait for all hardware modules to complete synchronization */
	}

#if (EXTINT_CLOCK_SELECTION == EXTINT_CLK_GCLK)
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRLA.bit.CKSEL = EXTINT_CLK_GCLK;
    64b0:	4a08      	ldr	r2, [pc, #32]	; (64d4 <_system_extint_init+0x74>)
    64b2:	7813      	ldrb	r3, [r2, #0]
    64b4:	2110      	movs	r1, #16
    64b6:	438b      	bics	r3, r1
    64b8:	7013      	strb	r3, [r2, #0]
    64ba:	4b09      	ldr	r3, [pc, #36]	; (64e0 <_system_extint_init+0x80>)
    64bc:	0019      	movs	r1, r3
    64be:	3140      	adds	r1, #64	; 0x40

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
		_extint_dev.callbacks[j] = NULL;
    64c0:	2200      	movs	r2, #0
    64c2:	e7ec      	b.n	649e <_system_extint_init+0x3e>
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_EIC);
#endif

	/* Enables the driver for further use */
	_extint_enable();
}
    64c4:	b003      	add	sp, #12
    64c6:	bd00      	pop	{pc}
    64c8:	40000400 	.word	0x40000400
    64cc:	00007715 	.word	0x00007715
    64d0:	000076a5 	.word	0x000076a5
    64d4:	40002400 	.word	0x40002400
    64d8:	e000e100 	.word	0xe000e100
    64dc:	00006421 	.word	0x00006421
    64e0:	20001304 	.word	0x20001304

000064e4 <extint_chan_get_config_defaults>:
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->gpio_pin            = 0;
    64e4:	2300      	movs	r3, #0
    64e6:	6003      	str	r3, [r0, #0]
	config->gpio_pin_mux        = 0;
    64e8:	6043      	str	r3, [r0, #4]
	config->gpio_pin_pull       = EXTINT_PULL_UP;
    64ea:	2201      	movs	r2, #1
    64ec:	7202      	strb	r2, [r0, #8]
	config->filter_input_signal = false;
    64ee:	7283      	strb	r3, [r0, #10]
	config->detection_criteria  = EXTINT_DETECT_FALLING;
    64f0:	3201      	adds	r2, #1
    64f2:	72c2      	strb	r2, [r0, #11]
	config->enable_async_edge_detection = false;
    64f4:	7243      	strb	r3, [r0, #9]
}
    64f6:	4770      	bx	lr

000064f8 <extint_chan_set_config>:

 */
void extint_chan_set_config(
		const uint8_t channel,
		const struct extint_chan_conf *const config)
{
    64f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    64fa:	b083      	sub	sp, #12
    64fc:	0005      	movs	r5, r0
    64fe:	000c      	movs	r4, r1
	/* Sanity check arguments */
	Assert(config);
	_extint_disable();
    6500:	4b1b      	ldr	r3, [pc, #108]	; (6570 <extint_chan_set_config+0x78>)
    6502:	4798      	blx	r3
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    6504:	a901      	add	r1, sp, #4
    6506:	2300      	movs	r3, #0
    6508:	704b      	strb	r3, [r1, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    650a:	70cb      	strb	r3, [r1, #3]
			config->detection_criteria)));
#endif
	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = config->gpio_pin_mux;
    650c:	7923      	ldrb	r3, [r4, #4]
    650e:	700b      	strb	r3, [r1, #0]
	pinmux_config.direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->gpio_pin_pull;
    6510:	7a23      	ldrb	r3, [r4, #8]
    6512:	708b      	strb	r3, [r1, #2]
	system_pinmux_pin_set_config(config->gpio_pin, &pinmux_config);
    6514:	7820      	ldrb	r0, [r4, #0]
    6516:	4b17      	ldr	r3, [pc, #92]	; (6574 <extint_chan_set_config+0x7c>)
    6518:	4798      	blx	r3
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
	} else {
		Assert(false);
		return NULL;
    651a:	2000      	movs	r0, #0
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    651c:	2d1f      	cmp	r5, #31
    651e:	d800      	bhi.n	6522 <extint_chan_set_config+0x2a>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    6520:	4815      	ldr	r0, [pc, #84]	; (6578 <extint_chan_set_config+0x80>)

	/* Get a pointer to the module hardware instance */
	Eic *const EIC_module = _extint_get_eic_from_channel(channel);

	uint32_t config_pos = (4 * (channel % 8));
    6522:	2107      	movs	r1, #7
    6524:	4029      	ands	r1, r5
    6526:	0089      	lsls	r1, r1, #2
	uint32_t new_config;

	/* Determine the channel's new edge detection configuration */
	new_config = (config->detection_criteria << EIC_CONFIG_SENSE0_Pos);
    6528:	7ae2      	ldrb	r2, [r4, #11]

	/* Enable the hardware signal filter if requested in the config */
	if (config->filter_input_signal) {
    652a:	7aa3      	ldrb	r3, [r4, #10]
    652c:	2b00      	cmp	r3, #0
    652e:	d001      	beq.n	6534 <extint_chan_set_config+0x3c>
		new_config |= EIC_CONFIG_FILTEN0;
    6530:	2308      	movs	r3, #8
    6532:	431a      	orrs	r2, r3
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
    6534:	08eb      	lsrs	r3, r5, #3
    6536:	009b      	lsls	r3, r3, #2
    6538:	18c3      	adds	r3, r0, r3
		= (EIC_module->CONFIG[channel / 8].reg &
    653a:	69de      	ldr	r6, [r3, #28]
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
    653c:	270f      	movs	r7, #15
    653e:	408f      	lsls	r7, r1
    6540:	43be      	bics	r6, r7
    6542:	408a      	lsls	r2, r1
    6544:	4332      	orrs	r2, r6
		new_config |= EIC_CONFIG_FILTEN0;
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
    6546:	61da      	str	r2, [r3, #28]
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
			(new_config << config_pos);
#if (SAML22) || (SAML21XXXB)
	/* Config asynchronous edge detection */
	if (config->enable_async_edge_detection) {
    6548:	7a63      	ldrb	r3, [r4, #9]
    654a:	2b00      	cmp	r3, #0
    654c:	d005      	beq.n	655a <extint_chan_set_config+0x62>
		EIC_module->ASYNCH.reg |= (1UL << channel);
    654e:	6982      	ldr	r2, [r0, #24]
    6550:	2301      	movs	r3, #1
    6552:	40ab      	lsls	r3, r5
    6554:	4313      	orrs	r3, r2
    6556:	6183      	str	r3, [r0, #24]
    6558:	e006      	b.n	6568 <extint_chan_set_config+0x70>
	} else {
		EIC_module->ASYNCH.reg &= (EIC_ASYNCH_MASK & (~(1UL << channel)));
    655a:	6983      	ldr	r3, [r0, #24]
    655c:	2201      	movs	r2, #1
    655e:	40aa      	lsls	r2, r5
    6560:	041b      	lsls	r3, r3, #16
    6562:	0c1b      	lsrs	r3, r3, #16
    6564:	4393      	bics	r3, r2
    6566:	6183      	str	r3, [r0, #24]
		EIC_module->EIC_ASYNCH.reg |= (1UL << channel);
	} else {
		EIC_module->EIC_ASYNCH.reg &= (EIC_EIC_ASYNCH_MASK & (~(1UL << channel)));
	}
#endif
	_extint_enable();
    6568:	4b04      	ldr	r3, [pc, #16]	; (657c <extint_chan_set_config+0x84>)
    656a:	4798      	blx	r3
}
    656c:	b003      	add	sp, #12
    656e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6570:	00006441 	.word	0x00006441
    6574:	00007811 	.word	0x00007811
    6578:	40002400 	.word	0x40002400
    657c:	00006421 	.word	0x00006421

00006580 <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
    6580:	b500      	push	{lr}
    6582:	b083      	sub	sp, #12
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    6584:	ab01      	add	r3, sp, #4
    6586:	2280      	movs	r2, #128	; 0x80
    6588:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
    658a:	780a      	ldrb	r2, [r1, #0]
    658c:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
    658e:	784a      	ldrb	r2, [r1, #1]
    6590:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
    6592:	788a      	ldrb	r2, [r1, #2]
    6594:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    6596:	0019      	movs	r1, r3
    6598:	4b01      	ldr	r3, [pc, #4]	; (65a0 <port_pin_set_config+0x20>)
    659a:	4798      	blx	r3
}
    659c:	b003      	add	sp, #12
    659e:	bd00      	pop	{pc}
    65a0:	00007811 	.word	0x00007811

000065a4 <_sercom_get_sync_baud_val>:
 */
enum status_code _sercom_get_sync_baud_val(
		const uint32_t baudrate,
		const uint32_t external_clock,
		uint16_t *const baudvalue)
{
    65a4:	b510      	push	{r4, lr}
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
    65a6:	0849      	lsrs	r1, r1, #1
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    65a8:	2340      	movs	r3, #64	; 0x40
    65aa:	2400      	movs	r4, #0
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
    65ac:	4281      	cmp	r1, r0
    65ae:	d201      	bcs.n	65b4 <_sercom_get_sync_baud_val+0x10>
    65b0:	e00a      	b.n	65c8 <_sercom_get_sync_baud_val+0x24>

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
		clock_value = clock_value - baudrate;
		baud_calculated++;
    65b2:	001c      	movs	r4, r3
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
		clock_value = clock_value - baudrate;
    65b4:	1a09      	subs	r1, r1, r0
		baud_calculated++;
    65b6:	1c63      	adds	r3, r4, #1
    65b8:	b29b      	uxth	r3, r3
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
    65ba:	4288      	cmp	r0, r1
    65bc:	d9f9      	bls.n	65b2 <_sercom_get_sync_baud_val+0xe>

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    65be:	2340      	movs	r3, #64	; 0x40
	}
	baud_calculated = baud_calculated - 1;

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
    65c0:	2cff      	cmp	r4, #255	; 0xff
    65c2:	d801      	bhi.n	65c8 <_sercom_get_sync_baud_val+0x24>
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		*baudvalue = baud_calculated;
    65c4:	8014      	strh	r4, [r2, #0]
		return STATUS_OK;
    65c6:	2300      	movs	r3, #0
	}
}
    65c8:	0018      	movs	r0, r3
    65ca:	bd10      	pop	{r4, pc}

000065cc <_sercom_get_async_baud_val>:
		const uint32_t baudrate,
		const uint32_t peripheral_clock,
		uint16_t *const baudval,
		enum sercom_asynchronous_operation_mode mode,
		enum sercom_asynchronous_sample_num sample_num)
{
    65cc:	b5f0      	push	{r4, r5, r6, r7, lr}
    65ce:	465f      	mov	r7, fp
    65d0:	4656      	mov	r6, sl
    65d2:	464d      	mov	r5, r9
    65d4:	4644      	mov	r4, r8
    65d6:	b4f0      	push	{r4, r5, r6, r7}
    65d8:	b089      	sub	sp, #36	; 0x24
    65da:	000c      	movs	r4, r1
    65dc:	9205      	str	r2, [sp, #20]
    65de:	aa12      	add	r2, sp, #72	; 0x48
    65e0:	7811      	ldrb	r1, [r2, #0]
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
    65e2:	0002      	movs	r2, r0
    65e4:	434a      	muls	r2, r1
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    65e6:	2540      	movs	r5, #64	; 0x40
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
    65e8:	42a2      	cmp	r2, r4
    65ea:	d900      	bls.n	65ee <_sercom_get_async_baud_val+0x22>
    65ec:	e0c6      	b.n	677c <_sercom_get_async_baud_val+0x1b0>
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
    65ee:	2b00      	cmp	r3, #0
    65f0:	d151      	bne.n	6696 <_sercom_get_async_baud_val+0xca>
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
    65f2:	0002      	movs	r2, r0
    65f4:	0008      	movs	r0, r1
    65f6:	2100      	movs	r1, #0
    65f8:	4d64      	ldr	r5, [pc, #400]	; (678c <_sercom_get_async_baud_val+0x1c0>)
    65fa:	47a8      	blx	r5
    65fc:	4683      	mov	fp, r0
		ratio = long_division(temp1, peripheral_clock);
    65fe:	0026      	movs	r6, r4
    6600:	2700      	movs	r7, #0
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
    6602:	2300      	movs	r3, #0
    6604:	2400      	movs	r4, #0
    6606:	9300      	str	r3, [sp, #0]
    6608:	9401      	str	r4, [sp, #4]
    660a:	2200      	movs	r2, #0
    660c:	2300      	movs	r3, #0
	for (i = 63; i >= 0; i--) {
    660e:	203f      	movs	r0, #63	; 0x3f
		bit_shift = (uint64_t)1 << i;
    6610:	2120      	movs	r1, #32
    6612:	468c      	mov	ip, r1
    6614:	391f      	subs	r1, #31
    6616:	9602      	str	r6, [sp, #8]
    6618:	9703      	str	r7, [sp, #12]
    661a:	2420      	movs	r4, #32
    661c:	4264      	negs	r4, r4
    661e:	1904      	adds	r4, r0, r4
    6620:	d403      	bmi.n	662a <_sercom_get_async_baud_val+0x5e>
    6622:	000d      	movs	r5, r1
    6624:	40a5      	lsls	r5, r4
    6626:	46a8      	mov	r8, r5
    6628:	e004      	b.n	6634 <_sercom_get_async_baud_val+0x68>
    662a:	4664      	mov	r4, ip
    662c:	1a24      	subs	r4, r4, r0
    662e:	000d      	movs	r5, r1
    6630:	40e5      	lsrs	r5, r4
    6632:	46a8      	mov	r8, r5
    6634:	000c      	movs	r4, r1
    6636:	4084      	lsls	r4, r0
    6638:	46a1      	mov	r9, r4

		r = r << 1;
    663a:	0014      	movs	r4, r2
    663c:	001d      	movs	r5, r3
    663e:	18a4      	adds	r4, r4, r2
    6640:	415d      	adcs	r5, r3
    6642:	0022      	movs	r2, r4
    6644:	002b      	movs	r3, r5

		if (n & bit_shift) {
    6646:	4646      	mov	r6, r8
    6648:	465f      	mov	r7, fp
    664a:	423e      	tst	r6, r7
    664c:	d003      	beq.n	6656 <_sercom_get_async_baud_val+0x8a>
			r |= 0x01;
    664e:	000e      	movs	r6, r1
    6650:	4326      	orrs	r6, r4
    6652:	0032      	movs	r2, r6
    6654:	002b      	movs	r3, r5
		}

		if (r >= d) {
    6656:	9c02      	ldr	r4, [sp, #8]
    6658:	9d03      	ldr	r5, [sp, #12]
    665a:	429d      	cmp	r5, r3
    665c:	d80f      	bhi.n	667e <_sercom_get_async_baud_val+0xb2>
    665e:	d101      	bne.n	6664 <_sercom_get_async_baud_val+0x98>
    6660:	4294      	cmp	r4, r2
    6662:	d80c      	bhi.n	667e <_sercom_get_async_baud_val+0xb2>
			r = r - d;
    6664:	9c02      	ldr	r4, [sp, #8]
    6666:	9d03      	ldr	r5, [sp, #12]
    6668:	1b12      	subs	r2, r2, r4
    666a:	41ab      	sbcs	r3, r5
			q |= bit_shift;
    666c:	464d      	mov	r5, r9
    666e:	9e00      	ldr	r6, [sp, #0]
    6670:	9f01      	ldr	r7, [sp, #4]
    6672:	4335      	orrs	r5, r6
    6674:	003c      	movs	r4, r7
    6676:	4646      	mov	r6, r8
    6678:	4334      	orrs	r4, r6
    667a:	9500      	str	r5, [sp, #0]
    667c:	9401      	str	r4, [sp, #4]
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
    667e:	3801      	subs	r0, #1
    6680:	d2cb      	bcs.n	661a <_sercom_get_async_baud_val+0x4e>
	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
    6682:	2200      	movs	r2, #0
    6684:	2301      	movs	r3, #1
    6686:	9800      	ldr	r0, [sp, #0]
    6688:	9901      	ldr	r1, [sp, #4]
    668a:	1a12      	subs	r2, r2, r0
    668c:	418b      	sbcs	r3, r1
    668e:	0c12      	lsrs	r2, r2, #16
    6690:	041b      	lsls	r3, r3, #16
    6692:	431a      	orrs	r2, r3
    6694:	e06f      	b.n	6776 <_sercom_get_async_baud_val+0x1aa>
		enum sercom_asynchronous_sample_num sample_num)
{
	/* Temporary variables  */
	uint64_t ratio = 0;
	uint64_t scale = 0;
	uint64_t baud_calculated = 0;
    6696:	2200      	movs	r2, #0
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
    6698:	2b01      	cmp	r3, #1
    669a:	d16c      	bne.n	6776 <_sercom_get_async_baud_val+0x1aa>
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
    669c:	0f63      	lsrs	r3, r4, #29
    669e:	9304      	str	r3, [sp, #16]
    66a0:	00e3      	lsls	r3, r4, #3
    66a2:	4698      	mov	r8, r3
			temp2 = ((uint64_t)baudrate * sample_num);
    66a4:	000a      	movs	r2, r1
    66a6:	2300      	movs	r3, #0
    66a8:	2100      	movs	r1, #0
    66aa:	4c38      	ldr	r4, [pc, #224]	; (678c <_sercom_get_async_baud_val+0x1c0>)
    66ac:	47a0      	blx	r4
    66ae:	0004      	movs	r4, r0
    66b0:	000d      	movs	r5, r1
    66b2:	2300      	movs	r3, #0
    66b4:	469c      	mov	ip, r3
    66b6:	9306      	str	r3, [sp, #24]
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;
    66b8:	3320      	adds	r3, #32
    66ba:	469b      	mov	fp, r3
    66bc:	2601      	movs	r6, #1
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
			baud_int = baud_int / BAUD_FP_MAX;
			if(baud_int < BAUD_INT_MAX) {
    66be:	4663      	mov	r3, ip
    66c0:	9307      	str	r3, [sp, #28]
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
    66c2:	2300      	movs	r3, #0
    66c4:	9302      	str	r3, [sp, #8]
    66c6:	2200      	movs	r2, #0
    66c8:	2300      	movs	r3, #0
	for (i = 63; i >= 0; i--) {
    66ca:	213f      	movs	r1, #63	; 0x3f
    66cc:	9400      	str	r4, [sp, #0]
    66ce:	9501      	str	r5, [sp, #4]
    66d0:	000f      	movs	r7, r1
		bit_shift = (uint64_t)1 << i;
    66d2:	2120      	movs	r1, #32
    66d4:	4249      	negs	r1, r1
    66d6:	1879      	adds	r1, r7, r1
    66d8:	d403      	bmi.n	66e2 <_sercom_get_async_baud_val+0x116>
    66da:	0030      	movs	r0, r6
    66dc:	4088      	lsls	r0, r1
    66de:	4684      	mov	ip, r0
    66e0:	e004      	b.n	66ec <_sercom_get_async_baud_val+0x120>
    66e2:	4659      	mov	r1, fp
    66e4:	1bc9      	subs	r1, r1, r7
    66e6:	0030      	movs	r0, r6
    66e8:	40c8      	lsrs	r0, r1
    66ea:	4684      	mov	ip, r0
    66ec:	0031      	movs	r1, r6
    66ee:	40b9      	lsls	r1, r7
    66f0:	4689      	mov	r9, r1

		r = r << 1;
    66f2:	0010      	movs	r0, r2
    66f4:	0019      	movs	r1, r3
    66f6:	1880      	adds	r0, r0, r2
    66f8:	4159      	adcs	r1, r3
    66fa:	0002      	movs	r2, r0
    66fc:	000b      	movs	r3, r1

		if (n & bit_shift) {
    66fe:	4644      	mov	r4, r8
    6700:	464d      	mov	r5, r9
    6702:	402c      	ands	r4, r5
    6704:	46a2      	mov	sl, r4
    6706:	4664      	mov	r4, ip
    6708:	9d04      	ldr	r5, [sp, #16]
    670a:	402c      	ands	r4, r5
    670c:	46a4      	mov	ip, r4
    670e:	4654      	mov	r4, sl
    6710:	4665      	mov	r5, ip
    6712:	432c      	orrs	r4, r5
    6714:	d003      	beq.n	671e <_sercom_get_async_baud_val+0x152>
			r |= 0x01;
    6716:	0034      	movs	r4, r6
    6718:	4304      	orrs	r4, r0
    671a:	0022      	movs	r2, r4
    671c:	000b      	movs	r3, r1
		}

		if (r >= d) {
    671e:	9800      	ldr	r0, [sp, #0]
    6720:	9901      	ldr	r1, [sp, #4]
    6722:	4299      	cmp	r1, r3
    6724:	d80a      	bhi.n	673c <_sercom_get_async_baud_val+0x170>
    6726:	d101      	bne.n	672c <_sercom_get_async_baud_val+0x160>
    6728:	4290      	cmp	r0, r2
    672a:	d807      	bhi.n	673c <_sercom_get_async_baud_val+0x170>
			r = r - d;
    672c:	9800      	ldr	r0, [sp, #0]
    672e:	9901      	ldr	r1, [sp, #4]
    6730:	1a12      	subs	r2, r2, r0
    6732:	418b      	sbcs	r3, r1
			q |= bit_shift;
    6734:	9902      	ldr	r1, [sp, #8]
    6736:	4648      	mov	r0, r9
    6738:	4301      	orrs	r1, r0
    673a:	9102      	str	r1, [sp, #8]
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
    673c:	3f01      	subs	r7, #1
    673e:	d2c8      	bcs.n	66d2 <_sercom_get_async_baud_val+0x106>
    6740:	9c00      	ldr	r4, [sp, #0]
    6742:	9d01      	ldr	r5, [sp, #4]
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
    6744:	9902      	ldr	r1, [sp, #8]
    6746:	9a07      	ldr	r2, [sp, #28]
    6748:	1a8b      	subs	r3, r1, r2
			baud_int = baud_int / BAUD_FP_MAX;
    674a:	08db      	lsrs	r3, r3, #3
			if(baud_int < BAUD_INT_MAX) {
    674c:	4910      	ldr	r1, [pc, #64]	; (6790 <_sercom_get_async_baud_val+0x1c4>)
    674e:	428b      	cmp	r3, r1
    6750:	d90b      	bls.n	676a <_sercom_get_async_baud_val+0x19e>
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
    6752:	9b06      	ldr	r3, [sp, #24]
    6754:	3301      	adds	r3, #1
    6756:	b2db      	uxtb	r3, r3
    6758:	0019      	movs	r1, r3
    675a:	9306      	str	r3, [sp, #24]
    675c:	0013      	movs	r3, r2
    675e:	3301      	adds	r3, #1
    6760:	9307      	str	r3, [sp, #28]
    6762:	2908      	cmp	r1, #8
    6764:	d1ad      	bne.n	66c2 <_sercom_get_async_baud_val+0xf6>
			if(baud_int < BAUD_INT_MAX) {
				break;
			}
		}
		if(baud_fp == BAUD_FP_MAX) {
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    6766:	2540      	movs	r5, #64	; 0x40
    6768:	e008      	b.n	677c <_sercom_get_async_baud_val+0x1b0>
    676a:	2540      	movs	r5, #64	; 0x40
			baud_int = baud_int / BAUD_FP_MAX;
			if(baud_int < BAUD_INT_MAX) {
				break;
			}
		}
		if(baud_fp == BAUD_FP_MAX) {
    676c:	9a06      	ldr	r2, [sp, #24]
    676e:	2a08      	cmp	r2, #8
    6770:	d004      	beq.n	677c <_sercom_get_async_baud_val+0x1b0>
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
		baud_calculated = baud_int | (baud_fp << 13);
    6772:	0352      	lsls	r2, r2, #13
    6774:	431a      	orrs	r2, r3
	}

	*baudval = baud_calculated;
    6776:	9b05      	ldr	r3, [sp, #20]
    6778:	801a      	strh	r2, [r3, #0]
	return STATUS_OK;
    677a:	2500      	movs	r5, #0
}
    677c:	0028      	movs	r0, r5
    677e:	b009      	add	sp, #36	; 0x24
    6780:	bc3c      	pop	{r2, r3, r4, r5}
    6782:	4690      	mov	r8, r2
    6784:	4699      	mov	r9, r3
    6786:	46a2      	mov	sl, r4
    6788:	46ab      	mov	fp, r5
    678a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    678c:	0000a6a9 	.word	0x0000a6a9
    6790:	00001fff 	.word	0x00001fff

00006794 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
    6794:	b510      	push	{r4, lr}
    6796:	b082      	sub	sp, #8
    6798:	0004      	movs	r4, r0
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
    679a:	4b0e      	ldr	r3, [pc, #56]	; (67d4 <sercom_set_gclk_generator+0x40>)
    679c:	781b      	ldrb	r3, [r3, #0]
    679e:	2b00      	cmp	r3, #0
    67a0:	d001      	beq.n	67a6 <sercom_set_gclk_generator+0x12>
    67a2:	2900      	cmp	r1, #0
    67a4:	d00d      	beq.n	67c2 <sercom_set_gclk_generator+0x2e>
		/* Create and fill a GCLK configuration structure for the new config */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
		gclk_chan_conf.source_generator = generator_source;
    67a6:	a901      	add	r1, sp, #4
    67a8:	700c      	strb	r4, [r1, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
    67aa:	2011      	movs	r0, #17
    67ac:	4b0a      	ldr	r3, [pc, #40]	; (67d8 <sercom_set_gclk_generator+0x44>)
    67ae:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
    67b0:	2011      	movs	r0, #17
    67b2:	4b0a      	ldr	r3, [pc, #40]	; (67dc <sercom_set_gclk_generator+0x48>)
    67b4:	4798      	blx	r3

		/* Save config */
		_sercom_config.generator_source = generator_source;
    67b6:	4b07      	ldr	r3, [pc, #28]	; (67d4 <sercom_set_gclk_generator+0x40>)
    67b8:	705c      	strb	r4, [r3, #1]
		_sercom_config.generator_is_set = true;
    67ba:	2201      	movs	r2, #1
    67bc:	701a      	strb	r2, [r3, #0]

		return STATUS_OK;
    67be:	2000      	movs	r0, #0
    67c0:	e006      	b.n	67d0 <sercom_set_gclk_generator+0x3c>
	} else if (generator_source == _sercom_config.generator_source) {
    67c2:	4b04      	ldr	r3, [pc, #16]	; (67d4 <sercom_set_gclk_generator+0x40>)
    67c4:	785b      	ldrb	r3, [r3, #1]
    67c6:	4283      	cmp	r3, r0
    67c8:	d001      	beq.n	67ce <sercom_set_gclk_generator+0x3a>
		/* Return status OK if same config */
		return STATUS_OK;
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
    67ca:	201d      	movs	r0, #29
    67cc:	e000      	b.n	67d0 <sercom_set_gclk_generator+0x3c>
		_sercom_config.generator_is_set = true;

		return STATUS_OK;
	} else if (generator_source == _sercom_config.generator_source) {
		/* Return status OK if same config */
		return STATUS_OK;
    67ce:	2000      	movs	r0, #0
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
}
    67d0:	b002      	add	sp, #8
    67d2:	bd10      	pop	{r4, pc}
    67d4:	20000394 	.word	0x20000394
    67d8:	00007715 	.word	0x00007715
    67dc:	000076a5 	.word	0x000076a5

000067e0 <_sercom_get_default_pad>:
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
    67e0:	4b44      	ldr	r3, [pc, #272]	; (68f4 <_sercom_get_default_pad+0x114>)
    67e2:	4298      	cmp	r0, r3
    67e4:	d034      	beq.n	6850 <_sercom_get_default_pad+0x70>
    67e6:	d807      	bhi.n	67f8 <_sercom_get_default_pad+0x18>
    67e8:	2384      	movs	r3, #132	; 0x84
    67ea:	05db      	lsls	r3, r3, #23
    67ec:	4298      	cmp	r0, r3
    67ee:	d00d      	beq.n	680c <_sercom_get_default_pad+0x2c>
    67f0:	4b41      	ldr	r3, [pc, #260]	; (68f8 <_sercom_get_default_pad+0x118>)
    67f2:	4298      	cmp	r0, r3
    67f4:	d01b      	beq.n	682e <_sercom_get_default_pad+0x4e>
    67f6:	e06f      	b.n	68d8 <_sercom_get_default_pad+0xf8>
    67f8:	4b40      	ldr	r3, [pc, #256]	; (68fc <_sercom_get_default_pad+0x11c>)
    67fa:	4298      	cmp	r0, r3
    67fc:	d04a      	beq.n	6894 <_sercom_get_default_pad+0xb4>
    67fe:	4b40      	ldr	r3, [pc, #256]	; (6900 <_sercom_get_default_pad+0x120>)
    6800:	4298      	cmp	r0, r3
    6802:	d058      	beq.n	68b6 <_sercom_get_default_pad+0xd6>
    6804:	4b3f      	ldr	r3, [pc, #252]	; (6904 <_sercom_get_default_pad+0x124>)
    6806:	4298      	cmp	r0, r3
    6808:	d166      	bne.n	68d8 <_sercom_get_default_pad+0xf8>
    680a:	e032      	b.n	6872 <_sercom_get_default_pad+0x92>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    680c:	2901      	cmp	r1, #1
    680e:	d006      	beq.n	681e <_sercom_get_default_pad+0x3e>
    6810:	2900      	cmp	r1, #0
    6812:	d063      	beq.n	68dc <_sercom_get_default_pad+0xfc>
    6814:	2902      	cmp	r1, #2
    6816:	d006      	beq.n	6826 <_sercom_get_default_pad+0x46>
    6818:	2903      	cmp	r1, #3
    681a:	d006      	beq.n	682a <_sercom_get_default_pad+0x4a>
    681c:	e001      	b.n	6822 <_sercom_get_default_pad+0x42>
    681e:	483a      	ldr	r0, [pc, #232]	; (6908 <_sercom_get_default_pad+0x128>)
    6820:	e067      	b.n	68f2 <_sercom_get_default_pad+0x112>
	}

	Assert(false);
	return 0;
    6822:	2000      	movs	r0, #0
    6824:	e065      	b.n	68f2 <_sercom_get_default_pad+0x112>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    6826:	4839      	ldr	r0, [pc, #228]	; (690c <_sercom_get_default_pad+0x12c>)
    6828:	e063      	b.n	68f2 <_sercom_get_default_pad+0x112>
    682a:	4839      	ldr	r0, [pc, #228]	; (6910 <_sercom_get_default_pad+0x130>)
    682c:	e061      	b.n	68f2 <_sercom_get_default_pad+0x112>
    682e:	2901      	cmp	r1, #1
    6830:	d006      	beq.n	6840 <_sercom_get_default_pad+0x60>
    6832:	2900      	cmp	r1, #0
    6834:	d054      	beq.n	68e0 <_sercom_get_default_pad+0x100>
    6836:	2902      	cmp	r1, #2
    6838:	d006      	beq.n	6848 <_sercom_get_default_pad+0x68>
    683a:	2903      	cmp	r1, #3
    683c:	d006      	beq.n	684c <_sercom_get_default_pad+0x6c>
    683e:	e001      	b.n	6844 <_sercom_get_default_pad+0x64>
    6840:	4834      	ldr	r0, [pc, #208]	; (6914 <_sercom_get_default_pad+0x134>)
    6842:	e056      	b.n	68f2 <_sercom_get_default_pad+0x112>
	}

	Assert(false);
	return 0;
    6844:	2000      	movs	r0, #0
    6846:	e054      	b.n	68f2 <_sercom_get_default_pad+0x112>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    6848:	4833      	ldr	r0, [pc, #204]	; (6918 <_sercom_get_default_pad+0x138>)
    684a:	e052      	b.n	68f2 <_sercom_get_default_pad+0x112>
    684c:	4833      	ldr	r0, [pc, #204]	; (691c <_sercom_get_default_pad+0x13c>)
    684e:	e050      	b.n	68f2 <_sercom_get_default_pad+0x112>
    6850:	2901      	cmp	r1, #1
    6852:	d006      	beq.n	6862 <_sercom_get_default_pad+0x82>
    6854:	2900      	cmp	r1, #0
    6856:	d045      	beq.n	68e4 <_sercom_get_default_pad+0x104>
    6858:	2902      	cmp	r1, #2
    685a:	d006      	beq.n	686a <_sercom_get_default_pad+0x8a>
    685c:	2903      	cmp	r1, #3
    685e:	d006      	beq.n	686e <_sercom_get_default_pad+0x8e>
    6860:	e001      	b.n	6866 <_sercom_get_default_pad+0x86>
    6862:	482f      	ldr	r0, [pc, #188]	; (6920 <_sercom_get_default_pad+0x140>)
    6864:	e045      	b.n	68f2 <_sercom_get_default_pad+0x112>
	}

	Assert(false);
	return 0;
    6866:	2000      	movs	r0, #0
    6868:	e043      	b.n	68f2 <_sercom_get_default_pad+0x112>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    686a:	482e      	ldr	r0, [pc, #184]	; (6924 <_sercom_get_default_pad+0x144>)
    686c:	e041      	b.n	68f2 <_sercom_get_default_pad+0x112>
    686e:	482e      	ldr	r0, [pc, #184]	; (6928 <_sercom_get_default_pad+0x148>)
    6870:	e03f      	b.n	68f2 <_sercom_get_default_pad+0x112>
    6872:	2901      	cmp	r1, #1
    6874:	d006      	beq.n	6884 <_sercom_get_default_pad+0xa4>
    6876:	2900      	cmp	r1, #0
    6878:	d036      	beq.n	68e8 <_sercom_get_default_pad+0x108>
    687a:	2902      	cmp	r1, #2
    687c:	d006      	beq.n	688c <_sercom_get_default_pad+0xac>
    687e:	2903      	cmp	r1, #3
    6880:	d006      	beq.n	6890 <_sercom_get_default_pad+0xb0>
    6882:	e001      	b.n	6888 <_sercom_get_default_pad+0xa8>
    6884:	4829      	ldr	r0, [pc, #164]	; (692c <_sercom_get_default_pad+0x14c>)
    6886:	e034      	b.n	68f2 <_sercom_get_default_pad+0x112>
	}

	Assert(false);
	return 0;
    6888:	2000      	movs	r0, #0
    688a:	e032      	b.n	68f2 <_sercom_get_default_pad+0x112>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    688c:	4828      	ldr	r0, [pc, #160]	; (6930 <_sercom_get_default_pad+0x150>)
    688e:	e030      	b.n	68f2 <_sercom_get_default_pad+0x112>
    6890:	4828      	ldr	r0, [pc, #160]	; (6934 <_sercom_get_default_pad+0x154>)
    6892:	e02e      	b.n	68f2 <_sercom_get_default_pad+0x112>
    6894:	2901      	cmp	r1, #1
    6896:	d006      	beq.n	68a6 <_sercom_get_default_pad+0xc6>
    6898:	2900      	cmp	r1, #0
    689a:	d027      	beq.n	68ec <_sercom_get_default_pad+0x10c>
    689c:	2902      	cmp	r1, #2
    689e:	d006      	beq.n	68ae <_sercom_get_default_pad+0xce>
    68a0:	2903      	cmp	r1, #3
    68a2:	d006      	beq.n	68b2 <_sercom_get_default_pad+0xd2>
    68a4:	e001      	b.n	68aa <_sercom_get_default_pad+0xca>
    68a6:	4824      	ldr	r0, [pc, #144]	; (6938 <_sercom_get_default_pad+0x158>)
    68a8:	e023      	b.n	68f2 <_sercom_get_default_pad+0x112>
	}

	Assert(false);
	return 0;
    68aa:	2000      	movs	r0, #0
    68ac:	e021      	b.n	68f2 <_sercom_get_default_pad+0x112>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    68ae:	4823      	ldr	r0, [pc, #140]	; (693c <_sercom_get_default_pad+0x15c>)
    68b0:	e01f      	b.n	68f2 <_sercom_get_default_pad+0x112>
    68b2:	4823      	ldr	r0, [pc, #140]	; (6940 <_sercom_get_default_pad+0x160>)
    68b4:	e01d      	b.n	68f2 <_sercom_get_default_pad+0x112>
    68b6:	2901      	cmp	r1, #1
    68b8:	d006      	beq.n	68c8 <_sercom_get_default_pad+0xe8>
    68ba:	2900      	cmp	r1, #0
    68bc:	d018      	beq.n	68f0 <_sercom_get_default_pad+0x110>
    68be:	2902      	cmp	r1, #2
    68c0:	d006      	beq.n	68d0 <_sercom_get_default_pad+0xf0>
    68c2:	2903      	cmp	r1, #3
    68c4:	d006      	beq.n	68d4 <_sercom_get_default_pad+0xf4>
    68c6:	e001      	b.n	68cc <_sercom_get_default_pad+0xec>
    68c8:	481e      	ldr	r0, [pc, #120]	; (6944 <_sercom_get_default_pad+0x164>)
    68ca:	e012      	b.n	68f2 <_sercom_get_default_pad+0x112>
	}

	Assert(false);
	return 0;
    68cc:	2000      	movs	r0, #0
    68ce:	e010      	b.n	68f2 <_sercom_get_default_pad+0x112>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    68d0:	481d      	ldr	r0, [pc, #116]	; (6948 <_sercom_get_default_pad+0x168>)
    68d2:	e00e      	b.n	68f2 <_sercom_get_default_pad+0x112>
    68d4:	481d      	ldr	r0, [pc, #116]	; (694c <_sercom_get_default_pad+0x16c>)
    68d6:	e00c      	b.n	68f2 <_sercom_get_default_pad+0x112>
	}

	Assert(false);
	return 0;
    68d8:	2000      	movs	r0, #0
    68da:	e00a      	b.n	68f2 <_sercom_get_default_pad+0x112>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    68dc:	481c      	ldr	r0, [pc, #112]	; (6950 <_sercom_get_default_pad+0x170>)
    68de:	e008      	b.n	68f2 <_sercom_get_default_pad+0x112>
    68e0:	2003      	movs	r0, #3
    68e2:	e006      	b.n	68f2 <_sercom_get_default_pad+0x112>
    68e4:	481b      	ldr	r0, [pc, #108]	; (6954 <_sercom_get_default_pad+0x174>)
    68e6:	e004      	b.n	68f2 <_sercom_get_default_pad+0x112>
    68e8:	481b      	ldr	r0, [pc, #108]	; (6958 <_sercom_get_default_pad+0x178>)
    68ea:	e002      	b.n	68f2 <_sercom_get_default_pad+0x112>
    68ec:	481b      	ldr	r0, [pc, #108]	; (695c <_sercom_get_default_pad+0x17c>)
    68ee:	e000      	b.n	68f2 <_sercom_get_default_pad+0x112>
    68f0:	481b      	ldr	r0, [pc, #108]	; (6960 <_sercom_get_default_pad+0x180>)
	}

	Assert(false);
	return 0;
}
    68f2:	4770      	bx	lr
    68f4:	42000800 	.word	0x42000800
    68f8:	42000400 	.word	0x42000400
    68fc:	42001000 	.word	0x42001000
    6900:	43000400 	.word	0x43000400
    6904:	42000c00 	.word	0x42000c00
    6908:	00050003 	.word	0x00050003
    690c:	00060003 	.word	0x00060003
    6910:	00070003 	.word	0x00070003
    6914:	00010003 	.word	0x00010003
    6918:	001e0003 	.word	0x001e0003
    691c:	001f0003 	.word	0x001f0003
    6920:	00090003 	.word	0x00090003
    6924:	000a0003 	.word	0x000a0003
    6928:	000b0003 	.word	0x000b0003
    692c:	00110003 	.word	0x00110003
    6930:	00120003 	.word	0x00120003
    6934:	00130003 	.word	0x00130003
    6938:	000d0003 	.word	0x000d0003
    693c:	000e0003 	.word	0x000e0003
    6940:	000f0003 	.word	0x000f0003
    6944:	00170003 	.word	0x00170003
    6948:	00180003 	.word	0x00180003
    694c:	00190003 	.word	0x00190003
    6950:	00040003 	.word	0x00040003
    6954:	00080003 	.word	0x00080003
    6958:	00100003 	.word	0x00100003
    695c:	000c0003 	.word	0x000c0003
    6960:	00160003 	.word	0x00160003

00006964 <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
    6964:	b530      	push	{r4, r5, lr}
    6966:	b087      	sub	sp, #28
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
    6968:	4b0c      	ldr	r3, [pc, #48]	; (699c <_sercom_get_sercom_inst_index+0x38>)
    696a:	466a      	mov	r2, sp
    696c:	cb32      	ldmia	r3!, {r1, r4, r5}
    696e:	c232      	stmia	r2!, {r1, r4, r5}
    6970:	cb32      	ldmia	r3!, {r1, r4, r5}
    6972:	c232      	stmia	r2!, {r1, r4, r5}

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
    6974:	9b00      	ldr	r3, [sp, #0]
    6976:	4283      	cmp	r3, r0
    6978:	d006      	beq.n	6988 <_sercom_get_sercom_inst_index+0x24>
    697a:	2301      	movs	r3, #1
    697c:	009a      	lsls	r2, r3, #2
    697e:	4669      	mov	r1, sp
    6980:	5852      	ldr	r2, [r2, r1]
    6982:	4282      	cmp	r2, r0
    6984:	d103      	bne.n	698e <_sercom_get_sercom_inst_index+0x2a>
    6986:	e000      	b.n	698a <_sercom_get_sercom_inst_index+0x26>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    6988:	2300      	movs	r3, #0
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
			return i;
    698a:	b2d8      	uxtb	r0, r3
    698c:	e003      	b.n	6996 <_sercom_get_sercom_inst_index+0x32>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    698e:	3301      	adds	r3, #1
    6990:	2b06      	cmp	r3, #6
    6992:	d1f3      	bne.n	697c <_sercom_get_sercom_inst_index+0x18>
		}
	}

	/* Invalid data given */
	Assert(false);
	return 0;
    6994:	2000      	movs	r0, #0
}
    6996:	b007      	add	sp, #28
    6998:	bd30      	pop	{r4, r5, pc}
    699a:	46c0      	nop			; (mov r8, r8)
    699c:	00013318 	.word	0x00013318

000069a0 <_sercom_default_handler>:
 */
static void _sercom_default_handler(
		const uint8_t instance)
{
	Assert(false);
}
    69a0:	4770      	bx	lr
    69a2:	46c0      	nop			; (mov r8, r8)

000069a4 <_sercom_set_handler>:
 * \param[in]  interrupt_handler  Pointer to instance callback handler.
 */
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
    69a4:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
    69a6:	4b0a      	ldr	r3, [pc, #40]	; (69d0 <_sercom_set_handler+0x2c>)
    69a8:	781b      	ldrb	r3, [r3, #0]
    69aa:	2b00      	cmp	r3, #0
    69ac:	d10c      	bne.n	69c8 <_sercom_set_handler+0x24>
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    69ae:	4f09      	ldr	r7, [pc, #36]	; (69d4 <_sercom_set_handler+0x30>)
    69b0:	4e09      	ldr	r6, [pc, #36]	; (69d8 <_sercom_set_handler+0x34>)
			_sercom_instances[i] = NULL;
    69b2:	4d0a      	ldr	r5, [pc, #40]	; (69dc <_sercom_set_handler+0x38>)
    69b4:	2400      	movs	r4, #0
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    69b6:	51de      	str	r6, [r3, r7]
			_sercom_instances[i] = NULL;
    69b8:	195a      	adds	r2, r3, r5
    69ba:	6014      	str	r4, [r2, #0]
    69bc:	3304      	adds	r3, #4
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    69be:	2b18      	cmp	r3, #24
    69c0:	d1f9      	bne.n	69b6 <_sercom_set_handler+0x12>
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
			_sercom_instances[i] = NULL;
		}

		_handler_table_initialized = true;
    69c2:	2201      	movs	r2, #1
    69c4:	4b02      	ldr	r3, [pc, #8]	; (69d0 <_sercom_set_handler+0x2c>)
    69c6:	701a      	strb	r2, [r3, #0]
	}

	/* Save interrupt handler */
	_sercom_interrupt_handlers[instance] = interrupt_handler;
    69c8:	0080      	lsls	r0, r0, #2
    69ca:	4b02      	ldr	r3, [pc, #8]	; (69d4 <_sercom_set_handler+0x30>)
    69cc:	50c1      	str	r1, [r0, r3]
}
    69ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
    69d0:	20000396 	.word	0x20000396
    69d4:	20000398 	.word	0x20000398
    69d8:	000069a1 	.word	0x000069a1
    69dc:	20001344 	.word	0x20001344

000069e0 <_sercom_get_interrupt_vector>:
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM6
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM7
 */
enum system_interrupt_vector _sercom_get_interrupt_vector(
		Sercom *const sercom_instance)
{
    69e0:	b510      	push	{r4, lr}
    69e2:	b082      	sub	sp, #8
    69e4:	0004      	movs	r4, r0
	const uint8_t sercom_int_vectors[SERCOM_INST_NUM] =
    69e6:	2206      	movs	r2, #6
    69e8:	4905      	ldr	r1, [pc, #20]	; (6a00 <_sercom_get_interrupt_vector+0x20>)
    69ea:	4668      	mov	r0, sp
    69ec:	4b05      	ldr	r3, [pc, #20]	; (6a04 <_sercom_get_interrupt_vector+0x24>)
    69ee:	4798      	blx	r3
		{
			MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_VECT_NUM, ~)
		};

	/* Retrieve the index of the SERCOM being requested */
	uint8_t instance_index = _sercom_get_sercom_inst_index(sercom_instance);
    69f0:	0020      	movs	r0, r4
    69f2:	4b05      	ldr	r3, [pc, #20]	; (6a08 <_sercom_get_interrupt_vector+0x28>)
    69f4:	4798      	blx	r3

	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
    69f6:	466b      	mov	r3, sp
    69f8:	5618      	ldrsb	r0, [r3, r0]
}
    69fa:	b002      	add	sp, #8
    69fc:	bd10      	pop	{r4, pc}
    69fe:	46c0      	nop			; (mov r8, r8)
    6a00:	00013330 	.word	0x00013330
    6a04:	0000a74d 	.word	0x0000a74d
    6a08:	00006965 	.word	0x00006965

00006a0c <SERCOM0_Handler>:

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
    6a0c:	b510      	push	{r4, lr}
    6a0e:	4b02      	ldr	r3, [pc, #8]	; (6a18 <SERCOM0_Handler+0xc>)
    6a10:	681b      	ldr	r3, [r3, #0]
    6a12:	2000      	movs	r0, #0
    6a14:	4798      	blx	r3
    6a16:	bd10      	pop	{r4, pc}
    6a18:	20000398 	.word	0x20000398

00006a1c <SERCOM1_Handler>:
    6a1c:	b510      	push	{r4, lr}
    6a1e:	4b02      	ldr	r3, [pc, #8]	; (6a28 <SERCOM1_Handler+0xc>)
    6a20:	685b      	ldr	r3, [r3, #4]
    6a22:	2001      	movs	r0, #1
    6a24:	4798      	blx	r3
    6a26:	bd10      	pop	{r4, pc}
    6a28:	20000398 	.word	0x20000398

00006a2c <SERCOM2_Handler>:
    6a2c:	b510      	push	{r4, lr}
    6a2e:	4b02      	ldr	r3, [pc, #8]	; (6a38 <SERCOM2_Handler+0xc>)
    6a30:	689b      	ldr	r3, [r3, #8]
    6a32:	2002      	movs	r0, #2
    6a34:	4798      	blx	r3
    6a36:	bd10      	pop	{r4, pc}
    6a38:	20000398 	.word	0x20000398

00006a3c <SERCOM3_Handler>:
    6a3c:	b510      	push	{r4, lr}
    6a3e:	4b02      	ldr	r3, [pc, #8]	; (6a48 <SERCOM3_Handler+0xc>)
    6a40:	68db      	ldr	r3, [r3, #12]
    6a42:	2003      	movs	r0, #3
    6a44:	4798      	blx	r3
    6a46:	bd10      	pop	{r4, pc}
    6a48:	20000398 	.word	0x20000398

00006a4c <SERCOM4_Handler>:
    6a4c:	b510      	push	{r4, lr}
    6a4e:	4b02      	ldr	r3, [pc, #8]	; (6a58 <SERCOM4_Handler+0xc>)
    6a50:	691b      	ldr	r3, [r3, #16]
    6a52:	2004      	movs	r0, #4
    6a54:	4798      	blx	r3
    6a56:	bd10      	pop	{r4, pc}
    6a58:	20000398 	.word	0x20000398

00006a5c <SERCOM5_Handler>:
    6a5c:	b510      	push	{r4, lr}
    6a5e:	4b02      	ldr	r3, [pc, #8]	; (6a68 <SERCOM5_Handler+0xc>)
    6a60:	695b      	ldr	r3, [r3, #20]
    6a62:	2005      	movs	r0, #5
    6a64:	4798      	blx	r3
    6a66:	bd10      	pop	{r4, pc}
    6a68:	20000398 	.word	0x20000398

00006a6c <usart_init>:
 */
enum status_code usart_init(
		struct usart_module *const module,
		Sercom *const hw,
		const struct usart_config *const config)
{
    6a6c:	b5f0      	push	{r4, r5, r6, r7, lr}
    6a6e:	465f      	mov	r7, fp
    6a70:	4656      	mov	r6, sl
    6a72:	464d      	mov	r5, r9
    6a74:	4644      	mov	r4, r8
    6a76:	b4f0      	push	{r4, r5, r6, r7}
    6a78:	b091      	sub	sp, #68	; 0x44
    6a7a:	0005      	movs	r5, r0
    6a7c:	000c      	movs	r4, r1
    6a7e:	0016      	movs	r6, r2
	Assert(config);

	enum status_code status_code = STATUS_OK;

	/* Assign module pointer to software instance struct */
	module->hw = hw;
    6a80:	6029      	str	r1, [r5, #0]

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    6a82:	0008      	movs	r0, r1
    6a84:	4bc4      	ldr	r3, [pc, #784]	; (6d98 <usart_init+0x32c>)
    6a86:	4798      	blx	r3
    6a88:	1e02      	subs	r2, r0, #0
	uint32_t pm_index, gclk_index; 
#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
#if (SAML21)
	if (sercom_index == 5) {
    6a8a:	2a05      	cmp	r2, #5
    6a8c:	d003      	beq.n	6a96 <usart_init+0x2a>
		pm_index     = MCLK_APBDMASK_SERCOM5_Pos;
		gclk_index   = SERCOM5_GCLK_ID_CORE;
	} else {
		pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
		gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    6a8e:	0007      	movs	r7, r0
    6a90:	3712      	adds	r7, #18
#if (SAML21)
	if (sercom_index == 5) {
		pm_index     = MCLK_APBDMASK_SERCOM5_Pos;
		gclk_index   = SERCOM5_GCLK_ID_CORE;
	} else {
		pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
    6a92:	0003      	movs	r3, r0
    6a94:	e001      	b.n	6a9a <usart_init+0x2e>
	uint32_t pm_index, gclk_index; 
#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
#if (SAML21)
	if (sercom_index == 5) {
		pm_index     = MCLK_APBDMASK_SERCOM5_Pos;
		gclk_index   = SERCOM5_GCLK_ID_CORE;
    6a96:	2718      	movs	r7, #24
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
	uint32_t pm_index, gclk_index; 
#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
#if (SAML21)
	if (sercom_index == 5) {
		pm_index     = MCLK_APBDMASK_SERCOM5_Pos;
    6a98:	2301      	movs	r3, #1
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    6a9a:	6821      	ldr	r1, [r4, #0]
		/* The module is busy resetting itself */
		return STATUS_BUSY;
    6a9c:	2005      	movs	r0, #5
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    6a9e:	07c9      	lsls	r1, r1, #31
    6aa0:	d500      	bpl.n	6aa4 <usart_init+0x38>
    6aa2:	e171      	b.n	6d88 <usart_init+0x31c>
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    6aa4:	6821      	ldr	r1, [r4, #0]
		/* Check the module is enabled */
		return STATUS_ERR_DENIED;
    6aa6:	3017      	adds	r0, #23
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    6aa8:	0789      	lsls	r1, r1, #30
    6aaa:	d500      	bpl.n	6aae <usart_init+0x42>
    6aac:	e16c      	b.n	6d88 <usart_init+0x31c>
		return STATUS_ERR_DENIED;
	}

	/* Turn on module in PM */
#if (SAML21)
	if (sercom_index == 5) {
    6aae:	2a05      	cmp	r2, #5
    6ab0:	d107      	bne.n	6ac2 <usart_init+0x56>

		case SYSTEM_CLOCK_APB_APBC:
			MCLK->APBCMASK.reg |= mask;
			break;
		case SYSTEM_CLOCK_APB_APBD:
			MCLK->APBDMASK.reg |= mask;
    6ab2:	48ba      	ldr	r0, [pc, #744]	; (6d9c <usart_init+0x330>)
    6ab4:	6a02      	ldr	r2, [r0, #32]
    6ab6:	2101      	movs	r1, #1
    6ab8:	4099      	lsls	r1, r3
    6aba:	000b      	movs	r3, r1
    6abc:	4313      	orrs	r3, r2
    6abe:	6203      	str	r3, [r0, #32]
    6ac0:	e006      	b.n	6ad0 <usart_init+0x64>
		case SYSTEM_CLOCK_APB_APBB:
			MCLK->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			MCLK->APBCMASK.reg |= mask;
    6ac2:	48b6      	ldr	r0, [pc, #728]	; (6d9c <usart_init+0x330>)
    6ac4:	69c2      	ldr	r2, [r0, #28]
    6ac6:	2101      	movs	r1, #1
    6ac8:	4099      	lsls	r1, r3
    6aca:	000b      	movs	r3, r1
    6acc:	4313      	orrs	r3, r2
    6ace:	61c3      	str	r3, [r0, #28]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    6ad0:	a90f      	add	r1, sp, #60	; 0x3c
    6ad2:	232d      	movs	r3, #45	; 0x2d
    6ad4:	4698      	mov	r8, r3
    6ad6:	5cf3      	ldrb	r3, [r6, r3]
    6ad8:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    6ada:	b2ff      	uxtb	r7, r7
    6adc:	0038      	movs	r0, r7
    6ade:	4bb0      	ldr	r3, [pc, #704]	; (6da0 <usart_init+0x334>)
    6ae0:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    6ae2:	0038      	movs	r0, r7
    6ae4:	4baf      	ldr	r3, [pc, #700]	; (6da4 <usart_init+0x338>)
    6ae6:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    6ae8:	4643      	mov	r3, r8
    6aea:	5cf0      	ldrb	r0, [r6, r3]
    6aec:	2100      	movs	r1, #0
    6aee:	4bae      	ldr	r3, [pc, #696]	; (6da8 <usart_init+0x33c>)
    6af0:	4798      	blx	r3

	/* Set character size */
	module->character_size = config->character_size;
    6af2:	7af3      	ldrb	r3, [r6, #11]
    6af4:	716b      	strb	r3, [r5, #5]

	/* Set transmitter and receiver status */
	module->receiver_enabled = config->receiver_enable;
    6af6:	2324      	movs	r3, #36	; 0x24
    6af8:	5cf3      	ldrb	r3, [r6, r3]
    6afa:	71ab      	strb	r3, [r5, #6]
	module->transmitter_enabled = config->transmitter_enable;
    6afc:	2325      	movs	r3, #37	; 0x25
    6afe:	5cf3      	ldrb	r3, [r6, r3]
    6b00:	71eb      	strb	r3, [r5, #7]

#ifdef FEATURE_USART_LIN_SLAVE
	module->lin_slave_enabled = config->lin_slave_enable;
    6b02:	7ef3      	ldrb	r3, [r6, #27]
    6b04:	722b      	strb	r3, [r5, #8]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	module->start_frame_detection_enabled = config->start_frame_detection_enable;
    6b06:	7f33      	ldrb	r3, [r6, #28]
    6b08:	726b      	strb	r3, [r5, #9]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    6b0a:	682b      	ldr	r3, [r5, #0]
    6b0c:	4699      	mov	r9, r3

	/* Index for generic clock */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    6b0e:	0018      	movs	r0, r3
    6b10:	4ba1      	ldr	r3, [pc, #644]	; (6d98 <usart_init+0x32c>)
    6b12:	4798      	blx	r3
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    6b14:	3012      	adds	r0, #18
	uint32_t ctrla = 0;
	uint32_t ctrlb = 0;
#ifdef FEATURE_USART_ISO7816
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
    6b16:	2200      	movs	r2, #0
    6b18:	230e      	movs	r3, #14
    6b1a:	a906      	add	r1, sp, #24
    6b1c:	468c      	mov	ip, r1
    6b1e:	4463      	add	r3, ip
    6b20:	801a      	strh	r2, [r3, #0]

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;

#ifdef FEATURE_USART_OVER_SAMPLE
	switch (config->sample_rate) {
    6b22:	8a32      	ldrh	r2, [r6, #16]
    6b24:	9202      	str	r2, [sp, #8]
    6b26:	2380      	movs	r3, #128	; 0x80
    6b28:	01db      	lsls	r3, r3, #7
    6b2a:	429a      	cmp	r2, r3
    6b2c:	d01a      	beq.n	6b64 <usart_init+0xf8>
    6b2e:	d804      	bhi.n	6b3a <usart_init+0xce>
    6b30:	2380      	movs	r3, #128	; 0x80
    6b32:	019b      	lsls	r3, r3, #6
    6b34:	429a      	cmp	r2, r3
    6b36:	d00b      	beq.n	6b50 <usart_init+0xe4>
    6b38:	e107      	b.n	6d4a <usart_init+0x2de>
    6b3a:	23c0      	movs	r3, #192	; 0xc0
    6b3c:	01db      	lsls	r3, r3, #7
    6b3e:	9a02      	ldr	r2, [sp, #8]
    6b40:	429a      	cmp	r2, r3
    6b42:	d00a      	beq.n	6b5a <usart_init+0xee>
    6b44:	2380      	movs	r3, #128	; 0x80
    6b46:	021b      	lsls	r3, r3, #8
    6b48:	429a      	cmp	r2, r3
    6b4a:	d100      	bne.n	6b4e <usart_init+0xe2>
    6b4c:	e102      	b.n	6d54 <usart_init+0x2e8>
    6b4e:	e0fc      	b.n	6d4a <usart_init+0x2de>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
			break;
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    6b50:	2310      	movs	r3, #16
    6b52:	9306      	str	r3, [sp, #24]
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
			break;
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
    6b54:	3b0f      	subs	r3, #15
    6b56:	9307      	str	r3, [sp, #28]
    6b58:	e100      	b.n	6d5c <usart_init+0x2f0>
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    6b5a:	2308      	movs	r3, #8
    6b5c:	9306      	str	r3, [sp, #24]
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
    6b5e:	3b07      	subs	r3, #7
    6b60:	9307      	str	r3, [sp, #28]
    6b62:	e0fb      	b.n	6d5c <usart_init+0x2f0>
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
    6b64:	6833      	ldr	r3, [r6, #0]
    6b66:	9304      	str	r3, [sp, #16]
		(uint32_t)config->mux_setting |
    6b68:	68f3      	ldr	r3, [r6, #12]
    6b6a:	469b      	mov	fp, r3
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
    6b6c:	6973      	ldr	r3, [r6, #20]
    6b6e:	9303      	str	r3, [sp, #12]
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    6b70:	7e33      	ldrb	r3, [r6, #24]
    6b72:	4698      	mov	r8, r3
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    6b74:	2326      	movs	r3, #38	; 0x26
    6b76:	5cf3      	ldrb	r3, [r6, r3]
    6b78:	9305      	str	r3, [sp, #20]

	enum status_code status_code = STATUS_OK;

	transfer_mode = (uint32_t)config->transfer_mode;
    6b7a:	6873      	ldr	r3, [r6, #4]
    6b7c:	469a      	mov	sl, r3
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
    6b7e:	2b00      	cmp	r3, #0
    6b80:	d016      	beq.n	6bb0 <usart_init+0x144>
    6b82:	2380      	movs	r3, #128	; 0x80
    6b84:	055b      	lsls	r3, r3, #21
    6b86:	459a      	cmp	sl, r3
    6b88:	d139      	bne.n	6bfe <usart_init+0x192>
	{
		case USART_TRANSFER_SYNCHRONOUSLY:
			if (!config->use_external_clock) {
    6b8a:	2327      	movs	r3, #39	; 0x27
    6b8c:	5cf3      	ldrb	r3, [r6, r3]
    6b8e:	2b00      	cmp	r3, #0
    6b90:	d139      	bne.n	6c06 <usart_init+0x19a>
				status_code = _sercom_get_sync_baud_val(config->baudrate,
    6b92:	6a33      	ldr	r3, [r6, #32]
    6b94:	001f      	movs	r7, r3
    6b96:	b2c0      	uxtb	r0, r0
    6b98:	4b84      	ldr	r3, [pc, #528]	; (6dac <usart_init+0x340>)
    6b9a:	4798      	blx	r3
    6b9c:	0001      	movs	r1, r0
    6b9e:	220e      	movs	r2, #14
    6ba0:	ab06      	add	r3, sp, #24
    6ba2:	469c      	mov	ip, r3
    6ba4:	4462      	add	r2, ip
    6ba6:	0038      	movs	r0, r7
    6ba8:	4b81      	ldr	r3, [pc, #516]	; (6db0 <usart_init+0x344>)
    6baa:	4798      	blx	r3
    6bac:	0003      	movs	r3, r0
    6bae:	e027      	b.n	6c00 <usart_init+0x194>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    6bb0:	2308      	movs	r3, #8
    6bb2:	9306      	str	r3, [sp, #24]
		case USART_SAMPLE_RATE_16X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    6bb4:	2300      	movs	r3, #0
    6bb6:	9307      	str	r3, [sp, #28]
			}

			break;

		case USART_TRANSFER_ASYNCHRONOUSLY:
			if (config->use_external_clock) {
    6bb8:	2327      	movs	r3, #39	; 0x27
    6bba:	5cf3      	ldrb	r3, [r6, r3]
    6bbc:	2b00      	cmp	r3, #0
    6bbe:	d00c      	beq.n	6bda <usart_init+0x16e>
				status_code =
    6bc0:	9b06      	ldr	r3, [sp, #24]
    6bc2:	9300      	str	r3, [sp, #0]
    6bc4:	9b07      	ldr	r3, [sp, #28]
    6bc6:	220e      	movs	r2, #14
    6bc8:	a906      	add	r1, sp, #24
    6bca:	468c      	mov	ip, r1
    6bcc:	4462      	add	r2, ip
    6bce:	6ab1      	ldr	r1, [r6, #40]	; 0x28
    6bd0:	6a30      	ldr	r0, [r6, #32]
    6bd2:	4f78      	ldr	r7, [pc, #480]	; (6db4 <usart_init+0x348>)
    6bd4:	47b8      	blx	r7
    6bd6:	0003      	movs	r3, r0
    6bd8:	e012      	b.n	6c00 <usart_init+0x194>
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
    6bda:	6a33      	ldr	r3, [r6, #32]
    6bdc:	001f      	movs	r7, r3
    6bde:	b2c0      	uxtb	r0, r0
    6be0:	4b72      	ldr	r3, [pc, #456]	; (6dac <usart_init+0x340>)
    6be2:	4798      	blx	r3
    6be4:	0001      	movs	r1, r0
			if (config->use_external_clock) {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
    6be6:	9b06      	ldr	r3, [sp, #24]
    6be8:	9300      	str	r3, [sp, #0]
    6bea:	9b07      	ldr	r3, [sp, #28]
    6bec:	220e      	movs	r2, #14
    6bee:	a806      	add	r0, sp, #24
    6bf0:	4684      	mov	ip, r0
    6bf2:	4462      	add	r2, ip
    6bf4:	0038      	movs	r0, r7
    6bf6:	4f6f      	ldr	r7, [pc, #444]	; (6db4 <usart_init+0x348>)
    6bf8:	47b8      	blx	r7
    6bfa:	0003      	movs	r3, r0
    6bfc:	e000      	b.n	6c00 <usart_init+0x194>
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);

	enum status_code status_code = STATUS_OK;
    6bfe:	2300      	movs	r3, #0
    6c00:	1e18      	subs	r0, r3, #0

			break;
	}

	/* Check if calculating the baudrate failed */
	if (status_code != STATUS_OK) {
    6c02:	d000      	beq.n	6c06 <usart_init+0x19a>
    6c04:	e0c0      	b.n	6d88 <usart_init+0x31c>
#ifdef FEATURE_USART_ISO7816
	}
#endif

#ifdef FEATURE_USART_IRDA
	if(config->encoding_format_enable) {
    6c06:	7e73      	ldrb	r3, [r6, #25]
    6c08:	2b00      	cmp	r3, #0
    6c0a:	d002      	beq.n	6c12 <usart_init+0x1a6>
		usart_hw->RXPL.reg = config->receive_pulse_length;
    6c0c:	7eb3      	ldrb	r3, [r6, #26]
    6c0e:	464a      	mov	r2, r9
    6c10:	7393      	strb	r3, [r2, #14]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    6c12:	682a      	ldr	r2, [r5, #0]
    6c14:	9f02      	ldr	r7, [sp, #8]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    6c16:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    6c18:	2b00      	cmp	r3, #0
    6c1a:	d1fc      	bne.n	6c16 <usart_init+0x1aa>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/*Set baud val */
	usart_hw->BAUD.reg = baud;
    6c1c:	330e      	adds	r3, #14
    6c1e:	aa06      	add	r2, sp, #24
    6c20:	4694      	mov	ip, r2
    6c22:	4463      	add	r3, ip
    6c24:	881b      	ldrh	r3, [r3, #0]
    6c26:	464a      	mov	r2, r9
    6c28:	8193      	strh	r3, [r2, #12]

	/* Set sample mode */
	ctrla |= transfer_mode;
    6c2a:	9b04      	ldr	r3, [sp, #16]
    6c2c:	465a      	mov	r2, fp
    6c2e:	4313      	orrs	r3, r2
    6c30:	9a03      	ldr	r2, [sp, #12]
    6c32:	4313      	orrs	r3, r2
    6c34:	4652      	mov	r2, sl
    6c36:	4313      	orrs	r3, r2
    6c38:	433b      	orrs	r3, r7
    6c3a:	4642      	mov	r2, r8
    6c3c:	0212      	lsls	r2, r2, #8
    6c3e:	4313      	orrs	r3, r2
    6c40:	9a05      	ldr	r2, [sp, #20]
    6c42:	0757      	lsls	r7, r2, #29
    6c44:	431f      	orrs	r7, r3

	if (config->use_external_clock == false) {
    6c46:	2327      	movs	r3, #39	; 0x27
    6c48:	5cf3      	ldrb	r3, [r6, r3]
    6c4a:	2b00      	cmp	r3, #0
    6c4c:	d101      	bne.n	6c52 <usart_init+0x1e6>
		ctrla |= SERCOM_USART_CTRLA_MODE(0x1);
    6c4e:	3304      	adds	r3, #4
    6c50:	431f      	orrs	r7, r3
	else {
		ctrla |= SERCOM_USART_CTRLA_MODE(0x0);
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
    6c52:	7e71      	ldrb	r1, [r6, #25]
    6c54:	0289      	lsls	r1, r1, #10
    6c56:	7f33      	ldrb	r3, [r6, #28]
    6c58:	025b      	lsls	r3, r3, #9
    6c5a:	4319      	orrs	r1, r3
    6c5c:	7f73      	ldrb	r3, [r6, #29]
    6c5e:	021b      	lsls	r3, r3, #8
    6c60:	4319      	orrs	r1, r3
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
    6c62:	2324      	movs	r3, #36	; 0x24
	else {
		ctrla |= SERCOM_USART_CTRLA_MODE(0x0);
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
    6c64:	5cf3      	ldrb	r3, [r6, r3]
    6c66:	045b      	lsls	r3, r3, #17
    6c68:	4319      	orrs	r1, r3
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
			(config->transmitter_enable << SERCOM_USART_CTRLB_TXEN_Pos);
    6c6a:	2325      	movs	r3, #37	; 0x25
	else {
		ctrla |= SERCOM_USART_CTRLA_MODE(0x0);
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
    6c6c:	5cf2      	ldrb	r2, [r6, r3]
    6c6e:	0412      	lsls	r2, r2, #16
    6c70:	4311      	orrs	r1, r2
				ctrlb |= USART_STOPBITS_1;
				break;		
		}
	} else {
#endif
	ctrlb |= (uint32_t)config->character_size;
    6c72:	7af3      	ldrb	r3, [r6, #11]
    6c74:	4319      	orrs	r1, r3
	/* Check parity mode bits */
	if (config->parity != USART_PARITY_NONE) {
    6c76:	8933      	ldrh	r3, [r6, #8]
    6c78:	2bff      	cmp	r3, #255	; 0xff
    6c7a:	d004      	beq.n	6c86 <usart_init+0x21a>
		ctrla |= SERCOM_USART_CTRLA_FORM(1);
    6c7c:	2280      	movs	r2, #128	; 0x80
    6c7e:	0452      	lsls	r2, r2, #17
    6c80:	4317      	orrs	r7, r2
		ctrlb |= config->parity;
    6c82:	4319      	orrs	r1, r3
    6c84:	e005      	b.n	6c92 <usart_init+0x226>
	} else {
#ifdef FEATURE_USART_LIN_SLAVE
		if(config->lin_slave_enable) {
    6c86:	7ef3      	ldrb	r3, [r6, #27]
    6c88:	2b00      	cmp	r3, #0
    6c8a:	d002      	beq.n	6c92 <usart_init+0x226>
			ctrla |= SERCOM_USART_CTRLA_FORM(0x4);
    6c8c:	2380      	movs	r3, #128	; 0x80
    6c8e:	04db      	lsls	r3, r3, #19
    6c90:	431f      	orrs	r7, r3
		ctrla |= config->lin_node;
	}
#endif

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    6c92:	232c      	movs	r3, #44	; 0x2c
    6c94:	5cf3      	ldrb	r3, [r6, r3]
    6c96:	2b00      	cmp	r3, #0
    6c98:	d103      	bne.n	6ca2 <usart_init+0x236>
    6c9a:	4b47      	ldr	r3, [pc, #284]	; (6db8 <usart_init+0x34c>)
    6c9c:	789b      	ldrb	r3, [r3, #2]
    6c9e:	079b      	lsls	r3, r3, #30
    6ca0:	d501      	bpl.n	6ca6 <usart_init+0x23a>
		ctrla |= SERCOM_USART_CTRLA_RUNSTDBY;
    6ca2:	2380      	movs	r3, #128	; 0x80
    6ca4:	431f      	orrs	r7, r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    6ca6:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    6ca8:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    6caa:	2b00      	cmp	r3, #0
    6cac:	d1fc      	bne.n	6ca8 <usart_init+0x23c>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLB */
	usart_hw->CTRLB.reg = ctrlb;
    6cae:	464b      	mov	r3, r9
    6cb0:	6059      	str	r1, [r3, #4]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    6cb2:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    6cb4:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    6cb6:	2b00      	cmp	r3, #0
    6cb8:	d1fc      	bne.n	6cb4 <usart_init+0x248>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLA */
	usart_hw->CTRLA.reg = ctrla;
    6cba:	464b      	mov	r3, r9
    6cbc:	601f      	str	r7, [r3, #0]
    6cbe:	ab0e      	add	r3, sp, #56	; 0x38
    6cc0:	2280      	movs	r2, #128	; 0x80
    6cc2:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    6cc4:	2200      	movs	r2, #0
    6cc6:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    6cc8:	70da      	strb	r2, [r3, #3]
	}

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    6cca:	709a      	strb	r2, [r3, #2]

	uint32_t pad_pinmuxes[] = {
    6ccc:	6b33      	ldr	r3, [r6, #48]	; 0x30
    6cce:	930a      	str	r3, [sp, #40]	; 0x28
    6cd0:	6b73      	ldr	r3, [r6, #52]	; 0x34
    6cd2:	930b      	str	r3, [sp, #44]	; 0x2c
    6cd4:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    6cd6:	930c      	str	r3, [sp, #48]	; 0x30
    6cd8:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
    6cda:	9302      	str	r3, [sp, #8]
    6cdc:	930d      	str	r3, [sp, #52]	; 0x34
    6cde:	2700      	movs	r7, #0
		if (current_pinmux == PINMUX_DEFAULT) {
			current_pinmux = _sercom_get_default_pad(hw, pad);
		}

		if (current_pinmux != PINMUX_UNUSED) {
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    6ce0:	ae0e      	add	r6, sp, #56	; 0x38
    6ce2:	b2f9      	uxtb	r1, r7
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    6ce4:	00bb      	lsls	r3, r7, #2
    6ce6:	aa0a      	add	r2, sp, #40	; 0x28
    6ce8:	5898      	ldr	r0, [r3, r2]

		if (current_pinmux == PINMUX_DEFAULT) {
    6cea:	2800      	cmp	r0, #0
    6cec:	d102      	bne.n	6cf4 <usart_init+0x288>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    6cee:	0020      	movs	r0, r4
    6cf0:	4b32      	ldr	r3, [pc, #200]	; (6dbc <usart_init+0x350>)
    6cf2:	4798      	blx	r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
    6cf4:	1c43      	adds	r3, r0, #1
    6cf6:	d005      	beq.n	6d04 <usart_init+0x298>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    6cf8:	7030      	strb	r0, [r6, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    6cfa:	0c00      	lsrs	r0, r0, #16
    6cfc:	b2c0      	uxtb	r0, r0
    6cfe:	0031      	movs	r1, r6
    6d00:	4b2f      	ldr	r3, [pc, #188]	; (6dc0 <usart_init+0x354>)
    6d02:	4798      	blx	r3
    6d04:	3701      	adds	r7, #1
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    6d06:	2f04      	cmp	r7, #4
    6d08:	d1eb      	bne.n	6ce2 <usart_init+0x276>
	}

#if USART_CALLBACK_MODE == true
	/* Initialize parameters */
	for (uint32_t i = 0; i < USART_CALLBACK_N; i++) {
		module->callback[i]            = NULL;
    6d0a:	2300      	movs	r3, #0
    6d0c:	60eb      	str	r3, [r5, #12]
    6d0e:	612b      	str	r3, [r5, #16]
    6d10:	616b      	str	r3, [r5, #20]
    6d12:	61ab      	str	r3, [r5, #24]
    6d14:	61eb      	str	r3, [r5, #28]
    6d16:	622b      	str	r3, [r5, #32]
	}

	module->tx_buffer_ptr              = NULL;
    6d18:	62ab      	str	r3, [r5, #40]	; 0x28
	module->rx_buffer_ptr              = NULL;
    6d1a:	626b      	str	r3, [r5, #36]	; 0x24
	module->remaining_tx_buffer_length = 0x0000;
    6d1c:	2200      	movs	r2, #0
    6d1e:	85eb      	strh	r3, [r5, #46]	; 0x2e
	module->remaining_rx_buffer_length = 0x0000;
    6d20:	85ab      	strh	r3, [r5, #44]	; 0x2c
	module->callback_reg_mask          = 0x00;
    6d22:	3330      	adds	r3, #48	; 0x30
    6d24:	54ea      	strb	r2, [r5, r3]
	module->callback_enable_mask       = 0x00;
    6d26:	3301      	adds	r3, #1
    6d28:	54ea      	strb	r2, [r5, r3]
	module->rx_status                  = STATUS_OK;
    6d2a:	3301      	adds	r3, #1
    6d2c:	54ea      	strb	r2, [r5, r3]
	module->tx_status                  = STATUS_OK;
    6d2e:	3301      	adds	r3, #1
    6d30:	54ea      	strb	r2, [r5, r3]

	/* Set interrupt handler and register USART software module struct in
	 * look-up table */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
    6d32:	6828      	ldr	r0, [r5, #0]
    6d34:	4b18      	ldr	r3, [pc, #96]	; (6d98 <usart_init+0x32c>)
    6d36:	4798      	blx	r3
    6d38:	0004      	movs	r4, r0
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
    6d3a:	4922      	ldr	r1, [pc, #136]	; (6dc4 <usart_init+0x358>)
    6d3c:	4b22      	ldr	r3, [pc, #136]	; (6dc8 <usart_init+0x35c>)
    6d3e:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    6d40:	00a4      	lsls	r4, r4, #2
    6d42:	4b22      	ldr	r3, [pc, #136]	; (6dcc <usart_init+0x360>)
    6d44:	50e5      	str	r5, [r4, r3]
#endif

	return status_code;
    6d46:	2000      	movs	r0, #0
    6d48:	e01e      	b.n	6d88 <usart_init+0x31c>
#endif
	uint16_t baud  = 0;
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    6d4a:	2310      	movs	r3, #16
    6d4c:	9306      	str	r3, [sp, #24]
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    6d4e:	2300      	movs	r3, #0
    6d50:	9307      	str	r3, [sp, #28]
    6d52:	e003      	b.n	6d5c <usart_init+0x2f0>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
			break;
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
    6d54:	2303      	movs	r3, #3
    6d56:	9306      	str	r3, [sp, #24]
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
			break;
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    6d58:	2300      	movs	r3, #0
    6d5a:	9307      	str	r3, [sp, #28]
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
    6d5c:	6833      	ldr	r3, [r6, #0]
    6d5e:	9304      	str	r3, [sp, #16]
		(uint32_t)config->mux_setting |
    6d60:	68f3      	ldr	r3, [r6, #12]
    6d62:	469b      	mov	fp, r3
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
    6d64:	6973      	ldr	r3, [r6, #20]
    6d66:	9303      	str	r3, [sp, #12]
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    6d68:	7e33      	ldrb	r3, [r6, #24]
    6d6a:	4698      	mov	r8, r3
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    6d6c:	2326      	movs	r3, #38	; 0x26
    6d6e:	5cf3      	ldrb	r3, [r6, r3]
    6d70:	9305      	str	r3, [sp, #20]

	enum status_code status_code = STATUS_OK;

	transfer_mode = (uint32_t)config->transfer_mode;
    6d72:	6873      	ldr	r3, [r6, #4]
    6d74:	469a      	mov	sl, r3
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
    6d76:	2b00      	cmp	r3, #0
    6d78:	d100      	bne.n	6d7c <usart_init+0x310>
    6d7a:	e71d      	b.n	6bb8 <usart_init+0x14c>
    6d7c:	2380      	movs	r3, #128	; 0x80
    6d7e:	055b      	lsls	r3, r3, #21
    6d80:	459a      	cmp	sl, r3
    6d82:	d100      	bne.n	6d86 <usart_init+0x31a>
    6d84:	e701      	b.n	6b8a <usart_init+0x11e>
    6d86:	e73e      	b.n	6c06 <usart_init+0x19a>
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
	_sercom_instances[instance_index] = module;
#endif

	return status_code;
}
    6d88:	b011      	add	sp, #68	; 0x44
    6d8a:	bc3c      	pop	{r2, r3, r4, r5}
    6d8c:	4690      	mov	r8, r2
    6d8e:	4699      	mov	r9, r3
    6d90:	46a2      	mov	sl, r4
    6d92:	46ab      	mov	fp, r5
    6d94:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6d96:	46c0      	nop			; (mov r8, r8)
    6d98:	00006965 	.word	0x00006965
    6d9c:	40000400 	.word	0x40000400
    6da0:	00007715 	.word	0x00007715
    6da4:	000076a5 	.word	0x000076a5
    6da8:	00006795 	.word	0x00006795
    6dac:	00007739 	.word	0x00007739
    6db0:	000065a5 	.word	0x000065a5
    6db4:	000065cd 	.word	0x000065cd
    6db8:	41002000 	.word	0x41002000
    6dbc:	000067e1 	.word	0x000067e1
    6dc0:	00007811 	.word	0x00007811
    6dc4:	00006e75 	.word	0x00006e75
    6dc8:	000069a5 	.word	0x000069a5
    6dcc:	20001344 	.word	0x20001344

00006dd0 <usart_write_wait>:

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
    6dd0:	79c2      	ldrb	r2, [r0, #7]
		return STATUS_ERR_DENIED;
    6dd2:	231c      	movs	r3, #28

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
    6dd4:	2a00      	cmp	r2, #0
    6dd6:	d00e      	beq.n	6df6 <usart_write_wait+0x26>
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_tx_buffer_length > 0) {
    6dd8:	8dc2      	ldrh	r2, [r0, #46]	; 0x2e
    6dda:	b292      	uxth	r2, r2
		return STATUS_BUSY;
    6ddc:	3b17      	subs	r3, #23
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_tx_buffer_length > 0) {
    6dde:	2a00      	cmp	r2, #0
    6de0:	d109      	bne.n	6df6 <usart_write_wait+0x26>
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    6de2:	6803      	ldr	r3, [r0, #0]
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    6de4:	69da      	ldr	r2, [r3, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    6de6:	2a00      	cmp	r2, #0
    6de8:	d1fc      	bne.n	6de4 <usart_write_wait+0x14>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write data to USART module */
	usart_hw->DATA.reg = tx_data;
    6dea:	8519      	strh	r1, [r3, #40]	; 0x28

	while (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_TXC)) {
    6dec:	2102      	movs	r1, #2
    6dee:	7e1a      	ldrb	r2, [r3, #24]
    6df0:	420a      	tst	r2, r1
    6df2:	d0fc      	beq.n	6dee <usart_write_wait+0x1e>
		/* Wait until data is sent */
	}

	return STATUS_OK;
    6df4:	2300      	movs	r3, #0
}
    6df6:	0018      	movs	r0, r3
    6df8:	4770      	bx	lr
    6dfa:	46c0      	nop			; (mov r8, r8)

00006dfc <usart_read_wait>:

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
    6dfc:	7982      	ldrb	r2, [r0, #6]
		return STATUS_ERR_DENIED;
    6dfe:	231c      	movs	r3, #28

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
    6e00:	2a00      	cmp	r2, #0
    6e02:	d034      	beq.n	6e6e <usart_read_wait+0x72>
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_rx_buffer_length > 0) {
    6e04:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
    6e06:	b292      	uxth	r2, r2
		return STATUS_BUSY;
    6e08:	3b17      	subs	r3, #23
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_rx_buffer_length > 0) {
    6e0a:	2a00      	cmp	r2, #0
    6e0c:	d12f      	bne.n	6e6e <usart_read_wait+0x72>

	/* Error variable */
	uint8_t error_code;

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    6e0e:	6802      	ldr	r2, [r0, #0]
		return STATUS_BUSY;
	}
#endif

	/* Check if USART has new data */
	if (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_RXC)) {
    6e10:	7e10      	ldrb	r0, [r2, #24]
    6e12:	0740      	lsls	r0, r0, #29
    6e14:	d52b      	bpl.n	6e6e <usart_read_wait+0x72>
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    6e16:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    6e18:	2b00      	cmp	r3, #0
    6e1a:	d1fc      	bne.n	6e16 <usart_read_wait+0x1a>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Read out the status code and mask away all but the 3 LSBs*/
	error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    6e1c:	8b53      	ldrh	r3, [r2, #26]
    6e1e:	b2db      	uxtb	r3, r3

	/* Check if an error has occurred during the receiving */
	if (error_code) {
    6e20:	0698      	lsls	r0, r3, #26
    6e22:	d021      	beq.n	6e68 <usart_read_wait+0x6c>
		/* Check which error occurred */
		if (error_code & SERCOM_USART_STATUS_FERR) {
    6e24:	0798      	lsls	r0, r3, #30
    6e26:	d503      	bpl.n	6e30 <usart_read_wait+0x34>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_FERR;
    6e28:	2302      	movs	r3, #2
    6e2a:	8353      	strh	r3, [r2, #26]

			return STATUS_ERR_BAD_FORMAT;
    6e2c:	3318      	adds	r3, #24
    6e2e:	e01e      	b.n	6e6e <usart_read_wait+0x72>
		} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
    6e30:	0758      	lsls	r0, r3, #29
    6e32:	d503      	bpl.n	6e3c <usart_read_wait+0x40>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_BUFOVF;
    6e34:	2304      	movs	r3, #4
    6e36:	8353      	strh	r3, [r2, #26]

			return STATUS_ERR_OVERFLOW;
    6e38:	331a      	adds	r3, #26
    6e3a:	e018      	b.n	6e6e <usart_read_wait+0x72>
		} else if (error_code & SERCOM_USART_STATUS_PERR) {
    6e3c:	07d8      	lsls	r0, r3, #31
    6e3e:	d503      	bpl.n	6e48 <usart_read_wait+0x4c>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_PERR;
    6e40:	2301      	movs	r3, #1
    6e42:	8353      	strh	r3, [r2, #26]

			return STATUS_ERR_BAD_DATA;
    6e44:	3312      	adds	r3, #18
    6e46:	e012      	b.n	6e6e <usart_read_wait+0x72>
		}
#ifdef FEATURE_USART_LIN_SLAVE
		else if (error_code & SERCOM_USART_STATUS_ISF) {
    6e48:	06d8      	lsls	r0, r3, #27
    6e4a:	d505      	bpl.n	6e58 <usart_read_wait+0x5c>
			/* Clear flag by writing 1 to it  and
			 *  return with an error code */
			usart_hw->STATUS.reg |= SERCOM_USART_STATUS_ISF;
    6e4c:	8b51      	ldrh	r1, [r2, #26]
    6e4e:	2310      	movs	r3, #16
    6e50:	430b      	orrs	r3, r1
    6e52:	8353      	strh	r3, [r2, #26]

			return STATUS_ERR_PROTOCOL;
    6e54:	2342      	movs	r3, #66	; 0x42
    6e56:	e00a      	b.n	6e6e <usart_read_wait+0x72>
		}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
		else if (error_code & SERCOM_USART_STATUS_COLL) {
    6e58:	069b      	lsls	r3, r3, #26
    6e5a:	d505      	bpl.n	6e68 <usart_read_wait+0x6c>
			/* Clear flag by writing 1 to it
			 *  return with an error code */
			usart_hw->STATUS.reg |= SERCOM_USART_STATUS_COLL;
    6e5c:	8b51      	ldrh	r1, [r2, #26]
    6e5e:	2320      	movs	r3, #32
    6e60:	430b      	orrs	r3, r1
    6e62:	8353      	strh	r3, [r2, #26]

			return STATUS_ERR_PACKET_COLLISION;
    6e64:	2341      	movs	r3, #65	; 0x41
    6e66:	e002      	b.n	6e6e <usart_read_wait+0x72>
		}
#endif
	}

	/* Read data from USART module */
	*rx_data = usart_hw->DATA.reg;
    6e68:	8d13      	ldrh	r3, [r2, #40]	; 0x28
    6e6a:	800b      	strh	r3, [r1, #0]

	return STATUS_OK;
    6e6c:	2300      	movs	r3, #0
}
    6e6e:	0018      	movs	r0, r3
    6e70:	4770      	bx	lr
    6e72:	46c0      	nop			; (mov r8, r8)

00006e74 <_usart_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _usart_interrupt_handler(
		uint8_t instance)
{
    6e74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint16_t callback_status;
	uint8_t error_code;


	/* Get device instance from the look-up table */
	struct usart_module *module
    6e76:	0080      	lsls	r0, r0, #2
    6e78:	4b65      	ldr	r3, [pc, #404]	; (7010 <_usart_interrupt_handler+0x19c>)
    6e7a:	58c5      	ldr	r5, [r0, r3]
		= (struct usart_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomUsart *const usart_hw
		= &(module->hw->USART);
    6e7c:	682c      	ldr	r4, [r5, #0]
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    6e7e:	69e3      	ldr	r3, [r4, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    6e80:	2b00      	cmp	r3, #0
    6e82:	d1fc      	bne.n	6e7e <_usart_interrupt_handler+0xa>

	/* Wait for the synchronization to complete */
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
    6e84:	7e23      	ldrb	r3, [r4, #24]
	interrupt_status &= usart_hw->INTENSET.reg;
    6e86:	7da6      	ldrb	r6, [r4, #22]
    6e88:	401e      	ands	r6, r3
	callback_status = module->callback_reg_mask &
    6e8a:	2330      	movs	r3, #48	; 0x30
    6e8c:	5ceb      	ldrb	r3, [r5, r3]
    6e8e:	2231      	movs	r2, #49	; 0x31
    6e90:	5caf      	ldrb	r7, [r5, r2]
    6e92:	401f      	ands	r7, r3
			module->callback_enable_mask;

	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
    6e94:	07f3      	lsls	r3, r6, #31
    6e96:	d522      	bpl.n	6ede <_usart_interrupt_handler+0x6a>
		if (module->remaining_tx_buffer_length) {
    6e98:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
    6e9a:	b29b      	uxth	r3, r3
    6e9c:	2b00      	cmp	r3, #0
    6e9e:	d01c      	beq.n	6eda <_usart_interrupt_handler+0x66>
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    6ea0:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    6ea2:	7813      	ldrb	r3, [r2, #0]
    6ea4:	b2db      	uxtb	r3, r3
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;
    6ea6:	1c51      	adds	r1, r2, #1
    6ea8:	62a9      	str	r1, [r5, #40]	; 0x28

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    6eaa:	7969      	ldrb	r1, [r5, #5]
    6eac:	2901      	cmp	r1, #1
    6eae:	d001      	beq.n	6eb4 <_usart_interrupt_handler+0x40>
	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
		if (module->remaining_tx_buffer_length) {
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    6eb0:	b29b      	uxth	r3, r3
    6eb2:	e004      	b.n	6ebe <_usart_interrupt_handler+0x4a>
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
    6eb4:	7851      	ldrb	r1, [r2, #1]
    6eb6:	0209      	lsls	r1, r1, #8
    6eb8:	430b      	orrs	r3, r1
				/* Increment 8-bit pointer */
				(module->tx_buffer_ptr)++;
    6eba:	3202      	adds	r2, #2
    6ebc:	62aa      	str	r2, [r5, #40]	; 0x28
			}
			/* Write the data to send */
			usart_hw->DATA.reg = (data_to_send & SERCOM_USART_DATA_MASK);
    6ebe:	05db      	lsls	r3, r3, #23
    6ec0:	0ddb      	lsrs	r3, r3, #23
    6ec2:	8523      	strh	r3, [r4, #40]	; 0x28

			if (--(module->remaining_tx_buffer_length) == 0) {
    6ec4:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
    6ec6:	3b01      	subs	r3, #1
    6ec8:	b29b      	uxth	r3, r3
    6eca:	85eb      	strh	r3, [r5, #46]	; 0x2e
    6ecc:	2b00      	cmp	r3, #0
    6ece:	d106      	bne.n	6ede <_usart_interrupt_handler+0x6a>
				/* Disable the Data Register Empty Interrupt */
				usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    6ed0:	3301      	adds	r3, #1
    6ed2:	7523      	strb	r3, [r4, #20]
				/* Enable Transmission Complete interrupt */
				usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_TXC;
    6ed4:	3301      	adds	r3, #1
    6ed6:	75a3      	strb	r3, [r4, #22]
    6ed8:	e001      	b.n	6ede <_usart_interrupt_handler+0x6a>

			}
		} else {
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    6eda:	2301      	movs	r3, #1
    6edc:	7523      	strb	r3, [r4, #20]

	/* Check if the Transmission Complete interrupt has occurred and
	 * that the transmit buffer is empty */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_TXC) {
    6ede:	07b3      	lsls	r3, r6, #30
    6ee0:	d509      	bpl.n	6ef6 <_usart_interrupt_handler+0x82>

		/* Disable TX Complete Interrupt, and set STATUS_OK */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_TXC;
    6ee2:	2302      	movs	r3, #2
    6ee4:	7523      	strb	r3, [r4, #20]
		module->tx_status = STATUS_OK;
    6ee6:	2200      	movs	r2, #0
    6ee8:	3331      	adds	r3, #49	; 0x31
    6eea:	54ea      	strb	r2, [r5, r3]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BUFFER_TRANSMITTED)) {
    6eec:	07fb      	lsls	r3, r7, #31
    6eee:	d502      	bpl.n	6ef6 <_usart_interrupt_handler+0x82>
			(*(module->callback[USART_CALLBACK_BUFFER_TRANSMITTED]))(module);
    6ef0:	0028      	movs	r0, r5
    6ef2:	68eb      	ldr	r3, [r5, #12]
    6ef4:	4798      	blx	r3

	/* Check if the Receive Complete interrupt has occurred, and that
	 * there's more data to receive */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {
    6ef6:	0773      	lsls	r3, r6, #29
    6ef8:	d56a      	bpl.n	6fd0 <_usart_interrupt_handler+0x15c>

		if (module->remaining_rx_buffer_length) {
    6efa:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    6efc:	b29b      	uxth	r3, r3
    6efe:	2b00      	cmp	r3, #0
    6f00:	d064      	beq.n	6fcc <_usart_interrupt_handler+0x158>
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    6f02:	8b63      	ldrh	r3, [r4, #26]
    6f04:	b2db      	uxtb	r3, r3
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
    6f06:	071a      	lsls	r2, r3, #28
    6f08:	d402      	bmi.n	6f10 <_usart_interrupt_handler+0x9c>

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {

		if (module->remaining_rx_buffer_length) {
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    6f0a:	223f      	movs	r2, #63	; 0x3f
    6f0c:	4013      	ands	r3, r2
    6f0e:	e001      	b.n	6f14 <_usart_interrupt_handler+0xa0>
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
				error_code &= ~SERCOM_USART_STATUS_CTS;
    6f10:	2237      	movs	r2, #55	; 0x37
    6f12:	4013      	ands	r3, r2
			if(error_code & SERCOM_USART_STATUS_TXE) {
				error_code &= ~SERCOM_USART_STATUS_TXE;
			}
#endif
			/* Check if an error has occurred during the receiving */
			if (error_code) {
    6f14:	2b00      	cmp	r3, #0
    6f16:	d037      	beq.n	6f88 <_usart_interrupt_handler+0x114>
				/* Check which error occurred */
				if (error_code & SERCOM_USART_STATUS_FERR) {
    6f18:	079a      	lsls	r2, r3, #30
    6f1a:	d507      	bpl.n	6f2c <_usart_interrupt_handler+0xb8>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_FORMAT;
    6f1c:	221a      	movs	r2, #26
    6f1e:	2332      	movs	r3, #50	; 0x32
    6f20:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_FERR;
    6f22:	8b62      	ldrh	r2, [r4, #26]
    6f24:	3b30      	subs	r3, #48	; 0x30
    6f26:	4313      	orrs	r3, r2
    6f28:	8363      	strh	r3, [r4, #26]
    6f2a:	e027      	b.n	6f7c <_usart_interrupt_handler+0x108>
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
    6f2c:	075a      	lsls	r2, r3, #29
    6f2e:	d507      	bpl.n	6f40 <_usart_interrupt_handler+0xcc>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_OVERFLOW;
    6f30:	221e      	movs	r2, #30
    6f32:	2332      	movs	r3, #50	; 0x32
    6f34:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_BUFOVF;
    6f36:	8b62      	ldrh	r2, [r4, #26]
    6f38:	3b2e      	subs	r3, #46	; 0x2e
    6f3a:	4313      	orrs	r3, r2
    6f3c:	8363      	strh	r3, [r4, #26]
    6f3e:	e01d      	b.n	6f7c <_usart_interrupt_handler+0x108>
				} else if (error_code & SERCOM_USART_STATUS_PERR) {
    6f40:	07da      	lsls	r2, r3, #31
    6f42:	d507      	bpl.n	6f54 <_usart_interrupt_handler+0xe0>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_DATA;
    6f44:	2213      	movs	r2, #19
    6f46:	2332      	movs	r3, #50	; 0x32
    6f48:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_PERR;
    6f4a:	8b62      	ldrh	r2, [r4, #26]
    6f4c:	3b31      	subs	r3, #49	; 0x31
    6f4e:	4313      	orrs	r3, r2
    6f50:	8363      	strh	r3, [r4, #26]
    6f52:	e013      	b.n	6f7c <_usart_interrupt_handler+0x108>
				}
#ifdef FEATURE_USART_LIN_SLAVE
				else if (error_code & SERCOM_USART_STATUS_ISF) {
    6f54:	06da      	lsls	r2, r3, #27
    6f56:	d507      	bpl.n	6f68 <_usart_interrupt_handler+0xf4>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PROTOCOL;
    6f58:	2242      	movs	r2, #66	; 0x42
    6f5a:	2332      	movs	r3, #50	; 0x32
    6f5c:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_ISF;
    6f5e:	8b62      	ldrh	r2, [r4, #26]
    6f60:	3b22      	subs	r3, #34	; 0x22
    6f62:	4313      	orrs	r3, r2
    6f64:	8363      	strh	r3, [r4, #26]
    6f66:	e009      	b.n	6f7c <_usart_interrupt_handler+0x108>
				}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
				else if (error_code & SERCOM_USART_STATUS_COLL) {
    6f68:	2220      	movs	r2, #32
    6f6a:	421a      	tst	r2, r3
    6f6c:	d006      	beq.n	6f7c <_usart_interrupt_handler+0x108>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PACKET_COLLISION;
    6f6e:	3221      	adds	r2, #33	; 0x21
    6f70:	2332      	movs	r3, #50	; 0x32
    6f72:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_COLL;
    6f74:	8b62      	ldrh	r2, [r4, #26]
    6f76:	3b12      	subs	r3, #18
    6f78:	4313      	orrs	r3, r2
    6f7a:	8363      	strh	r3, [r4, #26]
				}
#endif

				/* Run callback if registered and enabled */
				if (callback_status
    6f7c:	077b      	lsls	r3, r7, #29
    6f7e:	d527      	bpl.n	6fd0 <_usart_interrupt_handler+0x15c>
						& (1 << USART_CALLBACK_ERROR)) {
					(*(module->callback[USART_CALLBACK_ERROR]))(module);
    6f80:	0028      	movs	r0, r5
    6f82:	696b      	ldr	r3, [r5, #20]
    6f84:	4798      	blx	r3
    6f86:	e023      	b.n	6fd0 <_usart_interrupt_handler+0x15c>

			} else {

				/* Read current packet from DATA register,
				 * increment buffer pointer and decrement buffer length */
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
    6f88:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    6f8a:	05db      	lsls	r3, r3, #23
    6f8c:	0ddb      	lsrs	r3, r3, #23

				/* Read value will be at least 8-bits long */
				*(module->rx_buffer_ptr) = received_data;
    6f8e:	b2da      	uxtb	r2, r3
    6f90:	6a69      	ldr	r1, [r5, #36]	; 0x24
    6f92:	700a      	strb	r2, [r1, #0]
				/* Increment 8-bit pointer */
				module->rx_buffer_ptr += 1;
    6f94:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    6f96:	1c51      	adds	r1, r2, #1
    6f98:	6269      	str	r1, [r5, #36]	; 0x24

				if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    6f9a:	7969      	ldrb	r1, [r5, #5]
    6f9c:	2901      	cmp	r1, #1
    6f9e:	d104      	bne.n	6faa <_usart_interrupt_handler+0x136>
					/* 9-bit data, write next received byte to the buffer */
					*(module->rx_buffer_ptr) = (received_data >> 8);
    6fa0:	0a1b      	lsrs	r3, r3, #8
    6fa2:	7053      	strb	r3, [r2, #1]
					/* Increment 8-bit pointer */
					module->rx_buffer_ptr += 1;
    6fa4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    6fa6:	3301      	adds	r3, #1
    6fa8:	626b      	str	r3, [r5, #36]	; 0x24
				}

				/* Check if the last character have been received */
				if(--(module->remaining_rx_buffer_length) == 0) {
    6faa:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    6fac:	3b01      	subs	r3, #1
    6fae:	b29b      	uxth	r3, r3
    6fb0:	85ab      	strh	r3, [r5, #44]	; 0x2c
    6fb2:	2b00      	cmp	r3, #0
    6fb4:	d10c      	bne.n	6fd0 <_usart_interrupt_handler+0x15c>
					/* Disable RX Complete Interrupt,
					 * and set STATUS_OK */
					usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    6fb6:	3304      	adds	r3, #4
    6fb8:	7523      	strb	r3, [r4, #20]
					module->rx_status = STATUS_OK;
    6fba:	2200      	movs	r2, #0
    6fbc:	332e      	adds	r3, #46	; 0x2e
    6fbe:	54ea      	strb	r2, [r5, r3]

					/* Run callback if registered and enabled */
					if (callback_status
    6fc0:	07bb      	lsls	r3, r7, #30
    6fc2:	d505      	bpl.n	6fd0 <_usart_interrupt_handler+0x15c>
							& (1 << USART_CALLBACK_BUFFER_RECEIVED)) {
						(*(module->callback[USART_CALLBACK_BUFFER_RECEIVED]))(module);
    6fc4:	0028      	movs	r0, r5
    6fc6:	692b      	ldr	r3, [r5, #16]
    6fc8:	4798      	blx	r3
    6fca:	e001      	b.n	6fd0 <_usart_interrupt_handler+0x15c>
					}
				}
			}
		} else {
			/* This should not happen. Disable Receive Complete interrupt. */
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    6fcc:	2304      	movs	r3, #4
    6fce:	7523      	strb	r3, [r4, #20]
		}
	}

#ifdef FEATURE_USART_HARDWARE_FLOW_CONTROL
	if (interrupt_status & SERCOM_USART_INTFLAG_CTSIC) {
    6fd0:	06f3      	lsls	r3, r6, #27
    6fd2:	d507      	bpl.n	6fe4 <_usart_interrupt_handler+0x170>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_CTSIC;
    6fd4:	2310      	movs	r3, #16
    6fd6:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_CTSIC;
    6fd8:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_CTS_INPUT_CHANGE)) {
    6fda:	06fb      	lsls	r3, r7, #27
    6fdc:	d502      	bpl.n	6fe4 <_usart_interrupt_handler+0x170>
			(*(module->callback[USART_CALLBACK_CTS_INPUT_CHANGE]))(module);
    6fde:	0028      	movs	r0, r5
    6fe0:	69eb      	ldr	r3, [r5, #28]
    6fe2:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_LIN_SLAVE
	if (interrupt_status & SERCOM_USART_INTFLAG_RXBRK) {
    6fe4:	06b3      	lsls	r3, r6, #26
    6fe6:	d507      	bpl.n	6ff8 <_usart_interrupt_handler+0x184>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXBRK;
    6fe8:	2320      	movs	r3, #32
    6fea:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXBRK;
    6fec:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BREAK_RECEIVED)) {
    6fee:	073b      	lsls	r3, r7, #28
    6ff0:	d502      	bpl.n	6ff8 <_usart_interrupt_handler+0x184>
			(*(module->callback[USART_CALLBACK_BREAK_RECEIVED]))(module);
    6ff2:	0028      	movs	r0, r5
    6ff4:	69ab      	ldr	r3, [r5, #24]
    6ff6:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	if (interrupt_status & SERCOM_USART_INTFLAG_RXS) {
    6ff8:	0733      	lsls	r3, r6, #28
    6ffa:	d507      	bpl.n	700c <_usart_interrupt_handler+0x198>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXS;
    6ffc:	2308      	movs	r3, #8
    6ffe:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;
    7000:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_START_RECEIVED)) {
    7002:	06bb      	lsls	r3, r7, #26
    7004:	d502      	bpl.n	700c <_usart_interrupt_handler+0x198>
			(*(module->callback[USART_CALLBACK_START_RECEIVED]))(module);
    7006:	6a2b      	ldr	r3, [r5, #32]
    7008:	0028      	movs	r0, r5
    700a:	4798      	blx	r3
		}
	}
#endif
}
    700c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    700e:	46c0      	nop			; (mov r8, r8)
    7010:	20001344 	.word	0x20001344

00007014 <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
    7014:	b510      	push	{r4, lr}
	switch (clock_source) {
    7016:	2808      	cmp	r0, #8
    7018:	d803      	bhi.n	7022 <system_clock_source_get_hz+0xe>
    701a:	0080      	lsls	r0, r0, #2
    701c:	4b1c      	ldr	r3, [pc, #112]	; (7090 <system_clock_source_get_hz+0x7c>)
    701e:	581b      	ldr	r3, [r3, r0]
    7020:	469f      	mov	pc, r3
		}

		return _system_clock_inst.dpll.frequency;

	default:
		return 0;
    7022:	2000      	movs	r0, #0
    7024:	e032      	b.n	708c <system_clock_source_get_hz+0x78>
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;
    7026:	4b1b      	ldr	r3, [pc, #108]	; (7094 <system_clock_source_get_hz+0x80>)
    7028:	6918      	ldr	r0, [r3, #16]
    702a:	e02f      	b.n	708c <system_clock_source_get_hz+0x78>

	case SYSTEM_CLOCK_SOURCE_OSC16M:
		return (OSCCTRL->OSC16MCTRL.bit.FSEL+1)*4000000UL;
    702c:	4b1a      	ldr	r3, [pc, #104]	; (7098 <system_clock_source_get_hz+0x84>)
    702e:	7d18      	ldrb	r0, [r3, #20]
    7030:	0700      	lsls	r0, r0, #28
    7032:	0f80      	lsrs	r0, r0, #30
    7034:	3001      	adds	r0, #1
    7036:	4b19      	ldr	r3, [pc, #100]	; (709c <system_clock_source_get_hz+0x88>)
    7038:	4358      	muls	r0, r3
    703a:	e027      	b.n	708c <system_clock_source_get_hz+0x78>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		return 32768UL;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		return _system_clock_inst.xosc32k.frequency;
    703c:	4b15      	ldr	r3, [pc, #84]	; (7094 <system_clock_source_get_hz+0x80>)
    703e:	6958      	ldr	r0, [r3, #20]
    7040:	e024      	b.n	708c <system_clock_source_get_hz+0x78>

	case SYSTEM_CLOCK_SOURCE_DFLL:

		/* Check if the DFLL has been configured */
		if (!(_system_clock_inst.dfll.control & OSCCTRL_DFLLCTRL_ENABLE))
    7042:	4b14      	ldr	r3, [pc, #80]	; (7094 <system_clock_source_get_hz+0x80>)
    7044:	681b      	ldr	r3, [r3, #0]
    7046:	2002      	movs	r0, #2
    7048:	4018      	ands	r0, r3
    704a:	d01f      	beq.n	708c <system_clock_source_get_hz+0x78>
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(OSCCTRL->STATUS.reg & OSCCTRL_STATUS_DFLLRDY)) {
    704c:	4912      	ldr	r1, [pc, #72]	; (7098 <system_clock_source_get_hz+0x84>)
    704e:	2280      	movs	r2, #128	; 0x80
    7050:	0052      	lsls	r2, r2, #1
    7052:	68cb      	ldr	r3, [r1, #12]
    7054:	4213      	tst	r3, r2
    7056:	d0fc      	beq.n	7052 <system_clock_source_get_hz+0x3e>

		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & OSCCTRL_DFLLCTRL_MODE) {
    7058:	4b0e      	ldr	r3, [pc, #56]	; (7094 <system_clock_source_get_hz+0x80>)
    705a:	681b      	ldr	r3, [r3, #0]
    705c:	075b      	lsls	r3, r3, #29
    705e:	d514      	bpl.n	708a <system_clock_source_get_hz+0x76>
			return system_gclk_chan_get_hz(OSCCTRL_GCLK_ID_DFLL48) *
    7060:	2000      	movs	r0, #0
    7062:	4b0f      	ldr	r3, [pc, #60]	; (70a0 <system_clock_source_get_hz+0x8c>)
    7064:	4798      	blx	r3
					(_system_clock_inst.dfll.mul & 0xffff);
    7066:	4b0b      	ldr	r3, [pc, #44]	; (7094 <system_clock_source_get_hz+0x80>)
    7068:	689b      	ldr	r3, [r3, #8]
		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & OSCCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(OSCCTRL_GCLK_ID_DFLL48) *
    706a:	041b      	lsls	r3, r3, #16
    706c:	0c1b      	lsrs	r3, r3, #16
    706e:	4358      	muls	r0, r3
    7070:	e00c      	b.n	708c <system_clock_source_get_hz+0x78>
		}

		return 48000000UL;

	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(OSCCTRL->DPLLCTRLA.reg & OSCCTRL_DPLLCTRLA_ENABLE)) {
    7072:	2328      	movs	r3, #40	; 0x28
    7074:	4a08      	ldr	r2, [pc, #32]	; (7098 <system_clock_source_get_hz+0x84>)
    7076:	5cd3      	ldrb	r3, [r2, r3]
			return 0;
    7078:	2000      	movs	r0, #0
		}

		return 48000000UL;

	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(OSCCTRL->DPLLCTRLA.reg & OSCCTRL_DPLLCTRLA_ENABLE)) {
    707a:	079b      	lsls	r3, r3, #30
    707c:	d506      	bpl.n	708c <system_clock_source_get_hz+0x78>
			return 0;
		}

		return _system_clock_inst.dpll.frequency;
    707e:	4b05      	ldr	r3, [pc, #20]	; (7094 <system_clock_source_get_hz+0x80>)
    7080:	68d8      	ldr	r0, [r3, #12]
    7082:	e003      	b.n	708c <system_clock_source_get_hz+0x78>

	case SYSTEM_CLOCK_SOURCE_OSC16M:
		return (OSCCTRL->OSC16MCTRL.bit.FSEL+1)*4000000UL;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		return 32768UL;
    7084:	2080      	movs	r0, #128	; 0x80
    7086:	0200      	lsls	r0, r0, #8
    7088:	e000      	b.n	708c <system_clock_source_get_hz+0x78>
		if (_system_clock_inst.dfll.control & OSCCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(OSCCTRL_GCLK_ID_DFLL48) *
					(_system_clock_inst.dfll.mul & 0xffff);
		}

		return 48000000UL;
    708a:	4806      	ldr	r0, [pc, #24]	; (70a4 <system_clock_source_get_hz+0x90>)
		return _system_clock_inst.dpll.frequency;

	default:
		return 0;
	}
}
    708c:	bd10      	pop	{r4, pc}
    708e:	46c0      	nop			; (mov r8, r8)
    7090:	00013338 	.word	0x00013338
    7094:	200003b0 	.word	0x200003b0
    7098:	40000c00 	.word	0x40000c00
    709c:	003d0900 	.word	0x003d0900
    70a0:	00007739 	.word	0x00007739
    70a4:	02dc6c00 	.word	0x02dc6c00

000070a8 <system_clock_source_osc16m_set_config>:
 *
 * \param[in] config  OSC16M configuration structure containing the new config
 */
void system_clock_source_osc16m_set_config(
		struct system_clock_source_osc16m_config *const config)
{
    70a8:	b530      	push	{r4, r5, lr}
	OSCCTRL_OSC16MCTRL_Type temp = OSCCTRL->OSC16MCTRL;
    70aa:	4c0c      	ldr	r4, [pc, #48]	; (70dc <system_clock_source_osc16m_set_config+0x34>)
    70ac:	7d23      	ldrb	r3, [r4, #20]

	/* Use temporary struct to reduce register access */
	temp.bit.FSEL    = config->fsel;
	temp.bit.ONDEMAND = config->on_demand;
    70ae:	7885      	ldrb	r5, [r0, #2]
	temp.bit.RUNSTDBY = config->run_in_standby;
    70b0:	7841      	ldrb	r1, [r0, #1]

	OSCCTRL->OSC16MCTRL = temp;
    70b2:	7800      	ldrb	r0, [r0, #0]
    70b4:	2203      	movs	r2, #3
    70b6:	4010      	ands	r0, r2
    70b8:	0080      	lsls	r0, r0, #2
    70ba:	3209      	adds	r2, #9
    70bc:	4393      	bics	r3, r2
    70be:	4303      	orrs	r3, r0
    70c0:	3a0b      	subs	r2, #11
    70c2:	4011      	ands	r1, r2
    70c4:	0189      	lsls	r1, r1, #6
    70c6:	323f      	adds	r2, #63	; 0x3f
    70c8:	4393      	bics	r3, r2
    70ca:	430b      	orrs	r3, r1
    70cc:	001a      	movs	r2, r3
    70ce:	01e9      	lsls	r1, r5, #7
    70d0:	237f      	movs	r3, #127	; 0x7f
    70d2:	4013      	ands	r3, r2
    70d4:	430b      	orrs	r3, r1
    70d6:	7523      	strb	r3, [r4, #20]
}
    70d8:	bd30      	pop	{r4, r5, pc}
    70da:	46c0      	nop			; (mov r8, r8)
    70dc:	40000c00 	.word	0x40000c00

000070e0 <system_clock_source_xosc32k_set_config>:
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
    70e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    70e2:	465f      	mov	r7, fp
    70e4:	4656      	mov	r6, sl
    70e6:	464d      	mov	r5, r9
    70e8:	4644      	mov	r4, r8
    70ea:	b4f0      	push	{r4, r5, r6, r7}
	OSC32KCTRL_XOSC32K_Type temp = OSC32KCTRL->XOSC32K;
    70ec:	4e25      	ldr	r6, [pc, #148]	; (7184 <system_clock_source_xosc32k_set_config+0xa4>)
    70ee:	6973      	ldr	r3, [r6, #20]
    70f0:	469c      	mov	ip, r3

	temp.bit.STARTUP = config->startup_time;
    70f2:	7845      	ldrb	r5, [r0, #1]

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
    70f4:	7803      	ldrb	r3, [r0, #0]
    70f6:	425a      	negs	r2, r3
    70f8:	415a      	adcs	r2, r3
    70fa:	4690      	mov	r8, r2
		temp.bit.XTALEN = 1;
	} else {
		temp.bit.XTALEN = 0;
	}

	temp.bit.EN1K = config->enable_1khz_output;
    70fc:	7883      	ldrb	r3, [r0, #2]
    70fe:	469a      	mov	sl, r3
	temp.bit.EN32K = config->enable_32khz_output;
    7100:	78c3      	ldrb	r3, [r0, #3]

	temp.bit.ONDEMAND = config->on_demand;
    7102:	7a47      	ldrb	r7, [r0, #9]
	temp.bit.RUNSTDBY = config->run_in_standby;
    7104:	7a02      	ldrb	r2, [r0, #8]
    7106:	4693      	mov	fp, r2
	temp.bit.WRTLOCK  = config->write_once;
    7108:	7a84      	ldrb	r4, [r0, #10]

	/* Cache the new frequency in case the user needs to check the current
	 * operating frequency later */
	_system_clock_inst.xosc32k.frequency = config->frequency;
    710a:	6842      	ldr	r2, [r0, #4]
    710c:	481e      	ldr	r0, [pc, #120]	; (7188 <system_clock_source_xosc32k_set_config+0xa8>)
    710e:	6142      	str	r2, [r0, #20]

	OSC32KCTRL->XOSC32K = temp;
    7110:	2001      	movs	r0, #1
    7112:	4642      	mov	r2, r8
    7114:	0092      	lsls	r2, r2, #2
    7116:	4690      	mov	r8, r2
    7118:	2204      	movs	r2, #4
    711a:	4691      	mov	r9, r2
    711c:	4662      	mov	r2, ip
    711e:	4649      	mov	r1, r9
    7120:	438a      	bics	r2, r1
    7122:	4694      	mov	ip, r2
    7124:	4642      	mov	r2, r8
    7126:	4661      	mov	r1, ip
    7128:	430a      	orrs	r2, r1
    712a:	4694      	mov	ip, r2
    712c:	4003      	ands	r3, r0
    712e:	00db      	lsls	r3, r3, #3
    7130:	2208      	movs	r2, #8
    7132:	4690      	mov	r8, r2
    7134:	4662      	mov	r2, ip
    7136:	4641      	mov	r1, r8
    7138:	438a      	bics	r2, r1
    713a:	4313      	orrs	r3, r2
    713c:	4651      	mov	r1, sl
    713e:	4001      	ands	r1, r0
    7140:	0109      	lsls	r1, r1, #4
    7142:	2210      	movs	r2, #16
    7144:	4393      	bics	r3, r2
    7146:	430b      	orrs	r3, r1
    7148:	465a      	mov	r2, fp
    714a:	4002      	ands	r2, r0
    714c:	0192      	lsls	r2, r2, #6
    714e:	2140      	movs	r1, #64	; 0x40
    7150:	438b      	bics	r3, r1
    7152:	4313      	orrs	r3, r2
    7154:	4007      	ands	r7, r0
    7156:	01ff      	lsls	r7, r7, #7
    7158:	2280      	movs	r2, #128	; 0x80
    715a:	4393      	bics	r3, r2
    715c:	433b      	orrs	r3, r7
    715e:	3a79      	subs	r2, #121	; 0x79
    7160:	4015      	ands	r5, r2
    7162:	022d      	lsls	r5, r5, #8
    7164:	4f09      	ldr	r7, [pc, #36]	; (718c <system_clock_source_xosc32k_set_config+0xac>)
    7166:	403b      	ands	r3, r7
    7168:	432b      	orrs	r3, r5
    716a:	4004      	ands	r4, r0
    716c:	0320      	lsls	r0, r4, #12
    716e:	4c08      	ldr	r4, [pc, #32]	; (7190 <system_clock_source_xosc32k_set_config+0xb0>)
    7170:	401c      	ands	r4, r3
    7172:	4304      	orrs	r4, r0
    7174:	6174      	str	r4, [r6, #20]
}
    7176:	bc3c      	pop	{r2, r3, r4, r5}
    7178:	4690      	mov	r8, r2
    717a:	4699      	mov	r9, r3
    717c:	46a2      	mov	sl, r4
    717e:	46ab      	mov	fp, r5
    7180:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7182:	46c0      	nop			; (mov r8, r8)
    7184:	40001000 	.word	0x40001000
    7188:	200003b0 	.word	0x200003b0
    718c:	fffff8ff 	.word	0xfffff8ff
    7190:	ffffefff 	.word	0xffffefff

00007194 <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
    7194:	b510      	push	{r4, lr}
	_system_clock_inst.dfll.val =
			OSCCTRL_DFLLVAL_COARSE(config->coarse_value) |
    7196:	7a83      	ldrb	r3, [r0, #10]
    7198:	069b      	lsls	r3, r3, #26
    719a:	0c1a      	lsrs	r2, r3, #16
    719c:	8983      	ldrh	r3, [r0, #12]
    719e:	059b      	lsls	r3, r3, #22
    71a0:	0d9b      	lsrs	r3, r3, #22
    71a2:	4313      	orrs	r3, r2
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
    71a4:	4c1a      	ldr	r4, [pc, #104]	; (7210 <system_clock_source_dfll_set_config+0x7c>)
    71a6:	6063      	str	r3, [r4, #4]
	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << OSCCTRL_DFLLCTRL_ONDEMAND_Pos) |
    71a8:	7a01      	ldrb	r1, [r0, #8]
    71aa:	7a43      	ldrb	r3, [r0, #9]
    71ac:	4319      	orrs	r1, r3
    71ae:	8883      	ldrh	r3, [r0, #4]
    71b0:	88c2      	ldrh	r2, [r0, #6]
    71b2:	4313      	orrs	r3, r2
    71b4:	430b      	orrs	r3, r1
    71b6:	7842      	ldrb	r2, [r0, #1]
    71b8:	01d2      	lsls	r2, r2, #7
    71ba:	4313      	orrs	r3, r2
    71bc:	7882      	ldrb	r2, [r0, #2]
    71be:	0192      	lsls	r2, r2, #6
    71c0:	4313      	orrs	r3, r2
{
	_system_clock_inst.dfll.val =
			OSCCTRL_DFLLVAL_COARSE(config->coarse_value) |
			OSCCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
    71c2:	6023      	str	r3, [r4, #0]
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << OSCCTRL_DFLLCTRL_ONDEMAND_Pos) |
			((uint32_t)config->run_in_stanby << OSCCTRL_DFLLCTRL_RUNSTDBY_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
    71c4:	7803      	ldrb	r3, [r0, #0]
    71c6:	2b04      	cmp	r3, #4
    71c8:	d10f      	bne.n	71ea <system_clock_source_dfll_set_config+0x56>

		_system_clock_inst.dfll.mul =
				OSCCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				OSCCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    71ca:	7b83      	ldrb	r3, [r0, #14]
    71cc:	069b      	lsls	r3, r3, #26
    71ce:	8a42      	ldrh	r2, [r0, #18]
    71d0:	4313      	orrs	r3, r2
    71d2:	0019      	movs	r1, r3
    71d4:	8a03      	ldrh	r3, [r0, #16]
    71d6:	041b      	lsls	r3, r3, #16
    71d8:	4a0e      	ldr	r2, [pc, #56]	; (7214 <system_clock_source_dfll_set_config+0x80>)
    71da:	4013      	ands	r3, r2
    71dc:	430b      	orrs	r3, r1
			((uint32_t)config->on_demand << OSCCTRL_DFLLCTRL_ONDEMAND_Pos) |
			((uint32_t)config->run_in_stanby << OSCCTRL_DFLLCTRL_RUNSTDBY_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
    71de:	60a3      	str	r3, [r4, #8]
				OSCCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				OSCCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				OSCCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
    71e0:	6821      	ldr	r1, [r4, #0]
    71e2:	2304      	movs	r3, #4
    71e4:	430b      	orrs	r3, r1
    71e6:	6023      	str	r3, [r4, #0]
    71e8:	e011      	b.n	720e <system_clock_source_dfll_set_config+0x7a>
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
    71ea:	2b20      	cmp	r3, #32
    71ec:	d10f      	bne.n	720e <system_clock_source_dfll_set_config+0x7a>

		_system_clock_inst.dfll.mul =
				OSCCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				OSCCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    71ee:	7b83      	ldrb	r3, [r0, #14]
    71f0:	069b      	lsls	r3, r3, #26
    71f2:	8a42      	ldrh	r2, [r0, #18]
    71f4:	4313      	orrs	r3, r2
    71f6:	0019      	movs	r1, r3
    71f8:	8a03      	ldrh	r3, [r0, #16]
    71fa:	041b      	lsls	r3, r3, #16
    71fc:	4a05      	ldr	r2, [pc, #20]	; (7214 <system_clock_source_dfll_set_config+0x80>)
    71fe:	4013      	ands	r3, r2
    7200:	430b      	orrs	r3, r1
		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
    7202:	4a03      	ldr	r2, [pc, #12]	; (7210 <system_clock_source_dfll_set_config+0x7c>)
    7204:	6093      	str	r3, [r2, #8]
				OSCCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				OSCCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				OSCCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the USB recovery mode */
		_system_clock_inst.dfll.control |= config->loop_mode |
    7206:	6813      	ldr	r3, [r2, #0]
    7208:	4903      	ldr	r1, [pc, #12]	; (7218 <system_clock_source_dfll_set_config+0x84>)
    720a:	430b      	orrs	r3, r1
    720c:	6013      	str	r3, [r2, #0]
				OSCCTRL_DFLLCTRL_MODE | OSCCTRL_DFLLCTRL_BPLCKC;
	}
}
    720e:	bd10      	pop	{r4, pc}
    7210:	200003b0 	.word	0x200003b0
    7214:	03ff0000 	.word	0x03ff0000
    7218:	00000424 	.word	0x00000424

0000721c <system_clock_source_enable>:
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
    721c:	2808      	cmp	r0, #8
    721e:	d803      	bhi.n	7228 <system_clock_source_enable+0xc>
    7220:	0080      	lsls	r0, r0, #2
    7222:	4b29      	ldr	r3, [pc, #164]	; (72c8 <system_clock_source_enable+0xac>)
    7224:	581b      	ldr	r3, [r3, r0]
    7226:	469f      	mov	pc, r3
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    7228:	2017      	movs	r0, #23
    722a:	e04b      	b.n	72c4 <system_clock_source_enable+0xa8>
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC16M:
		OSCCTRL->OSC16MCTRL.reg |= OSCCTRL_OSC16MCTRL_ENABLE;
    722c:	4a27      	ldr	r2, [pc, #156]	; (72cc <system_clock_source_enable+0xb0>)
    722e:	7d11      	ldrb	r1, [r2, #20]
    7230:	2302      	movs	r3, #2
    7232:	430b      	orrs	r3, r1
    7234:	7513      	strb	r3, [r2, #20]
		return STATUS_OK;
    7236:	2000      	movs	r0, #0
    7238:	e044      	b.n	72c4 <system_clock_source_enable+0xa8>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		OSC32KCTRL->OSC32K.reg |= OSC32KCTRL_OSC32K_ENABLE;
    723a:	4a25      	ldr	r2, [pc, #148]	; (72d0 <system_clock_source_enable+0xb4>)
    723c:	6991      	ldr	r1, [r2, #24]
    723e:	2302      	movs	r3, #2
    7240:	430b      	orrs	r3, r1
    7242:	6193      	str	r3, [r2, #24]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    7244:	2000      	movs	r0, #0
		OSCCTRL->OSC16MCTRL.reg |= OSCCTRL_OSC16MCTRL_ENABLE;
		return STATUS_OK;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		OSC32KCTRL->OSC32K.reg |= OSC32KCTRL_OSC32K_ENABLE;
		break;
    7246:	e03d      	b.n	72c4 <system_clock_source_enable+0xa8>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		OSCCTRL->XOSCCTRL.reg |= OSCCTRL_XOSCCTRL_ENABLE;
    7248:	4a20      	ldr	r2, [pc, #128]	; (72cc <system_clock_source_enable+0xb0>)
    724a:	8a11      	ldrh	r1, [r2, #16]
    724c:	2302      	movs	r3, #2
    724e:	430b      	orrs	r3, r1
    7250:	8213      	strh	r3, [r2, #16]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    7252:	2000      	movs	r0, #0
		OSC32KCTRL->OSC32K.reg |= OSC32KCTRL_OSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC:
		OSCCTRL->XOSCCTRL.reg |= OSCCTRL_XOSCCTRL_ENABLE;
		break;
    7254:	e036      	b.n	72c4 <system_clock_source_enable+0xa8>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		OSC32KCTRL->XOSC32K.reg |= OSC32KCTRL_XOSC32K_ENABLE;
    7256:	4a1e      	ldr	r2, [pc, #120]	; (72d0 <system_clock_source_enable+0xb4>)
    7258:	6951      	ldr	r1, [r2, #20]
    725a:	2302      	movs	r3, #2
    725c:	430b      	orrs	r3, r1
    725e:	6153      	str	r3, [r2, #20]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    7260:	2000      	movs	r0, #0
		OSCCTRL->XOSCCTRL.reg |= OSCCTRL_XOSCCTRL_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		OSC32KCTRL->XOSC32K.reg |= OSC32KCTRL_XOSC32K_ENABLE;
		break;
    7262:	e02f      	b.n	72c4 <system_clock_source_enable+0xa8>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= OSCCTRL_DFLLCTRL_ENABLE;
    7264:	491b      	ldr	r1, [pc, #108]	; (72d4 <system_clock_source_enable+0xb8>)
    7266:	680b      	ldr	r3, [r1, #0]
    7268:	2202      	movs	r2, #2
    726a:	4313      	orrs	r3, r2
    726c:	600b      	str	r3, [r1, #0]

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{

	/* Disable ONDEMAND mode while writing configurations */
	OSCCTRL->DFLLCTRL.reg = OSCCTRL_DFLLCTRL_ENABLE;
    726e:	4b17      	ldr	r3, [pc, #92]	; (72cc <system_clock_source_enable+0xb0>)
    7270:	831a      	strh	r2, [r3, #24]
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(OSCCTRL->STATUS.reg & OSCCTRL_STATUS_DFLLRDY)) {
    7272:	0019      	movs	r1, r3
    7274:	32fe      	adds	r2, #254	; 0xfe
    7276:	68cb      	ldr	r3, [r1, #12]
    7278:	4213      	tst	r3, r2
    727a:	d0fc      	beq.n	7276 <system_clock_source_enable+0x5a>

	/* Disable ONDEMAND mode while writing configurations */
	OSCCTRL->DFLLCTRL.reg = OSCCTRL_DFLLCTRL_ENABLE;
	_system_dfll_wait_for_sync();

	OSCCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    727c:	4a15      	ldr	r2, [pc, #84]	; (72d4 <system_clock_source_enable+0xb8>)
    727e:	6891      	ldr	r1, [r2, #8]
    7280:	4b12      	ldr	r3, [pc, #72]	; (72cc <system_clock_source_enable+0xb0>)
    7282:	6219      	str	r1, [r3, #32]
	OSCCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
    7284:	6852      	ldr	r2, [r2, #4]
    7286:	61da      	str	r2, [r3, #28]

	/* Write full configuration to DFLL control register */
	OSCCTRL->DFLLCTRL.reg = 0;
    7288:	2200      	movs	r2, #0
    728a:	831a      	strh	r2, [r3, #24]
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(OSCCTRL->STATUS.reg & OSCCTRL_STATUS_DFLLRDY)) {
    728c:	0019      	movs	r1, r3
    728e:	3201      	adds	r2, #1
    7290:	32ff      	adds	r2, #255	; 0xff
    7292:	68cb      	ldr	r3, [r1, #12]
    7294:	4213      	tst	r3, r2
    7296:	d0fc      	beq.n	7292 <system_clock_source_enable+0x76>
	OSCCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;

	/* Write full configuration to DFLL control register */
	OSCCTRL->DFLLCTRL.reg = 0;
	_system_dfll_wait_for_sync();
	OSCCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    7298:	4b0e      	ldr	r3, [pc, #56]	; (72d4 <system_clock_source_enable+0xb8>)
    729a:	681b      	ldr	r3, [r3, #0]
    729c:	b29b      	uxth	r3, r3
    729e:	4a0b      	ldr	r2, [pc, #44]	; (72cc <system_clock_source_enable+0xb0>)
    72a0:	8313      	strh	r3, [r2, #24]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    72a2:	2000      	movs	r0, #0
    72a4:	e00e      	b.n	72c4 <system_clock_source_enable+0xa8>
		_system_clock_inst.dfll.control |= OSCCTRL_DFLLCTRL_ENABLE;
		_system_clock_source_dfll_set_config_errata_9905();
		break;

	case SYSTEM_CLOCK_SOURCE_DPLL:
		OSCCTRL->DPLLCTRLA.reg |= OSCCTRL_DPLLCTRLA_ENABLE;
    72a6:	4909      	ldr	r1, [pc, #36]	; (72cc <system_clock_source_enable+0xb0>)
    72a8:	2228      	movs	r2, #40	; 0x28
    72aa:	5c88      	ldrb	r0, [r1, r2]
    72ac:	2302      	movs	r3, #2
    72ae:	4303      	orrs	r3, r0
    72b0:	548b      	strb	r3, [r1, r2]
		while(OSCCTRL->DPLLSYNCBUSY.reg & OSCCTRL_DPLLSYNCBUSY_ENABLE){
    72b2:	0008      	movs	r0, r1
    72b4:	2138      	movs	r1, #56	; 0x38
    72b6:	3a26      	subs	r2, #38	; 0x26
    72b8:	5c43      	ldrb	r3, [r0, r1]
    72ba:	4213      	tst	r3, r2
    72bc:	d1fc      	bne.n	72b8 <system_clock_source_enable+0x9c>
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    72be:	2000      	movs	r0, #0
    72c0:	e000      	b.n	72c4 <system_clock_source_enable+0xa8>
		}
		break;

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
    72c2:	2000      	movs	r0, #0
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
}
    72c4:	4770      	bx	lr
    72c6:	46c0      	nop			; (mov r8, r8)
    72c8:	0001335c 	.word	0x0001335c
    72cc:	40000c00 	.word	0x40000c00
    72d0:	40001000 	.word	0x40001000
    72d4:	200003b0 	.word	0x200003b0

000072d8 <system_clock_source_disable>:
 *                                 given
 */
enum status_code system_clock_source_disable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
    72d8:	2808      	cmp	r0, #8
    72da:	d832      	bhi.n	7342 <system_clock_source_disable+0x6a>
    72dc:	0080      	lsls	r0, r0, #2
    72de:	4b1a      	ldr	r3, [pc, #104]	; (7348 <system_clock_source_disable+0x70>)
    72e0:	581b      	ldr	r3, [r3, r0]
    72e2:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_OSC16M:
		OSCCTRL->OSC16MCTRL.reg &= ~OSCCTRL_OSC16MCTRL_ENABLE;
    72e4:	4a19      	ldr	r2, [pc, #100]	; (734c <system_clock_source_disable+0x74>)
    72e6:	7d13      	ldrb	r3, [r2, #20]
    72e8:	2102      	movs	r1, #2
    72ea:	438b      	bics	r3, r1
    72ec:	7513      	strb	r3, [r2, #20]
		Assert(false);
		return STATUS_ERR_INVALID_ARG;

	}

	return STATUS_OK;
    72ee:	2000      	movs	r0, #0
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC16M:
		OSCCTRL->OSC16MCTRL.reg &= ~OSCCTRL_OSC16MCTRL_ENABLE;
		break;
    72f0:	e028      	b.n	7344 <system_clock_source_disable+0x6c>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		OSC32KCTRL->OSC32K.reg &= ~OSC32KCTRL_OSC32K_ENABLE;
    72f2:	4a17      	ldr	r2, [pc, #92]	; (7350 <system_clock_source_disable+0x78>)
    72f4:	6993      	ldr	r3, [r2, #24]
    72f6:	2102      	movs	r1, #2
    72f8:	438b      	bics	r3, r1
    72fa:	6193      	str	r3, [r2, #24]
		Assert(false);
		return STATUS_ERR_INVALID_ARG;

	}

	return STATUS_OK;
    72fc:	2000      	movs	r0, #0
		OSCCTRL->OSC16MCTRL.reg &= ~OSCCTRL_OSC16MCTRL_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		OSC32KCTRL->OSC32K.reg &= ~OSC32KCTRL_OSC32K_ENABLE;
		break;
    72fe:	e021      	b.n	7344 <system_clock_source_disable+0x6c>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		OSCCTRL->XOSCCTRL.reg &= ~OSCCTRL_XOSCCTRL_ENABLE;
    7300:	4a12      	ldr	r2, [pc, #72]	; (734c <system_clock_source_disable+0x74>)
    7302:	8a13      	ldrh	r3, [r2, #16]
    7304:	2102      	movs	r1, #2
    7306:	438b      	bics	r3, r1
    7308:	8213      	strh	r3, [r2, #16]
		Assert(false);
		return STATUS_ERR_INVALID_ARG;

	}

	return STATUS_OK;
    730a:	2000      	movs	r0, #0
		OSC32KCTRL->OSC32K.reg &= ~OSC32KCTRL_OSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC:
		OSCCTRL->XOSCCTRL.reg &= ~OSCCTRL_XOSCCTRL_ENABLE;
		break;
    730c:	e01a      	b.n	7344 <system_clock_source_disable+0x6c>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		OSC32KCTRL->XOSC32K.reg &= ~OSC32KCTRL_XOSC32K_ENABLE;
    730e:	4a10      	ldr	r2, [pc, #64]	; (7350 <system_clock_source_disable+0x78>)
    7310:	6953      	ldr	r3, [r2, #20]
    7312:	2102      	movs	r1, #2
    7314:	438b      	bics	r3, r1
    7316:	6153      	str	r3, [r2, #20]
		Assert(false);
		return STATUS_ERR_INVALID_ARG;

	}

	return STATUS_OK;
    7318:	2000      	movs	r0, #0
		OSCCTRL->XOSCCTRL.reg &= ~OSCCTRL_XOSCCTRL_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		OSC32KCTRL->XOSC32K.reg &= ~OSC32KCTRL_XOSC32K_ENABLE;
		break;
    731a:	e013      	b.n	7344 <system_clock_source_disable+0x6c>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control &= ~OSCCTRL_DFLLCTRL_ENABLE;
    731c:	4b0d      	ldr	r3, [pc, #52]	; (7354 <system_clock_source_disable+0x7c>)
    731e:	681a      	ldr	r2, [r3, #0]
    7320:	2102      	movs	r1, #2
    7322:	438a      	bics	r2, r1
    7324:	601a      	str	r2, [r3, #0]
		OSCCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    7326:	681b      	ldr	r3, [r3, #0]
    7328:	b29b      	uxth	r3, r3
    732a:	4a08      	ldr	r2, [pc, #32]	; (734c <system_clock_source_disable+0x74>)
    732c:	8313      	strh	r3, [r2, #24]
		Assert(false);
		return STATUS_ERR_INVALID_ARG;

	}

	return STATUS_OK;
    732e:	2000      	movs	r0, #0
		break;

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control &= ~OSCCTRL_DFLLCTRL_ENABLE;
		OSCCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
		break;
    7330:	e008      	b.n	7344 <system_clock_source_disable+0x6c>
	case SYSTEM_CLOCK_SOURCE_DPLL:
		OSCCTRL->DPLLCTRLA.reg &= ~OSCCTRL_DPLLCTRLA_ENABLE;
    7332:	4906      	ldr	r1, [pc, #24]	; (734c <system_clock_source_disable+0x74>)
    7334:	2228      	movs	r2, #40	; 0x28
    7336:	5c8b      	ldrb	r3, [r1, r2]
    7338:	2002      	movs	r0, #2
    733a:	4383      	bics	r3, r0
    733c:	548b      	strb	r3, [r1, r2]
		Assert(false);
		return STATUS_ERR_INVALID_ARG;

	}

	return STATUS_OK;
    733e:	2000      	movs	r0, #0
		_system_clock_inst.dfll.control &= ~OSCCTRL_DFLLCTRL_ENABLE;
		OSCCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
		break;
	case SYSTEM_CLOCK_SOURCE_DPLL:
		OSCCTRL->DPLLCTRLA.reg &= ~OSCCTRL_DPLLCTRLA_ENABLE;
		break;
    7340:	e000      	b.n	7344 <system_clock_source_disable+0x6c>
	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Not possible to disable */

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    7342:	2017      	movs	r0, #23

	}

	return STATUS_OK;
}
    7344:	4770      	bx	lr
    7346:	46c0      	nop			; (mov r8, r8)
    7348:	00013380 	.word	0x00013380
    734c:	40000c00 	.word	0x40000c00
    7350:	40001000 	.word	0x40001000
    7354:	200003b0 	.word	0x200003b0

00007358 <system_clock_init>:
 * \note OSC16M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC16M default enable can be disabled after system_clock_init. Make sure the
 * clock switches successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    7358:	b530      	push	{r4, r5, lr}
    735a:	b08d      	sub	sp, #52	; 0x34
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	OSCCTRL->INTFLAG.reg = OSCCTRL_INTFLAG_DFLLRDY;
    735c:	2280      	movs	r2, #128	; 0x80
    735e:	0052      	lsls	r2, r2, #1
    7360:	4b68      	ldr	r3, [pc, #416]	; (7504 <system_clock_init+0x1ac>)
    7362:	609a      	str	r2, [r3, #8]
	SUPC->INTFLAG.reg = SUPC_INTFLAG_BOD33RDY | SUPC_INTFLAG_BOD33DET;
    7364:	3afd      	subs	r2, #253	; 0xfd
    7366:	4b68      	ldr	r3, [pc, #416]	; (7508 <system_clock_init+0x1b0>)
    7368:	609a      	str	r2, [r3, #8]
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    736a:	4968      	ldr	r1, [pc, #416]	; (750c <system_clock_init+0x1b4>)
    736c:	684b      	ldr	r3, [r1, #4]
    736e:	321b      	adds	r2, #27
    7370:	4393      	bics	r3, r2
    7372:	3a1a      	subs	r2, #26
    7374:	4313      	orrs	r3, r2
    7376:	604b      	str	r3, [r1, #4]
 */
static inline enum status_code system_switch_performance_level(
					const enum system_performance_level performance_level)
{

	if (performance_level == (enum system_performance_level)PM->PLCFG.reg) {
    7378:	2380      	movs	r3, #128	; 0x80
    737a:	05db      	lsls	r3, r3, #23
    737c:	789b      	ldrb	r3, [r3, #2]
    737e:	2b02      	cmp	r3, #2
    7380:	d009      	beq.n	7396 <system_clock_init+0x3e>
		return STATUS_ERR_INVALID_ARG;
	}
#endif

	/* Clear performance level status */
	PM->INTFLAG.reg = PM_INTFLAG_PLRDY;
    7382:	2380      	movs	r3, #128	; 0x80
    7384:	05db      	lsls	r3, r3, #23
    7386:	3a03      	subs	r2, #3
    7388:	719a      	strb	r2, [r3, #6]

	/* Switch performance level */
	PM->PLCFG.reg = performance_level;
    738a:	3201      	adds	r2, #1
    738c:	709a      	strb	r2, [r3, #2]

	/* Waiting performance level ready */
	while (!PM->INTFLAG.reg) {
    738e:	001a      	movs	r2, r3
    7390:	7993      	ldrb	r3, [r2, #6]
    7392:	2b00      	cmp	r3, #0
    7394:	d0fc      	beq.n	7390 <system_clock_init+0x38>
static inline void system_clock_source_xosc32k_get_config_defaults(
		struct system_clock_source_xosc32k_config *const config)
{
	Assert(config);

	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
    7396:	a809      	add	r0, sp, #36	; 0x24
    7398:	2300      	movs	r3, #0
    739a:	7003      	strb	r3, [r0, #0]
	config->startup_time        = SYSTEM_XOSC32K_STARTUP_16384;
	config->frequency           = 32768UL;
    739c:	2280      	movs	r2, #128	; 0x80
    739e:	0212      	lsls	r2, r2, #8
    73a0:	6042      	str	r2, [r0, #4]
	config->enable_1khz_output  = false;
    73a2:	7083      	strb	r3, [r0, #2]
	config->enable_32khz_output = true;
    73a4:	2201      	movs	r2, #1
    73a6:	70c2      	strb	r2, [r0, #3]
	config->run_in_standby      = false;
    73a8:	7203      	strb	r3, [r0, #8]
	config->on_demand           = true;
	config->write_once          = false;
    73aa:	7283      	strb	r3, [r0, #10]
	struct system_clock_source_xosc32k_config xosc32k_conf;
	system_clock_source_xosc32k_get_config_defaults(&xosc32k_conf);

	xosc32k_conf.frequency           = 32768UL;
	xosc32k_conf.external_clock      = CONF_CLOCK_XOSC32K_EXTERNAL_CRYSTAL;
	xosc32k_conf.startup_time        = CONF_CLOCK_XOSC32K_STARTUP_TIME;
    73ac:	7042      	strb	r2, [r0, #1]
	xosc32k_conf.enable_1khz_output  = CONF_CLOCK_XOSC32K_ENABLE_1KHZ_OUPUT;
	xosc32k_conf.enable_32khz_output = CONF_CLOCK_XOSC32K_ENABLE_32KHZ_OUTPUT;
	xosc32k_conf.on_demand           = false;
    73ae:	7243      	strb	r3, [r0, #9]
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
    73b0:	4b57      	ldr	r3, [pc, #348]	; (7510 <system_clock_init+0x1b8>)
    73b2:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
    73b4:	2005      	movs	r0, #5
    73b6:	4b57      	ldr	r3, [pc, #348]	; (7514 <system_clock_init+0x1bc>)
    73b8:	4798      	blx	r3
		mask = OSCCTRL_STATUS_XOSCRDY;
		return ((OSCCTRL->STATUS.reg & mask) == mask);

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		mask = OSC32KCTRL_STATUS_XOSC32KRDY;
		return ((OSC32KCTRL->STATUS.reg & mask) == mask);
    73ba:	4957      	ldr	r1, [pc, #348]	; (7518 <system_clock_init+0x1c0>)
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K));
    73bc:	2201      	movs	r2, #1
		mask = OSCCTRL_STATUS_XOSCRDY;
		return ((OSCCTRL->STATUS.reg & mask) == mask);

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		mask = OSC32KCTRL_STATUS_XOSC32KRDY;
		return ((OSC32KCTRL->STATUS.reg & mask) == mask);
    73be:	68cb      	ldr	r3, [r1, #12]
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K));
    73c0:	421a      	tst	r2, r3
    73c2:	d0fc      	beq.n	73be <system_clock_init+0x66>
	if (CONF_CLOCK_XOSC32K_ON_DEMAND) {
		OSC32KCTRL->XOSC32K.bit.ONDEMAND = 1;
    73c4:	4a54      	ldr	r2, [pc, #336]	; (7518 <system_clock_init+0x1c0>)
    73c6:	6951      	ldr	r1, [r2, #20]
    73c8:	2380      	movs	r3, #128	; 0x80
    73ca:	430b      	orrs	r3, r1
    73cc:	6153      	str	r3, [r2, #20]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    73ce:	a901      	add	r1, sp, #4
    73d0:	2301      	movs	r3, #1
    73d2:	604b      	str	r3, [r1, #4]
	config->high_when_disabled = false;
    73d4:	2400      	movs	r4, #0
    73d6:	704c      	strb	r4, [r1, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    73d8:	720c      	strb	r4, [r1, #8]
	config->output_enable      = false;
    73da:	724c      	strb	r4, [r1, #9]
	struct system_gclk_gen_config gclk_conf;
	struct system_clock_source_osc16m_config osc16m_conf;

	/* Select OSCULP32K as new clock source for mainclock temporarily */
	system_gclk_gen_get_config_defaults(&gclk_conf);
	gclk_conf.source_clock = SYSTEM_CLOCK_SOURCE_ULP32K;
    73dc:	2503      	movs	r5, #3
    73de:	700d      	strb	r5, [r1, #0]
	system_gclk_gen_set_config(GCLK_GENERATOR_0, &gclk_conf);
    73e0:	2000      	movs	r0, #0
    73e2:	4b4e      	ldr	r3, [pc, #312]	; (751c <system_clock_init+0x1c4>)
    73e4:	4798      	blx	r3

	/* GCLK0 is enabled after POR */

	/* Disable OSC16M clock*/
	system_clock_source_disable(SYSTEM_CLOCK_SOURCE_OSC16M);
    73e6:	2006      	movs	r0, #6
    73e8:	4b4d      	ldr	r3, [pc, #308]	; (7520 <system_clock_init+0x1c8>)
    73ea:	4798      	blx	r3
		struct system_clock_source_osc16m_config *const config)
{
	Assert(config);

	config->fsel = SYSTEM_OSC16M_4M;
	config->run_in_standby  = false;
    73ec:	466b      	mov	r3, sp
    73ee:	705c      	strb	r4, [r3, #1]

	/* Switch to new frequency selection and enable OSC16M */
	system_clock_source_osc16m_get_config_defaults(&osc16m_conf);
	osc16m_conf.fsel      		= CONF_CLOCK_OSC16M_FREQ_SEL;
    73f0:	701d      	strb	r5, [r3, #0]
	osc16m_conf.on_demand       = 0;
    73f2:	709c      	strb	r4, [r3, #2]
	osc16m_conf.run_in_standby  = CONF_CLOCK_OSC16M_RUN_IN_STANDBY;
	system_clock_source_osc16m_set_config(&osc16m_conf);
    73f4:	4668      	mov	r0, sp
    73f6:	4b4b      	ldr	r3, [pc, #300]	; (7524 <system_clock_init+0x1cc>)
    73f8:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC16M);
    73fa:	2006      	movs	r0, #6
    73fc:	4b45      	ldr	r3, [pc, #276]	; (7514 <system_clock_init+0x1bc>)
    73fe:	4798      	blx	r3
	uint32_t mask = 0;

	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC16M:
		mask = OSCCTRL_STATUS_OSC16MRDY;
		return ((OSCCTRL->STATUS.reg & mask) == mask);
    7400:	4940      	ldr	r1, [pc, #256]	; (7504 <system_clock_init+0x1ac>)
	osc16m_conf.fsel      		= CONF_CLOCK_OSC16M_FREQ_SEL;
	osc16m_conf.on_demand       = 0;
	osc16m_conf.run_in_standby  = CONF_CLOCK_OSC16M_RUN_IN_STANDBY;
	system_clock_source_osc16m_set_config(&osc16m_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC16M);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_OSC16M));
    7402:	2210      	movs	r2, #16
	uint32_t mask = 0;

	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC16M:
		mask = OSCCTRL_STATUS_OSC16MRDY;
		return ((OSCCTRL->STATUS.reg & mask) == mask);
    7404:	68cb      	ldr	r3, [r1, #12]
	osc16m_conf.fsel      		= CONF_CLOCK_OSC16M_FREQ_SEL;
	osc16m_conf.on_demand       = 0;
	osc16m_conf.run_in_standby  = CONF_CLOCK_OSC16M_RUN_IN_STANDBY;
	system_clock_source_osc16m_set_config(&osc16m_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC16M);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_OSC16M));
    7406:	421a      	tst	r2, r3
    7408:	d0fc      	beq.n	7404 <system_clock_init+0xac>
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    740a:	a901      	add	r1, sp, #4
    740c:	2301      	movs	r3, #1
    740e:	604b      	str	r3, [r1, #4]
	config->high_when_disabled = false;
    7410:	2400      	movs	r4, #0
    7412:	704c      	strb	r4, [r1, #1]
#if SAML21 || SAML22
	config->source_clock       = GCLK_SOURCE_OSC16M;
    7414:	3305      	adds	r3, #5
    7416:	700b      	strb	r3, [r1, #0]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    7418:	720c      	strb	r4, [r1, #8]
	config->output_enable      = false;
    741a:	724c      	strb	r4, [r1, #9]

	/* Select OSC16M for mainclock again */
	system_gclk_gen_get_config_defaults(&gclk_conf);
	gclk_conf.source_clock = SYSTEM_CLOCK_SOURCE_OSC16M;
	system_gclk_gen_set_config(GCLK_GENERATOR_0, &gclk_conf);
    741c:	2000      	movs	r0, #0
    741e:	4b3f      	ldr	r3, [pc, #252]	; (751c <system_clock_init+0x1c4>)
    7420:	4798      	blx	r3
	if (CONF_CLOCK_OSC16M_ON_DEMAND){
		OSCCTRL->OSC16MCTRL.reg |= OSCCTRL_OSC16MCTRL_ONDEMAND;
    7422:	4a38      	ldr	r2, [pc, #224]	; (7504 <system_clock_init+0x1ac>)
    7424:	7d11      	ldrb	r1, [r2, #20]
    7426:	2380      	movs	r3, #128	; 0x80
    7428:	430b      	orrs	r3, r1
    742a:	7513      	strb	r3, [r2, #20]
		struct system_clock_source_dfll_config *const config)
{
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
    742c:	ab04      	add	r3, sp, #16
    742e:	2200      	movs	r2, #0
    7430:	809c      	strh	r4, [r3, #4]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
    7432:	80dc      	strh	r4, [r3, #6]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
    7434:	721a      	strb	r2, [r3, #8]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
    7436:	725a      	strb	r2, [r3, #9]
	config->on_demand       = true;
	config->run_in_stanby   = false;
    7438:	709a      	strb	r2, [r3, #2]

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
	config->fine_value      = 0xff / 4; /* Midpoint */
    743a:	213f      	movs	r1, #63	; 0x3f
    743c:	8199      	strh	r1, [r3, #12]
	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
    743e:	393b      	subs	r1, #59	; 0x3b
    7440:	7019      	strb	r1, [r3, #0]
	dfll_conf.on_demand      = false;
    7442:	705a      	strb	r2, [r3, #1]
	/* Using DFLL48M COARSE CAL value from NVM Software Calibration Area Mapping 
	   in DFLL.COARSE helps to output a frequency close to 48 MHz.*/
#define NVM_DFLL_COARSE_POS    26 /* DFLL48M Coarse calibration value bit position.*/
#define NVM_DFLL_COARSE_SIZE   6  /* DFLL48M Coarse calibration value bit size.*/

	uint32_t coarse =( *((uint32_t *)(NVMCTRL_OTP5)
    7444:	4b38      	ldr	r3, [pc, #224]	; (7528 <system_clock_init+0x1d0>)
    7446:	681b      	ldr	r3, [r3, #0]
    7448:	0e9b      	lsrs	r3, r3, #26
			+ (NVM_DFLL_COARSE_POS / 32))
		>> (NVM_DFLL_COARSE_POS % 32))
		& ((1 << NVM_DFLL_COARSE_SIZE) - 1);
	/* In some revision chip, the Calibration value is not correct */
	if (coarse == 0x3f) {
    744a:	2b3f      	cmp	r3, #63	; 0x3f
    744c:	d100      	bne.n	7450 <system_clock_init+0xf8>
		coarse = 0x1f;
    744e:	3b20      	subs	r3, #32
	}

	dfll_conf.coarse_value = coarse;
    7450:	a804      	add	r0, sp, #16
    7452:	7283      	strb	r3, [r0, #10]
#  else
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
#  endif

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
    7454:	4b35      	ldr	r3, [pc, #212]	; (752c <system_clock_init+0x1d4>)
    7456:	8243      	strh	r3, [r0, #18]
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
    7458:	2307      	movs	r3, #7
    745a:	7383      	strb	r3, [r0, #14]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
    745c:	3338      	adds	r3, #56	; 0x38
    745e:	8203      	strh	r3, [r0, #16]
		dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;

		dfll_conf.multiply_factor = 48000;
	}

	system_clock_source_dfll_set_config(&dfll_conf);
    7460:	4b33      	ldr	r3, [pc, #204]	; (7530 <system_clock_init+0x1d8>)
    7462:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    7464:	ac01      	add	r4, sp, #4
    7466:	2501      	movs	r5, #1
    7468:	9502      	str	r5, [sp, #8]
	config->high_when_disabled = false;
    746a:	2300      	movs	r3, #0
    746c:	7063      	strb	r3, [r4, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    746e:	7223      	strb	r3, [r4, #8]
	config->output_enable      = false;
    7470:	7263      	strb	r3, [r4, #9]
#if CONF_CLOCK_CONFIGURE_GCLK == true
	//system_gclk_init();

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(GCLK_GEN_NUM, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
    7472:	3305      	adds	r3, #5
    7474:	7023      	strb	r3, [r4, #0]
    7476:	0021      	movs	r1, r4
    7478:	2001      	movs	r0, #1
    747a:	4b28      	ldr	r3, [pc, #160]	; (751c <system_clock_init+0x1c4>)
    747c:	4798      	blx	r3
    747e:	2001      	movs	r0, #1
    7480:	4b2c      	ldr	r3, [pc, #176]	; (7534 <system_clock_init+0x1dc>)
    7482:	4798      	blx	r3
	/* Enable DFLL reference clock if in closed loop mode */
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		struct system_gclk_chan_config dfll_gclk_chan_conf;

		system_gclk_chan_get_config_defaults(&dfll_gclk_chan_conf);
		dfll_gclk_chan_conf.source_generator = CONF_CLOCK_DFLL_SOURCE_GCLK_GENERATOR;
    7484:	7025      	strb	r5, [r4, #0]
		system_gclk_chan_set_config(OSCCTRL_GCLK_ID_DFLL48, &dfll_gclk_chan_conf);
    7486:	0021      	movs	r1, r4
    7488:	2000      	movs	r0, #0
    748a:	4b2b      	ldr	r3, [pc, #172]	; (7538 <system_clock_init+0x1e0>)
    748c:	4798      	blx	r3
		system_gclk_chan_enable(OSCCTRL_GCLK_ID_DFLL48);
    748e:	2000      	movs	r0, #0
    7490:	4b2a      	ldr	r3, [pc, #168]	; (753c <system_clock_init+0x1e4>)
    7492:	4798      	blx	r3
#  endif
#endif

	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
    7494:	2007      	movs	r0, #7
    7496:	4b1f      	ldr	r3, [pc, #124]	; (7514 <system_clock_init+0x1bc>)
    7498:	4798      	blx	r3
			mask = (OSCCTRL_STATUS_DFLLRDY |
			        OSCCTRL_STATUS_DFLLLCKF | OSCCTRL_STATUS_DFLLLCKC);
		} else {
			mask = OSCCTRL_STATUS_DFLLRDY;
		}
		return ((OSCCTRL->STATUS.reg & mask) == mask);
    749a:	491a      	ldr	r1, [pc, #104]	; (7504 <system_clock_init+0x1ac>)
#endif

	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
    749c:	22d0      	movs	r2, #208	; 0xd0
    749e:	0112      	lsls	r2, r2, #4
			mask = (OSCCTRL_STATUS_DFLLRDY |
			        OSCCTRL_STATUS_DFLLLCKF | OSCCTRL_STATUS_DFLLLCKC);
		} else {
			mask = OSCCTRL_STATUS_DFLLRDY;
		}
		return ((OSCCTRL->STATUS.reg & mask) == mask);
    74a0:	68cb      	ldr	r3, [r1, #12]
#endif

	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
    74a2:	4013      	ands	r3, r2
    74a4:	4293      	cmp	r3, r2
    74a6:	d1fb      	bne.n	74a0 <system_clock_init+0x148>
 * \param[in] divider  CPU clock divider to set
 */
static inline void system_backup_clock_set_divider(
		const enum system_main_clock_div divider)
{
	MCLK->BUPDIV.reg = MCLK_BUPDIV_BUPDIV(1 << divider);
    74a8:	4c25      	ldr	r4, [pc, #148]	; (7540 <system_clock_init+0x1e8>)
    74aa:	2301      	movs	r3, #1
    74ac:	71a3      	strb	r3, [r4, #6]
 * \param[in] divider  CPU clock divider to set
 */
static inline void system_low_power_clock_set_divider(
		const enum system_main_clock_div divider)
{
	MCLK->LPDIV.reg = MCLK_LPDIV_LPDIV(1 << divider);
    74ae:	7163      	strb	r3, [r4, #5]
 * \param[in] divider  CPU clock divider to set
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
	MCLK->CPUDIV.reg = MCLK_CPUDIV_CPUDIV(1 << divider);
    74b0:	7123      	strb	r3, [r4, #4]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    74b2:	a901      	add	r1, sp, #4
    74b4:	604b      	str	r3, [r1, #4]
	config->high_when_disabled = false;
    74b6:	2300      	movs	r3, #0
    74b8:	704b      	strb	r3, [r1, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    74ba:	720b      	strb	r3, [r1, #8]
	config->output_enable      = false;
    74bc:	724b      	strb	r3, [r1, #9]
	system_main_clock_set_failure_detect(CONF_CLOCK_CPU_CLOCK_FAILURE_DETECT);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    74be:	3307      	adds	r3, #7
    74c0:	700b      	strb	r3, [r1, #0]
    74c2:	2000      	movs	r0, #0
    74c4:	4b15      	ldr	r3, [pc, #84]	; (751c <system_clock_init+0x1c4>)
    74c6:	4798      	blx	r3
    74c8:	2000      	movs	r0, #0
    74ca:	4b1a      	ldr	r3, [pc, #104]	; (7534 <system_clock_init+0x1dc>)
    74cc:	4798      	blx	r3
 *
 * \return Current CPU frequency in Hz.
 */
static inline uint32_t system_cpu_clock_get_hz(void)
{
	return (system_gclk_gen_get_hz(GCLK_GENERATOR_0) >> (MCLK->CPUDIV.reg - 1));
    74ce:	2000      	movs	r0, #0
    74d0:	4b1c      	ldr	r3, [pc, #112]	; (7544 <system_clock_init+0x1ec>)
    74d2:	4798      	blx	r3
    74d4:	7923      	ldrb	r3, [r4, #4]
#endif

	/* If CPU frequency is less than 12MHz, scale down performance level to PL0 */
	uint32_t cpu_freq = system_cpu_clock_get_hz();
	if (cpu_freq <= 12000000) {
    74d6:	3b01      	subs	r3, #1
    74d8:	40d8      	lsrs	r0, r3
    74da:	4b1b      	ldr	r3, [pc, #108]	; (7548 <system_clock_init+0x1f0>)
    74dc:	4298      	cmp	r0, r3
    74de:	d80e      	bhi.n	74fe <system_clock_init+0x1a6>
 */
static inline enum status_code system_switch_performance_level(
					const enum system_performance_level performance_level)
{

	if (performance_level == (enum system_performance_level)PM->PLCFG.reg) {
    74e0:	2380      	movs	r3, #128	; 0x80
    74e2:	05db      	lsls	r3, r3, #23
    74e4:	789b      	ldrb	r3, [r3, #2]
    74e6:	2b00      	cmp	r3, #0
    74e8:	d009      	beq.n	74fe <system_clock_init+0x1a6>
		return STATUS_ERR_INVALID_ARG;
	}
#endif

	/* Clear performance level status */
	PM->INTFLAG.reg = PM_INTFLAG_PLRDY;
    74ea:	2380      	movs	r3, #128	; 0x80
    74ec:	05db      	lsls	r3, r3, #23
    74ee:	2201      	movs	r2, #1
    74f0:	719a      	strb	r2, [r3, #6]

	/* Switch performance level */
	PM->PLCFG.reg = performance_level;
    74f2:	2200      	movs	r2, #0
    74f4:	709a      	strb	r2, [r3, #2]

	/* Waiting performance level ready */
	while (!PM->INTFLAG.reg) {
    74f6:	001a      	movs	r2, r3
    74f8:	7993      	ldrb	r3, [r2, #6]
    74fa:	2b00      	cmp	r3, #0
    74fc:	d0fc      	beq.n	74f8 <system_clock_init+0x1a0>
		system_switch_performance_level(SYSTEM_PERFORMANCE_LEVEL_0);
	}
}
    74fe:	b00d      	add	sp, #52	; 0x34
    7500:	bd30      	pop	{r4, r5, pc}
    7502:	46c0      	nop			; (mov r8, r8)
    7504:	40000c00 	.word	0x40000c00
    7508:	40001400 	.word	0x40001400
    750c:	41004000 	.word	0x41004000
    7510:	000070e1 	.word	0x000070e1
    7514:	0000721d 	.word	0x0000721d
    7518:	40001000 	.word	0x40001000
    751c:	0000754d 	.word	0x0000754d
    7520:	000072d9 	.word	0x000072d9
    7524:	000070a9 	.word	0x000070a9
    7528:	00806020 	.word	0x00806020
    752c:	000005b9 	.word	0x000005b9
    7530:	00007195 	.word	0x00007195
    7534:	000075f9 	.word	0x000075f9
    7538:	00007715 	.word	0x00007715
    753c:	000076a5 	.word	0x000076a5
    7540:	40000400 	.word	0x40000400
    7544:	00007639 	.word	0x00007639
    7548:	00b71b00 	.word	0x00b71b00

0000754c <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    754c:	b570      	push	{r4, r5, r6, lr}
    754e:	0005      	movs	r5, r0
	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config ;


	/* Select the requested source clock for the generator */
	new_genctrl_config = config->source_clock << GCLK_GENCTRL_SRC_Pos;
    7550:	780c      	ldrb	r4, [r1, #0]

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    7552:	784b      	ldrb	r3, [r1, #1]
    7554:	2b00      	cmp	r3, #0
    7556:	d002      	beq.n	755e <system_gclk_gen_set_config+0x12>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    7558:	2380      	movs	r3, #128	; 0x80
    755a:	00db      	lsls	r3, r3, #3
    755c:	431c      	orrs	r4, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    755e:	7a4b      	ldrb	r3, [r1, #9]
    7560:	2b00      	cmp	r3, #0
    7562:	d002      	beq.n	756a <system_gclk_gen_set_config+0x1e>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    7564:	2380      	movs	r3, #128	; 0x80
    7566:	011b      	lsls	r3, r3, #4
    7568:	431c      	orrs	r4, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    756a:	684a      	ldr	r2, [r1, #4]
    756c:	2a01      	cmp	r2, #1
    756e:	d917      	bls.n	75a0 <system_gclk_gen_set_config+0x54>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    7570:	1e53      	subs	r3, r2, #1
    7572:	421a      	tst	r2, r3
    7574:	d10f      	bne.n	7596 <system_gclk_gen_set_config+0x4a>
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    7576:	2a02      	cmp	r2, #2
    7578:	d906      	bls.n	7588 <system_gclk_gen_set_config+0x3c>
    757a:	2302      	movs	r3, #2
    757c:	2000      	movs	r0, #0
						mask <<= 1) {
				div2_count++;
    757e:	3001      	adds	r0, #1

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
    7580:	005b      	lsls	r3, r3, #1
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    7582:	429a      	cmp	r2, r3
    7584:	d8fb      	bhi.n	757e <system_gclk_gen_set_config+0x32>
    7586:	e000      	b.n	758a <system_gclk_gen_set_config+0x3e>
    7588:	2000      	movs	r0, #0
    758a:	2380      	movs	r3, #128	; 0x80
    758c:	015b      	lsls	r3, r3, #5
    758e:	431c      	orrs	r4, r3
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_genctrl_config  |= div2_count << GCLK_GENCTRL_DIV_Pos;
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    7590:	0400      	lsls	r0, r0, #16
    7592:	4304      	orrs	r4, r0
    7594:	e004      	b.n	75a0 <system_gclk_gen_set_config+0x54>

			new_genctrl_config  |=
					(config->division_factor) << GCLK_GENCTRL_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    7596:	0412      	lsls	r2, r2, #16
    7598:	2380      	movs	r3, #128	; 0x80
    759a:	009b      	lsls	r3, r3, #2
    759c:	431a      	orrs	r2, r3
    759e:	4314      	orrs	r4, r2
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    75a0:	7a0b      	ldrb	r3, [r1, #8]
    75a2:	2b00      	cmp	r3, #0
    75a4:	d002      	beq.n	75ac <system_gclk_gen_set_config+0x60>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    75a6:	2380      	movs	r3, #128	; 0x80
    75a8:	019b      	lsls	r3, r3, #6
    75aa:	431c      	orrs	r4, r3
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    75ac:	2604      	movs	r6, #4
    75ae:	40ae      	lsls	r6, r5
    75b0:	490d      	ldr	r1, [pc, #52]	; (75e8 <system_gclk_gen_set_config+0x9c>)
	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
	}

	while (system_gclk_is_syncing(generator)) {
    75b2:	4a0e      	ldr	r2, [pc, #56]	; (75ec <system_gclk_gen_set_config+0xa0>)
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    75b4:	684b      	ldr	r3, [r1, #4]
	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
	}

	while (system_gclk_is_syncing(generator)) {
    75b6:	4013      	ands	r3, r2
    75b8:	421e      	tst	r6, r3
    75ba:	d1fb      	bne.n	75b4 <system_gclk_gen_set_config+0x68>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    75bc:	4b0c      	ldr	r3, [pc, #48]	; (75f0 <system_gclk_gen_set_config+0xa4>)
    75be:	4798      	blx	r3
    75c0:	00ad      	lsls	r5, r5, #2
    75c2:	4b09      	ldr	r3, [pc, #36]	; (75e8 <system_gclk_gen_set_config+0x9c>)
    75c4:	469c      	mov	ip, r3
    75c6:	4465      	add	r5, ip
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();

	GCLK->GENCTRL[generator].reg = new_genctrl_config | (GCLK->GENCTRL[generator].reg & GCLK_GENCTRL_GENEN);
    75c8:	6a28      	ldr	r0, [r5, #32]
    75ca:	2380      	movs	r3, #128	; 0x80
    75cc:	005b      	lsls	r3, r3, #1
    75ce:	4018      	ands	r0, r3
    75d0:	4320      	orrs	r0, r4
    75d2:	6228      	str	r0, [r5, #32]
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    75d4:	4661      	mov	r1, ip

	system_interrupt_enter_critical_section();

	GCLK->GENCTRL[generator].reg = new_genctrl_config | (GCLK->GENCTRL[generator].reg & GCLK_GENCTRL_GENEN);

	while (system_gclk_is_syncing(generator)) {
    75d6:	4a05      	ldr	r2, [pc, #20]	; (75ec <system_gclk_gen_set_config+0xa0>)
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    75d8:	684b      	ldr	r3, [r1, #4]

	system_interrupt_enter_critical_section();

	GCLK->GENCTRL[generator].reg = new_genctrl_config | (GCLK->GENCTRL[generator].reg & GCLK_GENCTRL_GENEN);

	while (system_gclk_is_syncing(generator)) {
    75da:	4013      	ands	r3, r2
    75dc:	421e      	tst	r6, r3
    75de:	d1fb      	bne.n	75d8 <system_gclk_gen_set_config+0x8c>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    75e0:	4b04      	ldr	r3, [pc, #16]	; (75f4 <system_gclk_gen_set_config+0xa8>)
    75e2:	4798      	blx	r3
		/* Wait for synchronization */
	};

	system_interrupt_leave_critical_section();
}
    75e4:	bd70      	pop	{r4, r5, r6, pc}
    75e6:	46c0      	nop			; (mov r8, r8)
    75e8:	40001800 	.word	0x40001800
    75ec:	000007fc 	.word	0x000007fc
    75f0:	000062dd 	.word	0x000062dd
    75f4:	0000631d 	.word	0x0000631d

000075f8 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    75f8:	b510      	push	{r4, lr}
    75fa:	0004      	movs	r4, r0
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    75fc:	2204      	movs	r2, #4
    75fe:	4082      	lsls	r2, r0
    7600:	4809      	ldr	r0, [pc, #36]	; (7628 <system_gclk_gen_enable+0x30>)
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
	while (system_gclk_is_syncing(generator)) {
    7602:	490a      	ldr	r1, [pc, #40]	; (762c <system_gclk_gen_enable+0x34>)
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    7604:	6843      	ldr	r3, [r0, #4]
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
	while (system_gclk_is_syncing(generator)) {
    7606:	400b      	ands	r3, r1
    7608:	421a      	tst	r2, r3
    760a:	d1fb      	bne.n	7604 <system_gclk_gen_enable+0xc>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    760c:	4b08      	ldr	r3, [pc, #32]	; (7630 <system_gclk_gen_enable+0x38>)
    760e:	4798      	blx	r3
    7610:	00a4      	lsls	r4, r4, #2
    7612:	4b05      	ldr	r3, [pc, #20]	; (7628 <system_gclk_gen_enable+0x30>)
    7614:	469c      	mov	ip, r3
    7616:	4464      	add	r4, ip
	};

	system_interrupt_enter_critical_section();

	/* Enable generator */
	GCLK->GENCTRL[generator].reg |= GCLK_GENCTRL_GENEN;
    7618:	6a23      	ldr	r3, [r4, #32]
    761a:	2280      	movs	r2, #128	; 0x80
    761c:	0052      	lsls	r2, r2, #1
    761e:	4313      	orrs	r3, r2
    7620:	6223      	str	r3, [r4, #32]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    7622:	4b04      	ldr	r3, [pc, #16]	; (7634 <system_gclk_gen_enable+0x3c>)
    7624:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    7626:	bd10      	pop	{r4, pc}
    7628:	40001800 	.word	0x40001800
    762c:	000007fc 	.word	0x000007fc
    7630:	000062dd 	.word	0x000062dd
    7634:	0000631d 	.word	0x0000631d

00007638 <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
    7638:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    763a:	0004      	movs	r4, r0
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    763c:	2204      	movs	r2, #4
    763e:	4082      	lsls	r2, r0
    7640:	4812      	ldr	r0, [pc, #72]	; (768c <system_gclk_gen_get_hz+0x54>)
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
	while (system_gclk_is_syncing(generator)) {
    7642:	4913      	ldr	r1, [pc, #76]	; (7690 <system_gclk_gen_get_hz+0x58>)
  * \retval true if the module synchronization is ongoing
  */
static inline bool system_gclk_is_syncing(const uint8_t generator)
{

	 if (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL(1 << generator )){
    7644:	6843      	ldr	r3, [r0, #4]
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
	while (system_gclk_is_syncing(generator)) {
    7646:	400b      	ands	r3, r1
    7648:	421a      	tst	r2, r3
    764a:	d1fb      	bne.n	7644 <system_gclk_gen_get_hz+0xc>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    764c:	4b11      	ldr	r3, [pc, #68]	; (7694 <system_gclk_gen_get_hz+0x5c>)
    764e:	4798      	blx	r3

	system_interrupt_enter_critical_section();

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL[generator].bit.SRC);
    7650:	4f0e      	ldr	r7, [pc, #56]	; (768c <system_gclk_gen_get_hz+0x54>)
    7652:	3408      	adds	r4, #8
    7654:	00a4      	lsls	r4, r4, #2
    7656:	59e0      	ldr	r0, [r4, r7]
    7658:	0700      	lsls	r0, r0, #28
    765a:	0f00      	lsrs	r0, r0, #28
	};

	system_interrupt_enter_critical_section();

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
    765c:	4b0e      	ldr	r3, [pc, #56]	; (7698 <system_gclk_gen_get_hz+0x60>)
    765e:	4798      	blx	r3
    7660:	0006      	movs	r6, r0
			(enum system_clock_source)GCLK->GENCTRL[generator].bit.SRC);

	uint8_t divsel = GCLK->GENCTRL[generator].bit.DIVSEL;
    7662:	59e5      	ldr	r5, [r4, r7]
    7664:	04ed      	lsls	r5, r5, #19
    7666:	0fed      	lsrs	r5, r5, #31
	uint32_t divider = GCLK->GENCTRL[generator].bit.DIV;
    7668:	59e4      	ldr	r4, [r4, r7]
    766a:	0c24      	lsrs	r4, r4, #16
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    766c:	4b0b      	ldr	r3, [pc, #44]	; (769c <system_gclk_gen_get_hz+0x64>)
    766e:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    7670:	2d00      	cmp	r5, #0
    7672:	d107      	bne.n	7684 <system_gclk_gen_get_hz+0x4c>
    7674:	2c01      	cmp	r4, #1
    7676:	d907      	bls.n	7688 <system_gclk_gen_get_hz+0x50>
		gen_input_hz /= divider;
    7678:	0021      	movs	r1, r4
    767a:	0030      	movs	r0, r6
    767c:	4b08      	ldr	r3, [pc, #32]	; (76a0 <system_gclk_gen_get_hz+0x68>)
    767e:	4798      	blx	r3
    7680:	0006      	movs	r6, r0
    7682:	e001      	b.n	7688 <system_gclk_gen_get_hz+0x50>
	} else if (divsel) {
		gen_input_hz >>= (divider+1);
    7684:	3401      	adds	r4, #1
    7686:	40e6      	lsrs	r6, r4
	}

	return gen_input_hz;
}
    7688:	0030      	movs	r0, r6
    768a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    768c:	40001800 	.word	0x40001800
    7690:	000007fc 	.word	0x000007fc
    7694:	000062dd 	.word	0x000062dd
    7698:	00007015 	.word	0x00007015
    769c:	0000631d 	.word	0x0000631d
    76a0:	0000a38d 	.word	0x0000a38d

000076a4 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    76a4:	b510      	push	{r4, lr}
    76a6:	0004      	movs	r4, r0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    76a8:	4b09      	ldr	r3, [pc, #36]	; (76d0 <system_gclk_chan_enable+0x2c>)
    76aa:	4798      	blx	r3
    76ac:	00a0      	lsls	r0, r4, #2
    76ae:	4b09      	ldr	r3, [pc, #36]	; (76d4 <system_gclk_chan_enable+0x30>)
    76b0:	469c      	mov	ip, r3
    76b2:	4460      	add	r0, ip
	system_interrupt_enter_critical_section();

	/* Enable the peripheral channel */
	GCLK->PCHCTRL[channel].reg |= GCLK_PCHCTRL_CHEN;
    76b4:	2280      	movs	r2, #128	; 0x80
    76b6:	5881      	ldr	r1, [r0, r2]
    76b8:	2340      	movs	r3, #64	; 0x40
    76ba:	430b      	orrs	r3, r1
    76bc:	5083      	str	r3, [r0, r2]

	while (!(GCLK->PCHCTRL[channel].reg & GCLK_PCHCTRL_CHEN)) {
    76be:	2180      	movs	r1, #128	; 0x80
    76c0:	3a40      	subs	r2, #64	; 0x40
    76c2:	5843      	ldr	r3, [r0, r1]
    76c4:	421a      	tst	r2, r3
    76c6:	d0fc      	beq.n	76c2 <system_gclk_chan_enable+0x1e>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    76c8:	4b03      	ldr	r3, [pc, #12]	; (76d8 <system_gclk_chan_enable+0x34>)
    76ca:	4798      	blx	r3
		/* Wait for clock synchronization */
	}

	system_interrupt_leave_critical_section();
}
    76cc:	bd10      	pop	{r4, pc}
    76ce:	46c0      	nop			; (mov r8, r8)
    76d0:	000062dd 	.word	0x000062dd
    76d4:	40001800 	.word	0x40001800
    76d8:	0000631d 	.word	0x0000631d

000076dc <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    76dc:	b510      	push	{r4, lr}
    76de:	0004      	movs	r4, r0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    76e0:	4b09      	ldr	r3, [pc, #36]	; (7708 <system_gclk_chan_disable+0x2c>)
    76e2:	4798      	blx	r3
    76e4:	00a0      	lsls	r0, r4, #2
    76e6:	4b09      	ldr	r3, [pc, #36]	; (770c <system_gclk_chan_disable+0x30>)
    76e8:	469c      	mov	ip, r3
    76ea:	4460      	add	r0, ip

	/* Sanity check WRTLOCK */
	Assert(!GCLK->PCHCTRL[channel].bit.WRTLOCK);

	/* Disable the peripheral channel */
	GCLK->PCHCTRL[channel].reg &= ~GCLK_PCHCTRL_CHEN;
    76ec:	2280      	movs	r2, #128	; 0x80
    76ee:	5883      	ldr	r3, [r0, r2]
    76f0:	2140      	movs	r1, #64	; 0x40
    76f2:	438b      	bics	r3, r1
    76f4:	5083      	str	r3, [r0, r2]

	while (GCLK->PCHCTRL[channel].reg & GCLK_PCHCTRL_CHEN) {
    76f6:	3140      	adds	r1, #64	; 0x40
    76f8:	3a40      	subs	r2, #64	; 0x40
    76fa:	5843      	ldr	r3, [r0, r1]
    76fc:	421a      	tst	r2, r3
    76fe:	d1fc      	bne.n	76fa <system_gclk_chan_disable+0x1e>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    7700:	4b03      	ldr	r3, [pc, #12]	; (7710 <system_gclk_chan_disable+0x34>)
    7702:	4798      	blx	r3
		/* Wait for clock synchronization */
	}

	system_interrupt_leave_critical_section();
}
    7704:	bd10      	pop	{r4, pc}
    7706:	46c0      	nop			; (mov r8, r8)
    7708:	000062dd 	.word	0x000062dd
    770c:	40001800 	.word	0x40001800
    7710:	0000631d 	.word	0x0000631d

00007714 <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
    7714:	b570      	push	{r4, r5, r6, lr}
    7716:	0004      	movs	r4, r0
    7718:	000d      	movs	r5, r1
	/* Sanity check arguments */
	Assert(config);

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
    771a:	4b05      	ldr	r3, [pc, #20]	; (7730 <system_gclk_chan_set_config+0x1c>)
    771c:	4798      	blx	r3

	/* Configure the peripheral channel */
	GCLK->PCHCTRL[channel].reg = GCLK_PCHCTRL_GEN(config->source_generator);
    771e:	782b      	ldrb	r3, [r5, #0]
    7720:	220f      	movs	r2, #15
    7722:	4013      	ands	r3, r2
    7724:	3420      	adds	r4, #32
    7726:	00a4      	lsls	r4, r4, #2
    7728:	4a02      	ldr	r2, [pc, #8]	; (7734 <system_gclk_chan_set_config+0x20>)
    772a:	50a3      	str	r3, [r4, r2]


}
    772c:	bd70      	pop	{r4, r5, r6, pc}
    772e:	46c0      	nop			; (mov r8, r8)
    7730:	000076dd 	.word	0x000076dd
    7734:	40001800 	.word	0x40001800

00007738 <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    7738:	b510      	push	{r4, lr}
    773a:	0004      	movs	r4, r0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    773c:	4b06      	ldr	r3, [pc, #24]	; (7758 <system_gclk_chan_get_hz+0x20>)
    773e:	4798      	blx	r3
	uint8_t gen_id;

	system_interrupt_enter_critical_section();
	/* Select the requested generic clock channel */
	gen_id = GCLK->PCHCTRL[channel].bit.GEN;
    7740:	3420      	adds	r4, #32
    7742:	00a4      	lsls	r4, r4, #2
    7744:	4b05      	ldr	r3, [pc, #20]	; (775c <system_gclk_chan_get_hz+0x24>)
    7746:	58e4      	ldr	r4, [r4, r3]
    7748:	0724      	lsls	r4, r4, #28
    774a:	0f24      	lsrs	r4, r4, #28
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    774c:	4b04      	ldr	r3, [pc, #16]	; (7760 <system_gclk_chan_get_hz+0x28>)
    774e:	4798      	blx	r3
	system_interrupt_leave_critical_section();

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
    7750:	0020      	movs	r0, r4
    7752:	4b04      	ldr	r3, [pc, #16]	; (7764 <system_gclk_chan_get_hz+0x2c>)
    7754:	4798      	blx	r3
}
    7756:	bd10      	pop	{r4, pc}
    7758:	000062dd 	.word	0x000062dd
    775c:	40001800 	.word	0x40001800
    7760:	0000631d 	.word	0x0000631d
    7764:	00007639 	.word	0x00007639

00007768 <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    7768:	b530      	push	{r4, r5, lr}

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    776a:	78d3      	ldrb	r3, [r2, #3]
    776c:	2b00      	cmp	r3, #0
    776e:	d11e      	bne.n	77ae <_system_pinmux_config+0x46>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    7770:	7813      	ldrb	r3, [r2, #0]
    7772:	2b80      	cmp	r3, #128	; 0x80
    7774:	d004      	beq.n	7780 <_system_pinmux_config+0x18>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    7776:	061b      	lsls	r3, r3, #24
    7778:	2480      	movs	r4, #128	; 0x80
    777a:	0264      	lsls	r4, r4, #9
    777c:	4323      	orrs	r3, r4
    777e:	e000      	b.n	7782 <_system_pinmux_config+0x1a>
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    7780:	2300      	movs	r3, #0
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    7782:	7854      	ldrb	r4, [r2, #1]
    7784:	2502      	movs	r5, #2
    7786:	43ac      	bics	r4, r5
    7788:	d10a      	bne.n	77a0 <_system_pinmux_config+0x38>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    778a:	7894      	ldrb	r4, [r2, #2]
    778c:	2c00      	cmp	r4, #0
    778e:	d103      	bne.n	7798 <_system_pinmux_config+0x30>

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
    7790:	2480      	movs	r4, #128	; 0x80
    7792:	02a4      	lsls	r4, r4, #10
    7794:	4323      	orrs	r3, r4
    7796:	e002      	b.n	779e <_system_pinmux_config+0x36>

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    7798:	24c0      	movs	r4, #192	; 0xc0
    779a:	02e4      	lsls	r4, r4, #11
    779c:	4323      	orrs	r3, r4
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    779e:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    77a0:	7854      	ldrb	r4, [r2, #1]
    77a2:	3c01      	subs	r4, #1
    77a4:	2c01      	cmp	r4, #1
    77a6:	d812      	bhi.n	77ce <_system_pinmux_config+0x66>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    77a8:	4c18      	ldr	r4, [pc, #96]	; (780c <_system_pinmux_config+0xa4>)
    77aa:	4023      	ands	r3, r4
    77ac:	e00f      	b.n	77ce <_system_pinmux_config+0x66>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
    77ae:	6041      	str	r1, [r0, #4]

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    77b0:	040b      	lsls	r3, r1, #16
    77b2:	0c1b      	lsrs	r3, r3, #16
    77b4:	24a0      	movs	r4, #160	; 0xa0
    77b6:	05e4      	lsls	r4, r4, #23
    77b8:	4323      	orrs	r3, r4
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    77ba:	6283      	str	r3, [r0, #40]	; 0x28

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    77bc:	0c0b      	lsrs	r3, r1, #16
    77be:	24d0      	movs	r4, #208	; 0xd0
    77c0:	0624      	lsls	r4, r4, #24
    77c2:	4323      	orrs	r3, r4
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    77c4:	6283      	str	r3, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    77c6:	78d3      	ldrb	r3, [r2, #3]
    77c8:	2b00      	cmp	r3, #0
    77ca:	d018      	beq.n	77fe <_system_pinmux_config+0x96>
    77cc:	e01c      	b.n	7808 <_system_pinmux_config+0xa0>

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    77ce:	040c      	lsls	r4, r1, #16
    77d0:	0c24      	lsrs	r4, r4, #16
    77d2:	25a0      	movs	r5, #160	; 0xa0
    77d4:	05ed      	lsls	r5, r5, #23
    77d6:	432c      	orrs	r4, r5
    77d8:	431c      	orrs	r4, r3
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    77da:	6284      	str	r4, [r0, #40]	; 0x28

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    77dc:	0c0c      	lsrs	r4, r1, #16
    77de:	25d0      	movs	r5, #208	; 0xd0
    77e0:	062d      	lsls	r5, r5, #24
    77e2:	432c      	orrs	r4, r5
    77e4:	431c      	orrs	r4, r3
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    77e6:	6284      	str	r4, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    77e8:	78d4      	ldrb	r4, [r2, #3]
    77ea:	2c00      	cmp	r4, #0
    77ec:	d10c      	bne.n	7808 <_system_pinmux_config+0xa0>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    77ee:	035b      	lsls	r3, r3, #13
    77f0:	d505      	bpl.n	77fe <_system_pinmux_config+0x96>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    77f2:	7893      	ldrb	r3, [r2, #2]
    77f4:	2b01      	cmp	r3, #1
    77f6:	d101      	bne.n	77fc <_system_pinmux_config+0x94>
				port->OUTSET.reg = pin_mask;
    77f8:	6181      	str	r1, [r0, #24]
    77fa:	e000      	b.n	77fe <_system_pinmux_config+0x96>
			} else {
				port->OUTCLR.reg = pin_mask;
    77fc:	6141      	str	r1, [r0, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    77fe:	7853      	ldrb	r3, [r2, #1]
    7800:	3b01      	subs	r3, #1
    7802:	2b01      	cmp	r3, #1
    7804:	d800      	bhi.n	7808 <_system_pinmux_config+0xa0>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    7806:	6081      	str	r1, [r0, #8]
		}
	}
}
    7808:	bd30      	pop	{r4, r5, pc}
    780a:	46c0      	nop			; (mov r8, r8)
    780c:	fffbffff 	.word	0xfffbffff

00007810 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    7810:	b510      	push	{r4, lr}
    7812:	0003      	movs	r3, r0
    7814:	000a      	movs	r2, r1
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    7816:	09c1      	lsrs	r1, r0, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    7818:	2000      	movs	r0, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    781a:	2900      	cmp	r1, #0
    781c:	d104      	bne.n	7828 <system_pinmux_pin_set_config+0x18>
		return &(ports[port_index]->Group[group_index]);
    781e:	0958      	lsrs	r0, r3, #5
    7820:	01c0      	lsls	r0, r0, #7
    7822:	4905      	ldr	r1, [pc, #20]	; (7838 <system_pinmux_pin_set_config+0x28>)
    7824:	468c      	mov	ip, r1
    7826:	4460      	add	r0, ip
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));

	_system_pinmux_config(port, pin_mask, config);
    7828:	211f      	movs	r1, #31
    782a:	400b      	ands	r3, r1
    782c:	391e      	subs	r1, #30
    782e:	4099      	lsls	r1, r3
    7830:	4b02      	ldr	r3, [pc, #8]	; (783c <system_pinmux_pin_set_config+0x2c>)
    7832:	4798      	blx	r3
}
    7834:	bd10      	pop	{r4, pc}
    7836:	46c0      	nop			; (mov r8, r8)
    7838:	40002800 	.word	0x40002800
    783c:	00007769 	.word	0x00007769

00007840 <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
    7840:	4770      	bx	lr
    7842:	46c0      	nop			; (mov r8, r8)

00007844 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    7844:	b510      	push	{r4, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    7846:	4b04      	ldr	r3, [pc, #16]	; (7858 <system_init+0x14>)
    7848:	4798      	blx	r3

	/* Initialize board hardware */
	//system_board_init();

	/* Initialize EVSYS hardware */
	_system_events_init();
    784a:	4b04      	ldr	r3, [pc, #16]	; (785c <system_init+0x18>)
    784c:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    784e:	4b04      	ldr	r3, [pc, #16]	; (7860 <system_init+0x1c>)
    7850:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
    7852:	4b04      	ldr	r3, [pc, #16]	; (7864 <system_init+0x20>)
    7854:	4798      	blx	r3
}
    7856:	bd10      	pop	{r4, pc}
    7858:	00007359 	.word	0x00007359
    785c:	00005fa5 	.word	0x00005fa5
    7860:	00006461 	.word	0x00006461
    7864:	00007841 	.word	0x00007841

00007868 <tc_register_callback>:
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
    7868:	1c93      	adds	r3, r2, #2
    786a:	009b      	lsls	r3, r3, #2
    786c:	5019      	str	r1, [r3, r0]

	/* Set the bit corresponding to the callback_type */
	if (callback_type == TC_CALLBACK_CC_CHANNEL0) {
    786e:	2a02      	cmp	r2, #2
    7870:	d104      	bne.n	787c <tc_register_callback+0x14>
		module->register_callback_mask |= TC_INTFLAG_MC(1);
    7872:	7e02      	ldrb	r2, [r0, #24]
    7874:	2310      	movs	r3, #16
    7876:	4313      	orrs	r3, r2
    7878:	7603      	strb	r3, [r0, #24]
    787a:	e00b      	b.n	7894 <tc_register_callback+0x2c>
	}
	else if (callback_type == TC_CALLBACK_CC_CHANNEL1) {
    787c:	2a03      	cmp	r2, #3
    787e:	d104      	bne.n	788a <tc_register_callback+0x22>
		module->register_callback_mask |= TC_INTFLAG_MC(2);
    7880:	7e02      	ldrb	r2, [r0, #24]
    7882:	2320      	movs	r3, #32
    7884:	4313      	orrs	r3, r2
    7886:	7603      	strb	r3, [r0, #24]
    7888:	e004      	b.n	7894 <tc_register_callback+0x2c>
	}
	else {
		module->register_callback_mask |= (1 << callback_type);
    788a:	2301      	movs	r3, #1
    788c:	4093      	lsls	r3, r2
    788e:	7e02      	ldrb	r2, [r0, #24]
    7890:	4313      	orrs	r3, r2
    7892:	7603      	strb	r3, [r0, #24]
	}
	return STATUS_OK;
}
    7894:	2000      	movs	r0, #0
    7896:	4770      	bx	lr

00007898 <_tc_interrupt_handler>:
 * \param[in]  instance  ID of the TC instance calling the interrupt
 *                       handler
 */
void _tc_interrupt_handler(
		uint8_t instance)
{
    7898:	b570      	push	{r4, r5, r6, lr}
	/* Temporary variable */
	uint8_t interrupt_and_callback_status_mask;

	/* Get device instance from the look-up table */
	struct tc_module *module
    789a:	0080      	lsls	r0, r0, #2
    789c:	4b14      	ldr	r3, [pc, #80]	; (78f0 <_tc_interrupt_handler+0x58>)
    789e:	58c5      	ldr	r5, [r0, r3]
			= (struct tc_module *)_tc_instances[instance];

	/* Read and mask interrupt flag register */
	interrupt_and_callback_status_mask = module->hw->COUNT8.INTFLAG.reg &
    78a0:	682b      	ldr	r3, [r5, #0]
    78a2:	7a9c      	ldrb	r4, [r3, #10]
    78a4:	7e2b      	ldrb	r3, [r5, #24]
    78a6:	401c      	ands	r4, r3
    78a8:	7e6b      	ldrb	r3, [r5, #25]
    78aa:	401c      	ands	r4, r3
			module->register_callback_mask &
			module->enable_callback_mask;

	/* Check if an Overflow interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_OVF) {
    78ac:	07e3      	lsls	r3, r4, #31
    78ae:	d505      	bpl.n	78bc <_tc_interrupt_handler+0x24>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_OVERFLOW])(module);
    78b0:	0028      	movs	r0, r5
    78b2:	68ab      	ldr	r3, [r5, #8]
    78b4:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_OVF;
    78b6:	2301      	movs	r3, #1
    78b8:	682a      	ldr	r2, [r5, #0]
    78ba:	7293      	strb	r3, [r2, #10]
	}

	/* Check if an Error interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_ERR) {
    78bc:	07a3      	lsls	r3, r4, #30
    78be:	d505      	bpl.n	78cc <_tc_interrupt_handler+0x34>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_ERROR])(module);
    78c0:	0028      	movs	r0, r5
    78c2:	68eb      	ldr	r3, [r5, #12]
    78c4:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_ERR;
    78c6:	2302      	movs	r3, #2
    78c8:	682a      	ldr	r2, [r5, #0]
    78ca:	7293      	strb	r3, [r2, #10]
	}

	/* Check if an Match/Capture Channel 0 interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_MC(1)) {
    78cc:	06e3      	lsls	r3, r4, #27
    78ce:	d505      	bpl.n	78dc <_tc_interrupt_handler+0x44>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_CC_CHANNEL0])(module);
    78d0:	0028      	movs	r0, r5
    78d2:	692b      	ldr	r3, [r5, #16]
    78d4:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_MC(1);
    78d6:	2310      	movs	r3, #16
    78d8:	682a      	ldr	r2, [r5, #0]
    78da:	7293      	strb	r3, [r2, #10]
	}

	/* Check if an Match/Capture Channel 1 interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_MC(2)) {
    78dc:	06a3      	lsls	r3, r4, #26
    78de:	d505      	bpl.n	78ec <_tc_interrupt_handler+0x54>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_CC_CHANNEL1])(module);
    78e0:	0028      	movs	r0, r5
    78e2:	696b      	ldr	r3, [r5, #20]
    78e4:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_MC(2);
    78e6:	682b      	ldr	r3, [r5, #0]
    78e8:	2220      	movs	r2, #32
    78ea:	729a      	strb	r2, [r3, #10]
	}
}
    78ec:	bd70      	pop	{r4, r5, r6, pc}
    78ee:	46c0      	nop			; (mov r8, r8)
    78f0:	2000135c 	.word	0x2000135c

000078f4 <TC0_Handler>:
		{ \
			_tc_interrupt_handler(m); \
		}

#if (SAML21E) || (SAML21G)
	_TC_INTERRUPT_HANDLER(0,0)
    78f4:	b510      	push	{r4, lr}
    78f6:	2000      	movs	r0, #0
    78f8:	4b01      	ldr	r3, [pc, #4]	; (7900 <TC0_Handler+0xc>)
    78fa:	4798      	blx	r3
    78fc:	bd10      	pop	{r4, pc}
    78fe:	46c0      	nop			; (mov r8, r8)
    7900:	00007899 	.word	0x00007899

00007904 <TC1_Handler>:
	_TC_INTERRUPT_HANDLER(1,1)
    7904:	b510      	push	{r4, lr}
    7906:	2001      	movs	r0, #1
    7908:	4b01      	ldr	r3, [pc, #4]	; (7910 <TC1_Handler+0xc>)
    790a:	4798      	blx	r3
    790c:	bd10      	pop	{r4, pc}
    790e:	46c0      	nop			; (mov r8, r8)
    7910:	00007899 	.word	0x00007899

00007914 <TC4_Handler>:
	_TC_INTERRUPT_HANDLER(4,2)
    7914:	b510      	push	{r4, lr}
    7916:	2002      	movs	r0, #2
    7918:	4b01      	ldr	r3, [pc, #4]	; (7920 <TC4_Handler+0xc>)
    791a:	4798      	blx	r3
    791c:	bd10      	pop	{r4, pc}
    791e:	46c0      	nop			; (mov r8, r8)
    7920:	00007899 	.word	0x00007899

00007924 <_tc_get_inst_index>:
 *
 * \return Index of the given TC module instance.
 */
uint8_t _tc_get_inst_index(
		Tc *const hw)
{
    7924:	b530      	push	{r4, r5, lr}
    7926:	b085      	sub	sp, #20
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
    7928:	aa01      	add	r2, sp, #4
    792a:	4b0b      	ldr	r3, [pc, #44]	; (7958 <_tc_get_inst_index+0x34>)
    792c:	cb32      	ldmia	r3!, {r1, r4, r5}
    792e:	c232      	stmia	r2!, {r1, r4, r5}

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
		if (hw == tc_modules[i]) {
    7930:	9b01      	ldr	r3, [sp, #4]
    7932:	4298      	cmp	r0, r3
    7934:	d00a      	beq.n	794c <_tc_get_inst_index+0x28>
    7936:	9b02      	ldr	r3, [sp, #8]
    7938:	4298      	cmp	r0, r3
    793a:	d005      	beq.n	7948 <_tc_get_inst_index+0x24>
		}
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
    793c:	2300      	movs	r3, #0
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
		if (hw == tc_modules[i]) {
    793e:	9a03      	ldr	r2, [sp, #12]
    7940:	4282      	cmp	r2, r0
    7942:	d105      	bne.n	7950 <_tc_get_inst_index+0x2c>
{
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    7944:	3302      	adds	r3, #2
    7946:	e002      	b.n	794e <_tc_get_inst_index+0x2a>
    7948:	2301      	movs	r3, #1
    794a:	e000      	b.n	794e <_tc_get_inst_index+0x2a>
    794c:	2300      	movs	r3, #0
		if (hw == tc_modules[i]) {
			return i;
    794e:	b2db      	uxtb	r3, r3
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
}
    7950:	0018      	movs	r0, r3
    7952:	b005      	add	sp, #20
    7954:	bd30      	pop	{r4, r5, pc}
    7956:	46c0      	nop			; (mov r8, r8)
    7958:	000133cc 	.word	0x000133cc

0000795c <tc_init>:
 */
enum status_code tc_init(
		struct tc_module *const module_inst,
		Tc *const hw,
		const struct tc_config *const config)
{
    795c:	b5f0      	push	{r4, r5, r6, r7, lr}
    795e:	4647      	mov	r7, r8
    7960:	b480      	push	{r7}
    7962:	b08a      	sub	sp, #40	; 0x28
    7964:	0005      	movs	r5, r0
    7966:	000e      	movs	r6, r1
    7968:	0017      	movs	r7, r2
	uint32_t ctrla_tmp = 0;
	/* Temporary variable to hold all updates to the CTRLBSET
	 * register before they are written to it */
	uint8_t ctrlbset_tmp = 0;
	/* Temporary variable to hold TC instance number */
	uint8_t instance = _tc_get_inst_index(hw);
    796a:	0008      	movs	r0, r1
    796c:	4ba6      	ldr	r3, [pc, #664]	; (7c08 <tc_init+0x2ac>)
    796e:	4798      	blx	r3
    7970:	4680      	mov	r8, r0
									SYSTEM_CLOCK_APB_APBC, MCLK_APBCMASK_TC1,
									SYSTEM_CLOCK_APB_APBC, MCLK_APBCMASK_TC2,
									SYSTEM_CLOCK_APB_APBC, MCLK_APBCMASK_TC3};
#else
	/* Array of GLCK ID for different TC instances */
	uint8_t inst_gclk_id[] = {TC0_GCLK_ID, TC1_GCLK_ID, TC4_GCLK_ID};
    7972:	4ca6      	ldr	r4, [pc, #664]	; (7c0c <tc_init+0x2b0>)
    7974:	0021      	movs	r1, r4
    7976:	310c      	adds	r1, #12
    7978:	2203      	movs	r2, #3
    797a:	a809      	add	r0, sp, #36	; 0x24
    797c:	4ba4      	ldr	r3, [pc, #656]	; (7c10 <tc_init+0x2b4>)
    797e:	4798      	blx	r3
	/* Array of PM APB mask bit position for different TC instances */
	uint32_t inst_mclk_apbmask[] = {SYSTEM_CLOCK_APB_APBC, MCLK_APBCMASK_TC0,
    7980:	a903      	add	r1, sp, #12
    7982:	0023      	movs	r3, r4
    7984:	3310      	adds	r3, #16
    7986:	000a      	movs	r2, r1
    7988:	cb13      	ldmia	r3!, {r0, r1, r4}
    798a:	c213      	stmia	r2!, {r0, r1, r4}
    798c:	cb13      	ldmia	r3!, {r0, r1, r4}
    798e:	c213      	stmia	r2!, {r0, r1, r4}
	struct system_gclk_chan_config gclk_chan_config;

#if TC_ASYNC == true
	/* Initialize parameters */
	for (uint8_t i = 0; i < TC_CALLBACK_N; i++) {
		module_inst->callback[i]        = NULL;
    7990:	2300      	movs	r3, #0
    7992:	60ab      	str	r3, [r5, #8]
    7994:	60eb      	str	r3, [r5, #12]
    7996:	612b      	str	r3, [r5, #16]
    7998:	616b      	str	r3, [r5, #20]
	}
	module_inst->register_callback_mask     = 0x00;
    799a:	762b      	strb	r3, [r5, #24]
	module_inst->enable_callback_mask       = 0x00;
    799c:	766b      	strb	r3, [r5, #25]

	/* Register this instance for callbacks*/
	_tc_instances[instance] = module_inst;
    799e:	4643      	mov	r3, r8
    79a0:	009a      	lsls	r2, r3, #2
    79a2:	4b9c      	ldr	r3, [pc, #624]	; (7c14 <tc_init+0x2b8>)
    79a4:	50d5      	str	r5, [r2, r3]
#endif

	/* Associate the given device instance with the hardware module */
	module_inst->hw = hw;
    79a6:	602e      	str	r6, [r5, #0]

	module_inst->double_buffering_enabled = config->double_buffering_enabled;
    79a8:	2334      	movs	r3, #52	; 0x34
    79aa:	5cfb      	ldrb	r3, [r7, r3]
    79ac:	76ab      	strb	r3, [r5, #26]

	/* Check if odd numbered TC modules are being configured in 32-bit
	 * counter size. Only even numbered counters are allowed to be
	 * configured in 32-bit counter size.
	 */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT) &&
    79ae:	78fb      	ldrb	r3, [r7, #3]
    79b0:	2b08      	cmp	r3, #8
    79b2:	d104      	bne.n	79be <tc_init+0x62>
			((instance + TC_INSTANCE_OFFSET) & 0x01)) {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    79b4:	2017      	movs	r0, #23

	/* Check if odd numbered TC modules are being configured in 32-bit
	 * counter size. Only even numbered counters are allowed to be
	 * configured in 32-bit counter size.
	 */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT) &&
    79b6:	4642      	mov	r2, r8
    79b8:	07d2      	lsls	r2, r2, #31
    79ba:	d500      	bpl.n	79be <tc_init+0x62>
    79bc:	e11f      	b.n	7bfe <tc_init+0x2a2>
	}

	/* Make the counter size variable in the module_inst struct reflect
	 * the counter size in the module
	 */
	module_inst->counter_size = config->counter_size;
    79be:	712b      	strb	r3, [r5, #4]

	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_SWRST) {
    79c0:	6833      	ldr	r3, [r6, #0]
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
    79c2:	2005      	movs	r0, #5
	/* Make the counter size variable in the module_inst struct reflect
	 * the counter size in the module
	 */
	module_inst->counter_size = config->counter_size;

	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_SWRST) {
    79c4:	07db      	lsls	r3, r3, #31
    79c6:	d500      	bpl.n	79ca <tc_init+0x6e>
    79c8:	e119      	b.n	7bfe <tc_init+0x2a2>
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
	}

	if (hw->COUNT8.STATUS.reg & TC_STATUS_SLAVE) {
    79ca:	7af3      	ldrb	r3, [r6, #11]
		/* Module is used as a slave */
		return STATUS_ERR_DENIED;
    79cc:	3017      	adds	r0, #23
	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_SWRST) {
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
	}

	if (hw->COUNT8.STATUS.reg & TC_STATUS_SLAVE) {
    79ce:	079b      	lsls	r3, r3, #30
    79d0:	d500      	bpl.n	79d4 <tc_init+0x78>
    79d2:	e114      	b.n	7bfe <tc_init+0x2a2>
		/* Module is used as a slave */
		return STATUS_ERR_DENIED;
	}

	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_ENABLE) {
    79d4:	6833      	ldr	r3, [r6, #0]
    79d6:	079b      	lsls	r3, r3, #30
    79d8:	d500      	bpl.n	79dc <tc_init+0x80>
    79da:	e110      	b.n	7bfe <tc_init+0x2a2>
		/* Module must be disabled before initialization. Abort. */
		return STATUS_ERR_DENIED;
	}

	/* Set up the TC PWM out pin for channel 0 */
	if (config->pwm_channel[0].enabled) {
    79dc:	7c3b      	ldrb	r3, [r7, #16]
    79de:	2b00      	cmp	r3, #0
    79e0:	d00a      	beq.n	79f8 <tc_init+0x9c>
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    79e2:	a902      	add	r1, sp, #8
    79e4:	2301      	movs	r3, #1
    79e6:	708b      	strb	r3, [r1, #2]
	config->powersave    = false;
    79e8:	2200      	movs	r2, #0
    79ea:	70ca      	strb	r2, [r1, #3]
		system_pinmux_get_config_defaults(&pin_config);
		pin_config.mux_position = config->pwm_channel[0].pin_mux;
    79ec:	7e3a      	ldrb	r2, [r7, #24]
    79ee:	700a      	strb	r2, [r1, #0]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
    79f0:	704b      	strb	r3, [r1, #1]
		system_pinmux_pin_set_config(
    79f2:	7d38      	ldrb	r0, [r7, #20]
    79f4:	4b88      	ldr	r3, [pc, #544]	; (7c18 <tc_init+0x2bc>)
    79f6:	4798      	blx	r3
				config->pwm_channel[0].pin_out, &pin_config);
	}

	/* Set up the TC PWM out pin for channel 1 */
	if (config->pwm_channel[1].enabled) {
    79f8:	7f3b      	ldrb	r3, [r7, #28]
    79fa:	2b00      	cmp	r3, #0
    79fc:	d00b      	beq.n	7a16 <tc_init+0xba>
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    79fe:	a902      	add	r1, sp, #8
    7a00:	2301      	movs	r3, #1
    7a02:	708b      	strb	r3, [r1, #2]
	config->powersave    = false;
    7a04:	2200      	movs	r2, #0
    7a06:	70ca      	strb	r2, [r1, #3]
		system_pinmux_get_config_defaults(&pin_config);
		pin_config.mux_position = config->pwm_channel[1].pin_mux;
    7a08:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    7a0a:	700a      	strb	r2, [r1, #0]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
    7a0c:	704b      	strb	r3, [r1, #1]
		system_pinmux_pin_set_config(
    7a0e:	6a3b      	ldr	r3, [r7, #32]
    7a10:	b2d8      	uxtb	r0, r3
    7a12:	4b81      	ldr	r3, [pc, #516]	; (7c18 <tc_init+0x2bc>)
    7a14:	4798      	blx	r3
				config->pwm_channel[1].pin_out, &pin_config);
	}

	/* Enable the user interface clock in the MCLK */
	system_apb_clock_set_mask((enum system_clock_apb_bus)inst_mclk_apbmask[instance*2],
    7a16:	4643      	mov	r3, r8
    7a18:	005a      	lsls	r2, r3, #1
    7a1a:	a803      	add	r0, sp, #12
    7a1c:	1c53      	adds	r3, r2, #1
    7a1e:	009b      	lsls	r3, r3, #2
    7a20:	5819      	ldr	r1, [r3, r0]
    7a22:	4643      	mov	r3, r8
    7a24:	00db      	lsls	r3, r3, #3
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
    7a26:	581b      	ldr	r3, [r3, r0]
    7a28:	b2d8      	uxtb	r0, r3
    7a2a:	2804      	cmp	r0, #4
    7a2c:	d81b      	bhi.n	7a66 <tc_init+0x10a>
    7a2e:	0083      	lsls	r3, r0, #2
    7a30:	487a      	ldr	r0, [pc, #488]	; (7c1c <tc_init+0x2c0>)
    7a32:	58c3      	ldr	r3, [r0, r3]
    7a34:	469f      	mov	pc, r3
		case SYSTEM_CLOCK_APB_APBA:
			MCLK->APBAMASK.reg |= mask;
    7a36:	487a      	ldr	r0, [pc, #488]	; (7c20 <tc_init+0x2c4>)
    7a38:	6943      	ldr	r3, [r0, #20]
    7a3a:	430b      	orrs	r3, r1
    7a3c:	6143      	str	r3, [r0, #20]
    7a3e:	e012      	b.n	7a66 <tc_init+0x10a>
			break;

		case SYSTEM_CLOCK_APB_APBB:
			MCLK->APBBMASK.reg |= mask;
    7a40:	4877      	ldr	r0, [pc, #476]	; (7c20 <tc_init+0x2c4>)
    7a42:	6983      	ldr	r3, [r0, #24]
    7a44:	430b      	orrs	r3, r1
    7a46:	6183      	str	r3, [r0, #24]
    7a48:	e00d      	b.n	7a66 <tc_init+0x10a>
			break;

		case SYSTEM_CLOCK_APB_APBC:
			MCLK->APBCMASK.reg |= mask;
    7a4a:	4875      	ldr	r0, [pc, #468]	; (7c20 <tc_init+0x2c4>)
    7a4c:	69c3      	ldr	r3, [r0, #28]
    7a4e:	430b      	orrs	r3, r1
    7a50:	61c3      	str	r3, [r0, #28]
    7a52:	e008      	b.n	7a66 <tc_init+0x10a>
			break;
		case SYSTEM_CLOCK_APB_APBD:
			MCLK->APBDMASK.reg |= mask;
    7a54:	4872      	ldr	r0, [pc, #456]	; (7c20 <tc_init+0x2c4>)
    7a56:	6a03      	ldr	r3, [r0, #32]
    7a58:	430b      	orrs	r3, r1
    7a5a:	6203      	str	r3, [r0, #32]
    7a5c:	e003      	b.n	7a66 <tc_init+0x10a>
			break;
		case SYSTEM_CLOCK_APB_APBE:
			MCLK->APBEMASK.reg |= mask;
    7a5e:	4870      	ldr	r0, [pc, #448]	; (7c20 <tc_init+0x2c4>)
    7a60:	6a43      	ldr	r3, [r0, #36]	; 0x24
    7a62:	430b      	orrs	r3, r1
    7a64:	6243      	str	r3, [r0, #36]	; 0x24
			inst_mclk_apbmask[2*instance+1]);

	/* Enable the slave counter if counter_size is 32-bit */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT) && (instance+1 < TC_INST_NUM))
    7a66:	78fb      	ldrb	r3, [r7, #3]
    7a68:	2b08      	cmp	r3, #8
    7a6a:	d126      	bne.n	7aba <tc_init+0x15e>
    7a6c:	4643      	mov	r3, r8
    7a6e:	3301      	adds	r3, #1
    7a70:	2b02      	cmp	r3, #2
    7a72:	dc22      	bgt.n	7aba <tc_init+0x15e>
	{
		/* Enable the user interface clock in the MCLK */
		system_apb_clock_set_mask((enum system_clock_apb_bus)inst_mclk_apbmask[instance*2+1],
    7a74:	3202      	adds	r2, #2
    7a76:	0092      	lsls	r2, r2, #2
    7a78:	ab03      	add	r3, sp, #12
    7a7a:	58d2      	ldr	r2, [r2, r3]
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
    7a7c:	b2cb      	uxtb	r3, r1
    7a7e:	2b04      	cmp	r3, #4
    7a80:	d81b      	bhi.n	7aba <tc_init+0x15e>
    7a82:	009b      	lsls	r3, r3, #2
    7a84:	4967      	ldr	r1, [pc, #412]	; (7c24 <tc_init+0x2c8>)
    7a86:	58cb      	ldr	r3, [r1, r3]
    7a88:	469f      	mov	pc, r3
		case SYSTEM_CLOCK_APB_APBA:
			MCLK->APBAMASK.reg |= mask;
    7a8a:	4965      	ldr	r1, [pc, #404]	; (7c20 <tc_init+0x2c4>)
    7a8c:	694b      	ldr	r3, [r1, #20]
    7a8e:	431a      	orrs	r2, r3
    7a90:	614a      	str	r2, [r1, #20]
    7a92:	e012      	b.n	7aba <tc_init+0x15e>
			break;

		case SYSTEM_CLOCK_APB_APBB:
			MCLK->APBBMASK.reg |= mask;
    7a94:	4962      	ldr	r1, [pc, #392]	; (7c20 <tc_init+0x2c4>)
    7a96:	698b      	ldr	r3, [r1, #24]
    7a98:	431a      	orrs	r2, r3
    7a9a:	618a      	str	r2, [r1, #24]
    7a9c:	e00d      	b.n	7aba <tc_init+0x15e>
			break;

		case SYSTEM_CLOCK_APB_APBC:
			MCLK->APBCMASK.reg |= mask;
    7a9e:	4960      	ldr	r1, [pc, #384]	; (7c20 <tc_init+0x2c4>)
    7aa0:	69cb      	ldr	r3, [r1, #28]
    7aa2:	431a      	orrs	r2, r3
    7aa4:	61ca      	str	r2, [r1, #28]
    7aa6:	e008      	b.n	7aba <tc_init+0x15e>
			break;
		case SYSTEM_CLOCK_APB_APBD:
			MCLK->APBDMASK.reg |= mask;
    7aa8:	495d      	ldr	r1, [pc, #372]	; (7c20 <tc_init+0x2c4>)
    7aaa:	6a0b      	ldr	r3, [r1, #32]
    7aac:	431a      	orrs	r2, r3
    7aae:	620a      	str	r2, [r1, #32]
    7ab0:	e003      	b.n	7aba <tc_init+0x15e>
			break;
		case SYSTEM_CLOCK_APB_APBE:
			MCLK->APBEMASK.reg |= mask;
    7ab2:	495b      	ldr	r1, [pc, #364]	; (7c20 <tc_init+0x2c4>)
    7ab4:	6a4b      	ldr	r3, [r1, #36]	; 0x24
    7ab6:	431a      	orrs	r2, r3
    7ab8:	624a      	str	r2, [r1, #36]	; 0x24
	}


	/* Setup clock for module */
	system_gclk_chan_get_config_defaults(&gclk_chan_config);
	gclk_chan_config.source_generator = config->clock_source;
    7aba:	a901      	add	r1, sp, #4
    7abc:	783b      	ldrb	r3, [r7, #0]
    7abe:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(inst_gclk_id[instance], &gclk_chan_config);
    7ac0:	ab09      	add	r3, sp, #36	; 0x24
    7ac2:	4642      	mov	r2, r8
    7ac4:	5c9c      	ldrb	r4, [r3, r2]
    7ac6:	0020      	movs	r0, r4
    7ac8:	4b57      	ldr	r3, [pc, #348]	; (7c28 <tc_init+0x2cc>)
    7aca:	4798      	blx	r3
	system_gclk_chan_enable(inst_gclk_id[instance]);
    7acc:	0020      	movs	r0, r4
    7ace:	4b57      	ldr	r3, [pc, #348]	; (7c2c <tc_init+0x2d0>)
    7ad0:	4798      	blx	r3

	/* Set ctrla register */
	ctrla_tmp =
    7ad2:	78fa      	ldrb	r2, [r7, #3]
    7ad4:	79fb      	ldrb	r3, [r7, #7]
    7ad6:	4313      	orrs	r3, r2
    7ad8:	88ba      	ldrh	r2, [r7, #4]
    7ada:	4313      	orrs	r3, r2
			(uint32_t)config->counter_size |
			(uint32_t)config->reload_action |
			(uint32_t)config->clock_prescaler;

	for (uint8_t i = 0; i < NUMBER_OF_COMPARE_CAPTURE_CHANNELS; i++) {
		if (config->enable_capture_on_channel[i] == true) {
    7adc:	7a7a      	ldrb	r2, [r7, #9]
    7ade:	2a00      	cmp	r2, #0
    7ae0:	d002      	beq.n	7ae8 <tc_init+0x18c>
			ctrla_tmp |= (TC_CTRLA_CAPTEN(1) << i);
    7ae2:	2280      	movs	r2, #128	; 0x80
    7ae4:	0252      	lsls	r2, r2, #9
    7ae6:	4313      	orrs	r3, r2
			(uint32_t)config->counter_size |
			(uint32_t)config->reload_action |
			(uint32_t)config->clock_prescaler;

	for (uint8_t i = 0; i < NUMBER_OF_COMPARE_CAPTURE_CHANNELS; i++) {
		if (config->enable_capture_on_channel[i] == true) {
    7ae8:	7aba      	ldrb	r2, [r7, #10]
    7aea:	2a00      	cmp	r2, #0
    7aec:	d002      	beq.n	7af4 <tc_init+0x198>
			ctrla_tmp |= (TC_CTRLA_CAPTEN(1) << i);
    7aee:	2280      	movs	r2, #128	; 0x80
    7af0:	0292      	lsls	r2, r2, #10
    7af2:	4313      	orrs	r3, r2
		}
	}

	for (uint8_t i = 0; i < NUMBER_OF_COMPARE_CAPTURE_CHANNELS; i++) {
		if (config->enable_capture_on_IO[i] == true) {
    7af4:	7afa      	ldrb	r2, [r7, #11]
    7af6:	2a00      	cmp	r2, #0
    7af8:	d002      	beq.n	7b00 <tc_init+0x1a4>
			ctrla_tmp |= (TC_CTRLA_COPEN(1) << i);
    7afa:	2280      	movs	r2, #128	; 0x80
    7afc:	0352      	lsls	r2, r2, #13
    7afe:	4313      	orrs	r3, r2
			ctrla_tmp |= (TC_CTRLA_CAPTEN(1) << i);
		}
	}

	for (uint8_t i = 0; i < NUMBER_OF_COMPARE_CAPTURE_CHANNELS; i++) {
		if (config->enable_capture_on_IO[i] == true) {
    7b00:	7b3a      	ldrb	r2, [r7, #12]
    7b02:	2a00      	cmp	r2, #0
    7b04:	d002      	beq.n	7b0c <tc_init+0x1b0>
			ctrla_tmp |= (TC_CTRLA_COPEN(1) << i);
    7b06:	2280      	movs	r2, #128	; 0x80
    7b08:	0392      	lsls	r2, r2, #14
    7b0a:	4313      	orrs	r3, r2
		}
	}

	ctrla_tmp |= (config->run_in_standby << TC_CTRLA_RUNSTDBY_Pos)
    7b0c:	7879      	ldrb	r1, [r7, #1]
    7b0e:	0189      	lsls	r1, r1, #6
    7b10:	78ba      	ldrb	r2, [r7, #2]
    7b12:	01d2      	lsls	r2, r2, #7
    7b14:	4311      	orrs	r1, r2
    7b16:	4319      	orrs	r1, r3
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    7b18:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    7b1a:	6913      	ldr	r3, [r2, #16]
				|(config->on_demand << TC_CTRLA_ONDEMAND_Pos);

	/* Write configuration to register */
	while (tc_is_syncing(module_inst)) {
    7b1c:	2b00      	cmp	r3, #0
    7b1e:	d1fc      	bne.n	7b1a <tc_init+0x1be>
		/* Wait for sync */
	}
	hw->COUNT8.CTRLA.reg = ctrla_tmp;
    7b20:	6031      	str	r1, [r6, #0]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    7b22:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    7b24:	6913      	ldr	r3, [r2, #16]

	/* Write configuration to register */
	while (tc_is_syncing(module_inst)) {
    7b26:	2b00      	cmp	r3, #0
    7b28:	d1fc      	bne.n	7b24 <tc_init+0x1c8>
		/* Wait for sync */
	}
	hw->COUNT8.WAVE.reg = config->wave_generation;
    7b2a:	79bb      	ldrb	r3, [r7, #6]
    7b2c:	7333      	strb	r3, [r6, #12]

	/* Set ctrlb register */
	if (config->oneshot) {
    7b2e:	7b79      	ldrb	r1, [r7, #13]
		ctrlbset_tmp = TC_CTRLBSET_ONESHOT;
    7b30:	1e4b      	subs	r3, r1, #1
    7b32:	4199      	sbcs	r1, r3
    7b34:	0089      	lsls	r1, r1, #2
	}

	if (config->count_direction) {
    7b36:	7bbb      	ldrb	r3, [r7, #14]
    7b38:	2b00      	cmp	r3, #0
    7b3a:	d001      	beq.n	7b40 <tc_init+0x1e4>
		ctrlbset_tmp |= TC_CTRLBSET_DIR;
    7b3c:	2301      	movs	r3, #1
    7b3e:	4319      	orrs	r1, r3
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    7b40:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    7b42:	6913      	ldr	r3, [r2, #16]
	}

	/* Clear old ctrlb configuration */
	while (tc_is_syncing(module_inst)) {
    7b44:	2b00      	cmp	r3, #0
    7b46:	d1fc      	bne.n	7b42 <tc_init+0x1e6>
		/* Wait for sync */
	}
	hw->COUNT8.CTRLBCLR.reg = 0xFF;
    7b48:	33ff      	adds	r3, #255	; 0xff
    7b4a:	7133      	strb	r3, [r6, #4]

	/* Check if we actually need to go into a wait state. */
	if (ctrlbset_tmp) {
    7b4c:	2900      	cmp	r1, #0
    7b4e:	d004      	beq.n	7b5a <tc_init+0x1fe>
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    7b50:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    7b52:	6913      	ldr	r3, [r2, #16]
		while (tc_is_syncing(module_inst)) {
    7b54:	2b00      	cmp	r3, #0
    7b56:	d1fc      	bne.n	7b52 <tc_init+0x1f6>
			/* Wait for sync */
		}
		/* Write configuration to register */
		hw->COUNT8.CTRLBSET.reg = ctrlbset_tmp;
    7b58:	7171      	strb	r1, [r6, #5]
	}

	/* Set drvvtrl register*/
	hw->COUNT8.DRVCTRL.reg = config->waveform_invert_output;
    7b5a:	7a3b      	ldrb	r3, [r7, #8]
    7b5c:	7373      	strb	r3, [r6, #13]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    7b5e:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    7b60:	6913      	ldr	r3, [r2, #16]

	/* Write configuration to register */
	while (tc_is_syncing(module_inst)) {
    7b62:	2b00      	cmp	r3, #0
    7b64:	d1fc      	bne.n	7b60 <tc_init+0x204>
		/* Wait for sync */
	}

	/* Switch for TC counter size  */
	switch (module_inst->counter_size) {
    7b66:	792b      	ldrb	r3, [r5, #4]
    7b68:	2b04      	cmp	r3, #4
    7b6a:	d005      	beq.n	7b78 <tc_init+0x21c>
    7b6c:	2b08      	cmp	r3, #8
    7b6e:	d033      	beq.n	7bd8 <tc_init+0x27c>

			return STATUS_OK;
	}

	Assert(false);
	return STATUS_ERR_INVALID_ARG;
    7b70:	2017      	movs	r0, #23
	while (tc_is_syncing(module_inst)) {
		/* Wait for sync */
	}

	/* Switch for TC counter size  */
	switch (module_inst->counter_size) {
    7b72:	2b00      	cmp	r3, #0
    7b74:	d143      	bne.n	7bfe <tc_init+0x2a2>
    7b76:	e01c      	b.n	7bb2 <tc_init+0x256>
    7b78:	6913      	ldr	r3, [r2, #16]
		case TC_COUNTER_SIZE_8BIT:
			while (tc_is_syncing(module_inst)) {
    7b7a:	2b00      	cmp	r3, #0
    7b7c:	d1fc      	bne.n	7b78 <tc_init+0x21c>
				/* Wait for sync */
			}

			hw->COUNT8.COUNT.reg =
					config->counter_8_bit.value;
    7b7e:	3328      	adds	r3, #40	; 0x28
    7b80:	5cfb      	ldrb	r3, [r7, r3]
		case TC_COUNTER_SIZE_8BIT:
			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.COUNT.reg =
    7b82:	7533      	strb	r3, [r6, #20]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    7b84:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    7b86:	6913      	ldr	r3, [r2, #16]
					config->counter_8_bit.value;


			while (tc_is_syncing(module_inst)) {
    7b88:	2b00      	cmp	r3, #0
    7b8a:	d1fc      	bne.n	7b86 <tc_init+0x22a>
				/* Wait for sync */
			}

			hw->COUNT8.PER.reg =
					config->counter_8_bit.period;
    7b8c:	3329      	adds	r3, #41	; 0x29
    7b8e:	5cfb      	ldrb	r3, [r7, r3]

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.PER.reg =
    7b90:	76f3      	strb	r3, [r6, #27]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    7b92:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    7b94:	6913      	ldr	r3, [r2, #16]
					config->counter_8_bit.period;

			while (tc_is_syncing(module_inst)) {
    7b96:	2b00      	cmp	r3, #0
    7b98:	d1fc      	bne.n	7b94 <tc_init+0x238>
				/* Wait for sync */
			}

			hw->COUNT8.CC[0].reg =
					config->counter_8_bit.compare_capture_channel[0];
    7b9a:	332a      	adds	r3, #42	; 0x2a
    7b9c:	5cfb      	ldrb	r3, [r7, r3]

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.CC[0].reg =
    7b9e:	7733      	strb	r3, [r6, #28]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    7ba0:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    7ba2:	6913      	ldr	r3, [r2, #16]
					config->counter_8_bit.compare_capture_channel[0];

			while (tc_is_syncing(module_inst)) {
    7ba4:	2b00      	cmp	r3, #0
    7ba6:	d1fc      	bne.n	7ba2 <tc_init+0x246>
				/* Wait for sync */
			}

			hw->COUNT8.CC[1].reg =
					config->counter_8_bit.compare_capture_channel[1];
    7ba8:	332b      	adds	r3, #43	; 0x2b
    7baa:	5cfb      	ldrb	r3, [r7, r3]

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.CC[1].reg =
    7bac:	7773      	strb	r3, [r6, #29]
					config->counter_8_bit.compare_capture_channel[1];

			return STATUS_OK;
    7bae:	2000      	movs	r0, #0
    7bb0:	e025      	b.n	7bfe <tc_init+0x2a2>
    7bb2:	6913      	ldr	r3, [r2, #16]

		case TC_COUNTER_SIZE_16BIT:
			while (tc_is_syncing(module_inst)) {
    7bb4:	2b00      	cmp	r3, #0
    7bb6:	d1fc      	bne.n	7bb2 <tc_init+0x256>
				/* Wait for sync */
			}

			hw->COUNT16.COUNT.reg
				= config->counter_16_bit.value;
    7bb8:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
    7bba:	82b3      	strh	r3, [r6, #20]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    7bbc:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    7bbe:	6913      	ldr	r3, [r2, #16]

			while (tc_is_syncing(module_inst)) {
    7bc0:	2b00      	cmp	r3, #0
    7bc2:	d1fc      	bne.n	7bbe <tc_init+0x262>
				/* Wait for sync */
			}

			hw->COUNT16.CC[0].reg =
					config->counter_16_bit.compare_capture_channel[0];
    7bc4:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT16.CC[0].reg =
    7bc6:	83b3      	strh	r3, [r6, #28]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    7bc8:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    7bca:	6913      	ldr	r3, [r2, #16]
					config->counter_16_bit.compare_capture_channel[0];

			while (tc_is_syncing(module_inst)) {
    7bcc:	2b00      	cmp	r3, #0
    7bce:	d1fc      	bne.n	7bca <tc_init+0x26e>
				/* Wait for sync */
			}

			hw->COUNT16.CC[1].reg =
					config->counter_16_bit.compare_capture_channel[1];
    7bd0:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT16.CC[1].reg =
    7bd2:	83f3      	strh	r3, [r6, #30]
					config->counter_16_bit.compare_capture_channel[1];

			return STATUS_OK;
    7bd4:	2000      	movs	r0, #0
    7bd6:	e012      	b.n	7bfe <tc_init+0x2a2>
    7bd8:	6913      	ldr	r3, [r2, #16]

		case TC_COUNTER_SIZE_32BIT:
			while (tc_is_syncing(module_inst)) {
    7bda:	2b00      	cmp	r3, #0
    7bdc:	d1fc      	bne.n	7bd8 <tc_init+0x27c>
				/* Wait for sync */
			}

			hw->COUNT32.COUNT.reg
				= config->counter_32_bit.value;
    7bde:	6abb      	ldr	r3, [r7, #40]	; 0x28
    7be0:	6173      	str	r3, [r6, #20]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    7be2:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    7be4:	6913      	ldr	r3, [r2, #16]

			while (tc_is_syncing(module_inst)) {
    7be6:	2b00      	cmp	r3, #0
    7be8:	d1fc      	bne.n	7be4 <tc_init+0x288>
				/* Wait for sync */
			}

			hw->COUNT32.CC[0].reg =
    7bea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    7bec:	61f3      	str	r3, [r6, #28]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    7bee:	682a      	ldr	r2, [r5, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    7bf0:	6913      	ldr	r3, [r2, #16]
					config->counter_32_bit.compare_capture_channel[0];

			while (tc_is_syncing(module_inst)) {
    7bf2:	2b00      	cmp	r3, #0
    7bf4:	d1fc      	bne.n	7bf0 <tc_init+0x294>
				/* Wait for sync */
			}

			hw->COUNT32.CC[1].reg =
					config->counter_32_bit.compare_capture_channel[1];
    7bf6:	6b3b      	ldr	r3, [r7, #48]	; 0x30

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT32.CC[1].reg =
    7bf8:	6233      	str	r3, [r6, #32]
					config->counter_32_bit.compare_capture_channel[1];

			return STATUS_OK;
    7bfa:	2000      	movs	r0, #0
    7bfc:	e7ff      	b.n	7bfe <tc_init+0x2a2>
	}

	Assert(false);
	return STATUS_ERR_INVALID_ARG;
}
    7bfe:	b00a      	add	sp, #40	; 0x28
    7c00:	bc04      	pop	{r2}
    7c02:	4690      	mov	r8, r2
    7c04:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7c06:	46c0      	nop			; (mov r8, r8)
    7c08:	00007925 	.word	0x00007925
    7c0c:	000133cc 	.word	0x000133cc
    7c10:	0000a74d 	.word	0x0000a74d
    7c14:	2000135c 	.word	0x2000135c
    7c18:	00007811 	.word	0x00007811
    7c1c:	000133a4 	.word	0x000133a4
    7c20:	40000400 	.word	0x40000400
    7c24:	000133b8 	.word	0x000133b8
    7c28:	00007715 	.word	0x00007715
    7c2c:	000076a5 	.word	0x000076a5

00007c30 <tc_set_count_value>:
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance*/
	Tc *const tc_module = module_inst->hw;
    7c30:	6802      	ldr	r2, [r0, #0]
    7c32:	6913      	ldr	r3, [r2, #16]

	while (tc_is_syncing(module_inst)) {
    7c34:	2b00      	cmp	r3, #0
    7c36:	d1fc      	bne.n	7c32 <tc_set_count_value+0x2>
		/* Wait for sync */
	}

	/* Write to based on the TC counter_size */
	switch (module_inst->counter_size) {
    7c38:	7903      	ldrb	r3, [r0, #4]
    7c3a:	2b04      	cmp	r3, #4
    7c3c:	d005      	beq.n	7c4a <tc_set_count_value+0x1a>
    7c3e:	2b08      	cmp	r3, #8
    7c40:	d00b      	beq.n	7c5a <tc_set_count_value+0x2a>
		case TC_COUNTER_SIZE_32BIT:
			tc_module->COUNT32.COUNT.reg = (uint32_t)count;
			return STATUS_OK;

		default:
			return STATUS_ERR_INVALID_ARG;
    7c42:	2017      	movs	r0, #23
	while (tc_is_syncing(module_inst)) {
		/* Wait for sync */
	}

	/* Write to based on the TC counter_size */
	switch (module_inst->counter_size) {
    7c44:	2b00      	cmp	r3, #0
    7c46:	d10b      	bne.n	7c60 <tc_set_count_value+0x30>
    7c48:	e003      	b.n	7c52 <tc_set_count_value+0x22>
		case TC_COUNTER_SIZE_8BIT:
			tc_module->COUNT8.COUNT.reg  = (uint8_t)count;
    7c4a:	b2c9      	uxtb	r1, r1
    7c4c:	7511      	strb	r1, [r2, #20]
			return STATUS_OK;
    7c4e:	2000      	movs	r0, #0
    7c50:	e006      	b.n	7c60 <tc_set_count_value+0x30>

		case TC_COUNTER_SIZE_16BIT:
			tc_module->COUNT16.COUNT.reg = (uint16_t)count;
    7c52:	b289      	uxth	r1, r1
    7c54:	8291      	strh	r1, [r2, #20]
			return STATUS_OK;
    7c56:	2000      	movs	r0, #0
    7c58:	e002      	b.n	7c60 <tc_set_count_value+0x30>

		case TC_COUNTER_SIZE_32BIT:
			tc_module->COUNT32.COUNT.reg = (uint32_t)count;
    7c5a:	6151      	str	r1, [r2, #20]
			return STATUS_OK;
    7c5c:	2000      	movs	r0, #0
    7c5e:	e7ff      	b.n	7c60 <tc_set_count_value+0x30>

		default:
			return STATUS_ERR_INVALID_ARG;
	}
}
    7c60:	4770      	bx	lr
    7c62:	46c0      	nop			; (mov r8, r8)

00007c64 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    7c64:	e7fe      	b.n	7c64 <Dummy_Handler>
    7c66:	46c0      	nop			; (mov r8, r8)

00007c68 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    7c68:	b510      	push	{r4, lr}

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
    7c6a:	4b1d      	ldr	r3, [pc, #116]	; (7ce0 <Reset_Handler+0x78>)
    7c6c:	4a1d      	ldr	r2, [pc, #116]	; (7ce4 <Reset_Handler+0x7c>)
    7c6e:	429a      	cmp	r2, r3
    7c70:	d003      	beq.n	7c7a <Reset_Handler+0x12>
                for (; pDest < &_erelocate;) {
    7c72:	4b1d      	ldr	r3, [pc, #116]	; (7ce8 <Reset_Handler+0x80>)
    7c74:	4a1a      	ldr	r2, [pc, #104]	; (7ce0 <Reset_Handler+0x78>)
    7c76:	429a      	cmp	r2, r3
    7c78:	d304      	bcc.n	7c84 <Reset_Handler+0x1c>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    7c7a:	4b1c      	ldr	r3, [pc, #112]	; (7cec <Reset_Handler+0x84>)
    7c7c:	4a1c      	ldr	r2, [pc, #112]	; (7cf0 <Reset_Handler+0x88>)
    7c7e:	429a      	cmp	r2, r3
    7c80:	d310      	bcc.n	7ca4 <Reset_Handler+0x3c>
    7c82:	e01e      	b.n	7cc2 <Reset_Handler+0x5a>
    7c84:	4a1b      	ldr	r2, [pc, #108]	; (7cf4 <Reset_Handler+0x8c>)
    7c86:	4b18      	ldr	r3, [pc, #96]	; (7ce8 <Reset_Handler+0x80>)
    7c88:	3303      	adds	r3, #3
    7c8a:	1a9b      	subs	r3, r3, r2
    7c8c:	089b      	lsrs	r3, r3, #2
    7c8e:	3301      	adds	r3, #1
    7c90:	009b      	lsls	r3, r3, #2
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    7c92:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
    7c94:	4812      	ldr	r0, [pc, #72]	; (7ce0 <Reset_Handler+0x78>)
    7c96:	4913      	ldr	r1, [pc, #76]	; (7ce4 <Reset_Handler+0x7c>)
    7c98:	588c      	ldr	r4, [r1, r2]
    7c9a:	5084      	str	r4, [r0, r2]
    7c9c:	3204      	adds	r2, #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    7c9e:	429a      	cmp	r2, r3
    7ca0:	d1fa      	bne.n	7c98 <Reset_Handler+0x30>
    7ca2:	e7ea      	b.n	7c7a <Reset_Handler+0x12>
    7ca4:	4a14      	ldr	r2, [pc, #80]	; (7cf8 <Reset_Handler+0x90>)
    7ca6:	4b11      	ldr	r3, [pc, #68]	; (7cec <Reset_Handler+0x84>)
    7ca8:	3303      	adds	r3, #3
    7caa:	1a9b      	subs	r3, r3, r2
    7cac:	089b      	lsrs	r3, r3, #2
    7cae:	3301      	adds	r3, #1
    7cb0:	009b      	lsls	r3, r3, #2
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    7cb2:	2200      	movs	r2, #0
                *pDest++ = 0;
    7cb4:	480e      	ldr	r0, [pc, #56]	; (7cf0 <Reset_Handler+0x88>)
    7cb6:	2100      	movs	r1, #0
    7cb8:	1814      	adds	r4, r2, r0
    7cba:	6021      	str	r1, [r4, #0]
    7cbc:	3204      	adds	r2, #4
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    7cbe:	429a      	cmp	r2, r3
    7cc0:	d1fa      	bne.n	7cb8 <Reset_Handler+0x50>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    7cc2:	4a0e      	ldr	r2, [pc, #56]	; (7cfc <Reset_Handler+0x94>)
    7cc4:	21ff      	movs	r1, #255	; 0xff
    7cc6:	4b0e      	ldr	r3, [pc, #56]	; (7d00 <Reset_Handler+0x98>)
    7cc8:	438b      	bics	r3, r1
    7cca:	6093      	str	r3, [r2, #8]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
    7ccc:	4a0d      	ldr	r2, [pc, #52]	; (7d04 <Reset_Handler+0x9c>)
    7cce:	6851      	ldr	r1, [r2, #4]
    7cd0:	2380      	movs	r3, #128	; 0x80
    7cd2:	430b      	orrs	r3, r1
    7cd4:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
    7cd6:	4b0c      	ldr	r3, [pc, #48]	; (7d08 <Reset_Handler+0xa0>)
    7cd8:	4798      	blx	r3

        /* Branch to main function */
        main();
    7cda:	4b0c      	ldr	r3, [pc, #48]	; (7d0c <Reset_Handler+0xa4>)
    7cdc:	4798      	blx	r3
    7cde:	e7fe      	b.n	7cde <Reset_Handler+0x76>
    7ce0:	20000000 	.word	0x20000000
    7ce4:	000137c0 	.word	0x000137c0
    7ce8:	20000134 	.word	0x20000134
    7cec:	200013e0 	.word	0x200013e0
    7cf0:	20000134 	.word	0x20000134
    7cf4:	20000004 	.word	0x20000004
    7cf8:	20000138 	.word	0x20000138
    7cfc:	e000ed00 	.word	0xe000ed00
    7d00:	00000000 	.word	0x00000000
    7d04:	41004000 	.word	0x41004000
    7d08:	0000a701 	.word	0x0000a701
    7d0c:	000081d1 	.word	0x000081d1

00007d10 <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
    7d10:	b5f0      	push	{r4, r5, r6, r7, lr}
    7d12:	4647      	mov	r7, r8
    7d14:	b480      	push	{r7}
    7d16:	000c      	movs	r4, r1
    7d18:	4690      	mov	r8, r2
	int nChars = 0;

	if (file != 0) {
    7d1a:	2800      	cmp	r0, #0
    7d1c:	d10d      	bne.n	7d3a <_read+0x2a>
		return -1;
	}

	for (; len > 0; --len) {
    7d1e:	2a00      	cmp	r2, #0
    7d20:	dd0e      	ble.n	7d40 <_read+0x30>
    7d22:	188f      	adds	r7, r1, r2
		ptr_get(stdio_base, ptr);
    7d24:	4e08      	ldr	r6, [pc, #32]	; (7d48 <_read+0x38>)
    7d26:	4d09      	ldr	r5, [pc, #36]	; (7d4c <_read+0x3c>)
    7d28:	6830      	ldr	r0, [r6, #0]
    7d2a:	0021      	movs	r1, r4
    7d2c:	682b      	ldr	r3, [r5, #0]
    7d2e:	4798      	blx	r3
		ptr++;
    7d30:	3401      	adds	r4, #1

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
    7d32:	42a7      	cmp	r7, r4
    7d34:	d1f8      	bne.n	7d28 <_read+0x18>
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
    7d36:	4640      	mov	r0, r8
    7d38:	e003      	b.n	7d42 <_read+0x32>
_read (int file, char * ptr, int len)
{
	int nChars = 0;

	if (file != 0) {
		return -1;
    7d3a:	2001      	movs	r0, #1
    7d3c:	4240      	negs	r0, r0
    7d3e:	e000      	b.n	7d42 <_read+0x32>
	}

	for (; len > 0; --len) {
    7d40:	2000      	movs	r0, #0
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
}
    7d42:	bc04      	pop	{r2}
    7d44:	4690      	mov	r8, r2
    7d46:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7d48:	20001370 	.word	0x20001370
    7d4c:	20001368 	.word	0x20001368

00007d50 <_write>:
int __attribute__((weak))
_write (int file, char * ptr, int len);

int __attribute__((weak))
_write (int file, char * ptr, int len)
{
    7d50:	b5f0      	push	{r4, r5, r6, r7, lr}
    7d52:	4647      	mov	r7, r8
    7d54:	b480      	push	{r7}
    7d56:	000e      	movs	r6, r1
    7d58:	0015      	movs	r5, r2
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
    7d5a:	3801      	subs	r0, #1
    7d5c:	2802      	cmp	r0, #2
    7d5e:	d811      	bhi.n	7d84 <_write+0x34>
		return -1;
	}

	for (; len != 0; --len) {
    7d60:	2a00      	cmp	r2, #0
    7d62:	d012      	beq.n	7d8a <_write+0x3a>
    7d64:	2400      	movs	r4, #0
		if (ptr_put(stdio_base, *ptr++) < 0) {
    7d66:	4b0c      	ldr	r3, [pc, #48]	; (7d98 <_write+0x48>)
    7d68:	4698      	mov	r8, r3
    7d6a:	4f0c      	ldr	r7, [pc, #48]	; (7d9c <_write+0x4c>)
    7d6c:	4643      	mov	r3, r8
    7d6e:	6818      	ldr	r0, [r3, #0]
    7d70:	5d31      	ldrb	r1, [r6, r4]
    7d72:	683b      	ldr	r3, [r7, #0]
    7d74:	4798      	blx	r3
    7d76:	2800      	cmp	r0, #0
    7d78:	db09      	blt.n	7d8e <_write+0x3e>
			return -1;
		}
		++nChars;
    7d7a:	3401      	adds	r4, #1

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
    7d7c:	42a5      	cmp	r5, r4
    7d7e:	d1f5      	bne.n	7d6c <_write+0x1c>
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
    7d80:	0020      	movs	r0, r4
    7d82:	e006      	b.n	7d92 <_write+0x42>
_write (int file, char * ptr, int len)
{
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
    7d84:	2001      	movs	r0, #1
    7d86:	4240      	negs	r0, r0
    7d88:	e003      	b.n	7d92 <_write+0x42>
	}

	for (; len != 0; --len) {
    7d8a:	2000      	movs	r0, #0
    7d8c:	e001      	b.n	7d92 <_write+0x42>
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
    7d8e:	2001      	movs	r0, #1
    7d90:	4240      	negs	r0, r0
		}
		++nChars;
	}
	return nChars;
}
    7d92:	bc04      	pop	{r2}
    7d94:	4690      	mov	r8, r2
    7d96:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7d98:	20001370 	.word	0x20001370
    7d9c:	2000136c 	.word	0x2000136c

00007da0 <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
    7da0:	0003      	movs	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
    7da2:	4a06      	ldr	r2, [pc, #24]	; (7dbc <_sbrk+0x1c>)
    7da4:	6812      	ldr	r2, [r2, #0]
    7da6:	2a00      	cmp	r2, #0
    7da8:	d102      	bne.n	7db0 <_sbrk+0x10>
		heap = (unsigned char *)&_end;
    7daa:	4905      	ldr	r1, [pc, #20]	; (7dc0 <_sbrk+0x20>)
    7dac:	4a03      	ldr	r2, [pc, #12]	; (7dbc <_sbrk+0x1c>)
    7dae:	6011      	str	r1, [r2, #0]
	}
	prev_heap = heap;
    7db0:	4a02      	ldr	r2, [pc, #8]	; (7dbc <_sbrk+0x1c>)
    7db2:	6810      	ldr	r0, [r2, #0]

	heap += incr;
    7db4:	18c3      	adds	r3, r0, r3
    7db6:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap;
}
    7db8:	4770      	bx	lr
    7dba:	46c0      	nop			; (mov r8, r8)
    7dbc:	200003c8 	.word	0x200003c8
    7dc0:	200033e0 	.word	0x200033e0

00007dc4 <_close>:
}

extern int _close(int file)
{
	return -1;
}
    7dc4:	2001      	movs	r0, #1
    7dc6:	4240      	negs	r0, r0
    7dc8:	4770      	bx	lr
    7dca:	46c0      	nop			; (mov r8, r8)

00007dcc <_fstat>:

extern int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
    7dcc:	2380      	movs	r3, #128	; 0x80
    7dce:	019b      	lsls	r3, r3, #6
    7dd0:	604b      	str	r3, [r1, #4]

	return 0;
}
    7dd2:	2000      	movs	r0, #0
    7dd4:	4770      	bx	lr
    7dd6:	46c0      	nop			; (mov r8, r8)

00007dd8 <_isatty>:

extern int _isatty(int file)
{
	return 1;
}
    7dd8:	2001      	movs	r0, #1
    7dda:	4770      	bx	lr

00007ddc <_lseek>:

extern int _lseek(int file, int ptr, int dir)
{
	return 0;
}
    7ddc:	2000      	movs	r0, #0
    7dde:	4770      	bx	lr

00007de0 <usart_serial_getchar>:
 * \param[out]    c       Destination for the read character.
 */
static inline void usart_serial_getchar(
		struct usart_module *const module,
		uint8_t *c)
{
    7de0:	b570      	push	{r4, r5, r6, lr}
    7de2:	b082      	sub	sp, #8
    7de4:	0005      	movs	r5, r0
    7de6:	000e      	movs	r6, r1
	uint16_t temp = 0;
    7de8:	2200      	movs	r2, #0
    7dea:	466b      	mov	r3, sp
    7dec:	80da      	strh	r2, [r3, #6]

	while(STATUS_OK != usart_read_wait(module, &temp));
    7dee:	4c06      	ldr	r4, [pc, #24]	; (7e08 <usart_serial_getchar+0x28>)
    7df0:	466b      	mov	r3, sp
    7df2:	1d99      	adds	r1, r3, #6
    7df4:	0028      	movs	r0, r5
    7df6:	47a0      	blx	r4
    7df8:	2800      	cmp	r0, #0
    7dfa:	d1f9      	bne.n	7df0 <usart_serial_getchar+0x10>

	*c = temp;
    7dfc:	466b      	mov	r3, sp
    7dfe:	3306      	adds	r3, #6
    7e00:	881b      	ldrh	r3, [r3, #0]
    7e02:	7033      	strb	r3, [r6, #0]
}
    7e04:	b002      	add	sp, #8
    7e06:	bd70      	pop	{r4, r5, r6, pc}
    7e08:	00006dfd 	.word	0x00006dfd

00007e0c <usart_serial_putchar>:
 * \return Status code
 */
static inline enum status_code usart_serial_putchar(
		struct usart_module *const module,
		uint8_t c)
{
    7e0c:	b570      	push	{r4, r5, r6, lr}
    7e0e:	0005      	movs	r5, r0
	while(STATUS_OK !=usart_write_wait(module, c));
    7e10:	b28c      	uxth	r4, r1
    7e12:	4e03      	ldr	r6, [pc, #12]	; (7e20 <usart_serial_putchar+0x14>)
    7e14:	0021      	movs	r1, r4
    7e16:	0028      	movs	r0, r5
    7e18:	47b0      	blx	r6
    7e1a:	2800      	cmp	r0, #0
    7e1c:	d1fa      	bne.n	7e14 <usart_serial_putchar+0x8>

	return STATUS_OK;
}
    7e1e:	bd70      	pop	{r4, r5, r6, pc}
    7e20:	00006dd1 	.word	0x00006dd1

00007e24 <serial_console_init>:

/**
 *  Configure console.
 */
void serial_console_init(void)
{
    7e24:	b5f0      	push	{r4, r5, r6, r7, lr}
    7e26:	b091      	sub	sp, #68	; 0x44
{
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    7e28:	2380      	movs	r3, #128	; 0x80
    7e2a:	05db      	lsls	r3, r3, #23
    7e2c:	9300      	str	r3, [sp, #0]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    7e2e:	2300      	movs	r3, #0
    7e30:	9301      	str	r3, [sp, #4]
	config->parity           = USART_PARITY_NONE;
    7e32:	22ff      	movs	r2, #255	; 0xff
    7e34:	4669      	mov	r1, sp
    7e36:	810a      	strh	r2, [r1, #8]
	config->stopbits         = USART_STOPBITS_1;
    7e38:	2200      	movs	r2, #0
    7e3a:	728b      	strb	r3, [r1, #10]
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
    7e3c:	72cb      	strb	r3, [r1, #11]
	config->baudrate         = 9600;
	config->receiver_enable  = true;
    7e3e:	2401      	movs	r4, #1
    7e40:	2124      	movs	r1, #36	; 0x24
    7e42:	4668      	mov	r0, sp
    7e44:	5444      	strb	r4, [r0, r1]
	config->transmitter_enable = true;
    7e46:	3101      	adds	r1, #1
    7e48:	5444      	strb	r4, [r0, r1]
	config->clock_polarity_inverted = false;
    7e4a:	3101      	adds	r1, #1
    7e4c:	5443      	strb	r3, [r0, r1]
	config->use_external_clock = false;
    7e4e:	3101      	adds	r1, #1
    7e50:	5443      	strb	r3, [r0, r1]
	config->ext_clock_freq   = 0;
    7e52:	930a      	str	r3, [sp, #40]	; 0x28
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
	config->run_in_standby   = false;
    7e54:	3105      	adds	r1, #5
    7e56:	5443      	strb	r3, [r0, r1]
	config->generator_source = GCLK_GENERATOR_0;
    7e58:	3101      	adds	r1, #1
    7e5a:	5443      	strb	r3, [r0, r1]
	config->pinmux_pad0      = PINMUX_DEFAULT;
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->pinmux_pad2      = PINMUX_DEFAULT;
	config->pinmux_pad3      = PINMUX_DEFAULT;
#ifdef FEATURE_USART_OVER_SAMPLE
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
    7e5c:	9305      	str	r3, [sp, #20]
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
    7e5e:	8203      	strh	r3, [r0, #16]
#endif
#ifdef FEATURE_USART_LIN_SLAVE
	config->lin_slave_enable      = false;
    7e60:	76c3      	strb	r3, [r0, #27]
	config->lin_header_delay = LIN_MASTER_HEADER_DELAY_0;
	config->lin_break_length = LIN_MASTER_BREAK_LENGTH_13_BIT;
#endif

#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
	config->immediate_buffer_overflow_notification  = false;
    7e62:	7602      	strb	r2, [r0, #24]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
    7e64:	7702      	strb	r2, [r0, #28]
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
    7e66:	7642      	strb	r2, [r0, #25]
	config->receive_pulse_length                    = 19;
    7e68:	2313      	movs	r3, #19
    7e6a:	7683      	strb	r3, [r0, #26]
	config->iso7816_config.inhibit_nack             = ISO7816_INHIBIT_NACK_DISABLE;
	config->iso7816_config.successive_recv_nack     = ISO7816_SUCCESSIVE_RECV_NACK_DISABLE;
	config->iso7816_config.max_iterations           = 7;
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
	config->collision_detection_enable              = false;
    7e6c:	7742      	strb	r2, [r0, #29]
 	struct usart_config usart_conf;

	usart_get_config_defaults(&usart_conf);
	usart_conf.mux_setting = CONF_STDIO_MUX_SETTING;
    7e6e:	2380      	movs	r3, #128	; 0x80
    7e70:	035b      	lsls	r3, r3, #13
    7e72:	9303      	str	r3, [sp, #12]
	usart_conf.pinmux_pad0 = CONF_STDIO_PINMUX_PAD0;
    7e74:	4b1a      	ldr	r3, [pc, #104]	; (7ee0 <serial_console_init+0xbc>)
    7e76:	930c      	str	r3, [sp, #48]	; 0x30
	usart_conf.pinmux_pad1 = CONF_STDIO_PINMUX_PAD1;
    7e78:	4b1a      	ldr	r3, [pc, #104]	; (7ee4 <serial_console_init+0xc0>)
    7e7a:	930d      	str	r3, [sp, #52]	; 0x34
	usart_conf.pinmux_pad2 = CONF_STDIO_PINMUX_PAD2;
    7e7c:	2301      	movs	r3, #1
    7e7e:	425b      	negs	r3, r3
    7e80:	930e      	str	r3, [sp, #56]	; 0x38
	usart_conf.pinmux_pad3 = CONF_STDIO_PINMUX_PAD3;
    7e82:	930f      	str	r3, [sp, #60]	; 0x3c
	usart_conf.baudrate    = CONF_STDIO_BAUDRATE;
    7e84:	23e1      	movs	r3, #225	; 0xe1
    7e86:	025b      	lsls	r3, r3, #9
    7e88:	9308      	str	r3, [sp, #32]
static inline void stdio_serial_init(
		struct usart_module *const module,
		usart_inst_t const hw,
		const struct usart_config *const config)
{
	stdio_base = (void *)module;
    7e8a:	4d17      	ldr	r5, [pc, #92]	; (7ee8 <serial_console_init+0xc4>)
    7e8c:	4b17      	ldr	r3, [pc, #92]	; (7eec <serial_console_init+0xc8>)
    7e8e:	601d      	str	r5, [r3, #0]
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
    7e90:	4a17      	ldr	r2, [pc, #92]	; (7ef0 <serial_console_init+0xcc>)
    7e92:	4b18      	ldr	r3, [pc, #96]	; (7ef4 <serial_console_init+0xd0>)
    7e94:	601a      	str	r2, [r3, #0]
	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
    7e96:	4a18      	ldr	r2, [pc, #96]	; (7ef8 <serial_console_init+0xd4>)
    7e98:	4b18      	ldr	r3, [pc, #96]	; (7efc <serial_console_init+0xd8>)
    7e9a:	601a      	str	r2, [r3, #0]
static inline bool usart_serial_init(
		struct usart_module *const module,
		usart_inst_t const hw,
		const struct usart_config *const config)
{
	if (usart_init(module, hw, config) == STATUS_OK) {
    7e9c:	466a      	mov	r2, sp
    7e9e:	4918      	ldr	r1, [pc, #96]	; (7f00 <serial_console_init+0xdc>)
    7ea0:	0028      	movs	r0, r5
    7ea2:	4b18      	ldr	r3, [pc, #96]	; (7f04 <serial_console_init+0xe0>)
    7ea4:	4798      	blx	r3

	usart_serial_init(module, hw, config);
# if defined(__GNUC__)
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
    7ea6:	4f18      	ldr	r7, [pc, #96]	; (7f08 <serial_console_init+0xe4>)
    7ea8:	683b      	ldr	r3, [r7, #0]
    7eaa:	6898      	ldr	r0, [r3, #8]
    7eac:	2100      	movs	r1, #0
    7eae:	4e17      	ldr	r6, [pc, #92]	; (7f0c <serial_console_init+0xe8>)
    7eb0:	47b0      	blx	r6
	setbuf(stdin, NULL);
    7eb2:	683b      	ldr	r3, [r7, #0]
    7eb4:	6858      	ldr	r0, [r3, #4]
    7eb6:	2100      	movs	r1, #0
    7eb8:	47b0      	blx	r6
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    7eba:	682e      	ldr	r6, [r5, #0]

#if USART_CALLBACK_MODE == true
	/* Enable Global interrupt for module */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    7ebc:	0030      	movs	r0, r6
    7ebe:	4b14      	ldr	r3, [pc, #80]	; (7f10 <serial_console_init+0xec>)
    7ec0:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    7ec2:	231f      	movs	r3, #31
    7ec4:	4018      	ands	r0, r3
    7ec6:	4084      	lsls	r4, r0
    7ec8:	4b12      	ldr	r3, [pc, #72]	; (7f14 <serial_console_init+0xf0>)
    7eca:	601c      	str	r4, [r3, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    7ecc:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    7ece:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    7ed0:	2b00      	cmp	r3, #0
    7ed2:	d1fc      	bne.n	7ece <serial_console_init+0xaa>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Enable USART module */
	usart_hw->CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    7ed4:	6832      	ldr	r2, [r6, #0]
    7ed6:	3302      	adds	r3, #2
    7ed8:	4313      	orrs	r3, r2
    7eda:	6033      	str	r3, [r6, #0]

	stdio_serial_init(&cdc_uart_module, CONF_STDIO_USART_MODULE, &usart_conf);
	usart_enable(&cdc_uart_module);
}
    7edc:	b011      	add	sp, #68	; 0x44
    7ede:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7ee0:	00160002 	.word	0x00160002
    7ee4:	00170002 	.word	0x00170002
    7ee8:	200003cc 	.word	0x200003cc
    7eec:	20001370 	.word	0x20001370
    7ef0:	00007e0d 	.word	0x00007e0d
    7ef4:	2000136c 	.word	0x2000136c
    7ef8:	00007de1 	.word	0x00007de1
    7efc:	20001368 	.word	0x20001368
    7f00:	42000c00 	.word	0x42000c00
    7f04:	00006a6d 	.word	0x00006a6d
    7f08:	20000130 	.word	0x20000130
    7f0c:	0000a8a5 	.word	0x0000a8a5
    7f10:	000069e1 	.word	0x000069e1
    7f14:	e000e100 	.word	0xe000e100

00007f18 <tc_cc0_cb>:
{
	bus_timer_callback();
}

void tc_cc0_cb(struct tc_module *const module_inst)
{
    7f18:	b510      	push	{r4, lr}
	static uint16_t tc_count;
	tc_set_count_value(&tc_instance, 0);
    7f1a:	2100      	movs	r1, #0
    7f1c:	480a      	ldr	r0, [pc, #40]	; (7f48 <tc_cc0_cb+0x30>)
    7f1e:	4b0b      	ldr	r3, [pc, #44]	; (7f4c <tc_cc0_cb+0x34>)
    7f20:	4798      	blx	r3
	tc_count += 1;
    7f22:	4a0b      	ldr	r2, [pc, #44]	; (7f50 <tc_cc0_cb+0x38>)
    7f24:	8813      	ldrh	r3, [r2, #0]
    7f26:	3301      	adds	r3, #1
    7f28:	b29b      	uxth	r3, r3
    7f2a:	8013      	strh	r3, [r2, #0]
	if (tc_count >= timeout_count)
    7f2c:	4a09      	ldr	r2, [pc, #36]	; (7f54 <tc_cc0_cb+0x3c>)
    7f2e:	6812      	ldr	r2, [r2, #0]
    7f30:	4293      	cmp	r3, r2
    7f32:	d307      	bcc.n	7f44 <tc_cc0_cb+0x2c>
	{
		tc_count = 0;
    7f34:	2200      	movs	r2, #0
    7f36:	4b06      	ldr	r3, [pc, #24]	; (7f50 <tc_cc0_cb+0x38>)
    7f38:	801a      	strh	r2, [r3, #0]
		if (timer_callback != NULL)
    7f3a:	4b07      	ldr	r3, [pc, #28]	; (7f58 <tc_cc0_cb+0x40>)
    7f3c:	681b      	ldr	r3, [r3, #0]
    7f3e:	2b00      	cmp	r3, #0
    7f40:	d000      	beq.n	7f44 <tc_cc0_cb+0x2c>
		{
			timer_callback();
    7f42:	4798      	blx	r3
		}
	}
}
    7f44:	bd10      	pop	{r4, pc}
    7f46:	46c0      	nop			; (mov r8, r8)
    7f48:	20001384 	.word	0x20001384
    7f4c:	00007c31 	.word	0x00007c31
    7f50:	20000400 	.word	0x20000400
    7f54:	20001380 	.word	0x20001380
    7f58:	20001378 	.word	0x20001378

00007f5c <hw_timer_init>:

void tc_cc0_cb(struct tc_module *const module_inst);
void bus_tc_cc0_cb(struct tc_module *const module_inst);

void hw_timer_init(void)
{
    7f5c:	b510      	push	{r4, lr}
    7f5e:	b08e      	sub	sp, #56	; 0x38
{
	/* Sanity check arguments */
	Assert(config);

	/* Write default config to config struct */
	config->clock_source               = GCLK_GENERATOR_0;
    7f60:	2300      	movs	r3, #0
    7f62:	466a      	mov	r2, sp
    7f64:	7013      	strb	r3, [r2, #0]
	config->counter_size               = TC_COUNTER_SIZE_16BIT;
    7f66:	70d3      	strb	r3, [r2, #3]
	config->clock_prescaler            = TC_CLOCK_PRESCALER_DIV1;
	config->wave_generation            = TC_WAVE_GENERATION_NORMAL_FREQ;
    7f68:	7193      	strb	r3, [r2, #6]
	config->reload_action              = TC_RELOAD_ACTION_GCLK;
    7f6a:	71d3      	strb	r3, [r2, #7]
	config->run_in_standby             = false;
    7f6c:	7053      	strb	r3, [r2, #1]
#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	config->on_demand                  = false;
    7f6e:	7093      	strb	r3, [r2, #2]
#endif
	config->waveform_invert_output     = TC_WAVEFORM_INVERT_OUTPUT_NONE;
    7f70:	7213      	strb	r3, [r2, #8]
	config->enable_capture_on_channel[TC_COMPARE_CAPTURE_CHANNEL_0] = false;
    7f72:	7253      	strb	r3, [r2, #9]
	config->enable_capture_on_channel[TC_COMPARE_CAPTURE_CHANNEL_1] = false;
    7f74:	7293      	strb	r3, [r2, #10]
#ifdef 	FEATURE_TC_IO_CAPTURE
	config->enable_capture_on_IO[TC_COMPARE_CAPTURE_CHANNEL_0] = false;
    7f76:	72d3      	strb	r3, [r2, #11]
	config->enable_capture_on_IO[TC_COMPARE_CAPTURE_CHANNEL_1] = false;
    7f78:	7313      	strb	r3, [r2, #12]
#endif

	config->count_direction            = TC_COUNT_DIRECTION_UP;
    7f7a:	7393      	strb	r3, [r2, #14]
	config->oneshot                    = false;
    7f7c:	7353      	strb	r3, [r2, #13]

	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].enabled = false;
    7f7e:	7413      	strb	r3, [r2, #16]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].pin_out = 0;
    7f80:	9305      	str	r3, [sp, #20]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].pin_mux = 0;
    7f82:	9306      	str	r3, [sp, #24]

	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].enabled = false;
    7f84:	7713      	strb	r3, [r2, #28]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].pin_out = 0;
    7f86:	9308      	str	r3, [sp, #32]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].pin_mux = 0;
    7f88:	9309      	str	r3, [sp, #36]	; 0x24

	config->counter_16_bit.value                   = 0x0000;
    7f8a:	8513      	strh	r3, [r2, #40]	; 0x28
	config->counter_16_bit.compare_capture_channel\
		[TC_COMPARE_CAPTURE_CHANNEL_0]                        = 0x0000;
	config->counter_16_bit.compare_capture_channel\
		[TC_COMPARE_CAPTURE_CHANNEL_1]                        = 0x0000;
#ifdef FEATURE_TC_DOUBLE_BUFFERED
	config->double_buffering_enabled = false;
    7f8c:	3334      	adds	r3, #52	; 0x34
    7f8e:	2200      	movs	r2, #0
    7f90:	4669      	mov	r1, sp
    7f92:	54ca      	strb	r2, [r1, r3]

	tc_get_config_defaults(&config_tc);

	config_tc.counter_size = TC_COUNTER_SIZE_16BIT;
	config_tc.clock_source = GCLK_GENERATOR_0;
	config_tc.clock_prescaler = TC_CLOCK_PRESCALER_DIV1024;
    7f94:	23e0      	movs	r3, #224	; 0xe0
    7f96:	00db      	lsls	r3, r3, #3
    7f98:	808b      	strh	r3, [r1, #4]
	config_tc.counter_8_bit.period = 0;
    7f9a:	2329      	movs	r3, #41	; 0x29
    7f9c:	2200      	movs	r2, #0
    7f9e:	54ca      	strb	r2, [r1, r3]
	config_tc.counter_16_bit.compare_capture_channel[0] = TC_COUNT_1SEC;
    7fa0:	4b0c      	ldr	r3, [pc, #48]	; (7fd4 <hw_timer_init+0x78>)
    7fa2:	466a      	mov	r2, sp
    7fa4:	854b      	strh	r3, [r1, #42]	; 0x2a
	config_tc.counter_16_bit.compare_capture_channel[1] = 0xFFFF;
    7fa6:	2301      	movs	r3, #1
    7fa8:	425b      	negs	r3, r3
    7faa:	858b      	strh	r3, [r1, #44]	; 0x2c

	tc_init(&tc_instance, CONF_TC_MODULE, &config_tc);
    7fac:	4c0a      	ldr	r4, [pc, #40]	; (7fd8 <hw_timer_init+0x7c>)
    7fae:	490b      	ldr	r1, [pc, #44]	; (7fdc <hw_timer_init+0x80>)
    7fb0:	0020      	movs	r0, r4
    7fb2:	4b0b      	ldr	r3, [pc, #44]	; (7fe0 <hw_timer_init+0x84>)
    7fb4:	4798      	blx	r3
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    7fb6:	6822      	ldr	r2, [r4, #0]

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
    7fb8:	6913      	ldr	r3, [r2, #16]
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

	while (tc_is_syncing(module_inst)) {
    7fba:	2b00      	cmp	r3, #0
    7fbc:	d1fc      	bne.n	7fb8 <hw_timer_init+0x5c>
		/* Wait for sync */
	}

	/* Enable TC module */
	tc_module->CTRLA.reg |= TC_CTRLA_ENABLE;
    7fbe:	6811      	ldr	r1, [r2, #0]
    7fc0:	3302      	adds	r3, #2
    7fc2:	430b      	orrs	r3, r1
    7fc4:	6013      	str	r3, [r2, #0]

	tc_enable(&tc_instance);
	
	tc_register_callback(&tc_instance, tc_cc0_cb,
    7fc6:	2202      	movs	r2, #2
    7fc8:	4906      	ldr	r1, [pc, #24]	; (7fe4 <hw_timer_init+0x88>)
    7fca:	4803      	ldr	r0, [pc, #12]	; (7fd8 <hw_timer_init+0x7c>)
    7fcc:	4b06      	ldr	r3, [pc, #24]	; (7fe8 <hw_timer_init+0x8c>)
    7fce:	4798      	blx	r3
						TC_CALLBACK_CC_CHANNEL0);
}
    7fd0:	b00e      	add	sp, #56	; 0x38
    7fd2:	bd10      	pop	{r4, pc}
    7fd4:	ffffb71b 	.word	0xffffb71b
    7fd8:	20001384 	.word	0x20001384
    7fdc:	42002400 	.word	0x42002400
    7fe0:	0000795d 	.word	0x0000795d
    7fe4:	00007f19 	.word	0x00007f19
    7fe8:	00007869 	.word	0x00007869

00007fec <socket_cb>:
	.name = MAIN_WIFI_M2M_PRODUCT_NAME,
};


static void socket_cb(SOCKET sock, uint8_t u8Msg, void *pvMsg)
{
    7fec:	b510      	push	{r4, lr}
	switch (u8Msg) {
    7fee:	2906      	cmp	r1, #6
    7ff0:	d02b      	beq.n	804a <socket_cb+0x5e>
    7ff2:	2907      	cmp	r1, #7
    7ff4:	d01d      	beq.n	8032 <socket_cb+0x46>
    7ff6:	2905      	cmp	r1, #5
    7ff8:	d13d      	bne.n	8076 <socket_cb+0x8a>
		/* Socket connected */
		case SOCKET_MSG_CONNECT:
		{
			tstrSocketConnectMsg *pstrConnect = (tstrSocketConnectMsg *)pvMsg;
			if (pstrConnect && pstrConnect->s8Error >= 0) {
    7ffa:	2a00      	cmp	r2, #0
    7ffc:	d00e      	beq.n	801c <socket_cb+0x30>
    7ffe:	7853      	ldrb	r3, [r2, #1]
    8000:	2b7f      	cmp	r3, #127	; 0x7f
    8002:	d80b      	bhi.n	801c <socket_cb+0x30>
				printf("socket_cb: connect success!\r\n");
    8004:	481c      	ldr	r0, [pc, #112]	; (8078 <socket_cb+0x8c>)
    8006:	4b1d      	ldr	r3, [pc, #116]	; (807c <socket_cb+0x90>)
    8008:	4798      	blx	r3
				send(tcp_client_socket, &msg_wifi_product, sizeof(t_msg_wifi_product), 0);
    800a:	4b1d      	ldr	r3, [pc, #116]	; (8080 <socket_cb+0x94>)
    800c:	2000      	movs	r0, #0
    800e:	5618      	ldrsb	r0, [r3, r0]
    8010:	2300      	movs	r3, #0
    8012:	2209      	movs	r2, #9
    8014:	491b      	ldr	r1, [pc, #108]	; (8084 <socket_cb+0x98>)
    8016:	4c1c      	ldr	r4, [pc, #112]	; (8088 <socket_cb+0x9c>)
    8018:	47a0      	blx	r4
    801a:	e02c      	b.n	8076 <socket_cb+0x8a>
				} else {
				printf("socket_cb: connect error!\r\n");
    801c:	481b      	ldr	r0, [pc, #108]	; (808c <socket_cb+0xa0>)
    801e:	4b17      	ldr	r3, [pc, #92]	; (807c <socket_cb+0x90>)
    8020:	4798      	blx	r3
				close(tcp_client_socket);
    8022:	4c17      	ldr	r4, [pc, #92]	; (8080 <socket_cb+0x94>)
    8024:	2000      	movs	r0, #0
    8026:	5620      	ldrsb	r0, [r4, r0]
    8028:	4b19      	ldr	r3, [pc, #100]	; (8090 <socket_cb+0xa4>)
    802a:	4798      	blx	r3
				tcp_client_socket = -1;
    802c:	23ff      	movs	r3, #255	; 0xff
    802e:	7023      	strb	r3, [r4, #0]
    8030:	e021      	b.n	8076 <socket_cb+0x8a>
		break;

		/* Message send */
		case SOCKET_MSG_SEND:
		{
			printf("socket_cb: send success!\r\n");
    8032:	4818      	ldr	r0, [pc, #96]	; (8094 <socket_cb+0xa8>)
    8034:	4b11      	ldr	r3, [pc, #68]	; (807c <socket_cb+0x90>)
    8036:	4798      	blx	r3
			recv(tcp_client_socket, gau8SocketTestBuffer, sizeof(gau8SocketTestBuffer), 0);
    8038:	4b11      	ldr	r3, [pc, #68]	; (8080 <socket_cb+0x94>)
    803a:	2000      	movs	r0, #0
    803c:	5618      	ldrsb	r0, [r3, r0]
    803e:	2300      	movs	r3, #0
    8040:	4a15      	ldr	r2, [pc, #84]	; (8098 <socket_cb+0xac>)
    8042:	4916      	ldr	r1, [pc, #88]	; (809c <socket_cb+0xb0>)
    8044:	4c16      	ldr	r4, [pc, #88]	; (80a0 <socket_cb+0xb4>)
    8046:	47a0      	blx	r4
		}
		break;
    8048:	e015      	b.n	8076 <socket_cb+0x8a>

		/* Message receive */
		case SOCKET_MSG_RECV:
		{
			tstrSocketRecvMsg *pstrRecv = (tstrSocketRecvMsg *)pvMsg;
			if (pstrRecv && pstrRecv->s16BufferSize > 0) {
    804a:	2a00      	cmp	r2, #0
    804c:	d009      	beq.n	8062 <socket_cb+0x76>
    804e:	2304      	movs	r3, #4
    8050:	5ed3      	ldrsh	r3, [r2, r3]
    8052:	2b00      	cmp	r3, #0
    8054:	dd05      	ble.n	8062 <socket_cb+0x76>
				printf("socket_cb: recv success!\r\n");
    8056:	4813      	ldr	r0, [pc, #76]	; (80a4 <socket_cb+0xb8>)
    8058:	4c08      	ldr	r4, [pc, #32]	; (807c <socket_cb+0x90>)
    805a:	47a0      	blx	r4
				printf("TCP Client Test Complete!\r\n");
    805c:	4812      	ldr	r0, [pc, #72]	; (80a8 <socket_cb+0xbc>)
    805e:	47a0      	blx	r4
    8060:	e009      	b.n	8076 <socket_cb+0x8a>
				} else {
				printf("socket_cb: recv error!\r\n");
    8062:	4812      	ldr	r0, [pc, #72]	; (80ac <socket_cb+0xc0>)
    8064:	4b05      	ldr	r3, [pc, #20]	; (807c <socket_cb+0x90>)
    8066:	4798      	blx	r3
				close(tcp_client_socket);
    8068:	4c05      	ldr	r4, [pc, #20]	; (8080 <socket_cb+0x94>)
    806a:	2000      	movs	r0, #0
    806c:	5620      	ldrsb	r0, [r4, r0]
    806e:	4b08      	ldr	r3, [pc, #32]	; (8090 <socket_cb+0xa4>)
    8070:	4798      	blx	r3
				tcp_client_socket = -1;
    8072:	23ff      	movs	r3, #255	; 0xff
    8074:	7023      	strb	r3, [r4, #0]
		break;

		default:
		break;
	}
}
    8076:	bd10      	pop	{r4, pc}
    8078:	000133f4 	.word	0x000133f4
    807c:	0000a891 	.word	0x0000a891
    8080:	200000b1 	.word	0x200000b1
    8084:	200000b4 	.word	0x200000b4
    8088:	00002ef1 	.word	0x00002ef1
    808c:	00013414 	.word	0x00013414
    8090:	0000301d 	.word	0x0000301d
    8094:	00013430 	.word	0x00013430
    8098:	000005b4 	.word	0x000005b4
    809c:	20000404 	.word	0x20000404
    80a0:	00002f89 	.word	0x00002f89
    80a4:	0001344c 	.word	0x0001344c
    80a8:	00013468 	.word	0x00013468
    80ac:	00013484 	.word	0x00013484

000080b0 <wifi_cb>:


int wifi_connected = 0;
static void wifi_cb(uint8_t u8MsgType, void *pvMsg)
{
    80b0:	b510      	push	{r4, lr}
    80b2:	b082      	sub	sp, #8
	switch (u8MsgType) {
    80b4:	282c      	cmp	r0, #44	; 0x2c
    80b6:	d002      	beq.n	80be <wifi_cb+0xe>
    80b8:	2832      	cmp	r0, #50	; 0x32
    80ba:	d01a      	beq.n	80f2 <wifi_cb+0x42>
    80bc:	e025      	b.n	810a <wifi_cb+0x5a>
		case M2M_WIFI_RESP_CON_STATE_CHANGED:
		{
			tstrM2mWifiStateChanged *pstrWifiState = (tstrM2mWifiStateChanged *)pvMsg;
			if (pstrWifiState->u8CurrState == M2M_WIFI_CONNECTED) {
    80be:	780b      	ldrb	r3, [r1, #0]
    80c0:	2b01      	cmp	r3, #1
    80c2:	d105      	bne.n	80d0 <wifi_cb+0x20>
				printf("wifi_cb: M2M_WIFI_RESP_CON_STATE_CHANGED: CONNECTED\r\n");
    80c4:	4812      	ldr	r0, [pc, #72]	; (8110 <wifi_cb+0x60>)
    80c6:	4b13      	ldr	r3, [pc, #76]	; (8114 <wifi_cb+0x64>)
    80c8:	4798      	blx	r3
				m2m_wifi_request_dhcp_client();
    80ca:	4b13      	ldr	r3, [pc, #76]	; (8118 <wifi_cb+0x68>)
    80cc:	4798      	blx	r3
    80ce:	e01c      	b.n	810a <wifi_cb+0x5a>
				} else if (pstrWifiState->u8CurrState == M2M_WIFI_DISCONNECTED) {
    80d0:	2b00      	cmp	r3, #0
    80d2:	d11a      	bne.n	810a <wifi_cb+0x5a>
				printf("wifi_cb: M2M_WIFI_RESP_CON_STATE_CHANGED: DISCONNECTED\r\n");
    80d4:	4811      	ldr	r0, [pc, #68]	; (811c <wifi_cb+0x6c>)
    80d6:	4b0f      	ldr	r3, [pc, #60]	; (8114 <wifi_cb+0x64>)
    80d8:	4798      	blx	r3
				wifi_connected = 0;
    80da:	2200      	movs	r2, #0
    80dc:	4b10      	ldr	r3, [pc, #64]	; (8120 <wifi_cb+0x70>)
    80de:	601a      	str	r2, [r3, #0]
				m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL);
    80e0:	23ff      	movs	r3, #255	; 0xff
    80e2:	9300      	str	r3, [sp, #0]
    80e4:	4b0f      	ldr	r3, [pc, #60]	; (8124 <wifi_cb+0x74>)
    80e6:	3202      	adds	r2, #2
    80e8:	210a      	movs	r1, #10
    80ea:	480f      	ldr	r0, [pc, #60]	; (8128 <wifi_cb+0x78>)
    80ec:	4c0f      	ldr	r4, [pc, #60]	; (812c <wifi_cb+0x7c>)
    80ee:	47a0      	blx	r4
    80f0:	e00b      	b.n	810a <wifi_cb+0x5a>
		}

		case M2M_WIFI_REQ_DHCP_CONF:
		{
			uint8_t *pu8IPAddress = (uint8_t *)pvMsg;
			wifi_connected = 1;
    80f2:	2201      	movs	r2, #1
    80f4:	4b0a      	ldr	r3, [pc, #40]	; (8120 <wifi_cb+0x70>)
    80f6:	601a      	str	r2, [r3, #0]
			printf("wifi_cb: M2M_WIFI_REQ_DHCP_CONF: IP is %u.%u.%u.%u\r\n",
    80f8:	788b      	ldrb	r3, [r1, #2]
    80fa:	784a      	ldrb	r2, [r1, #1]
    80fc:	7808      	ldrb	r0, [r1, #0]
    80fe:	78c9      	ldrb	r1, [r1, #3]
    8100:	9100      	str	r1, [sp, #0]
    8102:	0001      	movs	r1, r0
    8104:	480a      	ldr	r0, [pc, #40]	; (8130 <wifi_cb+0x80>)
    8106:	4c0b      	ldr	r4, [pc, #44]	; (8134 <wifi_cb+0x84>)
    8108:	47a0      	blx	r4
		default:
		{
			break;
		}
	}
}
    810a:	b002      	add	sp, #8
    810c:	bd10      	pop	{r4, pc}
    810e:	46c0      	nop			; (mov r8, r8)
    8110:	0001349c 	.word	0x0001349c
    8114:	0000a891 	.word	0x0000a891
    8118:	00001469 	.word	0x00001469
    811c:	000134d4 	.word	0x000134d4
    8120:	200009b8 	.word	0x200009b8
    8124:	0001350c 	.word	0x0001350c
    8128:	00013518 	.word	0x00013518
    812c:	0000144d 	.word	0x0000144d
    8130:	00013524 	.word	0x00013524
    8134:	0000a771 	.word	0x0000a771

00008138 <get_environment_sensor_data>:
	/* Initialize and enable the Watchdog with the user settings */
	wdt_set_config(&config_wdt);
}

void get_environment_sensor_data(environment_data_t *env_data)
{	
    8138:	b510      	push	{r4, lr}
    813a:	0004      	movs	r4, r0
	bme280_set_power_mode(BME280_FORCED_MODE);
    813c:	2001      	movs	r0, #1
    813e:	4b16      	ldr	r3, [pc, #88]	; (8198 <get_environment_sensor_data+0x60>)
    8140:	4798      	blx	r3
	
	if(ERROR == bme280_read_pressure_temperature_humidity(&env_pressure, &env_temperature, &env_humidity)){
    8142:	4a16      	ldr	r2, [pc, #88]	; (819c <get_environment_sensor_data+0x64>)
    8144:	4916      	ldr	r1, [pc, #88]	; (81a0 <get_environment_sensor_data+0x68>)
    8146:	4817      	ldr	r0, [pc, #92]	; (81a4 <get_environment_sensor_data+0x6c>)
    8148:	4b17      	ldr	r3, [pc, #92]	; (81a8 <get_environment_sensor_data+0x70>)
    814a:	4798      	blx	r3
    814c:	1c43      	adds	r3, r0, #1
    814e:	d105      	bne.n	815c <get_environment_sensor_data+0x24>
		//error
		DBG_LOG("Reading BME280 has failed");
    8150:	4816      	ldr	r0, [pc, #88]	; (81ac <get_environment_sensor_data+0x74>)
    8152:	4b17      	ldr	r3, [pc, #92]	; (81b0 <get_environment_sensor_data+0x78>)
    8154:	4798      	blx	r3
    8156:	4817      	ldr	r0, [pc, #92]	; (81b4 <get_environment_sensor_data+0x7c>)
    8158:	4b17      	ldr	r3, [pc, #92]	; (81b8 <get_environment_sensor_data+0x80>)
    815a:	4798      	blx	r3
	}
	if(STATUS_OK != veml6080_read_alsdata(&als_data)){
    815c:	4817      	ldr	r0, [pc, #92]	; (81bc <get_environment_sensor_data+0x84>)
    815e:	4b18      	ldr	r3, [pc, #96]	; (81c0 <get_environment_sensor_data+0x88>)
    8160:	4798      	blx	r3
    8162:	2800      	cmp	r0, #0
    8164:	d005      	beq.n	8172 <get_environment_sensor_data+0x3a>
		//error
		DBG_LOG("Reading VEML6080 has failed");
    8166:	4811      	ldr	r0, [pc, #68]	; (81ac <get_environment_sensor_data+0x74>)
    8168:	4b11      	ldr	r3, [pc, #68]	; (81b0 <get_environment_sensor_data+0x78>)
    816a:	4798      	blx	r3
    816c:	4815      	ldr	r0, [pc, #84]	; (81c4 <get_environment_sensor_data+0x8c>)
    816e:	4b12      	ldr	r3, [pc, #72]	; (81b8 <get_environment_sensor_data+0x80>)
    8170:	4798      	blx	r3
	}
	
	/* Temperature: No data processing required for Temperature data. Data with resolution 0.01(x100) directly txd*/
	env_data->temperature = (int16_t)env_temperature;
    8172:	4b0b      	ldr	r3, [pc, #44]	; (81a0 <get_environment_sensor_data+0x68>)
    8174:	681b      	ldr	r3, [r3, #0]
    8176:	8023      	strh	r3, [r4, #0]
	/* Pressure: Returns pressure in Pa as unsigned 32 bit integer. Output value of ?6386?equals 96386 Pa = 963.86 hPa*/
	env_data->pressure = (uint16_t)(env_pressure / 100);
    8178:	4b0a      	ldr	r3, [pc, #40]	; (81a4 <get_environment_sensor_data+0x6c>)
    817a:	6818      	ldr	r0, [r3, #0]
    817c:	2164      	movs	r1, #100	; 0x64
    817e:	4b12      	ldr	r3, [pc, #72]	; (81c8 <get_environment_sensor_data+0x90>)
    8180:	4798      	blx	r3
    8182:	8060      	strh	r0, [r4, #2]
	/*ALS: lx/step = 0.07 */
	env_data->uv = ((uint32_t)als_data * 7000);
    8184:	4b0d      	ldr	r3, [pc, #52]	; (81bc <get_environment_sensor_data+0x84>)
    8186:	881a      	ldrh	r2, [r3, #0]
    8188:	4b10      	ldr	r3, [pc, #64]	; (81cc <get_environment_sensor_data+0x94>)
    818a:	4353      	muls	r3, r2
    818c:	6063      	str	r3, [r4, #4]
	/* Humidity: An output value of 42313 represents 42313 / 1024 = 41.321 %rH*/
	env_data->humidity = (uint8_t)(env_humidity / 1024);
    818e:	4b03      	ldr	r3, [pc, #12]	; (819c <get_environment_sensor_data+0x64>)
    8190:	681b      	ldr	r3, [r3, #0]
    8192:	0a9b      	lsrs	r3, r3, #10
    8194:	7223      	strb	r3, [r4, #8]
}
    8196:	bd10      	pop	{r4, pc}
    8198:	00005a09 	.word	0x00005a09
    819c:	200013c0 	.word	0x200013c0
    81a0:	200013bc 	.word	0x200013bc
    81a4:	200013d0 	.word	0x200013d0
    81a8:	0000546d 	.word	0x0000546d
    81ac:	00013448 	.word	0x00013448
    81b0:	0000a891 	.word	0x0000a891
    81b4:	0001355c 	.word	0x0001355c
    81b8:	0000a771 	.word	0x0000a771
    81bc:	200013d4 	.word	0x200013d4
    81c0:	000044e9 	.word	0x000044e9
    81c4:	00013578 	.word	0x00013578
    81c8:	0000a38d 	.word	0x0000a38d
    81cc:	00001b58 	.word	0x00001b58

000081d0 <main>:
}


/* main function */
int main(void)
{
    81d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    81d2:	4647      	mov	r7, r8
    81d4:	b480      	push	{r7}
    81d6:	b08c      	sub	sp, #48	; 0x30
	//initialise_led();
	
	//enable_gclk1();
		
	/* system clock initialization */
	system_init();
    81d8:	4b4d      	ldr	r3, [pc, #308]	; (8310 <main+0x140>)
    81da:	4798      	blx	r3

	//i2c configure
	configure_sensor_i2c();
    81dc:	4b4d      	ldr	r3, [pc, #308]	; (8314 <main+0x144>)
    81de:	4798      	blx	r3
	//Initialize BHI160
	bhy_driver_init(_bhi_fw, _bhi_fw_len);
    81e0:	4b4d      	ldr	r3, [pc, #308]	; (8318 <main+0x148>)
    81e2:	6819      	ldr	r1, [r3, #0]
    81e4:	484d      	ldr	r0, [pc, #308]	; (831c <main+0x14c>)
    81e6:	4b4e      	ldr	r3, [pc, #312]	; (8320 <main+0x150>)
    81e8:	4798      	blx	r3
	
	/* delay routine initialization */
	delay_init();
    81ea:	4b4e      	ldr	r3, [pc, #312]	; (8324 <main+0x154>)
    81ec:	4798      	blx	r3

	/* Initialize RTC */
	rtc_init();	
    81ee:	4b4e      	ldr	r3, [pc, #312]	; (8328 <main+0x158>)
    81f0:	4798      	blx	r3
	
	/* configure adc for battery measurement */
	configure_adc();
    81f2:	4b4e      	ldr	r3, [pc, #312]	; (832c <main+0x15c>)
    81f4:	4798      	blx	r3

	/* Initialize QTouch library and configure touch sensors */
	touch_sensors_init();
    81f6:	4b4e      	ldr	r3, [pc, #312]	; (8330 <main+0x160>)
    81f8:	4798      	blx	r3
 
#ifdef DEBUG_SUPPORT
	/* Initialize serial console for debugging */
	serial_console_init();
    81fa:	4b4e      	ldr	r3, [pc, #312]	; (8334 <main+0x164>)
    81fc:	4798      	blx	r3
#endif

	DBG_LOG("Initializing Wearable Demo Device");
    81fe:	4e4e      	ldr	r6, [pc, #312]	; (8338 <main+0x168>)
    8200:	0030      	movs	r0, r6
    8202:	4d4e      	ldr	r5, [pc, #312]	; (833c <main+0x16c>)
    8204:	47a8      	blx	r5
    8206:	484e      	ldr	r0, [pc, #312]	; (8340 <main+0x170>)
    8208:	4f4e      	ldr	r7, [pc, #312]	; (8344 <main+0x174>)
    820a:	47b8      	blx	r7
 *
 * \return Current CPU frequency in Hz.
 */
static inline uint32_t system_cpu_clock_get_hz(void)
{
	return (system_gclk_gen_get_hz(GCLK_GENERATOR_0) >> (MCLK->CPUDIV.reg - 1));
    820c:	2000      	movs	r0, #0
    820e:	4b4e      	ldr	r3, [pc, #312]	; (8348 <main+0x178>)
    8210:	4798      	blx	r3
    8212:	4680      	mov	r8, r0
    8214:	4b4d      	ldr	r3, [pc, #308]	; (834c <main+0x17c>)
    8216:	791c      	ldrb	r4, [r3, #4]
    8218:	b2e4      	uxtb	r4, r4
	uint32_t cpu_freq = system_cpu_clock_get_hz();
	DBG_LOG("cpu_freq=%d\n",cpu_freq);
    821a:	0030      	movs	r0, r6
    821c:	47a8      	blx	r5
    821e:	3c01      	subs	r4, #1
    8220:	4641      	mov	r1, r8
    8222:	40e1      	lsrs	r1, r4
    8224:	484a      	ldr	r0, [pc, #296]	; (8350 <main+0x180>)
    8226:	47b8      	blx	r7
	
	/* Hardware timer */
	hw_timer_init();
    8228:	4b4a      	ldr	r3, [pc, #296]	; (8354 <main+0x184>)
    822a:	4798      	blx	r3

	//Initialize bme280
	wearable_bme280_init();
    822c:	4b4a      	ldr	r3, [pc, #296]	; (8358 <main+0x188>)
    822e:	4798      	blx	r3
	//Initialize veml6080
	veml6080_init();		
    8230:	4b4a      	ldr	r3, [pc, #296]	; (835c <main+0x18c>)
    8232:	4798      	blx	r3
	
	tstrWifiInitParam param;
	int8_t ret;
	/* Initialize the BSP. */
	nm_bsp_init();
    8234:	4b4a      	ldr	r3, [pc, #296]	; (8360 <main+0x190>)
    8236:	4798      	blx	r3
	
	struct sockaddr_in addr;
	/* Initialize socket address structure. */
	addr.sin_family = AF_INET;
    8238:	ab02      	add	r3, sp, #8
    823a:	2202      	movs	r2, #2
    823c:	801a      	strh	r2, [r3, #0]
	addr.sin_port = _htons(MAIN_WIFI_M2M_SERVER_PORT);
    823e:	4a49      	ldr	r2, [pc, #292]	; (8364 <main+0x194>)
    8240:	805a      	strh	r2, [r3, #2]
	addr.sin_addr.s_addr = _htonl(MAIN_WIFI_M2M_SERVER_IP);
    8242:	4a49      	ldr	r2, [pc, #292]	; (8368 <main+0x198>)
    8244:	9203      	str	r2, [sp, #12]

	/* Initialize Wi-Fi parameters structure. */
	memset((uint8_t *)&param, 0, sizeof(tstrWifiInitParam));
    8246:	2218      	movs	r2, #24
    8248:	2100      	movs	r1, #0
    824a:	a806      	add	r0, sp, #24
    824c:	4b47      	ldr	r3, [pc, #284]	; (836c <main+0x19c>)
    824e:	4798      	blx	r3

	/* Initialize Wi-Fi driver with data and status callbacks. */
	param.pfAppWifiCb = wifi_cb;
    8250:	4b47      	ldr	r3, [pc, #284]	; (8370 <main+0x1a0>)
    8252:	9306      	str	r3, [sp, #24]
	ret = m2m_wifi_init(&param);
    8254:	a806      	add	r0, sp, #24
    8256:	4b47      	ldr	r3, [pc, #284]	; (8374 <main+0x1a4>)
    8258:	4798      	blx	r3
    825a:	1e01      	subs	r1, r0, #0
	if (M2M_SUCCESS != ret) {
    825c:	d003      	beq.n	8266 <main+0x96>
		printf("main: m2m_wifi_init call error!(%d)\r\n", ret);
    825e:	4846      	ldr	r0, [pc, #280]	; (8378 <main+0x1a8>)
    8260:	4b38      	ldr	r3, [pc, #224]	; (8344 <main+0x174>)
    8262:	4798      	blx	r3
    8264:	e7fe      	b.n	8264 <main+0x94>
		while (1) {
		}
	}
	
	/* Initialize socket module */
	socketInit();
    8266:	4b45      	ldr	r3, [pc, #276]	; (837c <main+0x1ac>)
    8268:	4798      	blx	r3
	registerSocketCallback(socket_cb, NULL);
    826a:	2100      	movs	r1, #0
    826c:	4844      	ldr	r0, [pc, #272]	; (8380 <main+0x1b0>)
    826e:	4b45      	ldr	r3, [pc, #276]	; (8384 <main+0x1b4>)
    8270:	4798      	blx	r3

	/* Connect to router. */
	m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL);
    8272:	23ff      	movs	r3, #255	; 0xff
    8274:	9300      	str	r3, [sp, #0]
    8276:	4b44      	ldr	r3, [pc, #272]	; (8388 <main+0x1b8>)
    8278:	2202      	movs	r2, #2
    827a:	210a      	movs	r1, #10
    827c:	4843      	ldr	r0, [pc, #268]	; (838c <main+0x1bc>)
    827e:	4c44      	ldr	r4, [pc, #272]	; (8390 <main+0x1c0>)
    8280:	47a0      	blx	r4

	//enable_gyroscope();
	enable_accelerometer();
    8282:	4b44      	ldr	r3, [pc, #272]	; (8394 <main+0x1c4>)
    8284:	4798      	blx	r3
	//enable_drop_detector();
	//enable_step_detector();
	
	while (1) {
		/* Handle pending events from network controller. */
		m2m_wifi_handle_events(NULL);
    8286:	4d44      	ldr	r5, [pc, #272]	; (8398 <main+0x1c8>)

		if (wifi_connected == M2M_WIFI_CONNECTED) {
    8288:	4c44      	ldr	r4, [pc, #272]	; (839c <main+0x1cc>)
				}
			}
		}

		// for testing 
		if(tick_bhi == 1)
    828a:	4e45      	ldr	r6, [pc, #276]	; (83a0 <main+0x1d0>)
	//enable_drop_detector();
	//enable_step_detector();
	
	while (1) {
		/* Handle pending events from network controller. */
		m2m_wifi_handle_events(NULL);
    828c:	2000      	movs	r0, #0
    828e:	47a8      	blx	r5

		if (wifi_connected == M2M_WIFI_CONNECTED) {
    8290:	6823      	ldr	r3, [r4, #0]
    8292:	2b01      	cmp	r3, #1
    8294:	d11d      	bne.n	82d2 <main+0x102>
			/* Open client socket. */
			if (tcp_client_socket < 0) {
    8296:	4b43      	ldr	r3, [pc, #268]	; (83a4 <main+0x1d4>)
    8298:	781b      	ldrb	r3, [r3, #0]
    829a:	2b7f      	cmp	r3, #127	; 0x7f
    829c:	d919      	bls.n	82d2 <main+0x102>
				if ((tcp_client_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    829e:	2200      	movs	r2, #0
    82a0:	2101      	movs	r1, #1
    82a2:	2002      	movs	r0, #2
    82a4:	4b40      	ldr	r3, [pc, #256]	; (83a8 <main+0x1d8>)
    82a6:	4798      	blx	r3
    82a8:	4b3e      	ldr	r3, [pc, #248]	; (83a4 <main+0x1d4>)
    82aa:	7018      	strb	r0, [r3, #0]
    82ac:	2800      	cmp	r0, #0
    82ae:	da03      	bge.n	82b8 <main+0xe8>
					printf("main: failed to create TCP client socket error!\r\n");
    82b0:	483e      	ldr	r0, [pc, #248]	; (83ac <main+0x1dc>)
    82b2:	4b22      	ldr	r3, [pc, #136]	; (833c <main+0x16c>)
    82b4:	4798      	blx	r3
					continue;
    82b6:	e7e9      	b.n	828c <main+0xbc>
				}

				/* Connect server */
				ret = connect(tcp_client_socket, (struct sockaddr *)&addr, sizeof(struct sockaddr_in));
    82b8:	2210      	movs	r2, #16
    82ba:	a902      	add	r1, sp, #8
    82bc:	4b3c      	ldr	r3, [pc, #240]	; (83b0 <main+0x1e0>)
    82be:	4798      	blx	r3

				if (ret < 0) {
    82c0:	2800      	cmp	r0, #0
    82c2:	da06      	bge.n	82d2 <main+0x102>
					close(tcp_client_socket);
    82c4:	4f37      	ldr	r7, [pc, #220]	; (83a4 <main+0x1d4>)
    82c6:	2000      	movs	r0, #0
    82c8:	5638      	ldrsb	r0, [r7, r0]
    82ca:	4b3a      	ldr	r3, [pc, #232]	; (83b4 <main+0x1e4>)
    82cc:	4798      	blx	r3
					tcp_client_socket = -1;
    82ce:	23ff      	movs	r3, #255	; 0xff
    82d0:	703b      	strb	r3, [r7, #0]
				}
			}
		}

		// for testing 
		if(tick_bhi == 1)
    82d2:	7833      	ldrb	r3, [r6, #0]
    82d4:	2b01      	cmp	r3, #1
    82d6:	d1d9      	bne.n	828c <main+0xbc>
		{
			tick_bhi = 0;
    82d8:	2200      	movs	r2, #0
    82da:	4b31      	ldr	r3, [pc, #196]	; (83a0 <main+0x1d0>)
    82dc:	701a      	strb	r2, [r3, #0]
			process_motion_sensor_data();
    82de:	4b36      	ldr	r3, [pc, #216]	; (83b8 <main+0x1e8>)
    82e0:	4798      	blx	r3
			
			get_environment_sensor_data(&environ_data);
    82e2:	4f36      	ldr	r7, [pc, #216]	; (83bc <main+0x1ec>)
    82e4:	0038      	movs	r0, r7
    82e6:	4b36      	ldr	r3, [pc, #216]	; (83c0 <main+0x1f0>)
    82e8:	4798      	blx	r3
			printf("environ_data = %d, %d, %d, %d\n", environ_data.temperature, environ_data.humidity, environ_data.uv, environ_data.pressure);
    82ea:	687b      	ldr	r3, [r7, #4]
    82ec:	7a3a      	ldrb	r2, [r7, #8]
    82ee:	2000      	movs	r0, #0
    82f0:	5e39      	ldrsh	r1, [r7, r0]
    82f2:	8878      	ldrh	r0, [r7, #2]
    82f4:	9000      	str	r0, [sp, #0]
    82f6:	4833      	ldr	r0, [pc, #204]	; (83c4 <main+0x1f4>)
    82f8:	4f12      	ldr	r7, [pc, #72]	; (8344 <main+0x174>)
    82fa:	47b8      	blx	r7
			
			//printf("acc data = %d, %d, %d\n", gyro_data.x_pos, gyro_data.y_pos, gyro_data.z_pos);
			printf("acc data = %d, %d, %d\n", acc_data.x_pos, acc_data.y_pos, acc_data.z_pos);
    82fc:	4932      	ldr	r1, [pc, #200]	; (83c8 <main+0x1f8>)
    82fe:	2204      	movs	r2, #4
    8300:	5e8b      	ldrsh	r3, [r1, r2]
    8302:	2002      	movs	r0, #2
    8304:	5e0a      	ldrsh	r2, [r1, r0]
    8306:	2000      	movs	r0, #0
    8308:	5e09      	ldrsh	r1, [r1, r0]
    830a:	4830      	ldr	r0, [pc, #192]	; (83cc <main+0x1fc>)
    830c:	47b8      	blx	r7
    830e:	e7bd      	b.n	828c <main+0xbc>
    8310:	00007845 	.word	0x00007845
    8314:	000043fd 	.word	0x000043fd
    8318:	00012dd8 	.word	0x00012dd8
    831c:	0000c910 	.word	0x0000c910
    8320:	00003f3d 	.word	0x00003f3d
    8324:	00006271 	.word	0x00006271
    8328:	00005f55 	.word	0x00005f55
    832c:	000036dd 	.word	0x000036dd
    8330:	00005c49 	.word	0x00005c49
    8334:	00007e25 	.word	0x00007e25
    8338:	00013448 	.word	0x00013448
    833c:	0000a891 	.word	0x0000a891
    8340:	00013594 	.word	0x00013594
    8344:	0000a771 	.word	0x0000a771
    8348:	00007639 	.word	0x00007639
    834c:	40000400 	.word	0x40000400
    8350:	000135b8 	.word	0x000135b8
    8354:	00007f5d 	.word	0x00007f5d
    8358:	00005bd5 	.word	0x00005bd5
    835c:	000044b5 	.word	0x000044b5
    8360:	00000181 	.word	0x00000181
    8364:	00000a1a 	.word	0x00000a1a
    8368:	6401a8c0 	.word	0x6401a8c0
    836c:	0000a75f 	.word	0x0000a75f
    8370:	000080b1 	.word	0x000080b1
    8374:	0000108d 	.word	0x0000108d
    8378:	000135c8 	.word	0x000135c8
    837c:	00002c85 	.word	0x00002c85
    8380:	00007fed 	.word	0x00007fed
    8384:	00002cc9 	.word	0x00002cc9
    8388:	0001350c 	.word	0x0001350c
    838c:	00013518 	.word	0x00013518
    8390:	0000144d 	.word	0x0000144d
    8394:	00003971 	.word	0x00003971
    8398:	000011bd 	.word	0x000011bd
    839c:	200009b8 	.word	0x200009b8
    83a0:	20001035 	.word	0x20001035
    83a4:	200000b1 	.word	0x200000b1
    83a8:	00002cdd 	.word	0x00002cdd
    83ac:	000135f0 	.word	0x000135f0
    83b0:	00002e61 	.word	0x00002e61
    83b4:	0000301d 	.word	0x0000301d
    83b8:	00003899 	.word	0x00003899
    83bc:	200013c4 	.word	0x200013c4
    83c0:	00008139 	.word	0x00008139
    83c4:	00013624 	.word	0x00013624
    83c8:	20000e58 	.word	0x20000e58
    83cc:	00013644 	.word	0x00013644

000083d0 <enable_key>:
    83d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    83d2:	ac05      	add	r4, sp, #20
    83d4:	7825      	ldrb	r5, [r4, #0]
    83d6:	1c04      	adds	r4, r0, #0
    83d8:	8906      	ldrh	r6, [r0, #8]
    83da:	3490      	adds	r4, #144	; 0x90
    83dc:	6827      	ldr	r7, [r4, #0]
    83de:	00f6      	lsls	r6, r6, #3
    83e0:	19be      	adds	r6, r7, r6
    83e2:	7133      	strb	r3, [r6, #4]
    83e4:	8903      	ldrh	r3, [r0, #8]
    83e6:	6826      	ldr	r6, [r4, #0]
    83e8:	00db      	lsls	r3, r3, #3
    83ea:	18f3      	adds	r3, r6, r3
    83ec:	2600      	movs	r6, #0
    83ee:	70de      	strb	r6, [r3, #3]
    83f0:	8903      	ldrh	r3, [r0, #8]
    83f2:	6827      	ldr	r7, [r4, #0]
    83f4:	00db      	lsls	r3, r3, #3
    83f6:	18fb      	adds	r3, r7, r3
    83f8:	78de      	ldrb	r6, [r3, #3]
    83fa:	2738      	movs	r7, #56	; 0x38
    83fc:	43be      	bics	r6, r7
    83fe:	70de      	strb	r6, [r3, #3]
    8400:	8903      	ldrh	r3, [r0, #8]
    8402:	6826      	ldr	r6, [r4, #0]
    8404:	00db      	lsls	r3, r3, #3
    8406:	18f3      	adds	r3, r6, r3
    8408:	2607      	movs	r6, #7
    840a:	4032      	ands	r2, r6
    840c:	78de      	ldrb	r6, [r3, #3]
    840e:	00d2      	lsls	r2, r2, #3
    8410:	4332      	orrs	r2, r6
    8412:	70da      	strb	r2, [r3, #3]
    8414:	8903      	ldrh	r3, [r0, #8]
    8416:	6827      	ldr	r7, [r4, #0]
    8418:	00db      	lsls	r3, r3, #3
    841a:	18fb      	adds	r3, r7, r3
    841c:	7159      	strb	r1, [r3, #5]
    841e:	8903      	ldrh	r3, [r0, #8]
    8420:	6822      	ldr	r2, [r4, #0]
    8422:	00db      	lsls	r3, r3, #3
    8424:	18d3      	adds	r3, r2, r3
    8426:	7199      	strb	r1, [r3, #6]
    8428:	8903      	ldrh	r3, [r0, #8]
    842a:	6826      	ldr	r6, [r4, #0]
    842c:	00db      	lsls	r3, r3, #3
    842e:	18f3      	adds	r3, r6, r3
    8430:	78d9      	ldrb	r1, [r3, #3]
    8432:	2203      	movs	r2, #3
    8434:	4391      	bics	r1, r2
    8436:	70d9      	strb	r1, [r3, #3]
    8438:	8903      	ldrh	r3, [r0, #8]
    843a:	6821      	ldr	r1, [r4, #0]
    843c:	4093      	lsls	r3, r2
    843e:	18cb      	adds	r3, r1, r3
    8440:	78d9      	ldrb	r1, [r3, #3]
    8442:	402a      	ands	r2, r5
    8444:	430a      	orrs	r2, r1
    8446:	70da      	strb	r2, [r3, #3]
    8448:	8903      	ldrh	r3, [r0, #8]
    844a:	3301      	adds	r3, #1
    844c:	8103      	strh	r3, [r0, #8]
    844e:	8883      	ldrh	r3, [r0, #4]
    8450:	3301      	adds	r3, #1
    8452:	8083      	strh	r3, [r0, #4]
    8454:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

00008458 <touch_sensor_config>:
    8458:	b5f0      	push	{r4, r5, r6, r7, lr}
    845a:	b087      	sub	sp, #28
    845c:	af0f      	add	r7, sp, #60	; 0x3c
    845e:	783f      	ldrb	r7, [r7, #0]
    8460:	1c0d      	adds	r5, r1, #0
    8462:	9705      	str	r7, [sp, #20]
    8464:	af10      	add	r7, sp, #64	; 0x40
    8466:	783f      	ldrb	r7, [r7, #0]
    8468:	1c11      	adds	r1, r2, #0
    846a:	ac0d      	add	r4, sp, #52	; 0x34
    846c:	1c1a      	adds	r2, r3, #0
    846e:	ae0e      	add	r6, sp, #56	; 0x38
    8470:	ab0c      	add	r3, sp, #48	; 0x30
    8472:	781b      	ldrb	r3, [r3, #0]
    8474:	7824      	ldrb	r4, [r4, #0]
    8476:	7836      	ldrb	r6, [r6, #0]
    8478:	46bc      	mov	ip, r7
    847a:	2d01      	cmp	r5, #1
    847c:	d001      	beq.n	8482 <touch_sensor_config+0x2a>
    847e:	2d04      	cmp	r5, #4
    8480:	d105      	bne.n	848e <touch_sensor_config+0x36>
    8482:	1c1a      	adds	r2, r3, #0
    8484:	9600      	str	r6, [sp, #0]
    8486:	1c23      	adds	r3, r4, #0
    8488:	4c0b      	ldr	r4, [pc, #44]	; (84b8 <touch_sensor_config+0x60>)
    848a:	47a0      	blx	r4
    848c:	e011      	b.n	84b2 <touch_sensor_config+0x5a>
    848e:	2d02      	cmp	r5, #2
    8490:	d102      	bne.n	8498 <touch_sensor_config+0x40>
    8492:	4d0a      	ldr	r5, [pc, #40]	; (84bc <touch_sensor_config+0x64>)
    8494:	682d      	ldr	r5, [r5, #0]
    8496:	e003      	b.n	84a0 <touch_sensor_config+0x48>
    8498:	2d03      	cmp	r5, #3
    849a:	d10a      	bne.n	84b2 <touch_sensor_config+0x5a>
    849c:	4d07      	ldr	r5, [pc, #28]	; (84bc <touch_sensor_config+0x64>)
    849e:	686d      	ldr	r5, [r5, #4]
    84a0:	2d00      	cmp	r5, #0
    84a2:	d006      	beq.n	84b2 <touch_sensor_config+0x5a>
    84a4:	9400      	str	r4, [sp, #0]
    84a6:	9c05      	ldr	r4, [sp, #20]
    84a8:	4667      	mov	r7, ip
    84aa:	9601      	str	r6, [sp, #4]
    84ac:	9402      	str	r4, [sp, #8]
    84ae:	9703      	str	r7, [sp, #12]
    84b0:	47a8      	blx	r5
    84b2:	b007      	add	sp, #28
    84b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    84b6:	46c0      	nop			; (mov r8, r8)
    84b8:	000083d1 	.word	0x000083d1
    84bc:	200009bc 	.word	0x200009bc

000084c0 <process_touch_postprocessing_mode>:
    84c0:	8cc2      	ldrh	r2, [r0, #38]	; 0x26
    84c2:	4b06      	ldr	r3, [pc, #24]	; (84dc <process_touch_postprocessing_mode+0x1c>)
    84c4:	2a00      	cmp	r2, #0
    84c6:	d006      	beq.n	84d6 <process_touch_postprocessing_mode+0x16>
    84c8:	8a99      	ldrh	r1, [r3, #20]
    84ca:	3101      	adds	r1, #1
    84cc:	b289      	uxth	r1, r1
    84ce:	8299      	strh	r1, [r3, #20]
    84d0:	4291      	cmp	r1, r2
    84d2:	d301      	bcc.n	84d8 <process_touch_postprocessing_mode+0x18>
    84d4:	2201      	movs	r2, #1
    84d6:	82da      	strh	r2, [r3, #22]
    84d8:	8ad8      	ldrh	r0, [r3, #22]
    84da:	4770      	bx	lr
    84dc:	200009bc 	.word	0x200009bc

000084e0 <reset_touch_postprocess_mode>:
    84e0:	4b02      	ldr	r3, [pc, #8]	; (84ec <reset_touch_postprocess_mode+0xc>)
    84e2:	2200      	movs	r2, #0
    84e4:	82da      	strh	r2, [r3, #22]
    84e6:	829a      	strh	r2, [r3, #20]
    84e8:	4770      	bx	lr
    84ea:	46c0      	nop			; (mov r8, r8)
    84ec:	200009bc 	.word	0x200009bc

000084f0 <touch_process>:
    84f0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    84f2:	7b83      	ldrb	r3, [r0, #14]
    84f4:	1c04      	adds	r4, r0, #0
    84f6:	2b00      	cmp	r3, #0
    84f8:	d11a      	bne.n	8530 <touch_process+0x40>
    84fa:	8b03      	ldrh	r3, [r0, #24]
    84fc:	8a81      	ldrh	r1, [r0, #20]
    84fe:	8a42      	ldrh	r2, [r0, #18]
    8500:	8243      	strh	r3, [r0, #18]
    8502:	185b      	adds	r3, r3, r1
    8504:	1a9b      	subs	r3, r3, r2
    8506:	8283      	strh	r3, [r0, #20]
    8508:	8aa3      	ldrh	r3, [r4, #20]
    850a:	2bc7      	cmp	r3, #199	; 0xc7
    850c:	d905      	bls.n	851a <touch_process+0x2a>
    850e:	3bc8      	subs	r3, #200	; 0xc8
    8510:	82a3      	strh	r3, [r4, #20]
    8512:	7da3      	ldrb	r3, [r4, #22]
    8514:	3301      	adds	r3, #1
    8516:	75a3      	strb	r3, [r4, #22]
    8518:	e7f6      	b.n	8508 <touch_process+0x18>
    851a:	7be3      	ldrb	r3, [r4, #15]
    851c:	2b00      	cmp	r3, #0
    851e:	d009      	beq.n	8534 <touch_process+0x44>
    8520:	7da2      	ldrb	r2, [r4, #22]
    8522:	429a      	cmp	r2, r3
    8524:	d901      	bls.n	852a <touch_process+0x3a>
    8526:	2300      	movs	r3, #0
    8528:	e000      	b.n	852c <touch_process+0x3c>
    852a:	1a9b      	subs	r3, r3, r2
    852c:	73e3      	strb	r3, [r4, #15]
    852e:	e001      	b.n	8534 <touch_process+0x44>
    8530:	2300      	movs	r3, #0
    8532:	7583      	strb	r3, [r0, #22]
    8534:	1c26      	adds	r6, r4, #0
    8536:	36fc      	adds	r6, #252	; 0xfc
    8538:	6a33      	ldr	r3, [r6, #32]
    853a:	2b00      	cmp	r3, #0
    853c:	d002      	beq.n	8544 <touch_process+0x54>
    853e:	1c20      	adds	r0, r4, #0
    8540:	3034      	adds	r0, #52	; 0x34
    8542:	4798      	blx	r3
    8544:	8923      	ldrh	r3, [r4, #8]
    8546:	2500      	movs	r5, #0
    8548:	73a5      	strb	r5, [r4, #14]
    854a:	9301      	str	r3, [sp, #4]
    854c:	9b01      	ldr	r3, [sp, #4]
    854e:	429d      	cmp	r5, r3
    8550:	d209      	bcs.n	8566 <touch_process+0x76>
    8552:	b2e9      	uxtb	r1, r5
    8554:	1c20      	adds	r0, r4, #0
    8556:	4b44      	ldr	r3, [pc, #272]	; (8668 <touch_process+0x178>)
    8558:	7ba7      	ldrb	r7, [r4, #14]
    855a:	4798      	blx	r3
    855c:	3501      	adds	r5, #1
    855e:	4307      	orrs	r7, r0
    8560:	73a7      	strb	r7, [r4, #14]
    8562:	b2ad      	uxth	r5, r5
    8564:	e7f2      	b.n	854c <touch_process+0x5c>
    8566:	4b41      	ldr	r3, [pc, #260]	; (866c <touch_process+0x17c>)
    8568:	1c20      	adds	r0, r4, #0
    856a:	4798      	blx	r3
    856c:	7ba3      	ldrb	r3, [r4, #14]
    856e:	2b01      	cmp	r3, #1
    8570:	d11c      	bne.n	85ac <touch_process+0xbc>
    8572:	4d3f      	ldr	r5, [pc, #252]	; (8670 <touch_process+0x180>)
    8574:	2780      	movs	r7, #128	; 0x80
    8576:	8aeb      	ldrh	r3, [r5, #22]
    8578:	007f      	lsls	r7, r7, #1
    857a:	2b01      	cmp	r3, #1
    857c:	d10f      	bne.n	859e <touch_process+0xae>
    857e:	4b3d      	ldr	r3, [pc, #244]	; (8674 <touch_process+0x184>)
    8580:	4798      	blx	r3
    8582:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
    8584:	431f      	orrs	r7, r3
    8586:	7823      	ldrb	r3, [r4, #0]
    8588:	87e7      	strh	r7, [r4, #62]	; 0x3e
    858a:	2b01      	cmp	r3, #1
    858c:	d102      	bne.n	8594 <touch_process+0xa4>
    858e:	2302      	movs	r3, #2
    8590:	762b      	strb	r3, [r5, #24]
    8592:	e023      	b.n	85dc <touch_process+0xec>
    8594:	2b00      	cmp	r3, #0
    8596:	d121      	bne.n	85dc <touch_process+0xec>
    8598:	2302      	movs	r3, #2
    859a:	766b      	strb	r3, [r5, #25]
    859c:	e01e      	b.n	85dc <touch_process+0xec>
    859e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
    85a0:	1c20      	adds	r0, r4, #0
    85a2:	431f      	orrs	r7, r3
    85a4:	87e7      	strh	r7, [r4, #62]	; 0x3e
    85a6:	4b34      	ldr	r3, [pc, #208]	; (8678 <touch_process+0x188>)
    85a8:	4798      	blx	r3
    85aa:	e017      	b.n	85dc <touch_process+0xec>
    85ac:	4b33      	ldr	r3, [pc, #204]	; (867c <touch_process+0x18c>)
    85ae:	781a      	ldrb	r2, [r3, #0]
    85b0:	2a01      	cmp	r2, #1
    85b2:	d101      	bne.n	85b8 <touch_process+0xc8>
    85b4:	2200      	movs	r2, #0
    85b6:	701a      	strb	r2, [r3, #0]
    85b8:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    85ba:	4b31      	ldr	r3, [pc, #196]	; (8680 <touch_process+0x190>)
    85bc:	4013      	ands	r3, r2
    85be:	87e3      	strh	r3, [r4, #62]	; 0x3e
    85c0:	7823      	ldrb	r3, [r4, #0]
    85c2:	2b01      	cmp	r3, #1
    85c4:	d103      	bne.n	85ce <touch_process+0xde>
    85c6:	4b2a      	ldr	r3, [pc, #168]	; (8670 <touch_process+0x180>)
    85c8:	2202      	movs	r2, #2
    85ca:	761a      	strb	r2, [r3, #24]
    85cc:	e004      	b.n	85d8 <touch_process+0xe8>
    85ce:	2b00      	cmp	r3, #0
    85d0:	d102      	bne.n	85d8 <touch_process+0xe8>
    85d2:	4b27      	ldr	r3, [pc, #156]	; (8670 <touch_process+0x180>)
    85d4:	2202      	movs	r2, #2
    85d6:	765a      	strb	r2, [r3, #25]
    85d8:	4b26      	ldr	r3, [pc, #152]	; (8674 <touch_process+0x184>)
    85da:	4798      	blx	r3
    85dc:	8861      	ldrh	r1, [r4, #2]
    85de:	2200      	movs	r2, #0
    85e0:	3107      	adds	r1, #7
    85e2:	08c9      	lsrs	r1, r1, #3
    85e4:	2300      	movs	r3, #0
    85e6:	428a      	cmp	r2, r1
    85e8:	d206      	bcs.n	85f8 <touch_process+0x108>
    85ea:	1c20      	adds	r0, r4, #0
    85ec:	30b0      	adds	r0, #176	; 0xb0
    85ee:	6800      	ldr	r0, [r0, #0]
    85f0:	5483      	strb	r3, [r0, r2]
    85f2:	3201      	adds	r2, #1
    85f4:	b292      	uxth	r2, r2
    85f6:	e7f5      	b.n	85e4 <touch_process+0xf4>
    85f8:	8921      	ldrh	r1, [r4, #8]
    85fa:	428b      	cmp	r3, r1
    85fc:	d218      	bcs.n	8630 <touch_process+0x140>
    85fe:	1c22      	adds	r2, r4, #0
    8600:	3290      	adds	r2, #144	; 0x90
    8602:	6812      	ldr	r2, [r2, #0]
    8604:	00d8      	lsls	r0, r3, #3
    8606:	5c80      	ldrb	r0, [r0, r2]
    8608:	2218      	movs	r2, #24
    860a:	4210      	tst	r0, r2
    860c:	d00d      	beq.n	862a <touch_process+0x13a>
    860e:	1c20      	adds	r0, r4, #0
    8610:	30b0      	adds	r0, #176	; 0xb0
    8612:	6800      	ldr	r0, [r0, #0]
    8614:	08da      	lsrs	r2, r3, #3
    8616:	b2d2      	uxtb	r2, r2
    8618:	1882      	adds	r2, r0, r2
    861a:	2007      	movs	r0, #7
    861c:	4018      	ands	r0, r3
    861e:	2501      	movs	r5, #1
    8620:	4085      	lsls	r5, r0
    8622:	1c28      	adds	r0, r5, #0
    8624:	7815      	ldrb	r5, [r2, #0]
    8626:	4328      	orrs	r0, r5
    8628:	7010      	strb	r0, [r2, #0]
    862a:	3301      	adds	r3, #1
    862c:	b29b      	uxth	r3, r3
    862e:	e7e4      	b.n	85fa <touch_process+0x10a>
    8630:	69b3      	ldr	r3, [r6, #24]
    8632:	2b00      	cmp	r3, #0
    8634:	d006      	beq.n	8644 <touch_process+0x154>
    8636:	1c22      	adds	r2, r4, #0
    8638:	32ec      	adds	r2, #236	; 0xec
    863a:	7812      	ldrb	r2, [r2, #0]
    863c:	2a00      	cmp	r2, #0
    863e:	d001      	beq.n	8644 <touch_process+0x154>
    8640:	1c20      	adds	r0, r4, #0
    8642:	4798      	blx	r3
    8644:	7823      	ldrb	r3, [r4, #0]
    8646:	2b00      	cmp	r3, #0
    8648:	d102      	bne.n	8650 <touch_process+0x160>
    864a:	4b09      	ldr	r3, [pc, #36]	; (8670 <touch_process+0x180>)
    864c:	7e5b      	ldrb	r3, [r3, #25]
    864e:	e003      	b.n	8658 <touch_process+0x168>
    8650:	2b01      	cmp	r3, #1
    8652:	d107      	bne.n	8664 <touch_process+0x174>
    8654:	4b06      	ldr	r3, [pc, #24]	; (8670 <touch_process+0x180>)
    8656:	7e1b      	ldrb	r3, [r3, #24]
    8658:	2b02      	cmp	r3, #2
    865a:	d003      	beq.n	8664 <touch_process+0x174>
    865c:	6a73      	ldr	r3, [r6, #36]	; 0x24
    865e:	2b00      	cmp	r3, #0
    8660:	d000      	beq.n	8664 <touch_process+0x174>
    8662:	4798      	blx	r3
    8664:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    8666:	46c0      	nop			; (mov r8, r8)
    8668:	00008e29 	.word	0x00008e29
    866c:	000084c1 	.word	0x000084c1
    8670:	200009bc 	.word	0x200009bc
    8674:	000084e1 	.word	0x000084e1
    8678:	000096f9 	.word	0x000096f9
    867c:	20000b64 	.word	0x20000b64
    8680:	fffffeff 	.word	0xfffffeff

00008684 <touch_init_sensing>:
    8684:	b570      	push	{r4, r5, r6, lr}
    8686:	2500      	movs	r5, #0
    8688:	8906      	ldrh	r6, [r0, #8]
    868a:	1c04      	adds	r4, r0, #0
    868c:	87c5      	strh	r5, [r0, #62]	; 0x3e
    868e:	42b5      	cmp	r5, r6
    8690:	d20d      	bcs.n	86ae <touch_init_sensing+0x2a>
    8692:	1c23      	adds	r3, r4, #0
    8694:	3390      	adds	r3, #144	; 0x90
    8696:	681b      	ldr	r3, [r3, #0]
    8698:	00ea      	lsls	r2, r5, #3
    869a:	5cd3      	ldrb	r3, [r2, r3]
    869c:	2b40      	cmp	r3, #64	; 0x40
    869e:	d003      	beq.n	86a8 <touch_init_sensing+0x24>
    86a0:	b2e9      	uxtb	r1, r5
    86a2:	1c20      	adds	r0, r4, #0
    86a4:	4b0a      	ldr	r3, [pc, #40]	; (86d0 <touch_init_sensing+0x4c>)
    86a6:	4798      	blx	r3
    86a8:	3501      	adds	r5, #1
    86aa:	b2ad      	uxth	r5, r5
    86ac:	e7ef      	b.n	868e <touch_init_sensing+0xa>
    86ae:	8863      	ldrh	r3, [r4, #2]
    86b0:	2000      	movs	r0, #0
    86b2:	1dd9      	adds	r1, r3, #7
    86b4:	1ca2      	adds	r2, r4, #2
    86b6:	08c9      	lsrs	r1, r1, #3
    86b8:	8260      	strh	r0, [r4, #18]
    86ba:	b2c9      	uxtb	r1, r1
    86bc:	87d3      	strh	r3, [r2, #62]	; 0x3e
    86be:	3246      	adds	r2, #70	; 0x46
    86c0:	8013      	strh	r3, [r2, #0]
    86c2:	7211      	strb	r1, [r2, #8]
    86c4:	7ae1      	ldrb	r1, [r4, #11]
    86c6:	7411      	strb	r1, [r2, #16]
    86c8:	8921      	ldrh	r1, [r4, #8]
    86ca:	8311      	strh	r1, [r2, #24]
    86cc:	86a3      	strh	r3, [r4, #52]	; 0x34
    86ce:	bd70      	pop	{r4, r5, r6, pc}
    86d0:	00008dc5 	.word	0x00008dc5

000086d4 <touch_get_sensor_delta>:
    86d4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    86d6:	1c03      	adds	r3, r0, #0
    86d8:	3390      	adds	r3, #144	; 0x90
    86da:	681b      	ldr	r3, [r3, #0]
    86dc:	00cd      	lsls	r5, r1, #3
    86de:	9100      	str	r1, [sp, #0]
    86e0:	195b      	adds	r3, r3, r5
    86e2:	7959      	ldrb	r1, [r3, #5]
    86e4:	1d42      	adds	r2, r0, #5
    86e6:	9101      	str	r1, [sp, #4]
    86e8:	7919      	ldrb	r1, [r3, #4]
    86ea:	7fd2      	ldrb	r2, [r2, #31]
    86ec:	1c04      	adds	r4, r0, #0
    86ee:	4111      	asrs	r1, r2
    86f0:	b2ce      	uxtb	r6, r1
    86f2:	2e03      	cmp	r6, #3
    86f4:	d800      	bhi.n	86f8 <touch_get_sensor_delta+0x24>
    86f6:	2604      	movs	r6, #4
    86f8:	8922      	ldrh	r2, [r4, #8]
    86fa:	9900      	ldr	r1, [sp, #0]
    86fc:	2000      	movs	r0, #0
    86fe:	428a      	cmp	r2, r1
    8700:	d92c      	bls.n	875c <touch_get_sensor_delta+0x88>
    8702:	78da      	ldrb	r2, [r3, #3]
    8704:	2104      	movs	r1, #4
    8706:	438a      	bics	r2, r1
    8708:	1c27      	adds	r7, r4, #0
    870a:	70da      	strb	r2, [r3, #3]
    870c:	3790      	adds	r7, #144	; 0x90
    870e:	683a      	ldr	r2, [r7, #0]
    8710:	1953      	adds	r3, r2, r5
    8712:	78db      	ldrb	r3, [r3, #3]
    8714:	223f      	movs	r2, #63	; 0x3f
    8716:	4393      	bics	r3, r2
    8718:	4283      	cmp	r3, r0
    871a:	d110      	bne.n	873e <touch_get_sensor_delta+0x6a>
    871c:	4b10      	ldr	r3, [pc, #64]	; (8760 <touch_get_sensor_delta+0x8c>)
    871e:	1c20      	adds	r0, r4, #0
    8720:	9901      	ldr	r1, [sp, #4]
    8722:	4798      	blx	r3
    8724:	4273      	negs	r3, r6
    8726:	4298      	cmp	r0, r3
    8728:	dc09      	bgt.n	873e <touch_get_sensor_delta+0x6a>
    872a:	1ca3      	adds	r3, r4, #2
    872c:	7fdb      	ldrb	r3, [r3, #31]
    872e:	2b00      	cmp	r3, #0
    8730:	d005      	beq.n	873e <touch_get_sensor_delta+0x6a>
    8732:	6839      	ldr	r1, [r7, #0]
    8734:	194b      	adds	r3, r1, r5
    8736:	78da      	ldrb	r2, [r3, #3]
    8738:	2104      	movs	r1, #4
    873a:	430a      	orrs	r2, r1
    873c:	70da      	strb	r2, [r3, #3]
    873e:	683b      	ldr	r3, [r7, #0]
    8740:	223f      	movs	r2, #63	; 0x3f
    8742:	195d      	adds	r5, r3, r5
    8744:	78eb      	ldrb	r3, [r5, #3]
    8746:	4393      	bics	r3, r2
    8748:	d008      	beq.n	875c <touch_get_sensor_delta+0x88>
    874a:	4b06      	ldr	r3, [pc, #24]	; (8764 <touch_get_sensor_delta+0x90>)
    874c:	68dd      	ldr	r5, [r3, #12]
    874e:	2d00      	cmp	r5, #0
    8750:	d004      	beq.n	875c <touch_get_sensor_delta+0x88>
    8752:	1c20      	adds	r0, r4, #0
    8754:	9900      	ldr	r1, [sp, #0]
    8756:	9a01      	ldr	r2, [sp, #4]
    8758:	1c33      	adds	r3, r6, #0
    875a:	47a8      	blx	r5
    875c:	b200      	sxth	r0, r0
    875e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    8760:	00008ded 	.word	0x00008ded
    8764:	200009bc 	.word	0x200009bc

00008768 <touch_memset>:
    8768:	b2c9      	uxtb	r1, r1
    876a:	1c03      	adds	r3, r0, #0
    876c:	1882      	adds	r2, r0, r2
    876e:	4293      	cmp	r3, r2
    8770:	d002      	beq.n	8778 <touch_memset+0x10>
    8772:	7019      	strb	r1, [r3, #0]
    8774:	3301      	adds	r3, #1
    8776:	e7fa      	b.n	876e <touch_memset+0x6>
    8778:	4770      	bx	lr
	...

0000877c <touch_self_process>:
    877c:	b510      	push	{r4, lr}
    877e:	4808      	ldr	r0, [pc, #32]	; (87a0 <touch_self_process+0x24>)
    8780:	7843      	ldrb	r3, [r0, #1]
    8782:	1c04      	adds	r4, r0, #0
    8784:	2b01      	cmp	r3, #1
    8786:	d104      	bne.n	8792 <touch_self_process+0x16>
    8788:	4b06      	ldr	r3, [pc, #24]	; (87a4 <touch_self_process+0x28>)
    878a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    878c:	2b00      	cmp	r3, #0
    878e:	d000      	beq.n	8792 <touch_self_process+0x16>
    8790:	4798      	blx	r3
    8792:	4a05      	ldr	r2, [pc, #20]	; (87a8 <touch_self_process+0x2c>)
    8794:	4b05      	ldr	r3, [pc, #20]	; (87ac <touch_self_process+0x30>)
    8796:	1c20      	adds	r0, r4, #0
    8798:	601a      	str	r2, [r3, #0]
    879a:	4b05      	ldr	r3, [pc, #20]	; (87b0 <touch_self_process+0x34>)
    879c:	4798      	blx	r3
    879e:	bd10      	pop	{r4, pc}
    87a0:	200009ec 	.word	0x200009ec
    87a4:	20000aec 	.word	0x20000aec
    87a8:	00009ced 	.word	0x00009ced
    87ac:	20000b74 	.word	0x20000b74
    87b0:	00009a99 	.word	0x00009a99

000087b4 <touch_selfcap_sensors_init_with_rs_table>:
    87b4:	b5f0      	push	{r4, r5, r6, r7, lr}
    87b6:	b08b      	sub	sp, #44	; 0x2c
    87b8:	9002      	str	r0, [sp, #8]
    87ba:	1c0d      	adds	r5, r1, #0
    87bc:	9203      	str	r2, [sp, #12]
    87be:	9308      	str	r3, [sp, #32]
    87c0:	2800      	cmp	r0, #0
    87c2:	d001      	beq.n	87c8 <touch_selfcap_sensors_init_with_rs_table+0x14>
    87c4:	6844      	ldr	r4, [r0, #4]
    87c6:	e000      	b.n	87ca <touch_selfcap_sensors_init_with_rs_table+0x16>
    87c8:	9c02      	ldr	r4, [sp, #8]
    87ca:	4bd5      	ldr	r3, [pc, #852]	; (8b20 <touch_selfcap_sensors_init_with_rs_table+0x36c>)
    87cc:	2703      	movs	r7, #3
    87ce:	781e      	ldrb	r6, [r3, #0]
    87d0:	b2f6      	uxtb	r6, r6
    87d2:	2e00      	cmp	r6, #0
    87d4:	d000      	beq.n	87d8 <touch_selfcap_sensors_init_with_rs_table+0x24>
    87d6:	e19f      	b.n	8b18 <touch_selfcap_sensors_init_with_rs_table+0x364>
    87d8:	9802      	ldr	r0, [sp, #8]
    87da:	2800      	cmp	r0, #0
    87dc:	d100      	bne.n	87e0 <touch_selfcap_sensors_init_with_rs_table+0x2c>
    87de:	e19a      	b.n	8b16 <touch_selfcap_sensors_init_with_rs_table+0x362>
    87e0:	2c00      	cmp	r4, #0
    87e2:	d100      	bne.n	87e6 <touch_selfcap_sensors_init_with_rs_table+0x32>
    87e4:	e197      	b.n	8b16 <touch_selfcap_sensors_init_with_rs_table+0x362>
    87e6:	8823      	ldrh	r3, [r4, #0]
    87e8:	2704      	movs	r7, #4
    87ea:	2b00      	cmp	r3, #0
    87ec:	d100      	bne.n	87f0 <touch_selfcap_sensors_init_with_rs_table+0x3c>
    87ee:	e193      	b.n	8b18 <touch_selfcap_sensors_init_with_rs_table+0x364>
    87f0:	8863      	ldrh	r3, [r4, #2]
    87f2:	2b00      	cmp	r3, #0
    87f4:	d100      	bne.n	87f8 <touch_selfcap_sensors_init_with_rs_table+0x44>
    87f6:	e18f      	b.n	8b18 <touch_selfcap_sensors_init_with_rs_table+0x364>
    87f8:	6c20      	ldr	r0, [r4, #64]	; 0x40
    87fa:	2800      	cmp	r0, #0
    87fc:	d100      	bne.n	8800 <touch_selfcap_sensors_init_with_rs_table+0x4c>
    87fe:	e18b      	b.n	8b18 <touch_selfcap_sensors_init_with_rs_table+0x364>
    8800:	1da1      	adds	r1, r4, #6
    8802:	9101      	str	r1, [sp, #4]
    8804:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
    8806:	2a00      	cmp	r2, #0
    8808:	d100      	bne.n	880c <touch_selfcap_sensors_init_with_rs_table+0x58>
    880a:	e185      	b.n	8b18 <touch_selfcap_sensors_init_with_rs_table+0x364>
    880c:	7ba3      	ldrb	r3, [r4, #14]
    880e:	2706      	movs	r7, #6
    8810:	2b04      	cmp	r3, #4
    8812:	d900      	bls.n	8816 <touch_selfcap_sensors_init_with_rs_table+0x62>
    8814:	e180      	b.n	8b18 <touch_selfcap_sensors_init_with_rs_table+0x364>
    8816:	1c31      	adds	r1, r6, #0
    8818:	4bc2      	ldr	r3, [pc, #776]	; (8b24 <touch_selfcap_sensors_init_with_rs_table+0x370>)
    881a:	4798      	blx	r3
    881c:	4bc2      	ldr	r3, [pc, #776]	; (8b28 <touch_selfcap_sensors_init_with_rs_table+0x374>)
    881e:	9901      	ldr	r1, [sp, #4]
    8820:	62dd      	str	r5, [r3, #44]	; 0x2c
    8822:	9d03      	ldr	r5, [sp, #12]
    8824:	2218      	movs	r2, #24
    8826:	631d      	str	r5, [r3, #48]	; 0x30
    8828:	4dc0      	ldr	r5, [pc, #768]	; (8b2c <touch_selfcap_sensors_init_with_rs_table+0x378>)
    882a:	2301      	movs	r3, #1
    882c:	702b      	strb	r3, [r5, #0]
    882e:	8823      	ldrh	r3, [r4, #0]
    8830:	80ae      	strh	r6, [r5, #4]
    8832:	806b      	strh	r3, [r5, #2]
    8834:	8863      	ldrh	r3, [r4, #2]
    8836:	812e      	strh	r6, [r5, #8]
    8838:	80eb      	strh	r3, [r5, #6]
    883a:	7923      	ldrb	r3, [r4, #4]
    883c:	1c28      	adds	r0, r5, #0
    883e:	72ab      	strb	r3, [r5, #10]
    8840:	301c      	adds	r0, #28
    8842:	4bbb      	ldr	r3, [pc, #748]	; (8b30 <touch_selfcap_sensors_init_with_rs_table+0x37c>)
    8844:	72ee      	strb	r6, [r5, #11]
    8846:	73ae      	strb	r6, [r5, #14]
    8848:	73ee      	strb	r6, [r5, #15]
    884a:	826e      	strh	r6, [r5, #18]
    884c:	82ae      	strh	r6, [r5, #20]
    884e:	75ae      	strb	r6, [r5, #22]
    8850:	4798      	blx	r3
    8852:	1c23      	adds	r3, r4, #0
    8854:	3354      	adds	r3, #84	; 0x54
    8856:	781b      	ldrb	r3, [r3, #0]
    8858:	1c22      	adds	r2, r4, #0
    885a:	9303      	str	r3, [sp, #12]
    885c:	9e03      	ldr	r6, [sp, #12]
    885e:	1c2b      	adds	r3, r5, #0
    8860:	33e8      	adds	r3, #232	; 0xe8
    8862:	701e      	strb	r6, [r3, #0]
    8864:	1c23      	adds	r3, r4, #0
    8866:	3355      	adds	r3, #85	; 0x55
    8868:	781b      	ldrb	r3, [r3, #0]
    886a:	3258      	adds	r2, #88	; 0x58
    886c:	9307      	str	r3, [sp, #28]
    886e:	9807      	ldr	r0, [sp, #28]
    8870:	1c2b      	adds	r3, r5, #0
    8872:	33e9      	adds	r3, #233	; 0xe9
    8874:	7018      	strb	r0, [r3, #0]
    8876:	1c23      	adds	r3, r4, #0
    8878:	3357      	adds	r3, #87	; 0x57
    887a:	781b      	ldrb	r3, [r3, #0]
    887c:	9209      	str	r2, [sp, #36]	; 0x24
    887e:	469c      	mov	ip, r3
    8880:	1c2b      	adds	r3, r5, #0
    8882:	33ec      	adds	r3, #236	; 0xec
    8884:	4661      	mov	r1, ip
    8886:	7019      	strb	r1, [r3, #0]
    8888:	7812      	ldrb	r2, [r2, #0]
    888a:	1c2b      	adds	r3, r5, #0
    888c:	33eb      	adds	r3, #235	; 0xeb
    888e:	701a      	strb	r2, [r3, #0]
    8890:	1c23      	adds	r3, r4, #0
    8892:	3359      	adds	r3, #89	; 0x59
    8894:	781a      	ldrb	r2, [r3, #0]
    8896:	1c2b      	adds	r3, r5, #0
    8898:	33ed      	adds	r3, #237	; 0xed
    889a:	701a      	strb	r2, [r3, #0]
    889c:	1c23      	adds	r3, r4, #0
    889e:	3356      	adds	r3, #86	; 0x56
    88a0:	781a      	ldrb	r2, [r3, #0]
    88a2:	1c2b      	adds	r3, r5, #0
    88a4:	33ea      	adds	r3, #234	; 0xea
    88a6:	701a      	strb	r2, [r3, #0]
    88a8:	6c22      	ldr	r2, [r4, #64]	; 0x40
    88aa:	2303      	movs	r3, #3
    88ac:	3203      	adds	r2, #3
    88ae:	439a      	bics	r2, r3
    88b0:	9204      	str	r2, [sp, #16]
    88b2:	9e04      	ldr	r6, [sp, #16]
    88b4:	1c2a      	adds	r2, r5, #0
    88b6:	3290      	adds	r2, #144	; 0x90
    88b8:	6016      	str	r6, [r2, #0]
    88ba:	8860      	ldrh	r0, [r4, #2]
    88bc:	00c2      	lsls	r2, r0, #3
    88be:	18b2      	adds	r2, r6, r2
    88c0:	18d2      	adds	r2, r2, r3
    88c2:	439a      	bics	r2, r3
    88c4:	9201      	str	r2, [sp, #4]
    88c6:	9901      	ldr	r1, [sp, #4]
    88c8:	1c2a      	adds	r2, r5, #0
    88ca:	3294      	adds	r2, #148	; 0x94
    88cc:	6011      	str	r1, [r2, #0]
    88ce:	8822      	ldrh	r2, [r4, #0]
    88d0:	9e01      	ldr	r6, [sp, #4]
    88d2:	0051      	lsls	r1, r2, #1
    88d4:	9000      	str	r0, [sp, #0]
    88d6:	1870      	adds	r0, r6, r1
    88d8:	18c6      	adds	r6, r0, r3
    88da:	1c28      	adds	r0, r5, #0
    88dc:	439e      	bics	r6, r3
    88de:	3098      	adds	r0, #152	; 0x98
    88e0:	6006      	str	r6, [r0, #0]
    88e2:	1870      	adds	r0, r6, r1
    88e4:	9605      	str	r6, [sp, #20]
    88e6:	18c6      	adds	r6, r0, r3
    88e8:	439e      	bics	r6, r3
    88ea:	1c28      	adds	r0, r5, #0
    88ec:	309c      	adds	r0, #156	; 0x9c
    88ee:	1871      	adds	r1, r6, r1
    88f0:	6006      	str	r6, [r0, #0]
    88f2:	9606      	str	r6, [sp, #24]
    88f4:	18c9      	adds	r1, r1, r3
    88f6:	1c2e      	adds	r6, r5, #0
    88f8:	4399      	bics	r1, r3
    88fa:	36a0      	adds	r6, #160	; 0xa0
    88fc:	6031      	str	r1, [r6, #0]
    88fe:	1889      	adds	r1, r1, r2
    8900:	18c9      	adds	r1, r1, r3
    8902:	1c2e      	adds	r6, r5, #0
    8904:	36b4      	adds	r6, #180	; 0xb4
    8906:	4399      	bics	r1, r3
    8908:	4660      	mov	r0, ip
    890a:	6031      	str	r1, [r6, #0]
    890c:	8826      	ldrh	r6, [r4, #0]
    890e:	2800      	cmp	r0, #0
    8910:	d01b      	beq.n	894a <touch_selfcap_sensors_init_with_rs_table+0x196>
    8912:	437a      	muls	r2, r7
    8914:	9800      	ldr	r0, [sp, #0]
    8916:	1889      	adds	r1, r1, r2
    8918:	18c9      	adds	r1, r1, r3
    891a:	1c2a      	adds	r2, r5, #0
    891c:	32fc      	adds	r2, #252	; 0xfc
    891e:	4399      	bics	r1, r3
    8920:	0087      	lsls	r7, r0, #2
    8922:	6091      	str	r1, [r2, #8]
    8924:	19c9      	adds	r1, r1, r7
    8926:	18c9      	adds	r1, r1, r3
    8928:	3007      	adds	r0, #7
    892a:	4399      	bics	r1, r3
    892c:	4118      	asrs	r0, r3
    892e:	1808      	adds	r0, r1, r0
    8930:	18c0      	adds	r0, r0, r3
    8932:	4398      	bics	r0, r3
    8934:	6111      	str	r1, [r2, #16]
    8936:	60d0      	str	r0, [r2, #12]
    8938:	9a09      	ldr	r2, [sp, #36]	; 0x24
    893a:	35bc      	adds	r5, #188	; 0xbc
    893c:	7811      	ldrb	r1, [r2, #0]
    893e:	4099      	lsls	r1, r3
    8940:	1841      	adds	r1, r0, r1
    8942:	18c9      	adds	r1, r1, r3
    8944:	4399      	bics	r1, r3
    8946:	6029      	str	r1, [r5, #0]
    8948:	e005      	b.n	8956 <touch_selfcap_sensors_init_with_rs_table+0x1a2>
    894a:	437a      	muls	r2, r7
    894c:	188a      	adds	r2, r1, r2
    894e:	3203      	adds	r2, #3
    8950:	35bc      	adds	r5, #188	; 0xbc
    8952:	439a      	bics	r2, r3
    8954:	602a      	str	r2, [r5, #0]
    8956:	4b75      	ldr	r3, [pc, #468]	; (8b2c <touch_selfcap_sensors_init_with_rs_table+0x378>)
    8958:	250c      	movs	r5, #12
    895a:	1c1a      	adds	r2, r3, #0
    895c:	32bc      	adds	r2, #188	; 0xbc
    895e:	6810      	ldr	r0, [r2, #0]
    8960:	1c19      	adds	r1, r3, #0
    8962:	2203      	movs	r2, #3
    8964:	300b      	adds	r0, #11
    8966:	4390      	bics	r0, r2
    8968:	31c0      	adds	r1, #192	; 0xc0
    896a:	6008      	str	r0, [r1, #0]
    896c:	300b      	adds	r0, #11
    896e:	1c19      	adds	r1, r3, #0
    8970:	4390      	bics	r0, r2
    8972:	31a4      	adds	r1, #164	; 0xa4
    8974:	6008      	str	r0, [r1, #0]
    8976:	7921      	ldrb	r1, [r4, #4]
    8978:	434d      	muls	r5, r1
    897a:	1940      	adds	r0, r0, r5
    897c:	1880      	adds	r0, r0, r2
    897e:	1c07      	adds	r7, r0, #0
    8980:	4397      	bics	r7, r2
    8982:	1c18      	adds	r0, r3, #0
    8984:	30a8      	adds	r0, #168	; 0xa8
    8986:	1879      	adds	r1, r7, r1
    8988:	6007      	str	r7, [r0, #0]
    898a:	1889      	adds	r1, r1, r2
    898c:	1c18      	adds	r0, r3, #0
    898e:	9d07      	ldr	r5, [sp, #28]
    8990:	4391      	bics	r1, r2
    8992:	30b0      	adds	r0, #176	; 0xb0
    8994:	6001      	str	r1, [r0, #0]
    8996:	2d00      	cmp	r5, #0
    8998:	d02b      	beq.n	89f2 <touch_selfcap_sensors_init_with_rs_table+0x23e>
    899a:	8865      	ldrh	r5, [r4, #2]
    899c:	1c18      	adds	r0, r3, #0
    899e:	3507      	adds	r5, #7
    89a0:	4115      	asrs	r5, r2
    89a2:	194d      	adds	r5, r1, r5
    89a4:	18ad      	adds	r5, r5, r2
    89a6:	4395      	bics	r5, r2
    89a8:	30f0      	adds	r0, #240	; 0xf0
    89aa:	6005      	str	r5, [r0, #0]
    89ac:	1df0      	adds	r0, r6, #7
    89ae:	4110      	asrs	r0, r2
    89b0:	182d      	adds	r5, r5, r0
    89b2:	18ad      	adds	r5, r5, r2
    89b4:	9007      	str	r0, [sp, #28]
    89b6:	4395      	bics	r5, r2
    89b8:	20f4      	movs	r0, #244	; 0xf4
    89ba:	50c5      	str	r5, [r0, r3]
    89bc:	9807      	ldr	r0, [sp, #28]
    89be:	182d      	adds	r5, r5, r0
    89c0:	18ad      	adds	r5, r5, r2
    89c2:	1c18      	adds	r0, r3, #0
    89c4:	4395      	bics	r5, r2
    89c6:	30f8      	adds	r0, #248	; 0xf8
    89c8:	6005      	str	r5, [r0, #0]
    89ca:	0070      	lsls	r0, r6, #1
    89cc:	182d      	adds	r5, r5, r0
    89ce:	18ad      	adds	r5, r5, r2
    89d0:	1c18      	adds	r0, r3, #0
    89d2:	4395      	bics	r5, r2
    89d4:	30fc      	adds	r0, #252	; 0xfc
    89d6:	46ac      	mov	ip, r5
    89d8:	6005      	str	r5, [r0, #0]
    89da:	9d03      	ldr	r5, [sp, #12]
    89dc:	2d00      	cmp	r5, #0
    89de:	d012      	beq.n	8a06 <touch_selfcap_sensors_init_with_rs_table+0x252>
    89e0:	33ea      	adds	r3, #234	; 0xea
    89e2:	781b      	ldrb	r3, [r3, #0]
    89e4:	4373      	muls	r3, r6
    89e6:	005b      	lsls	r3, r3, #1
    89e8:	4463      	add	r3, ip
    89ea:	189b      	adds	r3, r3, r2
    89ec:	4393      	bics	r3, r2
    89ee:	6043      	str	r3, [r0, #4]
    89f0:	e009      	b.n	8a06 <touch_selfcap_sensors_init_with_rs_table+0x252>
    89f2:	9803      	ldr	r0, [sp, #12]
    89f4:	2800      	cmp	r0, #0
    89f6:	d006      	beq.n	8a06 <touch_selfcap_sensors_init_with_rs_table+0x252>
    89f8:	3607      	adds	r6, #7
    89fa:	10f6      	asrs	r6, r6, #3
    89fc:	198e      	adds	r6, r1, r6
    89fe:	3603      	adds	r6, #3
    8a00:	33fc      	adds	r3, #252	; 0xfc
    8a02:	4396      	bics	r6, r2
    8a04:	605e      	str	r6, [r3, #4]
    8a06:	4d49      	ldr	r5, [pc, #292]	; (8b2c <touch_selfcap_sensors_init_with_rs_table+0x378>)
    8a08:	6d22      	ldr	r2, [r4, #80]	; 0x50
    8a0a:	1c2b      	adds	r3, r5, #0
    8a0c:	33fc      	adds	r3, #252	; 0xfc
    8a0e:	4849      	ldr	r0, [pc, #292]	; (8b34 <touch_selfcap_sensors_init_with_rs_table+0x380>)
    8a10:	9e01      	ldr	r6, [sp, #4]
    8a12:	621a      	str	r2, [r3, #32]
    8a14:	2200      	movs	r2, #0
    8a16:	87ea      	strh	r2, [r5, #62]	; 0x3e
    8a18:	6298      	str	r0, [r3, #40]	; 0x28
    8a1a:	646e      	str	r6, [r5, #68]	; 0x44
    8a1c:	9805      	ldr	r0, [sp, #20]
    8a1e:	9e06      	ldr	r6, [sp, #24]
    8a20:	64e8      	str	r0, [r5, #76]	; 0x4c
    8a22:	666e      	str	r6, [r5, #100]	; 0x64
    8a24:	6569      	str	r1, [r5, #84]	; 0x54
    8a26:	1c29      	adds	r1, r5, #0
    8a28:	31f0      	adds	r1, #240	; 0xf0
    8a2a:	6809      	ldr	r1, [r1, #0]
    8a2c:	6918      	ldr	r0, [r3, #16]
    8a2e:	66e9      	str	r1, [r5, #108]	; 0x6c
    8a30:	1c29      	adds	r1, r5, #0
    8a32:	31f8      	adds	r1, #248	; 0xf8
    8a34:	6809      	ldr	r1, [r1, #0]
    8a36:	9e01      	ldr	r6, [sp, #4]
    8a38:	6729      	str	r1, [r5, #112]	; 0x70
    8a3a:	9904      	ldr	r1, [sp, #16]
    8a3c:	6768      	str	r0, [r5, #116]	; 0x74
    8a3e:	6ca0      	ldr	r0, [r4, #72]	; 0x48
    8a40:	65ef      	str	r7, [r5, #92]	; 0x5c
    8a42:	66a9      	str	r1, [r5, #104]	; 0x68
    8a44:	1c29      	adds	r1, r5, #0
    8a46:	31c4      	adds	r1, #196	; 0xc4
    8a48:	6008      	str	r0, [r1, #0]
    8a4a:	63ae      	str	r6, [r5, #56]	; 0x38
    8a4c:	1c29      	adds	r1, r5, #0
    8a4e:	6a26      	ldr	r6, [r4, #32]
    8a50:	31c8      	adds	r1, #200	; 0xc8
    8a52:	600e      	str	r6, [r1, #0]
    8a54:	625a      	str	r2, [r3, #36]	; 0x24
    8a56:	1d60      	adds	r0, r4, #5
    8a58:	7fc0      	ldrb	r0, [r0, #31]
    8a5a:	1c29      	adds	r1, r5, #0
    8a5c:	31cc      	adds	r1, #204	; 0xcc
    8a5e:	7008      	strb	r0, [r1, #0]
    8a60:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    8a62:	1c29      	adds	r1, r5, #0
    8a64:	31d0      	adds	r1, #208	; 0xd0
    8a66:	6008      	str	r0, [r1, #0]
    8a68:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    8a6a:	1c29      	adds	r1, r5, #0
    8a6c:	31d4      	adds	r1, #212	; 0xd4
    8a6e:	600e      	str	r6, [r1, #0]
    8a70:	6b20      	ldr	r0, [r4, #48]	; 0x30
    8a72:	1c29      	adds	r1, r5, #0
    8a74:	31d8      	adds	r1, #216	; 0xd8
    8a76:	6008      	str	r0, [r1, #0]
    8a78:	6b66      	ldr	r6, [r4, #52]	; 0x34
    8a7a:	1c29      	adds	r1, r5, #0
    8a7c:	31dc      	adds	r1, #220	; 0xdc
    8a7e:	600e      	str	r6, [r1, #0]
    8a80:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    8a82:	1c29      	adds	r1, r5, #0
    8a84:	31e0      	adds	r1, #224	; 0xe0
    8a86:	6008      	str	r0, [r1, #0]
    8a88:	1c20      	adds	r0, r4, #0
    8a8a:	303d      	adds	r0, #61	; 0x3d
    8a8c:	7800      	ldrb	r0, [r0, #0]
    8a8e:	1c29      	adds	r1, r5, #0
    8a90:	31e5      	adds	r1, #229	; 0xe5
    8a92:	7008      	strb	r0, [r1, #0]
    8a94:	1c20      	adds	r0, r4, #0
    8a96:	303c      	adds	r0, #60	; 0x3c
    8a98:	7800      	ldrb	r0, [r0, #0]
    8a9a:	1c29      	adds	r1, r5, #0
    8a9c:	9e02      	ldr	r6, [sp, #8]
    8a9e:	31e4      	adds	r1, #228	; 0xe4
    8aa0:	7008      	strb	r0, [r1, #0]
    8aa2:	7a30      	ldrb	r0, [r6, #8]
    8aa4:	1c29      	adds	r1, r5, #0
    8aa6:	31e7      	adds	r1, #231	; 0xe7
    8aa8:	7008      	strb	r0, [r1, #0]
    8aaa:	1c21      	adds	r1, r4, #0
    8aac:	314c      	adds	r1, #76	; 0x4c
    8aae:	7808      	ldrb	r0, [r1, #0]
    8ab0:	1c29      	adds	r1, r5, #0
    8ab2:	736a      	strb	r2, [r5, #13]
    8ab4:	836a      	strh	r2, [r5, #26]
    8ab6:	31e6      	adds	r1, #230	; 0xe6
    8ab8:	1c2a      	adds	r2, r5, #0
    8aba:	7008      	strb	r0, [r1, #0]
    8abc:	327c      	adds	r2, #124	; 0x7c
    8abe:	345c      	adds	r4, #92	; 0x5c
    8ac0:	cc43      	ldmia	r4!, {r0, r1, r6}
    8ac2:	c243      	stmia	r2!, {r0, r1, r6}
    8ac4:	6824      	ldr	r4, [r4, #0]
    8ac6:	6014      	str	r4, [r2, #0]
    8ac8:	6fe8      	ldr	r0, [r5, #124]	; 0x7c
    8aca:	1c2a      	adds	r2, r5, #0
    8acc:	61d8      	str	r0, [r3, #28]
    8ace:	4b1a      	ldr	r3, [pc, #104]	; (8b38 <touch_selfcap_sensors_init_with_rs_table+0x384>)
    8ad0:	323c      	adds	r2, #60	; 0x3c
    8ad2:	601a      	str	r2, [r3, #0]
    8ad4:	4a19      	ldr	r2, [pc, #100]	; (8b3c <touch_selfcap_sensors_init_with_rs_table+0x388>)
    8ad6:	4b1a      	ldr	r3, [pc, #104]	; (8b40 <touch_selfcap_sensors_init_with_rs_table+0x38c>)
    8ad8:	4c13      	ldr	r4, [pc, #76]	; (8b28 <touch_selfcap_sensors_init_with_rs_table+0x374>)
    8ada:	601a      	str	r2, [r3, #0]
    8adc:	4b19      	ldr	r3, [pc, #100]	; (8b44 <touch_selfcap_sensors_init_with_rs_table+0x390>)
    8ade:	1c28      	adds	r0, r5, #0
    8ae0:	6363      	str	r3, [r4, #52]	; 0x34
    8ae2:	4b19      	ldr	r3, [pc, #100]	; (8b48 <touch_selfcap_sensors_init_with_rs_table+0x394>)
    8ae4:	4798      	blx	r3
    8ae6:	6b23      	ldr	r3, [r4, #48]	; 0x30
    8ae8:	2b00      	cmp	r3, #0
    8aea:	d000      	beq.n	8aee <touch_selfcap_sensors_init_with_rs_table+0x33a>
    8aec:	4798      	blx	r3
    8aee:	9e08      	ldr	r6, [sp, #32]
    8af0:	2e00      	cmp	r6, #0
    8af2:	d001      	beq.n	8af8 <touch_selfcap_sensors_init_with_rs_table+0x344>
    8af4:	2001      	movs	r0, #1
    8af6:	47b0      	blx	r6
    8af8:	9e10      	ldr	r6, [sp, #64]	; 0x40
    8afa:	2e00      	cmp	r6, #0
    8afc:	d001      	beq.n	8b02 <touch_selfcap_sensors_init_with_rs_table+0x34e>
    8afe:	1c28      	adds	r0, r5, #0
    8b00:	47b0      	blx	r6
    8b02:	3588      	adds	r5, #136	; 0x88
    8b04:	682b      	ldr	r3, [r5, #0]
    8b06:	2b00      	cmp	r3, #0
    8b08:	d000      	beq.n	8b0c <touch_selfcap_sensors_init_with_rs_table+0x358>
    8b0a:	4798      	blx	r3
    8b0c:	4b04      	ldr	r3, [pc, #16]	; (8b20 <touch_selfcap_sensors_init_with_rs_table+0x36c>)
    8b0e:	2201      	movs	r2, #1
    8b10:	701a      	strb	r2, [r3, #0]
    8b12:	2700      	movs	r7, #0
    8b14:	e000      	b.n	8b18 <touch_selfcap_sensors_init_with_rs_table+0x364>
    8b16:	2702      	movs	r7, #2
    8b18:	1c38      	adds	r0, r7, #0
    8b1a:	b00b      	add	sp, #44	; 0x2c
    8b1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8b1e:	46c0      	nop			; (mov r8, r8)
    8b20:	200009d4 	.word	0x200009d4
    8b24:	00008769 	.word	0x00008769
    8b28:	20000aec 	.word	0x20000aec
    8b2c:	200009ec 	.word	0x200009ec
    8b30:	0000a74d 	.word	0x0000a74d
    8b34:	0000877d 	.word	0x0000877d
    8b38:	20000384 	.word	0x20000384
    8b3c:	00009809 	.word	0x00009809
    8b40:	20000b54 	.word	0x20000b54
    8b44:	00009d59 	.word	0x00009d59
    8b48:	0000a1d1 	.word	0x0000a1d1

00008b4c <touch_selfcap_sensor_config>:
    8b4c:	b5f0      	push	{r4, r5, r6, r7, lr}
    8b4e:	b08b      	sub	sp, #44	; 0x2c
    8b50:	1c1f      	adds	r7, r3, #0
    8b52:	ab10      	add	r3, sp, #64	; 0x40
    8b54:	781b      	ldrb	r3, [r3, #0]
    8b56:	1c05      	adds	r5, r0, #0
    8b58:	9309      	str	r3, [sp, #36]	; 0x24
    8b5a:	ab11      	add	r3, sp, #68	; 0x44
    8b5c:	781b      	ldrb	r3, [r3, #0]
    8b5e:	1c0c      	adds	r4, r1, #0
    8b60:	9307      	str	r3, [sp, #28]
    8b62:	ab12      	add	r3, sp, #72	; 0x48
    8b64:	781b      	ldrb	r3, [r3, #0]
    8b66:	1c16      	adds	r6, r2, #0
    8b68:	9308      	str	r3, [sp, #32]
    8b6a:	4b25      	ldr	r3, [pc, #148]	; (8c00 <touch_selfcap_sensor_config+0xb4>)
    8b6c:	2003      	movs	r0, #3
    8b6e:	781b      	ldrb	r3, [r3, #0]
    8b70:	2b01      	cmp	r3, #1
    8b72:	d142      	bne.n	8bfa <touch_selfcap_sensor_config+0xae>
    8b74:	1e6b      	subs	r3, r5, #1
    8b76:	2008      	movs	r0, #8
    8b78:	2b03      	cmp	r3, #3
    8b7a:	d83e      	bhi.n	8bfa <touch_selfcap_sensor_config+0xae>
    8b7c:	2002      	movs	r0, #2
    8b7e:	2f07      	cmp	r7, #7
    8b80:	d83b      	bhi.n	8bfa <touch_selfcap_sensor_config+0xae>
    8b82:	9a07      	ldr	r2, [sp, #28]
    8b84:	2a03      	cmp	r2, #3
    8b86:	d838      	bhi.n	8bfa <touch_selfcap_sensor_config+0xae>
    8b88:	9b08      	ldr	r3, [sp, #32]
    8b8a:	2b07      	cmp	r3, #7
    8b8c:	d835      	bhi.n	8bfa <touch_selfcap_sensor_config+0xae>
    8b8e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    8b90:	2a00      	cmp	r2, #0
    8b92:	d032      	beq.n	8bfa <touch_selfcap_sensor_config+0xae>
    8b94:	4a1b      	ldr	r2, [pc, #108]	; (8c04 <touch_selfcap_sensor_config+0xb8>)
    8b96:	2007      	movs	r0, #7
    8b98:	8853      	ldrh	r3, [r2, #2]
    8b9a:	4299      	cmp	r1, r3
    8b9c:	d22d      	bcs.n	8bfa <touch_selfcap_sensor_config+0xae>
    8b9e:	429e      	cmp	r6, r3
    8ba0:	d22b      	bcs.n	8bfa <touch_selfcap_sensor_config+0xae>
    8ba2:	8891      	ldrh	r1, [r2, #4]
    8ba4:	4299      	cmp	r1, r3
    8ba6:	d228      	bcs.n	8bfa <touch_selfcap_sensor_config+0xae>
    8ba8:	2d01      	cmp	r5, #1
    8baa:	d004      	beq.n	8bb6 <touch_selfcap_sensor_config+0x6a>
    8bac:	2d04      	cmp	r5, #4
    8bae:	d105      	bne.n	8bbc <touch_selfcap_sensor_config+0x70>
    8bb0:	1e63      	subs	r3, r4, #1
    8bb2:	421c      	tst	r4, r3
    8bb4:	d102      	bne.n	8bbc <touch_selfcap_sensor_config+0x70>
    8bb6:	2007      	movs	r0, #7
    8bb8:	42b4      	cmp	r4, r6
    8bba:	d11e      	bne.n	8bfa <touch_selfcap_sensor_config+0xae>
    8bbc:	1eab      	subs	r3, r5, #2
    8bbe:	2b01      	cmp	r3, #1
    8bc0:	d803      	bhi.n	8bca <touch_selfcap_sensor_config+0x7e>
    8bc2:	7a93      	ldrb	r3, [r2, #10]
    8bc4:	200a      	movs	r0, #10
    8bc6:	2b00      	cmp	r3, #0
    8bc8:	d017      	beq.n	8bfa <touch_selfcap_sensor_config+0xae>
    8bca:	4b0f      	ldr	r3, [pc, #60]	; (8c08 <touch_selfcap_sensor_config+0xbc>)
    8bcc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    8bce:	2b00      	cmp	r3, #0
    8bd0:	d000      	beq.n	8bd4 <touch_selfcap_sensor_config+0x88>
    8bd2:	4798      	blx	r3
    8bd4:	480b      	ldr	r0, [pc, #44]	; (8c04 <touch_selfcap_sensor_config+0xb8>)
    8bd6:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    8bd8:	8903      	ldrh	r3, [r0, #8]
    8bda:	1c29      	adds	r1, r5, #0
    8bdc:	7013      	strb	r3, [r2, #0]
    8bde:	9b09      	ldr	r3, [sp, #36]	; 0x24
    8be0:	9a07      	ldr	r2, [sp, #28]
    8be2:	9301      	str	r3, [sp, #4]
    8be4:	9b08      	ldr	r3, [sp, #32]
    8be6:	9700      	str	r7, [sp, #0]
    8be8:	2700      	movs	r7, #0
    8bea:	9202      	str	r2, [sp, #8]
    8bec:	9303      	str	r3, [sp, #12]
    8bee:	1c22      	adds	r2, r4, #0
    8bf0:	9704      	str	r7, [sp, #16]
    8bf2:	1c33      	adds	r3, r6, #0
    8bf4:	4c05      	ldr	r4, [pc, #20]	; (8c0c <touch_selfcap_sensor_config+0xc0>)
    8bf6:	47a0      	blx	r4
    8bf8:	1c38      	adds	r0, r7, #0
    8bfa:	b00b      	add	sp, #44	; 0x2c
    8bfc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8bfe:	46c0      	nop			; (mov r8, r8)
    8c00:	200009d4 	.word	0x200009d4
    8c04:	200009ec 	.word	0x200009ec
    8c08:	20000aec 	.word	0x20000aec
    8c0c:	00008459 	.word	0x00008459

00008c10 <touch_selfcap_sensors_calibrate>:
    8c10:	b570      	push	{r4, r5, r6, lr}
    8c12:	4e12      	ldr	r6, [pc, #72]	; (8c5c <touch_selfcap_sensors_calibrate+0x4c>)
    8c14:	1c04      	adds	r4, r0, #0
    8c16:	7833      	ldrb	r3, [r6, #0]
    8c18:	2003      	movs	r0, #3
    8c1a:	2b00      	cmp	r3, #0
    8c1c:	d01d      	beq.n	8c5a <touch_selfcap_sensors_calibrate+0x4a>
    8c1e:	7833      	ldrb	r3, [r6, #0]
    8c20:	2b04      	cmp	r3, #4
    8c22:	d01a      	beq.n	8c5a <touch_selfcap_sensors_calibrate+0x4a>
    8c24:	2002      	movs	r0, #2
    8c26:	4284      	cmp	r4, r0
    8c28:	d817      	bhi.n	8c5a <touch_selfcap_sensors_calibrate+0x4a>
    8c2a:	4d0d      	ldr	r5, [pc, #52]	; (8c60 <touch_selfcap_sensors_calibrate+0x50>)
    8c2c:	4b0d      	ldr	r3, [pc, #52]	; (8c64 <touch_selfcap_sensors_calibrate+0x54>)
    8c2e:	1c28      	adds	r0, r5, #0
    8c30:	4798      	blx	r3
    8c32:	88ab      	ldrh	r3, [r5, #4]
    8c34:	836b      	strh	r3, [r5, #26]
    8c36:	2c00      	cmp	r4, #0
    8c38:	d00b      	beq.n	8c52 <touch_selfcap_sensors_calibrate+0x42>
    8c3a:	746b      	strb	r3, [r5, #17]
    8c3c:	2301      	movs	r3, #1
    8c3e:	742c      	strb	r4, [r5, #16]
    8c40:	732b      	strb	r3, [r5, #12]
    8c42:	429c      	cmp	r4, r3
    8c44:	d102      	bne.n	8c4c <touch_selfcap_sensors_calibrate+0x3c>
    8c46:	2200      	movs	r2, #0
    8c48:	4b07      	ldr	r3, [pc, #28]	; (8c68 <touch_selfcap_sensors_calibrate+0x58>)
    8c4a:	e001      	b.n	8c50 <touch_selfcap_sensors_calibrate+0x40>
    8c4c:	4b07      	ldr	r3, [pc, #28]	; (8c6c <touch_selfcap_sensors_calibrate+0x5c>)
    8c4e:	2203      	movs	r2, #3
    8c50:	701a      	strb	r2, [r3, #0]
    8c52:	2301      	movs	r3, #1
    8c54:	73ab      	strb	r3, [r5, #14]
    8c56:	2302      	movs	r3, #2
    8c58:	7033      	strb	r3, [r6, #0]
    8c5a:	bd70      	pop	{r4, r5, r6, pc}
    8c5c:	200009d4 	.word	0x200009d4
    8c60:	200009ec 	.word	0x200009ec
    8c64:	00008685 	.word	0x00008685
    8c68:	20000b50 	.word	0x20000b50
    8c6c:	200000c9 	.word	0x200000c9

00008c70 <goto_no_detect>:
    8c70:	b570      	push	{r4, r5, r6, lr}
    8c72:	1c04      	adds	r4, r0, #0
    8c74:	3490      	adds	r4, #144	; 0x90
    8c76:	6823      	ldr	r3, [r4, #0]
    8c78:	00c9      	lsls	r1, r1, #3
    8c7a:	185a      	adds	r2, r3, r1
    8c7c:	2502      	movs	r5, #2
    8c7e:	7015      	strb	r5, [r2, #0]
    8c80:	7953      	ldrb	r3, [r2, #5]
    8c82:	7996      	ldrb	r6, [r2, #6]
    8c84:	8fc2      	ldrh	r2, [r0, #62]	; 0x3e
    8c86:	4315      	orrs	r5, r2
    8c88:	6822      	ldr	r2, [r4, #0]
    8c8a:	87c5      	strh	r5, [r0, #62]	; 0x3e
    8c8c:	1851      	adds	r1, r2, r1
    8c8e:	2200      	movs	r2, #0
    8c90:	708a      	strb	r2, [r1, #2]
    8c92:	42b3      	cmp	r3, r6
    8c94:	d807      	bhi.n	8ca6 <goto_no_detect+0x36>
    8c96:	1c02      	adds	r2, r0, #0
    8c98:	32a0      	adds	r2, #160	; 0xa0
    8c9a:	6812      	ldr	r2, [r2, #0]
    8c9c:	2180      	movs	r1, #128	; 0x80
    8c9e:	54d1      	strb	r1, [r2, r3]
    8ca0:	3301      	adds	r3, #1
    8ca2:	b29b      	uxth	r3, r3
    8ca4:	e7f5      	b.n	8c92 <goto_no_detect+0x22>
    8ca6:	bd70      	pop	{r4, r5, r6, pc}

00008ca8 <calibrate_sensor>:
    8ca8:	b5f0      	push	{r4, r5, r6, r7, lr}
    8caa:	1c03      	adds	r3, r0, #0
    8cac:	3390      	adds	r3, #144	; 0x90
    8cae:	681b      	ldr	r3, [r3, #0]
    8cb0:	00c9      	lsls	r1, r1, #3
    8cb2:	1859      	adds	r1, r3, r1
    8cb4:	798e      	ldrb	r6, [r1, #6]
    8cb6:	794b      	ldrb	r3, [r1, #5]
    8cb8:	42b3      	cmp	r3, r6
    8cba:	d823      	bhi.n	8d04 <calibrate_sensor+0x5c>
    8cbc:	1d02      	adds	r2, r0, #4
    8cbe:	7fd5      	ldrb	r5, [r2, #31]
    8cc0:	784f      	ldrb	r7, [r1, #1]
    8cc2:	005c      	lsls	r4, r3, #1
    8cc4:	3294      	adds	r2, #148	; 0x94
    8cc6:	42af      	cmp	r7, r5
    8cc8:	d306      	bcc.n	8cd8 <calibrate_sensor+0x30>
    8cca:	1c05      	adds	r5, r0, #0
    8ccc:	3594      	adds	r5, #148	; 0x94
    8cce:	682d      	ldr	r5, [r5, #0]
    8cd0:	6812      	ldr	r2, [r2, #0]
    8cd2:	5b2d      	ldrh	r5, [r5, r4]
    8cd4:	5315      	strh	r5, [r2, r4]
    8cd6:	e00e      	b.n	8cf6 <calibrate_sensor+0x4e>
    8cd8:	1c07      	adds	r7, r0, #0
    8cda:	6815      	ldr	r5, [r2, #0]
    8cdc:	3794      	adds	r7, #148	; 0x94
    8cde:	683f      	ldr	r7, [r7, #0]
    8ce0:	192d      	adds	r5, r5, r4
    8ce2:	882a      	ldrh	r2, [r5, #0]
    8ce4:	5b3c      	ldrh	r4, [r7, r4]
    8ce6:	42a2      	cmp	r2, r4
    8ce8:	d901      	bls.n	8cee <calibrate_sensor+0x46>
    8cea:	3a01      	subs	r2, #1
    8cec:	e002      	b.n	8cf4 <calibrate_sensor+0x4c>
    8cee:	42a2      	cmp	r2, r4
    8cf0:	d205      	bcs.n	8cfe <calibrate_sensor+0x56>
    8cf2:	3201      	adds	r2, #1
    8cf4:	802a      	strh	r2, [r5, #0]
    8cf6:	8fc2      	ldrh	r2, [r0, #62]	; 0x3e
    8cf8:	2408      	movs	r4, #8
    8cfa:	4322      	orrs	r2, r4
    8cfc:	87c2      	strh	r2, [r0, #62]	; 0x3e
    8cfe:	3301      	adds	r3, #1
    8d00:	b29b      	uxth	r3, r3
    8d02:	e7d9      	b.n	8cb8 <calibrate_sensor+0x10>
    8d04:	bdf0      	pop	{r4, r5, r6, r7, pc}

00008d06 <drift_sensor>:
    8d06:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    8d08:	1c03      	adds	r3, r0, #0
    8d0a:	3390      	adds	r3, #144	; 0x90
    8d0c:	681b      	ldr	r3, [r3, #0]
    8d0e:	00c9      	lsls	r1, r1, #3
    8d10:	1859      	adds	r1, r3, r1
    8d12:	798a      	ldrb	r2, [r1, #6]
    8d14:	9201      	str	r2, [sp, #4]
    8d16:	794b      	ldrb	r3, [r1, #5]
    8d18:	9f01      	ldr	r7, [sp, #4]
    8d1a:	42bb      	cmp	r3, r7
    8d1c:	d851      	bhi.n	8dc2 <drift_sensor+0xbc>
    8d1e:	1c04      	adds	r4, r0, #0
    8d20:	1c02      	adds	r2, r0, #0
    8d22:	3498      	adds	r4, #152	; 0x98
    8d24:	3294      	adds	r2, #148	; 0x94
    8d26:	6812      	ldr	r2, [r2, #0]
    8d28:	6825      	ldr	r5, [r4, #0]
    8d2a:	0059      	lsls	r1, r3, #1
    8d2c:	5a56      	ldrh	r6, [r2, r1]
    8d2e:	5a6f      	ldrh	r7, [r5, r1]
    8d30:	1c02      	adds	r2, r0, #0
    8d32:	32a0      	adds	r2, #160	; 0xa0
    8d34:	42b7      	cmp	r7, r6
    8d36:	d215      	bcs.n	8d64 <drift_sensor+0x5e>
    8d38:	6817      	ldr	r7, [r2, #0]
    8d3a:	18fe      	adds	r6, r7, r3
    8d3c:	7835      	ldrb	r5, [r6, #0]
    8d3e:	7d87      	ldrb	r7, [r0, #22]
    8d40:	46ac      	mov	ip, r5
    8d42:	4467      	add	r7, ip
    8d44:	7037      	strb	r7, [r6, #0]
    8d46:	6812      	ldr	r2, [r2, #0]
    8d48:	7f86      	ldrb	r6, [r0, #30]
    8d4a:	18d2      	adds	r2, r2, r3
    8d4c:	3e80      	subs	r6, #128	; 0x80
    8d4e:	7817      	ldrb	r7, [r2, #0]
    8d50:	b2f6      	uxtb	r6, r6
    8d52:	42b7      	cmp	r7, r6
    8d54:	d332      	bcc.n	8dbc <drift_sensor+0xb6>
    8d56:	2680      	movs	r6, #128	; 0x80
    8d58:	7016      	strb	r6, [r2, #0]
    8d5a:	6822      	ldr	r2, [r4, #0]
    8d5c:	1851      	adds	r1, r2, r1
    8d5e:	880a      	ldrh	r2, [r1, #0]
    8d60:	3201      	adds	r2, #1
    8d62:	e016      	b.n	8d92 <drift_sensor+0x8c>
    8d64:	42b7      	cmp	r7, r6
    8d66:	d91a      	bls.n	8d9e <drift_sensor+0x98>
    8d68:	6817      	ldr	r7, [r2, #0]
    8d6a:	18fe      	adds	r6, r7, r3
    8d6c:	7835      	ldrb	r5, [r6, #0]
    8d6e:	7d87      	ldrb	r7, [r0, #22]
    8d70:	1bef      	subs	r7, r5, r7
    8d72:	7037      	strb	r7, [r6, #0]
    8d74:	6812      	ldr	r2, [r2, #0]
    8d76:	7f47      	ldrb	r7, [r0, #29]
    8d78:	2680      	movs	r6, #128	; 0x80
    8d7a:	18d2      	adds	r2, r2, r3
    8d7c:	4276      	negs	r6, r6
    8d7e:	1bf7      	subs	r7, r6, r7
    8d80:	7815      	ldrb	r5, [r2, #0]
    8d82:	b2ff      	uxtb	r7, r7
    8d84:	42bd      	cmp	r5, r7
    8d86:	d819      	bhi.n	8dbc <drift_sensor+0xb6>
    8d88:	7016      	strb	r6, [r2, #0]
    8d8a:	6822      	ldr	r2, [r4, #0]
    8d8c:	1851      	adds	r1, r2, r1
    8d8e:	880a      	ldrh	r2, [r1, #0]
    8d90:	3a01      	subs	r2, #1
    8d92:	800a      	strh	r2, [r1, #0]
    8d94:	8fc2      	ldrh	r2, [r0, #62]	; 0x3e
    8d96:	2108      	movs	r1, #8
    8d98:	430a      	orrs	r2, r1
    8d9a:	87c2      	strh	r2, [r0, #62]	; 0x3e
    8d9c:	e00e      	b.n	8dbc <drift_sensor+0xb6>
    8d9e:	6816      	ldr	r6, [r2, #0]
    8da0:	18f1      	adds	r1, r6, r3
    8da2:	780c      	ldrb	r4, [r1, #0]
    8da4:	2c80      	cmp	r4, #128	; 0x80
    8da6:	d901      	bls.n	8dac <drift_sensor+0xa6>
    8da8:	3c01      	subs	r4, #1
    8daa:	700c      	strb	r4, [r1, #0]
    8dac:	6812      	ldr	r2, [r2, #0]
    8dae:	18d2      	adds	r2, r2, r3
    8db0:	7811      	ldrb	r1, [r2, #0]
    8db2:	b24c      	sxtb	r4, r1
    8db4:	2c00      	cmp	r4, #0
    8db6:	db01      	blt.n	8dbc <drift_sensor+0xb6>
    8db8:	3101      	adds	r1, #1
    8dba:	7011      	strb	r1, [r2, #0]
    8dbc:	3301      	adds	r3, #1
    8dbe:	b29b      	uxth	r3, r3
    8dc0:	e7aa      	b.n	8d18 <drift_sensor+0x12>
    8dc2:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

00008dc4 <start_cal_sensor>:
    8dc4:	b538      	push	{r3, r4, r5, lr}
    8dc6:	1c04      	adds	r4, r0, #0
    8dc8:	4b07      	ldr	r3, [pc, #28]	; (8de8 <start_cal_sensor+0x24>)
    8dca:	1c0d      	adds	r5, r1, #0
    8dcc:	4798      	blx	r3
    8dce:	1c23      	adds	r3, r4, #0
    8dd0:	3390      	adds	r3, #144	; 0x90
    8dd2:	6819      	ldr	r1, [r3, #0]
    8dd4:	00ed      	lsls	r5, r5, #3
    8dd6:	2201      	movs	r2, #1
    8dd8:	554a      	strb	r2, [r1, r5]
    8dda:	681b      	ldr	r3, [r3, #0]
    8ddc:	3403      	adds	r4, #3
    8dde:	7fe2      	ldrb	r2, [r4, #31]
    8de0:	195d      	adds	r5, r3, r5
    8de2:	706a      	strb	r2, [r5, #1]
    8de4:	bd38      	pop	{r3, r4, r5, pc}
    8de6:	46c0      	nop			; (mov r8, r8)
    8de8:	00008c71 	.word	0x00008c71

00008dec <get_channel_delta>:
    8dec:	1c03      	adds	r3, r0, #0
    8dee:	3394      	adds	r3, #148	; 0x94
    8df0:	3098      	adds	r0, #152	; 0x98
    8df2:	681a      	ldr	r2, [r3, #0]
    8df4:	6803      	ldr	r3, [r0, #0]
    8df6:	0049      	lsls	r1, r1, #1
    8df8:	5a50      	ldrh	r0, [r2, r1]
    8dfa:	5a5b      	ldrh	r3, [r3, r1]
    8dfc:	1ac0      	subs	r0, r0, r3
    8dfe:	b200      	sxth	r0, r0
    8e00:	4770      	bx	lr
	...

00008e04 <populate_cc_calib_array>:
    8e04:	1c0b      	adds	r3, r1, #0
    8e06:	3390      	adds	r3, #144	; 0x90
    8e08:	681b      	ldr	r3, [r3, #0]
    8e0a:	00c0      	lsls	r0, r0, #3
    8e0c:	1818      	adds	r0, r3, r0
    8e0e:	8b4b      	ldrh	r3, [r1, #26]
    8e10:	7982      	ldrb	r2, [r0, #6]
    8e12:	3301      	adds	r3, #1
    8e14:	18d3      	adds	r3, r2, r3
    8e16:	7942      	ldrb	r2, [r0, #5]
    8e18:	1a9b      	subs	r3, r3, r2
    8e1a:	834b      	strh	r3, [r1, #26]
    8e1c:	4b01      	ldr	r3, [pc, #4]	; (8e24 <populate_cc_calib_array+0x20>)
    8e1e:	2200      	movs	r2, #0
    8e20:	701a      	strb	r2, [r3, #0]
    8e22:	4770      	bx	lr
    8e24:	20000b64 	.word	0x20000b64

00008e28 <process_sensor>:
    8e28:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    8e2a:	00cd      	lsls	r5, r1, #3
    8e2c:	9501      	str	r5, [sp, #4]
    8e2e:	1c05      	adds	r5, r0, #0
    8e30:	3590      	adds	r5, #144	; 0x90
    8e32:	9100      	str	r1, [sp, #0]
    8e34:	1c04      	adds	r4, r0, #0
    8e36:	9901      	ldr	r1, [sp, #4]
    8e38:	6828      	ldr	r0, [r5, #0]
    8e3a:	2700      	movs	r7, #0
    8e3c:	1843      	adds	r3, r0, r1
    8e3e:	78de      	ldrb	r6, [r3, #3]
    8e40:	2103      	movs	r1, #3
    8e42:	791a      	ldrb	r2, [r3, #4]
    8e44:	400e      	ands	r6, r1
    8e46:	3601      	adds	r6, #1
    8e48:	781b      	ldrb	r3, [r3, #0]
    8e4a:	4132      	asrs	r2, r6
    8e4c:	b2d6      	uxtb	r6, r2
    8e4e:	2b40      	cmp	r3, #64	; 0x40
    8e50:	d004      	beq.n	8e5c <process_sensor+0x34>
    8e52:	1c20      	adds	r0, r4, #0
    8e54:	9900      	ldr	r1, [sp, #0]
    8e56:	4bc6      	ldr	r3, [pc, #792]	; (9170 <process_sensor+0x348>)
    8e58:	4798      	blx	r3
    8e5a:	1c07      	adds	r7, r0, #0
    8e5c:	2e01      	cmp	r6, #1
    8e5e:	d800      	bhi.n	8e62 <process_sensor+0x3a>
    8e60:	2602      	movs	r6, #2
    8e62:	682b      	ldr	r3, [r5, #0]
    8e64:	9d01      	ldr	r5, [sp, #4]
    8e66:	195b      	adds	r3, r3, r5
    8e68:	791d      	ldrb	r5, [r3, #4]
    8e6a:	1c23      	adds	r3, r4, #0
    8e6c:	3331      	adds	r3, #49	; 0x31
    8e6e:	781b      	ldrb	r3, [r3, #0]
    8e70:	1bae      	subs	r6, r5, r6
    8e72:	b2b5      	uxth	r5, r6
    8e74:	2b02      	cmp	r3, #2
    8e76:	d019      	beq.n	8eac <process_sensor+0x84>
    8e78:	1c23      	adds	r3, r4, #0
    8e7a:	33e9      	adds	r3, #233	; 0xe9
    8e7c:	781b      	ldrb	r3, [r3, #0]
    8e7e:	2100      	movs	r1, #0
    8e80:	428b      	cmp	r3, r1
    8e82:	d014      	beq.n	8eae <process_sensor+0x86>
    8e84:	4bbb      	ldr	r3, [pc, #748]	; (9174 <process_sensor+0x34c>)
    8e86:	685b      	ldr	r3, [r3, #4]
    8e88:	428b      	cmp	r3, r1
    8e8a:	d002      	beq.n	8e92 <process_sensor+0x6a>
    8e8c:	1c20      	adds	r0, r4, #0
    8e8e:	9900      	ldr	r1, [sp, #0]
    8e90:	4798      	blx	r3
    8e92:	1c22      	adds	r2, r4, #0
    8e94:	9800      	ldr	r0, [sp, #0]
    8e96:	32f0      	adds	r2, #240	; 0xf0
    8e98:	6812      	ldr	r2, [r2, #0]
    8e9a:	2107      	movs	r1, #7
    8e9c:	4001      	ands	r1, r0
    8e9e:	08c3      	lsrs	r3, r0, #3
    8ea0:	2001      	movs	r0, #1
    8ea2:	4088      	lsls	r0, r1
    8ea4:	5cd3      	ldrb	r3, [r2, r3]
    8ea6:	1c01      	adds	r1, r0, #0
    8ea8:	4019      	ands	r1, r3
    8eaa:	e000      	b.n	8eae <process_sensor+0x86>
    8eac:	2100      	movs	r1, #0
    8eae:	1c26      	adds	r6, r4, #0
    8eb0:	3690      	adds	r6, #144	; 0x90
    8eb2:	6833      	ldr	r3, [r6, #0]
    8eb4:	9801      	ldr	r0, [sp, #4]
    8eb6:	181a      	adds	r2, r3, r0
    8eb8:	7813      	ldrb	r3, [r2, #0]
    8eba:	2b08      	cmp	r3, #8
    8ebc:	d100      	bne.n	8ec0 <process_sensor+0x98>
    8ebe:	e0bd      	b.n	903c <process_sensor+0x214>
    8ec0:	d807      	bhi.n	8ed2 <process_sensor+0xaa>
    8ec2:	2b02      	cmp	r3, #2
    8ec4:	d036      	beq.n	8f34 <process_sensor+0x10c>
    8ec6:	2b04      	cmp	r3, #4
    8ec8:	d068      	beq.n	8f9c <process_sensor+0x174>
    8eca:	2b01      	cmp	r3, #1
    8ecc:	d000      	beq.n	8ed0 <process_sensor+0xa8>
    8ece:	e17e      	b.n	91ce <process_sensor+0x3a6>
    8ed0:	e014      	b.n	8efc <process_sensor+0xd4>
    8ed2:	2b20      	cmp	r3, #32
    8ed4:	d100      	bne.n	8ed8 <process_sensor+0xb0>
    8ed6:	e12c      	b.n	9132 <process_sensor+0x30a>
    8ed8:	d803      	bhi.n	8ee2 <process_sensor+0xba>
    8eda:	2b10      	cmp	r3, #16
    8edc:	d100      	bne.n	8ee0 <process_sensor+0xb8>
    8ede:	e0b7      	b.n	9050 <process_sensor+0x228>
    8ee0:	e175      	b.n	91ce <process_sensor+0x3a6>
    8ee2:	2b40      	cmp	r3, #64	; 0x40
    8ee4:	d100      	bne.n	8ee8 <process_sensor+0xc0>
    8ee6:	e16c      	b.n	91c2 <process_sensor+0x39a>
    8ee8:	2b80      	cmp	r3, #128	; 0x80
    8eea:	d000      	beq.n	8eee <process_sensor+0xc6>
    8eec:	e16f      	b.n	91ce <process_sensor+0x3a6>
    8eee:	1d23      	adds	r3, r4, #4
    8ef0:	7fdb      	ldrb	r3, [r3, #31]
    8ef2:	1c20      	adds	r0, r4, #0
    8ef4:	7053      	strb	r3, [r2, #1]
    8ef6:	9900      	ldr	r1, [sp, #0]
    8ef8:	4b9f      	ldr	r3, [pc, #636]	; (9178 <process_sensor+0x350>)
    8efa:	e167      	b.n	91cc <process_sensor+0x3a4>
    8efc:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    8efe:	2380      	movs	r3, #128	; 0x80
    8f00:	009b      	lsls	r3, r3, #2
    8f02:	4313      	orrs	r3, r2
    8f04:	87e3      	strh	r3, [r4, #62]	; 0x3e
    8f06:	9900      	ldr	r1, [sp, #0]
    8f08:	4b9b      	ldr	r3, [pc, #620]	; (9178 <process_sensor+0x350>)
    8f0a:	1c20      	adds	r0, r4, #0
    8f0c:	4798      	blx	r3
    8f0e:	6831      	ldr	r1, [r6, #0]
    8f10:	9d01      	ldr	r5, [sp, #4]
    8f12:	194b      	adds	r3, r1, r5
    8f14:	785a      	ldrb	r2, [r3, #1]
    8f16:	3a01      	subs	r2, #1
    8f18:	705a      	strb	r2, [r3, #1]
    8f1a:	6833      	ldr	r3, [r6, #0]
    8f1c:	195b      	adds	r3, r3, r5
    8f1e:	785b      	ldrb	r3, [r3, #1]
    8f20:	2b00      	cmp	r3, #0
    8f22:	d103      	bne.n	8f2c <process_sensor+0x104>
    8f24:	1c20      	adds	r0, r4, #0
    8f26:	9900      	ldr	r1, [sp, #0]
    8f28:	4b94      	ldr	r3, [pc, #592]	; (917c <process_sensor+0x354>)
    8f2a:	4798      	blx	r3
    8f2c:	1c63      	adds	r3, r4, #1
    8f2e:	7fdb      	ldrb	r3, [r3, #31]
    8f30:	73e3      	strb	r3, [r4, #15]
    8f32:	e144      	b.n	91be <process_sensor+0x396>
    8f34:	2500      	movs	r5, #0
    8f36:	42a9      	cmp	r1, r5
    8f38:	d000      	beq.n	8f3c <process_sensor+0x114>
    8f3a:	e149      	b.n	91d0 <process_sensor+0x3a8>
    8f3c:	78d1      	ldrb	r1, [r2, #3]
    8f3e:	2304      	movs	r3, #4
    8f40:	4219      	tst	r1, r3
    8f42:	d00c      	beq.n	8f5e <process_sensor+0x136>
    8f44:	7953      	ldrb	r3, [r2, #5]
    8f46:	1c22      	adds	r2, r4, #0
    8f48:	32a0      	adds	r2, #160	; 0xa0
    8f4a:	6812      	ldr	r2, [r2, #0]
    8f4c:	54d5      	strb	r5, [r2, r3]
    8f4e:	6833      	ldr	r3, [r6, #0]
    8f50:	9d01      	ldr	r5, [sp, #4]
    8f52:	2220      	movs	r2, #32
    8f54:	555a      	strb	r2, [r3, r5]
    8f56:	2380      	movs	r3, #128	; 0x80
    8f58:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    8f5a:	015b      	lsls	r3, r3, #5
    8f5c:	e12d      	b.n	91ba <process_sensor+0x392>
    8f5e:	b239      	sxth	r1, r7
    8f60:	43c9      	mvns	r1, r1
    8f62:	17c9      	asrs	r1, r1, #31
    8f64:	400f      	ands	r7, r1
    8f66:	7911      	ldrb	r1, [r2, #4]
    8f68:	b2bf      	uxth	r7, r7
    8f6a:	428f      	cmp	r7, r1
    8f6c:	d308      	bcc.n	8f80 <process_sensor+0x158>
    8f6e:	1c61      	adds	r1, r4, #1
    8f70:	7fc9      	ldrb	r1, [r1, #31]
    8f72:	9801      	ldr	r0, [sp, #4]
    8f74:	73e1      	strb	r1, [r4, #15]
    8f76:	7013      	strb	r3, [r2, #0]
    8f78:	6833      	ldr	r3, [r6, #0]
    8f7a:	181b      	adds	r3, r3, r0
    8f7c:	709d      	strb	r5, [r3, #2]
    8f7e:	e119      	b.n	91b4 <process_sensor+0x38c>
    8f80:	7da3      	ldrb	r3, [r4, #22]
    8f82:	2b00      	cmp	r3, #0
    8f84:	d100      	bne.n	8f88 <process_sensor+0x160>
    8f86:	e123      	b.n	91d0 <process_sensor+0x3a8>
    8f88:	7be3      	ldrb	r3, [r4, #15]
    8f8a:	2500      	movs	r5, #0
    8f8c:	42ab      	cmp	r3, r5
    8f8e:	d000      	beq.n	8f92 <process_sensor+0x16a>
    8f90:	e11e      	b.n	91d0 <process_sensor+0x3a8>
    8f92:	1c20      	adds	r0, r4, #0
    8f94:	9900      	ldr	r1, [sp, #0]
    8f96:	4b7a      	ldr	r3, [pc, #488]	; (9180 <process_sensor+0x358>)
    8f98:	4798      	blx	r3
    8f9a:	e119      	b.n	91d0 <process_sensor+0x3a8>
    8f9c:	b239      	sxth	r1, r7
    8f9e:	43cb      	mvns	r3, r1
    8fa0:	17db      	asrs	r3, r3, #31
    8fa2:	401f      	ands	r7, r3
    8fa4:	7913      	ldrb	r3, [r2, #4]
    8fa6:	b2bf      	uxth	r7, r7
    8fa8:	429f      	cmp	r7, r3
    8faa:	d34d      	bcc.n	9048 <process_sensor+0x220>
    8fac:	1c63      	adds	r3, r4, #1
    8fae:	7fdb      	ldrb	r3, [r3, #31]
    8fb0:	73e3      	strb	r3, [r4, #15]
    8fb2:	7893      	ldrb	r3, [r2, #2]
    8fb4:	3301      	adds	r3, #1
    8fb6:	7093      	strb	r3, [r2, #2]
    8fb8:	4b6e      	ldr	r3, [pc, #440]	; (9174 <process_sensor+0x34c>)
    8fba:	681b      	ldr	r3, [r3, #0]
    8fbc:	2b00      	cmp	r3, #0
    8fbe:	d103      	bne.n	8fc8 <process_sensor+0x1a0>
    8fc0:	7f23      	ldrb	r3, [r4, #28]
    8fc2:	2b00      	cmp	r3, #0
    8fc4:	d107      	bne.n	8fd6 <process_sensor+0x1ae>
    8fc6:	e004      	b.n	8fd2 <process_sensor+0x1aa>
    8fc8:	9800      	ldr	r0, [sp, #0]
    8fca:	1c22      	adds	r2, r4, #0
    8fcc:	4798      	blx	r3
    8fce:	2800      	cmp	r0, #0
    8fd0:	d0f6      	beq.n	8fc0 <process_sensor+0x198>
    8fd2:	2500      	movs	r5, #0
    8fd4:	e005      	b.n	8fe2 <process_sensor+0x1ba>
    8fd6:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    8fd8:	2380      	movs	r3, #128	; 0x80
    8fda:	011b      	lsls	r3, r3, #4
    8fdc:	4313      	orrs	r3, r2
    8fde:	87e3      	strh	r3, [r4, #62]	; 0x3e
    8fe0:	2501      	movs	r5, #1
    8fe2:	6831      	ldr	r1, [r6, #0]
    8fe4:	9a01      	ldr	r2, [sp, #4]
    8fe6:	188b      	adds	r3, r1, r2
    8fe8:	7899      	ldrb	r1, [r3, #2]
    8fea:	7f22      	ldrb	r2, [r4, #28]
    8fec:	4291      	cmp	r1, r2
    8fee:	d200      	bcs.n	8ff2 <process_sensor+0x1ca>
    8ff0:	e0ee      	b.n	91d0 <process_sensor+0x3a8>
    8ff2:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    8ff4:	2101      	movs	r1, #1
    8ff6:	430a      	orrs	r2, r1
    8ff8:	87e2      	strh	r2, [r4, #62]	; 0x3e
    8ffa:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    8ffc:	2102      	movs	r1, #2
    8ffe:	430a      	orrs	r2, r1
    9000:	87e2      	strh	r2, [r4, #62]	; 0x3e
    9002:	2210      	movs	r2, #16
    9004:	701a      	strb	r2, [r3, #0]
    9006:	6830      	ldr	r0, [r6, #0]
    9008:	9901      	ldr	r1, [sp, #4]
    900a:	2200      	movs	r2, #0
    900c:	1843      	adds	r3, r0, r1
    900e:	705a      	strb	r2, [r3, #1]
    9010:	6833      	ldr	r3, [r6, #0]
    9012:	223f      	movs	r2, #63	; 0x3f
    9014:	185b      	adds	r3, r3, r1
    9016:	78db      	ldrb	r3, [r3, #3]
    9018:	4393      	bics	r3, r2
    901a:	d100      	bne.n	901e <process_sensor+0x1f6>
    901c:	e0d8      	b.n	91d0 <process_sensor+0x3a8>
    901e:	4e59      	ldr	r6, [pc, #356]	; (9184 <process_sensor+0x35c>)
    9020:	6933      	ldr	r3, [r6, #16]
    9022:	2b00      	cmp	r3, #0
    9024:	d002      	beq.n	902c <process_sensor+0x204>
    9026:	1c20      	adds	r0, r4, #0
    9028:	9900      	ldr	r1, [sp, #0]
    902a:	4798      	blx	r3
    902c:	68b3      	ldr	r3, [r6, #8]
    902e:	2b00      	cmp	r3, #0
    9030:	d100      	bne.n	9034 <process_sensor+0x20c>
    9032:	e0cd      	b.n	91d0 <process_sensor+0x3a8>
    9034:	1c20      	adds	r0, r4, #0
    9036:	9900      	ldr	r1, [sp, #0]
    9038:	4798      	blx	r3
    903a:	e0c9      	b.n	91d0 <process_sensor+0x3a8>
    903c:	1c63      	adds	r3, r4, #1
    903e:	7fdb      	ldrb	r3, [r3, #31]
    9040:	73e3      	strb	r3, [r4, #15]
    9042:	7893      	ldrb	r3, [r2, #2]
    9044:	2b00      	cmp	r3, #0
    9046:	d15a      	bne.n	90fe <process_sensor+0x2d6>
    9048:	1c20      	adds	r0, r4, #0
    904a:	9900      	ldr	r1, [sp, #0]
    904c:	4b4b      	ldr	r3, [pc, #300]	; (917c <process_sensor+0x354>)
    904e:	e0bd      	b.n	91cc <process_sensor+0x3a4>
    9050:	78d3      	ldrb	r3, [r2, #3]
    9052:	0758      	lsls	r0, r3, #29
    9054:	d50c      	bpl.n	9070 <process_sensor+0x248>
    9056:	7953      	ldrb	r3, [r2, #5]
    9058:	1c22      	adds	r2, r4, #0
    905a:	32a0      	adds	r2, #160	; 0xa0
    905c:	6812      	ldr	r2, [r2, #0]
    905e:	2180      	movs	r1, #128	; 0x80
    9060:	54d1      	strb	r1, [r2, r3]
    9062:	6833      	ldr	r3, [r6, #0]
    9064:	9d01      	ldr	r5, [sp, #4]
    9066:	2220      	movs	r2, #32
    9068:	555a      	strb	r2, [r3, r5]
    906a:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    906c:	014b      	lsls	r3, r1, #5
    906e:	e00b      	b.n	9088 <process_sensor+0x260>
    9070:	b23b      	sxth	r3, r7
    9072:	43db      	mvns	r3, r3
    9074:	17db      	asrs	r3, r3, #31
    9076:	401f      	ands	r7, r3
    9078:	b2bf      	uxth	r7, r7
    907a:	42af      	cmp	r7, r5
    907c:	d207      	bcs.n	908e <process_sensor+0x266>
    907e:	2308      	movs	r3, #8
    9080:	7013      	strb	r3, [r2, #0]
    9082:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    9084:	2380      	movs	r3, #128	; 0x80
    9086:	00db      	lsls	r3, r3, #3
    9088:	4313      	orrs	r3, r2
    908a:	87e3      	strh	r3, [r4, #62]	; 0x3e
    908c:	e032      	b.n	90f4 <process_sensor+0x2cc>
    908e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
    9090:	2101      	movs	r1, #1
    9092:	430b      	orrs	r3, r1
    9094:	87e3      	strh	r3, [r4, #62]	; 0x3e
    9096:	7893      	ldrb	r3, [r2, #2]
    9098:	7f21      	ldrb	r1, [r4, #28]
    909a:	4299      	cmp	r1, r3
    909c:	d901      	bls.n	90a2 <process_sensor+0x27a>
    909e:	3301      	adds	r3, #1
    90a0:	7093      	strb	r3, [r2, #2]
    90a2:	6830      	ldr	r0, [r6, #0]
    90a4:	9d01      	ldr	r5, [sp, #4]
    90a6:	223f      	movs	r2, #63	; 0x3f
    90a8:	1943      	adds	r3, r0, r5
    90aa:	78db      	ldrb	r3, [r3, #3]
    90ac:	4393      	bics	r3, r2
    90ae:	d006      	beq.n	90be <process_sensor+0x296>
    90b0:	4b34      	ldr	r3, [pc, #208]	; (9184 <process_sensor+0x35c>)
    90b2:	689b      	ldr	r3, [r3, #8]
    90b4:	2b00      	cmp	r3, #0
    90b6:	d002      	beq.n	90be <process_sensor+0x296>
    90b8:	1c20      	adds	r0, r4, #0
    90ba:	9900      	ldr	r1, [sp, #0]
    90bc:	4798      	blx	r3
    90be:	7fe1      	ldrb	r1, [r4, #31]
    90c0:	2500      	movs	r5, #0
    90c2:	42a9      	cmp	r1, r5
    90c4:	d017      	beq.n	90f6 <process_sensor+0x2ce>
    90c6:	6833      	ldr	r3, [r6, #0]
    90c8:	9801      	ldr	r0, [sp, #4]
    90ca:	181b      	adds	r3, r3, r0
    90cc:	785a      	ldrb	r2, [r3, #1]
    90ce:	428a      	cmp	r2, r1
    90d0:	d203      	bcs.n	90da <process_sensor+0x2b2>
    90d2:	7da1      	ldrb	r1, [r4, #22]
    90d4:	1852      	adds	r2, r2, r1
    90d6:	705a      	strb	r2, [r3, #1]
    90d8:	e00d      	b.n	90f6 <process_sensor+0x2ce>
    90da:	1c20      	adds	r0, r4, #0
    90dc:	9900      	ldr	r1, [sp, #0]
    90de:	4b2a      	ldr	r3, [pc, #168]	; (9188 <process_sensor+0x360>)
    90e0:	4798      	blx	r3
    90e2:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    90e4:	2380      	movs	r3, #128	; 0x80
    90e6:	009b      	lsls	r3, r3, #2
    90e8:	4313      	orrs	r3, r2
    90ea:	87e3      	strh	r3, [r4, #62]	; 0x3e
    90ec:	9800      	ldr	r0, [sp, #0]
    90ee:	1c21      	adds	r1, r4, #0
    90f0:	4b26      	ldr	r3, [pc, #152]	; (918c <process_sensor+0x364>)
    90f2:	4798      	blx	r3
    90f4:	2501      	movs	r5, #1
    90f6:	1c63      	adds	r3, r4, #1
    90f8:	7fdb      	ldrb	r3, [r3, #31]
    90fa:	73e3      	strb	r3, [r4, #15]
    90fc:	e068      	b.n	91d0 <process_sensor+0x3a8>
    90fe:	0439      	lsls	r1, r7, #16
    9100:	d40a      	bmi.n	9118 <process_sensor+0x2f0>
    9102:	b2bb      	uxth	r3, r7
    9104:	42ab      	cmp	r3, r5
    9106:	d907      	bls.n	9118 <process_sensor+0x2f0>
    9108:	2310      	movs	r3, #16
    910a:	7013      	strb	r3, [r2, #0]
    910c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
    910e:	2201      	movs	r2, #1
    9110:	4313      	orrs	r3, r2
    9112:	87e3      	strh	r3, [r4, #62]	; 0x3e
    9114:	2500      	movs	r5, #0
    9116:	e005      	b.n	9124 <process_sensor+0x2fc>
    9118:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    911a:	2380      	movs	r3, #128	; 0x80
    911c:	00db      	lsls	r3, r3, #3
    911e:	4313      	orrs	r3, r2
    9120:	87e3      	strh	r3, [r4, #62]	; 0x3e
    9122:	2501      	movs	r5, #1
    9124:	6833      	ldr	r3, [r6, #0]
    9126:	9a01      	ldr	r2, [sp, #4]
    9128:	189b      	adds	r3, r3, r2
    912a:	789a      	ldrb	r2, [r3, #2]
    912c:	3a01      	subs	r2, #1
    912e:	709a      	strb	r2, [r3, #2]
    9130:	e04e      	b.n	91d0 <process_sensor+0x3a8>
    9132:	1c21      	adds	r1, r4, #0
    9134:	31a0      	adds	r1, #160	; 0xa0
    9136:	680d      	ldr	r5, [r1, #0]
    9138:	7952      	ldrb	r2, [r2, #5]
    913a:	1ca3      	adds	r3, r4, #2
    913c:	18af      	adds	r7, r5, r2
    913e:	7838      	ldrb	r0, [r7, #0]
    9140:	7fdb      	ldrb	r3, [r3, #31]
    9142:	b245      	sxtb	r5, r0
    9144:	2d00      	cmp	r5, #0
    9146:	da01      	bge.n	914c <process_sensor+0x324>
    9148:	3b80      	subs	r3, #128	; 0x80
    914a:	b2db      	uxtb	r3, r3
    914c:	3001      	adds	r0, #1
    914e:	7038      	strb	r0, [r7, #0]
    9150:	6830      	ldr	r0, [r6, #0]
    9152:	9d01      	ldr	r5, [sp, #4]
    9154:	1940      	adds	r0, r0, r5
    9156:	78c6      	ldrb	r6, [r0, #3]
    9158:	2504      	movs	r5, #4
    915a:	4035      	ands	r5, r6
    915c:	d118      	bne.n	9190 <process_sensor+0x368>
    915e:	680b      	ldr	r3, [r1, #0]
    9160:	5c9b      	ldrb	r3, [r3, r2]
    9162:	2b7f      	cmp	r3, #127	; 0x7f
    9164:	d800      	bhi.n	9168 <process_sensor+0x340>
    9166:	e76f      	b.n	9048 <process_sensor+0x220>
    9168:	2310      	movs	r3, #16
    916a:	7003      	strb	r3, [r0, #0]
    916c:	e030      	b.n	91d0 <process_sensor+0x3a8>
    916e:	46c0      	nop			; (mov r8, r8)
    9170:	000086d5 	.word	0x000086d5
    9174:	20000b24 	.word	0x20000b24
    9178:	00008ca9 	.word	0x00008ca9
    917c:	00008c71 	.word	0x00008c71
    9180:	00008d07 	.word	0x00008d07
    9184:	200009bc 	.word	0x200009bc
    9188:	00008dc5 	.word	0x00008dc5
    918c:	00008e05 	.word	0x00008e05
    9190:	6809      	ldr	r1, [r1, #0]
    9192:	5c8a      	ldrb	r2, [r1, r2]
    9194:	429a      	cmp	r2, r3
    9196:	d30d      	bcc.n	91b4 <process_sensor+0x38c>
    9198:	1c20      	adds	r0, r4, #0
    919a:	9900      	ldr	r1, [sp, #0]
    919c:	4b0d      	ldr	r3, [pc, #52]	; (91d4 <process_sensor+0x3ac>)
    919e:	4798      	blx	r3
    91a0:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    91a2:	2380      	movs	r3, #128	; 0x80
    91a4:	015b      	lsls	r3, r3, #5
    91a6:	4313      	orrs	r3, r2
    91a8:	87e3      	strh	r3, [r4, #62]	; 0x3e
    91aa:	9800      	ldr	r0, [sp, #0]
    91ac:	1c21      	adds	r1, r4, #0
    91ae:	4b0a      	ldr	r3, [pc, #40]	; (91d8 <process_sensor+0x3b0>)
    91b0:	4798      	blx	r3
    91b2:	e004      	b.n	91be <process_sensor+0x396>
    91b4:	2380      	movs	r3, #128	; 0x80
    91b6:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    91b8:	00db      	lsls	r3, r3, #3
    91ba:	4313      	orrs	r3, r2
    91bc:	87e3      	strh	r3, [r4, #62]	; 0x3e
    91be:	2501      	movs	r5, #1
    91c0:	e006      	b.n	91d0 <process_sensor+0x3a8>
    91c2:	7da5      	ldrb	r5, [r4, #22]
    91c4:	2d00      	cmp	r5, #0
    91c6:	d000      	beq.n	91ca <process_sensor+0x3a2>
    91c8:	e6de      	b.n	8f88 <process_sensor+0x160>
    91ca:	e001      	b.n	91d0 <process_sensor+0x3a8>
    91cc:	4798      	blx	r3
    91ce:	2500      	movs	r5, #0
    91d0:	1c28      	adds	r0, r5, #0
    91d2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    91d4:	00008dc5 	.word	0x00008dc5
    91d8:	00008e05 	.word	0x00008e05

000091dc <get_next_active_node>:
    91dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    91de:	4b3c      	ldr	r3, [pc, #240]	; (92d0 <get_next_active_node+0xf4>)
    91e0:	b087      	sub	sp, #28
    91e2:	881b      	ldrh	r3, [r3, #0]
    91e4:	9003      	str	r0, [sp, #12]
    91e6:	8842      	ldrh	r2, [r0, #2]
    91e8:	1c5c      	adds	r4, r3, #1
    91ea:	1c1e      	adds	r6, r3, #0
    91ec:	2300      	movs	r3, #0
    91ee:	b2a4      	uxth	r4, r4
    91f0:	9204      	str	r2, [sp, #16]
    91f2:	9301      	str	r3, [sp, #4]
    91f4:	9a04      	ldr	r2, [sp, #16]
    91f6:	4294      	cmp	r4, r2
    91f8:	d305      	bcc.n	9206 <get_next_active_node+0x2a>
    91fa:	4b35      	ldr	r3, [pc, #212]	; (92d0 <get_next_active_node+0xf4>)
    91fc:	801e      	strh	r6, [r3, #0]
    91fe:	4b34      	ldr	r3, [pc, #208]	; (92d0 <get_next_active_node+0xf4>)
    9200:	2400      	movs	r4, #0
    9202:	881d      	ldrh	r5, [r3, #0]
    9204:	e055      	b.n	92b2 <get_next_active_node+0xd6>
    9206:	9b01      	ldr	r3, [sp, #4]
    9208:	2b00      	cmp	r3, #0
    920a:	d125      	bne.n	9258 <get_next_active_node+0x7c>
    920c:	9b03      	ldr	r3, [sp, #12]
    920e:	09a5      	lsrs	r5, r4, #6
    9210:	33bc      	adds	r3, #188	; 0xbc
    9212:	681b      	ldr	r3, [r3, #0]
    9214:	b2ed      	uxtb	r5, r5
    9216:	00ed      	lsls	r5, r5, #3
    9218:	195d      	adds	r5, r3, r5
    921a:	682a      	ldr	r2, [r5, #0]
    921c:	686b      	ldr	r3, [r5, #4]
    921e:	273f      	movs	r7, #63	; 0x3f
    9220:	4027      	ands	r7, r4
    9222:	9200      	str	r2, [sp, #0]
    9224:	9302      	str	r3, [sp, #8]
    9226:	1c10      	adds	r0, r2, #0
    9228:	1c19      	adds	r1, r3, #0
    922a:	1c3a      	adds	r2, r7, #0
    922c:	4b29      	ldr	r3, [pc, #164]	; (92d4 <get_next_active_node+0xf8>)
    922e:	4798      	blx	r3
    9230:	2201      	movs	r2, #1
    9232:	4210      	tst	r0, r2
    9234:	d00d      	beq.n	9252 <get_next_active_node+0x76>
    9236:	4b28      	ldr	r3, [pc, #160]	; (92d8 <get_next_active_node+0xfc>)
    9238:	2001      	movs	r0, #1
    923a:	2100      	movs	r1, #0
    923c:	1c3a      	adds	r2, r7, #0
    923e:	4798      	blx	r3
    9240:	9b00      	ldr	r3, [sp, #0]
    9242:	1c26      	adds	r6, r4, #0
    9244:	4383      	bics	r3, r0
    9246:	602b      	str	r3, [r5, #0]
    9248:	9b02      	ldr	r3, [sp, #8]
    924a:	438b      	bics	r3, r1
    924c:	606b      	str	r3, [r5, #4]
    924e:	2301      	movs	r3, #1
    9250:	9301      	str	r3, [sp, #4]
    9252:	3401      	adds	r4, #1
    9254:	b2a4      	uxth	r4, r4
    9256:	e7cd      	b.n	91f4 <get_next_active_node+0x18>
    9258:	4b1d      	ldr	r3, [pc, #116]	; (92d0 <get_next_active_node+0xf4>)
    925a:	2201      	movs	r2, #1
    925c:	801e      	strh	r6, [r3, #0]
    925e:	9201      	str	r2, [sp, #4]
    9260:	e7cd      	b.n	91fe <get_next_active_node+0x22>
    9262:	9b01      	ldr	r3, [sp, #4]
    9264:	2b00      	cmp	r3, #0
    9266:	d127      	bne.n	92b8 <get_next_active_node+0xdc>
    9268:	9b03      	ldr	r3, [sp, #12]
    926a:	09a6      	lsrs	r6, r4, #6
    926c:	33bc      	adds	r3, #188	; 0xbc
    926e:	681b      	ldr	r3, [r3, #0]
    9270:	b2f6      	uxtb	r6, r6
    9272:	00f6      	lsls	r6, r6, #3
    9274:	199e      	adds	r6, r3, r6
    9276:	6833      	ldr	r3, [r6, #0]
    9278:	6872      	ldr	r2, [r6, #4]
    927a:	9302      	str	r3, [sp, #8]
    927c:	233f      	movs	r3, #63	; 0x3f
    927e:	4023      	ands	r3, r4
    9280:	9205      	str	r2, [sp, #20]
    9282:	9300      	str	r3, [sp, #0]
    9284:	1c11      	adds	r1, r2, #0
    9286:	9802      	ldr	r0, [sp, #8]
    9288:	1c1a      	adds	r2, r3, #0
    928a:	4b12      	ldr	r3, [pc, #72]	; (92d4 <get_next_active_node+0xf8>)
    928c:	4798      	blx	r3
    928e:	2701      	movs	r7, #1
    9290:	4238      	tst	r0, r7
    9292:	d00c      	beq.n	92ae <get_next_active_node+0xd2>
    9294:	4b10      	ldr	r3, [pc, #64]	; (92d8 <get_next_active_node+0xfc>)
    9296:	2001      	movs	r0, #1
    9298:	2100      	movs	r1, #0
    929a:	9a00      	ldr	r2, [sp, #0]
    929c:	4798      	blx	r3
    929e:	9b02      	ldr	r3, [sp, #8]
    92a0:	1c25      	adds	r5, r4, #0
    92a2:	4383      	bics	r3, r0
    92a4:	6033      	str	r3, [r6, #0]
    92a6:	9b05      	ldr	r3, [sp, #20]
    92a8:	9701      	str	r7, [sp, #4]
    92aa:	438b      	bics	r3, r1
    92ac:	6073      	str	r3, [r6, #4]
    92ae:	3401      	adds	r4, #1
    92b0:	b2a4      	uxth	r4, r4
    92b2:	42ac      	cmp	r4, r5
    92b4:	d3d5      	bcc.n	9262 <get_next_active_node+0x86>
    92b6:	e002      	b.n	92be <get_next_active_node+0xe2>
    92b8:	4b05      	ldr	r3, [pc, #20]	; (92d0 <get_next_active_node+0xf4>)
    92ba:	801d      	strh	r5, [r3, #0]
    92bc:	e006      	b.n	92cc <get_next_active_node+0xf0>
    92be:	4b04      	ldr	r3, [pc, #16]	; (92d0 <get_next_active_node+0xf4>)
    92c0:	9a01      	ldr	r2, [sp, #4]
    92c2:	801d      	strh	r5, [r3, #0]
    92c4:	2a00      	cmp	r2, #0
    92c6:	d101      	bne.n	92cc <get_next_active_node+0xf0>
    92c8:	9a04      	ldr	r2, [sp, #16]
    92ca:	801a      	strh	r2, [r3, #0]
    92cc:	b007      	add	sp, #28
    92ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
    92d0:	200013da 	.word	0x200013da
    92d4:	0000a679 	.word	0x0000a679
    92d8:	0000a691 	.word	0x0000a691

000092dc <sequence_next_node>:
    92dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    92de:	4b1f      	ldr	r3, [pc, #124]	; (935c <sequence_next_node+0x80>)
    92e0:	1c01      	adds	r1, r0, #0
    92e2:	781c      	ldrb	r4, [r3, #0]
    92e4:	3190      	adds	r1, #144	; 0x90
    92e6:	885a      	ldrh	r2, [r3, #2]
    92e8:	680d      	ldr	r5, [r1, #0]
    92ea:	2c00      	cmp	r4, #0
    92ec:	d10f      	bne.n	930e <sequence_next_node+0x32>
    92ee:	00d1      	lsls	r1, r2, #3
    92f0:	1869      	adds	r1, r5, r1
    92f2:	7808      	ldrb	r0, [r1, #0]
    92f4:	1c54      	adds	r4, r2, #1
    92f6:	b2a4      	uxth	r4, r4
    92f8:	2840      	cmp	r0, #64	; 0x40
    92fa:	d101      	bne.n	9300 <sequence_next_node+0x24>
    92fc:	1c22      	adds	r2, r4, #0
    92fe:	e7f6      	b.n	92ee <sequence_next_node+0x12>
    9300:	805a      	strh	r2, [r3, #2]
    9302:	2201      	movs	r2, #1
    9304:	701a      	strb	r2, [r3, #0]
    9306:	794a      	ldrb	r2, [r1, #5]
    9308:	4b15      	ldr	r3, [pc, #84]	; (9360 <sequence_next_node+0x84>)
    930a:	801a      	strh	r2, [r3, #0]
    930c:	e025      	b.n	935a <sequence_next_node+0x7e>
    930e:	4914      	ldr	r1, [pc, #80]	; (9360 <sequence_next_node+0x84>)
    9310:	00d4      	lsls	r4, r2, #3
    9312:	192c      	adds	r4, r5, r4
    9314:	79a7      	ldrb	r7, [r4, #6]
    9316:	880e      	ldrh	r6, [r1, #0]
    9318:	1c0c      	adds	r4, r1, #0
    931a:	42b7      	cmp	r7, r6
    931c:	d002      	beq.n	9324 <sequence_next_node+0x48>
    931e:	3601      	adds	r6, #1
    9320:	800e      	strh	r6, [r1, #0]
    9322:	e01a      	b.n	935a <sequence_next_node+0x7e>
    9324:	3201      	adds	r2, #1
    9326:	b292      	uxth	r2, r2
    9328:	805a      	strh	r2, [r3, #2]
    932a:	00d1      	lsls	r1, r2, #3
    932c:	1869      	adds	r1, r5, r1
    932e:	780e      	ldrb	r6, [r1, #0]
    9330:	2e40      	cmp	r6, #64	; 0x40
    9332:	d009      	beq.n	9348 <sequence_next_node+0x6c>
    9334:	805a      	strh	r2, [r3, #2]
    9336:	8905      	ldrh	r5, [r0, #8]
    9338:	4295      	cmp	r5, r2
    933a:	d10c      	bne.n	9356 <sequence_next_node+0x7a>
    933c:	8842      	ldrh	r2, [r0, #2]
    933e:	8022      	strh	r2, [r4, #0]
    9340:	2200      	movs	r2, #0
    9342:	701a      	strb	r2, [r3, #0]
    9344:	805a      	strh	r2, [r3, #2]
    9346:	e008      	b.n	935a <sequence_next_node+0x7e>
    9348:	8906      	ldrh	r6, [r0, #8]
    934a:	1c57      	adds	r7, r2, #1
    934c:	b2bf      	uxth	r7, r7
    934e:	4296      	cmp	r6, r2
    9350:	d9f0      	bls.n	9334 <sequence_next_node+0x58>
    9352:	1c3a      	adds	r2, r7, #0
    9354:	e7e9      	b.n	932a <sequence_next_node+0x4e>
    9356:	794b      	ldrb	r3, [r1, #5]
    9358:	8023      	strh	r3, [r4, #0]
    935a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    935c:	20000b30 	.word	0x20000b30
    9360:	200013da 	.word	0x200013da

00009364 <setup_channel>:
    9364:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    9366:	1c0c      	adds	r4, r1, #0
    9368:	4e36      	ldr	r6, [pc, #216]	; (9444 <setup_channel+0xe0>)
    936a:	1c05      	adds	r5, r0, #0
    936c:	9201      	str	r2, [sp, #4]
    936e:	47b0      	blx	r6
    9370:	7822      	ldrb	r2, [r4, #0]
    9372:	1c23      	adds	r3, r4, #0
    9374:	33c4      	adds	r3, #196	; 0xc4
    9376:	006e      	lsls	r6, r5, #1
    9378:	2a00      	cmp	r2, #0
    937a:	d109      	bne.n	9390 <setup_channel+0x2c>
    937c:	681a      	ldr	r2, [r3, #0]
    937e:	b2b3      	uxth	r3, r6
    9380:	009b      	lsls	r3, r3, #2
    9382:	58d0      	ldr	r0, [r2, r3]
    9384:	18d3      	adds	r3, r2, r3
    9386:	6859      	ldr	r1, [r3, #4]
    9388:	4b2f      	ldr	r3, [pc, #188]	; (9448 <setup_channel+0xe4>)
    938a:	4798      	blx	r3
    938c:	2008      	movs	r0, #8
    938e:	e006      	b.n	939e <setup_channel+0x3a>
    9390:	681b      	ldr	r3, [r3, #0]
    9392:	00aa      	lsls	r2, r5, #2
    9394:	58d1      	ldr	r1, [r2, r3]
    9396:	2000      	movs	r0, #0
    9398:	4b2b      	ldr	r3, [pc, #172]	; (9448 <setup_channel+0xe4>)
    939a:	4798      	blx	r3
    939c:	200a      	movs	r0, #10
    939e:	4b2b      	ldr	r3, [pc, #172]	; (944c <setup_channel+0xe8>)
    93a0:	4798      	blx	r3
    93a2:	9901      	ldr	r1, [sp, #4]
    93a4:	4b2a      	ldr	r3, [pc, #168]	; (9450 <setup_channel+0xec>)
    93a6:	4f2b      	ldr	r7, [pc, #172]	; (9454 <setup_channel+0xf0>)
    93a8:	1c22      	adds	r2, r4, #0
    93aa:	2901      	cmp	r1, #1
    93ac:	d106      	bne.n	93bc <setup_channel+0x58>
    93ae:	32d4      	adds	r2, #212	; 0xd4
    93b0:	6812      	ldr	r2, [r2, #0]
    93b2:	5d50      	ldrb	r0, [r2, r5]
    93b4:	4798      	blx	r3
    93b6:	1c23      	adds	r3, r4, #0
    93b8:	33d0      	adds	r3, #208	; 0xd0
    93ba:	e005      	b.n	93c8 <setup_channel+0x64>
    93bc:	32dc      	adds	r2, #220	; 0xdc
    93be:	6812      	ldr	r2, [r2, #0]
    93c0:	5d50      	ldrb	r0, [r2, r5]
    93c2:	4798      	blx	r3
    93c4:	1c23      	adds	r3, r4, #0
    93c6:	33d8      	adds	r3, #216	; 0xd8
    93c8:	681b      	ldr	r3, [r3, #0]
    93ca:	5d58      	ldrb	r0, [r3, r5]
    93cc:	47b8      	blx	r7
    93ce:	1c23      	adds	r3, r4, #0
    93d0:	339c      	adds	r3, #156	; 0x9c
    93d2:	681b      	ldr	r3, [r3, #0]
    93d4:	5b98      	ldrh	r0, [r3, r6]
    93d6:	4b20      	ldr	r3, [pc, #128]	; (9458 <setup_channel+0xf4>)
    93d8:	4798      	blx	r3
    93da:	1c23      	adds	r3, r4, #0
    93dc:	33c8      	adds	r3, #200	; 0xc8
    93de:	1c22      	adds	r2, r4, #0
    93e0:	32e4      	adds	r2, #228	; 0xe4
    93e2:	681b      	ldr	r3, [r3, #0]
    93e4:	9201      	str	r2, [sp, #4]
    93e6:	5d5b      	ldrb	r3, [r3, r5]
    93e8:	7812      	ldrb	r2, [r2, #0]
    93ea:	3a01      	subs	r2, #1
    93ec:	b2d2      	uxtb	r2, r2
    93ee:	2aff      	cmp	r2, #255	; 0xff
    93f0:	d004      	beq.n	93fc <setup_channel+0x98>
    93f2:	2b00      	cmp	r3, #0
    93f4:	d0f9      	beq.n	93ea <setup_channel+0x86>
    93f6:	3b01      	subs	r3, #1
    93f8:	b2db      	uxtb	r3, r3
    93fa:	e7f6      	b.n	93ea <setup_channel+0x86>
    93fc:	4a17      	ldr	r2, [pc, #92]	; (945c <setup_channel+0xf8>)
    93fe:	1c26      	adds	r6, r4, #0
    9400:	5cd0      	ldrb	r0, [r2, r3]
    9402:	36cc      	adds	r6, #204	; 0xcc
    9404:	4b16      	ldr	r3, [pc, #88]	; (9460 <setup_channel+0xfc>)
    9406:	4798      	blx	r3
    9408:	7833      	ldrb	r3, [r6, #0]
    940a:	4d16      	ldr	r5, [pc, #88]	; (9464 <setup_channel+0x100>)
    940c:	4f16      	ldr	r7, [pc, #88]	; (9468 <setup_channel+0x104>)
    940e:	2000      	movs	r0, #0
    9410:	2b01      	cmp	r3, #1
    9412:	d106      	bne.n	9422 <setup_channel+0xbe>
    9414:	47a8      	blx	r5
    9416:	7b63      	ldrb	r3, [r4, #13]
    9418:	34e0      	adds	r4, #224	; 0xe0
    941a:	6822      	ldr	r2, [r4, #0]
    941c:	5cd0      	ldrb	r0, [r2, r3]
    941e:	47b8      	blx	r7
    9420:	e007      	b.n	9432 <setup_channel+0xce>
    9422:	47b8      	blx	r7
    9424:	7833      	ldrb	r3, [r6, #0]
    9426:	2001      	movs	r0, #1
    9428:	3b02      	subs	r3, #2
    942a:	2b01      	cmp	r3, #1
    942c:	d900      	bls.n	9430 <setup_channel+0xcc>
    942e:	2000      	movs	r0, #0
    9430:	47a8      	blx	r5
    9432:	4b0e      	ldr	r3, [pc, #56]	; (946c <setup_channel+0x108>)
    9434:	4798      	blx	r3
    9436:	9b01      	ldr	r3, [sp, #4]
    9438:	7818      	ldrb	r0, [r3, #0]
    943a:	4b0d      	ldr	r3, [pc, #52]	; (9470 <setup_channel+0x10c>)
    943c:	4798      	blx	r3
    943e:	4901      	ldr	r1, [pc, #4]	; (9444 <setup_channel+0xe0>)
    9440:	4788      	blx	r1
    9442:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    9444:	00009e9d 	.word	0x00009e9d
    9448:	0000a011 	.word	0x0000a011
    944c:	0000a035 	.word	0x0000a035
    9450:	0000a159 	.word	0x0000a159
    9454:	0000a17d 	.word	0x0000a17d
    9458:	0000a0bd 	.word	0x0000a0bd
    945c:	200000be 	.word	0x200000be
    9460:	0000a125 	.word	0x0000a125
    9464:	00009fe9 	.word	0x00009fe9
    9468:	0000a099 	.word	0x0000a099
    946c:	0000a059 	.word	0x0000a059
    9470:	0000a075 	.word	0x0000a075

00009474 <PTC_Handler>:
    9474:	b510      	push	{r4, lr}
    9476:	4b1f      	ldr	r3, [pc, #124]	; (94f4 <PTC_Handler+0x80>)
    9478:	4798      	blx	r3
    947a:	4b1f      	ldr	r3, [pc, #124]	; (94f8 <PTC_Handler+0x84>)
    947c:	4798      	blx	r3
    947e:	4b1f      	ldr	r3, [pc, #124]	; (94fc <PTC_Handler+0x88>)
    9480:	781b      	ldrb	r3, [r3, #0]
    9482:	2b01      	cmp	r3, #1
    9484:	d113      	bne.n	94ae <PTC_Handler+0x3a>
    9486:	4c1e      	ldr	r4, [pc, #120]	; (9500 <PTC_Handler+0x8c>)
    9488:	6823      	ldr	r3, [r4, #0]
    948a:	2b00      	cmp	r3, #0
    948c:	d031      	beq.n	94f2 <PTC_Handler+0x7e>
    948e:	4b1d      	ldr	r3, [pc, #116]	; (9504 <PTC_Handler+0x90>)
    9490:	4798      	blx	r3
    9492:	4b1d      	ldr	r3, [pc, #116]	; (9508 <PTC_Handler+0x94>)
    9494:	2207      	movs	r2, #7
    9496:	7819      	ldrb	r1, [r3, #0]
    9498:	00c9      	lsls	r1, r1, #3
    949a:	4311      	orrs	r1, r2
    949c:	b2c9      	uxtb	r1, r1
    949e:	7019      	strb	r1, [r3, #0]
    94a0:	7859      	ldrb	r1, [r3, #1]
    94a2:	00c9      	lsls	r1, r1, #3
    94a4:	430a      	orrs	r2, r1
    94a6:	b2d2      	uxtb	r2, r2
    94a8:	705a      	strb	r2, [r3, #1]
    94aa:	6823      	ldr	r3, [r4, #0]
    94ac:	e020      	b.n	94f0 <PTC_Handler+0x7c>
    94ae:	4b17      	ldr	r3, [pc, #92]	; (950c <PTC_Handler+0x98>)
    94b0:	2200      	movs	r2, #0
    94b2:	7819      	ldrb	r1, [r3, #0]
    94b4:	4c16      	ldr	r4, [pc, #88]	; (9510 <PTC_Handler+0x9c>)
    94b6:	701a      	strb	r2, [r3, #0]
    94b8:	2901      	cmp	r1, #1
    94ba:	d110      	bne.n	94de <PTC_Handler+0x6a>
    94bc:	4b12      	ldr	r3, [pc, #72]	; (9508 <PTC_Handler+0x94>)
    94be:	7122      	strb	r2, [r4, #4]
    94c0:	785a      	ldrb	r2, [r3, #1]
    94c2:	2a04      	cmp	r2, #4
    94c4:	d102      	bne.n	94cc <PTC_Handler+0x58>
    94c6:	2202      	movs	r2, #2
    94c8:	705a      	strb	r2, [r3, #1]
    94ca:	e004      	b.n	94d6 <PTC_Handler+0x62>
    94cc:	781a      	ldrb	r2, [r3, #0]
    94ce:	2a04      	cmp	r2, #4
    94d0:	d101      	bne.n	94d6 <PTC_Handler+0x62>
    94d2:	2202      	movs	r2, #2
    94d4:	701a      	strb	r2, [r3, #0]
    94d6:	4b0f      	ldr	r3, [pc, #60]	; (9514 <PTC_Handler+0xa0>)
    94d8:	2201      	movs	r2, #1
    94da:	701a      	strb	r2, [r3, #0]
    94dc:	e009      	b.n	94f2 <PTC_Handler+0x7e>
    94de:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    94e0:	2b00      	cmp	r3, #0
    94e2:	d000      	beq.n	94e6 <PTC_Handler+0x72>
    94e4:	4798      	blx	r3
    94e6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    94e8:	4798      	blx	r3
    94ea:	6b23      	ldr	r3, [r4, #48]	; 0x30
    94ec:	2b00      	cmp	r3, #0
    94ee:	d000      	beq.n	94f2 <PTC_Handler+0x7e>
    94f0:	4798      	blx	r3
    94f2:	bd10      	pop	{r4, pc}
    94f4:	00009f91 	.word	0x00009f91
    94f8:	00009f71 	.word	0x00009f71
    94fc:	200009dc 	.word	0x200009dc
    9500:	200009d8 	.word	0x200009d8
    9504:	00009ec9 	.word	0x00009ec9
    9508:	200009d4 	.word	0x200009d4
    950c:	200013d8 	.word	0x200013d8
    9510:	20000b30 	.word	0x20000b30
    9514:	200009dd 	.word	0x200009dd

00009518 <calc_update_burst_again_mask>:
    9518:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    951a:	1c0b      	adds	r3, r1, #0
    951c:	3390      	adds	r3, #144	; 0x90
    951e:	681b      	ldr	r3, [r3, #0]
    9520:	00c0      	lsls	r0, r0, #3
    9522:	1818      	adds	r0, r3, r0
    9524:	7944      	ldrb	r4, [r0, #5]
    9526:	7987      	ldrb	r7, [r0, #6]
    9528:	1c0e      	adds	r6, r1, #0
    952a:	42bc      	cmp	r4, r7
    952c:	d814      	bhi.n	9558 <calc_update_burst_again_mask+0x40>
    952e:	1c33      	adds	r3, r6, #0
    9530:	33bc      	adds	r3, #188	; 0xbc
    9532:	681b      	ldr	r3, [r3, #0]
    9534:	09a5      	lsrs	r5, r4, #6
    9536:	00ed      	lsls	r5, r5, #3
    9538:	223f      	movs	r2, #63	; 0x3f
    953a:	195d      	adds	r5, r3, r5
    953c:	4022      	ands	r2, r4
    953e:	4b07      	ldr	r3, [pc, #28]	; (955c <calc_update_burst_again_mask+0x44>)
    9540:	2001      	movs	r0, #1
    9542:	2100      	movs	r1, #0
    9544:	4798      	blx	r3
    9546:	682b      	ldr	r3, [r5, #0]
    9548:	3401      	adds	r4, #1
    954a:	4318      	orrs	r0, r3
    954c:	686b      	ldr	r3, [r5, #4]
    954e:	6028      	str	r0, [r5, #0]
    9550:	4319      	orrs	r1, r3
    9552:	6069      	str	r1, [r5, #4]
    9554:	b2a4      	uxth	r4, r4
    9556:	e7e8      	b.n	952a <calc_update_burst_again_mask+0x12>
    9558:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    955a:	46c0      	nop			; (mov r8, r8)
    955c:	0000a691 	.word	0x0000a691

00009560 <ptc_setup_channel_freq_hopp_process>:
    9560:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    9562:	7803      	ldrb	r3, [r0, #0]
    9564:	1c04      	adds	r4, r0, #0
    9566:	1c0d      	adds	r5, r1, #0
    9568:	1c17      	adds	r7, r2, #0
    956a:	2b01      	cmp	r3, #1
    956c:	d101      	bne.n	9572 <ptc_setup_channel_freq_hopp_process+0x12>
    956e:	4e58      	ldr	r6, [pc, #352]	; (96d0 <ptc_setup_channel_freq_hopp_process+0x170>)
    9570:	e000      	b.n	9574 <ptc_setup_channel_freq_hopp_process+0x14>
    9572:	4e58      	ldr	r6, [pc, #352]	; (96d4 <ptc_setup_channel_freq_hopp_process+0x174>)
    9574:	8862      	ldrh	r2, [r4, #2]
    9576:	9201      	str	r2, [sp, #4]
    9578:	2d00      	cmp	r5, #0
    957a:	d115      	bne.n	95a8 <ptc_setup_channel_freq_hopp_process+0x48>
    957c:	1c23      	adds	r3, r4, #0
    957e:	33cc      	adds	r3, #204	; 0xcc
    9580:	781b      	ldrb	r3, [r3, #0]
    9582:	2b01      	cmp	r3, #1
    9584:	d110      	bne.n	95a8 <ptc_setup_channel_freq_hopp_process+0x48>
    9586:	1c23      	adds	r3, r4, #0
    9588:	33e8      	adds	r3, #232	; 0xe8
    958a:	781b      	ldrb	r3, [r3, #0]
    958c:	2b00      	cmp	r3, #0
    958e:	d005      	beq.n	959c <ptc_setup_channel_freq_hopp_process+0x3c>
    9590:	4b51      	ldr	r3, [pc, #324]	; (96d8 <ptc_setup_channel_freq_hopp_process+0x178>)
    9592:	681b      	ldr	r3, [r3, #0]
    9594:	2b00      	cmp	r3, #0
    9596:	d001      	beq.n	959c <ptc_setup_channel_freq_hopp_process+0x3c>
    9598:	1c20      	adds	r0, r4, #0
    959a:	4798      	blx	r3
    959c:	7b60      	ldrb	r0, [r4, #13]
    959e:	2103      	movs	r1, #3
    95a0:	3001      	adds	r0, #1
    95a2:	4b4e      	ldr	r3, [pc, #312]	; (96dc <ptc_setup_channel_freq_hopp_process+0x17c>)
    95a4:	4798      	blx	r3
    95a6:	7361      	strb	r1, [r4, #13]
    95a8:	7ba3      	ldrb	r3, [r4, #14]
    95aa:	2b01      	cmp	r3, #1
    95ac:	d175      	bne.n	969a <ptc_setup_channel_freq_hopp_process+0x13a>
    95ae:	2d00      	cmp	r5, #0
    95b0:	d000      	beq.n	95b4 <ptc_setup_channel_freq_hopp_process+0x54>
    95b2:	e083      	b.n	96bc <ptc_setup_channel_freq_hopp_process+0x15c>
    95b4:	1c23      	adds	r3, r4, #0
    95b6:	33e6      	adds	r3, #230	; 0xe6
    95b8:	781b      	ldrb	r3, [r3, #0]
    95ba:	2b01      	cmp	r3, #1
    95bc:	d16f      	bne.n	969e <ptc_setup_channel_freq_hopp_process+0x13e>
    95be:	4b48      	ldr	r3, [pc, #288]	; (96e0 <ptc_setup_channel_freq_hopp_process+0x180>)
    95c0:	9f01      	ldr	r7, [sp, #4]
    95c2:	1c1a      	adds	r2, r3, #0
    95c4:	3f01      	subs	r7, #1
    95c6:	3234      	adds	r2, #52	; 0x34
    95c8:	09bf      	lsrs	r7, r7, #6
    95ca:	7812      	ldrb	r2, [r2, #0]
    95cc:	3701      	adds	r7, #1
    95ce:	b2bf      	uxth	r7, r7
    95d0:	2a01      	cmp	r2, #1
    95d2:	d111      	bne.n	95f8 <ptc_setup_channel_freq_hopp_process+0x98>
    95d4:	b2ab      	uxth	r3, r5
    95d6:	42bb      	cmp	r3, r7
    95d8:	d259      	bcs.n	968e <ptc_setup_channel_freq_hopp_process+0x12e>
    95da:	1c23      	adds	r3, r4, #0
    95dc:	1c20      	adds	r0, r4, #0
    95de:	33c0      	adds	r3, #192	; 0xc0
    95e0:	30bc      	adds	r0, #188	; 0xbc
    95e2:	681b      	ldr	r3, [r3, #0]
    95e4:	6800      	ldr	r0, [r0, #0]
    95e6:	00e9      	lsls	r1, r5, #3
    95e8:	185b      	adds	r3, r3, r1
    95ea:	1841      	adds	r1, r0, r1
    95ec:	681a      	ldr	r2, [r3, #0]
    95ee:	685b      	ldr	r3, [r3, #4]
    95f0:	3501      	adds	r5, #1
    95f2:	600a      	str	r2, [r1, #0]
    95f4:	604b      	str	r3, [r1, #4]
    95f6:	e7ed      	b.n	95d4 <ptc_setup_channel_freq_hopp_process+0x74>
    95f8:	7035      	strb	r5, [r6, #0]
    95fa:	b2ab      	uxth	r3, r5
    95fc:	42bb      	cmp	r3, r7
    95fe:	d20a      	bcs.n	9616 <ptc_setup_channel_freq_hopp_process+0xb6>
    9600:	1c23      	adds	r3, r4, #0
    9602:	33bc      	adds	r3, #188	; 0xbc
    9604:	6819      	ldr	r1, [r3, #0]
    9606:	00eb      	lsls	r3, r5, #3
    9608:	18c9      	adds	r1, r1, r3
    960a:	2200      	movs	r2, #0
    960c:	2300      	movs	r3, #0
    960e:	600a      	str	r2, [r1, #0]
    9610:	604b      	str	r3, [r1, #4]
    9612:	3501      	adds	r5, #1
    9614:	e7f1      	b.n	95fa <ptc_setup_channel_freq_hopp_process+0x9a>
    9616:	2500      	movs	r5, #0
    9618:	8923      	ldrh	r3, [r4, #8]
    961a:	42ab      	cmp	r3, r5
    961c:	d920      	bls.n	9660 <ptc_setup_channel_freq_hopp_process+0x100>
    961e:	1c23      	adds	r3, r4, #0
    9620:	3390      	adds	r3, #144	; 0x90
    9622:	681b      	ldr	r3, [r3, #0]
    9624:	00ea      	lsls	r2, r5, #3
    9626:	5cd3      	ldrb	r3, [r2, r3]
    9628:	2b02      	cmp	r3, #2
    962a:	d016      	beq.n	965a <ptc_setup_channel_freq_hopp_process+0xfa>
    962c:	2b40      	cmp	r3, #64	; 0x40
    962e:	d014      	beq.n	965a <ptc_setup_channel_freq_hopp_process+0xfa>
    9630:	4b2c      	ldr	r3, [pc, #176]	; (96e4 <ptc_setup_channel_freq_hopp_process+0x184>)
    9632:	1c28      	adds	r0, r5, #0
    9634:	1c21      	adds	r1, r4, #0
    9636:	4798      	blx	r3
    9638:	1c23      	adds	r3, r4, #0
    963a:	33fc      	adds	r3, #252	; 0xfc
    963c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    963e:	2b00      	cmp	r3, #0
    9640:	d003      	beq.n	964a <ptc_setup_channel_freq_hopp_process+0xea>
    9642:	1c20      	adds	r0, r4, #0
    9644:	1c31      	adds	r1, r6, #0
    9646:	1c2a      	adds	r2, r5, #0
    9648:	4798      	blx	r3
    964a:	4a25      	ldr	r2, [pc, #148]	; (96e0 <ptc_setup_channel_freq_hopp_process+0x180>)
    964c:	6b93      	ldr	r3, [r2, #56]	; 0x38
    964e:	2b00      	cmp	r3, #0
    9650:	d003      	beq.n	965a <ptc_setup_channel_freq_hopp_process+0xfa>
    9652:	1c28      	adds	r0, r5, #0
    9654:	1c31      	adds	r1, r6, #0
    9656:	1c22      	adds	r2, r4, #0
    9658:	4798      	blx	r3
    965a:	3501      	adds	r5, #1
    965c:	b2ad      	uxth	r5, r5
    965e:	e7db      	b.n	9618 <ptc_setup_channel_freq_hopp_process+0xb8>
    9660:	2100      	movs	r1, #0
    9662:	b28b      	uxth	r3, r1
    9664:	42bb      	cmp	r3, r7
    9666:	d20e      	bcs.n	9686 <ptc_setup_channel_freq_hopp_process+0x126>
    9668:	1c23      	adds	r3, r4, #0
    966a:	1c25      	adds	r5, r4, #0
    966c:	33bc      	adds	r3, #188	; 0xbc
    966e:	35c0      	adds	r5, #192	; 0xc0
    9670:	681b      	ldr	r3, [r3, #0]
    9672:	682d      	ldr	r5, [r5, #0]
    9674:	00c8      	lsls	r0, r1, #3
    9676:	181b      	adds	r3, r3, r0
    9678:	1828      	adds	r0, r5, r0
    967a:	681a      	ldr	r2, [r3, #0]
    967c:	685b      	ldr	r3, [r3, #4]
    967e:	3101      	adds	r1, #1
    9680:	6002      	str	r2, [r0, #0]
    9682:	6043      	str	r3, [r0, #4]
    9684:	e7ed      	b.n	9662 <ptc_setup_channel_freq_hopp_process+0x102>
    9686:	4b16      	ldr	r3, [pc, #88]	; (96e0 <ptc_setup_channel_freq_hopp_process+0x180>)
    9688:	2201      	movs	r2, #1
    968a:	3334      	adds	r3, #52	; 0x34
    968c:	701a      	strb	r2, [r3, #0]
    968e:	1c20      	adds	r0, r4, #0
    9690:	4b15      	ldr	r3, [pc, #84]	; (96e8 <ptc_setup_channel_freq_hopp_process+0x188>)
    9692:	4798      	blx	r3
    9694:	4b15      	ldr	r3, [pc, #84]	; (96ec <ptc_setup_channel_freq_hopp_process+0x18c>)
    9696:	8818      	ldrh	r0, [r3, #0]
    9698:	e00b      	b.n	96b2 <ptc_setup_channel_freq_hopp_process+0x152>
    969a:	2d00      	cmp	r5, #0
    969c:	d10e      	bne.n	96bc <ptc_setup_channel_freq_hopp_process+0x15c>
    969e:	4d13      	ldr	r5, [pc, #76]	; (96ec <ptc_setup_channel_freq_hopp_process+0x18c>)
    96a0:	2300      	movs	r3, #0
    96a2:	802b      	strh	r3, [r5, #0]
    96a4:	1c20      	adds	r0, r4, #0
    96a6:	4b12      	ldr	r3, [pc, #72]	; (96f0 <ptc_setup_channel_freq_hopp_process+0x190>)
    96a8:	4798      	blx	r3
    96aa:	8828      	ldrh	r0, [r5, #0]
    96ac:	8863      	ldrh	r3, [r4, #2]
    96ae:	4283      	cmp	r3, r0
    96b0:	d90d      	bls.n	96ce <ptc_setup_channel_freq_hopp_process+0x16e>
    96b2:	1c21      	adds	r1, r4, #0
    96b4:	2201      	movs	r2, #1
    96b6:	4b0f      	ldr	r3, [pc, #60]	; (96f4 <ptc_setup_channel_freq_hopp_process+0x194>)
    96b8:	4798      	blx	r3
    96ba:	e008      	b.n	96ce <ptc_setup_channel_freq_hopp_process+0x16e>
    96bc:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    96be:	23c0      	movs	r3, #192	; 0xc0
    96c0:	009b      	lsls	r3, r3, #2
    96c2:	4313      	orrs	r3, r2
    96c4:	87e3      	strh	r3, [r4, #62]	; 0x3e
    96c6:	2f00      	cmp	r7, #0
    96c8:	d001      	beq.n	96ce <ptc_setup_channel_freq_hopp_process+0x16e>
    96ca:	1c20      	adds	r0, r4, #0
    96cc:	47b8      	blx	r7
    96ce:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    96d0:	200013d9 	.word	0x200013d9
    96d4:	200013d6 	.word	0x200013d6
    96d8:	200009e0 	.word	0x200009e0
    96dc:	0000a499 	.word	0x0000a499
    96e0:	20000b30 	.word	0x20000b30
    96e4:	00009519 	.word	0x00009519
    96e8:	000091dd 	.word	0x000091dd
    96ec:	200013da 	.word	0x200013da
    96f0:	000092dd 	.word	0x000092dd
    96f4:	00009365 	.word	0x00009365

000096f8 <ptc_start_cycle_with_callbacks>:
    96f8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    96fa:	4b33      	ldr	r3, [pc, #204]	; (97c8 <ptc_start_cycle_with_callbacks+0xd0>)
    96fc:	1c04      	adds	r4, r0, #0
    96fe:	4798      	blx	r3
    9700:	4b32      	ldr	r3, [pc, #200]	; (97cc <ptc_start_cycle_with_callbacks+0xd4>)
    9702:	4798      	blx	r3
    9704:	4d32      	ldr	r5, [pc, #200]	; (97d0 <ptc_start_cycle_with_callbacks+0xd8>)
    9706:	1c23      	adds	r3, r4, #0
    9708:	33fc      	adds	r3, #252	; 0xfc
    970a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    970c:	792e      	ldrb	r6, [r5, #4]
    970e:	62eb      	str	r3, [r5, #44]	; 0x2c
    9710:	2001      	movs	r0, #1
    9712:	2e00      	cmp	r6, #0
    9714:	d157      	bne.n	97c6 <ptc_start_cycle_with_callbacks+0xce>
    9716:	4b2f      	ldr	r3, [pc, #188]	; (97d4 <ptc_start_cycle_with_callbacks+0xdc>)
    9718:	2280      	movs	r2, #128	; 0x80
    971a:	21c0      	movs	r1, #192	; 0xc0
    971c:	0492      	lsls	r2, r2, #18
    971e:	4081      	lsls	r1, r0
    9720:	505a      	str	r2, [r3, r1]
    9722:	21c6      	movs	r1, #198	; 0xc6
    9724:	0089      	lsls	r1, r1, #2
    9726:	5858      	ldr	r0, [r3, r1]
    9728:	4684      	mov	ip, r0
    972a:	1c20      	adds	r0, r4, #0
    972c:	30e7      	adds	r0, #231	; 0xe7
    972e:	7807      	ldrb	r7, [r0, #0]
    9730:	20ff      	movs	r0, #255	; 0xff
    9732:	01bf      	lsls	r7, r7, #6
    9734:	4007      	ands	r7, r0
    9736:	023f      	lsls	r7, r7, #8
    9738:	9701      	str	r7, [sp, #4]
    973a:	4f27      	ldr	r7, [pc, #156]	; (97d8 <ptc_start_cycle_with_callbacks+0xe0>)
    973c:	4660      	mov	r0, ip
    973e:	4007      	ands	r7, r0
    9740:	1c38      	adds	r0, r7, #0
    9742:	9f01      	ldr	r7, [sp, #4]
    9744:	4338      	orrs	r0, r7
    9746:	5058      	str	r0, [r3, r1]
    9748:	601a      	str	r2, [r3, #0]
    974a:	4b24      	ldr	r3, [pc, #144]	; (97dc <ptc_start_cycle_with_callbacks+0xe4>)
    974c:	4798      	blx	r3
    974e:	4b24      	ldr	r3, [pc, #144]	; (97e0 <ptc_start_cycle_with_callbacks+0xe8>)
    9750:	4798      	blx	r3
    9752:	4b24      	ldr	r3, [pc, #144]	; (97e4 <ptc_start_cycle_with_callbacks+0xec>)
    9754:	4798      	blx	r3
    9756:	4b24      	ldr	r3, [pc, #144]	; (97e8 <ptc_start_cycle_with_callbacks+0xf0>)
    9758:	4798      	blx	r3
    975a:	4b24      	ldr	r3, [pc, #144]	; (97ec <ptc_start_cycle_with_callbacks+0xf4>)
    975c:	4798      	blx	r3
    975e:	4b24      	ldr	r3, [pc, #144]	; (97f0 <ptc_start_cycle_with_callbacks+0xf8>)
    9760:	1c20      	adds	r0, r4, #0
    9762:	701e      	strb	r6, [r3, #0]
    9764:	7822      	ldrb	r2, [r4, #0]
    9766:	1c21      	adds	r1, r4, #0
    9768:	4e22      	ldr	r6, [pc, #136]	; (97f4 <ptc_start_cycle_with_callbacks+0xfc>)
    976a:	30d4      	adds	r0, #212	; 0xd4
    976c:	31d0      	adds	r1, #208	; 0xd0
    976e:	4b22      	ldr	r3, [pc, #136]	; (97f8 <ptc_start_cycle_with_callbacks+0x100>)
    9770:	2a00      	cmp	r2, #0
    9772:	d109      	bne.n	9788 <ptc_start_cycle_with_callbacks+0x90>
    9774:	8832      	ldrh	r2, [r6, #0]
    9776:	6800      	ldr	r0, [r0, #0]
    9778:	6809      	ldr	r1, [r1, #0]
    977a:	5c80      	ldrb	r0, [r0, r2]
    977c:	7168      	strb	r0, [r5, #5]
    977e:	5c8a      	ldrb	r2, [r1, r2]
    9780:	71aa      	strb	r2, [r5, #6]
    9782:	8b61      	ldrh	r1, [r4, #26]
    9784:	4a1d      	ldr	r2, [pc, #116]	; (97fc <ptc_start_cycle_with_callbacks+0x104>)
    9786:	e008      	b.n	979a <ptc_start_cycle_with_callbacks+0xa2>
    9788:	8832      	ldrh	r2, [r6, #0]
    978a:	6800      	ldr	r0, [r0, #0]
    978c:	6809      	ldr	r1, [r1, #0]
    978e:	5c80      	ldrb	r0, [r0, r2]
    9790:	71e8      	strb	r0, [r5, #7]
    9792:	5c8a      	ldrb	r2, [r1, r2]
    9794:	722a      	strb	r2, [r5, #8]
    9796:	8b61      	ldrh	r1, [r4, #26]
    9798:	4a19      	ldr	r2, [pc, #100]	; (9800 <ptc_start_cycle_with_callbacks+0x108>)
    979a:	6812      	ldr	r2, [r2, #0]
    979c:	1c20      	adds	r0, r4, #0
    979e:	4798      	blx	r3
    97a0:	8832      	ldrh	r2, [r6, #0]
    97a2:	8863      	ldrh	r3, [r4, #2]
    97a4:	4d0a      	ldr	r5, [pc, #40]	; (97d0 <ptc_start_cycle_with_callbacks+0xd8>)
    97a6:	429a      	cmp	r2, r3
    97a8:	d205      	bcs.n	97b6 <ptc_start_cycle_with_callbacks+0xbe>
    97aa:	4b16      	ldr	r3, [pc, #88]	; (9804 <ptc_start_cycle_with_callbacks+0x10c>)
    97ac:	4798      	blx	r3
    97ae:	2301      	movs	r3, #1
    97b0:	712b      	strb	r3, [r5, #4]
    97b2:	2000      	movs	r0, #0
    97b4:	e007      	b.n	97c6 <ptc_start_cycle_with_callbacks+0xce>
    97b6:	2300      	movs	r3, #0
    97b8:	34fc      	adds	r4, #252	; 0xfc
    97ba:	712b      	strb	r3, [r5, #4]
    97bc:	6a63      	ldr	r3, [r4, #36]	; 0x24
    97be:	2b00      	cmp	r3, #0
    97c0:	d000      	beq.n	97c4 <ptc_start_cycle_with_callbacks+0xcc>
    97c2:	4798      	blx	r3
    97c4:	2001      	movs	r0, #1
    97c6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    97c8:	00009f01 	.word	0x00009f01
    97cc:	00009ead 	.word	0x00009ead
    97d0:	20000b30 	.word	0x20000b30
    97d4:	e000e100 	.word	0xe000e100
    97d8:	ffff00ff 	.word	0xffff00ff
    97dc:	00009e9d 	.word	0x00009e9d
    97e0:	00009fb1 	.word	0x00009fb1
    97e4:	00009f39 	.word	0x00009f39
    97e8:	00009f55 	.word	0x00009f55
    97ec:	00009fcd 	.word	0x00009fcd
    97f0:	200013d8 	.word	0x200013d8
    97f4:	200013da 	.word	0x200013da
    97f8:	00009561 	.word	0x00009561
    97fc:	20000cc4 	.word	0x20000cc4
    9800:	20000b20 	.word	0x20000b20
    9804:	0000a1b1 	.word	0x0000a1b1

00009808 <self_cap_calib_check>:
    9808:	b538      	push	{r3, r4, r5, lr}
    980a:	8b43      	ldrh	r3, [r0, #26]
    980c:	4d23      	ldr	r5, [pc, #140]	; (989c <self_cap_calib_check+0x94>)
    980e:	3b01      	subs	r3, #1
    9810:	b29b      	uxth	r3, r3
    9812:	2200      	movs	r2, #0
    9814:	1c04      	adds	r4, r0, #0
    9816:	8343      	strh	r3, [r0, #26]
    9818:	712a      	strb	r2, [r5, #4]
    981a:	4293      	cmp	r3, r2
    981c:	d102      	bne.n	9824 <self_cap_calib_check+0x1c>
    981e:	1c02      	adds	r2, r0, #0
    9820:	3278      	adds	r2, #120	; 0x78
    9822:	7013      	strb	r3, [r2, #0]
    9824:	4b1e      	ldr	r3, [pc, #120]	; (98a0 <self_cap_calib_check+0x98>)
    9826:	1c20      	adds	r0, r4, #0
    9828:	4798      	blx	r3
    982a:	8b63      	ldrh	r3, [r4, #26]
    982c:	2800      	cmp	r0, #0
    982e:	d110      	bne.n	9852 <self_cap_calib_check+0x4a>
    9830:	2b00      	cmp	r3, #0
    9832:	d015      	beq.n	9860 <self_cap_calib_check+0x58>
    9834:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    9836:	23c0      	movs	r3, #192	; 0xc0
    9838:	009b      	lsls	r3, r3, #2
    983a:	4313      	orrs	r3, r2
    983c:	87e3      	strh	r3, [r4, #62]	; 0x3e
    983e:	4b19      	ldr	r3, [pc, #100]	; (98a4 <self_cap_calib_check+0x9c>)
    9840:	681b      	ldr	r3, [r3, #0]
    9842:	2b00      	cmp	r3, #0
    9844:	d001      	beq.n	984a <self_cap_calib_check+0x42>
    9846:	1c20      	adds	r0, r4, #0
    9848:	4798      	blx	r3
    984a:	2301      	movs	r3, #1
    984c:	712b      	strb	r3, [r5, #4]
    984e:	4b16      	ldr	r3, [pc, #88]	; (98a8 <self_cap_calib_check+0xa0>)
    9850:	e005      	b.n	985e <self_cap_calib_check+0x56>
    9852:	2b00      	cmp	r3, #0
    9854:	d004      	beq.n	9860 <self_cap_calib_check+0x58>
    9856:	4b15      	ldr	r3, [pc, #84]	; (98ac <self_cap_calib_check+0xa4>)
    9858:	2202      	movs	r2, #2
    985a:	701a      	strb	r2, [r3, #0]
    985c:	4b14      	ldr	r3, [pc, #80]	; (98b0 <self_cap_calib_check+0xa8>)
    985e:	4798      	blx	r3
    9860:	7ba2      	ldrb	r2, [r4, #14]
    9862:	8b63      	ldrh	r3, [r4, #26]
    9864:	2a01      	cmp	r2, #1
    9866:	d112      	bne.n	988e <self_cap_calib_check+0x86>
    9868:	2b00      	cmp	r3, #0
    986a:	d110      	bne.n	988e <self_cap_calib_check+0x86>
    986c:	4a11      	ldr	r2, [pc, #68]	; (98b4 <self_cap_calib_check+0xac>)
    986e:	712b      	strb	r3, [r5, #4]
    9870:	8013      	strh	r3, [r2, #0]
    9872:	4a11      	ldr	r2, [pc, #68]	; (98b8 <self_cap_calib_check+0xb0>)
    9874:	1c20      	adds	r0, r4, #0
    9876:	8013      	strh	r3, [r2, #0]
    9878:	8862      	ldrh	r2, [r4, #2]
    987a:	4b10      	ldr	r3, [pc, #64]	; (98bc <self_cap_calib_check+0xb4>)
    987c:	801a      	strh	r2, [r3, #0]
    987e:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    9880:	2380      	movs	r3, #128	; 0x80
    9882:	005b      	lsls	r3, r3, #1
    9884:	4313      	orrs	r3, r2
    9886:	87e3      	strh	r3, [r4, #62]	; 0x3e
    9888:	4b0d      	ldr	r3, [pc, #52]	; (98c0 <self_cap_calib_check+0xb8>)
    988a:	4798      	blx	r3
    988c:	e005      	b.n	989a <self_cap_calib_check+0x92>
    988e:	2b00      	cmp	r3, #0
    9890:	d103      	bne.n	989a <self_cap_calib_check+0x92>
    9892:	4a08      	ldr	r2, [pc, #32]	; (98b4 <self_cap_calib_check+0xac>)
    9894:	8013      	strh	r3, [r2, #0]
    9896:	4a08      	ldr	r2, [pc, #32]	; (98b8 <self_cap_calib_check+0xb0>)
    9898:	8013      	strh	r3, [r2, #0]
    989a:	bd38      	pop	{r3, r4, r5, pc}
    989c:	20000b30 	.word	0x20000b30
    98a0:	000084c1 	.word	0x000084c1
    98a4:	20000b20 	.word	0x20000b20
    98a8:	0000a1b1 	.word	0x0000a1b1
    98ac:	200009d4 	.word	0x200009d4
    98b0:	000084e1 	.word	0x000084e1
    98b4:	20000b8c 	.word	0x20000b8c
    98b8:	20000b84 	.word	0x20000b84
    98bc:	200013da 	.word	0x200013da
    98c0:	000096f9 	.word	0x000096f9

000098c4 <ptc_cc_calculate_formula>:
    98c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    98c6:	1c0c      	adds	r4, r1, #0
    98c8:	34c8      	adds	r4, #200	; 0xc8
    98ca:	6824      	ldr	r4, [r4, #0]
    98cc:	5ca4      	ldrb	r4, [r4, r2]
    98ce:	1c0a      	adds	r2, r1, #0
    98d0:	32e4      	adds	r2, #228	; 0xe4
    98d2:	7812      	ldrb	r2, [r2, #0]
    98d4:	3a01      	subs	r2, #1
    98d6:	b2d2      	uxtb	r2, r2
    98d8:	2aff      	cmp	r2, #255	; 0xff
    98da:	d004      	beq.n	98e6 <ptc_cc_calculate_formula+0x22>
    98dc:	2c00      	cmp	r4, #0
    98de:	d0f9      	beq.n	98d4 <ptc_cc_calculate_formula+0x10>
    98e0:	3c01      	subs	r4, #1
    98e2:	b2e4      	uxtb	r4, r4
    98e4:	e7f6      	b.n	98d4 <ptc_cc_calculate_formula+0x10>
    98e6:	4a2b      	ldr	r2, [pc, #172]	; (9994 <ptc_cc_calculate_formula+0xd0>)
    98e8:	00a4      	lsls	r4, r4, #2
    98ea:	58a5      	ldr	r5, [r4, r2]
    98ec:	049c      	lsls	r4, r3, #18
    98ee:	0fa4      	lsrs	r4, r4, #30
    98f0:	00a4      	lsls	r4, r4, #2
    98f2:	1914      	adds	r4, r2, r4
    98f4:	69a6      	ldr	r6, [r4, #24]
    98f6:	051c      	lsls	r4, r3, #20
    98f8:	0f24      	lsrs	r4, r4, #28
    98fa:	00a4      	lsls	r4, r4, #2
    98fc:	1914      	adds	r4, r2, r4
    98fe:	6aa4      	ldr	r4, [r4, #40]	; 0x28
    9900:	061f      	lsls	r7, r3, #24
    9902:	1936      	adds	r6, r6, r4
    9904:	0f3f      	lsrs	r7, r7, #28
    9906:	2468      	movs	r4, #104	; 0x68
    9908:	18a4      	adds	r4, r4, r2
    990a:	007f      	lsls	r7, r7, #1
    990c:	5f3f      	ldrsh	r7, [r7, r4]
    990e:	4c22      	ldr	r4, [pc, #136]	; (9998 <ptc_cc_calculate_formula+0xd4>)
    9910:	19f6      	adds	r6, r6, r7
    9912:	270f      	movs	r7, #15
    9914:	403b      	ands	r3, r7
    9916:	005b      	lsls	r3, r3, #1
    9918:	18e3      	adds	r3, r4, r3
    991a:	2708      	movs	r7, #8
    991c:	5fdb      	ldrsh	r3, [r3, r7]
    991e:	18f6      	adds	r6, r6, r3
    9920:	780b      	ldrb	r3, [r1, #0]
    9922:	2b01      	cmp	r3, #1
    9924:	d104      	bne.n	9930 <ptc_cc_calculate_formula+0x6c>
    9926:	4b1d      	ldr	r3, [pc, #116]	; (999c <ptc_cc_calculate_formula+0xd8>)
    9928:	18c0      	adds	r0, r0, r3
    992a:	b280      	uxth	r0, r0
    992c:	230a      	movs	r3, #10
    992e:	e004      	b.n	993a <ptc_cc_calculate_formula+0x76>
    9930:	2380      	movs	r3, #128	; 0x80
    9932:	009b      	lsls	r3, r3, #2
    9934:	1a18      	subs	r0, r3, r0
    9936:	b280      	uxth	r0, r0
    9938:	230b      	movs	r3, #11
    993a:	b200      	sxth	r0, r0
    993c:	4345      	muls	r5, r0
    993e:	411d      	asrs	r5, r3
    9940:	2380      	movs	r3, #128	; 0x80
    9942:	1976      	adds	r6, r6, r5
    9944:	210e      	movs	r1, #14
    9946:	019b      	lsls	r3, r3, #6
    9948:	2000      	movs	r0, #0
    994a:	4318      	orrs	r0, r3
    994c:	0485      	lsls	r5, r0, #18
    994e:	0fad      	lsrs	r5, r5, #30
    9950:	00ad      	lsls	r5, r5, #2
    9952:	1955      	adds	r5, r2, r5
    9954:	69af      	ldr	r7, [r5, #24]
    9956:	0505      	lsls	r5, r0, #20
    9958:	0f2d      	lsrs	r5, r5, #28
    995a:	00ad      	lsls	r5, r5, #2
    995c:	1955      	adds	r5, r2, r5
    995e:	6aad      	ldr	r5, [r5, #40]	; 0x28
    9960:	0604      	lsls	r4, r0, #24
    9962:	197d      	adds	r5, r7, r5
    9964:	0f24      	lsrs	r4, r4, #28
    9966:	1c17      	adds	r7, r2, #0
    9968:	0064      	lsls	r4, r4, #1
    996a:	3768      	adds	r7, #104	; 0x68
    996c:	5fe7      	ldrsh	r7, [r4, r7]
    996e:	4c0a      	ldr	r4, [pc, #40]	; (9998 <ptc_cc_calculate_formula+0xd4>)
    9970:	19ed      	adds	r5, r5, r7
    9972:	270f      	movs	r7, #15
    9974:	4007      	ands	r7, r0
    9976:	007f      	lsls	r7, r7, #1
    9978:	19e7      	adds	r7, r4, r7
    997a:	2408      	movs	r4, #8
    997c:	5f3f      	ldrsh	r7, [r7, r4]
    997e:	19ed      	adds	r5, r5, r7
    9980:	42b5      	cmp	r5, r6
    9982:	dd01      	ble.n	9988 <ptc_cc_calculate_formula+0xc4>
    9984:	4058      	eors	r0, r3
    9986:	b280      	uxth	r0, r0
    9988:	3901      	subs	r1, #1
    998a:	b2c9      	uxtb	r1, r1
    998c:	085b      	lsrs	r3, r3, #1
    998e:	2900      	cmp	r1, #0
    9990:	d1db      	bne.n	994a <ptc_cc_calculate_formula+0x86>
    9992:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9994:	0001365c 	.word	0x0001365c
    9998:	000136dc 	.word	0x000136dc
    999c:	fffffe00 	.word	0xfffffe00

000099a0 <ptc_cc_calib_auto_tune_ctrl_fun>:
    99a0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    99a2:	1c17      	adds	r7, r2, #0
    99a4:	1c1e      	adds	r6, r3, #0
    99a6:	4a34      	ldr	r2, [pc, #208]	; (9a78 <ptc_cc_calib_auto_tune_ctrl_fun+0xd8>)
    99a8:	1c03      	adds	r3, r0, #0
    99aa:	33e4      	adds	r3, #228	; 0xe4
    99ac:	1c05      	adds	r5, r0, #0
    99ae:	7818      	ldrb	r0, [r3, #0]
    99b0:	7813      	ldrb	r3, [r2, #0]
    99b2:	468c      	mov	ip, r1
    99b4:	4c31      	ldr	r4, [pc, #196]	; (9a7c <ptc_cc_calib_auto_tune_ctrl_fun+0xdc>)
    99b6:	1c11      	adds	r1, r2, #0
    99b8:	2b00      	cmp	r3, #0
    99ba:	d038      	beq.n	9a2e <ptc_cc_calib_auto_tune_ctrl_fun+0x8e>
    99bc:	4666      	mov	r6, ip
    99be:	7d62      	ldrb	r2, [r4, #21]
    99c0:	4106      	asrs	r6, r0
    99c2:	b2b0      	uxth	r0, r6
    99c4:	4f2e      	ldr	r7, [pc, #184]	; (9a80 <ptc_cc_calib_auto_tune_ctrl_fun+0xe0>)
    99c6:	2a01      	cmp	r2, #1
    99c8:	d10b      	bne.n	99e2 <ptc_cc_calib_auto_tune_ctrl_fun+0x42>
    99ca:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
    99cc:	4e2d      	ldr	r6, [pc, #180]	; (9a84 <ptc_cc_calib_auto_tune_ctrl_fun+0xe4>)
    99ce:	883a      	ldrh	r2, [r7, #0]
    99d0:	1c29      	adds	r1, r5, #0
    99d2:	47b0      	blx	r6
    99d4:	2302      	movs	r3, #2
    99d6:	4e28      	ldr	r6, [pc, #160]	; (9a78 <ptc_cc_calib_auto_tune_ctrl_fun+0xd8>)
    99d8:	7563      	strb	r3, [r4, #21]
    99da:	2300      	movs	r3, #0
    99dc:	87a0      	strh	r0, [r4, #60]	; 0x3c
    99de:	7033      	strb	r3, [r6, #0]
    99e0:	e017      	b.n	9a12 <ptc_cc_calib_auto_tune_ctrl_fun+0x72>
    99e2:	4a29      	ldr	r2, [pc, #164]	; (9a88 <ptc_cc_calib_auto_tune_ctrl_fun+0xe8>)
    99e4:	8996      	ldrh	r6, [r2, #12]
    99e6:	4286      	cmp	r6, r0
    99e8:	d30b      	bcc.n	9a02 <ptc_cc_calib_auto_tune_ctrl_fun+0x62>
    99ea:	89d2      	ldrh	r2, [r2, #14]
    99ec:	4282      	cmp	r2, r0
    99ee:	d808      	bhi.n	9a02 <ptc_cc_calib_auto_tune_ctrl_fun+0x62>
    99f0:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
    99f2:	883a      	ldrh	r2, [r7, #0]
    99f4:	1c29      	adds	r1, r5, #0
    99f6:	4e23      	ldr	r6, [pc, #140]	; (9a84 <ptc_cc_calib_auto_tune_ctrl_fun+0xe4>)
    99f8:	47b0      	blx	r6
    99fa:	2301      	movs	r3, #1
    99fc:	87a0      	strh	r0, [r4, #60]	; 0x3c
    99fe:	7563      	strb	r3, [r4, #21]
    9a00:	e007      	b.n	9a12 <ptc_cc_calib_auto_tune_ctrl_fun+0x72>
    9a02:	3b01      	subs	r3, #1
    9a04:	700b      	strb	r3, [r1, #0]
    9a06:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
    9a08:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
    9a0a:	085b      	lsrs	r3, r3, #1
    9a0c:	87e3      	strh	r3, [r4, #62]	; 0x3e
    9a0e:	4313      	orrs	r3, r2
    9a10:	87a3      	strh	r3, [r4, #60]	; 0x3c
    9a12:	883a      	ldrh	r2, [r7, #0]
    9a14:	359c      	adds	r5, #156	; 0x9c
    9a16:	682b      	ldr	r3, [r5, #0]
    9a18:	8fa1      	ldrh	r1, [r4, #60]	; 0x3c
    9a1a:	0052      	lsls	r2, r2, #1
    9a1c:	52d1      	strh	r1, [r2, r3]
    9a1e:	883a      	ldrh	r2, [r7, #0]
    9a20:	0052      	lsls	r2, r2, #1
    9a22:	5ad0      	ldrh	r0, [r2, r3]
    9a24:	4b19      	ldr	r3, [pc, #100]	; (9a8c <ptc_cc_calib_auto_tune_ctrl_fun+0xec>)
    9a26:	4798      	blx	r3
    9a28:	4b19      	ldr	r3, [pc, #100]	; (9a90 <ptc_cc_calib_auto_tune_ctrl_fun+0xf0>)
    9a2a:	4798      	blx	r3
    9a2c:	e022      	b.n	9a74 <ptc_cc_calib_auto_tune_ctrl_fun+0xd4>
    9a2e:	7d63      	ldrb	r3, [r4, #21]
    9a30:	2b02      	cmp	r3, #2
    9a32:	d109      	bne.n	9a48 <ptc_cc_calib_auto_tune_ctrl_fun+0xa8>
    9a34:	7c6b      	ldrb	r3, [r5, #17]
    9a36:	2b00      	cmp	r3, #0
    9a38:	d016      	beq.n	9a68 <ptc_cc_calib_auto_tune_ctrl_fun+0xc8>
    9a3a:	2f00      	cmp	r7, #0
    9a3c:	d01a      	beq.n	9a74 <ptc_cc_calib_auto_tune_ctrl_fun+0xd4>
    9a3e:	7c29      	ldrb	r1, [r5, #16]
    9a40:	1c28      	adds	r0, r5, #0
    9a42:	4662      	mov	r2, ip
    9a44:	47b8      	blx	r7
    9a46:	e015      	b.n	9a74 <ptc_cc_calib_auto_tune_ctrl_fun+0xd4>
    9a48:	4b0d      	ldr	r3, [pc, #52]	; (9a80 <ptc_cc_calib_auto_tune_ctrl_fun+0xe0>)
    9a4a:	1c28      	adds	r0, r5, #0
    9a4c:	8819      	ldrh	r1, [r3, #0]
    9a4e:	4b11      	ldr	r3, [pc, #68]	; (9a94 <ptc_cc_calib_auto_tune_ctrl_fun+0xf4>)
    9a50:	4798      	blx	r3
    9a52:	1c2b      	adds	r3, r5, #0
    9a54:	3390      	adds	r3, #144	; 0x90
    9a56:	681b      	ldr	r3, [r3, #0]
    9a58:	2280      	movs	r2, #128	; 0x80
    9a5a:	00c0      	lsls	r0, r0, #3
    9a5c:	54c2      	strb	r2, [r0, r3]
    9a5e:	8fea      	ldrh	r2, [r5, #62]	; 0x3e
    9a60:	2380      	movs	r3, #128	; 0x80
    9a62:	019b      	lsls	r3, r3, #6
    9a64:	4313      	orrs	r3, r2
    9a66:	87eb      	strh	r3, [r5, #62]	; 0x3e
    9a68:	2e00      	cmp	r6, #0
    9a6a:	d001      	beq.n	9a70 <ptc_cc_calib_auto_tune_ctrl_fun+0xd0>
    9a6c:	1c28      	adds	r0, r5, #0
    9a6e:	47b0      	blx	r6
    9a70:	2300      	movs	r3, #0
    9a72:	7563      	strb	r3, [r4, #21]
    9a74:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    9a76:	46c0      	nop			; (mov r8, r8)
    9a78:	200013d7 	.word	0x200013d7
    9a7c:	20000b30 	.word	0x20000b30
    9a80:	200013da 	.word	0x200013da
    9a84:	000098c5 	.word	0x000098c5
    9a88:	200000be 	.word	0x200000be
    9a8c:	0000a0bd 	.word	0x0000a0bd
    9a90:	0000a1b1 	.word	0x0000a1b1
    9a94:	0000a35d 	.word	0x0000a35d

00009a98 <handle_eoc_interrupt>:
    9a98:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    9a9a:	466f      	mov	r7, sp
    9a9c:	2300      	movs	r3, #0
    9a9e:	3706      	adds	r7, #6
    9aa0:	ae01      	add	r6, sp, #4
    9aa2:	1c04      	adds	r4, r0, #0
    9aa4:	803b      	strh	r3, [r7, #0]
    9aa6:	1c30      	adds	r0, r6, #0
    9aa8:	4b7f      	ldr	r3, [pc, #508]	; (9ca8 <handle_eoc_interrupt+0x210>)
    9aaa:	4798      	blx	r3
    9aac:	8b62      	ldrh	r2, [r4, #26]
    9aae:	1c23      	adds	r3, r4, #0
    9ab0:	33e4      	adds	r3, #228	; 0xe4
    9ab2:	4d7e      	ldr	r5, [pc, #504]	; (9cac <handle_eoc_interrupt+0x214>)
    9ab4:	2a00      	cmp	r2, #0
    9ab6:	d035      	beq.n	9b24 <handle_eoc_interrupt+0x8c>
    9ab8:	8831      	ldrh	r1, [r6, #0]
    9aba:	781b      	ldrb	r3, [r3, #0]
    9abc:	1c08      	adds	r0, r1, #0
    9abe:	4118      	asrs	r0, r3
    9ac0:	b283      	uxth	r3, r0
    9ac2:	803b      	strh	r3, [r7, #0]
    9ac4:	4b7a      	ldr	r3, [pc, #488]	; (9cb0 <handle_eoc_interrupt+0x218>)
    9ac6:	4a7b      	ldr	r2, [pc, #492]	; (9cb4 <handle_eoc_interrupt+0x21c>)
    9ac8:	8998      	ldrh	r0, [r3, #12]
    9aca:	4290      	cmp	r0, r2
    9acc:	d802      	bhi.n	9ad4 <handle_eoc_interrupt+0x3c>
    9ace:	89d8      	ldrh	r0, [r3, #14]
    9ad0:	4290      	cmp	r0, r2
    9ad2:	d903      	bls.n	9adc <handle_eoc_interrupt+0x44>
    9ad4:	22c8      	movs	r2, #200	; 0xc8
    9ad6:	81da      	strh	r2, [r3, #14]
    9ad8:	0092      	lsls	r2, r2, #2
    9ada:	819a      	strh	r2, [r3, #12]
    9adc:	7820      	ldrb	r0, [r4, #0]
    9ade:	1c22      	adds	r2, r4, #0
    9ae0:	32fc      	adds	r2, #252	; 0xfc
    9ae2:	4e75      	ldr	r6, [pc, #468]	; (9cb8 <handle_eoc_interrupt+0x220>)
    9ae4:	2800      	cmp	r0, #0
    9ae6:	d10d      	bne.n	9b04 <handle_eoc_interrupt+0x6c>
    9ae8:	7d68      	ldrb	r0, [r5, #21]
    9aea:	2800      	cmp	r0, #0
    9aec:	d107      	bne.n	9afe <handle_eoc_interrupt+0x66>
    9aee:	8838      	ldrh	r0, [r7, #0]
    9af0:	899b      	ldrh	r3, [r3, #12]
    9af2:	4283      	cmp	r3, r0
    9af4:	d803      	bhi.n	9afe <handle_eoc_interrupt+0x66>
    9af6:	8fab      	ldrh	r3, [r5, #60]	; 0x3c
    9af8:	8fe8      	ldrh	r0, [r5, #62]	; 0x3e
    9afa:	4043      	eors	r3, r0
    9afc:	87ab      	strh	r3, [r5, #60]	; 0x3c
    9afe:	69d2      	ldr	r2, [r2, #28]
    9b00:	69ab      	ldr	r3, [r5, #24]
    9b02:	e00c      	b.n	9b1e <handle_eoc_interrupt+0x86>
    9b04:	7d68      	ldrb	r0, [r5, #21]
    9b06:	2800      	cmp	r0, #0
    9b08:	d107      	bne.n	9b1a <handle_eoc_interrupt+0x82>
    9b0a:	8838      	ldrh	r0, [r7, #0]
    9b0c:	89db      	ldrh	r3, [r3, #14]
    9b0e:	4283      	cmp	r3, r0
    9b10:	d303      	bcc.n	9b1a <handle_eoc_interrupt+0x82>
    9b12:	8fab      	ldrh	r3, [r5, #60]	; 0x3c
    9b14:	8fe8      	ldrh	r0, [r5, #62]	; 0x3e
    9b16:	4043      	eors	r3, r0
    9b18:	87ab      	strh	r3, [r5, #60]	; 0x3c
    9b1a:	69d2      	ldr	r2, [r2, #28]
    9b1c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    9b1e:	1c20      	adds	r0, r4, #0
    9b20:	47b0      	blx	r6
    9b22:	e0a8      	b.n	9c76 <handle_eoc_interrupt+0x1de>
    9b24:	4f65      	ldr	r7, [pc, #404]	; (9cbc <handle_eoc_interrupt+0x224>)
    9b26:	1c21      	adds	r1, r4, #0
    9b28:	31c8      	adds	r1, #200	; 0xc8
    9b2a:	781a      	ldrb	r2, [r3, #0]
    9b2c:	6809      	ldr	r1, [r1, #0]
    9b2e:	883b      	ldrh	r3, [r7, #0]
    9b30:	5ccb      	ldrb	r3, [r1, r3]
    9b32:	429a      	cmp	r2, r3
    9b34:	d904      	bls.n	9b40 <handle_eoc_interrupt+0xa8>
    9b36:	8831      	ldrh	r1, [r6, #0]
    9b38:	1ad3      	subs	r3, r2, r3
    9b3a:	b2db      	uxtb	r3, r3
    9b3c:	4119      	asrs	r1, r3
    9b3e:	8031      	strh	r1, [r6, #0]
    9b40:	1d23      	adds	r3, r4, #4
    9b42:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    9b44:	2b00      	cmp	r3, #0
    9b46:	d004      	beq.n	9b52 <handle_eoc_interrupt+0xba>
    9b48:	8831      	ldrh	r1, [r6, #0]
    9b4a:	1c20      	adds	r0, r4, #0
    9b4c:	4798      	blx	r3
    9b4e:	6428      	str	r0, [r5, #64]	; 0x40
    9b50:	e001      	b.n	9b56 <handle_eoc_interrupt+0xbe>
    9b52:	8833      	ldrh	r3, [r6, #0]
    9b54:	642b      	str	r3, [r5, #64]	; 0x40
    9b56:	1c23      	adds	r3, r4, #0
    9b58:	338c      	adds	r3, #140	; 0x8c
    9b5a:	781b      	ldrb	r3, [r3, #0]
    9b5c:	2b00      	cmp	r3, #0
    9b5e:	d151      	bne.n	9c04 <handle_eoc_interrupt+0x16c>
    9b60:	6c2b      	ldr	r3, [r5, #64]	; 0x40
    9b62:	b29a      	uxth	r2, r3
    9b64:	4b56      	ldr	r3, [pc, #344]	; (9cc0 <handle_eoc_interrupt+0x228>)
    9b66:	8032      	strh	r2, [r6, #0]
    9b68:	689b      	ldr	r3, [r3, #8]
    9b6a:	2b00      	cmp	r3, #0
    9b6c:	d007      	beq.n	9b7e <handle_eoc_interrupt+0xe6>
    9b6e:	1c21      	adds	r1, r4, #0
    9b70:	31e8      	adds	r1, #232	; 0xe8
    9b72:	7809      	ldrb	r1, [r1, #0]
    9b74:	2900      	cmp	r1, #0
    9b76:	d002      	beq.n	9b7e <handle_eoc_interrupt+0xe6>
    9b78:	7839      	ldrb	r1, [r7, #0]
    9b7a:	1c20      	adds	r0, r4, #0
    9b7c:	4798      	blx	r3
    9b7e:	1c22      	adds	r2, r4, #0
    9b80:	8838      	ldrh	r0, [r7, #0]
    9b82:	8831      	ldrh	r1, [r6, #0]
    9b84:	6c6b      	ldr	r3, [r5, #68]	; 0x44
    9b86:	4798      	blx	r3
    9b88:	8030      	strh	r0, [r6, #0]
    9b8a:	484d      	ldr	r0, [pc, #308]	; (9cc0 <handle_eoc_interrupt+0x228>)
    9b8c:	6842      	ldr	r2, [r0, #4]
    9b8e:	2a00      	cmp	r2, #0
    9b90:	d017      	beq.n	9bc2 <handle_eoc_interrupt+0x12a>
    9b92:	1c23      	adds	r3, r4, #0
    9b94:	33e9      	adds	r3, #233	; 0xe9
    9b96:	781b      	ldrb	r3, [r3, #0]
    9b98:	2200      	movs	r2, #0
    9b9a:	4293      	cmp	r3, r2
    9b9c:	d011      	beq.n	9bc2 <handle_eoc_interrupt+0x12a>
    9b9e:	8839      	ldrh	r1, [r7, #0]
    9ba0:	4b48      	ldr	r3, [pc, #288]	; (9cc4 <handle_eoc_interrupt+0x22c>)
    9ba2:	1c20      	adds	r0, r4, #0
    9ba4:	4798      	blx	r3
    9ba6:	1c23      	adds	r3, r4, #0
    9ba8:	3390      	adds	r3, #144	; 0x90
    9baa:	3548      	adds	r5, #72	; 0x48
    9bac:	681b      	ldr	r3, [r3, #0]
    9bae:	8028      	strh	r0, [r5, #0]
    9bb0:	00c0      	lsls	r0, r0, #3
    9bb2:	5cc3      	ldrb	r3, [r0, r3]
    9bb4:	4842      	ldr	r0, [pc, #264]	; (9cc0 <handle_eoc_interrupt+0x228>)
    9bb6:	8832      	ldrh	r2, [r6, #0]
    9bb8:	6845      	ldr	r5, [r0, #4]
    9bba:	7839      	ldrb	r1, [r7, #0]
    9bbc:	1c20      	adds	r0, r4, #0
    9bbe:	47a8      	blx	r5
    9bc0:	1c02      	adds	r2, r0, #0
    9bc2:	1c23      	adds	r3, r4, #0
    9bc4:	3308      	adds	r3, #8
    9bc6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    9bc8:	2b00      	cmp	r3, #0
    9bca:	d002      	beq.n	9bd2 <handle_eoc_interrupt+0x13a>
    9bcc:	8831      	ldrh	r1, [r6, #0]
    9bce:	1c20      	adds	r0, r4, #0
    9bd0:	4798      	blx	r3
    9bd2:	4b3a      	ldr	r3, [pc, #232]	; (9cbc <handle_eoc_interrupt+0x224>)
    9bd4:	1c22      	adds	r2, r4, #0
    9bd6:	8819      	ldrh	r1, [r3, #0]
    9bd8:	3294      	adds	r2, #148	; 0x94
    9bda:	6812      	ldr	r2, [r2, #0]
    9bdc:	8830      	ldrh	r0, [r6, #0]
    9bde:	0049      	lsls	r1, r1, #1
    9be0:	5288      	strh	r0, [r1, r2]
    9be2:	881a      	ldrh	r2, [r3, #0]
    9be4:	8863      	ldrh	r3, [r4, #2]
    9be6:	429a      	cmp	r2, r3
    9be8:	d20c      	bcs.n	9c04 <handle_eoc_interrupt+0x16c>
    9bea:	7ba3      	ldrb	r3, [r4, #14]
    9bec:	1c20      	adds	r0, r4, #0
    9bee:	2b01      	cmp	r3, #1
    9bf0:	d106      	bne.n	9c00 <handle_eoc_interrupt+0x168>
    9bf2:	1c23      	adds	r3, r4, #0
    9bf4:	33e6      	adds	r3, #230	; 0xe6
    9bf6:	781b      	ldrb	r3, [r3, #0]
    9bf8:	2b01      	cmp	r3, #1
    9bfa:	d101      	bne.n	9c00 <handle_eoc_interrupt+0x168>
    9bfc:	4b32      	ldr	r3, [pc, #200]	; (9cc8 <handle_eoc_interrupt+0x230>)
    9bfe:	e000      	b.n	9c02 <handle_eoc_interrupt+0x16a>
    9c00:	4b32      	ldr	r3, [pc, #200]	; (9ccc <handle_eoc_interrupt+0x234>)
    9c02:	4798      	blx	r3
    9c04:	4d2d      	ldr	r5, [pc, #180]	; (9cbc <handle_eoc_interrupt+0x224>)
    9c06:	8863      	ldrh	r3, [r4, #2]
    9c08:	8828      	ldrh	r0, [r5, #0]
    9c0a:	4283      	cmp	r3, r0
    9c0c:	d128      	bne.n	9c60 <handle_eoc_interrupt+0x1c8>
    9c0e:	4b27      	ldr	r3, [pc, #156]	; (9cac <handle_eoc_interrupt+0x214>)
    9c10:	2200      	movs	r2, #0
    9c12:	1c19      	adds	r1, r3, #0
    9c14:	3148      	adds	r1, #72	; 0x48
    9c16:	800a      	strh	r2, [r1, #0]
    9c18:	711a      	strb	r2, [r3, #4]
    9c1a:	7862      	ldrb	r2, [r4, #1]
    9c1c:	2a01      	cmp	r2, #1
    9c1e:	d103      	bne.n	9c28 <handle_eoc_interrupt+0x190>
    9c20:	1c20      	adds	r0, r4, #0
    9c22:	4b2b      	ldr	r3, [pc, #172]	; (9cd0 <handle_eoc_interrupt+0x238>)
    9c24:	4798      	blx	r3
    9c26:	e013      	b.n	9c50 <handle_eoc_interrupt+0x1b8>
    9c28:	7822      	ldrb	r2, [r4, #0]
    9c2a:	2a00      	cmp	r2, #0
    9c2c:	d103      	bne.n	9c36 <handle_eoc_interrupt+0x19e>
    9c2e:	4a29      	ldr	r2, [pc, #164]	; (9cd4 <handle_eoc_interrupt+0x23c>)
    9c30:	2102      	movs	r1, #2
    9c32:	7051      	strb	r1, [r2, #1]
    9c34:	e004      	b.n	9c40 <handle_eoc_interrupt+0x1a8>
    9c36:	2a01      	cmp	r2, #1
    9c38:	d102      	bne.n	9c40 <handle_eoc_interrupt+0x1a8>
    9c3a:	4a26      	ldr	r2, [pc, #152]	; (9cd4 <handle_eoc_interrupt+0x23c>)
    9c3c:	2102      	movs	r1, #2
    9c3e:	7011      	strb	r1, [r2, #0]
    9c40:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
    9c42:	4a25      	ldr	r2, [pc, #148]	; (9cd8 <handle_eoc_interrupt+0x240>)
    9c44:	3334      	adds	r3, #52	; 0x34
    9c46:	400a      	ands	r2, r1
    9c48:	87e2      	strh	r2, [r4, #62]	; 0x3e
    9c4a:	2200      	movs	r2, #0
    9c4c:	73a2      	strb	r2, [r4, #14]
    9c4e:	701a      	strb	r2, [r3, #0]
    9c50:	8b63      	ldrh	r3, [r4, #26]
    9c52:	2b00      	cmp	r3, #0
    9c54:	d10f      	bne.n	9c76 <handle_eoc_interrupt+0x1de>
    9c56:	7ba2      	ldrb	r2, [r4, #14]
    9c58:	2a01      	cmp	r2, #1
    9c5a:	d00c      	beq.n	9c76 <handle_eoc_interrupt+0x1de>
    9c5c:	802b      	strh	r3, [r5, #0]
    9c5e:	e00a      	b.n	9c76 <handle_eoc_interrupt+0x1de>
    9c60:	1c23      	adds	r3, r4, #0
    9c62:	338c      	adds	r3, #140	; 0x8c
    9c64:	781b      	ldrb	r3, [r3, #0]
    9c66:	2b00      	cmp	r3, #0
    9c68:	d103      	bne.n	9c72 <handle_eoc_interrupt+0x1da>
    9c6a:	1c21      	adds	r1, r4, #0
    9c6c:	2201      	movs	r2, #1
    9c6e:	4b1b      	ldr	r3, [pc, #108]	; (9cdc <handle_eoc_interrupt+0x244>)
    9c70:	4798      	blx	r3
    9c72:	4b1b      	ldr	r3, [pc, #108]	; (9ce0 <handle_eoc_interrupt+0x248>)
    9c74:	4798      	blx	r3
    9c76:	7823      	ldrb	r3, [r4, #0]
    9c78:	2b00      	cmp	r3, #0
    9c7a:	d102      	bne.n	9c82 <handle_eoc_interrupt+0x1ea>
    9c7c:	4b15      	ldr	r3, [pc, #84]	; (9cd4 <handle_eoc_interrupt+0x23c>)
    9c7e:	785b      	ldrb	r3, [r3, #1]
    9c80:	e003      	b.n	9c8a <handle_eoc_interrupt+0x1f2>
    9c82:	2b01      	cmp	r3, #1
    9c84:	d10e      	bne.n	9ca4 <handle_eoc_interrupt+0x20c>
    9c86:	4b13      	ldr	r3, [pc, #76]	; (9cd4 <handle_eoc_interrupt+0x23c>)
    9c88:	781b      	ldrb	r3, [r3, #0]
    9c8a:	2b02      	cmp	r3, #2
    9c8c:	d10a      	bne.n	9ca4 <handle_eoc_interrupt+0x20c>
    9c8e:	4b15      	ldr	r3, [pc, #84]	; (9ce4 <handle_eoc_interrupt+0x24c>)
    9c90:	4798      	blx	r3
    9c92:	34fc      	adds	r4, #252	; 0xfc
    9c94:	4b14      	ldr	r3, [pc, #80]	; (9ce8 <handle_eoc_interrupt+0x250>)
    9c96:	4798      	blx	r3
    9c98:	6a63      	ldr	r3, [r4, #36]	; 0x24
    9c9a:	2b00      	cmp	r3, #0
    9c9c:	d002      	beq.n	9ca4 <handle_eoc_interrupt+0x20c>
    9c9e:	4798      	blx	r3
    9ca0:	2300      	movs	r3, #0
    9ca2:	6263      	str	r3, [r4, #36]	; 0x24
    9ca4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    9ca6:	46c0      	nop			; (mov r8, r8)
    9ca8:	00009ee5 	.word	0x00009ee5
    9cac:	20000b30 	.word	0x20000b30
    9cb0:	200000be 	.word	0x200000be
    9cb4:	000003ff 	.word	0x000003ff
    9cb8:	000099a1 	.word	0x000099a1
    9cbc:	200013da 	.word	0x200013da
    9cc0:	200009e0 	.word	0x200009e0
    9cc4:	0000a35d 	.word	0x0000a35d
    9cc8:	000091dd 	.word	0x000091dd
    9ccc:	000092dd 	.word	0x000092dd
    9cd0:	000084f1 	.word	0x000084f1
    9cd4:	200009d4 	.word	0x200009d4
    9cd8:	fffffeff 	.word	0xfffffeff
    9cdc:	00009365 	.word	0x00009365
    9ce0:	0000a1b1 	.word	0x0000a1b1
    9ce4:	00009ec9 	.word	0x00009ec9
    9ce8:	00009f1d 	.word	0x00009f1d

00009cec <median_filter>:
    9cec:	b570      	push	{r4, r5, r6, lr}
    9cee:	7813      	ldrb	r3, [r2, #0]
    9cf0:	2b01      	cmp	r3, #1
    9cf2:	d102      	bne.n	9cfa <median_filter+0xe>
    9cf4:	1c13      	adds	r3, r2, #0
    9cf6:	33b4      	adds	r3, #180	; 0xb4
    9cf8:	e001      	b.n	9cfe <median_filter+0x12>
    9cfa:	1c13      	adds	r3, r2, #0
    9cfc:	33b8      	adds	r3, #184	; 0xb8
    9cfe:	2403      	movs	r4, #3
    9d00:	4344      	muls	r4, r0
    9d02:	b2a4      	uxth	r4, r4
    9d04:	681b      	ldr	r3, [r3, #0]
    9d06:	0064      	lsls	r4, r4, #1
    9d08:	1ca0      	adds	r0, r4, #2
    9d0a:	1818      	adds	r0, r3, r0
    9d0c:	8805      	ldrh	r5, [r0, #0]
    9d0e:	191e      	adds	r6, r3, r4
    9d10:	3404      	adds	r4, #4
    9d12:	8035      	strh	r5, [r6, #0]
    9d14:	191b      	adds	r3, r3, r4
    9d16:	881c      	ldrh	r4, [r3, #0]
    9d18:	32cc      	adds	r2, #204	; 0xcc
    9d1a:	8004      	strh	r4, [r0, #0]
    9d1c:	8019      	strh	r1, [r3, #0]
    9d1e:	7813      	ldrb	r3, [r2, #0]
    9d20:	2202      	movs	r2, #2
    9d22:	4393      	bics	r3, r2
    9d24:	2b01      	cmp	r3, #1
    9d26:	d115      	bne.n	9d54 <median_filter+0x68>
    9d28:	8833      	ldrh	r3, [r6, #0]
    9d2a:	8802      	ldrh	r2, [r0, #0]
    9d2c:	4293      	cmp	r3, r2
    9d2e:	d806      	bhi.n	9d3e <median_filter+0x52>
    9d30:	428b      	cmp	r3, r1
    9d32:	d20c      	bcs.n	9d4e <median_filter+0x62>
    9d34:	b28d      	uxth	r5, r1
    9d36:	1c13      	adds	r3, r2, #0
    9d38:	42aa      	cmp	r2, r5
    9d3a:	d907      	bls.n	9d4c <median_filter+0x60>
    9d3c:	e005      	b.n	9d4a <median_filter+0x5e>
    9d3e:	428b      	cmp	r3, r1
    9d40:	d905      	bls.n	9d4e <median_filter+0x62>
    9d42:	b28d      	uxth	r5, r1
    9d44:	1c13      	adds	r3, r2, #0
    9d46:	42aa      	cmp	r2, r5
    9d48:	d200      	bcs.n	9d4c <median_filter+0x60>
    9d4a:	1c0b      	adds	r3, r1, #0
    9d4c:	b29b      	uxth	r3, r3
    9d4e:	2b00      	cmp	r3, #0
    9d50:	d000      	beq.n	9d54 <median_filter+0x68>
    9d52:	1c19      	adds	r1, r3, #0
    9d54:	1c08      	adds	r0, r1, #0
    9d56:	bd70      	pop	{r4, r5, r6, pc}

00009d58 <setup_self_channel_cc_recal>:
    9d58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9d5a:	4d35      	ldr	r5, [pc, #212]	; (9e30 <setup_self_channel_cc_recal+0xd8>)
    9d5c:	230e      	movs	r3, #14
    9d5e:	702b      	strb	r3, [r5, #0]
    9d60:	4c34      	ldr	r4, [pc, #208]	; (9e34 <setup_self_channel_cc_recal+0xdc>)
    9d62:	1c03      	adds	r3, r0, #0
    9d64:	3378      	adds	r3, #120	; 0x78
    9d66:	2201      	movs	r2, #1
    9d68:	701a      	strb	r2, [r3, #0]
    9d6a:	7822      	ldrb	r2, [r4, #0]
    9d6c:	1c01      	adds	r1, r0, #0
    9d6e:	4b32      	ldr	r3, [pc, #200]	; (9e38 <setup_self_channel_cc_recal+0xe0>)
    9d70:	2a00      	cmp	r2, #0
    9d72:	d021      	beq.n	9db8 <setup_self_channel_cc_recal+0x60>
    9d74:	1c02      	adds	r2, r0, #0
    9d76:	3290      	adds	r2, #144	; 0x90
    9d78:	6816      	ldr	r6, [r2, #0]
    9d7a:	88c7      	ldrh	r7, [r0, #6]
    9d7c:	881a      	ldrh	r2, [r3, #0]
    9d7e:	7898      	ldrb	r0, [r3, #2]
    9d80:	00d5      	lsls	r5, r2, #3
    9d82:	5dad      	ldrb	r5, [r5, r6]
    9d84:	2d01      	cmp	r5, #1
    9d86:	d100      	bne.n	9d8a <setup_self_channel_cc_recal+0x32>
    9d88:	1c28      	adds	r0, r5, #0
    9d8a:	3201      	adds	r2, #1
    9d8c:	b292      	uxth	r2, r2
    9d8e:	42ba      	cmp	r2, r7
    9d90:	d30f      	bcc.n	9db2 <setup_self_channel_cc_recal+0x5a>
    9d92:	4f2a      	ldr	r7, [pc, #168]	; (9e3c <setup_self_channel_cc_recal+0xe4>)
    9d94:	801a      	strh	r2, [r3, #0]
    9d96:	19d2      	adds	r2, r2, r7
    9d98:	00d2      	lsls	r2, r2, #3
    9d9a:	18b6      	adds	r6, r6, r2
    9d9c:	7098      	strb	r0, [r3, #2]
    9d9e:	7970      	ldrb	r0, [r6, #5]
    9da0:	8098      	strh	r0, [r3, #4]
    9da2:	79b2      	ldrb	r2, [r6, #6]
    9da4:	1c46      	adds	r6, r0, #1
    9da6:	80da      	strh	r2, [r3, #6]
    9da8:	811e      	strh	r6, [r3, #8]
    9daa:	4290      	cmp	r0, r2
    9dac:	d010      	beq.n	9dd0 <setup_self_channel_cc_recal+0x78>
    9dae:	2200      	movs	r2, #0
    9db0:	e00f      	b.n	9dd2 <setup_self_channel_cc_recal+0x7a>
    9db2:	2800      	cmp	r0, #0
    9db4:	d0e4      	beq.n	9d80 <setup_self_channel_cc_recal+0x28>
    9db6:	e7ec      	b.n	9d92 <setup_self_channel_cc_recal+0x3a>
    9db8:	8898      	ldrh	r0, [r3, #4]
    9dba:	88da      	ldrh	r2, [r3, #6]
    9dbc:	4290      	cmp	r0, r2
    9dbe:	d004      	beq.n	9dca <setup_self_channel_cc_recal+0x72>
    9dc0:	891e      	ldrh	r6, [r3, #8]
    9dc2:	3001      	adds	r0, #1
    9dc4:	3601      	adds	r6, #1
    9dc6:	811e      	strh	r6, [r3, #8]
    9dc8:	8098      	strh	r0, [r3, #4]
    9dca:	8898      	ldrh	r0, [r3, #4]
    9dcc:	4290      	cmp	r0, r2
    9dce:	d101      	bne.n	9dd4 <setup_self_channel_cc_recal+0x7c>
    9dd0:	2201      	movs	r2, #1
    9dd2:	7022      	strb	r2, [r4, #0]
    9dd4:	2200      	movs	r2, #0
    9dd6:	709a      	strb	r2, [r3, #2]
    9dd8:	891a      	ldrh	r2, [r3, #8]
    9dda:	4819      	ldr	r0, [pc, #100]	; (9e40 <setup_self_channel_cc_recal+0xe8>)
    9ddc:	3a01      	subs	r2, #1
    9dde:	7a9c      	ldrb	r4, [r3, #10]
    9de0:	b292      	uxth	r2, r2
    9de2:	8002      	strh	r2, [r0, #0]
    9de4:	1c06      	adds	r6, r0, #0
    9de6:	4817      	ldr	r0, [pc, #92]	; (9e44 <setup_self_channel_cc_recal+0xec>)
    9de8:	2c00      	cmp	r4, #0
    9dea:	d109      	bne.n	9e00 <setup_self_channel_cc_recal+0xa8>
    9dec:	4f10      	ldr	r7, [pc, #64]	; (9e30 <setup_self_channel_cc_recal+0xd8>)
    9dee:	729c      	strb	r4, [r3, #10]
    9df0:	783d      	ldrb	r5, [r7, #0]
    9df2:	2701      	movs	r7, #1
    9df4:	3d01      	subs	r5, #1
    9df6:	40af      	lsls	r7, r5
    9df8:	b2bd      	uxth	r5, r7
    9dfa:	4f13      	ldr	r7, [pc, #76]	; (9e48 <setup_self_channel_cc_recal+0xf0>)
    9dfc:	8005      	strh	r5, [r0, #0]
    9dfe:	803d      	strh	r5, [r7, #0]
    9e00:	1c0b      	adds	r3, r1, #0
    9e02:	33d8      	adds	r3, #216	; 0xd8
    9e04:	681b      	ldr	r3, [r3, #0]
    9e06:	8800      	ldrh	r0, [r0, #0]
    9e08:	5c9c      	ldrb	r4, [r3, r2]
    9e0a:	4b10      	ldr	r3, [pc, #64]	; (9e4c <setup_self_channel_cc_recal+0xf4>)
    9e0c:	701c      	strb	r4, [r3, #0]
    9e0e:	1c0b      	adds	r3, r1, #0
    9e10:	33dc      	adds	r3, #220	; 0xdc
    9e12:	681b      	ldr	r3, [r3, #0]
    9e14:	5c9c      	ldrb	r4, [r3, r2]
    9e16:	4b0e      	ldr	r3, [pc, #56]	; (9e50 <setup_self_channel_cc_recal+0xf8>)
    9e18:	0052      	lsls	r2, r2, #1
    9e1a:	701c      	strb	r4, [r3, #0]
    9e1c:	1c0b      	adds	r3, r1, #0
    9e1e:	339c      	adds	r3, #156	; 0x9c
    9e20:	681b      	ldr	r3, [r3, #0]
    9e22:	52d0      	strh	r0, [r2, r3]
    9e24:	8830      	ldrh	r0, [r6, #0]
    9e26:	2200      	movs	r2, #0
    9e28:	4b0a      	ldr	r3, [pc, #40]	; (9e54 <setup_self_channel_cc_recal+0xfc>)
    9e2a:	4798      	blx	r3
    9e2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9e2e:	46c0      	nop			; (mov r8, r8)
    9e30:	200013d7 	.word	0x200013d7
    9e34:	200000ce 	.word	0x200000ce
    9e38:	20000b84 	.word	0x20000b84
    9e3c:	1fffffff 	.word	0x1fffffff
    9e40:	200013da 	.word	0x200013da
    9e44:	20000b6e 	.word	0x20000b6e
    9e48:	20000b6c 	.word	0x20000b6c
    9e4c:	20000b38 	.word	0x20000b38
    9e50:	20000b37 	.word	0x20000b37
    9e54:	00009365 	.word	0x00009365

00009e58 <pin_mode_analog>:
    9e58:	084b      	lsrs	r3, r1, #1
    9e5a:	01c0      	lsls	r0, r0, #7
    9e5c:	2201      	movs	r2, #1
    9e5e:	b530      	push	{r4, r5, lr}
    9e60:	181b      	adds	r3, r3, r0
    9e62:	4211      	tst	r1, r2
    9e64:	d006      	beq.n	9e74 <pin_mode_analog+0x1c>
    9e66:	4a0b      	ldr	r2, [pc, #44]	; (9e94 <pin_mode_analog+0x3c>)
    9e68:	189b      	adds	r3, r3, r2
    9e6a:	781c      	ldrb	r4, [r3, #0]
    9e6c:	220f      	movs	r2, #15
    9e6e:	4022      	ands	r2, r4
    9e70:	2410      	movs	r4, #16
    9e72:	e004      	b.n	9e7e <pin_mode_analog+0x26>
    9e74:	4c07      	ldr	r4, [pc, #28]	; (9e94 <pin_mode_analog+0x3c>)
    9e76:	250f      	movs	r5, #15
    9e78:	191b      	adds	r3, r3, r4
    9e7a:	781c      	ldrb	r4, [r3, #0]
    9e7c:	43ac      	bics	r4, r5
    9e7e:	4322      	orrs	r2, r4
    9e80:	701a      	strb	r2, [r3, #0]
    9e82:	4a05      	ldr	r2, [pc, #20]	; (9e98 <pin_mode_analog+0x40>)
    9e84:	1809      	adds	r1, r1, r0
    9e86:	1889      	adds	r1, r1, r2
    9e88:	780b      	ldrb	r3, [r1, #0]
    9e8a:	2201      	movs	r2, #1
    9e8c:	4313      	orrs	r3, r2
    9e8e:	700b      	strb	r3, [r1, #0]
    9e90:	bd30      	pop	{r4, r5, pc}
    9e92:	46c0      	nop			; (mov r8, r8)
    9e94:	40002830 	.word	0x40002830
    9e98:	40002840 	.word	0x40002840

00009e9c <sync_config>:
    9e9c:	4a02      	ldr	r2, [pc, #8]	; (9ea8 <sync_config+0xc>)
    9e9e:	7853      	ldrb	r3, [r2, #1]
    9ea0:	09db      	lsrs	r3, r3, #7
    9ea2:	d1fc      	bne.n	9e9e <sync_config+0x2>
    9ea4:	4770      	bx	lr
    9ea6:	46c0      	nop			; (mov r8, r8)
    9ea8:	43001400 	.word	0x43001400

00009eac <enable_ptc>:
    9eac:	b510      	push	{r4, lr}
    9eae:	4c04      	ldr	r4, [pc, #16]	; (9ec0 <enable_ptc+0x14>)
    9eb0:	47a0      	blx	r4
    9eb2:	4b04      	ldr	r3, [pc, #16]	; (9ec4 <enable_ptc+0x18>)
    9eb4:	2102      	movs	r1, #2
    9eb6:	781a      	ldrb	r2, [r3, #0]
    9eb8:	430a      	orrs	r2, r1
    9eba:	701a      	strb	r2, [r3, #0]
    9ebc:	47a0      	blx	r4
    9ebe:	bd10      	pop	{r4, pc}
    9ec0:	00009e9d 	.word	0x00009e9d
    9ec4:	43001400 	.word	0x43001400

00009ec8 <disable_ptc>:
    9ec8:	b510      	push	{r4, lr}
    9eca:	4c04      	ldr	r4, [pc, #16]	; (9edc <disable_ptc+0x14>)
    9ecc:	47a0      	blx	r4
    9ece:	4b04      	ldr	r3, [pc, #16]	; (9ee0 <disable_ptc+0x18>)
    9ed0:	2102      	movs	r1, #2
    9ed2:	781a      	ldrb	r2, [r3, #0]
    9ed4:	438a      	bics	r2, r1
    9ed6:	701a      	strb	r2, [r3, #0]
    9ed8:	47a0      	blx	r4
    9eda:	bd10      	pop	{r4, pc}
    9edc:	00009e9d 	.word	0x00009e9d
    9ee0:	43001400 	.word	0x43001400

00009ee4 <get_conversion_result>:
    9ee4:	b538      	push	{r3, r4, r5, lr}
    9ee6:	4c04      	ldr	r4, [pc, #16]	; (9ef8 <get_conversion_result+0x14>)
    9ee8:	1c05      	adds	r5, r0, #0
    9eea:	47a0      	blx	r4
    9eec:	4b03      	ldr	r3, [pc, #12]	; (9efc <get_conversion_result+0x18>)
    9eee:	8b9b      	ldrh	r3, [r3, #28]
    9ef0:	802b      	strh	r3, [r5, #0]
    9ef2:	47a0      	blx	r4
    9ef4:	bd38      	pop	{r3, r4, r5, pc}
    9ef6:	46c0      	nop			; (mov r8, r8)
    9ef8:	00009e9d 	.word	0x00009e9d
    9efc:	43001400 	.word	0x43001400

00009f00 <enable_run_in_stdby>:
    9f00:	b510      	push	{r4, lr}
    9f02:	4c04      	ldr	r4, [pc, #16]	; (9f14 <enable_run_in_stdby+0x14>)
    9f04:	47a0      	blx	r4
    9f06:	4b04      	ldr	r3, [pc, #16]	; (9f18 <enable_run_in_stdby+0x18>)
    9f08:	2104      	movs	r1, #4
    9f0a:	781a      	ldrb	r2, [r3, #0]
    9f0c:	430a      	orrs	r2, r1
    9f0e:	701a      	strb	r2, [r3, #0]
    9f10:	47a0      	blx	r4
    9f12:	bd10      	pop	{r4, pc}
    9f14:	00009e9d 	.word	0x00009e9d
    9f18:	43001400 	.word	0x43001400

00009f1c <disable_run_in_stdby>:
    9f1c:	b510      	push	{r4, lr}
    9f1e:	4c04      	ldr	r4, [pc, #16]	; (9f30 <disable_run_in_stdby+0x14>)
    9f20:	47a0      	blx	r4
    9f22:	4b04      	ldr	r3, [pc, #16]	; (9f34 <disable_run_in_stdby+0x18>)
    9f24:	2104      	movs	r1, #4
    9f26:	781a      	ldrb	r2, [r3, #0]
    9f28:	438a      	bics	r2, r1
    9f2a:	701a      	strb	r2, [r3, #0]
    9f2c:	47a0      	blx	r4
    9f2e:	bd10      	pop	{r4, pc}
    9f30:	00009e9d 	.word	0x00009e9d
    9f34:	43001400 	.word	0x43001400

00009f38 <clear_wco_int_flag>:
    9f38:	b510      	push	{r4, lr}
    9f3a:	4c04      	ldr	r4, [pc, #16]	; (9f4c <clear_wco_int_flag+0x14>)
    9f3c:	47a0      	blx	r4
    9f3e:	4b04      	ldr	r3, [pc, #16]	; (9f50 <clear_wco_int_flag+0x18>)
    9f40:	2102      	movs	r1, #2
    9f42:	7a9a      	ldrb	r2, [r3, #10]
    9f44:	430a      	orrs	r2, r1
    9f46:	729a      	strb	r2, [r3, #10]
    9f48:	47a0      	blx	r4
    9f4a:	bd10      	pop	{r4, pc}
    9f4c:	00009e9d 	.word	0x00009e9d
    9f50:	43001400 	.word	0x43001400

00009f54 <clear_eoc_int_flag>:
    9f54:	b510      	push	{r4, lr}
    9f56:	4c04      	ldr	r4, [pc, #16]	; (9f68 <clear_eoc_int_flag+0x14>)
    9f58:	47a0      	blx	r4
    9f5a:	4b04      	ldr	r3, [pc, #16]	; (9f6c <clear_eoc_int_flag+0x18>)
    9f5c:	2101      	movs	r1, #1
    9f5e:	7a9a      	ldrb	r2, [r3, #10]
    9f60:	430a      	orrs	r2, r1
    9f62:	729a      	strb	r2, [r3, #10]
    9f64:	47a0      	blx	r4
    9f66:	bd10      	pop	{r4, pc}
    9f68:	00009e9d 	.word	0x00009e9d
    9f6c:	43001400 	.word	0x43001400

00009f70 <check_n_clear_eoc_flag>:
    9f70:	b508      	push	{r3, lr}
    9f72:	4b04      	ldr	r3, [pc, #16]	; (9f84 <check_n_clear_eoc_flag+0x14>)
    9f74:	4798      	blx	r3
    9f76:	4b04      	ldr	r3, [pc, #16]	; (9f88 <check_n_clear_eoc_flag+0x18>)
    9f78:	7a9b      	ldrb	r3, [r3, #10]
    9f7a:	07da      	lsls	r2, r3, #31
    9f7c:	d501      	bpl.n	9f82 <check_n_clear_eoc_flag+0x12>
    9f7e:	4b03      	ldr	r3, [pc, #12]	; (9f8c <check_n_clear_eoc_flag+0x1c>)
    9f80:	4798      	blx	r3
    9f82:	bd08      	pop	{r3, pc}
    9f84:	00009e9d 	.word	0x00009e9d
    9f88:	43001400 	.word	0x43001400
    9f8c:	00009f55 	.word	0x00009f55

00009f90 <check_n_clear_wco_flag>:
    9f90:	b508      	push	{r3, lr}
    9f92:	4b04      	ldr	r3, [pc, #16]	; (9fa4 <check_n_clear_wco_flag+0x14>)
    9f94:	4798      	blx	r3
    9f96:	4b04      	ldr	r3, [pc, #16]	; (9fa8 <check_n_clear_wco_flag+0x18>)
    9f98:	7a9b      	ldrb	r3, [r3, #10]
    9f9a:	079a      	lsls	r2, r3, #30
    9f9c:	d501      	bpl.n	9fa2 <check_n_clear_wco_flag+0x12>
    9f9e:	4b03      	ldr	r3, [pc, #12]	; (9fac <check_n_clear_wco_flag+0x1c>)
    9fa0:	4798      	blx	r3
    9fa2:	bd08      	pop	{r3, pc}
    9fa4:	00009e9d 	.word	0x00009e9d
    9fa8:	43001400 	.word	0x43001400
    9fac:	00009f39 	.word	0x00009f39

00009fb0 <disable_wco_int>:
    9fb0:	b510      	push	{r4, lr}
    9fb2:	4c04      	ldr	r4, [pc, #16]	; (9fc4 <disable_wco_int+0x14>)
    9fb4:	47a0      	blx	r4
    9fb6:	4b04      	ldr	r3, [pc, #16]	; (9fc8 <disable_wco_int+0x18>)
    9fb8:	2102      	movs	r1, #2
    9fba:	7a1a      	ldrb	r2, [r3, #8]
    9fbc:	430a      	orrs	r2, r1
    9fbe:	721a      	strb	r2, [r3, #8]
    9fc0:	47a0      	blx	r4
    9fc2:	bd10      	pop	{r4, pc}
    9fc4:	00009e9d 	.word	0x00009e9d
    9fc8:	43001400 	.word	0x43001400

00009fcc <enable_eoc_int>:
    9fcc:	b510      	push	{r4, lr}
    9fce:	4c04      	ldr	r4, [pc, #16]	; (9fe0 <enable_eoc_int+0x14>)
    9fd0:	47a0      	blx	r4
    9fd2:	4b04      	ldr	r3, [pc, #16]	; (9fe4 <enable_eoc_int+0x18>)
    9fd4:	2101      	movs	r1, #1
    9fd6:	7a5a      	ldrb	r2, [r3, #9]
    9fd8:	430a      	orrs	r2, r1
    9fda:	725a      	strb	r2, [r3, #9]
    9fdc:	47a0      	blx	r4
    9fde:	bd10      	pop	{r4, pc}
    9fe0:	00009e9d 	.word	0x00009e9d
    9fe4:	43001400 	.word	0x43001400

00009fe8 <set_freq_spread>:
    9fe8:	b538      	push	{r3, r4, r5, lr}
    9fea:	4c07      	ldr	r4, [pc, #28]	; (a008 <set_freq_spread+0x20>)
    9fec:	1c05      	adds	r5, r0, #0
    9fee:	47a0      	blx	r4
    9ff0:	4b06      	ldr	r3, [pc, #24]	; (a00c <set_freq_spread+0x24>)
    9ff2:	2201      	movs	r2, #1
    9ff4:	4015      	ands	r5, r2
    9ff6:	012a      	lsls	r2, r5, #4
    9ff8:	7b1d      	ldrb	r5, [r3, #12]
    9ffa:	2110      	movs	r1, #16
    9ffc:	438d      	bics	r5, r1
    9ffe:	4315      	orrs	r5, r2
    a000:	731d      	strb	r5, [r3, #12]
    a002:	47a0      	blx	r4
    a004:	bd38      	pop	{r3, r4, r5, pc}
    a006:	46c0      	nop			; (mov r8, r8)
    a008:	00009e9d 	.word	0x00009e9d
    a00c:	43001400 	.word	0x43001400

0000a010 <set_xy_select>:
    a010:	b570      	push	{r4, r5, r6, lr}
    a012:	1c0d      	adds	r5, r1, #0
    a014:	4c05      	ldr	r4, [pc, #20]	; (a02c <set_xy_select+0x1c>)
    a016:	1c06      	adds	r6, r0, #0
    a018:	47a0      	blx	r4
    a01a:	b2ab      	uxth	r3, r5
    a01c:	4d04      	ldr	r5, [pc, #16]	; (a030 <set_xy_select+0x20>)
    a01e:	b2b6      	uxth	r6, r6
    a020:	822b      	strh	r3, [r5, #16]
    a022:	47a0      	blx	r4
    a024:	826e      	strh	r6, [r5, #18]
    a026:	47a0      	blx	r4
    a028:	bd70      	pop	{r4, r5, r6, pc}
    a02a:	46c0      	nop			; (mov r8, r8)
    a02c:	00009e9d 	.word	0x00009e9d
    a030:	43001400 	.word	0x43001400

0000a034 <set_burst_mode>:
    a034:	b538      	push	{r3, r4, r5, lr}
    a036:	4c06      	ldr	r4, [pc, #24]	; (a050 <set_burst_mode+0x1c>)
    a038:	1c05      	adds	r5, r0, #0
    a03a:	47a0      	blx	r4
    a03c:	4b05      	ldr	r3, [pc, #20]	; (a054 <set_burst_mode+0x20>)
    a03e:	220f      	movs	r2, #15
    a040:	7fd9      	ldrb	r1, [r3, #31]
    a042:	4015      	ands	r5, r2
    a044:	012d      	lsls	r5, r5, #4
    a046:	400a      	ands	r2, r1
    a048:	432a      	orrs	r2, r5
    a04a:	77da      	strb	r2, [r3, #31]
    a04c:	47a0      	blx	r4
    a04e:	bd38      	pop	{r3, r4, r5, pc}
    a050:	00009e9d 	.word	0x00009e9d
    a054:	43001401 	.word	0x43001401

0000a058 <set_cts_lowpower_mode>:
    a058:	b510      	push	{r4, lr}
    a05a:	4c04      	ldr	r4, [pc, #16]	; (a06c <set_cts_lowpower_mode+0x14>)
    a05c:	47a0      	blx	r4
    a05e:	4b04      	ldr	r3, [pc, #16]	; (a070 <set_cts_lowpower_mode+0x18>)
    a060:	2104      	movs	r1, #4
    a062:	7fda      	ldrb	r2, [r3, #31]
    a064:	430a      	orrs	r2, r1
    a066:	77da      	strb	r2, [r3, #31]
    a068:	47a0      	blx	r4
    a06a:	bd10      	pop	{r4, pc}
    a06c:	00009e9d 	.word	0x00009e9d
    a070:	43001401 	.word	0x43001401

0000a074 <set_adc_accumulation_cnt>:
    a074:	b538      	push	{r3, r4, r5, lr}
    a076:	4c06      	ldr	r4, [pc, #24]	; (a090 <set_adc_accumulation_cnt+0x1c>)
    a078:	1c05      	adds	r5, r0, #0
    a07a:	47a0      	blx	r4
    a07c:	4b05      	ldr	r3, [pc, #20]	; (a094 <set_adc_accumulation_cnt+0x20>)
    a07e:	2207      	movs	r2, #7
    a080:	7b59      	ldrb	r1, [r3, #13]
    a082:	4015      	ands	r5, r2
    a084:	4391      	bics	r1, r2
    a086:	430d      	orrs	r5, r1
    a088:	735d      	strb	r5, [r3, #13]
    a08a:	47a0      	blx	r4
    a08c:	bd38      	pop	{r3, r4, r5, pc}
    a08e:	46c0      	nop			; (mov r8, r8)
    a090:	00009e9d 	.word	0x00009e9d
    a094:	43001400 	.word	0x43001400

0000a098 <set_sample_delay>:
    a098:	b538      	push	{r3, r4, r5, lr}
    a09a:	4c06      	ldr	r4, [pc, #24]	; (a0b4 <set_sample_delay+0x1c>)
    a09c:	1c05      	adds	r5, r0, #0
    a09e:	47a0      	blx	r4
    a0a0:	4b05      	ldr	r3, [pc, #20]	; (a0b8 <set_sample_delay+0x20>)
    a0a2:	220f      	movs	r2, #15
    a0a4:	7b19      	ldrb	r1, [r3, #12]
    a0a6:	4015      	ands	r5, r2
    a0a8:	4391      	bics	r1, r2
    a0aa:	430d      	orrs	r5, r1
    a0ac:	731d      	strb	r5, [r3, #12]
    a0ae:	47a0      	blx	r4
    a0b0:	bd38      	pop	{r3, r4, r5, pc}
    a0b2:	46c0      	nop			; (mov r8, r8)
    a0b4:	00009e9d 	.word	0x00009e9d
    a0b8:	43001400 	.word	0x43001400

0000a0bc <load_comp_cap>:
    a0bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a0be:	4c15      	ldr	r4, [pc, #84]	; (a114 <load_comp_cap+0x58>)
    a0c0:	1c07      	adds	r7, r0, #0
    a0c2:	4d15      	ldr	r5, [pc, #84]	; (a118 <load_comp_cap+0x5c>)
    a0c4:	47a8      	blx	r5
    a0c6:	8b21      	ldrh	r1, [r4, #24]
    a0c8:	04ba      	lsls	r2, r7, #18
    a0ca:	4b14      	ldr	r3, [pc, #80]	; (a11c <load_comp_cap+0x60>)
    a0cc:	0f92      	lsrs	r2, r2, #30
    a0ce:	0312      	lsls	r2, r2, #12
    a0d0:	400b      	ands	r3, r1
    a0d2:	4313      	orrs	r3, r2
    a0d4:	8323      	strh	r3, [r4, #24]
    a0d6:	47a8      	blx	r5
    a0d8:	260f      	movs	r6, #15
    a0da:	8b21      	ldrh	r1, [r4, #24]
    a0dc:	0a3a      	lsrs	r2, r7, #8
    a0de:	4b10      	ldr	r3, [pc, #64]	; (a120 <load_comp_cap+0x64>)
    a0e0:	4032      	ands	r2, r6
    a0e2:	0212      	lsls	r2, r2, #8
    a0e4:	400b      	ands	r3, r1
    a0e6:	4313      	orrs	r3, r2
    a0e8:	8323      	strh	r3, [r4, #24]
    a0ea:	47a8      	blx	r5
    a0ec:	23f0      	movs	r3, #240	; 0xf0
    a0ee:	1c3a      	adds	r2, r7, #0
    a0f0:	8b21      	ldrh	r1, [r4, #24]
    a0f2:	401a      	ands	r2, r3
    a0f4:	0912      	lsrs	r2, r2, #4
    a0f6:	4399      	bics	r1, r3
    a0f8:	4032      	ands	r2, r6
    a0fa:	0112      	lsls	r2, r2, #4
    a0fc:	1c0b      	adds	r3, r1, #0
    a0fe:	4313      	orrs	r3, r2
    a100:	8323      	strh	r3, [r4, #24]
    a102:	47a8      	blx	r5
    a104:	8b23      	ldrh	r3, [r4, #24]
    a106:	4037      	ands	r7, r6
    a108:	43b3      	bics	r3, r6
    a10a:	431f      	orrs	r7, r3
    a10c:	8327      	strh	r7, [r4, #24]
    a10e:	47a8      	blx	r5
    a110:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a112:	46c0      	nop			; (mov r8, r8)
    a114:	43001400 	.word	0x43001400
    a118:	00009e9d 	.word	0x00009e9d
    a11c:	ffffcfff 	.word	0xffffcfff
    a120:	fffff0ff 	.word	0xfffff0ff

0000a124 <load_int_cap>:
    a124:	b570      	push	{r4, r5, r6, lr}
    a126:	4c0a      	ldr	r4, [pc, #40]	; (a150 <load_int_cap+0x2c>)
    a128:	4d0a      	ldr	r5, [pc, #40]	; (a154 <load_int_cap+0x30>)
    a12a:	1c06      	adds	r6, r0, #0
    a12c:	47a8      	blx	r5
    a12e:	7ea1      	ldrb	r1, [r4, #26]
    a130:	2330      	movs	r3, #48	; 0x30
    a132:	4399      	bics	r1, r3
    a134:	1c32      	adds	r2, r6, #0
    a136:	401a      	ands	r2, r3
    a138:	1c0b      	adds	r3, r1, #0
    a13a:	4313      	orrs	r3, r2
    a13c:	76a3      	strb	r3, [r4, #26]
    a13e:	47a8      	blx	r5
    a140:	7ea2      	ldrb	r2, [r4, #26]
    a142:	230f      	movs	r3, #15
    a144:	401e      	ands	r6, r3
    a146:	439a      	bics	r2, r3
    a148:	4316      	orrs	r6, r2
    a14a:	76a6      	strb	r6, [r4, #26]
    a14c:	47a8      	blx	r5
    a14e:	bd70      	pop	{r4, r5, r6, pc}
    a150:	43001400 	.word	0x43001400
    a154:	00009e9d 	.word	0x00009e9d

0000a158 <load_sense_r>:
    a158:	b538      	push	{r3, r4, r5, lr}
    a15a:	4c06      	ldr	r4, [pc, #24]	; (a174 <load_sense_r+0x1c>)
    a15c:	1c05      	adds	r5, r0, #0
    a15e:	47a0      	blx	r4
    a160:	4b05      	ldr	r3, [pc, #20]	; (a178 <load_sense_r+0x20>)
    a162:	2203      	movs	r2, #3
    a164:	7ed9      	ldrb	r1, [r3, #27]
    a166:	4015      	ands	r5, r2
    a168:	4391      	bics	r1, r2
    a16a:	430d      	orrs	r5, r1
    a16c:	76dd      	strb	r5, [r3, #27]
    a16e:	47a0      	blx	r4
    a170:	bd38      	pop	{r3, r4, r5, pc}
    a172:	46c0      	nop			; (mov r8, r8)
    a174:	00009e9d 	.word	0x00009e9d
    a178:	43001400 	.word	0x43001400

0000a17c <load_ptc_prescaler>:
    a17c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a17e:	4c0a      	ldr	r4, [pc, #40]	; (a1a8 <load_ptc_prescaler+0x2c>)
    a180:	4d0a      	ldr	r5, [pc, #40]	; (a1ac <load_ptc_prescaler+0x30>)
    a182:	1c07      	adds	r7, r0, #0
    a184:	47a8      	blx	r5
    a186:	7823      	ldrb	r3, [r4, #0]
    a188:	2602      	movs	r6, #2
    a18a:	43b3      	bics	r3, r6
    a18c:	7023      	strb	r3, [r4, #0]
    a18e:	47a8      	blx	r5
    a190:	7922      	ldrb	r2, [r4, #4]
    a192:	2303      	movs	r3, #3
    a194:	439a      	bics	r2, r3
    a196:	401f      	ands	r7, r3
    a198:	4317      	orrs	r7, r2
    a19a:	7127      	strb	r7, [r4, #4]
    a19c:	47a8      	blx	r5
    a19e:	7823      	ldrb	r3, [r4, #0]
    a1a0:	431e      	orrs	r6, r3
    a1a2:	7026      	strb	r6, [r4, #0]
    a1a4:	47a8      	blx	r5
    a1a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a1a8:	43001400 	.word	0x43001400
    a1ac:	00009e9d 	.word	0x00009e9d

0000a1b0 <start_ptc_acquire>:
    a1b0:	b510      	push	{r4, lr}
    a1b2:	4c05      	ldr	r4, [pc, #20]	; (a1c8 <start_ptc_acquire+0x18>)
    a1b4:	47a0      	blx	r4
    a1b6:	4b05      	ldr	r3, [pc, #20]	; (a1cc <start_ptc_acquire+0x1c>)
    a1b8:	2280      	movs	r2, #128	; 0x80
    a1ba:	7b59      	ldrb	r1, [r3, #13]
    a1bc:	4252      	negs	r2, r2
    a1be:	430a      	orrs	r2, r1
    a1c0:	735a      	strb	r2, [r3, #13]
    a1c2:	47a0      	blx	r4
    a1c4:	bd10      	pop	{r4, pc}
    a1c6:	46c0      	nop			; (mov r8, r8)
    a1c8:	00009e9d 	.word	0x00009e9d
    a1cc:	43001400 	.word	0x43001400

0000a1d0 <ptc_init_settings>:
    a1d0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    a1d2:	2300      	movs	r3, #0
    a1d4:	8844      	ldrh	r4, [r0, #2]
    a1d6:	1c1f      	adds	r7, r3, #0
    a1d8:	9301      	str	r3, [sp, #4]
    a1da:	b29a      	uxth	r2, r3
    a1dc:	42a2      	cmp	r2, r4
    a1de:	d213      	bcs.n	a208 <ptc_init_settings+0x38>
    a1e0:	7801      	ldrb	r1, [r0, #0]
    a1e2:	1c02      	adds	r2, r0, #0
    a1e4:	32c4      	adds	r2, #196	; 0xc4
    a1e6:	2900      	cmp	r1, #0
    a1e8:	d108      	bne.n	a1fc <ptc_init_settings+0x2c>
    a1ea:	6811      	ldr	r1, [r2, #0]
    a1ec:	00da      	lsls	r2, r3, #3
    a1ee:	5a8d      	ldrh	r5, [r1, r2]
    a1f0:	9e01      	ldr	r6, [sp, #4]
    a1f2:	188a      	adds	r2, r1, r2
    a1f4:	432e      	orrs	r6, r5
    a1f6:	9601      	str	r6, [sp, #4]
    a1f8:	8892      	ldrh	r2, [r2, #4]
    a1fa:	e002      	b.n	a202 <ptc_init_settings+0x32>
    a1fc:	6811      	ldr	r1, [r2, #0]
    a1fe:	009a      	lsls	r2, r3, #2
    a200:	5a8a      	ldrh	r2, [r1, r2]
    a202:	4317      	orrs	r7, r2
    a204:	3301      	adds	r3, #1
    a206:	e7e8      	b.n	a1da <ptc_init_settings+0xa>
    a208:	2600      	movs	r6, #0
    a20a:	2001      	movs	r0, #1
    a20c:	1c05      	adds	r5, r0, #0
    a20e:	9a01      	ldr	r2, [sp, #4]
    a210:	40b5      	lsls	r5, r6
    a212:	b2f4      	uxtb	r4, r6
    a214:	4215      	tst	r5, r2
    a216:	d00b      	beq.n	a230 <ptc_init_settings+0x60>
    a218:	4b46      	ldr	r3, [pc, #280]	; (a334 <ptc_init_settings+0x164>)
    a21a:	1e21      	subs	r1, r4, #0
    a21c:	2903      	cmp	r1, #3
    a21e:	d801      	bhi.n	a224 <ptc_init_settings+0x54>
    a220:	3108      	adds	r1, #8
    a222:	e002      	b.n	a22a <ptc_init_settings+0x5a>
    a224:	2c0b      	cmp	r4, #11
    a226:	d802      	bhi.n	a22e <ptc_init_settings+0x5e>
    a228:	310c      	adds	r1, #12
    a22a:	b2c9      	uxtb	r1, r1
    a22c:	2000      	movs	r0, #0
    a22e:	4798      	blx	r3
    a230:	422f      	tst	r7, r5
    a232:	d040      	beq.n	a2b6 <ptc_init_settings+0xe6>
    a234:	2c01      	cmp	r4, #1
    a236:	d920      	bls.n	a27a <ptc_init_settings+0xaa>
    a238:	2c03      	cmp	r4, #3
    a23a:	d805      	bhi.n	a248 <ptc_init_settings+0x78>
    a23c:	3408      	adds	r4, #8
    a23e:	b2e1      	uxtb	r1, r4
    a240:	2001      	movs	r0, #1
    a242:	4b3c      	ldr	r3, [pc, #240]	; (a334 <ptc_init_settings+0x164>)
    a244:	4798      	blx	r3
    a246:	e036      	b.n	a2b6 <ptc_init_settings+0xe6>
    a248:	2c04      	cmp	r4, #4
    a24a:	d108      	bne.n	a25e <ptc_init_settings+0x8e>
    a24c:	4b3a      	ldr	r3, [pc, #232]	; (a338 <ptc_init_settings+0x168>)
    a24e:	220f      	movs	r2, #15
    a250:	7819      	ldrb	r1, [r3, #0]
    a252:	4391      	bics	r1, r2
    a254:	2201      	movs	r2, #1
    a256:	4311      	orrs	r1, r2
    a258:	7019      	strb	r1, [r3, #0]
    a25a:	4b38      	ldr	r3, [pc, #224]	; (a33c <ptc_init_settings+0x16c>)
    a25c:	e009      	b.n	a272 <ptc_init_settings+0xa2>
    a25e:	2c05      	cmp	r4, #5
    a260:	d109      	bne.n	a276 <ptc_init_settings+0xa6>
    a262:	4b37      	ldr	r3, [pc, #220]	; (a340 <ptc_init_settings+0x170>)
    a264:	220f      	movs	r2, #15
    a266:	7819      	ldrb	r1, [r3, #0]
    a268:	4391      	bics	r1, r2
    a26a:	2201      	movs	r2, #1
    a26c:	4311      	orrs	r1, r2
    a26e:	7019      	strb	r1, [r3, #0]
    a270:	4b34      	ldr	r3, [pc, #208]	; (a344 <ptc_init_settings+0x174>)
    a272:	7819      	ldrb	r1, [r3, #0]
    a274:	e01d      	b.n	a2b2 <ptc_init_settings+0xe2>
    a276:	2c09      	cmp	r4, #9
    a278:	d803      	bhi.n	a282 <ptc_init_settings+0xb2>
    a27a:	3402      	adds	r4, #2
    a27c:	b2e1      	uxtb	r1, r4
    a27e:	2000      	movs	r0, #0
    a280:	e7df      	b.n	a242 <ptc_init_settings+0x72>
    a282:	2c0d      	cmp	r4, #13
    a284:	d801      	bhi.n	a28a <ptc_init_settings+0xba>
    a286:	3c06      	subs	r4, #6
    a288:	e7d9      	b.n	a23e <ptc_init_settings+0x6e>
    a28a:	220f      	movs	r2, #15
    a28c:	2c0e      	cmp	r4, #14
    a28e:	d107      	bne.n	a2a0 <ptc_init_settings+0xd0>
    a290:	4b2b      	ldr	r3, [pc, #172]	; (a340 <ptc_init_settings+0x170>)
    a292:	7819      	ldrb	r1, [r3, #0]
    a294:	400a      	ands	r2, r1
    a296:	2110      	movs	r1, #16
    a298:	430a      	orrs	r2, r1
    a29a:	701a      	strb	r2, [r3, #0]
    a29c:	4b2a      	ldr	r3, [pc, #168]	; (a348 <ptc_init_settings+0x178>)
    a29e:	e006      	b.n	a2ae <ptc_init_settings+0xde>
    a2a0:	4b2a      	ldr	r3, [pc, #168]	; (a34c <ptc_init_settings+0x17c>)
    a2a2:	7819      	ldrb	r1, [r3, #0]
    a2a4:	400a      	ands	r2, r1
    a2a6:	2110      	movs	r1, #16
    a2a8:	430a      	orrs	r2, r1
    a2aa:	701a      	strb	r2, [r3, #0]
    a2ac:	4b28      	ldr	r3, [pc, #160]	; (a350 <ptc_init_settings+0x180>)
    a2ae:	781a      	ldrb	r2, [r3, #0]
    a2b0:	2101      	movs	r1, #1
    a2b2:	430a      	orrs	r2, r1
    a2b4:	701a      	strb	r2, [r3, #0]
    a2b6:	3601      	adds	r6, #1
    a2b8:	2e10      	cmp	r6, #16
    a2ba:	d1a6      	bne.n	a20a <ptc_init_settings+0x3a>
    a2bc:	4c25      	ldr	r4, [pc, #148]	; (a354 <ptc_init_settings+0x184>)
    a2be:	4d26      	ldr	r5, [pc, #152]	; (a358 <ptc_init_settings+0x188>)
    a2c0:	47a8      	blx	r5
    a2c2:	2300      	movs	r3, #0
    a2c4:	7023      	strb	r3, [r4, #0]
    a2c6:	47a8      	blx	r5
    a2c8:	9a01      	ldr	r2, [sp, #4]
    a2ca:	8ae3      	ldrh	r3, [r4, #22]
    a2cc:	4313      	orrs	r3, r2
    a2ce:	82e3      	strh	r3, [r4, #22]
    a2d0:	47a8      	blx	r5
    a2d2:	8aa3      	ldrh	r3, [r4, #20]
    a2d4:	431f      	orrs	r7, r3
    a2d6:	82a7      	strh	r7, [r4, #20]
    a2d8:	47a8      	blx	r5
    a2da:	7923      	ldrb	r3, [r4, #4]
    a2dc:	2208      	movs	r2, #8
    a2de:	4393      	bics	r3, r2
    a2e0:	7123      	strb	r3, [r4, #4]
    a2e2:	47a8      	blx	r5
    a2e4:	7923      	ldrb	r3, [r4, #4]
    a2e6:	2704      	movs	r7, #4
    a2e8:	43bb      	bics	r3, r7
    a2ea:	7123      	strb	r3, [r4, #4]
    a2ec:	47a8      	blx	r5
    a2ee:	7923      	ldrb	r3, [r4, #4]
    a2f0:	2203      	movs	r2, #3
    a2f2:	4393      	bics	r3, r2
    a2f4:	7123      	strb	r3, [r4, #4]
    a2f6:	47a8      	blx	r5
    a2f8:	7b23      	ldrb	r3, [r4, #12]
    a2fa:	2260      	movs	r2, #96	; 0x60
    a2fc:	4393      	bics	r3, r2
    a2fe:	7323      	strb	r3, [r4, #12]
    a300:	47a8      	blx	r5
    a302:	7b23      	ldrb	r3, [r4, #12]
    a304:	43b3      	bics	r3, r6
    a306:	7323      	strb	r3, [r4, #12]
    a308:	47a8      	blx	r5
    a30a:	7b23      	ldrb	r3, [r4, #12]
    a30c:	220f      	movs	r2, #15
    a30e:	4393      	bics	r3, r2
    a310:	7323      	strb	r3, [r4, #12]
    a312:	47a8      	blx	r5
    a314:	7963      	ldrb	r3, [r4, #5]
    a316:	2201      	movs	r2, #1
    a318:	4313      	orrs	r3, r2
    a31a:	7163      	strb	r3, [r4, #5]
    a31c:	47a8      	blx	r5
    a31e:	7823      	ldrb	r3, [r4, #0]
    a320:	431f      	orrs	r7, r3
    a322:	7027      	strb	r7, [r4, #0]
    a324:	47a8      	blx	r5
    a326:	7823      	ldrb	r3, [r4, #0]
    a328:	2202      	movs	r2, #2
    a32a:	4313      	orrs	r3, r2
    a32c:	7023      	strb	r3, [r4, #0]
    a32e:	47a8      	blx	r5
    a330:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    a332:	46c0      	nop			; (mov r8, r8)
    a334:	00009e59 	.word	0x00009e59
    a338:	40002833 	.word	0x40002833
    a33c:	40002846 	.word	0x40002846
    a340:	400028b6 	.word	0x400028b6
    a344:	400028cc 	.word	0x400028cc
    a348:	400028cd 	.word	0x400028cd
    a34c:	400028b4 	.word	0x400028b4
    a350:	400028c9 	.word	0x400028c9
    a354:	43001400 	.word	0x43001400
    a358:	00009e9d 	.word	0x00009e9d

0000a35c <channel_to_sensor_mapping>:
    a35c:	b570      	push	{r4, r5, r6, lr}
    a35e:	2200      	movs	r2, #0
    a360:	8904      	ldrh	r4, [r0, #8]
    a362:	1c13      	adds	r3, r2, #0
    a364:	42a3      	cmp	r3, r4
    a366:	d20f      	bcs.n	a388 <channel_to_sensor_mapping+0x2c>
    a368:	1c06      	adds	r6, r0, #0
    a36a:	3690      	adds	r6, #144	; 0x90
    a36c:	6836      	ldr	r6, [r6, #0]
    a36e:	00dd      	lsls	r5, r3, #3
    a370:	1975      	adds	r5, r6, r5
    a372:	79ae      	ldrb	r6, [r5, #6]
    a374:	796d      	ldrb	r5, [r5, #5]
    a376:	428d      	cmp	r5, r1
    a378:	d803      	bhi.n	a382 <channel_to_sensor_mapping+0x26>
    a37a:	42b1      	cmp	r1, r6
    a37c:	d801      	bhi.n	a382 <channel_to_sensor_mapping+0x26>
    a37e:	1c1a      	adds	r2, r3, #0
    a380:	1c23      	adds	r3, r4, #0
    a382:	3301      	adds	r3, #1
    a384:	b29b      	uxth	r3, r3
    a386:	e7ed      	b.n	a364 <channel_to_sensor_mapping+0x8>
    a388:	1c10      	adds	r0, r2, #0
    a38a:	bd70      	pop	{r4, r5, r6, pc}

0000a38c <__aeabi_uidiv>:
    a38c:	2200      	movs	r2, #0
    a38e:	0843      	lsrs	r3, r0, #1
    a390:	428b      	cmp	r3, r1
    a392:	d374      	bcc.n	a47e <__aeabi_uidiv+0xf2>
    a394:	0903      	lsrs	r3, r0, #4
    a396:	428b      	cmp	r3, r1
    a398:	d35f      	bcc.n	a45a <__aeabi_uidiv+0xce>
    a39a:	0a03      	lsrs	r3, r0, #8
    a39c:	428b      	cmp	r3, r1
    a39e:	d344      	bcc.n	a42a <__aeabi_uidiv+0x9e>
    a3a0:	0b03      	lsrs	r3, r0, #12
    a3a2:	428b      	cmp	r3, r1
    a3a4:	d328      	bcc.n	a3f8 <__aeabi_uidiv+0x6c>
    a3a6:	0c03      	lsrs	r3, r0, #16
    a3a8:	428b      	cmp	r3, r1
    a3aa:	d30d      	bcc.n	a3c8 <__aeabi_uidiv+0x3c>
    a3ac:	22ff      	movs	r2, #255	; 0xff
    a3ae:	0209      	lsls	r1, r1, #8
    a3b0:	ba12      	rev	r2, r2
    a3b2:	0c03      	lsrs	r3, r0, #16
    a3b4:	428b      	cmp	r3, r1
    a3b6:	d302      	bcc.n	a3be <__aeabi_uidiv+0x32>
    a3b8:	1212      	asrs	r2, r2, #8
    a3ba:	0209      	lsls	r1, r1, #8
    a3bc:	d065      	beq.n	a48a <__aeabi_uidiv+0xfe>
    a3be:	0b03      	lsrs	r3, r0, #12
    a3c0:	428b      	cmp	r3, r1
    a3c2:	d319      	bcc.n	a3f8 <__aeabi_uidiv+0x6c>
    a3c4:	e000      	b.n	a3c8 <__aeabi_uidiv+0x3c>
    a3c6:	0a09      	lsrs	r1, r1, #8
    a3c8:	0bc3      	lsrs	r3, r0, #15
    a3ca:	428b      	cmp	r3, r1
    a3cc:	d301      	bcc.n	a3d2 <__aeabi_uidiv+0x46>
    a3ce:	03cb      	lsls	r3, r1, #15
    a3d0:	1ac0      	subs	r0, r0, r3
    a3d2:	4152      	adcs	r2, r2
    a3d4:	0b83      	lsrs	r3, r0, #14
    a3d6:	428b      	cmp	r3, r1
    a3d8:	d301      	bcc.n	a3de <__aeabi_uidiv+0x52>
    a3da:	038b      	lsls	r3, r1, #14
    a3dc:	1ac0      	subs	r0, r0, r3
    a3de:	4152      	adcs	r2, r2
    a3e0:	0b43      	lsrs	r3, r0, #13
    a3e2:	428b      	cmp	r3, r1
    a3e4:	d301      	bcc.n	a3ea <__aeabi_uidiv+0x5e>
    a3e6:	034b      	lsls	r3, r1, #13
    a3e8:	1ac0      	subs	r0, r0, r3
    a3ea:	4152      	adcs	r2, r2
    a3ec:	0b03      	lsrs	r3, r0, #12
    a3ee:	428b      	cmp	r3, r1
    a3f0:	d301      	bcc.n	a3f6 <__aeabi_uidiv+0x6a>
    a3f2:	030b      	lsls	r3, r1, #12
    a3f4:	1ac0      	subs	r0, r0, r3
    a3f6:	4152      	adcs	r2, r2
    a3f8:	0ac3      	lsrs	r3, r0, #11
    a3fa:	428b      	cmp	r3, r1
    a3fc:	d301      	bcc.n	a402 <__aeabi_uidiv+0x76>
    a3fe:	02cb      	lsls	r3, r1, #11
    a400:	1ac0      	subs	r0, r0, r3
    a402:	4152      	adcs	r2, r2
    a404:	0a83      	lsrs	r3, r0, #10
    a406:	428b      	cmp	r3, r1
    a408:	d301      	bcc.n	a40e <__aeabi_uidiv+0x82>
    a40a:	028b      	lsls	r3, r1, #10
    a40c:	1ac0      	subs	r0, r0, r3
    a40e:	4152      	adcs	r2, r2
    a410:	0a43      	lsrs	r3, r0, #9
    a412:	428b      	cmp	r3, r1
    a414:	d301      	bcc.n	a41a <__aeabi_uidiv+0x8e>
    a416:	024b      	lsls	r3, r1, #9
    a418:	1ac0      	subs	r0, r0, r3
    a41a:	4152      	adcs	r2, r2
    a41c:	0a03      	lsrs	r3, r0, #8
    a41e:	428b      	cmp	r3, r1
    a420:	d301      	bcc.n	a426 <__aeabi_uidiv+0x9a>
    a422:	020b      	lsls	r3, r1, #8
    a424:	1ac0      	subs	r0, r0, r3
    a426:	4152      	adcs	r2, r2
    a428:	d2cd      	bcs.n	a3c6 <__aeabi_uidiv+0x3a>
    a42a:	09c3      	lsrs	r3, r0, #7
    a42c:	428b      	cmp	r3, r1
    a42e:	d301      	bcc.n	a434 <__aeabi_uidiv+0xa8>
    a430:	01cb      	lsls	r3, r1, #7
    a432:	1ac0      	subs	r0, r0, r3
    a434:	4152      	adcs	r2, r2
    a436:	0983      	lsrs	r3, r0, #6
    a438:	428b      	cmp	r3, r1
    a43a:	d301      	bcc.n	a440 <__aeabi_uidiv+0xb4>
    a43c:	018b      	lsls	r3, r1, #6
    a43e:	1ac0      	subs	r0, r0, r3
    a440:	4152      	adcs	r2, r2
    a442:	0943      	lsrs	r3, r0, #5
    a444:	428b      	cmp	r3, r1
    a446:	d301      	bcc.n	a44c <__aeabi_uidiv+0xc0>
    a448:	014b      	lsls	r3, r1, #5
    a44a:	1ac0      	subs	r0, r0, r3
    a44c:	4152      	adcs	r2, r2
    a44e:	0903      	lsrs	r3, r0, #4
    a450:	428b      	cmp	r3, r1
    a452:	d301      	bcc.n	a458 <__aeabi_uidiv+0xcc>
    a454:	010b      	lsls	r3, r1, #4
    a456:	1ac0      	subs	r0, r0, r3
    a458:	4152      	adcs	r2, r2
    a45a:	08c3      	lsrs	r3, r0, #3
    a45c:	428b      	cmp	r3, r1
    a45e:	d301      	bcc.n	a464 <__aeabi_uidiv+0xd8>
    a460:	00cb      	lsls	r3, r1, #3
    a462:	1ac0      	subs	r0, r0, r3
    a464:	4152      	adcs	r2, r2
    a466:	0883      	lsrs	r3, r0, #2
    a468:	428b      	cmp	r3, r1
    a46a:	d301      	bcc.n	a470 <__aeabi_uidiv+0xe4>
    a46c:	008b      	lsls	r3, r1, #2
    a46e:	1ac0      	subs	r0, r0, r3
    a470:	4152      	adcs	r2, r2
    a472:	0843      	lsrs	r3, r0, #1
    a474:	428b      	cmp	r3, r1
    a476:	d301      	bcc.n	a47c <__aeabi_uidiv+0xf0>
    a478:	004b      	lsls	r3, r1, #1
    a47a:	1ac0      	subs	r0, r0, r3
    a47c:	4152      	adcs	r2, r2
    a47e:	1a41      	subs	r1, r0, r1
    a480:	d200      	bcs.n	a484 <__aeabi_uidiv+0xf8>
    a482:	4601      	mov	r1, r0
    a484:	4152      	adcs	r2, r2
    a486:	4610      	mov	r0, r2
    a488:	4770      	bx	lr
    a48a:	e7ff      	b.n	a48c <__aeabi_uidiv+0x100>
    a48c:	b501      	push	{r0, lr}
    a48e:	2000      	movs	r0, #0
    a490:	f000 f8f0 	bl	a674 <__aeabi_idiv0>
    a494:	bd02      	pop	{r1, pc}
    a496:	46c0      	nop			; (mov r8, r8)

0000a498 <__aeabi_uidivmod>:
    a498:	2900      	cmp	r1, #0
    a49a:	d0f7      	beq.n	a48c <__aeabi_uidiv+0x100>
    a49c:	e776      	b.n	a38c <__aeabi_uidiv>
    a49e:	4770      	bx	lr

0000a4a0 <__aeabi_idiv>:
    a4a0:	4603      	mov	r3, r0
    a4a2:	430b      	orrs	r3, r1
    a4a4:	d47f      	bmi.n	a5a6 <__aeabi_idiv+0x106>
    a4a6:	2200      	movs	r2, #0
    a4a8:	0843      	lsrs	r3, r0, #1
    a4aa:	428b      	cmp	r3, r1
    a4ac:	d374      	bcc.n	a598 <__aeabi_idiv+0xf8>
    a4ae:	0903      	lsrs	r3, r0, #4
    a4b0:	428b      	cmp	r3, r1
    a4b2:	d35f      	bcc.n	a574 <__aeabi_idiv+0xd4>
    a4b4:	0a03      	lsrs	r3, r0, #8
    a4b6:	428b      	cmp	r3, r1
    a4b8:	d344      	bcc.n	a544 <__aeabi_idiv+0xa4>
    a4ba:	0b03      	lsrs	r3, r0, #12
    a4bc:	428b      	cmp	r3, r1
    a4be:	d328      	bcc.n	a512 <__aeabi_idiv+0x72>
    a4c0:	0c03      	lsrs	r3, r0, #16
    a4c2:	428b      	cmp	r3, r1
    a4c4:	d30d      	bcc.n	a4e2 <__aeabi_idiv+0x42>
    a4c6:	22ff      	movs	r2, #255	; 0xff
    a4c8:	0209      	lsls	r1, r1, #8
    a4ca:	ba12      	rev	r2, r2
    a4cc:	0c03      	lsrs	r3, r0, #16
    a4ce:	428b      	cmp	r3, r1
    a4d0:	d302      	bcc.n	a4d8 <__aeabi_idiv+0x38>
    a4d2:	1212      	asrs	r2, r2, #8
    a4d4:	0209      	lsls	r1, r1, #8
    a4d6:	d065      	beq.n	a5a4 <__aeabi_idiv+0x104>
    a4d8:	0b03      	lsrs	r3, r0, #12
    a4da:	428b      	cmp	r3, r1
    a4dc:	d319      	bcc.n	a512 <__aeabi_idiv+0x72>
    a4de:	e000      	b.n	a4e2 <__aeabi_idiv+0x42>
    a4e0:	0a09      	lsrs	r1, r1, #8
    a4e2:	0bc3      	lsrs	r3, r0, #15
    a4e4:	428b      	cmp	r3, r1
    a4e6:	d301      	bcc.n	a4ec <__aeabi_idiv+0x4c>
    a4e8:	03cb      	lsls	r3, r1, #15
    a4ea:	1ac0      	subs	r0, r0, r3
    a4ec:	4152      	adcs	r2, r2
    a4ee:	0b83      	lsrs	r3, r0, #14
    a4f0:	428b      	cmp	r3, r1
    a4f2:	d301      	bcc.n	a4f8 <__aeabi_idiv+0x58>
    a4f4:	038b      	lsls	r3, r1, #14
    a4f6:	1ac0      	subs	r0, r0, r3
    a4f8:	4152      	adcs	r2, r2
    a4fa:	0b43      	lsrs	r3, r0, #13
    a4fc:	428b      	cmp	r3, r1
    a4fe:	d301      	bcc.n	a504 <__aeabi_idiv+0x64>
    a500:	034b      	lsls	r3, r1, #13
    a502:	1ac0      	subs	r0, r0, r3
    a504:	4152      	adcs	r2, r2
    a506:	0b03      	lsrs	r3, r0, #12
    a508:	428b      	cmp	r3, r1
    a50a:	d301      	bcc.n	a510 <__aeabi_idiv+0x70>
    a50c:	030b      	lsls	r3, r1, #12
    a50e:	1ac0      	subs	r0, r0, r3
    a510:	4152      	adcs	r2, r2
    a512:	0ac3      	lsrs	r3, r0, #11
    a514:	428b      	cmp	r3, r1
    a516:	d301      	bcc.n	a51c <__aeabi_idiv+0x7c>
    a518:	02cb      	lsls	r3, r1, #11
    a51a:	1ac0      	subs	r0, r0, r3
    a51c:	4152      	adcs	r2, r2
    a51e:	0a83      	lsrs	r3, r0, #10
    a520:	428b      	cmp	r3, r1
    a522:	d301      	bcc.n	a528 <__aeabi_idiv+0x88>
    a524:	028b      	lsls	r3, r1, #10
    a526:	1ac0      	subs	r0, r0, r3
    a528:	4152      	adcs	r2, r2
    a52a:	0a43      	lsrs	r3, r0, #9
    a52c:	428b      	cmp	r3, r1
    a52e:	d301      	bcc.n	a534 <__aeabi_idiv+0x94>
    a530:	024b      	lsls	r3, r1, #9
    a532:	1ac0      	subs	r0, r0, r3
    a534:	4152      	adcs	r2, r2
    a536:	0a03      	lsrs	r3, r0, #8
    a538:	428b      	cmp	r3, r1
    a53a:	d301      	bcc.n	a540 <__aeabi_idiv+0xa0>
    a53c:	020b      	lsls	r3, r1, #8
    a53e:	1ac0      	subs	r0, r0, r3
    a540:	4152      	adcs	r2, r2
    a542:	d2cd      	bcs.n	a4e0 <__aeabi_idiv+0x40>
    a544:	09c3      	lsrs	r3, r0, #7
    a546:	428b      	cmp	r3, r1
    a548:	d301      	bcc.n	a54e <__aeabi_idiv+0xae>
    a54a:	01cb      	lsls	r3, r1, #7
    a54c:	1ac0      	subs	r0, r0, r3
    a54e:	4152      	adcs	r2, r2
    a550:	0983      	lsrs	r3, r0, #6
    a552:	428b      	cmp	r3, r1
    a554:	d301      	bcc.n	a55a <__aeabi_idiv+0xba>
    a556:	018b      	lsls	r3, r1, #6
    a558:	1ac0      	subs	r0, r0, r3
    a55a:	4152      	adcs	r2, r2
    a55c:	0943      	lsrs	r3, r0, #5
    a55e:	428b      	cmp	r3, r1
    a560:	d301      	bcc.n	a566 <__aeabi_idiv+0xc6>
    a562:	014b      	lsls	r3, r1, #5
    a564:	1ac0      	subs	r0, r0, r3
    a566:	4152      	adcs	r2, r2
    a568:	0903      	lsrs	r3, r0, #4
    a56a:	428b      	cmp	r3, r1
    a56c:	d301      	bcc.n	a572 <__aeabi_idiv+0xd2>
    a56e:	010b      	lsls	r3, r1, #4
    a570:	1ac0      	subs	r0, r0, r3
    a572:	4152      	adcs	r2, r2
    a574:	08c3      	lsrs	r3, r0, #3
    a576:	428b      	cmp	r3, r1
    a578:	d301      	bcc.n	a57e <__aeabi_idiv+0xde>
    a57a:	00cb      	lsls	r3, r1, #3
    a57c:	1ac0      	subs	r0, r0, r3
    a57e:	4152      	adcs	r2, r2
    a580:	0883      	lsrs	r3, r0, #2
    a582:	428b      	cmp	r3, r1
    a584:	d301      	bcc.n	a58a <__aeabi_idiv+0xea>
    a586:	008b      	lsls	r3, r1, #2
    a588:	1ac0      	subs	r0, r0, r3
    a58a:	4152      	adcs	r2, r2
    a58c:	0843      	lsrs	r3, r0, #1
    a58e:	428b      	cmp	r3, r1
    a590:	d301      	bcc.n	a596 <__aeabi_idiv+0xf6>
    a592:	004b      	lsls	r3, r1, #1
    a594:	1ac0      	subs	r0, r0, r3
    a596:	4152      	adcs	r2, r2
    a598:	1a41      	subs	r1, r0, r1
    a59a:	d200      	bcs.n	a59e <__aeabi_idiv+0xfe>
    a59c:	4601      	mov	r1, r0
    a59e:	4152      	adcs	r2, r2
    a5a0:	4610      	mov	r0, r2
    a5a2:	4770      	bx	lr
    a5a4:	e05d      	b.n	a662 <__aeabi_idiv+0x1c2>
    a5a6:	0fca      	lsrs	r2, r1, #31
    a5a8:	d000      	beq.n	a5ac <__aeabi_idiv+0x10c>
    a5aa:	4249      	negs	r1, r1
    a5ac:	1003      	asrs	r3, r0, #32
    a5ae:	d300      	bcc.n	a5b2 <__aeabi_idiv+0x112>
    a5b0:	4240      	negs	r0, r0
    a5b2:	4053      	eors	r3, r2
    a5b4:	2200      	movs	r2, #0
    a5b6:	469c      	mov	ip, r3
    a5b8:	0903      	lsrs	r3, r0, #4
    a5ba:	428b      	cmp	r3, r1
    a5bc:	d32d      	bcc.n	a61a <__aeabi_idiv+0x17a>
    a5be:	0a03      	lsrs	r3, r0, #8
    a5c0:	428b      	cmp	r3, r1
    a5c2:	d312      	bcc.n	a5ea <__aeabi_idiv+0x14a>
    a5c4:	22fc      	movs	r2, #252	; 0xfc
    a5c6:	0189      	lsls	r1, r1, #6
    a5c8:	ba12      	rev	r2, r2
    a5ca:	0a03      	lsrs	r3, r0, #8
    a5cc:	428b      	cmp	r3, r1
    a5ce:	d30c      	bcc.n	a5ea <__aeabi_idiv+0x14a>
    a5d0:	0189      	lsls	r1, r1, #6
    a5d2:	1192      	asrs	r2, r2, #6
    a5d4:	428b      	cmp	r3, r1
    a5d6:	d308      	bcc.n	a5ea <__aeabi_idiv+0x14a>
    a5d8:	0189      	lsls	r1, r1, #6
    a5da:	1192      	asrs	r2, r2, #6
    a5dc:	428b      	cmp	r3, r1
    a5de:	d304      	bcc.n	a5ea <__aeabi_idiv+0x14a>
    a5e0:	0189      	lsls	r1, r1, #6
    a5e2:	d03a      	beq.n	a65a <__aeabi_idiv+0x1ba>
    a5e4:	1192      	asrs	r2, r2, #6
    a5e6:	e000      	b.n	a5ea <__aeabi_idiv+0x14a>
    a5e8:	0989      	lsrs	r1, r1, #6
    a5ea:	09c3      	lsrs	r3, r0, #7
    a5ec:	428b      	cmp	r3, r1
    a5ee:	d301      	bcc.n	a5f4 <__aeabi_idiv+0x154>
    a5f0:	01cb      	lsls	r3, r1, #7
    a5f2:	1ac0      	subs	r0, r0, r3
    a5f4:	4152      	adcs	r2, r2
    a5f6:	0983      	lsrs	r3, r0, #6
    a5f8:	428b      	cmp	r3, r1
    a5fa:	d301      	bcc.n	a600 <__aeabi_idiv+0x160>
    a5fc:	018b      	lsls	r3, r1, #6
    a5fe:	1ac0      	subs	r0, r0, r3
    a600:	4152      	adcs	r2, r2
    a602:	0943      	lsrs	r3, r0, #5
    a604:	428b      	cmp	r3, r1
    a606:	d301      	bcc.n	a60c <__aeabi_idiv+0x16c>
    a608:	014b      	lsls	r3, r1, #5
    a60a:	1ac0      	subs	r0, r0, r3
    a60c:	4152      	adcs	r2, r2
    a60e:	0903      	lsrs	r3, r0, #4
    a610:	428b      	cmp	r3, r1
    a612:	d301      	bcc.n	a618 <__aeabi_idiv+0x178>
    a614:	010b      	lsls	r3, r1, #4
    a616:	1ac0      	subs	r0, r0, r3
    a618:	4152      	adcs	r2, r2
    a61a:	08c3      	lsrs	r3, r0, #3
    a61c:	428b      	cmp	r3, r1
    a61e:	d301      	bcc.n	a624 <__aeabi_idiv+0x184>
    a620:	00cb      	lsls	r3, r1, #3
    a622:	1ac0      	subs	r0, r0, r3
    a624:	4152      	adcs	r2, r2
    a626:	0883      	lsrs	r3, r0, #2
    a628:	428b      	cmp	r3, r1
    a62a:	d301      	bcc.n	a630 <__aeabi_idiv+0x190>
    a62c:	008b      	lsls	r3, r1, #2
    a62e:	1ac0      	subs	r0, r0, r3
    a630:	4152      	adcs	r2, r2
    a632:	d2d9      	bcs.n	a5e8 <__aeabi_idiv+0x148>
    a634:	0843      	lsrs	r3, r0, #1
    a636:	428b      	cmp	r3, r1
    a638:	d301      	bcc.n	a63e <__aeabi_idiv+0x19e>
    a63a:	004b      	lsls	r3, r1, #1
    a63c:	1ac0      	subs	r0, r0, r3
    a63e:	4152      	adcs	r2, r2
    a640:	1a41      	subs	r1, r0, r1
    a642:	d200      	bcs.n	a646 <__aeabi_idiv+0x1a6>
    a644:	4601      	mov	r1, r0
    a646:	4663      	mov	r3, ip
    a648:	4152      	adcs	r2, r2
    a64a:	105b      	asrs	r3, r3, #1
    a64c:	4610      	mov	r0, r2
    a64e:	d301      	bcc.n	a654 <__aeabi_idiv+0x1b4>
    a650:	4240      	negs	r0, r0
    a652:	2b00      	cmp	r3, #0
    a654:	d500      	bpl.n	a658 <__aeabi_idiv+0x1b8>
    a656:	4249      	negs	r1, r1
    a658:	4770      	bx	lr
    a65a:	4663      	mov	r3, ip
    a65c:	105b      	asrs	r3, r3, #1
    a65e:	d300      	bcc.n	a662 <__aeabi_idiv+0x1c2>
    a660:	4240      	negs	r0, r0
    a662:	b501      	push	{r0, lr}
    a664:	2000      	movs	r0, #0
    a666:	f000 f805 	bl	a674 <__aeabi_idiv0>
    a66a:	bd02      	pop	{r1, pc}

0000a66c <__aeabi_idivmod>:
    a66c:	2900      	cmp	r1, #0
    a66e:	d0f8      	beq.n	a662 <__aeabi_idiv+0x1c2>
    a670:	e716      	b.n	a4a0 <__aeabi_idiv>
    a672:	4770      	bx	lr

0000a674 <__aeabi_idiv0>:
    a674:	4770      	bx	lr
    a676:	46c0      	nop			; (mov r8, r8)

0000a678 <__aeabi_llsr>:
    a678:	40d0      	lsrs	r0, r2
    a67a:	1c0b      	adds	r3, r1, #0
    a67c:	40d1      	lsrs	r1, r2
    a67e:	469c      	mov	ip, r3
    a680:	3a20      	subs	r2, #32
    a682:	40d3      	lsrs	r3, r2
    a684:	4318      	orrs	r0, r3
    a686:	4252      	negs	r2, r2
    a688:	4663      	mov	r3, ip
    a68a:	4093      	lsls	r3, r2
    a68c:	4318      	orrs	r0, r3
    a68e:	4770      	bx	lr

0000a690 <__aeabi_llsl>:
    a690:	4091      	lsls	r1, r2
    a692:	1c03      	adds	r3, r0, #0
    a694:	4090      	lsls	r0, r2
    a696:	469c      	mov	ip, r3
    a698:	3a20      	subs	r2, #32
    a69a:	4093      	lsls	r3, r2
    a69c:	4319      	orrs	r1, r3
    a69e:	4252      	negs	r2, r2
    a6a0:	4663      	mov	r3, ip
    a6a2:	40d3      	lsrs	r3, r2
    a6a4:	4319      	orrs	r1, r3
    a6a6:	4770      	bx	lr

0000a6a8 <__aeabi_lmul>:
    a6a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    a6aa:	464f      	mov	r7, r9
    a6ac:	4646      	mov	r6, r8
    a6ae:	b4c0      	push	{r6, r7}
    a6b0:	0416      	lsls	r6, r2, #16
    a6b2:	0c36      	lsrs	r6, r6, #16
    a6b4:	4699      	mov	r9, r3
    a6b6:	0033      	movs	r3, r6
    a6b8:	0405      	lsls	r5, r0, #16
    a6ba:	0c2c      	lsrs	r4, r5, #16
    a6bc:	0c07      	lsrs	r7, r0, #16
    a6be:	0c15      	lsrs	r5, r2, #16
    a6c0:	4363      	muls	r3, r4
    a6c2:	437e      	muls	r6, r7
    a6c4:	436f      	muls	r7, r5
    a6c6:	4365      	muls	r5, r4
    a6c8:	0c1c      	lsrs	r4, r3, #16
    a6ca:	19ad      	adds	r5, r5, r6
    a6cc:	1964      	adds	r4, r4, r5
    a6ce:	469c      	mov	ip, r3
    a6d0:	42a6      	cmp	r6, r4
    a6d2:	d903      	bls.n	a6dc <__aeabi_lmul+0x34>
    a6d4:	2380      	movs	r3, #128	; 0x80
    a6d6:	025b      	lsls	r3, r3, #9
    a6d8:	4698      	mov	r8, r3
    a6da:	4447      	add	r7, r8
    a6dc:	4663      	mov	r3, ip
    a6de:	0c25      	lsrs	r5, r4, #16
    a6e0:	19ef      	adds	r7, r5, r7
    a6e2:	041d      	lsls	r5, r3, #16
    a6e4:	464b      	mov	r3, r9
    a6e6:	434a      	muls	r2, r1
    a6e8:	4343      	muls	r3, r0
    a6ea:	0c2d      	lsrs	r5, r5, #16
    a6ec:	0424      	lsls	r4, r4, #16
    a6ee:	1964      	adds	r4, r4, r5
    a6f0:	1899      	adds	r1, r3, r2
    a6f2:	19c9      	adds	r1, r1, r7
    a6f4:	0020      	movs	r0, r4
    a6f6:	bc0c      	pop	{r2, r3}
    a6f8:	4690      	mov	r8, r2
    a6fa:	4699      	mov	r9, r3
    a6fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a6fe:	46c0      	nop			; (mov r8, r8)

0000a700 <__libc_init_array>:
    a700:	4b0e      	ldr	r3, [pc, #56]	; (a73c <__libc_init_array+0x3c>)
    a702:	b570      	push	{r4, r5, r6, lr}
    a704:	2500      	movs	r5, #0
    a706:	001e      	movs	r6, r3
    a708:	4c0d      	ldr	r4, [pc, #52]	; (a740 <__libc_init_array+0x40>)
    a70a:	1ae4      	subs	r4, r4, r3
    a70c:	10a4      	asrs	r4, r4, #2
    a70e:	42a5      	cmp	r5, r4
    a710:	d004      	beq.n	a71c <__libc_init_array+0x1c>
    a712:	00ab      	lsls	r3, r5, #2
    a714:	58f3      	ldr	r3, [r6, r3]
    a716:	4798      	blx	r3
    a718:	3501      	adds	r5, #1
    a71a:	e7f8      	b.n	a70e <__libc_init_array+0xe>
    a71c:	f009 f840 	bl	137a0 <_init>
    a720:	4b08      	ldr	r3, [pc, #32]	; (a744 <__libc_init_array+0x44>)
    a722:	2500      	movs	r5, #0
    a724:	001e      	movs	r6, r3
    a726:	4c08      	ldr	r4, [pc, #32]	; (a748 <__libc_init_array+0x48>)
    a728:	1ae4      	subs	r4, r4, r3
    a72a:	10a4      	asrs	r4, r4, #2
    a72c:	42a5      	cmp	r5, r4
    a72e:	d004      	beq.n	a73a <__libc_init_array+0x3a>
    a730:	00ab      	lsls	r3, r5, #2
    a732:	58f3      	ldr	r3, [r6, r3]
    a734:	4798      	blx	r3
    a736:	3501      	adds	r5, #1
    a738:	e7f8      	b.n	a72c <__libc_init_array+0x2c>
    a73a:	bd70      	pop	{r4, r5, r6, pc}
    a73c:	000137ac 	.word	0x000137ac
    a740:	000137ac 	.word	0x000137ac
    a744:	000137ac 	.word	0x000137ac
    a748:	000137b0 	.word	0x000137b0

0000a74c <memcpy>:
    a74c:	2300      	movs	r3, #0
    a74e:	b510      	push	{r4, lr}
    a750:	429a      	cmp	r2, r3
    a752:	d003      	beq.n	a75c <memcpy+0x10>
    a754:	5ccc      	ldrb	r4, [r1, r3]
    a756:	54c4      	strb	r4, [r0, r3]
    a758:	3301      	adds	r3, #1
    a75a:	e7f9      	b.n	a750 <memcpy+0x4>
    a75c:	bd10      	pop	{r4, pc}

0000a75e <memset>:
    a75e:	0003      	movs	r3, r0
    a760:	1882      	adds	r2, r0, r2
    a762:	4293      	cmp	r3, r2
    a764:	d002      	beq.n	a76c <memset+0xe>
    a766:	7019      	strb	r1, [r3, #0]
    a768:	3301      	adds	r3, #1
    a76a:	e7fa      	b.n	a762 <memset+0x4>
    a76c:	4770      	bx	lr
	...

0000a770 <iprintf>:
    a770:	b40f      	push	{r0, r1, r2, r3}
    a772:	4b0b      	ldr	r3, [pc, #44]	; (a7a0 <iprintf+0x30>)
    a774:	b513      	push	{r0, r1, r4, lr}
    a776:	681c      	ldr	r4, [r3, #0]
    a778:	2c00      	cmp	r4, #0
    a77a:	d005      	beq.n	a788 <iprintf+0x18>
    a77c:	69a3      	ldr	r3, [r4, #24]
    a77e:	2b00      	cmp	r3, #0
    a780:	d102      	bne.n	a788 <iprintf+0x18>
    a782:	0020      	movs	r0, r4
    a784:	f000 fb0a 	bl	ad9c <__sinit>
    a788:	ab05      	add	r3, sp, #20
    a78a:	9a04      	ldr	r2, [sp, #16]
    a78c:	68a1      	ldr	r1, [r4, #8]
    a78e:	0020      	movs	r0, r4
    a790:	9301      	str	r3, [sp, #4]
    a792:	f000 fcc9 	bl	b128 <_vfiprintf_r>
    a796:	bc16      	pop	{r1, r2, r4}
    a798:	bc08      	pop	{r3}
    a79a:	b004      	add	sp, #16
    a79c:	4718      	bx	r3
    a79e:	46c0      	nop			; (mov r8, r8)
    a7a0:	20000130 	.word	0x20000130

0000a7a4 <putchar>:
    a7a4:	4b08      	ldr	r3, [pc, #32]	; (a7c8 <putchar+0x24>)
    a7a6:	b570      	push	{r4, r5, r6, lr}
    a7a8:	681c      	ldr	r4, [r3, #0]
    a7aa:	0005      	movs	r5, r0
    a7ac:	2c00      	cmp	r4, #0
    a7ae:	d005      	beq.n	a7bc <putchar+0x18>
    a7b0:	69a3      	ldr	r3, [r4, #24]
    a7b2:	2b00      	cmp	r3, #0
    a7b4:	d102      	bne.n	a7bc <putchar+0x18>
    a7b6:	0020      	movs	r0, r4
    a7b8:	f000 faf0 	bl	ad9c <__sinit>
    a7bc:	0029      	movs	r1, r5
    a7be:	68a2      	ldr	r2, [r4, #8]
    a7c0:	0020      	movs	r0, r4
    a7c2:	f000 ff5d 	bl	b680 <_putc_r>
    a7c6:	bd70      	pop	{r4, r5, r6, pc}
    a7c8:	20000130 	.word	0x20000130

0000a7cc <_puts_r>:
    a7cc:	b570      	push	{r4, r5, r6, lr}
    a7ce:	0005      	movs	r5, r0
    a7d0:	000e      	movs	r6, r1
    a7d2:	2800      	cmp	r0, #0
    a7d4:	d004      	beq.n	a7e0 <_puts_r+0x14>
    a7d6:	6983      	ldr	r3, [r0, #24]
    a7d8:	2b00      	cmp	r3, #0
    a7da:	d101      	bne.n	a7e0 <_puts_r+0x14>
    a7dc:	f000 fade 	bl	ad9c <__sinit>
    a7e0:	69ab      	ldr	r3, [r5, #24]
    a7e2:	68ac      	ldr	r4, [r5, #8]
    a7e4:	2b00      	cmp	r3, #0
    a7e6:	d102      	bne.n	a7ee <_puts_r+0x22>
    a7e8:	0028      	movs	r0, r5
    a7ea:	f000 fad7 	bl	ad9c <__sinit>
    a7ee:	4b25      	ldr	r3, [pc, #148]	; (a884 <_puts_r+0xb8>)
    a7f0:	429c      	cmp	r4, r3
    a7f2:	d101      	bne.n	a7f8 <_puts_r+0x2c>
    a7f4:	686c      	ldr	r4, [r5, #4]
    a7f6:	e008      	b.n	a80a <_puts_r+0x3e>
    a7f8:	4b23      	ldr	r3, [pc, #140]	; (a888 <_puts_r+0xbc>)
    a7fa:	429c      	cmp	r4, r3
    a7fc:	d101      	bne.n	a802 <_puts_r+0x36>
    a7fe:	68ac      	ldr	r4, [r5, #8]
    a800:	e003      	b.n	a80a <_puts_r+0x3e>
    a802:	4b22      	ldr	r3, [pc, #136]	; (a88c <_puts_r+0xc0>)
    a804:	429c      	cmp	r4, r3
    a806:	d100      	bne.n	a80a <_puts_r+0x3e>
    a808:	68ec      	ldr	r4, [r5, #12]
    a80a:	89a3      	ldrh	r3, [r4, #12]
    a80c:	071b      	lsls	r3, r3, #28
    a80e:	d502      	bpl.n	a816 <_puts_r+0x4a>
    a810:	6923      	ldr	r3, [r4, #16]
    a812:	2b00      	cmp	r3, #0
    a814:	d111      	bne.n	a83a <_puts_r+0x6e>
    a816:	0021      	movs	r1, r4
    a818:	0028      	movs	r0, r5
    a81a:	f000 f955 	bl	aac8 <__swsetup_r>
    a81e:	2800      	cmp	r0, #0
    a820:	d00b      	beq.n	a83a <_puts_r+0x6e>
    a822:	2001      	movs	r0, #1
    a824:	4240      	negs	r0, r0
    a826:	e02b      	b.n	a880 <_puts_r+0xb4>
    a828:	3b01      	subs	r3, #1
    a82a:	3601      	adds	r6, #1
    a82c:	60a3      	str	r3, [r4, #8]
    a82e:	2b00      	cmp	r3, #0
    a830:	db08      	blt.n	a844 <_puts_r+0x78>
    a832:	6823      	ldr	r3, [r4, #0]
    a834:	1c5a      	adds	r2, r3, #1
    a836:	6022      	str	r2, [r4, #0]
    a838:	7019      	strb	r1, [r3, #0]
    a83a:	7831      	ldrb	r1, [r6, #0]
    a83c:	68a3      	ldr	r3, [r4, #8]
    a83e:	2900      	cmp	r1, #0
    a840:	d1f2      	bne.n	a828 <_puts_r+0x5c>
    a842:	e00b      	b.n	a85c <_puts_r+0x90>
    a844:	69a2      	ldr	r2, [r4, #24]
    a846:	4293      	cmp	r3, r2
    a848:	db01      	blt.n	a84e <_puts_r+0x82>
    a84a:	290a      	cmp	r1, #10
    a84c:	d1f1      	bne.n	a832 <_puts_r+0x66>
    a84e:	0022      	movs	r2, r4
    a850:	0028      	movs	r0, r5
    a852:	f000 f8e1 	bl	aa18 <__swbuf_r>
    a856:	1c43      	adds	r3, r0, #1
    a858:	d1ef      	bne.n	a83a <_puts_r+0x6e>
    a85a:	e7e2      	b.n	a822 <_puts_r+0x56>
    a85c:	3b01      	subs	r3, #1
    a85e:	60a3      	str	r3, [r4, #8]
    a860:	2b00      	cmp	r3, #0
    a862:	da08      	bge.n	a876 <_puts_r+0xaa>
    a864:	0022      	movs	r2, r4
    a866:	310a      	adds	r1, #10
    a868:	0028      	movs	r0, r5
    a86a:	f000 f8d5 	bl	aa18 <__swbuf_r>
    a86e:	1c43      	adds	r3, r0, #1
    a870:	d0d7      	beq.n	a822 <_puts_r+0x56>
    a872:	200a      	movs	r0, #10
    a874:	e004      	b.n	a880 <_puts_r+0xb4>
    a876:	200a      	movs	r0, #10
    a878:	6823      	ldr	r3, [r4, #0]
    a87a:	1c5a      	adds	r2, r3, #1
    a87c:	6022      	str	r2, [r4, #0]
    a87e:	7018      	strb	r0, [r3, #0]
    a880:	bd70      	pop	{r4, r5, r6, pc}
    a882:	46c0      	nop			; (mov r8, r8)
    a884:	0001370c 	.word	0x0001370c
    a888:	0001372c 	.word	0x0001372c
    a88c:	0001374c 	.word	0x0001374c

0000a890 <puts>:
    a890:	b510      	push	{r4, lr}
    a892:	4b03      	ldr	r3, [pc, #12]	; (a8a0 <puts+0x10>)
    a894:	0001      	movs	r1, r0
    a896:	6818      	ldr	r0, [r3, #0]
    a898:	f7ff ff98 	bl	a7cc <_puts_r>
    a89c:	bd10      	pop	{r4, pc}
    a89e:	46c0      	nop			; (mov r8, r8)
    a8a0:	20000130 	.word	0x20000130

0000a8a4 <setbuf>:
    a8a4:	424a      	negs	r2, r1
    a8a6:	414a      	adcs	r2, r1
    a8a8:	2380      	movs	r3, #128	; 0x80
    a8aa:	b510      	push	{r4, lr}
    a8ac:	0052      	lsls	r2, r2, #1
    a8ae:	00db      	lsls	r3, r3, #3
    a8b0:	f000 f802 	bl	a8b8 <setvbuf>
    a8b4:	bd10      	pop	{r4, pc}
	...

0000a8b8 <setvbuf>:
    a8b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    a8ba:	001d      	movs	r5, r3
    a8bc:	4b51      	ldr	r3, [pc, #324]	; (aa04 <setvbuf+0x14c>)
    a8be:	b085      	sub	sp, #20
    a8c0:	681e      	ldr	r6, [r3, #0]
    a8c2:	0004      	movs	r4, r0
    a8c4:	000f      	movs	r7, r1
    a8c6:	9200      	str	r2, [sp, #0]
    a8c8:	2e00      	cmp	r6, #0
    a8ca:	d005      	beq.n	a8d8 <setvbuf+0x20>
    a8cc:	69b3      	ldr	r3, [r6, #24]
    a8ce:	2b00      	cmp	r3, #0
    a8d0:	d102      	bne.n	a8d8 <setvbuf+0x20>
    a8d2:	0030      	movs	r0, r6
    a8d4:	f000 fa62 	bl	ad9c <__sinit>
    a8d8:	4b4b      	ldr	r3, [pc, #300]	; (aa08 <setvbuf+0x150>)
    a8da:	429c      	cmp	r4, r3
    a8dc:	d101      	bne.n	a8e2 <setvbuf+0x2a>
    a8de:	6874      	ldr	r4, [r6, #4]
    a8e0:	e008      	b.n	a8f4 <setvbuf+0x3c>
    a8e2:	4b4a      	ldr	r3, [pc, #296]	; (aa0c <setvbuf+0x154>)
    a8e4:	429c      	cmp	r4, r3
    a8e6:	d101      	bne.n	a8ec <setvbuf+0x34>
    a8e8:	68b4      	ldr	r4, [r6, #8]
    a8ea:	e003      	b.n	a8f4 <setvbuf+0x3c>
    a8ec:	4b48      	ldr	r3, [pc, #288]	; (aa10 <setvbuf+0x158>)
    a8ee:	429c      	cmp	r4, r3
    a8f0:	d100      	bne.n	a8f4 <setvbuf+0x3c>
    a8f2:	68f4      	ldr	r4, [r6, #12]
    a8f4:	9b00      	ldr	r3, [sp, #0]
    a8f6:	2b02      	cmp	r3, #2
    a8f8:	d005      	beq.n	a906 <setvbuf+0x4e>
    a8fa:	2b01      	cmp	r3, #1
    a8fc:	d900      	bls.n	a900 <setvbuf+0x48>
    a8fe:	e07c      	b.n	a9fa <setvbuf+0x142>
    a900:	2d00      	cmp	r5, #0
    a902:	da00      	bge.n	a906 <setvbuf+0x4e>
    a904:	e079      	b.n	a9fa <setvbuf+0x142>
    a906:	0021      	movs	r1, r4
    a908:	0030      	movs	r0, r6
    a90a:	f000 f9d9 	bl	acc0 <_fflush_r>
    a90e:	6b61      	ldr	r1, [r4, #52]	; 0x34
    a910:	2900      	cmp	r1, #0
    a912:	d008      	beq.n	a926 <setvbuf+0x6e>
    a914:	0023      	movs	r3, r4
    a916:	3344      	adds	r3, #68	; 0x44
    a918:	4299      	cmp	r1, r3
    a91a:	d002      	beq.n	a922 <setvbuf+0x6a>
    a91c:	0030      	movs	r0, r6
    a91e:	f000 fb3f 	bl	afa0 <_free_r>
    a922:	2300      	movs	r3, #0
    a924:	6363      	str	r3, [r4, #52]	; 0x34
    a926:	2300      	movs	r3, #0
    a928:	61a3      	str	r3, [r4, #24]
    a92a:	6063      	str	r3, [r4, #4]
    a92c:	89a3      	ldrh	r3, [r4, #12]
    a92e:	061b      	lsls	r3, r3, #24
    a930:	d503      	bpl.n	a93a <setvbuf+0x82>
    a932:	6921      	ldr	r1, [r4, #16]
    a934:	0030      	movs	r0, r6
    a936:	f000 fb33 	bl	afa0 <_free_r>
    a93a:	89a2      	ldrh	r2, [r4, #12]
    a93c:	4b35      	ldr	r3, [pc, #212]	; (aa14 <setvbuf+0x15c>)
    a93e:	4013      	ands	r3, r2
    a940:	81a3      	strh	r3, [r4, #12]
    a942:	9b00      	ldr	r3, [sp, #0]
    a944:	2b02      	cmp	r3, #2
    a946:	d021      	beq.n	a98c <setvbuf+0xd4>
    a948:	ab03      	add	r3, sp, #12
    a94a:	aa02      	add	r2, sp, #8
    a94c:	0021      	movs	r1, r4
    a94e:	0030      	movs	r0, r6
    a950:	f000 fab8 	bl	aec4 <__swhatbuf_r>
    a954:	89a3      	ldrh	r3, [r4, #12]
    a956:	4318      	orrs	r0, r3
    a958:	81a0      	strh	r0, [r4, #12]
    a95a:	2d00      	cmp	r5, #0
    a95c:	d101      	bne.n	a962 <setvbuf+0xaa>
    a95e:	9d02      	ldr	r5, [sp, #8]
    a960:	e001      	b.n	a966 <setvbuf+0xae>
    a962:	2f00      	cmp	r7, #0
    a964:	d125      	bne.n	a9b2 <setvbuf+0xfa>
    a966:	0028      	movs	r0, r5
    a968:	f000 fb10 	bl	af8c <malloc>
    a96c:	9501      	str	r5, [sp, #4]
    a96e:	1e07      	subs	r7, r0, #0
    a970:	d11a      	bne.n	a9a8 <setvbuf+0xf0>
    a972:	9b02      	ldr	r3, [sp, #8]
    a974:	9301      	str	r3, [sp, #4]
    a976:	42ab      	cmp	r3, r5
    a978:	d102      	bne.n	a980 <setvbuf+0xc8>
    a97a:	2001      	movs	r0, #1
    a97c:	4240      	negs	r0, r0
    a97e:	e006      	b.n	a98e <setvbuf+0xd6>
    a980:	9801      	ldr	r0, [sp, #4]
    a982:	f000 fb03 	bl	af8c <malloc>
    a986:	1e07      	subs	r7, r0, #0
    a988:	d10e      	bne.n	a9a8 <setvbuf+0xf0>
    a98a:	e7f6      	b.n	a97a <setvbuf+0xc2>
    a98c:	2000      	movs	r0, #0
    a98e:	2202      	movs	r2, #2
    a990:	89a3      	ldrh	r3, [r4, #12]
    a992:	4313      	orrs	r3, r2
    a994:	81a3      	strh	r3, [r4, #12]
    a996:	2300      	movs	r3, #0
    a998:	60a3      	str	r3, [r4, #8]
    a99a:	0023      	movs	r3, r4
    a99c:	3347      	adds	r3, #71	; 0x47
    a99e:	6023      	str	r3, [r4, #0]
    a9a0:	6123      	str	r3, [r4, #16]
    a9a2:	2301      	movs	r3, #1
    a9a4:	6163      	str	r3, [r4, #20]
    a9a6:	e02a      	b.n	a9fe <setvbuf+0x146>
    a9a8:	2280      	movs	r2, #128	; 0x80
    a9aa:	89a3      	ldrh	r3, [r4, #12]
    a9ac:	9d01      	ldr	r5, [sp, #4]
    a9ae:	4313      	orrs	r3, r2
    a9b0:	81a3      	strh	r3, [r4, #12]
    a9b2:	69b3      	ldr	r3, [r6, #24]
    a9b4:	2b00      	cmp	r3, #0
    a9b6:	d102      	bne.n	a9be <setvbuf+0x106>
    a9b8:	0030      	movs	r0, r6
    a9ba:	f000 f9ef 	bl	ad9c <__sinit>
    a9be:	9b00      	ldr	r3, [sp, #0]
    a9c0:	2b01      	cmp	r3, #1
    a9c2:	d103      	bne.n	a9cc <setvbuf+0x114>
    a9c4:	89a3      	ldrh	r3, [r4, #12]
    a9c6:	9a00      	ldr	r2, [sp, #0]
    a9c8:	431a      	orrs	r2, r3
    a9ca:	81a2      	strh	r2, [r4, #12]
    a9cc:	2308      	movs	r3, #8
    a9ce:	89a2      	ldrh	r2, [r4, #12]
    a9d0:	6027      	str	r7, [r4, #0]
    a9d2:	4013      	ands	r3, r2
    a9d4:	6127      	str	r7, [r4, #16]
    a9d6:	6165      	str	r5, [r4, #20]
    a9d8:	1e18      	subs	r0, r3, #0
    a9da:	d00c      	beq.n	a9f6 <setvbuf+0x13e>
    a9dc:	2301      	movs	r3, #1
    a9de:	401a      	ands	r2, r3
    a9e0:	2300      	movs	r3, #0
    a9e2:	1e10      	subs	r0, r2, #0
    a9e4:	4298      	cmp	r0, r3
    a9e6:	d004      	beq.n	a9f2 <setvbuf+0x13a>
    a9e8:	426d      	negs	r5, r5
    a9ea:	60a3      	str	r3, [r4, #8]
    a9ec:	61a5      	str	r5, [r4, #24]
    a9ee:	0018      	movs	r0, r3
    a9f0:	e005      	b.n	a9fe <setvbuf+0x146>
    a9f2:	60a5      	str	r5, [r4, #8]
    a9f4:	e003      	b.n	a9fe <setvbuf+0x146>
    a9f6:	60a3      	str	r3, [r4, #8]
    a9f8:	e001      	b.n	a9fe <setvbuf+0x146>
    a9fa:	2001      	movs	r0, #1
    a9fc:	4240      	negs	r0, r0
    a9fe:	b005      	add	sp, #20
    aa00:	bdf0      	pop	{r4, r5, r6, r7, pc}
    aa02:	46c0      	nop			; (mov r8, r8)
    aa04:	20000130 	.word	0x20000130
    aa08:	0001370c 	.word	0x0001370c
    aa0c:	0001372c 	.word	0x0001372c
    aa10:	0001374c 	.word	0x0001374c
    aa14:	fffff35c 	.word	0xfffff35c

0000aa18 <__swbuf_r>:
    aa18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    aa1a:	0005      	movs	r5, r0
    aa1c:	000f      	movs	r7, r1
    aa1e:	0014      	movs	r4, r2
    aa20:	2800      	cmp	r0, #0
    aa22:	d004      	beq.n	aa2e <__swbuf_r+0x16>
    aa24:	6983      	ldr	r3, [r0, #24]
    aa26:	2b00      	cmp	r3, #0
    aa28:	d101      	bne.n	aa2e <__swbuf_r+0x16>
    aa2a:	f000 f9b7 	bl	ad9c <__sinit>
    aa2e:	4b23      	ldr	r3, [pc, #140]	; (aabc <__swbuf_r+0xa4>)
    aa30:	429c      	cmp	r4, r3
    aa32:	d101      	bne.n	aa38 <__swbuf_r+0x20>
    aa34:	686c      	ldr	r4, [r5, #4]
    aa36:	e008      	b.n	aa4a <__swbuf_r+0x32>
    aa38:	4b21      	ldr	r3, [pc, #132]	; (aac0 <__swbuf_r+0xa8>)
    aa3a:	429c      	cmp	r4, r3
    aa3c:	d101      	bne.n	aa42 <__swbuf_r+0x2a>
    aa3e:	68ac      	ldr	r4, [r5, #8]
    aa40:	e003      	b.n	aa4a <__swbuf_r+0x32>
    aa42:	4b20      	ldr	r3, [pc, #128]	; (aac4 <__swbuf_r+0xac>)
    aa44:	429c      	cmp	r4, r3
    aa46:	d100      	bne.n	aa4a <__swbuf_r+0x32>
    aa48:	68ec      	ldr	r4, [r5, #12]
    aa4a:	69a3      	ldr	r3, [r4, #24]
    aa4c:	60a3      	str	r3, [r4, #8]
    aa4e:	89a3      	ldrh	r3, [r4, #12]
    aa50:	071b      	lsls	r3, r3, #28
    aa52:	d50a      	bpl.n	aa6a <__swbuf_r+0x52>
    aa54:	6923      	ldr	r3, [r4, #16]
    aa56:	2b00      	cmp	r3, #0
    aa58:	d007      	beq.n	aa6a <__swbuf_r+0x52>
    aa5a:	6823      	ldr	r3, [r4, #0]
    aa5c:	6922      	ldr	r2, [r4, #16]
    aa5e:	b2fe      	uxtb	r6, r7
    aa60:	1a98      	subs	r0, r3, r2
    aa62:	6963      	ldr	r3, [r4, #20]
    aa64:	4298      	cmp	r0, r3
    aa66:	db0f      	blt.n	aa88 <__swbuf_r+0x70>
    aa68:	e008      	b.n	aa7c <__swbuf_r+0x64>
    aa6a:	0021      	movs	r1, r4
    aa6c:	0028      	movs	r0, r5
    aa6e:	f000 f82b 	bl	aac8 <__swsetup_r>
    aa72:	2800      	cmp	r0, #0
    aa74:	d0f1      	beq.n	aa5a <__swbuf_r+0x42>
    aa76:	2001      	movs	r0, #1
    aa78:	4240      	negs	r0, r0
    aa7a:	e01d      	b.n	aab8 <__swbuf_r+0xa0>
    aa7c:	0021      	movs	r1, r4
    aa7e:	0028      	movs	r0, r5
    aa80:	f000 f91e 	bl	acc0 <_fflush_r>
    aa84:	2800      	cmp	r0, #0
    aa86:	d1f6      	bne.n	aa76 <__swbuf_r+0x5e>
    aa88:	68a3      	ldr	r3, [r4, #8]
    aa8a:	3001      	adds	r0, #1
    aa8c:	3b01      	subs	r3, #1
    aa8e:	60a3      	str	r3, [r4, #8]
    aa90:	6823      	ldr	r3, [r4, #0]
    aa92:	1c5a      	adds	r2, r3, #1
    aa94:	6022      	str	r2, [r4, #0]
    aa96:	701f      	strb	r7, [r3, #0]
    aa98:	6963      	ldr	r3, [r4, #20]
    aa9a:	4298      	cmp	r0, r3
    aa9c:	d005      	beq.n	aaaa <__swbuf_r+0x92>
    aa9e:	89a3      	ldrh	r3, [r4, #12]
    aaa0:	0030      	movs	r0, r6
    aaa2:	07db      	lsls	r3, r3, #31
    aaa4:	d508      	bpl.n	aab8 <__swbuf_r+0xa0>
    aaa6:	2e0a      	cmp	r6, #10
    aaa8:	d106      	bne.n	aab8 <__swbuf_r+0xa0>
    aaaa:	0021      	movs	r1, r4
    aaac:	0028      	movs	r0, r5
    aaae:	f000 f907 	bl	acc0 <_fflush_r>
    aab2:	2800      	cmp	r0, #0
    aab4:	d1df      	bne.n	aa76 <__swbuf_r+0x5e>
    aab6:	0030      	movs	r0, r6
    aab8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    aaba:	46c0      	nop			; (mov r8, r8)
    aabc:	0001370c 	.word	0x0001370c
    aac0:	0001372c 	.word	0x0001372c
    aac4:	0001374c 	.word	0x0001374c

0000aac8 <__swsetup_r>:
    aac8:	4b36      	ldr	r3, [pc, #216]	; (aba4 <__swsetup_r+0xdc>)
    aaca:	b570      	push	{r4, r5, r6, lr}
    aacc:	681d      	ldr	r5, [r3, #0]
    aace:	0006      	movs	r6, r0
    aad0:	000c      	movs	r4, r1
    aad2:	2d00      	cmp	r5, #0
    aad4:	d005      	beq.n	aae2 <__swsetup_r+0x1a>
    aad6:	69ab      	ldr	r3, [r5, #24]
    aad8:	2b00      	cmp	r3, #0
    aada:	d102      	bne.n	aae2 <__swsetup_r+0x1a>
    aadc:	0028      	movs	r0, r5
    aade:	f000 f95d 	bl	ad9c <__sinit>
    aae2:	4b31      	ldr	r3, [pc, #196]	; (aba8 <__swsetup_r+0xe0>)
    aae4:	429c      	cmp	r4, r3
    aae6:	d101      	bne.n	aaec <__swsetup_r+0x24>
    aae8:	686c      	ldr	r4, [r5, #4]
    aaea:	e008      	b.n	aafe <__swsetup_r+0x36>
    aaec:	4b2f      	ldr	r3, [pc, #188]	; (abac <__swsetup_r+0xe4>)
    aaee:	429c      	cmp	r4, r3
    aaf0:	d101      	bne.n	aaf6 <__swsetup_r+0x2e>
    aaf2:	68ac      	ldr	r4, [r5, #8]
    aaf4:	e003      	b.n	aafe <__swsetup_r+0x36>
    aaf6:	4b2e      	ldr	r3, [pc, #184]	; (abb0 <__swsetup_r+0xe8>)
    aaf8:	429c      	cmp	r4, r3
    aafa:	d100      	bne.n	aafe <__swsetup_r+0x36>
    aafc:	68ec      	ldr	r4, [r5, #12]
    aafe:	220c      	movs	r2, #12
    ab00:	5ea3      	ldrsh	r3, [r4, r2]
    ab02:	b29a      	uxth	r2, r3
    ab04:	0711      	lsls	r1, r2, #28
    ab06:	d423      	bmi.n	ab50 <__swsetup_r+0x88>
    ab08:	06d1      	lsls	r1, r2, #27
    ab0a:	d407      	bmi.n	ab1c <__swsetup_r+0x54>
    ab0c:	2209      	movs	r2, #9
    ab0e:	2001      	movs	r0, #1
    ab10:	6032      	str	r2, [r6, #0]
    ab12:	3237      	adds	r2, #55	; 0x37
    ab14:	4313      	orrs	r3, r2
    ab16:	81a3      	strh	r3, [r4, #12]
    ab18:	4240      	negs	r0, r0
    ab1a:	e042      	b.n	aba2 <__swsetup_r+0xda>
    ab1c:	0753      	lsls	r3, r2, #29
    ab1e:	d513      	bpl.n	ab48 <__swsetup_r+0x80>
    ab20:	6b61      	ldr	r1, [r4, #52]	; 0x34
    ab22:	2900      	cmp	r1, #0
    ab24:	d008      	beq.n	ab38 <__swsetup_r+0x70>
    ab26:	0023      	movs	r3, r4
    ab28:	3344      	adds	r3, #68	; 0x44
    ab2a:	4299      	cmp	r1, r3
    ab2c:	d002      	beq.n	ab34 <__swsetup_r+0x6c>
    ab2e:	0030      	movs	r0, r6
    ab30:	f000 fa36 	bl	afa0 <_free_r>
    ab34:	2300      	movs	r3, #0
    ab36:	6363      	str	r3, [r4, #52]	; 0x34
    ab38:	2224      	movs	r2, #36	; 0x24
    ab3a:	89a3      	ldrh	r3, [r4, #12]
    ab3c:	4393      	bics	r3, r2
    ab3e:	81a3      	strh	r3, [r4, #12]
    ab40:	2300      	movs	r3, #0
    ab42:	6063      	str	r3, [r4, #4]
    ab44:	6923      	ldr	r3, [r4, #16]
    ab46:	6023      	str	r3, [r4, #0]
    ab48:	2208      	movs	r2, #8
    ab4a:	89a3      	ldrh	r3, [r4, #12]
    ab4c:	4313      	orrs	r3, r2
    ab4e:	81a3      	strh	r3, [r4, #12]
    ab50:	6923      	ldr	r3, [r4, #16]
    ab52:	2b00      	cmp	r3, #0
    ab54:	d10b      	bne.n	ab6e <__swsetup_r+0xa6>
    ab56:	23a0      	movs	r3, #160	; 0xa0
    ab58:	89a2      	ldrh	r2, [r4, #12]
    ab5a:	009b      	lsls	r3, r3, #2
    ab5c:	4013      	ands	r3, r2
    ab5e:	2280      	movs	r2, #128	; 0x80
    ab60:	0092      	lsls	r2, r2, #2
    ab62:	4293      	cmp	r3, r2
    ab64:	d003      	beq.n	ab6e <__swsetup_r+0xa6>
    ab66:	0021      	movs	r1, r4
    ab68:	0030      	movs	r0, r6
    ab6a:	f000 f9d1 	bl	af10 <__smakebuf_r>
    ab6e:	2301      	movs	r3, #1
    ab70:	89a2      	ldrh	r2, [r4, #12]
    ab72:	4013      	ands	r3, r2
    ab74:	d005      	beq.n	ab82 <__swsetup_r+0xba>
    ab76:	2300      	movs	r3, #0
    ab78:	60a3      	str	r3, [r4, #8]
    ab7a:	6963      	ldr	r3, [r4, #20]
    ab7c:	425b      	negs	r3, r3
    ab7e:	61a3      	str	r3, [r4, #24]
    ab80:	e003      	b.n	ab8a <__swsetup_r+0xc2>
    ab82:	0792      	lsls	r2, r2, #30
    ab84:	d400      	bmi.n	ab88 <__swsetup_r+0xc0>
    ab86:	6963      	ldr	r3, [r4, #20]
    ab88:	60a3      	str	r3, [r4, #8]
    ab8a:	2000      	movs	r0, #0
    ab8c:	6923      	ldr	r3, [r4, #16]
    ab8e:	4283      	cmp	r3, r0
    ab90:	d107      	bne.n	aba2 <__swsetup_r+0xda>
    ab92:	220c      	movs	r2, #12
    ab94:	5ea3      	ldrsh	r3, [r4, r2]
    ab96:	061a      	lsls	r2, r3, #24
    ab98:	d503      	bpl.n	aba2 <__swsetup_r+0xda>
    ab9a:	2240      	movs	r2, #64	; 0x40
    ab9c:	4313      	orrs	r3, r2
    ab9e:	81a3      	strh	r3, [r4, #12]
    aba0:	3801      	subs	r0, #1
    aba2:	bd70      	pop	{r4, r5, r6, pc}
    aba4:	20000130 	.word	0x20000130
    aba8:	0001370c 	.word	0x0001370c
    abac:	0001372c 	.word	0x0001372c
    abb0:	0001374c 	.word	0x0001374c

0000abb4 <__sflush_r>:
    abb4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    abb6:	898a      	ldrh	r2, [r1, #12]
    abb8:	0005      	movs	r5, r0
    abba:	000c      	movs	r4, r1
    abbc:	0713      	lsls	r3, r2, #28
    abbe:	d45a      	bmi.n	ac76 <__sflush_r+0xc2>
    abc0:	684b      	ldr	r3, [r1, #4]
    abc2:	2b00      	cmp	r3, #0
    abc4:	dc02      	bgt.n	abcc <__sflush_r+0x18>
    abc6:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    abc8:	2b00      	cmp	r3, #0
    abca:	dd19      	ble.n	ac00 <__sflush_r+0x4c>
    abcc:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    abce:	2f00      	cmp	r7, #0
    abd0:	d016      	beq.n	ac00 <__sflush_r+0x4c>
    abd2:	2300      	movs	r3, #0
    abd4:	682e      	ldr	r6, [r5, #0]
    abd6:	602b      	str	r3, [r5, #0]
    abd8:	2380      	movs	r3, #128	; 0x80
    abda:	015b      	lsls	r3, r3, #5
    abdc:	401a      	ands	r2, r3
    abde:	d001      	beq.n	abe4 <__sflush_r+0x30>
    abe0:	6d60      	ldr	r0, [r4, #84]	; 0x54
    abe2:	e014      	b.n	ac0e <__sflush_r+0x5a>
    abe4:	2301      	movs	r3, #1
    abe6:	6a21      	ldr	r1, [r4, #32]
    abe8:	0028      	movs	r0, r5
    abea:	47b8      	blx	r7
    abec:	1c43      	adds	r3, r0, #1
    abee:	d10e      	bne.n	ac0e <__sflush_r+0x5a>
    abf0:	682b      	ldr	r3, [r5, #0]
    abf2:	2b00      	cmp	r3, #0
    abf4:	d00b      	beq.n	ac0e <__sflush_r+0x5a>
    abf6:	2b1d      	cmp	r3, #29
    abf8:	d001      	beq.n	abfe <__sflush_r+0x4a>
    abfa:	2b16      	cmp	r3, #22
    abfc:	d102      	bne.n	ac04 <__sflush_r+0x50>
    abfe:	602e      	str	r6, [r5, #0]
    ac00:	2000      	movs	r0, #0
    ac02:	e05a      	b.n	acba <__sflush_r+0x106>
    ac04:	2240      	movs	r2, #64	; 0x40
    ac06:	89a3      	ldrh	r3, [r4, #12]
    ac08:	4313      	orrs	r3, r2
    ac0a:	81a3      	strh	r3, [r4, #12]
    ac0c:	e055      	b.n	acba <__sflush_r+0x106>
    ac0e:	89a3      	ldrh	r3, [r4, #12]
    ac10:	075b      	lsls	r3, r3, #29
    ac12:	d506      	bpl.n	ac22 <__sflush_r+0x6e>
    ac14:	6863      	ldr	r3, [r4, #4]
    ac16:	1ac0      	subs	r0, r0, r3
    ac18:	6b63      	ldr	r3, [r4, #52]	; 0x34
    ac1a:	2b00      	cmp	r3, #0
    ac1c:	d001      	beq.n	ac22 <__sflush_r+0x6e>
    ac1e:	6c23      	ldr	r3, [r4, #64]	; 0x40
    ac20:	1ac0      	subs	r0, r0, r3
    ac22:	2300      	movs	r3, #0
    ac24:	0002      	movs	r2, r0
    ac26:	6a21      	ldr	r1, [r4, #32]
    ac28:	0028      	movs	r0, r5
    ac2a:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    ac2c:	47b8      	blx	r7
    ac2e:	89a3      	ldrh	r3, [r4, #12]
    ac30:	1c42      	adds	r2, r0, #1
    ac32:	d106      	bne.n	ac42 <__sflush_r+0x8e>
    ac34:	6829      	ldr	r1, [r5, #0]
    ac36:	291d      	cmp	r1, #29
    ac38:	d83a      	bhi.n	acb0 <__sflush_r+0xfc>
    ac3a:	4a20      	ldr	r2, [pc, #128]	; (acbc <__sflush_r+0x108>)
    ac3c:	40ca      	lsrs	r2, r1
    ac3e:	07d2      	lsls	r2, r2, #31
    ac40:	d536      	bpl.n	acb0 <__sflush_r+0xfc>
    ac42:	2200      	movs	r2, #0
    ac44:	6062      	str	r2, [r4, #4]
    ac46:	6922      	ldr	r2, [r4, #16]
    ac48:	6022      	str	r2, [r4, #0]
    ac4a:	04db      	lsls	r3, r3, #19
    ac4c:	d505      	bpl.n	ac5a <__sflush_r+0xa6>
    ac4e:	1c43      	adds	r3, r0, #1
    ac50:	d102      	bne.n	ac58 <__sflush_r+0xa4>
    ac52:	682b      	ldr	r3, [r5, #0]
    ac54:	2b00      	cmp	r3, #0
    ac56:	d100      	bne.n	ac5a <__sflush_r+0xa6>
    ac58:	6560      	str	r0, [r4, #84]	; 0x54
    ac5a:	6b61      	ldr	r1, [r4, #52]	; 0x34
    ac5c:	602e      	str	r6, [r5, #0]
    ac5e:	2900      	cmp	r1, #0
    ac60:	d0ce      	beq.n	ac00 <__sflush_r+0x4c>
    ac62:	0023      	movs	r3, r4
    ac64:	3344      	adds	r3, #68	; 0x44
    ac66:	4299      	cmp	r1, r3
    ac68:	d002      	beq.n	ac70 <__sflush_r+0xbc>
    ac6a:	0028      	movs	r0, r5
    ac6c:	f000 f998 	bl	afa0 <_free_r>
    ac70:	2000      	movs	r0, #0
    ac72:	6360      	str	r0, [r4, #52]	; 0x34
    ac74:	e021      	b.n	acba <__sflush_r+0x106>
    ac76:	690f      	ldr	r7, [r1, #16]
    ac78:	2f00      	cmp	r7, #0
    ac7a:	d0c1      	beq.n	ac00 <__sflush_r+0x4c>
    ac7c:	680b      	ldr	r3, [r1, #0]
    ac7e:	600f      	str	r7, [r1, #0]
    ac80:	1bdb      	subs	r3, r3, r7
    ac82:	9301      	str	r3, [sp, #4]
    ac84:	2300      	movs	r3, #0
    ac86:	0792      	lsls	r2, r2, #30
    ac88:	d100      	bne.n	ac8c <__sflush_r+0xd8>
    ac8a:	694b      	ldr	r3, [r1, #20]
    ac8c:	60a3      	str	r3, [r4, #8]
    ac8e:	e003      	b.n	ac98 <__sflush_r+0xe4>
    ac90:	9b01      	ldr	r3, [sp, #4]
    ac92:	183f      	adds	r7, r7, r0
    ac94:	1a1b      	subs	r3, r3, r0
    ac96:	9301      	str	r3, [sp, #4]
    ac98:	9b01      	ldr	r3, [sp, #4]
    ac9a:	2b00      	cmp	r3, #0
    ac9c:	ddb0      	ble.n	ac00 <__sflush_r+0x4c>
    ac9e:	9b01      	ldr	r3, [sp, #4]
    aca0:	003a      	movs	r2, r7
    aca2:	6a21      	ldr	r1, [r4, #32]
    aca4:	0028      	movs	r0, r5
    aca6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    aca8:	47b0      	blx	r6
    acaa:	2800      	cmp	r0, #0
    acac:	dcf0      	bgt.n	ac90 <__sflush_r+0xdc>
    acae:	89a3      	ldrh	r3, [r4, #12]
    acb0:	2240      	movs	r2, #64	; 0x40
    acb2:	2001      	movs	r0, #1
    acb4:	4313      	orrs	r3, r2
    acb6:	81a3      	strh	r3, [r4, #12]
    acb8:	4240      	negs	r0, r0
    acba:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    acbc:	20400001 	.word	0x20400001

0000acc0 <_fflush_r>:
    acc0:	690b      	ldr	r3, [r1, #16]
    acc2:	b570      	push	{r4, r5, r6, lr}
    acc4:	0005      	movs	r5, r0
    acc6:	000c      	movs	r4, r1
    acc8:	2b00      	cmp	r3, #0
    acca:	d101      	bne.n	acd0 <_fflush_r+0x10>
    accc:	2000      	movs	r0, #0
    acce:	e01c      	b.n	ad0a <_fflush_r+0x4a>
    acd0:	2800      	cmp	r0, #0
    acd2:	d004      	beq.n	acde <_fflush_r+0x1e>
    acd4:	6983      	ldr	r3, [r0, #24]
    acd6:	2b00      	cmp	r3, #0
    acd8:	d101      	bne.n	acde <_fflush_r+0x1e>
    acda:	f000 f85f 	bl	ad9c <__sinit>
    acde:	4b0b      	ldr	r3, [pc, #44]	; (ad0c <_fflush_r+0x4c>)
    ace0:	429c      	cmp	r4, r3
    ace2:	d101      	bne.n	ace8 <_fflush_r+0x28>
    ace4:	686c      	ldr	r4, [r5, #4]
    ace6:	e008      	b.n	acfa <_fflush_r+0x3a>
    ace8:	4b09      	ldr	r3, [pc, #36]	; (ad10 <_fflush_r+0x50>)
    acea:	429c      	cmp	r4, r3
    acec:	d101      	bne.n	acf2 <_fflush_r+0x32>
    acee:	68ac      	ldr	r4, [r5, #8]
    acf0:	e003      	b.n	acfa <_fflush_r+0x3a>
    acf2:	4b08      	ldr	r3, [pc, #32]	; (ad14 <_fflush_r+0x54>)
    acf4:	429c      	cmp	r4, r3
    acf6:	d100      	bne.n	acfa <_fflush_r+0x3a>
    acf8:	68ec      	ldr	r4, [r5, #12]
    acfa:	220c      	movs	r2, #12
    acfc:	5ea3      	ldrsh	r3, [r4, r2]
    acfe:	2b00      	cmp	r3, #0
    ad00:	d0e4      	beq.n	accc <_fflush_r+0xc>
    ad02:	0021      	movs	r1, r4
    ad04:	0028      	movs	r0, r5
    ad06:	f7ff ff55 	bl	abb4 <__sflush_r>
    ad0a:	bd70      	pop	{r4, r5, r6, pc}
    ad0c:	0001370c 	.word	0x0001370c
    ad10:	0001372c 	.word	0x0001372c
    ad14:	0001374c 	.word	0x0001374c

0000ad18 <_cleanup_r>:
    ad18:	b510      	push	{r4, lr}
    ad1a:	4902      	ldr	r1, [pc, #8]	; (ad24 <_cleanup_r+0xc>)
    ad1c:	f000 f8b0 	bl	ae80 <_fwalk_reent>
    ad20:	bd10      	pop	{r4, pc}
    ad22:	46c0      	nop			; (mov r8, r8)
    ad24:	0000acc1 	.word	0x0000acc1

0000ad28 <std.isra.0>:
    ad28:	2300      	movs	r3, #0
    ad2a:	b510      	push	{r4, lr}
    ad2c:	0004      	movs	r4, r0
    ad2e:	6003      	str	r3, [r0, #0]
    ad30:	6043      	str	r3, [r0, #4]
    ad32:	6083      	str	r3, [r0, #8]
    ad34:	8181      	strh	r1, [r0, #12]
    ad36:	6643      	str	r3, [r0, #100]	; 0x64
    ad38:	81c2      	strh	r2, [r0, #14]
    ad3a:	6103      	str	r3, [r0, #16]
    ad3c:	6143      	str	r3, [r0, #20]
    ad3e:	6183      	str	r3, [r0, #24]
    ad40:	0019      	movs	r1, r3
    ad42:	2208      	movs	r2, #8
    ad44:	305c      	adds	r0, #92	; 0x5c
    ad46:	f7ff fd0a 	bl	a75e <memset>
    ad4a:	4b05      	ldr	r3, [pc, #20]	; (ad60 <std.isra.0+0x38>)
    ad4c:	6224      	str	r4, [r4, #32]
    ad4e:	6263      	str	r3, [r4, #36]	; 0x24
    ad50:	4b04      	ldr	r3, [pc, #16]	; (ad64 <std.isra.0+0x3c>)
    ad52:	62a3      	str	r3, [r4, #40]	; 0x28
    ad54:	4b04      	ldr	r3, [pc, #16]	; (ad68 <std.isra.0+0x40>)
    ad56:	62e3      	str	r3, [r4, #44]	; 0x2c
    ad58:	4b04      	ldr	r3, [pc, #16]	; (ad6c <std.isra.0+0x44>)
    ad5a:	6323      	str	r3, [r4, #48]	; 0x30
    ad5c:	bd10      	pop	{r4, pc}
    ad5e:	46c0      	nop			; (mov r8, r8)
    ad60:	0000b711 	.word	0x0000b711
    ad64:	0000b739 	.word	0x0000b739
    ad68:	0000b771 	.word	0x0000b771
    ad6c:	0000b79d 	.word	0x0000b79d

0000ad70 <__sfmoreglue>:
    ad70:	b570      	push	{r4, r5, r6, lr}
    ad72:	2568      	movs	r5, #104	; 0x68
    ad74:	1e4b      	subs	r3, r1, #1
    ad76:	435d      	muls	r5, r3
    ad78:	000e      	movs	r6, r1
    ad7a:	0029      	movs	r1, r5
    ad7c:	3174      	adds	r1, #116	; 0x74
    ad7e:	f000 f955 	bl	b02c <_malloc_r>
    ad82:	1e04      	subs	r4, r0, #0
    ad84:	d008      	beq.n	ad98 <__sfmoreglue+0x28>
    ad86:	2100      	movs	r1, #0
    ad88:	002a      	movs	r2, r5
    ad8a:	6001      	str	r1, [r0, #0]
    ad8c:	6046      	str	r6, [r0, #4]
    ad8e:	300c      	adds	r0, #12
    ad90:	60a0      	str	r0, [r4, #8]
    ad92:	3268      	adds	r2, #104	; 0x68
    ad94:	f7ff fce3 	bl	a75e <memset>
    ad98:	0020      	movs	r0, r4
    ad9a:	bd70      	pop	{r4, r5, r6, pc}

0000ad9c <__sinit>:
    ad9c:	6983      	ldr	r3, [r0, #24]
    ad9e:	b513      	push	{r0, r1, r4, lr}
    ada0:	0004      	movs	r4, r0
    ada2:	2b00      	cmp	r3, #0
    ada4:	d128      	bne.n	adf8 <__sinit+0x5c>
    ada6:	6483      	str	r3, [r0, #72]	; 0x48
    ada8:	64c3      	str	r3, [r0, #76]	; 0x4c
    adaa:	6503      	str	r3, [r0, #80]	; 0x50
    adac:	4b13      	ldr	r3, [pc, #76]	; (adfc <__sinit+0x60>)
    adae:	4a14      	ldr	r2, [pc, #80]	; (ae00 <__sinit+0x64>)
    adb0:	681b      	ldr	r3, [r3, #0]
    adb2:	6282      	str	r2, [r0, #40]	; 0x28
    adb4:	9301      	str	r3, [sp, #4]
    adb6:	4298      	cmp	r0, r3
    adb8:	d101      	bne.n	adbe <__sinit+0x22>
    adba:	2301      	movs	r3, #1
    adbc:	6183      	str	r3, [r0, #24]
    adbe:	0020      	movs	r0, r4
    adc0:	f000 f820 	bl	ae04 <__sfp>
    adc4:	6060      	str	r0, [r4, #4]
    adc6:	0020      	movs	r0, r4
    adc8:	f000 f81c 	bl	ae04 <__sfp>
    adcc:	60a0      	str	r0, [r4, #8]
    adce:	0020      	movs	r0, r4
    add0:	f000 f818 	bl	ae04 <__sfp>
    add4:	2200      	movs	r2, #0
    add6:	60e0      	str	r0, [r4, #12]
    add8:	2104      	movs	r1, #4
    adda:	6860      	ldr	r0, [r4, #4]
    addc:	f7ff ffa4 	bl	ad28 <std.isra.0>
    ade0:	2201      	movs	r2, #1
    ade2:	2109      	movs	r1, #9
    ade4:	68a0      	ldr	r0, [r4, #8]
    ade6:	f7ff ff9f 	bl	ad28 <std.isra.0>
    adea:	2202      	movs	r2, #2
    adec:	2112      	movs	r1, #18
    adee:	68e0      	ldr	r0, [r4, #12]
    adf0:	f7ff ff9a 	bl	ad28 <std.isra.0>
    adf4:	2301      	movs	r3, #1
    adf6:	61a3      	str	r3, [r4, #24]
    adf8:	bd13      	pop	{r0, r1, r4, pc}
    adfa:	46c0      	nop			; (mov r8, r8)
    adfc:	00013708 	.word	0x00013708
    ae00:	0000ad19 	.word	0x0000ad19

0000ae04 <__sfp>:
    ae04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ae06:	4b1d      	ldr	r3, [pc, #116]	; (ae7c <__sfp+0x78>)
    ae08:	0006      	movs	r6, r0
    ae0a:	681d      	ldr	r5, [r3, #0]
    ae0c:	69ab      	ldr	r3, [r5, #24]
    ae0e:	2b00      	cmp	r3, #0
    ae10:	d102      	bne.n	ae18 <__sfp+0x14>
    ae12:	0028      	movs	r0, r5
    ae14:	f7ff ffc2 	bl	ad9c <__sinit>
    ae18:	3548      	adds	r5, #72	; 0x48
    ae1a:	68ac      	ldr	r4, [r5, #8]
    ae1c:	686b      	ldr	r3, [r5, #4]
    ae1e:	3b01      	subs	r3, #1
    ae20:	d405      	bmi.n	ae2e <__sfp+0x2a>
    ae22:	220c      	movs	r2, #12
    ae24:	5ea7      	ldrsh	r7, [r4, r2]
    ae26:	2f00      	cmp	r7, #0
    ae28:	d010      	beq.n	ae4c <__sfp+0x48>
    ae2a:	3468      	adds	r4, #104	; 0x68
    ae2c:	e7f7      	b.n	ae1e <__sfp+0x1a>
    ae2e:	682b      	ldr	r3, [r5, #0]
    ae30:	2b00      	cmp	r3, #0
    ae32:	d001      	beq.n	ae38 <__sfp+0x34>
    ae34:	682d      	ldr	r5, [r5, #0]
    ae36:	e7f0      	b.n	ae1a <__sfp+0x16>
    ae38:	2104      	movs	r1, #4
    ae3a:	0030      	movs	r0, r6
    ae3c:	f7ff ff98 	bl	ad70 <__sfmoreglue>
    ae40:	6028      	str	r0, [r5, #0]
    ae42:	2800      	cmp	r0, #0
    ae44:	d1f6      	bne.n	ae34 <__sfp+0x30>
    ae46:	230c      	movs	r3, #12
    ae48:	6033      	str	r3, [r6, #0]
    ae4a:	e016      	b.n	ae7a <__sfp+0x76>
    ae4c:	2301      	movs	r3, #1
    ae4e:	0020      	movs	r0, r4
    ae50:	425b      	negs	r3, r3
    ae52:	81e3      	strh	r3, [r4, #14]
    ae54:	3302      	adds	r3, #2
    ae56:	81a3      	strh	r3, [r4, #12]
    ae58:	6667      	str	r7, [r4, #100]	; 0x64
    ae5a:	6027      	str	r7, [r4, #0]
    ae5c:	60a7      	str	r7, [r4, #8]
    ae5e:	6067      	str	r7, [r4, #4]
    ae60:	6127      	str	r7, [r4, #16]
    ae62:	6167      	str	r7, [r4, #20]
    ae64:	61a7      	str	r7, [r4, #24]
    ae66:	305c      	adds	r0, #92	; 0x5c
    ae68:	2208      	movs	r2, #8
    ae6a:	0039      	movs	r1, r7
    ae6c:	f7ff fc77 	bl	a75e <memset>
    ae70:	0020      	movs	r0, r4
    ae72:	6367      	str	r7, [r4, #52]	; 0x34
    ae74:	63a7      	str	r7, [r4, #56]	; 0x38
    ae76:	64a7      	str	r7, [r4, #72]	; 0x48
    ae78:	64e7      	str	r7, [r4, #76]	; 0x4c
    ae7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ae7c:	00013708 	.word	0x00013708

0000ae80 <_fwalk_reent>:
    ae80:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    ae82:	0004      	movs	r4, r0
    ae84:	0007      	movs	r7, r0
    ae86:	2600      	movs	r6, #0
    ae88:	9101      	str	r1, [sp, #4]
    ae8a:	3448      	adds	r4, #72	; 0x48
    ae8c:	2c00      	cmp	r4, #0
    ae8e:	d016      	beq.n	aebe <_fwalk_reent+0x3e>
    ae90:	6863      	ldr	r3, [r4, #4]
    ae92:	68a5      	ldr	r5, [r4, #8]
    ae94:	9300      	str	r3, [sp, #0]
    ae96:	9b00      	ldr	r3, [sp, #0]
    ae98:	3b01      	subs	r3, #1
    ae9a:	9300      	str	r3, [sp, #0]
    ae9c:	d40d      	bmi.n	aeba <_fwalk_reent+0x3a>
    ae9e:	89ab      	ldrh	r3, [r5, #12]
    aea0:	2b01      	cmp	r3, #1
    aea2:	d908      	bls.n	aeb6 <_fwalk_reent+0x36>
    aea4:	220e      	movs	r2, #14
    aea6:	5eab      	ldrsh	r3, [r5, r2]
    aea8:	3301      	adds	r3, #1
    aeaa:	d004      	beq.n	aeb6 <_fwalk_reent+0x36>
    aeac:	0029      	movs	r1, r5
    aeae:	0038      	movs	r0, r7
    aeb0:	9b01      	ldr	r3, [sp, #4]
    aeb2:	4798      	blx	r3
    aeb4:	4306      	orrs	r6, r0
    aeb6:	3568      	adds	r5, #104	; 0x68
    aeb8:	e7ed      	b.n	ae96 <_fwalk_reent+0x16>
    aeba:	6824      	ldr	r4, [r4, #0]
    aebc:	e7e6      	b.n	ae8c <_fwalk_reent+0xc>
    aebe:	0030      	movs	r0, r6
    aec0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

0000aec4 <__swhatbuf_r>:
    aec4:	b570      	push	{r4, r5, r6, lr}
    aec6:	000e      	movs	r6, r1
    aec8:	001d      	movs	r5, r3
    aeca:	230e      	movs	r3, #14
    aecc:	5ec9      	ldrsh	r1, [r1, r3]
    aece:	b090      	sub	sp, #64	; 0x40
    aed0:	0014      	movs	r4, r2
    aed2:	2900      	cmp	r1, #0
    aed4:	da06      	bge.n	aee4 <__swhatbuf_r+0x20>
    aed6:	2300      	movs	r3, #0
    aed8:	602b      	str	r3, [r5, #0]
    aeda:	89b3      	ldrh	r3, [r6, #12]
    aedc:	061b      	lsls	r3, r3, #24
    aede:	d50f      	bpl.n	af00 <__swhatbuf_r+0x3c>
    aee0:	2340      	movs	r3, #64	; 0x40
    aee2:	e00f      	b.n	af04 <__swhatbuf_r+0x40>
    aee4:	aa01      	add	r2, sp, #4
    aee6:	f000 fc85 	bl	b7f4 <_fstat_r>
    aeea:	2800      	cmp	r0, #0
    aeec:	dbf3      	blt.n	aed6 <__swhatbuf_r+0x12>
    aeee:	23f0      	movs	r3, #240	; 0xf0
    aef0:	9a02      	ldr	r2, [sp, #8]
    aef2:	021b      	lsls	r3, r3, #8
    aef4:	4013      	ands	r3, r2
    aef6:	4a05      	ldr	r2, [pc, #20]	; (af0c <__swhatbuf_r+0x48>)
    aef8:	189b      	adds	r3, r3, r2
    aefa:	425a      	negs	r2, r3
    aefc:	4153      	adcs	r3, r2
    aefe:	602b      	str	r3, [r5, #0]
    af00:	2380      	movs	r3, #128	; 0x80
    af02:	00db      	lsls	r3, r3, #3
    af04:	2000      	movs	r0, #0
    af06:	6023      	str	r3, [r4, #0]
    af08:	b010      	add	sp, #64	; 0x40
    af0a:	bd70      	pop	{r4, r5, r6, pc}
    af0c:	ffffe000 	.word	0xffffe000

0000af10 <__smakebuf_r>:
    af10:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    af12:	2602      	movs	r6, #2
    af14:	898b      	ldrh	r3, [r1, #12]
    af16:	0005      	movs	r5, r0
    af18:	000c      	movs	r4, r1
    af1a:	4233      	tst	r3, r6
    af1c:	d110      	bne.n	af40 <__smakebuf_r+0x30>
    af1e:	ab01      	add	r3, sp, #4
    af20:	466a      	mov	r2, sp
    af22:	f7ff ffcf 	bl	aec4 <__swhatbuf_r>
    af26:	9900      	ldr	r1, [sp, #0]
    af28:	0007      	movs	r7, r0
    af2a:	0028      	movs	r0, r5
    af2c:	f000 f87e 	bl	b02c <_malloc_r>
    af30:	2800      	cmp	r0, #0
    af32:	d10c      	bne.n	af4e <__smakebuf_r+0x3e>
    af34:	220c      	movs	r2, #12
    af36:	5ea3      	ldrsh	r3, [r4, r2]
    af38:	059a      	lsls	r2, r3, #22
    af3a:	d423      	bmi.n	af84 <__smakebuf_r+0x74>
    af3c:	4333      	orrs	r3, r6
    af3e:	81a3      	strh	r3, [r4, #12]
    af40:	0023      	movs	r3, r4
    af42:	3347      	adds	r3, #71	; 0x47
    af44:	6023      	str	r3, [r4, #0]
    af46:	6123      	str	r3, [r4, #16]
    af48:	2301      	movs	r3, #1
    af4a:	6163      	str	r3, [r4, #20]
    af4c:	e01a      	b.n	af84 <__smakebuf_r+0x74>
    af4e:	2280      	movs	r2, #128	; 0x80
    af50:	4b0d      	ldr	r3, [pc, #52]	; (af88 <__smakebuf_r+0x78>)
    af52:	62ab      	str	r3, [r5, #40]	; 0x28
    af54:	89a3      	ldrh	r3, [r4, #12]
    af56:	6020      	str	r0, [r4, #0]
    af58:	4313      	orrs	r3, r2
    af5a:	81a3      	strh	r3, [r4, #12]
    af5c:	9b00      	ldr	r3, [sp, #0]
    af5e:	6120      	str	r0, [r4, #16]
    af60:	6163      	str	r3, [r4, #20]
    af62:	9b01      	ldr	r3, [sp, #4]
    af64:	2b00      	cmp	r3, #0
    af66:	d00a      	beq.n	af7e <__smakebuf_r+0x6e>
    af68:	230e      	movs	r3, #14
    af6a:	5ee1      	ldrsh	r1, [r4, r3]
    af6c:	0028      	movs	r0, r5
    af6e:	f000 fc53 	bl	b818 <_isatty_r>
    af72:	2800      	cmp	r0, #0
    af74:	d003      	beq.n	af7e <__smakebuf_r+0x6e>
    af76:	2201      	movs	r2, #1
    af78:	89a3      	ldrh	r3, [r4, #12]
    af7a:	4313      	orrs	r3, r2
    af7c:	81a3      	strh	r3, [r4, #12]
    af7e:	89a3      	ldrh	r3, [r4, #12]
    af80:	431f      	orrs	r7, r3
    af82:	81a7      	strh	r7, [r4, #12]
    af84:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    af86:	46c0      	nop			; (mov r8, r8)
    af88:	0000ad19 	.word	0x0000ad19

0000af8c <malloc>:
    af8c:	b510      	push	{r4, lr}
    af8e:	4b03      	ldr	r3, [pc, #12]	; (af9c <malloc+0x10>)
    af90:	0001      	movs	r1, r0
    af92:	6818      	ldr	r0, [r3, #0]
    af94:	f000 f84a 	bl	b02c <_malloc_r>
    af98:	bd10      	pop	{r4, pc}
    af9a:	46c0      	nop			; (mov r8, r8)
    af9c:	20000130 	.word	0x20000130

0000afa0 <_free_r>:
    afa0:	b530      	push	{r4, r5, lr}
    afa2:	2900      	cmp	r1, #0
    afa4:	d03e      	beq.n	b024 <_free_r+0x84>
    afa6:	3904      	subs	r1, #4
    afa8:	680b      	ldr	r3, [r1, #0]
    afaa:	2b00      	cmp	r3, #0
    afac:	da00      	bge.n	afb0 <_free_r+0x10>
    afae:	18c9      	adds	r1, r1, r3
    afb0:	4a1d      	ldr	r2, [pc, #116]	; (b028 <_free_r+0x88>)
    afb2:	6813      	ldr	r3, [r2, #0]
    afb4:	0014      	movs	r4, r2
    afb6:	2b00      	cmp	r3, #0
    afb8:	d102      	bne.n	afc0 <_free_r+0x20>
    afba:	604b      	str	r3, [r1, #4]
    afbc:	6011      	str	r1, [r2, #0]
    afbe:	e031      	b.n	b024 <_free_r+0x84>
    afc0:	428b      	cmp	r3, r1
    afc2:	d90d      	bls.n	afe0 <_free_r+0x40>
    afc4:	680a      	ldr	r2, [r1, #0]
    afc6:	1888      	adds	r0, r1, r2
    afc8:	4283      	cmp	r3, r0
    afca:	d103      	bne.n	afd4 <_free_r+0x34>
    afcc:	6818      	ldr	r0, [r3, #0]
    afce:	685b      	ldr	r3, [r3, #4]
    afd0:	1882      	adds	r2, r0, r2
    afd2:	600a      	str	r2, [r1, #0]
    afd4:	604b      	str	r3, [r1, #4]
    afd6:	6021      	str	r1, [r4, #0]
    afd8:	e024      	b.n	b024 <_free_r+0x84>
    afda:	428a      	cmp	r2, r1
    afdc:	d803      	bhi.n	afe6 <_free_r+0x46>
    afde:	0013      	movs	r3, r2
    afe0:	685a      	ldr	r2, [r3, #4]
    afe2:	2a00      	cmp	r2, #0
    afe4:	d1f9      	bne.n	afda <_free_r+0x3a>
    afe6:	681d      	ldr	r5, [r3, #0]
    afe8:	195c      	adds	r4, r3, r5
    afea:	428c      	cmp	r4, r1
    afec:	d10b      	bne.n	b006 <_free_r+0x66>
    afee:	6809      	ldr	r1, [r1, #0]
    aff0:	1869      	adds	r1, r5, r1
    aff2:	1858      	adds	r0, r3, r1
    aff4:	6019      	str	r1, [r3, #0]
    aff6:	4282      	cmp	r2, r0
    aff8:	d114      	bne.n	b024 <_free_r+0x84>
    affa:	6810      	ldr	r0, [r2, #0]
    affc:	6852      	ldr	r2, [r2, #4]
    affe:	1841      	adds	r1, r0, r1
    b000:	6019      	str	r1, [r3, #0]
    b002:	605a      	str	r2, [r3, #4]
    b004:	e00e      	b.n	b024 <_free_r+0x84>
    b006:	428c      	cmp	r4, r1
    b008:	d902      	bls.n	b010 <_free_r+0x70>
    b00a:	230c      	movs	r3, #12
    b00c:	6003      	str	r3, [r0, #0]
    b00e:	e009      	b.n	b024 <_free_r+0x84>
    b010:	6808      	ldr	r0, [r1, #0]
    b012:	180c      	adds	r4, r1, r0
    b014:	42a2      	cmp	r2, r4
    b016:	d103      	bne.n	b020 <_free_r+0x80>
    b018:	6814      	ldr	r4, [r2, #0]
    b01a:	6852      	ldr	r2, [r2, #4]
    b01c:	1820      	adds	r0, r4, r0
    b01e:	6008      	str	r0, [r1, #0]
    b020:	604a      	str	r2, [r1, #4]
    b022:	6059      	str	r1, [r3, #4]
    b024:	bd30      	pop	{r4, r5, pc}
    b026:	46c0      	nop			; (mov r8, r8)
    b028:	20000ccc 	.word	0x20000ccc

0000b02c <_malloc_r>:
    b02c:	2303      	movs	r3, #3
    b02e:	b570      	push	{r4, r5, r6, lr}
    b030:	1ccd      	adds	r5, r1, #3
    b032:	439d      	bics	r5, r3
    b034:	3508      	adds	r5, #8
    b036:	0006      	movs	r6, r0
    b038:	2d0c      	cmp	r5, #12
    b03a:	d201      	bcs.n	b040 <_malloc_r+0x14>
    b03c:	250c      	movs	r5, #12
    b03e:	e005      	b.n	b04c <_malloc_r+0x20>
    b040:	2d00      	cmp	r5, #0
    b042:	da03      	bge.n	b04c <_malloc_r+0x20>
    b044:	230c      	movs	r3, #12
    b046:	2000      	movs	r0, #0
    b048:	6033      	str	r3, [r6, #0]
    b04a:	e040      	b.n	b0ce <_malloc_r+0xa2>
    b04c:	42a9      	cmp	r1, r5
    b04e:	d8f9      	bhi.n	b044 <_malloc_r+0x18>
    b050:	4b1f      	ldr	r3, [pc, #124]	; (b0d0 <_malloc_r+0xa4>)
    b052:	681c      	ldr	r4, [r3, #0]
    b054:	001a      	movs	r2, r3
    b056:	0021      	movs	r1, r4
    b058:	2900      	cmp	r1, #0
    b05a:	d013      	beq.n	b084 <_malloc_r+0x58>
    b05c:	680b      	ldr	r3, [r1, #0]
    b05e:	1b5b      	subs	r3, r3, r5
    b060:	d40d      	bmi.n	b07e <_malloc_r+0x52>
    b062:	2b0b      	cmp	r3, #11
    b064:	d902      	bls.n	b06c <_malloc_r+0x40>
    b066:	600b      	str	r3, [r1, #0]
    b068:	18cc      	adds	r4, r1, r3
    b06a:	e01e      	b.n	b0aa <_malloc_r+0x7e>
    b06c:	428c      	cmp	r4, r1
    b06e:	d102      	bne.n	b076 <_malloc_r+0x4a>
    b070:	6863      	ldr	r3, [r4, #4]
    b072:	6013      	str	r3, [r2, #0]
    b074:	e01a      	b.n	b0ac <_malloc_r+0x80>
    b076:	684b      	ldr	r3, [r1, #4]
    b078:	6063      	str	r3, [r4, #4]
    b07a:	000c      	movs	r4, r1
    b07c:	e016      	b.n	b0ac <_malloc_r+0x80>
    b07e:	000c      	movs	r4, r1
    b080:	6849      	ldr	r1, [r1, #4]
    b082:	e7e9      	b.n	b058 <_malloc_r+0x2c>
    b084:	4c13      	ldr	r4, [pc, #76]	; (b0d4 <_malloc_r+0xa8>)
    b086:	6823      	ldr	r3, [r4, #0]
    b088:	2b00      	cmp	r3, #0
    b08a:	d103      	bne.n	b094 <_malloc_r+0x68>
    b08c:	0030      	movs	r0, r6
    b08e:	f000 fb2d 	bl	b6ec <_sbrk_r>
    b092:	6020      	str	r0, [r4, #0]
    b094:	0029      	movs	r1, r5
    b096:	0030      	movs	r0, r6
    b098:	f000 fb28 	bl	b6ec <_sbrk_r>
    b09c:	1c43      	adds	r3, r0, #1
    b09e:	d0d1      	beq.n	b044 <_malloc_r+0x18>
    b0a0:	2303      	movs	r3, #3
    b0a2:	1cc4      	adds	r4, r0, #3
    b0a4:	439c      	bics	r4, r3
    b0a6:	42a0      	cmp	r0, r4
    b0a8:	d10a      	bne.n	b0c0 <_malloc_r+0x94>
    b0aa:	6025      	str	r5, [r4, #0]
    b0ac:	0020      	movs	r0, r4
    b0ae:	2207      	movs	r2, #7
    b0b0:	300b      	adds	r0, #11
    b0b2:	1d23      	adds	r3, r4, #4
    b0b4:	4390      	bics	r0, r2
    b0b6:	1ac3      	subs	r3, r0, r3
    b0b8:	d009      	beq.n	b0ce <_malloc_r+0xa2>
    b0ba:	425a      	negs	r2, r3
    b0bc:	50e2      	str	r2, [r4, r3]
    b0be:	e006      	b.n	b0ce <_malloc_r+0xa2>
    b0c0:	1a21      	subs	r1, r4, r0
    b0c2:	0030      	movs	r0, r6
    b0c4:	f000 fb12 	bl	b6ec <_sbrk_r>
    b0c8:	1c43      	adds	r3, r0, #1
    b0ca:	d1ee      	bne.n	b0aa <_malloc_r+0x7e>
    b0cc:	e7ba      	b.n	b044 <_malloc_r+0x18>
    b0ce:	bd70      	pop	{r4, r5, r6, pc}
    b0d0:	20000ccc 	.word	0x20000ccc
    b0d4:	20000cc8 	.word	0x20000cc8

0000b0d8 <__sfputc_r>:
    b0d8:	6893      	ldr	r3, [r2, #8]
    b0da:	b510      	push	{r4, lr}
    b0dc:	3b01      	subs	r3, #1
    b0de:	6093      	str	r3, [r2, #8]
    b0e0:	2b00      	cmp	r3, #0
    b0e2:	da05      	bge.n	b0f0 <__sfputc_r+0x18>
    b0e4:	6994      	ldr	r4, [r2, #24]
    b0e6:	42a3      	cmp	r3, r4
    b0e8:	db08      	blt.n	b0fc <__sfputc_r+0x24>
    b0ea:	b2cb      	uxtb	r3, r1
    b0ec:	2b0a      	cmp	r3, #10
    b0ee:	d005      	beq.n	b0fc <__sfputc_r+0x24>
    b0f0:	6813      	ldr	r3, [r2, #0]
    b0f2:	1c58      	adds	r0, r3, #1
    b0f4:	6010      	str	r0, [r2, #0]
    b0f6:	7019      	strb	r1, [r3, #0]
    b0f8:	b2c8      	uxtb	r0, r1
    b0fa:	e001      	b.n	b100 <__sfputc_r+0x28>
    b0fc:	f7ff fc8c 	bl	aa18 <__swbuf_r>
    b100:	bd10      	pop	{r4, pc}

0000b102 <__sfputs_r>:
    b102:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b104:	0006      	movs	r6, r0
    b106:	000f      	movs	r7, r1
    b108:	0014      	movs	r4, r2
    b10a:	18d5      	adds	r5, r2, r3
    b10c:	42ac      	cmp	r4, r5
    b10e:	d008      	beq.n	b122 <__sfputs_r+0x20>
    b110:	7821      	ldrb	r1, [r4, #0]
    b112:	003a      	movs	r2, r7
    b114:	0030      	movs	r0, r6
    b116:	f7ff ffdf 	bl	b0d8 <__sfputc_r>
    b11a:	3401      	adds	r4, #1
    b11c:	1c43      	adds	r3, r0, #1
    b11e:	d1f5      	bne.n	b10c <__sfputs_r+0xa>
    b120:	e000      	b.n	b124 <__sfputs_r+0x22>
    b122:	2000      	movs	r0, #0
    b124:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0000b128 <_vfiprintf_r>:
    b128:	b5f0      	push	{r4, r5, r6, r7, lr}
    b12a:	b09f      	sub	sp, #124	; 0x7c
    b12c:	0006      	movs	r6, r0
    b12e:	000f      	movs	r7, r1
    b130:	9202      	str	r2, [sp, #8]
    b132:	9305      	str	r3, [sp, #20]
    b134:	2800      	cmp	r0, #0
    b136:	d004      	beq.n	b142 <_vfiprintf_r+0x1a>
    b138:	6983      	ldr	r3, [r0, #24]
    b13a:	2b00      	cmp	r3, #0
    b13c:	d101      	bne.n	b142 <_vfiprintf_r+0x1a>
    b13e:	f7ff fe2d 	bl	ad9c <__sinit>
    b142:	4b7f      	ldr	r3, [pc, #508]	; (b340 <_vfiprintf_r+0x218>)
    b144:	429f      	cmp	r7, r3
    b146:	d101      	bne.n	b14c <_vfiprintf_r+0x24>
    b148:	6877      	ldr	r7, [r6, #4]
    b14a:	e008      	b.n	b15e <_vfiprintf_r+0x36>
    b14c:	4b7d      	ldr	r3, [pc, #500]	; (b344 <_vfiprintf_r+0x21c>)
    b14e:	429f      	cmp	r7, r3
    b150:	d101      	bne.n	b156 <_vfiprintf_r+0x2e>
    b152:	68b7      	ldr	r7, [r6, #8]
    b154:	e003      	b.n	b15e <_vfiprintf_r+0x36>
    b156:	4b7c      	ldr	r3, [pc, #496]	; (b348 <_vfiprintf_r+0x220>)
    b158:	429f      	cmp	r7, r3
    b15a:	d100      	bne.n	b15e <_vfiprintf_r+0x36>
    b15c:	68f7      	ldr	r7, [r6, #12]
    b15e:	89bb      	ldrh	r3, [r7, #12]
    b160:	071b      	lsls	r3, r3, #28
    b162:	d50a      	bpl.n	b17a <_vfiprintf_r+0x52>
    b164:	693b      	ldr	r3, [r7, #16]
    b166:	2b00      	cmp	r3, #0
    b168:	d007      	beq.n	b17a <_vfiprintf_r+0x52>
    b16a:	2300      	movs	r3, #0
    b16c:	ad06      	add	r5, sp, #24
    b16e:	616b      	str	r3, [r5, #20]
    b170:	3320      	adds	r3, #32
    b172:	766b      	strb	r3, [r5, #25]
    b174:	3310      	adds	r3, #16
    b176:	76ab      	strb	r3, [r5, #26]
    b178:	e03d      	b.n	b1f6 <_vfiprintf_r+0xce>
    b17a:	0039      	movs	r1, r7
    b17c:	0030      	movs	r0, r6
    b17e:	f7ff fca3 	bl	aac8 <__swsetup_r>
    b182:	2800      	cmp	r0, #0
    b184:	d0f1      	beq.n	b16a <_vfiprintf_r+0x42>
    b186:	2001      	movs	r0, #1
    b188:	4240      	negs	r0, r0
    b18a:	e0d6      	b.n	b33a <_vfiprintf_r+0x212>
    b18c:	9a05      	ldr	r2, [sp, #20]
    b18e:	1d11      	adds	r1, r2, #4
    b190:	6812      	ldr	r2, [r2, #0]
    b192:	9105      	str	r1, [sp, #20]
    b194:	2a00      	cmp	r2, #0
    b196:	da00      	bge.n	b19a <_vfiprintf_r+0x72>
    b198:	e07f      	b.n	b29a <_vfiprintf_r+0x172>
    b19a:	9209      	str	r2, [sp, #36]	; 0x24
    b19c:	3401      	adds	r4, #1
    b19e:	7823      	ldrb	r3, [r4, #0]
    b1a0:	2b2e      	cmp	r3, #46	; 0x2e
    b1a2:	d100      	bne.n	b1a6 <_vfiprintf_r+0x7e>
    b1a4:	e08d      	b.n	b2c2 <_vfiprintf_r+0x19a>
    b1a6:	7821      	ldrb	r1, [r4, #0]
    b1a8:	2203      	movs	r2, #3
    b1aa:	4868      	ldr	r0, [pc, #416]	; (b34c <_vfiprintf_r+0x224>)
    b1ac:	f000 fb5a 	bl	b864 <memchr>
    b1b0:	2800      	cmp	r0, #0
    b1b2:	d007      	beq.n	b1c4 <_vfiprintf_r+0x9c>
    b1b4:	4b65      	ldr	r3, [pc, #404]	; (b34c <_vfiprintf_r+0x224>)
    b1b6:	682a      	ldr	r2, [r5, #0]
    b1b8:	1ac0      	subs	r0, r0, r3
    b1ba:	2340      	movs	r3, #64	; 0x40
    b1bc:	4083      	lsls	r3, r0
    b1be:	4313      	orrs	r3, r2
    b1c0:	602b      	str	r3, [r5, #0]
    b1c2:	3401      	adds	r4, #1
    b1c4:	7821      	ldrb	r1, [r4, #0]
    b1c6:	1c63      	adds	r3, r4, #1
    b1c8:	2206      	movs	r2, #6
    b1ca:	4861      	ldr	r0, [pc, #388]	; (b350 <_vfiprintf_r+0x228>)
    b1cc:	9302      	str	r3, [sp, #8]
    b1ce:	7629      	strb	r1, [r5, #24]
    b1d0:	f000 fb48 	bl	b864 <memchr>
    b1d4:	2800      	cmp	r0, #0
    b1d6:	d100      	bne.n	b1da <_vfiprintf_r+0xb2>
    b1d8:	e09d      	b.n	b316 <_vfiprintf_r+0x1ee>
    b1da:	4b5e      	ldr	r3, [pc, #376]	; (b354 <_vfiprintf_r+0x22c>)
    b1dc:	2b00      	cmp	r3, #0
    b1de:	d000      	beq.n	b1e2 <_vfiprintf_r+0xba>
    b1e0:	e090      	b.n	b304 <_vfiprintf_r+0x1dc>
    b1e2:	2207      	movs	r2, #7
    b1e4:	9b05      	ldr	r3, [sp, #20]
    b1e6:	3307      	adds	r3, #7
    b1e8:	4393      	bics	r3, r2
    b1ea:	3308      	adds	r3, #8
    b1ec:	9305      	str	r3, [sp, #20]
    b1ee:	696b      	ldr	r3, [r5, #20]
    b1f0:	9a03      	ldr	r2, [sp, #12]
    b1f2:	189b      	adds	r3, r3, r2
    b1f4:	616b      	str	r3, [r5, #20]
    b1f6:	9c02      	ldr	r4, [sp, #8]
    b1f8:	7823      	ldrb	r3, [r4, #0]
    b1fa:	2b00      	cmp	r3, #0
    b1fc:	d104      	bne.n	b208 <_vfiprintf_r+0xe0>
    b1fe:	9b02      	ldr	r3, [sp, #8]
    b200:	1ae3      	subs	r3, r4, r3
    b202:	9304      	str	r3, [sp, #16]
    b204:	d012      	beq.n	b22c <_vfiprintf_r+0x104>
    b206:	e003      	b.n	b210 <_vfiprintf_r+0xe8>
    b208:	2b25      	cmp	r3, #37	; 0x25
    b20a:	d0f8      	beq.n	b1fe <_vfiprintf_r+0xd6>
    b20c:	3401      	adds	r4, #1
    b20e:	e7f3      	b.n	b1f8 <_vfiprintf_r+0xd0>
    b210:	9b04      	ldr	r3, [sp, #16]
    b212:	9a02      	ldr	r2, [sp, #8]
    b214:	0039      	movs	r1, r7
    b216:	0030      	movs	r0, r6
    b218:	f7ff ff73 	bl	b102 <__sfputs_r>
    b21c:	1c43      	adds	r3, r0, #1
    b21e:	d100      	bne.n	b222 <_vfiprintf_r+0xfa>
    b220:	e086      	b.n	b330 <_vfiprintf_r+0x208>
    b222:	696a      	ldr	r2, [r5, #20]
    b224:	9b04      	ldr	r3, [sp, #16]
    b226:	4694      	mov	ip, r2
    b228:	4463      	add	r3, ip
    b22a:	616b      	str	r3, [r5, #20]
    b22c:	7823      	ldrb	r3, [r4, #0]
    b22e:	2b00      	cmp	r3, #0
    b230:	d07e      	beq.n	b330 <_vfiprintf_r+0x208>
    b232:	2201      	movs	r2, #1
    b234:	2300      	movs	r3, #0
    b236:	4252      	negs	r2, r2
    b238:	606a      	str	r2, [r5, #4]
    b23a:	a902      	add	r1, sp, #8
    b23c:	3254      	adds	r2, #84	; 0x54
    b23e:	1852      	adds	r2, r2, r1
    b240:	3401      	adds	r4, #1
    b242:	602b      	str	r3, [r5, #0]
    b244:	60eb      	str	r3, [r5, #12]
    b246:	60ab      	str	r3, [r5, #8]
    b248:	7013      	strb	r3, [r2, #0]
    b24a:	65ab      	str	r3, [r5, #88]	; 0x58
    b24c:	7821      	ldrb	r1, [r4, #0]
    b24e:	2205      	movs	r2, #5
    b250:	4841      	ldr	r0, [pc, #260]	; (b358 <_vfiprintf_r+0x230>)
    b252:	f000 fb07 	bl	b864 <memchr>
    b256:	2800      	cmp	r0, #0
    b258:	d008      	beq.n	b26c <_vfiprintf_r+0x144>
    b25a:	4b3f      	ldr	r3, [pc, #252]	; (b358 <_vfiprintf_r+0x230>)
    b25c:	682a      	ldr	r2, [r5, #0]
    b25e:	1ac0      	subs	r0, r0, r3
    b260:	2301      	movs	r3, #1
    b262:	4083      	lsls	r3, r0
    b264:	4313      	orrs	r3, r2
    b266:	602b      	str	r3, [r5, #0]
    b268:	3401      	adds	r4, #1
    b26a:	e7ef      	b.n	b24c <_vfiprintf_r+0x124>
    b26c:	682b      	ldr	r3, [r5, #0]
    b26e:	06da      	lsls	r2, r3, #27
    b270:	d504      	bpl.n	b27c <_vfiprintf_r+0x154>
    b272:	2253      	movs	r2, #83	; 0x53
    b274:	2120      	movs	r1, #32
    b276:	a802      	add	r0, sp, #8
    b278:	1812      	adds	r2, r2, r0
    b27a:	7011      	strb	r1, [r2, #0]
    b27c:	071a      	lsls	r2, r3, #28
    b27e:	d504      	bpl.n	b28a <_vfiprintf_r+0x162>
    b280:	2253      	movs	r2, #83	; 0x53
    b282:	212b      	movs	r1, #43	; 0x2b
    b284:	a802      	add	r0, sp, #8
    b286:	1812      	adds	r2, r2, r0
    b288:	7011      	strb	r1, [r2, #0]
    b28a:	7822      	ldrb	r2, [r4, #0]
    b28c:	2a2a      	cmp	r2, #42	; 0x2a
    b28e:	d100      	bne.n	b292 <_vfiprintf_r+0x16a>
    b290:	e77c      	b.n	b18c <_vfiprintf_r+0x64>
    b292:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b294:	2000      	movs	r0, #0
    b296:	210a      	movs	r1, #10
    b298:	e005      	b.n	b2a6 <_vfiprintf_r+0x17e>
    b29a:	4252      	negs	r2, r2
    b29c:	60ea      	str	r2, [r5, #12]
    b29e:	2202      	movs	r2, #2
    b2a0:	4313      	orrs	r3, r2
    b2a2:	602b      	str	r3, [r5, #0]
    b2a4:	e77a      	b.n	b19c <_vfiprintf_r+0x74>
    b2a6:	7822      	ldrb	r2, [r4, #0]
    b2a8:	3a30      	subs	r2, #48	; 0x30
    b2aa:	2a09      	cmp	r2, #9
    b2ac:	d804      	bhi.n	b2b8 <_vfiprintf_r+0x190>
    b2ae:	434b      	muls	r3, r1
    b2b0:	3401      	adds	r4, #1
    b2b2:	189b      	adds	r3, r3, r2
    b2b4:	2001      	movs	r0, #1
    b2b6:	e7f6      	b.n	b2a6 <_vfiprintf_r+0x17e>
    b2b8:	2800      	cmp	r0, #0
    b2ba:	d100      	bne.n	b2be <_vfiprintf_r+0x196>
    b2bc:	e76f      	b.n	b19e <_vfiprintf_r+0x76>
    b2be:	9309      	str	r3, [sp, #36]	; 0x24
    b2c0:	e76d      	b.n	b19e <_vfiprintf_r+0x76>
    b2c2:	7863      	ldrb	r3, [r4, #1]
    b2c4:	2b2a      	cmp	r3, #42	; 0x2a
    b2c6:	d10a      	bne.n	b2de <_vfiprintf_r+0x1b6>
    b2c8:	9b05      	ldr	r3, [sp, #20]
    b2ca:	3402      	adds	r4, #2
    b2cc:	1d1a      	adds	r2, r3, #4
    b2ce:	681b      	ldr	r3, [r3, #0]
    b2d0:	9205      	str	r2, [sp, #20]
    b2d2:	2b00      	cmp	r3, #0
    b2d4:	da01      	bge.n	b2da <_vfiprintf_r+0x1b2>
    b2d6:	2301      	movs	r3, #1
    b2d8:	425b      	negs	r3, r3
    b2da:	9307      	str	r3, [sp, #28]
    b2dc:	e763      	b.n	b1a6 <_vfiprintf_r+0x7e>
    b2de:	2300      	movs	r3, #0
    b2e0:	200a      	movs	r0, #10
    b2e2:	001a      	movs	r2, r3
    b2e4:	3401      	adds	r4, #1
    b2e6:	606b      	str	r3, [r5, #4]
    b2e8:	7821      	ldrb	r1, [r4, #0]
    b2ea:	3930      	subs	r1, #48	; 0x30
    b2ec:	2909      	cmp	r1, #9
    b2ee:	d804      	bhi.n	b2fa <_vfiprintf_r+0x1d2>
    b2f0:	4342      	muls	r2, r0
    b2f2:	3401      	adds	r4, #1
    b2f4:	1852      	adds	r2, r2, r1
    b2f6:	2301      	movs	r3, #1
    b2f8:	e7f6      	b.n	b2e8 <_vfiprintf_r+0x1c0>
    b2fa:	2b00      	cmp	r3, #0
    b2fc:	d100      	bne.n	b300 <_vfiprintf_r+0x1d8>
    b2fe:	e752      	b.n	b1a6 <_vfiprintf_r+0x7e>
    b300:	9207      	str	r2, [sp, #28]
    b302:	e750      	b.n	b1a6 <_vfiprintf_r+0x7e>
    b304:	ab05      	add	r3, sp, #20
    b306:	9300      	str	r3, [sp, #0]
    b308:	003a      	movs	r2, r7
    b30a:	4b14      	ldr	r3, [pc, #80]	; (b35c <_vfiprintf_r+0x234>)
    b30c:	0029      	movs	r1, r5
    b30e:	0030      	movs	r0, r6
    b310:	e000      	b.n	b314 <_vfiprintf_r+0x1ec>
    b312:	bf00      	nop
    b314:	e007      	b.n	b326 <_vfiprintf_r+0x1fe>
    b316:	ab05      	add	r3, sp, #20
    b318:	9300      	str	r3, [sp, #0]
    b31a:	003a      	movs	r2, r7
    b31c:	4b0f      	ldr	r3, [pc, #60]	; (b35c <_vfiprintf_r+0x234>)
    b31e:	0029      	movs	r1, r5
    b320:	0030      	movs	r0, r6
    b322:	f000 f88b 	bl	b43c <_printf_i>
    b326:	9003      	str	r0, [sp, #12]
    b328:	9b03      	ldr	r3, [sp, #12]
    b32a:	3301      	adds	r3, #1
    b32c:	d000      	beq.n	b330 <_vfiprintf_r+0x208>
    b32e:	e75e      	b.n	b1ee <_vfiprintf_r+0xc6>
    b330:	89bb      	ldrh	r3, [r7, #12]
    b332:	065b      	lsls	r3, r3, #25
    b334:	d500      	bpl.n	b338 <_vfiprintf_r+0x210>
    b336:	e726      	b.n	b186 <_vfiprintf_r+0x5e>
    b338:	980b      	ldr	r0, [sp, #44]	; 0x2c
    b33a:	b01f      	add	sp, #124	; 0x7c
    b33c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b33e:	46c0      	nop			; (mov r8, r8)
    b340:	0001370c 	.word	0x0001370c
    b344:	0001372c 	.word	0x0001372c
    b348:	0001374c 	.word	0x0001374c
    b34c:	00013772 	.word	0x00013772
    b350:	00013776 	.word	0x00013776
    b354:	00000000 	.word	0x00000000
    b358:	0001376c 	.word	0x0001376c
    b35c:	0000b103 	.word	0x0000b103

0000b360 <_printf_common>:
    b360:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    b362:	0017      	movs	r7, r2
    b364:	9301      	str	r3, [sp, #4]
    b366:	688a      	ldr	r2, [r1, #8]
    b368:	690b      	ldr	r3, [r1, #16]
    b36a:	9000      	str	r0, [sp, #0]
    b36c:	000c      	movs	r4, r1
    b36e:	4293      	cmp	r3, r2
    b370:	da00      	bge.n	b374 <_printf_common+0x14>
    b372:	0013      	movs	r3, r2
    b374:	0022      	movs	r2, r4
    b376:	603b      	str	r3, [r7, #0]
    b378:	3243      	adds	r2, #67	; 0x43
    b37a:	7812      	ldrb	r2, [r2, #0]
    b37c:	2a00      	cmp	r2, #0
    b37e:	d001      	beq.n	b384 <_printf_common+0x24>
    b380:	3301      	adds	r3, #1
    b382:	603b      	str	r3, [r7, #0]
    b384:	6823      	ldr	r3, [r4, #0]
    b386:	069b      	lsls	r3, r3, #26
    b388:	d502      	bpl.n	b390 <_printf_common+0x30>
    b38a:	683b      	ldr	r3, [r7, #0]
    b38c:	3302      	adds	r3, #2
    b38e:	603b      	str	r3, [r7, #0]
    b390:	2506      	movs	r5, #6
    b392:	6823      	ldr	r3, [r4, #0]
    b394:	401d      	ands	r5, r3
    b396:	d01e      	beq.n	b3d6 <_printf_common+0x76>
    b398:	0023      	movs	r3, r4
    b39a:	3343      	adds	r3, #67	; 0x43
    b39c:	781b      	ldrb	r3, [r3, #0]
    b39e:	1e5a      	subs	r2, r3, #1
    b3a0:	4193      	sbcs	r3, r2
    b3a2:	6822      	ldr	r2, [r4, #0]
    b3a4:	0692      	lsls	r2, r2, #26
    b3a6:	d51c      	bpl.n	b3e2 <_printf_common+0x82>
    b3a8:	2030      	movs	r0, #48	; 0x30
    b3aa:	18e1      	adds	r1, r4, r3
    b3ac:	3143      	adds	r1, #67	; 0x43
    b3ae:	7008      	strb	r0, [r1, #0]
    b3b0:	0021      	movs	r1, r4
    b3b2:	1c5a      	adds	r2, r3, #1
    b3b4:	3145      	adds	r1, #69	; 0x45
    b3b6:	7809      	ldrb	r1, [r1, #0]
    b3b8:	18a2      	adds	r2, r4, r2
    b3ba:	3243      	adds	r2, #67	; 0x43
    b3bc:	3302      	adds	r3, #2
    b3be:	7011      	strb	r1, [r2, #0]
    b3c0:	e00f      	b.n	b3e2 <_printf_common+0x82>
    b3c2:	0022      	movs	r2, r4
    b3c4:	2301      	movs	r3, #1
    b3c6:	3219      	adds	r2, #25
    b3c8:	9901      	ldr	r1, [sp, #4]
    b3ca:	9800      	ldr	r0, [sp, #0]
    b3cc:	9e08      	ldr	r6, [sp, #32]
    b3ce:	47b0      	blx	r6
    b3d0:	1c43      	adds	r3, r0, #1
    b3d2:	d00e      	beq.n	b3f2 <_printf_common+0x92>
    b3d4:	3501      	adds	r5, #1
    b3d6:	68e3      	ldr	r3, [r4, #12]
    b3d8:	683a      	ldr	r2, [r7, #0]
    b3da:	1a9b      	subs	r3, r3, r2
    b3dc:	429d      	cmp	r5, r3
    b3de:	dbf0      	blt.n	b3c2 <_printf_common+0x62>
    b3e0:	e7da      	b.n	b398 <_printf_common+0x38>
    b3e2:	0022      	movs	r2, r4
    b3e4:	9901      	ldr	r1, [sp, #4]
    b3e6:	3243      	adds	r2, #67	; 0x43
    b3e8:	9800      	ldr	r0, [sp, #0]
    b3ea:	9d08      	ldr	r5, [sp, #32]
    b3ec:	47a8      	blx	r5
    b3ee:	1c43      	adds	r3, r0, #1
    b3f0:	d102      	bne.n	b3f8 <_printf_common+0x98>
    b3f2:	2001      	movs	r0, #1
    b3f4:	4240      	negs	r0, r0
    b3f6:	e020      	b.n	b43a <_printf_common+0xda>
    b3f8:	2306      	movs	r3, #6
    b3fa:	6820      	ldr	r0, [r4, #0]
    b3fc:	68e1      	ldr	r1, [r4, #12]
    b3fe:	683a      	ldr	r2, [r7, #0]
    b400:	4003      	ands	r3, r0
    b402:	2500      	movs	r5, #0
    b404:	2b04      	cmp	r3, #4
    b406:	d103      	bne.n	b410 <_printf_common+0xb0>
    b408:	1a8d      	subs	r5, r1, r2
    b40a:	43eb      	mvns	r3, r5
    b40c:	17db      	asrs	r3, r3, #31
    b40e:	401d      	ands	r5, r3
    b410:	68a3      	ldr	r3, [r4, #8]
    b412:	6922      	ldr	r2, [r4, #16]
    b414:	4293      	cmp	r3, r2
    b416:	dd01      	ble.n	b41c <_printf_common+0xbc>
    b418:	1a9b      	subs	r3, r3, r2
    b41a:	18ed      	adds	r5, r5, r3
    b41c:	2700      	movs	r7, #0
    b41e:	42bd      	cmp	r5, r7
    b420:	d00a      	beq.n	b438 <_printf_common+0xd8>
    b422:	0022      	movs	r2, r4
    b424:	2301      	movs	r3, #1
    b426:	321a      	adds	r2, #26
    b428:	9901      	ldr	r1, [sp, #4]
    b42a:	9800      	ldr	r0, [sp, #0]
    b42c:	9e08      	ldr	r6, [sp, #32]
    b42e:	47b0      	blx	r6
    b430:	1c43      	adds	r3, r0, #1
    b432:	d0de      	beq.n	b3f2 <_printf_common+0x92>
    b434:	3701      	adds	r7, #1
    b436:	e7f2      	b.n	b41e <_printf_common+0xbe>
    b438:	2000      	movs	r0, #0
    b43a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0000b43c <_printf_i>:
    b43c:	b5f0      	push	{r4, r5, r6, r7, lr}
    b43e:	b08b      	sub	sp, #44	; 0x2c
    b440:	9206      	str	r2, [sp, #24]
    b442:	000a      	movs	r2, r1
    b444:	3243      	adds	r2, #67	; 0x43
    b446:	9307      	str	r3, [sp, #28]
    b448:	9005      	str	r0, [sp, #20]
    b44a:	9204      	str	r2, [sp, #16]
    b44c:	7e0a      	ldrb	r2, [r1, #24]
    b44e:	000c      	movs	r4, r1
    b450:	9b10      	ldr	r3, [sp, #64]	; 0x40
    b452:	2a6e      	cmp	r2, #110	; 0x6e
    b454:	d100      	bne.n	b458 <_printf_i+0x1c>
    b456:	e0ab      	b.n	b5b0 <_printf_i+0x174>
    b458:	d811      	bhi.n	b47e <_printf_i+0x42>
    b45a:	2a63      	cmp	r2, #99	; 0x63
    b45c:	d022      	beq.n	b4a4 <_printf_i+0x68>
    b45e:	d809      	bhi.n	b474 <_printf_i+0x38>
    b460:	2a00      	cmp	r2, #0
    b462:	d100      	bne.n	b466 <_printf_i+0x2a>
    b464:	e0b5      	b.n	b5d2 <_printf_i+0x196>
    b466:	2a58      	cmp	r2, #88	; 0x58
    b468:	d000      	beq.n	b46c <_printf_i+0x30>
    b46a:	e0c5      	b.n	b5f8 <_printf_i+0x1bc>
    b46c:	3145      	adds	r1, #69	; 0x45
    b46e:	700a      	strb	r2, [r1, #0]
    b470:	4a81      	ldr	r2, [pc, #516]	; (b678 <_printf_i+0x23c>)
    b472:	e04f      	b.n	b514 <_printf_i+0xd8>
    b474:	2a64      	cmp	r2, #100	; 0x64
    b476:	d01d      	beq.n	b4b4 <_printf_i+0x78>
    b478:	2a69      	cmp	r2, #105	; 0x69
    b47a:	d01b      	beq.n	b4b4 <_printf_i+0x78>
    b47c:	e0bc      	b.n	b5f8 <_printf_i+0x1bc>
    b47e:	2a73      	cmp	r2, #115	; 0x73
    b480:	d100      	bne.n	b484 <_printf_i+0x48>
    b482:	e0aa      	b.n	b5da <_printf_i+0x19e>
    b484:	d809      	bhi.n	b49a <_printf_i+0x5e>
    b486:	2a6f      	cmp	r2, #111	; 0x6f
    b488:	d029      	beq.n	b4de <_printf_i+0xa2>
    b48a:	2a70      	cmp	r2, #112	; 0x70
    b48c:	d000      	beq.n	b490 <_printf_i+0x54>
    b48e:	e0b3      	b.n	b5f8 <_printf_i+0x1bc>
    b490:	2220      	movs	r2, #32
    b492:	6809      	ldr	r1, [r1, #0]
    b494:	430a      	orrs	r2, r1
    b496:	6022      	str	r2, [r4, #0]
    b498:	e037      	b.n	b50a <_printf_i+0xce>
    b49a:	2a75      	cmp	r2, #117	; 0x75
    b49c:	d01f      	beq.n	b4de <_printf_i+0xa2>
    b49e:	2a78      	cmp	r2, #120	; 0x78
    b4a0:	d033      	beq.n	b50a <_printf_i+0xce>
    b4a2:	e0a9      	b.n	b5f8 <_printf_i+0x1bc>
    b4a4:	000e      	movs	r6, r1
    b4a6:	681a      	ldr	r2, [r3, #0]
    b4a8:	3642      	adds	r6, #66	; 0x42
    b4aa:	1d11      	adds	r1, r2, #4
    b4ac:	6019      	str	r1, [r3, #0]
    b4ae:	6813      	ldr	r3, [r2, #0]
    b4b0:	7033      	strb	r3, [r6, #0]
    b4b2:	e0a4      	b.n	b5fe <_printf_i+0x1c2>
    b4b4:	6821      	ldr	r1, [r4, #0]
    b4b6:	681a      	ldr	r2, [r3, #0]
    b4b8:	0608      	lsls	r0, r1, #24
    b4ba:	d406      	bmi.n	b4ca <_printf_i+0x8e>
    b4bc:	0649      	lsls	r1, r1, #25
    b4be:	d504      	bpl.n	b4ca <_printf_i+0x8e>
    b4c0:	1d11      	adds	r1, r2, #4
    b4c2:	6019      	str	r1, [r3, #0]
    b4c4:	2300      	movs	r3, #0
    b4c6:	5ed5      	ldrsh	r5, [r2, r3]
    b4c8:	e002      	b.n	b4d0 <_printf_i+0x94>
    b4ca:	1d11      	adds	r1, r2, #4
    b4cc:	6019      	str	r1, [r3, #0]
    b4ce:	6815      	ldr	r5, [r2, #0]
    b4d0:	2d00      	cmp	r5, #0
    b4d2:	da3b      	bge.n	b54c <_printf_i+0x110>
    b4d4:	232d      	movs	r3, #45	; 0x2d
    b4d6:	9a04      	ldr	r2, [sp, #16]
    b4d8:	426d      	negs	r5, r5
    b4da:	7013      	strb	r3, [r2, #0]
    b4dc:	e036      	b.n	b54c <_printf_i+0x110>
    b4de:	6821      	ldr	r1, [r4, #0]
    b4e0:	681a      	ldr	r2, [r3, #0]
    b4e2:	0608      	lsls	r0, r1, #24
    b4e4:	d406      	bmi.n	b4f4 <_printf_i+0xb8>
    b4e6:	0649      	lsls	r1, r1, #25
    b4e8:	d504      	bpl.n	b4f4 <_printf_i+0xb8>
    b4ea:	6815      	ldr	r5, [r2, #0]
    b4ec:	1d11      	adds	r1, r2, #4
    b4ee:	6019      	str	r1, [r3, #0]
    b4f0:	b2ad      	uxth	r5, r5
    b4f2:	e002      	b.n	b4fa <_printf_i+0xbe>
    b4f4:	1d11      	adds	r1, r2, #4
    b4f6:	6019      	str	r1, [r3, #0]
    b4f8:	6815      	ldr	r5, [r2, #0]
    b4fa:	4b5f      	ldr	r3, [pc, #380]	; (b678 <_printf_i+0x23c>)
    b4fc:	7e22      	ldrb	r2, [r4, #24]
    b4fe:	9303      	str	r3, [sp, #12]
    b500:	2708      	movs	r7, #8
    b502:	2a6f      	cmp	r2, #111	; 0x6f
    b504:	d01d      	beq.n	b542 <_printf_i+0x106>
    b506:	270a      	movs	r7, #10
    b508:	e01b      	b.n	b542 <_printf_i+0x106>
    b50a:	0022      	movs	r2, r4
    b50c:	2178      	movs	r1, #120	; 0x78
    b50e:	3245      	adds	r2, #69	; 0x45
    b510:	7011      	strb	r1, [r2, #0]
    b512:	4a5a      	ldr	r2, [pc, #360]	; (b67c <_printf_i+0x240>)
    b514:	6819      	ldr	r1, [r3, #0]
    b516:	9203      	str	r2, [sp, #12]
    b518:	1d08      	adds	r0, r1, #4
    b51a:	6822      	ldr	r2, [r4, #0]
    b51c:	6018      	str	r0, [r3, #0]
    b51e:	680d      	ldr	r5, [r1, #0]
    b520:	0610      	lsls	r0, r2, #24
    b522:	d402      	bmi.n	b52a <_printf_i+0xee>
    b524:	0650      	lsls	r0, r2, #25
    b526:	d500      	bpl.n	b52a <_printf_i+0xee>
    b528:	b2ad      	uxth	r5, r5
    b52a:	07d3      	lsls	r3, r2, #31
    b52c:	d502      	bpl.n	b534 <_printf_i+0xf8>
    b52e:	2320      	movs	r3, #32
    b530:	431a      	orrs	r2, r3
    b532:	6022      	str	r2, [r4, #0]
    b534:	2710      	movs	r7, #16
    b536:	2d00      	cmp	r5, #0
    b538:	d103      	bne.n	b542 <_printf_i+0x106>
    b53a:	2320      	movs	r3, #32
    b53c:	6822      	ldr	r2, [r4, #0]
    b53e:	439a      	bics	r2, r3
    b540:	6022      	str	r2, [r4, #0]
    b542:	0023      	movs	r3, r4
    b544:	2200      	movs	r2, #0
    b546:	3343      	adds	r3, #67	; 0x43
    b548:	701a      	strb	r2, [r3, #0]
    b54a:	e002      	b.n	b552 <_printf_i+0x116>
    b54c:	270a      	movs	r7, #10
    b54e:	4b4a      	ldr	r3, [pc, #296]	; (b678 <_printf_i+0x23c>)
    b550:	9303      	str	r3, [sp, #12]
    b552:	6863      	ldr	r3, [r4, #4]
    b554:	60a3      	str	r3, [r4, #8]
    b556:	2b00      	cmp	r3, #0
    b558:	db09      	blt.n	b56e <_printf_i+0x132>
    b55a:	2204      	movs	r2, #4
    b55c:	6821      	ldr	r1, [r4, #0]
    b55e:	4391      	bics	r1, r2
    b560:	6021      	str	r1, [r4, #0]
    b562:	2d00      	cmp	r5, #0
    b564:	d105      	bne.n	b572 <_printf_i+0x136>
    b566:	9e04      	ldr	r6, [sp, #16]
    b568:	2b00      	cmp	r3, #0
    b56a:	d011      	beq.n	b590 <_printf_i+0x154>
    b56c:	e07b      	b.n	b666 <_printf_i+0x22a>
    b56e:	2d00      	cmp	r5, #0
    b570:	d079      	beq.n	b666 <_printf_i+0x22a>
    b572:	9e04      	ldr	r6, [sp, #16]
    b574:	0028      	movs	r0, r5
    b576:	0039      	movs	r1, r7
    b578:	f7fe ff8e 	bl	a498 <__aeabi_uidivmod>
    b57c:	9b03      	ldr	r3, [sp, #12]
    b57e:	3e01      	subs	r6, #1
    b580:	5c5b      	ldrb	r3, [r3, r1]
    b582:	0028      	movs	r0, r5
    b584:	7033      	strb	r3, [r6, #0]
    b586:	0039      	movs	r1, r7
    b588:	f7fe ff00 	bl	a38c <__aeabi_uidiv>
    b58c:	1e05      	subs	r5, r0, #0
    b58e:	d1f1      	bne.n	b574 <_printf_i+0x138>
    b590:	2f08      	cmp	r7, #8
    b592:	d109      	bne.n	b5a8 <_printf_i+0x16c>
    b594:	6823      	ldr	r3, [r4, #0]
    b596:	07db      	lsls	r3, r3, #31
    b598:	d506      	bpl.n	b5a8 <_printf_i+0x16c>
    b59a:	6863      	ldr	r3, [r4, #4]
    b59c:	6922      	ldr	r2, [r4, #16]
    b59e:	4293      	cmp	r3, r2
    b5a0:	dc02      	bgt.n	b5a8 <_printf_i+0x16c>
    b5a2:	2330      	movs	r3, #48	; 0x30
    b5a4:	3e01      	subs	r6, #1
    b5a6:	7033      	strb	r3, [r6, #0]
    b5a8:	9b04      	ldr	r3, [sp, #16]
    b5aa:	1b9b      	subs	r3, r3, r6
    b5ac:	6123      	str	r3, [r4, #16]
    b5ae:	e02b      	b.n	b608 <_printf_i+0x1cc>
    b5b0:	6809      	ldr	r1, [r1, #0]
    b5b2:	681a      	ldr	r2, [r3, #0]
    b5b4:	0608      	lsls	r0, r1, #24
    b5b6:	d407      	bmi.n	b5c8 <_printf_i+0x18c>
    b5b8:	0649      	lsls	r1, r1, #25
    b5ba:	d505      	bpl.n	b5c8 <_printf_i+0x18c>
    b5bc:	1d11      	adds	r1, r2, #4
    b5be:	6019      	str	r1, [r3, #0]
    b5c0:	6813      	ldr	r3, [r2, #0]
    b5c2:	8aa2      	ldrh	r2, [r4, #20]
    b5c4:	801a      	strh	r2, [r3, #0]
    b5c6:	e004      	b.n	b5d2 <_printf_i+0x196>
    b5c8:	1d11      	adds	r1, r2, #4
    b5ca:	6019      	str	r1, [r3, #0]
    b5cc:	6813      	ldr	r3, [r2, #0]
    b5ce:	6962      	ldr	r2, [r4, #20]
    b5d0:	601a      	str	r2, [r3, #0]
    b5d2:	2300      	movs	r3, #0
    b5d4:	9e04      	ldr	r6, [sp, #16]
    b5d6:	6123      	str	r3, [r4, #16]
    b5d8:	e016      	b.n	b608 <_printf_i+0x1cc>
    b5da:	681a      	ldr	r2, [r3, #0]
    b5dc:	1d11      	adds	r1, r2, #4
    b5de:	6019      	str	r1, [r3, #0]
    b5e0:	6816      	ldr	r6, [r2, #0]
    b5e2:	2100      	movs	r1, #0
    b5e4:	6862      	ldr	r2, [r4, #4]
    b5e6:	0030      	movs	r0, r6
    b5e8:	f000 f93c 	bl	b864 <memchr>
    b5ec:	2800      	cmp	r0, #0
    b5ee:	d001      	beq.n	b5f4 <_printf_i+0x1b8>
    b5f0:	1b80      	subs	r0, r0, r6
    b5f2:	6060      	str	r0, [r4, #4]
    b5f4:	6863      	ldr	r3, [r4, #4]
    b5f6:	e003      	b.n	b600 <_printf_i+0x1c4>
    b5f8:	0026      	movs	r6, r4
    b5fa:	3642      	adds	r6, #66	; 0x42
    b5fc:	7032      	strb	r2, [r6, #0]
    b5fe:	2301      	movs	r3, #1
    b600:	6123      	str	r3, [r4, #16]
    b602:	2300      	movs	r3, #0
    b604:	9a04      	ldr	r2, [sp, #16]
    b606:	7013      	strb	r3, [r2, #0]
    b608:	9b07      	ldr	r3, [sp, #28]
    b60a:	aa09      	add	r2, sp, #36	; 0x24
    b60c:	9300      	str	r3, [sp, #0]
    b60e:	0021      	movs	r1, r4
    b610:	9b06      	ldr	r3, [sp, #24]
    b612:	9805      	ldr	r0, [sp, #20]
    b614:	f7ff fea4 	bl	b360 <_printf_common>
    b618:	1c43      	adds	r3, r0, #1
    b61a:	d102      	bne.n	b622 <_printf_i+0x1e6>
    b61c:	2001      	movs	r0, #1
    b61e:	4240      	negs	r0, r0
    b620:	e027      	b.n	b672 <_printf_i+0x236>
    b622:	6923      	ldr	r3, [r4, #16]
    b624:	0032      	movs	r2, r6
    b626:	9906      	ldr	r1, [sp, #24]
    b628:	9805      	ldr	r0, [sp, #20]
    b62a:	9d07      	ldr	r5, [sp, #28]
    b62c:	47a8      	blx	r5
    b62e:	1c43      	adds	r3, r0, #1
    b630:	d0f4      	beq.n	b61c <_printf_i+0x1e0>
    b632:	6823      	ldr	r3, [r4, #0]
    b634:	2500      	movs	r5, #0
    b636:	079b      	lsls	r3, r3, #30
    b638:	d40f      	bmi.n	b65a <_printf_i+0x21e>
    b63a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b63c:	68e0      	ldr	r0, [r4, #12]
    b63e:	4298      	cmp	r0, r3
    b640:	da17      	bge.n	b672 <_printf_i+0x236>
    b642:	0018      	movs	r0, r3
    b644:	e015      	b.n	b672 <_printf_i+0x236>
    b646:	0022      	movs	r2, r4
    b648:	2301      	movs	r3, #1
    b64a:	3219      	adds	r2, #25
    b64c:	9906      	ldr	r1, [sp, #24]
    b64e:	9805      	ldr	r0, [sp, #20]
    b650:	9e07      	ldr	r6, [sp, #28]
    b652:	47b0      	blx	r6
    b654:	1c43      	adds	r3, r0, #1
    b656:	d0e1      	beq.n	b61c <_printf_i+0x1e0>
    b658:	3501      	adds	r5, #1
    b65a:	68e3      	ldr	r3, [r4, #12]
    b65c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    b65e:	1a9b      	subs	r3, r3, r2
    b660:	429d      	cmp	r5, r3
    b662:	dbf0      	blt.n	b646 <_printf_i+0x20a>
    b664:	e7e9      	b.n	b63a <_printf_i+0x1fe>
    b666:	0026      	movs	r6, r4
    b668:	9b03      	ldr	r3, [sp, #12]
    b66a:	3642      	adds	r6, #66	; 0x42
    b66c:	781b      	ldrb	r3, [r3, #0]
    b66e:	7033      	strb	r3, [r6, #0]
    b670:	e78e      	b.n	b590 <_printf_i+0x154>
    b672:	b00b      	add	sp, #44	; 0x2c
    b674:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b676:	46c0      	nop			; (mov r8, r8)
    b678:	0001377d 	.word	0x0001377d
    b67c:	0001378e 	.word	0x0001378e

0000b680 <_putc_r>:
    b680:	b570      	push	{r4, r5, r6, lr}
    b682:	0006      	movs	r6, r0
    b684:	000d      	movs	r5, r1
    b686:	0014      	movs	r4, r2
    b688:	2800      	cmp	r0, #0
    b68a:	d004      	beq.n	b696 <_putc_r+0x16>
    b68c:	6983      	ldr	r3, [r0, #24]
    b68e:	2b00      	cmp	r3, #0
    b690:	d101      	bne.n	b696 <_putc_r+0x16>
    b692:	f7ff fb83 	bl	ad9c <__sinit>
    b696:	4b12      	ldr	r3, [pc, #72]	; (b6e0 <_putc_r+0x60>)
    b698:	429c      	cmp	r4, r3
    b69a:	d101      	bne.n	b6a0 <_putc_r+0x20>
    b69c:	6874      	ldr	r4, [r6, #4]
    b69e:	e008      	b.n	b6b2 <_putc_r+0x32>
    b6a0:	4b10      	ldr	r3, [pc, #64]	; (b6e4 <_putc_r+0x64>)
    b6a2:	429c      	cmp	r4, r3
    b6a4:	d101      	bne.n	b6aa <_putc_r+0x2a>
    b6a6:	68b4      	ldr	r4, [r6, #8]
    b6a8:	e003      	b.n	b6b2 <_putc_r+0x32>
    b6aa:	4b0f      	ldr	r3, [pc, #60]	; (b6e8 <_putc_r+0x68>)
    b6ac:	429c      	cmp	r4, r3
    b6ae:	d100      	bne.n	b6b2 <_putc_r+0x32>
    b6b0:	68f4      	ldr	r4, [r6, #12]
    b6b2:	68a3      	ldr	r3, [r4, #8]
    b6b4:	3b01      	subs	r3, #1
    b6b6:	60a3      	str	r3, [r4, #8]
    b6b8:	2b00      	cmp	r3, #0
    b6ba:	da05      	bge.n	b6c8 <_putc_r+0x48>
    b6bc:	69a2      	ldr	r2, [r4, #24]
    b6be:	4293      	cmp	r3, r2
    b6c0:	db08      	blt.n	b6d4 <_putc_r+0x54>
    b6c2:	b2eb      	uxtb	r3, r5
    b6c4:	2b0a      	cmp	r3, #10
    b6c6:	d005      	beq.n	b6d4 <_putc_r+0x54>
    b6c8:	6823      	ldr	r3, [r4, #0]
    b6ca:	b2e8      	uxtb	r0, r5
    b6cc:	1c5a      	adds	r2, r3, #1
    b6ce:	6022      	str	r2, [r4, #0]
    b6d0:	701d      	strb	r5, [r3, #0]
    b6d2:	e004      	b.n	b6de <_putc_r+0x5e>
    b6d4:	0022      	movs	r2, r4
    b6d6:	0029      	movs	r1, r5
    b6d8:	0030      	movs	r0, r6
    b6da:	f7ff f99d 	bl	aa18 <__swbuf_r>
    b6de:	bd70      	pop	{r4, r5, r6, pc}
    b6e0:	0001370c 	.word	0x0001370c
    b6e4:	0001372c 	.word	0x0001372c
    b6e8:	0001374c 	.word	0x0001374c

0000b6ec <_sbrk_r>:
    b6ec:	2300      	movs	r3, #0
    b6ee:	b570      	push	{r4, r5, r6, lr}
    b6f0:	4c06      	ldr	r4, [pc, #24]	; (b70c <_sbrk_r+0x20>)
    b6f2:	0005      	movs	r5, r0
    b6f4:	0008      	movs	r0, r1
    b6f6:	6023      	str	r3, [r4, #0]
    b6f8:	f7fc fb52 	bl	7da0 <_sbrk>
    b6fc:	1c43      	adds	r3, r0, #1
    b6fe:	d103      	bne.n	b708 <_sbrk_r+0x1c>
    b700:	6823      	ldr	r3, [r4, #0]
    b702:	2b00      	cmp	r3, #0
    b704:	d000      	beq.n	b708 <_sbrk_r+0x1c>
    b706:	602b      	str	r3, [r5, #0]
    b708:	bd70      	pop	{r4, r5, r6, pc}
    b70a:	46c0      	nop			; (mov r8, r8)
    b70c:	200013dc 	.word	0x200013dc

0000b710 <__sread>:
    b710:	b570      	push	{r4, r5, r6, lr}
    b712:	000c      	movs	r4, r1
    b714:	250e      	movs	r5, #14
    b716:	5f49      	ldrsh	r1, [r1, r5]
    b718:	f000 f8b0 	bl	b87c <_read_r>
    b71c:	2800      	cmp	r0, #0
    b71e:	db03      	blt.n	b728 <__sread+0x18>
    b720:	6d63      	ldr	r3, [r4, #84]	; 0x54
    b722:	181b      	adds	r3, r3, r0
    b724:	6563      	str	r3, [r4, #84]	; 0x54
    b726:	e003      	b.n	b730 <__sread+0x20>
    b728:	89a2      	ldrh	r2, [r4, #12]
    b72a:	4b02      	ldr	r3, [pc, #8]	; (b734 <__sread+0x24>)
    b72c:	4013      	ands	r3, r2
    b72e:	81a3      	strh	r3, [r4, #12]
    b730:	bd70      	pop	{r4, r5, r6, pc}
    b732:	46c0      	nop			; (mov r8, r8)
    b734:	ffffefff 	.word	0xffffefff

0000b738 <__swrite>:
    b738:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b73a:	001f      	movs	r7, r3
    b73c:	898b      	ldrh	r3, [r1, #12]
    b73e:	0005      	movs	r5, r0
    b740:	000c      	movs	r4, r1
    b742:	0016      	movs	r6, r2
    b744:	05db      	lsls	r3, r3, #23
    b746:	d505      	bpl.n	b754 <__swrite+0x1c>
    b748:	230e      	movs	r3, #14
    b74a:	5ec9      	ldrsh	r1, [r1, r3]
    b74c:	2200      	movs	r2, #0
    b74e:	2302      	movs	r3, #2
    b750:	f000 f874 	bl	b83c <_lseek_r>
    b754:	89a2      	ldrh	r2, [r4, #12]
    b756:	4b05      	ldr	r3, [pc, #20]	; (b76c <__swrite+0x34>)
    b758:	0028      	movs	r0, r5
    b75a:	4013      	ands	r3, r2
    b75c:	81a3      	strh	r3, [r4, #12]
    b75e:	0032      	movs	r2, r6
    b760:	230e      	movs	r3, #14
    b762:	5ee1      	ldrsh	r1, [r4, r3]
    b764:	003b      	movs	r3, r7
    b766:	f000 f81f 	bl	b7a8 <_write_r>
    b76a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b76c:	ffffefff 	.word	0xffffefff

0000b770 <__sseek>:
    b770:	b570      	push	{r4, r5, r6, lr}
    b772:	000c      	movs	r4, r1
    b774:	250e      	movs	r5, #14
    b776:	5f49      	ldrsh	r1, [r1, r5]
    b778:	f000 f860 	bl	b83c <_lseek_r>
    b77c:	89a3      	ldrh	r3, [r4, #12]
    b77e:	1c42      	adds	r2, r0, #1
    b780:	d103      	bne.n	b78a <__sseek+0x1a>
    b782:	4a05      	ldr	r2, [pc, #20]	; (b798 <__sseek+0x28>)
    b784:	4013      	ands	r3, r2
    b786:	81a3      	strh	r3, [r4, #12]
    b788:	e004      	b.n	b794 <__sseek+0x24>
    b78a:	2280      	movs	r2, #128	; 0x80
    b78c:	0152      	lsls	r2, r2, #5
    b78e:	4313      	orrs	r3, r2
    b790:	81a3      	strh	r3, [r4, #12]
    b792:	6560      	str	r0, [r4, #84]	; 0x54
    b794:	bd70      	pop	{r4, r5, r6, pc}
    b796:	46c0      	nop			; (mov r8, r8)
    b798:	ffffefff 	.word	0xffffefff

0000b79c <__sclose>:
    b79c:	b510      	push	{r4, lr}
    b79e:	230e      	movs	r3, #14
    b7a0:	5ec9      	ldrsh	r1, [r1, r3]
    b7a2:	f000 f815 	bl	b7d0 <_close_r>
    b7a6:	bd10      	pop	{r4, pc}

0000b7a8 <_write_r>:
    b7a8:	b570      	push	{r4, r5, r6, lr}
    b7aa:	0005      	movs	r5, r0
    b7ac:	0008      	movs	r0, r1
    b7ae:	0011      	movs	r1, r2
    b7b0:	2200      	movs	r2, #0
    b7b2:	4c06      	ldr	r4, [pc, #24]	; (b7cc <_write_r+0x24>)
    b7b4:	6022      	str	r2, [r4, #0]
    b7b6:	001a      	movs	r2, r3
    b7b8:	f7fc faca 	bl	7d50 <_write>
    b7bc:	1c43      	adds	r3, r0, #1
    b7be:	d103      	bne.n	b7c8 <_write_r+0x20>
    b7c0:	6823      	ldr	r3, [r4, #0]
    b7c2:	2b00      	cmp	r3, #0
    b7c4:	d000      	beq.n	b7c8 <_write_r+0x20>
    b7c6:	602b      	str	r3, [r5, #0]
    b7c8:	bd70      	pop	{r4, r5, r6, pc}
    b7ca:	46c0      	nop			; (mov r8, r8)
    b7cc:	200013dc 	.word	0x200013dc

0000b7d0 <_close_r>:
    b7d0:	2300      	movs	r3, #0
    b7d2:	b570      	push	{r4, r5, r6, lr}
    b7d4:	4c06      	ldr	r4, [pc, #24]	; (b7f0 <_close_r+0x20>)
    b7d6:	0005      	movs	r5, r0
    b7d8:	0008      	movs	r0, r1
    b7da:	6023      	str	r3, [r4, #0]
    b7dc:	f7fc faf2 	bl	7dc4 <_close>
    b7e0:	1c43      	adds	r3, r0, #1
    b7e2:	d103      	bne.n	b7ec <_close_r+0x1c>
    b7e4:	6823      	ldr	r3, [r4, #0]
    b7e6:	2b00      	cmp	r3, #0
    b7e8:	d000      	beq.n	b7ec <_close_r+0x1c>
    b7ea:	602b      	str	r3, [r5, #0]
    b7ec:	bd70      	pop	{r4, r5, r6, pc}
    b7ee:	46c0      	nop			; (mov r8, r8)
    b7f0:	200013dc 	.word	0x200013dc

0000b7f4 <_fstat_r>:
    b7f4:	2300      	movs	r3, #0
    b7f6:	b570      	push	{r4, r5, r6, lr}
    b7f8:	4c06      	ldr	r4, [pc, #24]	; (b814 <_fstat_r+0x20>)
    b7fa:	0005      	movs	r5, r0
    b7fc:	0008      	movs	r0, r1
    b7fe:	0011      	movs	r1, r2
    b800:	6023      	str	r3, [r4, #0]
    b802:	f7fc fae3 	bl	7dcc <_fstat>
    b806:	1c43      	adds	r3, r0, #1
    b808:	d103      	bne.n	b812 <_fstat_r+0x1e>
    b80a:	6823      	ldr	r3, [r4, #0]
    b80c:	2b00      	cmp	r3, #0
    b80e:	d000      	beq.n	b812 <_fstat_r+0x1e>
    b810:	602b      	str	r3, [r5, #0]
    b812:	bd70      	pop	{r4, r5, r6, pc}
    b814:	200013dc 	.word	0x200013dc

0000b818 <_isatty_r>:
    b818:	2300      	movs	r3, #0
    b81a:	b570      	push	{r4, r5, r6, lr}
    b81c:	4c06      	ldr	r4, [pc, #24]	; (b838 <_isatty_r+0x20>)
    b81e:	0005      	movs	r5, r0
    b820:	0008      	movs	r0, r1
    b822:	6023      	str	r3, [r4, #0]
    b824:	f7fc fad8 	bl	7dd8 <_isatty>
    b828:	1c43      	adds	r3, r0, #1
    b82a:	d103      	bne.n	b834 <_isatty_r+0x1c>
    b82c:	6823      	ldr	r3, [r4, #0]
    b82e:	2b00      	cmp	r3, #0
    b830:	d000      	beq.n	b834 <_isatty_r+0x1c>
    b832:	602b      	str	r3, [r5, #0]
    b834:	bd70      	pop	{r4, r5, r6, pc}
    b836:	46c0      	nop			; (mov r8, r8)
    b838:	200013dc 	.word	0x200013dc

0000b83c <_lseek_r>:
    b83c:	b570      	push	{r4, r5, r6, lr}
    b83e:	0005      	movs	r5, r0
    b840:	0008      	movs	r0, r1
    b842:	0011      	movs	r1, r2
    b844:	2200      	movs	r2, #0
    b846:	4c06      	ldr	r4, [pc, #24]	; (b860 <_lseek_r+0x24>)
    b848:	6022      	str	r2, [r4, #0]
    b84a:	001a      	movs	r2, r3
    b84c:	f7fc fac6 	bl	7ddc <_lseek>
    b850:	1c43      	adds	r3, r0, #1
    b852:	d103      	bne.n	b85c <_lseek_r+0x20>
    b854:	6823      	ldr	r3, [r4, #0]
    b856:	2b00      	cmp	r3, #0
    b858:	d000      	beq.n	b85c <_lseek_r+0x20>
    b85a:	602b      	str	r3, [r5, #0]
    b85c:	bd70      	pop	{r4, r5, r6, pc}
    b85e:	46c0      	nop			; (mov r8, r8)
    b860:	200013dc 	.word	0x200013dc

0000b864 <memchr>:
    b864:	b2c9      	uxtb	r1, r1
    b866:	1882      	adds	r2, r0, r2
    b868:	4290      	cmp	r0, r2
    b86a:	d004      	beq.n	b876 <memchr+0x12>
    b86c:	7803      	ldrb	r3, [r0, #0]
    b86e:	428b      	cmp	r3, r1
    b870:	d002      	beq.n	b878 <memchr+0x14>
    b872:	3001      	adds	r0, #1
    b874:	e7f8      	b.n	b868 <memchr+0x4>
    b876:	2000      	movs	r0, #0
    b878:	4770      	bx	lr
	...

0000b87c <_read_r>:
    b87c:	b570      	push	{r4, r5, r6, lr}
    b87e:	0005      	movs	r5, r0
    b880:	0008      	movs	r0, r1
    b882:	0011      	movs	r1, r2
    b884:	2200      	movs	r2, #0
    b886:	4c06      	ldr	r4, [pc, #24]	; (b8a0 <_read_r+0x24>)
    b888:	6022      	str	r2, [r4, #0]
    b88a:	001a      	movs	r2, r3
    b88c:	f7fc fa40 	bl	7d10 <_read>
    b890:	1c43      	adds	r3, r0, #1
    b892:	d103      	bne.n	b89c <_read_r+0x20>
    b894:	6823      	ldr	r3, [r4, #0]
    b896:	2b00      	cmp	r3, #0
    b898:	d000      	beq.n	b89c <_read_r+0x20>
    b89a:	602b      	str	r3, [r5, #0]
    b89c:	bd70      	pop	{r4, r5, r6, pc}
    b89e:	46c0      	nop			; (mov r8, r8)
    b8a0:	200013dc 	.word	0x200013dc

0000b8a4 <__FUNCTION__.15585>:
    b8a4:	625f6d6e 695f7375 6c74636f 00000000     nm_bus_ioctl....
    b8b4:	50504128 52452829 255b2952 255b5d73     (APP)(ERR)[%s][%
    b8c4:	00005d64 61766e69 6564696c 636f6920     d]..invalide ioc
    b8d4:	6320746c 0000646d 00000d80 00000d50     lt cmd......P...
    b8e4:	00000d48 00000d60 00000d58 00000d78     H...`...X...x...
    b8f4:	00000d68 00000d70                       h...p...

0000b8fc <__FUNCTION__.13753>:
    b8fc:	5f666968 646e6168 695f656c 00007273     hif_handle_isr..

0000b90c <__FUNCTION__.13765>:
    b90c:	5f666968 65636572 00657669              hif_receive.

0000b918 <__FUNCTION__.13781>:
    b918:	5f666968 69676572 72657473 0062635f     hif_register_cb.
    b928:	50504128 4e492829 00294f46 776f6c53     (APP)(INFO).Slow
    b938:	20676e69 6e776f64 002e2e2e 46494828     ing down....(HIF
    b948:	69614629 6f74206c 6b617720 74207075     )Fail to wakup t
    b958:	63206568 00706968 66696828 49572029     he chip.(hif) WI
    b968:	485f4946 5f54534f 5f564352 4c525443     FI_HOST_RCV_CTRL
    b978:	6220315f 66207375 006c6961 66696828     _1 bus fail.(hif
    b988:	64612029 73657264 75622073 61662073     ) address bus fa
    b998:	00006c69 66696828 6f432029 70757272     il..(hif) Corrup
    b9a8:	20646574 6b636170 53207465 20657a69     ted packet Size 
    b9b8:	7525203d 204c3c20 7525203d 2047202c     = %u <L = %u, G 
    b9c8:	7525203d 504f202c 25203d20 3e583230     = %u, OP = %02X>
    b9d8:	0000000a 49464957 6c616320 6361626c     ....WIFI callbac
    b9e8:	7369206b 746f6e20 67657220 65747369     k is not registe
    b9f8:	00646572 6b6f6353 63207465 626c6c61     red.Scoket callb
    ba08:	206b6361 6e207369 7220746f 73696765     ack is not regis
    ba18:	65726574 00000064 2061744f 6c6c6163     tered...Ota call
    ba28:	6b636162 20736920 20746f6e 69676572     back is not regi
    ba38:	72657473 00006465 70797243 63206f74     stered..Crypto c
    ba48:	626c6c61 206b6361 6e207369 7220746f     allback is not r
    ba58:	73696765 65726574 00000064 6d676953     egistered...Sigm
    ba68:	61632061 61626c6c 69206b63 6f6e2073     a callback is no
    ba78:	65722074 74736967 64657265 00000000     t registered....
    ba88:	66696828 6e692029 696c6176 72672064     (hif) invalid gr
    ba98:	2070756f 00004449 66696828 6f682029     oup ID..(hif) ho
    baa8:	61207473 64207070 276e6469 65732074     st app didn't se
    bab8:	58522074 6e6f4420 253c2065 253c3e75     t RX Done <%u><%
    bac8:	000a3e58 66696828 72572029 20676e6f     X>..(hif) Wrong 
    bad8:	657a6953 00000000 66696828 61462029     Size....(hif) Fa
    bae8:	2065736c 65746e69 70757272 6c252074     lse interrupt %l
    baf8:	00000078 66696828 61462029 74206c69     x...(hif) Fail t
    bb08:	6552206f 69206461 7265746e 74707572     o Read interrupt
    bb18:	67657220 00000000 46494828 61462029      reg....(HIF) Fa
    bb28:	74206c69 6168206f 656c646e 746e6920     il to handle int
    bb38:	75727265 25207470 72742064 67412079     errupt %d try Ag
    bb48:	2e6e6961 00000a2e 66696820 6365725f     ain..... hif_rec
    bb58:	65766965 6e49203a 696c6176 72612064     eive: Invalid ar
    bb68:	656d7567 0000746e 20505041 75716552     gument..APP Requ
    bb78:	65747365 69532064 6920657a 616c2073     ested Size is la
    bb88:	72656772 61687420 6874206e 65722065     rger than the re
    bb98:	65766963 75622064 72656666 7a697320     cived buffer siz
    bba8:	253c2065 253c3e75 0a3e756c 00000000     e <%u><%lu>.....
    bbb8:	20505041 75716552 65747365 64412064     APP Requested Ad
    bbc8:	73657264 65622073 646e6f79 65687420     dress beyond the
    bbd8:	63657220 64657669 66756220 20726566      recived buffer 
    bbe8:	72646461 20737365 20646e61 676e656c     address and leng
    bbf8:	00006874 20705247 6425203f 0000000a     th..GRp ? %d....

0000bc08 <__FUNCTION__.13737>:
    bc08:	5f666968 646e6573 00000000              hif_send....

0000bc14 <__FUNCTION__.13747>:
    bc14:	5f666968 00727369                       hif_isr.

0000bc1c <__FUNCTION__.13773>:
    bc1c:	5f6d326d 69666977 6e6f635f 7463656e     m2m_wifi_connect
    bc2c:	0063735f                                _sc.

0000bc30 <__FUNCTION__.13716>:
    bc30:	5f6d326d 69666977 0062635f 666e6f43     m2m_wifi_cb.Conf
    bc40:	7463696c 49206465 20222050 252e7525     licted IP " %u.%
    bc50:	75252e75 2075252e 000a2022 20514552     u.%u.%u " ..REQ 
    bc60:	20746f4e 69666564 2064656e 000a6425     Not defined %d..
    bc70:	41564e49 2044494c 4e494f50 00524554     INVALID POINTER.
    bc80:	41564e49 2044494c 44495353 00000000     INVALID SSID....
    bc90:	41564e49 2044494c 00004843 41564e49     INVALID CH..INVA
    bca0:	2044494c 50434844 52455320 20524556     LID DHCP SERVER 
    bcb0:	00005049 41564e49 2044494c 2059454b     IP..INVALID KEY 
    bcc0:	45444e49 00000058 41564e49 2044494c     INDEX...INVALID 
    bcd0:	2059454b 49525453 5320474e 00455a49     KEY STRING SIZE.
    bce0:	41564e49 2044494c 2059454b 455a4953     INVALID KEY SIZE
    bcf0:	00000000 41564e49 2044494c 20415057     ....INVALID WPA 
    bd00:	2059454b 455a4953 00000000 41564e49     KEY SIZE....INVA
    bd10:	2044494c 48545541 49544e45 49544143     LID AUTHENTICATI
    bd20:	4d204e4f 0045444f 6d726946 65726177     ON MODE.Firmware
    bd30:	72657620 3a202020 2e752520 252e7525      ver   : %u.%u.%
    bd40:	76532075 7665726e 0a752520 00000000     u Svnrev %u.....
    bd50:	6d726946 65726177 69754220 2520646c     Firmware Build %
    bd60:	69542073 2520656d 00000a73 6d726946     s Time %s...Firm
    bd70:	65726177 6e694d20 69726420 20726576     ware Min driver 
    bd80:	20726576 7525203a 2e75252e 000a7525     ver : %u.%u.%u..
    bd90:	76697244 76207265 203a7265 252e7525     Driver ver: %u.%
    bda0:	75252e75 0000000a 343a3031 30313a33     u.%u....10:43:10
    bdb0:	00000000 20677541 32203631 00373130     ....Aug 16 2017.
    bdc0:	76697244 62207265 746c6975 20746120     Driver built at 
    bdd0:	25097325 00000a73 6d73694d 68637461     %s.%s...Mismatch
    bde0:	72694620 7277616d 65562065 6f697372      Firmawre Versio
    bdf0:	0000006e 2079654b 6e207369 7620746f     n...Key is not v
    be00:	64696c61 00000000 61766e49 2064696c     alid....Invalid 
    be10:	0079654b 44495353 4e454c20 564e4920     Key.SSID LEN INV
    be20:	44494c41 00000000 49204843 4c41564e     ALID....CH INVAL
    be30:	00004449 61766e49 2064696c 20706557     ID..Invalid Wep 
    be40:	2079656b 65646e69 64252078 0000000a     key index %d....
    be50:	61766e49 2064696c 20706557 2079656b     Invalid Wep key 
    be60:	676e656c 25206874 00000a64 6f636e49     length %d...Inco
    be70:	63657272 53502074 656b204b 656c2079     rrect PSK key le
    be80:	6874676e 00000000 65646e75 656e6966     ngth....undefine
    be90:	65732064 79742063 00006570 41564e49     d sec type..INVA
    bea0:	2044494c 6f206f4e 63732066 73206e61     LID No of scan s
    beb0:	73746f6c 64252021 0000000a 41564e49     lots! %d....INVA
    bec0:	2044494c 6e616373 6f6c7320 69742074     LID scan slot ti
    bed0:	2021656d 000a6425 41564e49 2044494c     me! %d..INVALID 
    bee0:	6f206f4e 72702066 2065626f 75716572     No of probe requ
    bef0:	73747365 72657020 61637320 6c73206e     ests per scan sl
    bf00:	2520746f 00000a64 41564e49 2044494c     ot %d...INVALID 
    bf10:	49535352 72687420 6f687365 2520646c     RSSI threshold %
    bf20:	000a2064 5f53505f 56524553 205f5245     d .._PS_SERVER_ 
    bf30:	6e207369 6420746f 6e696665 00006465     is not defined..
    bf40:	7473694c 63206e65 6e6e6168 73206c65     Listen channel s
    bf50:	6c756f68 6e6f2064 6220796c 324d2065     hould only be M2
    bf60:	49575f4d 435f4946 2f315f48 31312f36     M_WIFI_CH_1/6/11
    bf70:	00000020 45574f50 41532052 25204556      ...POWER SAVE %
    bf80:	00000a64 41564e49 2044494c 414d4f44     d...INVALID DOMA
    bf90:	4e204e49 00454d41 474e5250 66754220     IN NAME.PRNG Buf
    bfa0:	20726566 65637865 64656465 78616d20     fer exceeded max
    bfb0:	6d756d69 7a697320 64252065 20726f20     imum size %d or 
    bfc0:	4c4c554e 66754220 0a726566 00000000     NULL Buffer.....

0000bfd0 <__FUNCTION__.13745>:
    bfd0:	5f6d326d 69666977 696e695f 00000074     m2m_wifi_init...
    bfe0:	20737542 6f727265 35282072 64252e29     Bus error (5).%d
    bff0:	786c2520 0000000a 6c696146 74206465      %lx....Failed t
    c000:	6177206f 2070756b 20656874 70696863     o wakup the chip
    c010:	00000000 76697244 65567265 666e4972     ....DriverVerInf
    c020:	30203a6f 38302578 000a786c 6c696166     o: 0x%08lx..fail
    c030:	74206465 6564206f 696e692d 6c616974     ed to de-initial
    c040:	00657a69                                ize.

0000c044 <__FUNCTION__.13628>:
    c044:	70696863 6965645f 0074696e              chip_deinit.

0000c050 <__FUNCTION__.13579>:
    c050:	70696863 6b61775f 00000065 696d6e5b     chip_wake...[nmi
    c060:	61747320 3a5d7472 69616620 6e69206c      start]: fail in
    c070:	62207469 00007375 70696843 20444920     it bus..Chip ID 
    c080:	0a786c25 00000000 6c696166 74206465     %lx.....failed t
    c090:	6e65206f 656c6261 746e6920 75727265     o enable interru
    c0a0:	2e737470 0000002e 696d6e5b 6f747320     pts.....[nmi sto
    c0b0:	203a5d70 70696863 6965645f 2074696e     p]: chip_deinit 
    c0c0:	6c696166 00000000 696d6e5b 6f747320     fail....[nmi sto
    c0d0:	203a5d70 20495053 73616c66 69642068     p]: SPI flash di
    c0e0:	6c626173 61662065 00006c69 696d6e5b     sable fail..[nmi
    c0f0:	6f747320 203a5d70 6c696166 696e6920      stop]: fail ini
    c100:	75622074 00000073                       t bus...

0000c108 <__FUNCTION__.13626>:
    c108:	645f6d6e 695f7672 0074696e              nm_drv_init.

0000c114 <__FUNCTION__.13633>:
    c114:	645f6d6e 645f7672 696e6965 00000074     nm_drv_deinit...
    c124:	00001d24 00001d24 00001d54 00001cd6     $...$...T.......
    c134:	00001cfa 00001d08 00001d3a 00001d3a     ........:...:...
    c144:	00001d82 00001cc6 00001de4 00001de4     ................
    c154:	00001de4 00001de4 00001d16 cac4c9c3     ................

0000c164 <__FUNCTION__.13027>:
    c164:	735f6d6e 725f6970 00646165              nm_spi_read.

0000c170 <__FUNCTION__.12979>:
    c170:	5f697073 61746164 6972775f 00006574     spi_data_write..

0000c180 <__FUNCTION__.12991>:
    c180:	5f697073 74697277 65725f65 00000067     spi_write_reg...

0000c190 <__FUNCTION__.12932>:
    c190:	5f697073 00646d63                       spi_cmd.

0000c198 <__FUNCTION__.12939>:
    c198:	5f697073 61746164 7073725f 00000000     spi_data_rsp....

0000c1a8 <__FUNCTION__.13002>:
    c1a8:	735f6d6e 775f6970 65746972 00000000     nm_spi_write....
    c1b8:	696d6e5b 69707320 46203a5d 656c6961     [nmi spi]: Faile
    c1c8:	6d632064 72772064 2c657469 73756220     d cmd write, bus
    c1d8:	72726520 2e2e726f 0000002e 696d6e5b      error......[nmi
    c1e8:	69707320 46203a5d 656c6961 6d632064      spi]: Failed cm
    c1f8:	65722064 6e6f7073 72206573 2c646165     d response read,
    c208:	73756220 72726520 2e2e726f 0000002e      bus error......
    c218:	696d6e5b 69707320 46203a5d 656c6961     [nmi spi]: Faile
    c228:	61642064 72206174 6f707365 2065736e     d data response 
    c238:	64616572 7562202c 72652073 2e726f72     read, bus error.
    c248:	00002e2e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
    c258:	656c6961 61642064 72206174 6f707365     ailed data respo
    c268:	2065736e 64616572 282e2e2e 78323025     nse read...(%02x
    c278:	00000a29 696d6e5b 69707320 46203a5d     )...[nmi spi]: F
    c288:	656c6961 61642064 62206174 6b636f6c     ailed data block
    c298:	61657220 62202c64 65207375 726f7272      read, bus error
    c2a8:	002e2e2e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
    c2b8:	656c6961 61642064 62206174 6b636f6c     ailed data block
    c2c8:	63726320 61657220 62202c64 65207375      crc read, bus e
    c2d8:	726f7272 002e2e2e 696d6e5b 69707320     rror....[nmi spi
    c2e8:	46203a5d 656c6961 6d632064 77202c64     ]: Failed cmd, w
    c2f8:	65746972 67657220 30252820 2e297838     rite reg (%08x).
    c308:	000a2e2e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
    c318:	656c6961 6d632064 65722064 6e6f7073     ailed cmd respon
    c328:	202c6573 74697277 65722065 25282067     se, write reg (%
    c338:	29783830 0a2e2e2e 00000000 65736552     08x)........Rese
    c348:	6e612074 65722064 20797274 25206425     t and retry %d %
    c358:	2520786c 000a786c 696d6e5b 69707320     lx %lx..[nmi spi
    c368:	46203a5d 656c6961 6d632064 72202c64     ]: Failed cmd, r
    c378:	20646165 20676572 38302528 2e2e2978     ead reg (%08x)..
    c388:	00000a2e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
    c398:	656c6961 6d632064 65722064 6e6f7073     ailed cmd respon
    c3a8:	202c6573 64616572 67657220 30252820     se, read reg (%0
    c3b8:	2e297838 000a2e2e 696d6e5b 69707320     8x).....[nmi spi
    c3c8:	46203a5d 656c6961 61642064 72206174     ]: Failed data r
    c3d8:	2e646165 00002e2e 65736552 6e612074     ead.....Reset an
    c3e8:	65722064 20797274 25206425 000a786c     d retry %d %lx..
    c3f8:	696d6e5b 69707320 46203a5d 656c6961     [nmi spi]: Faile
    c408:	6e692064 6e726574 72206c61 20646165     d internal read 
    c418:	746f7270 6c6f636f 74697720 52432068     protocol with CR
    c428:	6e6f2043 6572202c 69727974 7720676e     C on, retyring w
    c438:	20687469 20435243 2e66666f 00002e2e     ith CRC off.....
    c448:	696d6e5b 69707320 46203a5d 656c6961     [nmi spi]: Faile
    c458:	6e692064 6e726574 72206c61 20646165     d internal read 
    c468:	746f7270 6c6f636f 002e2e2e 696d6e5b     protocol....[nmi
    c478:	69707320 46203a5d 656c6961 6e692064      spi]: Failed in
    c488:	6e726574 77206c61 65746972 6f727020     ternal write pro
    c498:	6f636f74 6572206c 2e2e2e67 00000000     tocol reg.......
    c4a8:	696d6e5b 69707320 46203a5d 206c6961     [nmi spi]: Fail 
    c4b8:	20646d63 64616572 69686320 64692070     cmd read chip id
    c4c8:	002e2e2e 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
    c4d8:	656c6961 6d632064 72202c64 20646165     ailed cmd, read 
    c4e8:	636f6c62 2528206b 29783830 0a2e2e2e     block (%08x)....
    c4f8:	00000000 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
    c508:	656c6961 6d632064 65722064 6e6f7073     ailed cmd respon
    c518:	202c6573 64616572 6f6c6220 28206b63     se, read block (
    c528:	78383025 2e2e2e29 0000000a 696d6e5b     %08x).......[nmi
    c538:	69707320 46203a5d 656c6961 6c622064      spi]: Failed bl
    c548:	206b636f 61746164 61657220 2e2e2e64     ock data read...
    c558:	00000000 65736552 6e612074 65722064     ....Reset and re
    c568:	20797274 25206425 2520786c 00000a64     try %d %lx %d...
    c578:	696d6e5b 69707320 46203a5d 656c6961     [nmi spi]: Faile
    c588:	6d632064 77202c64 65746972 6f6c6220     d cmd, write blo
    c598:	28206b63 78383025 2e2e2e29 0000000a     ck (%08x).......
    c5a8:	696d6e5b 69707320 203a5d20 6c696146     [nmi spi ]: Fail
    c5b8:	63206465 7220646d 6f707365 2c65736e     ed cmd response,
    c5c8:	69727720 62206574 6b636f6c 30252820      write block (%0
    c5d8:	2e297838 000a2e2e 696d6e5b 69707320     8x).....[nmi spi
    c5e8:	46203a5d 656c6961 61642064 62206174     ]: Failed data b
    c5f8:	6b636f6c 646d6320 69727720 202c6574     lock cmd write, 
    c608:	20737562 6f727265 2e2e2e72 00000000     bus error.......
    c618:	696d6e5b 69707320 46203a5d 656c6961     [nmi spi]: Faile
    c628:	61642064 62206174 6b636f6c 69727720     d data block wri
    c638:	202c6574 20737562 6f727265 2e2e2e72     te, bus error...
    c648:	00000000 696d6e5b 69707320 46203a5d     ....[nmi spi]: F
    c658:	656c6961 61642064 62206174 6b636f6c     ailed data block
    c668:	63726320 69727720 202c6574 20737562      crc write, bus 
    c678:	6f727265 2e2e2e72 00000000 696d6e5b     error.......[nmi
    c688:	69707320 46203a5d 656c6961 75622064      spi]: Failed bu
    c698:	72652073 2e726f72 00002e2e 696d6e5b     s error.....[nmi
    c6a8:	69707320 46203a5d 656c6961 61642064      spi]: Failed da
    c6b8:	72206174 6f707365 2065736e 64616572     ta response read
    c6c8:	7825202c 20782520 000a7825 696d6e5b     , %x %x %x..[nmi
    c6d8:	69707320 46203a5d 656c6961 6c622064      spi]: Failed bl
    c6e8:	206b636f 61746164 69727720 2e2e6574     ock data write..
    c6f8:	0000002e                                ....

0000c6fc <__FUNCTION__.12948>:
    c6fc:	5f697073 5f646d63 00707372              spi_cmd_rsp.

0000c708 <__FUNCTION__.13014>:
    c708:	5f697073 64616572 6765725f 00000000     spi_read_reg....

0000c718 <__FUNCTION__.12964>:
    c718:	5f697073 61746164 6165725f 00000064     spi_data_read...

0000c728 <crc7_syndrome_table>:
    c728:	1b120900 3f362d24 535a4148 777e656c     ....$-6?HAZSle~w
    c738:	020b1019 262f343d 4a435851 6e677c75     ....=4/&QXCJu|gn
    c748:	29203b32 0d041f16 6168737a 454c575e     2; )....zsha^WLE
    c758:	3039222b 141d060f 78716a63 5c554e47     +"90....cjqxGNU\
    c768:	7f766d64 5b524940 373e252c 131a0108     dmv.@IR[,%>7....
    c778:	666f747d 424b5059 2e273c35 0a031811     }tofYPKB5<'.....
    c788:	4d445f56 69607b72 050c171e 2128333a     V_DMr{`i....:3(!
    c798:	545d464f 7079626b 1c150e07 38312a23     OF]Tkbyp....#*18
    c7a8:	5a534841 7e776c65 121b0009 363f242d     AHSZelw~....-$?6
    c7b8:	434a5158 676e757c 0b021910 2f263d34     XQJC|ung....4=&/
    c7c8:	68617a73 4c455e57 2029323b 040d161f     szahW^EL;2) ....
    c7d8:	7178636a 555c474e 39302b22 1d140f06     jcxqNG\U"+09....
    c7e8:	3e372c25 1a130801 767f646d 525b4049     %,7>....md.vI@[R
    c7f8:	272e353c 030a1118 6f667d74 4b425950     <5.'....t}foPYBK
    c808:	0c051e17 28213a33 444d565f 6069727b     ....3:!(_VMD{ri`
    c818:	151c070e 3138232a 5d544f46 79706b62     ....*#81FOT]bkpy

0000c828 <__FUNCTION__.13048>:
    c828:	735f6d6e 695f6970 0074696e 52524528     nm_spi_init.(ERR
    c838:	75432952 6e657272 253c2074 000a3e64     R)Current <%d>..
    c848:	6b636f53 25207465 65732064 6f697373     Socket %d sessio
    c858:	4449206e 25203d20 000a0d64 6b636f53     n ID = %d...Sock
    c868:	206f7420 656c6564 3c206574 0a3e6425      to delete <%d>.
    c878:	00000000 20494e53 65637845 20736465     ....SNI Exceeds 
    c888:	2078614d 676e654c 00006874 6e6b6e55     Max Length..Unkn
    c898:	206e776f 204c5353 6b636f53 4f207465     own SSL Socket O
    c8a8:	6f697470 6425206e 0000000a 20746f4e     ption %d....Not 
    c8b8:	204c5353 6b636f53 00007465 00003866     SSL Socket..f8..
    c8c8:	000037a2 00003866 00003866 000037b2     .7..f8..f8...7..
    c8d8:	00003866 00003866 00003866 00003866     f8..f8..f8..f8..
    c8e8:	000037ea 00003866 00003866 00003866     .7..f8..f8..f8..
    c8f8:	00003866 00003866 0000378e 00003866     f8..f8...7..f8..
    c908:	00003866 000037e2                       f8...7..

0000c910 <_bhi_fw>:
    c910:	0a00652a 4edccf94 00000000 000064b8     *e.....N.....d..
    c920:	007f8c5c 007f8c1c 007f8c34 7000264a     \.......4...J&.p
    c930:	7000264a 7000264a 7000264a 7000264a     J&.pJ&.pJ&.pJ&.p
    c940:	7000264a 7000264a 7000264a 7000264a     J&.pJ&.pJ&.pJ&.p
    c950:	7000264a 7000264a 7000264a 7000264a     J&.pJ&.pJ&.pJ&.p
    c960:	0060967c 0060967c 0060967c 0060967c     |.`.|.`.|.`.|.`.
    c970:	0060967c 0060967c 0060967c 0060967c     |.`.|.`.|.`.|.`.
    c980:	00605ba8 006071a4 0060750c 006061ac     .[`..q`..u`..a`.
    c990:	007f8c28 007f8c28 007f8c28 007f8c28     (...(...(...(...
    c9a0:	00606c78 00606c78 00606c78 00606c78     xl`.xl`.xl`.xl`.
    c9b0:	00606c78 00606c78 0d8f01d5 0d4f0409     xl`.xl`.......O.
    c9c0:	0d4f03b1 0d4f03cd 0d4f0399 0d4f03b5     ..O...O...O...O.
    c9d0:	0d4f034d 0d8f00e9 0d4f04c1 0d8f01e5     M.O.......O.....
    c9e0:	0d8f007d 0d8f003d 0d8f0021 0d4f067d     }...=...!...}.O.
    c9f0:	0d4f03e5 0d4f06c9 0d4f035d 0d4f04e1     ..O...O.].O...O.
    ca00:	0d4f0539 0d4f0335 0d4f0325 0d4f03fd     9.O.5.O.%.O...O.
    ca10:	0e0f0701 0e0f0639 0e0f078d 0e0f07a1     ....9...........
    ca20:	0e0f0699 0e0f069d 0e0f06a1 0e0f0615     ................
    ca30:	0e0f0665 0e0f0671 0e0f0665 0e0f0671     e...q...e...q...
    ca40:	0e0f073d 0bcf06b5 0bcf06bd 0bcf06c5     =...............
    ca50:	0bcf06e1 0bcf0611 0bcf0731 0bcf05d9     ........1.......
    ca60:	0bcf05e5 0bcf0621 0bcf05ed 0bcf05f1     ....!...........
    ca70:	0bcf060d 0f8f0631 0f8f0621 0f8f0611     ....1...!.......
    ca80:	0f8f0431 0f8f044d 0c0f07f1 0c0f0415     1...M...........
    ca90:	0c0f0369 0c0f050d 0c0f048d 0c0f0331     i...........1...
    caa0:	0c0f06e5 0c0f0235 0c0f02f9 0c0f00e5     ....5...........
    cab0:	0c0f0399 0c0f00fd 0c0f0241 0c0f02b9     ........A.......
    cac0:	0c0f07a5 0c0f00a9 0c0f0251 0c0f0521     ........Q...!...
    cad0:	0c0f0179 0c0f00fd 0c0f010d 0c0f0115     y...............
    cae0:	0c0f068d 0d8f02b9 0d8f026d 0d8f023d     ........m...=...
    caf0:	0d8f0301 0d8f0241 0d8f05b5 0d8f05c5     ....A...........
    cb00:	0d8f0429 0d8f03fd 0d8f045d 0d8f038d     ).......].......
    cb10:	0d8f0429 0d8f037d 0d8f0435 0e8f056d     )...}...5...m...
    cb20:	0e8f0491 00c002c1 0e8f0389 0e8f0649     ............I...
    cb30:	0e8f03ad 0e8f02d9 0ecf01b5 0e8f06ad     ................
    cb40:	0e8f0355 0e8f0419 0e8f0379 0e8f0661     U.......y...a...
    cb50:	0e8f06c9 0e8f0351 0e8f03bd 0ecf00e1     ....Q...........
    cb60:	00c003ad 00c003b9 00c003c5 0ecf025d     ............]...
    cb70:	0ecf0249 0ecf04a5 0ecf0231 00c003c9     I.......1.......
    cb80:	0ecf04f1 00c0050d 00c00535 0ecf031d     ........5.......
    cb90:	0f0f01d5 0f0f0069 0f0f0329 0f0f0345     ....i...)...E...
    cba0:	0f0f0085 00c00735 00c00741 01000015     ....5...A.......
    cbb0:	0f0f0391 0f0f0359 0f0f007d 0acf0765     ....Y...}...e...
    cbc0:	0acf06f1 0acf0721 0acf06a1 0acf06cd     ....!...........
    cbd0:	0acf0661 0acf06ad 0acf0679 0b0f0205     a.......y.......
    cbe0:	0b0f0121 0b0f00f5 0b0f00c9 0b0f0101     !...............
    cbf0:	0b0f032d 0b0f01ad 0b0f011d 0acf07ed     -...............
    cc00:	0b0f0011 0b0f001d 0b0f0301 0b0f002d     ............-...
    cc10:	0b0f0041 0b0f0055 0acf07e1 0b0f006d     A...U.......m...
    cc20:	0b0f051d 0b0f04ed 0b0f059d 0b0f05f9     ................
    cc30:	0b0f0529 0b0f0541 0e8f00a9 0e8f0031     )...A.......1...
    cc40:	0e4f06b9 0e4f06e1 0e4f0705 0e4f075d     ..O...O...O.].O.
    cc50:	0e4f07c9 0e4f07f5 0e4f0679 0e4f0701     ..O...O.y.O...O.
    cc60:	0e4f068d 0e4f06d9 0e8f0145 0e4f0701     ..O...O.E.....O.
    cc70:	0e4f0711 0e4f0695 0e4f06a1 0e4f0719     ..O...O...O...O.
    cc80:	0e4f073d 0e0f05f9 0e4f00cd 0e0f0679     =.O.......O.y...
    cc90:	0e0f0659 0e0f0585 0e0f0629 0e0f0659     Y.......)...Y...
    cca0:	0e0f065d 0e0f0635 0f8f03b5 0c4f0169     ]...5.......i.O.
    ccb0:	0c4f0151 0c4f0085 0c4f028d 0c4f0175     Q.O...O...O.u.O.
    ccc0:	0c4f01cd 0c4f02b9 0c4f019d 0c4f00e5     ..O...O...O...O.
    ccd0:	0c4f00d1 0c4f00ed 0c4f00d1 0c4f00dd     ..O...O...O...O.
    cce0:	0c4f00f9 0c4f00e5 0c4f00e9 0c4f00f5     ..O...O...O...O.
    ccf0:	0c4f0101 0c4f00f5 0c4f0031 0c4f0099     ..O...O.1.O...O.
    cd00:	0e0f0185 0d8f0651 0d8f0699 0d8f06b1     ....Q...........
    cd10:	0d8f0761 0d8f076d 0d8f0749 0d8f0735     a...m...I...5...
    cd20:	0d8f0671 0dcf0451 0e0f0089 0dcf0179     q...Q.......y...
    cd30:	0dcf0369 0dcf029d 0dcf01e5 0dcf0279     i...........y...
    cd40:	0dcf0199 0d8f0411 0d8f053d 0d8f0681     ........=.......
    cd50:	0d8f0689 0dcf073d 0dcf0431 0d8f06d9     ....=...1.......
    cd60:	0d8f0625 0dcf03fd 0d8f05d9 0d8f0765     %...........e...
    cd70:	0d8f0389 0d8f05f1 0e4f003d 0e4f00a5     ........=.O...O.
    cd80:	0e4f001d 0e0f07e1 0e4f0005 0e4f0009     ..O.......O...O.
    cd90:	0e4f02e9 0e4f03c5 0e4f04ed 0e4f0245     ..O...O...O.E.O.
    cda0:	0e4f02bd 0e4f0335 0e4f0345 0e4f0325     ..O.5.O.E.O.%.O.
    cdb0:	0e4f0315 0e4f0341 0b0f05e1 0b0f0571     ..O.A.O.....q...
    cdc0:	0b0f0605 0b0f0595 0b0f06a9 0b0f06d9     ................
    cdd0:	0b0f07f9 0b4f0055 0b0f0685 0b0f066d     ....U.O.....m...
    cde0:	0b0f0611 0b0f0639 0b0f06e5 0b4f0005     ....9.........O.
    cdf0:	0b4f0109 0b4f0199 0b4f01b1 0b4f0289     ..O...O...O...O.
    ce00:	0b4f02f5 0b4f031d 0b4f0141 0b4f01e1     ..O...O.A.O...O.
    ce10:	0b4f01f9 0b4f0211 0b4f0229 0b4f0069     ..O...O.).O.i.O.
    ce20:	0b4f0101 0b4f0021 0b0f06ed 0c4f05d9     ..O.!.O.......O.
    ce30:	0c8f0431 0c4f061d 0c4f0175 0c4f04b1     1.....O.u.O...O.
    ce40:	0c4f0525 0c4f02d5 0c8f0119 0c4f07c9     %.O...O.......O.
    ce50:	0c4f078d 0c4f0289 0c4f0295 00c00639     ..O...O...O.9...
    ce60:	0c4f06ed 0c4f022d 0c4f0265 0c4f07c5     ..O.-.O.e.O...O.
    ce70:	0c4f0565 0c4f0125 0c4f0449 0c4f0455     e.O.%.O.I.O.U.O.
    ce80:	0c4f056d 0c4f0389 0c4f035d 0c4f03a9     m.O...O.].O...O.
    ce90:	0c4f0369 0c4f038d 0c4f015d 0c4f062d     i.O...O.].O.-.O.
    cea0:	0c4f01e5 0c4f01d5 0c4f03c9 0c4f039d     ..O...O...O...O.
    ceb0:	0c4f03e9 0c4f03f9 0c4f03a5 0c4f03c9     ..O...O...O...O.
    cec0:	0c4f02dd 0c4f05f1 0c4f02f1 0c4f0301     ..O...O...O...O.
    ced0:	0c8f07a1 0c4f0649 0c4f0101 0c4f0191     ....I.O...O...O.
    cee0:	0c4f0609 0c4f0219 0c4f0251 0c4f0165     ..O...O.Q.O.e.O.
    cef0:	0c4f0145 0c8f0515 0ccf0391 0ccf0519     E.O.............
    cf00:	0ccf0555 0ccf06a1 0ccf05dd 0ccf01dd     U...............
    cf10:	0ccf02e5 0ccf01ed 0ccf0601 00400605     ..............@.
    cf20:	0bcf0439 0bcf03d9 0bcf03e1 0bcf03c9     9...............
    cf30:	07cf04dd 0d0f0345 0f4f01a1 0f4f0255     ....E.....O.U.O.
    cf40:	00c00675 0f0f074d 0f0f07fd 0bcf0141     u...M.......A...
    cf50:	07cf01b9 0f4f0179 08cf02d5 00c006b1     ....y.O.........
    cf60:	08cf03e1 00c00739 088f0491 08cf01bd     ....9...........
    cf70:	08cf0219 088f0759 088f0779 088f0799     ....Y...y.......
    cf80:	08cf00f5 08cf0119 08cf013d 08cf043d     ........=...=...
    cf90:	08cf015d 08cf0215 088f07a1 088f07dd     ]...............
    cfa0:	08cf0015 08cf01a9 088f0481 08cf0049     ............I...
    cfb0:	08cf0319 01000121 0100016d 098f07a9     ....!...m.......
    cfc0:	0acf00b5 0acf00c9 0a4f04e5 0a4f0431     ..........O.1.O.
    cfd0:	0a4f0609 098f060d 09cf0531 09cf05e5     ..O.....1.......
    cfe0:	09cf04b9 09cf04a5 0a0f02e9 0a0f028d     ................
    cff0:	0a0f0481 0a0f0165 0a0f006d 0acf0009     ....e...m.......
    d000:	0a0f00e9 0a0f0009 0acf0029 0a0f012d     ........)...-...
    d010:	0a8f07c9 0a0f0085 0a0f0409 0a0f03dd     ................
    d020:	098f02e9 0a0f02f1 0a0f0499 010002d1     ................
    d030:	098f07b5 098f07a9 098f07b9 09cf0681     ................
    d040:	098f0715 09cf06a1 09cf0739 0acf001d     ........9.......
    d050:	0a0f02dd 09cf004d 098f0775 09cf060d     ....M...u.......
    d060:	010002f9 0a0f05a9 0a0f0699 0a0f0171     ............q...
    d070:	0a0f0771 0a0f06f5 0a0f0181 0a0f07f1     q...............
    d080:	0a0f06d5 098f0419 098f0635 098f044d     ........5...M...
    d090:	0a4f07b5 098f04b5 098f0479 098f04e5     ..O.....y.......
    d0a0:	098f0235 098f04f5 098f0595 098f061d     5...............
    d0b0:	098f05f1 098f0535 098f0579 098f05ad     ....5...y.......
    d0c0:	098f06b9 098f06d9 0a8f0025 0a0f0199     ........%.......
    d0d0:	09cf012d 0a8f00a5 09cf0371 0a8f04e1     -.......q.......
    d0e0:	0a8f0365 09cf06d5 0a8f01b5 09cf04fd     e...............
    d0f0:	0a8f05f5 0a8f0045 09cf03b1 09cf0109     ....E...........
    d100:	09cf0009 09cf0355 0a0f03e9 0a0f0489     ....U...........
    d110:	09cf0079 09cf009d 09cf00d9 09cf0701     y...............
    d120:	09cf0261 09cf003d 09cf06a1 09cf00b9     a...=...........
    d130:	09cf00ad 09cf010d 098f01c5 0a8f0641     ............A...
    d140:	098f07f5 09cf005d 098f016d 09cf02c1     ....]...m.......
    d150:	010003fd 09cf04e5 098f0131 010003f5     ........1.......
    d160:	01000539 09cf04a1 06cf0021 07cf01e1     9.......!.......
    d170:	0bcf028d 01000785 00800099 070f023d     ............=...
    d180:	070f02b9 070f02fd 01400199 078f0695     ..........@.....
    d190:	014001cd 078f0339 0d4f053d 07cf01f5     ..@.9...=.O.....
    d1a0:	0f4f0359 080f0431 080f0475 0140035d     Y.O.1...u...].@.
    d1b0:	0140045d 084f03e5 014004a9 080f06e1     ].@...O...@.....
    d1c0:	01400599 01400625 01400655 014006a5     ..@.%.@.U.@...@.
    d1d0:	01400771 0140079d 014007c9 01800039     q.@...@...@.9...
    d1e0:	0f4f0475 0f4f057d 0f4f0591 0d0f00f1     u.O.}.O...O.....
    d1f0:	074f06b1 0acf00cd 0a8f0701 0a8f0705     ..O.............
    d200:	0a8f06f1 0a8f0705 0a8f077d 0a8f06dd     ........}.......
    d210:	0a8f0769 0a8f077d 0a8f0701 0acf05a1     i...}...........
    d220:	0acf058d 0acf05a1 0acf060d 0acf0579     ............y...
    d230:	0acf05f9 0acf05a1 0acf0541 0acf062d     ........A...-...
    d240:	0acf0639 0acf062d 0acf0609 0acf060d     9...-...........
    d250:	0acf0631 014007e1 06cf07b1 074f0635     1.....@.....5.O.
    d260:	01800061 01800075 018000a9 06cf0751     a...u.......Q...
    d270:	06cf0239 06cf079d 018000f9 01800479     9...........y...
    d280:	07cf0559 078f069d 080f0021 06cf0459     Y.......!...Y...
    d290:	070f0241 078f063d 01800685 01800695     A...=...........
    d2a0:	018006a5 018006b5 018006c5 018006d5     ................
    d2b0:	018006e9 01800735 074f06f9 068f0411     ....5.....O.....
    d2c0:	068f0435 068f039d 074f072d 0f4f0505     5.......-.O...O.
    d2d0:	0acf07f5 0f4f035d 0d8f010d 0d0f0151     ....].O.....Q...
    d2e0:	01c003c9 0f4f0515 0b4f01c1 0b4f00b9     ......O...O...O.
    d2f0:	0b4f013d 0b0f0759 0b0f0789 0b4f0015     =.O.Y.........O.
    d300:	0f4f0285 06cf0491 020001c9 020001d5     ..O.............
    d310:	020001e1 020001ed 020001f9 02000205     ................
    d320:	0200020d 02000215 02000265 02000271     ........e...q...
    d330:	02000279 02000281 02000289 02000291     y...............
    d340:	02000299 07cf034d 078f0649 07cf016d     ....M...I...m...
    d350:	0b8f0051 0b4f0771 0b8f00fd 0b8f0165     Q...q.O.....e...
    d360:	0b4f0405 0b4f02e5 0b4f0575 0b4f0621     ..O...O.u.O.!.O.
    d370:	0b8f019d 0b4f0519 0b4f01a1 0b4f0221     ......O...O.!.O.
    d380:	0b4f06bd 0b4f0401 0b4f03c9 0b8f0099     ..O...O...O.....
    d390:	078f0465 07cf0509 07cf0531 06cf021d     e.......1.......
    d3a0:	078f038d 06cf07e9 078f0269 06cf066d     ........i...m...
    d3b0:	078f050d 0f8f01c1 0f8f01c9 0f8f01cd     ................
    d3c0:	0f8f01d5 0f8f01d9 0f8f01e1 0f8f0265     ............e...
    d3d0:	0f8f0289 06cf0705 06cf0669 070f0259     ........i...Y...
    d3e0:	070f0271 070f00dd 074f0409 06cf06bd     q.........O.....
    d3f0:	0ccf0509 0ccf0515 020005f5 0ccf051d     ................
    d400:	02000671 0ccf065d 0ecf061d 0f0f026d     q...].......m...
    d410:	068f0561 06cf00a5 06cf022d 06cf0271     a.......-...q...
    d420:	024006f1 0f4f0125 0f4f010d 02800019     ..@.%.O...O.....
    d430:	028000ed 0f8f0309 078f07d5 078f04cd     ................
    d440:	084f07b9 098f019d 09cf0179 010002fd     ..O.....y.......
    d450:	06cf0769 06cf07e5 070f0029 078f03c5     i.......).......
    d460:	078f0731 080f0171 080f01a5 074f0435     1...q.......5.O.
    d470:	014005c5 01400609 06cf01a9 06cf058d     ..@...@.........
    d480:	01400641 01400655 01400689 06cf001d     A.@.U.@...@.....
    d490:	06cf0581 01800261 078f0489 078f0595     ....a...........
    d4a0:	070f0031 078f042d 018004f1 0180053d     1...-.......=...
    d4b0:	074f0501 068f0219 068f023d 068f01a5     ..O.....=.......
    d4c0:	078f071d 018005ed 078f0301 01c0027d     ............}...
    d4d0:	07cf01c1 078f04bd 078f07e1 078f076d     ............m...
    d4e0:	07cf03bd 07cf03e5 06cf00d1 078f0241     ............A...
    d4f0:	06cf069d 078f011d 06cf0521 078f04fd     ........!.......
    d500:	078f03a9 078f03b9 06cf05d1 06cf0535     ............5...
    d510:	070f0125 070f013d 078f0449 06cf058d     %...=...I.......
    d520:	020003ad 06cf0121 024005bd 074f03fd     ....!.....@...O.
    d530:	740a26ab 8098007f 78e07ee0 7ce026ab     .&.t.....~.x.&.|
    d540:	00400000 003f246f 7ce026ab 004f0000     ..@.o$?..&.|..O.
    d550:	003f246f 20aac0e1 70d30010 39020001     o$?.... ...p...9
    d560:	ffc207e8 007f40c3 20ab8c58 c0c10010     .....@..X.. ....
    d570:	0001382f 003f246f 78e078e0 007f40c3     /8..o$?..x.x.@..
    d580:	206b8000 702c0940 706c704c 70ac708c     ..k @.,pLplp.p.p
    d590:	70ec70cc 702d700d 706d704d 70ad708d     .p.p.p-pMpmp.p.p
    d5a0:	70ed70cd 702e700e 706e704e 70ae708e     .p.p.p.pNpnp.p.p
    d5b0:	70ee70ce 702f700f 254a700c 264a3000     .p.p.p/p.pJ%.0J&
    d5c0:	44db3000 11f00080 008042db 220a12f0     .0.D.....B....."
    d5d0:	007f8f80 20e28c10 706f0082 0f802022     ....... ..op" ..
    d5e0:	a3ac007f 048f065d 007fc1a4 0000013d     ....].......=...
    d5f0:	4508c2e8 85438102 0f833000 ccd03d4c     ...E..C..0..L=..
    d600:	0f803200 33333f73 00cc3001 81c0a583     .2..s?33.0......
    d610:	85028541 a5c18161 330281e1 36020003     A...a......3...6
    d620:	34011082 c47a1f80 41c30000 f17842cb     ...4..z....A.Bx.
    d630:	bbbfb8bf a5e2babf 056f0e86 00d03201     ..........o..2..
    d640:	8de0f643 70edf008 702c4d28 0c32764c     C......p(M,pLv2.
    d650:	ade0066f 10b00f2d 0f4b70cd 8d111051     o...-....pK.Q...
    d660:	41f441c3 68e1bb5d 0e564002 adf1056f     .A.A]..h.@V.o...
    d670:	000c0064 71048d14 1d12ad14 f03c1003     d......q......<.
    d680:	71048d13 780fad13 02f40883 8d154002     ...q...x.....@..
    d690:	01b4088f 4d28adc0 0be6702c 764c066f     ......(M,p..o.Lv
    d6a0:	0f85f042 8d101011 41f441c3 68e1bb5d     B........A.A]..h
    d6b0:	e0b278ef 1cad27ca 0e064002 adf0056f     .x...'...@..o...
    d6c0:	002c0064 083978ef 70cd0cb1 10431d00     d.,..x9....p..C.
    d6d0:	f02aadd0 71048d12 780fad12 01940819     ..*....q...x....
    d6e0:	081d8d14 70cd02f4 10831d00 add4add1     .......p........
    d6f0:	f01aadd2 e0e578ef 70cdf796 702c4d28     .....x.....p(M,p
    d700:	0b7e764c adc0066f 41c3f00e bb5d41f4     Lv~.o......A.A].
    d710:	054f0dae 8d15f6c8 ad157104 add3f004     ..O......q......
    d720:	de81add5 c6c840c1 6844706c a860702c     .....@..lpDh,p`.
    d730:	09017124 1a0400b2 b06a00d0 7fe0a064     $q........j.d...
    d740:	78e0a063 000001e9 4608c2f4 45288102     c..x.......F..(E
    d750:	30008624 3dcc0f82 3100ccd0 3f660f80     $..0...=...1..f?
    d760:	30016666 1e100094 85001500 1008160c     ff.0............
    d770:	866185e2 85218642 8581a601 00813102     ..a.B.!......1..
    d780:	8582a682 00c03002 8e80a683 10121504     .....0..........
    d790:	10131500 b8bfb9bf 00413001 12003702     .........0A..7..
    d7a0:	3101b8bf 22500000 235027d5 409127d6     ...1..P".'P#.'.@
    d7b0:	ec06702e 430e41c3 f005c2a1 420e41c3     .p...A.C.....A.B
    d7c0:	0cfec2a1 3602054f b8bf2540 434b41c3     ....O..6@%...AKC
    d7d0:	0ceef178 21ca056f 74ed2069 8502f69b     x...o..!i .t....
    d7e0:	0cde70ad 41a1056f 40c2f695 056f0cd2     .p..o..A...@..o.
    d7f0:	f6ca41a2 0cca4062 41a1056f f64b72ed     .A..b@..o..A.rK.
    d800:	f00973ed 0cba4042 41a1056f f64370ed     .s..B@..o..A.pC.
    d810:	3c0071ed 447a2f80 41c30000 00003f80     .q.<./zD...A.?..
    d820:	0c9e4310 4230056f 70adf60a 0c924062     .C..o.0B...pb@..
    d830:	41a1056f 24c0220a 42b1f642 08316f0a     o..A.".$B..B.o1.
    d840:	70ad00b5 3f7a41c3 0c76e148 4042056f     ...p.Az?H.v.o.B@
    d850:	002a004a 41c34042 147b3eae 054f0c62     J.*.B@.A.>{.b.O.
    d860:	41c3f6dd f178434b f01540a2 41c3ef98     ...AKCx..@.....A
    d870:	e1483f7a 056f0c4a f6514042 3eae41c3     z?H.J.o.B@Q..A.>
    d880:	0c3e147b 4042056f 41c3f6c9 f178434b     {.>.o.B@...AKCx.
    d890:	0c2e40c2 71ad054f 70adf682 2051082b     .@..O..q...p+.Q 
    d8a0:	71048e14 780fae14 02f40843 8e16706c     ...q...xC...lp..
    d8b0:	02f40869 ae604e2c ae76ae77 ae74ae75     i...,N`.w.v.u.t.
    d8c0:	10431e18 0863f031 092f2011 ed042010     ..C.1.c.. /.. ..
    d8d0:	e8138e18 71048e15 780dae15 0412084b     .......q...xK...
    d8e0:	13c31e15 10431e17 093ff01f 8e162010     ......C...?.. ..
    d8f0:	ae167104 8e15f019 262f7704 002af005     .q.......w/&..*.
    d900:	ae150023 10031e15 e80f8e17 10031e17     #...............
    d910:	1e00ed0b f0091043 754c702c 066f0962     ....C...,pLub.o.
    d920:	d881ae60 700ced82 78e0c6d4 6844706c     `......p...xlpDh
    d930:	a860702c 09017124 1a0400f2 a87800d0     ,p`.$q........x.
    d940:	7fe0a065 78e0a064 00000341 c1afc3f0     e...d..xA.......
    d950:	45084130 224a48dc 244a0000 c08b7100     0A.E.HJ"..J$.q..
    d960:	018020a8 04031104 00d01804 244ac487     . ............J$
    d970:	700c7100 024020a8 10012515 2415812f     .q.p. @..%../..$
    d980:	71041003 c384a320 10802515 23158002     ...q ....%.....#
    d990:	71440081 80f20af5 141ca100 70ed3010     ..Dq.........0.p
    d9a0:	a7fe2050 de7ff21e 4002be17 056f0b12     P .........@..o.
    d9b0:	0380210a 244af216 c08b7100 01c020a8     .!....J$.q... ..
    d9c0:	39008020 18040401 c0880050 8040702c      ..9....P...,p@.
    d9d0:	3a007124 09fb0402 180480f2 c6470090     $q.:..........G.
    d9e0:	c204c105 c142c006 c043c241 c181c380     ......B.A.C.....
    d9f0:	8041c080 0fff71e5 180490f2 708d0090     ..A..q.........p
    da00:	1108c443 244a200b c28b7100 02c020a8     C.... J$.q... ..
    da10:	04001204 330083c0 36011000 1b041000     .......3...6....
    da20:	c3880010 1304c281 c000040e 300082e0     ...............0
    da30:	37020380 71851000 90f20cef 00101a04     ...7...q........
    da40:	81608141 c0008122 c344c245 a505c146     A.`."...E.D.F...
    da50:	12022540 c184700c 04031104 08fd7104     @%...p.......q..
    da60:	1a0480f2 8d1800d0 ad386821 40308de4     ........!h8...0@
    da70:	8d19ef04 ad197104 850585c7 421041c1     .....q.......A.B
    da80:	056f0a3e 004a41d1 4042002c 30018509     >.o..AJ.,.B@...0
    da90:	43fe0f81 4042edd6 056f0a26 21ca4130     ...C..B@&.o.0A.!
    daa0:	1d1c248b 15281440 70cd1080 1554e8b8     .$..@.(....p..T.
    dab0:	212f1080 08130407 0fc50044 15551010     ../!....D.....U.
    dac0:	0abd1082 1d280045 ad181043 09f2f085     ....E.(.C.......
    dad0:	8528056f 002a0076 0407212f 30018509     o.(.v.*./!.....0
    dae0:	c3fe0f8e 4042edd6 056f09d6 26ca41c1     ......B@..o..A.&
    daf0:	a5c81489 10801528 0031088d 155470cd     ....(.....1..pT.
    db00:	212f1080 08110407 ef3a0044 10821555     ../!....D.:.U...
    db10:	00450a6d 10831d28 f05fad18 00b108bb     m.E.(....._.....
    db20:	0407222f 10811554 008509af 10801556     /"..T.......V...
    db30:	780f6038 008208a3 10801529 1d297104     8`.x....)....q).
    db40:	1d281002 ad381043 1554f047 080d1080     ..(.C.8.G.T.....
    db50:	15280045 ea331082 10821556 780f6058     E.(...3.V...X`.x
    db60:	00607110 700c002c 10811529 0947e923     .q`.,..p)...#.G.
    db70:	ef2a0115 ad19ad04 f01f72cd 13821d28     ..*......r..(...
    db80:	f02badd8 00710853 0407222f 10811554     ..+.S.q./"..T...
    db90:	00850947 10801556 780f6038 0082083b     G...V...8`.x;...
    dba0:	10801529 1d297104 1d281002 ad381083     )....q)...(...8.
    dbb0:	73cdf013 70edad04 70edf00a ade4ad18     ...s...p...p....
    dbc0:	f00b70cd ade471ed 71cdad19 10021d29     .p...q.....q)...
    dbd0:	1d28ad18 85091002 2f813200 d7003c23     ..(......2./#<..
    dbe0:	0f803000 70a43f7d 00133101 24c03102     .0..}?.p.1...1.$
    dbf0:	3f7542d3 3000c28f 40d30480 bb5d42f4     .Bu?...0...@.B].
    dc00:	20003301 24013301 41304410 056f08b2     .3. .3.$.D0A..o.
    dc10:	14c01d24 250921ca 14401d1c 204f8508     $....!.%..@...O 
    dc20:	330227d0 30002000 33010480 33022401     .'.3. .0...3.$.3
    dc30:	41102000 056f088a 20ca4030 1d20244b     . .A..o.0@. K$ .
    dc40:	ef8c1400 10811557 09118d19 700c0025     ....W.......%..p
    dc50:	ad19ad04 10021d28 714c702c ad38ee08     ....(...,pLq..8.
    dc60:	10b10e0d 10421d28 704cd981 208c8500     ....(.B...Lp... 
    dc70:	20b98f83 763c0f83 80be2005 00be208a     ... ..<v. ... ..
    dc80:	780f70dd 78e0c7d0 2040706c 702c0202     .p.x...xlp@ ..,p
    dc90:	a864a060 09017124 1a0400f2 41c300d0     `.d.$q.........A
    dca0:	0000447a a878a065 a027a879 44cbb99f     zD..e.x.y.'....D
    dcb0:	de78007f 244aa028 20407100 41810b02     ..x.(.J$.q@ ...A
    dcc0:	00c01824 00c21829 00c21828 018020a8     $...)...(.... ..
    dcd0:	04031104 00d01a04 0f032040 7100244a     ........@ ..J$.q
    dce0:	14012440 018020a8 04021104 00901b04     @$... ..........
    dcf0:	0406218a 0044184c 184ed93c 18500505     .!..L.D.<.N...P.
    dd00:	218a0044 18520d07 d9640044 00421857     D..!..R.D.d.W.B.
    dd10:	1856d950 18550303 7fe00103 00421854     P.V...U.....T.B.
    dd20:	4608c2ec 45cb70ed 1b440080 008041d3     ...F.p.E..D..A..
    dd30:	262f21a4 f212f048 20401900 7440244a     .!/&H.....@ J$@t
    dd40:	0000214a 01c020a8 25147830 71241000     J!... ..0x.%..$q
    dd50:	78e0b0e0 000004af e0a19e01 f686700c     ...x.........p..
    dd60:	08fa9d22 710c0f6f 9e01b502 700ce0a7     "...o..q.......p
    dd70:	9d23f685 0f6f08e6 b503710c e0ad9e01     ..#...o..q......
    dd80:	f686700c 08d69d24 710c0f6f 9e02b504     .p..$...o..q....
    dd90:	700ce0a1 9d25f685 0f6f08c2 b505710c     ...p..%...o..q..
    dda0:	700e9e03 700ce0a1 9d26f685 0f6f08ae     ...p...p..&...o.
    ddb0:	b506710c 08119e03 710c09f2 0f6f089e     .q.........q..o.
    ddc0:	40109d27 14041d0e 704e9e04 700ce0ad     '..@......Np...p
    ddd0:	9d28f685 0f6f0886 b508710c e88d9600     ..(...o..q......
    dde0:	e88b9601 e8899602 e8879603 086e9d09     ..............n.
    ddf0:	712c0f6f 1d124210 950a1484 b50a781b     o.,q.B.......x..
    de00:	090b9e23 e00809d2 952bb50a b52b793b     #.........+.;y+.
    de10:	0a0b9e44 722409d2 9d4cb52b e290700e     D.....$r+.L..p..
    de20:	0052706c 704c002b 262f706c f20ef008     lpR.+.Lplp/&....
    de30:	7a70706c 00432044 0f802004 fffe0000     lppzD C.. ......
    de40:	202f635b f5f78002 262f704c f20ef048     [c/ ....Lp/&H...
    de50:	7850704c 00422144 2104621a 00000f80     LpPxD!B..b.!....
    de60:	212ffffe f5f78002 23d20a0b 785d7a50     ../!.......#Pz]x
    de70:	9500621a 035ee087 2025000d f0090000     .b....^...% ....
    de80:	f013f00d f02ff020 f046f03b 9e00f051     .... ./.;.F.Q...
    de90:	087208b9 b520712c 9e00f05e 031308bd     ..r.,q .^.......
    dea0:	00200227 9e00b5e0 085208cd 10451d00     '. .......R...E.
    deb0:	0408202f 724c722c 0f2f09a6 02754010     / ..,rLr../..@u.
    dec0:	95200020 e0a69e01 00290110 9e05726c      . .......).lr..
    ded0:	00fee0ac 762c002c 02d5b520 1d020020     ....,.,v ... ...
    dee0:	9e0010c5 085208a1 10451d00 0408202f     ......R...E./ ..
    def0:	724c742c 0f2f096a 95204010 9e00f04b     ,tLrj./..@ .K...
    df00:	09d208a1 08df9d0e d90707b3 00200211     .............. .
    df10:	10451d00 0f469d30 710c0f2f b5ecb510     ..E.0.F./..q....
    df20:	0c919e80 025d1692 1d000020 9e051045     ......]. ...E...
    df30:	09f20893 762c700c 1d00714c 09221185     .....p,vLq....".
    df40:	1d020f2f f0be1145 08a19e05 762c0b72     /...E.......r.,v
    df50:	b5e1b520 00000275 e0a79e05 002b0276      ...u.......v.+.
    df60:	762c700c 1d00714c 08f61185 1d020f2f     .p,vLq....../...
    df70:	f0ab1045 08f39e05 762c0072 1d02b520     E.......r.,v ...
    df80:	f0d81085 08739e05 762c09f2 1d02b520     ......s...,v ...
    df90:	714c1105 0f2f08ca 023b4002 b5ed0020     ..Lq../..@;. ...
    dfa0:	087d9e05 762c0b72 1d02b520 f0bf1145     ..}.r.,v ...E...
    dfb0:	0b7b9e64 952109f2 f4e37534 11451d00     d.{...!.4u....E.
    dfc0:	9e24f0e0 08520991 11451d00 9e02f07d     ..$...R...E.}...
    dfd0:	0202e0a0 706c002a 732c700c b560724c     ....*.lp.p,sLr`.
    dfe0:	b520f0e3 f0a3b5ef 089d9d02 722c00f2     .. ...........,r
    dff0:	4030b520 7850f0ea 03b4087d 08797870      .0@..Px}...pxy.
    e000:	9d0d0095 0070e0e3 204a0029 e08e2380     ......p.).J .#..
    e010:	ffe906dc 11451d00 f16a4010 08779d04     ......E..@j...w.
    e020:	1d000152 740e1085 1602f07a 21781148     R......tz...H.x!
    e030:	207f008b 220b1802 f43482c0 0a659d42     ... ..."..4.B.e.
    e040:	9d4500d3 00d20a9d 7234b9a0 1d00f499     ..E.......4r....
    e050:	f09810c5 60389e00 00f3084f 752c700c     ......8`O....p,u
    e060:	b5e0724c 9d05f02b 00f20867 1d007870     Lr..+...g...px..
    e070:	f12010c5 e08a9d03 204af69a 1d002240     .. .......J @"..
    e080:	f1361085 08719d05 732c00f2 720eb520     ..6...q...,s ..r
    e090:	9e02f09c 09f20875 1d007870 f04010c5     ....u...px....@.
    e0a0:	10851d00 9d0ff06e 8d42208c 002b0126     ....n.... B.&.+.
    e0b0:	752c700c 1d00724c 0fa61045 b5ee0ecf     .p,uLr..E.......
    e0c0:	71149500 700cf287 724c712c 086bf081     ...q...p,qLr..k.
    e0d0:	1d0002d4 9d0d1105 2049b5ed f0380250     ..........I P.8.
    e0e0:	0a719d46 639b00f2 01110997 11051d00     F.q....c........
    e0f0:	f048b5ed 08bd7870 742c0334 9d0db520     ..H.px..4.,t ...
    e100:	2049b5ed f0620250 02d408cb 08c79d0e     ..I P.b.........
    e110:	204a02b3 1d002240 b5ed1105 724c752c     ..J @"......,uLr
    e120:	0eef0f3e b5ee4002 e1879520 006121ca     >....@.. ....!a.
    e130:	4002714c 9e04f04d 09d30813 9e029e41     Lq.@M.......A...
    e140:	60589e23 088f6038 b5e00653 ffcf0565     #.X`8`..S...e...
    e150:	16069e42 7301114b 627a9ec5 108b2300     B...K..s..zb.#..
    e160:	0e1f7661 e90d14d2 0132086b 0ef2700c     av......k.2..p..
    e170:	724c0eef 08919501 b5ee0151 b5e0f047     ..Lr....Q...G...
    e180:	762c700c 0eda724c b5f00eef 95009521     .p,vLr......!...
    e190:	00400843 01510909 f005b5ee 01110907     C.@...Q.........
    e1a0:	700cb5ed 0eba724c 95200ecf f010700c     ...pLr.... ..p..
    e1b0:	080d7850 9d080315 02d2081b b520752c     Px..........,u .
    e1c0:	b5ee9d0e 03502049 0408202f 0e92714c     ....I P./ ..Lq..
    e1d0:	40260ecf 68419d2d 0c82710c 19000f2f     ..&@-.Ah.q../...
    e1e0:	b50d2080 0c769d2e 710c0f2f 9d2fb50e     . ....v./..q../.
    e1f0:	0f2f0c6a b50f710c 0c629d2c 710c0f2f     j./..q..,.b./..q
    e200:	c6ccb50c 01110807 b5e1b5ed 78e0f1ba     ...............x
    e210:	9045c2ea 43484728 8004228c 9024f785     ..E.(GHC."....$.
    e220:	8fc3218c 8040f713 0a1b706c dd3f02f2     .!....@.lp....?.
    e230:	dd359024 f787e1e3 e0f99006 002600a0     $.5...........&.
    e240:	702cdd23 70cd704c 9063f0ac 8550238c     #.,pLp.p..c..#P.
    e250:	000d004a e2e49046 002d00a0 dd25de08     J...F.....-...%.
    e260:	85c2218c 8080f799 9e02248c 002900fa     .!.......$....).
    e270:	90a2e2c8 9b08258c 002d0134 e3e240b1     .....%..4.-..@..
    e280:	002d01b2 a881208c 002d0256 0282e3b9     ..-.. ..V.-.....
    e290:	dd0d0026 0305de2d 80800000 9e97248c     &...-........$..
    e2a0:	0029007c 712c90a2 1f850d8b 10240000     |.)...,q......$.
    e2b0:	73cd9006 00d2e0c2 da37002d 000073d3     ...s....-.7..s..
    e2c0:	012e0d7c da36002d 258cda0b 01989419     |...-.6....%....
    e2d0:	72cd0026 025ddb0c 75cd0020 09b30a51     &..r..]. ..uQ...
    e2e0:	208cde2c 007c8c82 dd28002d 025ce28f     ,.. ..|.-.(...\.
    e2f0:	de22002b f037dd17 76cd8020 e18ddd37     +."...7. ..v7...
    e300:	218cf68c 008a8b02 de390029 72ad9002     ...!....).9....r
    e310:	8fc3208c de26f702 00000281 1f850d3d     . ....&.....=...
    e320:	13bd0000 da35726c f04070ad de2a75ad     ....lr5..p@..u*.
    e330:	da3bf019 1f850d71 285d0000 1f850db9     ..;.q.....](....
    e340:	13ec0000 9a15238c 0026014c db3473cd     .....#..L.&..s4.
    e350:	70adda07 f026702c 736cd93c f17470ad     ...p,p&.<.ls.pt.
    e360:	023bdd13 00980000 de0a002d 72ad756c     ..;.....-...lu.r
    e370:	1f840bbd 09fe0000 202f9022 08b102c2     ........"./ ....
    e380:	db270045 70adf054 702c716c 238cf00a     E.'.T..plq,p...#
    e390:	008a8689 de2f0026 706c70ad 764c702c     ....&./..plp,pLv
    e3a0:	000001ff 716c70ad f14f722c 72adde30     .....plq,rO.0..r
    e3b0:	1f840b7b 0c3c0000 052f0b1a 43c34061     {.....<.../.a@.C
    e3c0:	80004046 04ef0b16 2840704c 41102182     F@......Lp@(.!.A
    e3d0:	0b024040 4030052f 43204200 0c8e4022     @@../.0@.B C"@..
    e3e0:	4102056f 002c0046 de0adb29 70adf020     o..AF.,.)... ..p
    e3f0:	f0f6766c db3b70ad f127724c 0bb9716c     lv...p;.Lr'.lq..
    e400:	00001f85 de1f088e 9b43248c 002b0124     .........$C.$.+.
    e410:	de16724c 702c71ad 9002f0c3 80ce208c     Lr...q,p..... ..
    e420:	002600b2 de0eda2d 706cf057 724c702c     ..&.-...W.lp,pLr
    e430:	208cf0b7 00aea703 de0d002d 015ce49c     ... ....-.....\.
    e440:	dd27002b e2c7dd10 218cf789 014a8307     +.'........!..J.
    e450:	de11002d 208cde14 0140a002 de1f0005     -...... ..@.....
    e460:	f09cdd0a 0d75088d 9243248c 002900a8     ......u..$C...).
    e470:	02c2202f 72c1263c 09fd0000 0340203c     / ..<&.r....< @.
    e480:	f471790b 0ddfde2d 00001f85 71ad0c3c     .yq.-.......<..q
    e490:	f085db0b e0cc9006 002d0068 0b9bda35     ........h.-.5...
    e4a0:	00000f85 248c1650 00c2908b da0e002a     ....P..$....*...
    e4b0:	f095db2f 9e44248c 0029004c 9002de09     /....$D.L.).....
    e4c0:	208cda26 f7898fcd 71adde2a da08702c     &.. ....*..q,p..
    e4d0:	de2af067 70adda11 702c706c 74adf061     g.*....plp,pa..t
    e4e0:	238cf006 00588b02 72ad0026 f056de34     ...#..X.&..r4.V.
    e4f0:	9d43248c 002a005c 71adde31 f150726c     .$C.\.*.1..qlrP.
    e500:	f06ddb08 766c71ad da09702c de10f049     ..m..qlv,p..I...
    e510:	f044dd1c 9fc9248c 0009005c 1f850d8f     ..D..$..\.......
    e520:	09f80000 000073d3 00a40932 db1d0026     .....s..2...&...
    e530:	702c72ad db0cf035 f051da33 0040e2c3     .r,p5...3.Q...@.
    e540:	de070026 706cdd07 704c702c f029de13     &.....lp,pLp..).
    e550:	9f85248c db07f65b 71adda2e 73cd702c     .$..[......q,p.s
    e560:	de0af01f 71addb29 0d49f019 db1510e5     ....)..q..I.....
    e570:	f035da27 da1edb12 f03272ad 8c5f218c     '.5......r2..!_.
    e580:	75adf75c 714cde27 248cf1a8 f6599a49     \..u'.Lq...$I.Y.
    e590:	da0fdb1f dd0df023 702c706c b7a0704c     ....#...lp,pLp..
    e5a0:	b722b761 b7c4b743 05a9c6ca db2dffef     a.".C.........-.
    e5b0:	db28da13 f01570ad dd08da1e 0b1bf18e     ..(..p..........
    e5c0:	00000f85 db140ebd f009da26 da3371cd     ........&....q3.
    e5d0:	ffef0583 da13756c 70addb28 046b702c     ....lu..(..p,pk.
    e5e0:	78e0ffcf 46cbc3e4 3b380080 10031e01     ...x...F..8;....
    e5f0:	0c9d8e80 c1a41030 01150b95 00100a91     ....0...........
    e600:	43c38040 cccd3dcc 00c23200 008045cb     @..C.=...2...E..
    e610:	a5403ae8 32008041 a54100c2 734c8002     .:@.A..2..A...Ls
    e620:	00c03000 8100a502 3d7943c3 3000db23     .0.......Cy=#..0
    e630:	b8bf00c0 8101c040 00c03000 c041b8bf     ....@....0....A.
    e640:	c0808182 10c33400 bbbf702c 0a6f0ce2     .....4..,p....o.
    e650:	0842c342 24400020 140f33c1 4dbc3082     B.B. .@$.3...0.M
    e660:	002009aa 42c340a1 12a10080 ae018a20     .. ..@.B.... ...
    e670:	ae224d1c a52b8020 a52c8524 a52d8525     .M". .+.$.,.%.-.
    e680:	8a218566 08cea56e aa2c0aef c7c4700c     f.!.n.....,..p..
    e690:	45cbc2e8 3ae40080 470885c0 1b0c2680     ...E...:...G.&..
    e6a0:	40308602 04ef0e1a f65541e1 0e128600     ..0@.....AU.....
    e6b0:	41e104ef 8601f652 04ef0e06 004241e1     ...AR........AB.
    e6c0:	1800000a 85002103 020d2080 a5149000     .....!... ......
    e6d0:	1800f00e f0042043 20831800 68298513     ....C ..... ..)h
    e6e0:	8514a533 080f7704 a5140032 21031800     3....w..2......!
    e6f0:	090bf005 18000012 700c20c3 1800c6c8     ......... .p....
    e700:	850020c3 018d2080 f1ec9020 008041c3     . ... .. ....A..
    e710:	892012a1 7fe0a820 78e0700c 008041c3     .. . ....p.x.A..
    e720:	892012ac 7fe0a820 78e0700c 008041c3     .. . ....p.x.A..
    e730:	81403ea8 a0404300 a3018101 700c8122     .>@..C@....."..p
    e740:	a3227fe0 c1a6c3e8 008040d3 db7f3b3c     .."......@..<;..
    e750:	20001800 40c370ad 3eec0080 008047cb     ... .p.@...>.G..
    e760:	b0a03e98 a0a2a8ac 008046cb b0a21288     .>.......F......
    e770:	702cb0a3 6f04da18 afa0bb17 a6a1a76b     ..,p...o....k...
    e780:	05ef0afe 710ca76c ae10ae0c 000040c3     ....l..q.....@..
    e790:	a6057530 b6a4700c 13441e0a 13051e0e     0u...p....D.....
    e7a0:	2715790f 71041041 790fa1b1 80f409f5     .y.'A..q...y....
    e7b0:	7280244a 028020a8 261578af 00807000     J$.r. ...x.&.p..
    e7c0:	71a53e70 00011800 0aaf0f8a 700c4f3c     p>.q........<O.p
    e7d0:	a70fa70e d83fa710 10008751 b818200b     ......?.Q.... ..
    e7e0:	87738792 c041c040 3f3440c3 c042fdf4     ..s.@.A..@4?..B.
    e7f0:	c180c243 1ec22355 21002040 0aeec444     C...U#..@ .!D...
    e800:	c3450020 c7c8700c 8080c2e2 008043c3      .E..p.......C..
    e810:	a3803e9c a3818081 a3028002 a3068100     .>..............
    e820:	a3078101 a3088102 008040c3 81831288     .........@......
    e830:	a3898830 0071090b 097aa858 45cb0000     0.....q.X.z....E
    e840:	3ef40080 e8048d02 0dcf0e62 e8048d01     ...>....b.......
    e850:	00000842 40c38d20 3b3c0080 01b00917     B... ..@..<;....
    e860:	091970ad 091d0090 08da0111 71ad00c0     .p.............q
    e870:	0eeaf00b f0090080 00800fa6 f00571ad     .............q..
    e880:	08f2e983 08b200c0 40a10000 78e0c6c2     ...........@...x
    e890:	704cc0f1 008040c3 a8403ef4 8803a841     ..Lp.@...>@.A...
    e8a0:	008041c3 a140128c 40c3e806 3b3c0080     .A....@....@..<;
    e8b0:	00c00966 7fe0c0d1 78e0700c c1a6c3e8     f........p.x....
    e8c0:	45cb8080 3ea80080 8061a580 008046cb     ...E...>..a..F..
    e8d0:	a5613b3c c1808042 80e3a542 c4406e04     <;a.B...B....n@.
    e8e0:	a5e7c341 0b524010 c2420e2f 0b5e4002     A....@R./.B..@^.
    e8f0:	41e10020 c2838600 0e812056 00c0204a      ..A....V ..J ..
    e900:	0403111c 08fd7104 1a0481b4 c18300d0     .....q..........
    e910:	0e2f0dfe 43c34002 3ef40080 e8888b00     ../..@.C...>....
    e920:	c101c200 a54ac002 a50ca52b 1b04700c     ......J.+....p..
    e930:	c7c80043 c1a1c3e8 008042c3 6a043b3c     C........B..<;.j
    e940:	0da2c180 82c00e2f 008045cb 8dfb1288     ..../....E......
    e950:	c000ef97 0b6a8623 401004ef 730cf643     ....#.j....@C..s
    e960:	8622f010 04ef0b5a f6444002 f00a720c     ..".Z....@D..r..
    e970:	0b4e8621 400204ef 710cf643 700cf002     !.N....@C..q...p
    e980:	09198d3c ad190071 ad1a8d2c 0815e90a     <...q...,.......
    e990:	1d1c00d1 f00b1003 1d1aef07 f0071003     ................
    e9a0:	10431d1c 1d1af003 700c10c3 78e0c7c8     ..C........p...x
    e9b0:	c1a6c3e4 008045cb c1833b40 0e2f0a6a     .....E..@;..j./.
    e9c0:	c18040a1 0e2f0a86 c00140a1 c302c100     .@..../..@......
    e9d0:	00023000 00403100 00813001 00c03300     .0...1@..0...3..
    e9e0:	800b3101 40c3f222 3e9c0080 8041c104     .1.."..@...>..A.
    e9f0:	8080c303 c60580a2 00413202 10c03402     .........2A..4..
    ea00:	00413100 00003000 00413001 13803502     .1A..0...0A..5..
    ea10:	00003000 00003101 02c03800 70013602     .0...1...8...6.p
    ea20:	00003f80 f005b9bf 42c841c3 42c30000     .?.......A.B...B
    ea30:	12a80080 a220700c 78e0c7c4 c1a1c3ea     .....p ....x....
    ea40:	008045cb 8d101288 47cb712e 12a80080     .E.......q.G....
    ea50:	8d1be808 10101700 d93fe819 f019b918     ..........?.....
    ea60:	008046cb 41c33b3c 3e9c0080 c2806e04     .F..<;.A...>.n..
    ea70:	0def0daa c1004030 20401830 0a428600     ....0@..0.@ ..B.
    ea80:	800004ef f65870cd d97ff011 0a32b917     .....pX.......2.
    ea90:	400204ef f60371cd 41c370cd 00004396     ...@.q...p.A.C..
    eaa0:	04ef0a1e 41d14002 710cf6c6 10051d0e     .....@.A...q....
    eab0:	f010af04 71049507 7810b507 700ce08d     .......q...x...p
    eac0:	1d0ef785 af041305 1f04f003 41d11043     ............C..A
    ead0:	14421d1b 78e0c7ca 008040c3 804012b0     ..B....x.@....@.
    eae0:	7fe0700c 78e0a140 c1a9c3e8 46484428     .p..@..x....(DHF
    eaf0:	489c4708 716c764c 0a6f0c96 27554081     .G.HLvlq..o..@U'
    eb00:	764c1b41 0c8a766c 40c10a6f 764c4fcc     A.Lvlv..o..@.OLv
    eb10:	0c7e766c 40c10a6f 030c208a 60f870ad     lv~.o..@. ...p.`
    eb20:	714c732c 0a6f0cca 208a43a1 60f8060c     ,sLq..o..C. ...`
    eb30:	714c732c 0a6f0cba 208a43a1 60f80b07     ,sLq..o..C. ...`
    eb40:	764c762c 0a6f0caa 208a43a1 60f8010b     ,vLv..o..C. ...`
    eb50:	764c732c 0c9a43a1 40100a6f 0beec080     ,sLv.C..o..@....
    eb60:	732c0a6f c080738c 706c704c 76cc4580     o.,s.s..Lplp.E.v
    eb70:	0a6f0c3a 736c4102 704cc080 45604460     :.o..Als..Lp`D`E
    eb80:	0c2a76cc 41020a6f 714c762c 0d6a766c     .v*.o..A,vLqlvj.
    eb90:	40c10a6f 10181fc9 714c762c 0d5a736c     o..@....,vLqlsZ.
    eba0:	40c10a6f 10181fca 008041c3 08c212b0     o..@.....A......
    ebb0:	40e10020 1b0c2780 1f00700c c7c81043      ..@.'...p..C...
    ebc0:	4708c2e8 4448766c 0105208a 671a4030     ...GlvHD. ..0@.g
    ebd0:	1b402755 0b264460 41810a6f 0507208a     U'@.`D&.o..A. ..
    ebe0:	4f1c671d 766c714c 0a6f0ba6 208a41a1     .g.OLqlv..o..A. 
    ebf0:	671e010b 704c738c 4580706c 400276cc     ...g.sLplp.E.v.@
    ec00:	0a6f0baa 208a41c1 671a060c 768c736c     ..o..A. ...gls.v
    ec10:	40c171ac 0a6f0a72 41c341a1 12b00080     .q.@r.o..A.A....
    ec20:	0020084e 700c40e1 78e0c6c8 0b422055     N. ..@.p...xU B.
    ec30:	78c0244a 20a8e024 100401c0 1a040401     J$.x$.. ........
    ec40:	7fe00050 78e0700c 0f823100 00003f00     P....p.x.1...?..
    ec50:	a044a043 0f823100 fdf43f34 42c3a045     C.D..1..4?..E..B
    ec60:	12b00080 7fe0700c 78e0a220 8044c2e2     .....p.. ..x..D.
    ec70:	80858063 00823200 00c03300 00823001     c....2...3...0..
    ec80:	13003400 00003201 04ef0cc2 a5004528     .4...2......(E..
    ec90:	c6c2700c c1a2c0f1 008044cb 145835e4     .p.......D...5X.
    eca0:	14541007 14501006 144c1005 84631004     ..T...P...L...c.
    ecb0:	84218442 c0418480 09924081 1c000aaf     B.!...A..@......
    ecc0:	c0a23041 7fe0c0d1 78e0700c 40c3c0f1     A0.......p.x...@
    ecd0:	13640080 008041c3 49121bb4 05af0da2     ..d..A.....I....
    ece0:	0812702c 0de20000 c0d100c0 78e07ee0     ,p...........~.x
    ecf0:	c1a1c3e8 007f40c3 e833de10 007f46cb     .....@....3..F..
    ed00:	0f7adc2c 40c103ef 8e03e8ac 00f4080f     ,.z....@........
    ed10:	87a06ee4 120f2640 45cbf010 237c0060     .n..@&.....E`.|#
    ed20:	00000019 4002c380 7d6041c1 6e034281     .......@.A`}.B.n
    ed30:	0040206c e708671f 70d587c1 0021001a     l @..g.....p..!.
    ed40:	27408780 f6301210 702c7ad3 05af0d32     ..@'..0..z,p2...
    ed50:	470a4081 ec05f1f2 68e46f04 700cf1ee     .@.G.....o.h...p
    ed60:	78e0c7c8 c1a5c3e4 70c11600 1fe40080     ...x.......p....
    ed70:	0033093d c0804508 5aa4c680 34c02440     =.3..E.....Z@$.4
    ed80:	14135aa3 382f3080 c0430003 0000204a     .Z...0/8..C.J ..
    ed90:	71048620 0f813900 ac123c20 80f208f5      ..q.9.. <......
    eda0:	10501e04 d8fa8548 5acdc180 08af0bea     ..P.H......Z....
    edb0:	c7c440a1 008040c3 18003f5c 00800f80     .@...@..\?......
    edc0:	68241414 1900e008 00800f80 18001540     ..$h........@...
    edd0:	00800f80 40c3166c 218c0080 0f801800     ....l..@...!....
    ede0:	17980080 008040c3 18002190 00800f80     .....@...!......
    edf0:	40c318c4 21940080 0f801800 19f00080     ...@...!........
    ee00:	70451e00 21880080 0e4f0089 c1a1c3e6     ..Ep...!..O.....
    ee10:	008046cb 86401fb4 47084528 00600a7b     .F....@.(E.G{.`.
    ee20:	30031c03 9002258c d912f403 258cf007     ...0.%.........%
    ee30:	f4049fc3 f003d911 40e1d910 07af0dee     ...........@....
    ee40:	30421c03 5aa2740c 9002258c dcb7f403     ..B0.t.Z.%......
    ee50:	d940f00c 30c22440 40e1716c 14035abf     ..@.@$.0lq.@.Z..
    ee60:	b8c33080 014c204f 2440d940 716c30c2     .0..O L.@.@$.0lq
    ee70:	1c0340e1 5ac13302 5aa2710c 2440d96c     .@...3.Z.q.Zl.@$
    ee80:	716c30c2 1c0340e1 5ac13003 9002258c     .0lq.@...0.Z.%..
    ee90:	710cf403 a6a05aa2 78e0c7c6 c1a1c3e6     ...q.Z.....x....
    eea0:	008045cb 85201268 70cd4708 702ce92e     .E..h. ..G.p..,p
    eeb0:	30c22440 40e1716c de225abf 1403e8a6     @$.0lq.@.Z".....
    eec0:	de213080 0080206c 8403208c d9b6f41e     .0!.l ... ......
    eed0:	07af0d5a 730c40e1 70cd5aa2 2440d97f     Z....@.s.Z.p..@$
    eee0:	716c30c2 1c0340e1 5ac13382 5aa2710c     .0lq.@...3.Z.q.Z
    eef0:	07ef0bda 702c40e1 ffef0f16 702c40e1     .....@,p.....@,p
    ef00:	07ef0c42 a5c040e1 c7c640c1 c1a1c3f6     B....@...@......
    ef10:	d9b670ad 1c034310 0d123342 1c0007af     .p...C..B3......
    ef20:	47083344 5aa2d83c 0d02d911 406207af     D3.G<..Z......b@
    ef30:	d83c4608 d9085aa2 07ef0a72 40104062     .F<..Z..r...b@.@
    ef40:	09aed90c 406207ef 260066fe 712c1412     ......b@.f.&..,q
    ef50:	0015204e 214adf12 40d328c0 12680080     N ....J!.(.@..h.
    ef60:	21ab70cd 25400a61 d96d134c 30c22440     .p.!a.@%L.m.@$.0
    ef70:	4062716c 33021c03 d8325ac1 79ef5aa2     lqb@...3.Z2..Z.y
    ef80:	726cc280 47304062 25405abf 1400124c     ..lrb@0G.Z@%L...
    ef90:	14013094 d96d30d6 30c22440 4062716c     .0...0m.@$.0lqb@
    efa0:	33021c03 d8325ac1 c2805aa2 4062726c     ...3.Z2..Z..lrb@
    efb0:	5abf41e2 1401c220 d86030c3 25610a71     .A.Z ....0`.q.a%
    efc0:	24401800 22002e40 05012005 02002b40     ..@$@..". ..@+..
    efd0:	78227845 07c12842 78276038 10b10d13     Ex"xB(..8`'x....
    efe0:	208c7810 f78c8a19 7ecfbe82 0811f008     .x. .......~....
    eff0:	00000f84 78cf0cce 034e200f 71a5710c     .......x. N..q.q
    f000:	0d6772e5 20ab90f2 d9b60a61 07af0c1e     .rg.... a.......
    f010:	d83c4062 0e195aa2 d861103e 091179cf     b@<..Z..>.a..y..
    f020:	d862007e 00be0909 720cd864 78e0c7d6     ~.b.....d..r...x
    f030:	c1a1c3e6 d9b670ad 0bf24708 1c0307af     .....p...G......
    f040:	d8323342 71cd5aa2 40e1d915 07af0bde     B32..Z.q...@....
    f050:	1a6126ab 5aa2d832 26ab750c 5aa21a61     .&a.2..Z.u.&a..Z
    f060:	2440732c 716c30c2 5abf40e1 30801403     ,s@$.0lq.@.Z...0
    f070:	03002044 0110080b 0de171a5 712c9152     D .......q..R.,q
    f080:	07af0f76 d83240e1 71cd5aa2 26ab750c     v....@2..Z.q.u.&
    f090:	5aa21a61 30c12440 07af0e7e 140340e1     a..Z@$.0~....@..
    f0a0:	080d3080 71a50070 91520de5 0b7ed9b6     .0..p..q..R...~.
    f0b0:	40e107af 5aa2d832 30801403 7014d960     ...@2..Z...0`..p
    f0c0:	20ca720c d9230041 70401e00 12680080     .r. A.#...@p..h.
    f0d0:	78e0c7c6 0f62c2e2 452807af 710ced03     ...x..b...(E...q
    f0e0:	700c5aa2 78e0c6c2 c1a1c3e4 88044508     .Z.p...x.....E..
    f0f0:	2440702c 716c30c2 de225abf 1403e892     ,p@$.0lq.Z".....
    f100:	de213080 0080206c 8403208c 0d92f40a     .0!.l ... ......
    f110:	8d04ffef 700ce886 0020080e 70cd41a1     .......p.. ..A.p
    f120:	c7c440c1 4628c2ec 05ef0bd2 0baa4508     .@....(F.....E..
    f130:	401005ef d8114708 420241e1 42105ab1     ...@.G...A.B.Z.B
    f140:	41e1d812 5ab14202 d8134110 420241e1     ...A.B.Z.A...A.B
    f150:	47085ab1 9fc3258c 0d4df221 258c1430     .Z.G.%..!.M.0..%
    f160:	f2299002 10b50d65 08c64042 e80d07cf     ..).e...B@......
    f170:	07ef08be e8094022 07ef08b6 e80540e1     ...."@.......@..
    f180:	702c8e04 8e04f003 0c86d980 1672ffcf     ..,p..........r.
    f190:	b8c61080 10021e72 8e04f011 ffef0c72     ....r.......r...
    f1a0:	f00dd9ff ffef0d6a 41008e04 5acf40c1     ....j......A.@.Z
    f1b0:	8e04f005 ffef0c5a 42c3d980 1fc80080     ....Z......B....
    f1c0:	41c1700c 5ad5a2a0 008040c3 80001fc8     .p.A...Z.@......
    f1d0:	78e0c6cc c1a1c3ea 46cb70ad de20007f     ...x.....p.F.. .
    f1e0:	41104728 33421c03 2380200a 41229600     (G.A..B3. .#.."A
    f1f0:	04af0ace 0003382f 71a5f645 91340df1     ..../8..E..q..4.
    f200:	086274c5 40e107ef 8002208c f21d710c     .tb....@. ...q..
    f210:	07ef0852 208c40e1 f4168fc3 20158f04     R....@. ....... 
    f220:	d940234c 30c22440 8cc2716c 26535abf     L#@.@$.0lq...ZS&
    f230:	b88510c0 30021c03 d9408f04 30c22440     .......0..@.@$.0
    f240:	5ac1716c 201540a1 91002001 008045cb     lq.Z.@. . ...E..
    f250:	3a2f1fd0 700c0003 a54041e1 85005ad7     ../:...p.A@..Z..
    f260:	78e0c7ca 0a0b8848 80310c51 01798123     ...xH...Q.1.#.y.
    f270:	78e0080f 4528c2e8 05ef0a76 0a964010     ...x..(Ev....@..
    f280:	470805ef d8404608 42c141e1 08275ab6     ...G.F@..A.B.Z'.
    f290:	d8170421 42c141e1 e80d5ab6 e80b880d     !....A.B.Z......
    f2a0:	1e00d8c8 00807000 40c32078 00004348     .....p..x .@HC..
    f2b0:	c6c8a500 0a22c2e6 0a3605cf 470805ef     ......"...6....G
    f2c0:	05ef0a52 0a364608 450805ef d8104200     R....F6....E.B..
    f2d0:	5ab141e1 8020e805 180de983 d8170003     .A.Z.. .........
    f2e0:	42a141c1 e80b5ab6 e809880d 41c1d840     .A.B.Z......@..A
    f2f0:	5ab642a1 180de803 c6c60043 c1a1c3e4     .B.Z....C.......
    f300:	450870cd 33821c03 40c3a8c0 2ab00080     .p.E...3...@...*
    f310:	e81c8817 008040c3 88002bf4 00910819     .....@...+......
    f320:	008040c3 882012ad 30c02440 0d6f0ebe     .@.... .@$.0..o.
    f330:	f00dad20 00710815 088640a1 09260c8f      .....q..@....&.
    f340:	24400caf f00430c0 700cadc0 30811403     ..@$.0.....p...0
    f350:	adc0e902 78e0c7c4 01851802 18004100     .......x.....A..
    f360:	d82500c5 700cb103 19047fe0 78e00045     ..%....p....E..x
    f370:	c1adc3f8 00121020 5ad34508 008047cb     .... ....E.Z.G..
    f380:	87201238 00002079 090d7104 0f2a0000     8. .y ...q....*.
    f390:	a700086f 05cf0942 05ef0962 47104018     o...B...b....@.G
    f3a0:	40a1d936 0da021ab 41c35ab3 24004974     6..@.!...Z.AtI.$
    f3b0:	04af0916 00003900 70cd8721 24406038     .....9..!..p8`@$
    f3c0:	70ad3116 2532a701 007f1f80 4103de1c     .1.p..2%.......A
    f3d0:	5ab142e2 e8274410 20011420 40827960     .B.Z.D'. .. `y.@
    f3e0:	0042e0c0 24400025 40d330c0 1b1c0080     ..B.%.@$.0.@....
    f3f0:	734126f0 13580080 23502015 20131444     .&As..X.. P#D.. 
    f400:	2015100c 10007960 0ef22011 140307ef     ... `y... ......
    f410:	08b63080 081d048f 41c30191 71000002     .0.........A...q
    f420:	6d14f014 a0c370c2 a0c1a0c2 f032a0c0     ...m.p........2.
    f430:	0331080f 41c37014 38800001 41c3f006     ..1..p.A...8...A
    f440:	4240000f 000229c5 043f266f 003f236f     ..@B.)..o&?.o#?.
    f450:	144c6d74 13082009 13042008 1300200b     tmL.. ... ... ..
    f460:	266f200c 874105ff 6078c081 04432202     . o&..A...x`."C.
    f470:	1804a080 0b0f02c0 18080065 0d0d0200     ........e.......
    f480:	41502240 20801800 2240180c 0440180c     @"PA... ..@"..@.
    f490:	73b571a5 ffc50732 008045cb 8d001fe4     .q.s2....E......
    f4a0:	003e080f d8fbc181 5acd4242 08118d00     ..>.....BB.Z....
    f4b0:	c185007e 4242d8fa 8d005acd 00be080d     ~.....BB.Z......
    f4c0:	c189d8f9 5acd4242 c081d93a 092f0f32     ....BB.Z:...2./.
    f4d0:	0da021ab 094f0906 086f0f12 30802440     .!....O...o.@$.0
    f4e0:	30801402 0ffee813 081e058f 450805ef     ...0...........E
    f4f0:	d8414200 5ab641a1 180de807 181d0043     .BA..A.Z....C...
    f500:	5adb0043 d857f003 d93b5acc 21ab700c     C..Z..W..Z;..p.!
    f510:	c7d80da0 0fbac2e2 450807cf 41c3d80f     ...........E...A
    f520:	c8d0007f d80f5acb 007f41c3 5acac828     .....Z...A..(..Z
    f530:	007f41c3 e904c7bc 5acb720c 007f41c3     .A.......r.Z.A..
    f540:	e904c720 5aca720c c6c240a1 710c7fe0      ....r.Z.@.....q
    f550:	c1a4c3e8 008041c3 8920120e 26f04508     .....A.... ..E.&
    f560:	00807042 c1832038 086f0da2 c0234040     Bp..8 ....o.@@#.
    f570:	0071084f 0f96c080 c022088f 00d10843     O.q.......".C...
    f580:	31401400 0cc72080 898f208c 1402f719     ..@1. ... ......
    f590:	20803140 208c0cc7 f713898f 31401404     @1. ... ......@1
    f5a0:	0cc72080 898f208c c300f70b 1408c201     . ... ..........
    f5b0:	40c33101 13640080 a060a041 140db024     .1.@..d.A.`.$...
    f5c0:	08273080 c0800071 088f0a2a 081bc022     .0'.q...*..."...
    f5d0:	c30000d1 1408c201 40c33101 13700080     .........1.@..p.
    f5e0:	a060a041 140eb024 08273080 c0800071     A.`.$....0'.q...
    f5f0:	08cf0a76 081bc022 c30000d1 1408c201     v..."...........
    f600:	40c33101 137c0080 a060a041 0aa6b024     .1.@..|.A.`.$...
    f610:	40a1092f 0cf68500 c183086f 0929c123     /..@....o...#.).
    f620:	40100071 008040c3 80211364 90048040     q..@.@..d.!.@...
    f630:	c240c141 30041c08 080dc022 c08000f1     A.@....0".......
    f640:	088f0e6a 3080140d 00510825 008040c3     j......0%.Q..@..
    f650:	80211370 90048040 c240c141 30041c08     p.!.@...A.@....0
    f660:	080dc022 c08000f1 088f0bda 3080140e     "..............0
    f670:	00510825 008040c3 8021137c 90048040     %.Q..@..|.!.@...
    f680:	c240c141 30041c08 080dc022 c08000f1     A.@....0".......
    f690:	08cf098e c7c84002 008041c3 40c320c0     .....@...A... .@
    f6a0:	967f0098 01031901 700ca101 19007fe0     ...........p....
    f6b0:	78e00003 0e22c2ec 401005af 05af0e3e     ...x.."....@>...
    f6c0:	41104508 e81b70cd 13522540 70ede515     .E.A.p..@%R....p
    f6d0:	24801278 8d00e80d 00df0817 1001150b     x..$............
    f6e0:	7960e906 15402542 f203e0c0 71c571e5     ..`yB%@......q.q
    f6f0:	94640ee1 1f0d2554 70edf002 008045cb     ..d.T%.....p.E..
    f700:	85011204 a5216821 21001006 00c0205f     ....!h!....!_ ..
    f710:	00430809 10011d04 5ac5ef8f 4006e88d     ..C........Z...@
    f720:	e80f706c 0000224a 8000882d 21797945     lp..J"..-...Eyy!
    f730:	e8fc0002 1d00e905 700c1043 4002c6cc     ........C..p...@
    f740:	5adaad60 78e0f1fb 4588c2f4 45504270     `..Z...x...EpBPE
    f750:	44104130 03bf272f 003f236f 40a25aa9     0A.D/'..o#?..Z.@
    f760:	5abe4142 70811600 1ea40080 f40e7034     BA.Z...p....4p..
    f770:	205278a5 f20a803e 043f266f 003f236f     .xR >...o&?.o#?.
    f780:	262f5aaa f09e03bf 4082da78 262f4122     .Z/&....x..@"A/&
    f790:	0ae603bf da3405cf 0ade40a2 414205ef     ......4..@....BA
    f7a0:	41224082 434242a2 238a5aa8 09bb2e01     .@"A.BBC.Z.#....
    f7b0:	70ed2030 261a70cd 758214cd 5aa740a1     0 .p.p.&...u.@.Z
    f7c0:	0d768536 401003ef 40a1f227 a7fe2050     6.v....@'..@P ..
    f7d0:	5adcf225 20508516 f20a87fe 209a40c1     %..Z..P .....@. 
    f7e0:	70820e01 e904802c 40a17960 269a46d1     ...p,...`y.@.F.&
    f7f0:	1d582e01 40021400 25162600 20021624     ..X....@.&.%$.. 
    f800:	41a17a60 0120087a 162c40a1 e90c2001     `z.Az. ..@,.. ..
    f810:	40a17960 712cf008 5ad9f003 08de702c     `y.@..,q...Z,p..
    f820:	40a10020 a7fe2050 40d1f21a 2e01209a      ..@P .....@. ..
    f830:	200040a1 5adc2510 5aa640a1 105c4610     .@. .%.Z.@.Z.F\.
    f840:	70d62100 206126ca 05a00815 0588202f     .!.p.&a ..../ ..
    f850:	2002103c 41a17a60 2584185c 5abd40a1     <.. `z.A\..%.@.Z
    f860:	0e5771c5 0a5b9444 275a2010 75a21d0d     .qW.D.[.. Z'...u
    f870:	b8c18d15 00510845 e8209503 087e712c     ....E.Q... .,q~.
    f880:	40a10020 e8188d0d 05af0a2a 10c01505      ..@....*.......
    f890:	0946e894 15050160 d8ff10c0 42005aad     ..F.`........Z.B
    f8a0:	0b02732c 40a105ef 704c722c 05ef0af6     ,s.....@,rLp....
    f8b0:	f00440a1 5ada40a1 0fb371e5 5aaa9484     .@...@.Z.q.....Z
    f8c0:	c6d4700c 42c3c0f1 12100080 81208221     .p.....B....!. .
    f8d0:	0f80091b b66b5aa5 e9898a28 7014712c     .....Zk.(...,q.p
    f8e0:	aa28d827 d827f205 c0d15acc 20ab7ee0     '.(...'..Z...~. 
    f8f0:	21ab0ce0 f1ff0a61 4508c3f4 05af0c4a     ...!a......EJ...
    f900:	b8024030 206c7304 24020040 0b16300f     0@...sl @..$.0..
    f910:	44f9056f 41f1ed0a 1340260a 5ab340c1     o..D...A.&@..@.Z
    f920:	20101904 eefc86c0 b8c18d15 00710897     ... ..........q.
    f930:	8d0d40a1 0030089b 1d1d704e 95031043     .@....0.Np..C...
    f940:	20033a2f b8c18d04 0091088f 5aa740a1     /:. .........@.Z
    f950:	20504310 f24987fe be18de3f 2480210a     .CP ..I.?....!.$
    f960:	23803100 220a4162 0b562440 4110046f     .1.#bA."@$V.o..A
    f970:	0b56f698 4042046f 382f781d 0bba0003     ..V.o.B@.x/8....
    f980:	412203ef 8d04f40e 80812841 8d1df3ea     .."A....A(......
    f990:	09d1781b f0068003 220a783b ad1d2440     .x......;x."@$..
    f9a0:	23803200 0b1a4162 4110046f 000b003a     .2.#bA..o..A:...
    f9b0:	8d3d8d04 80822841 783bf3f0 80030add     ..=.A(....;x....
    f9c0:	852af013 85a07940 710c4210 700cf002     ..*.@y...B.q...p
    f9d0:	ed9971cd 0813f0a5 40a10071 20505aa7     .q......q..@.ZP 
    f9e0:	f20387fe 8ddd4210 0383382f 046f0ada     .....B../8....o.
    f9f0:	20003200 10c21505 087a7910 40400160     .2. .....yz.`.@@
    fa00:	2052700c 7f152015 7f8043d3 700e0000     .pR . ...C.....p
    fa10:	74e5f002 08b38d0d 40a10030 41105ab2     ...t....0..@.Z.A
    fa20:	05af0fae 260a40a1 e80624c0 0100105e     .....@.&.$..^...
    fa30:	20033e2f 2010090b 08c18d15 1516011e     />. ... ........
    fa40:	712e1094 04ef095e 25803a00 044f0a7a     ...q^....:.%z.O.
    fa50:	70144200 203f0c15 006122ca 00e00e0e     .B.p..? ."a.....
    fa60:	08094040 7a1b0080 21ca7232 0d1e208d     @@.....z2r.!. ..
    fa70:	4022046f 211a8d3d 0929238e 3a0003a0     o."@=..!.#)....:
    fa80:	e98d2012 10911514 5aadd8ff 5ab54410     . .........Z.D.Z
    fa90:	730c4300 42824122 addd5ad0 10031d1e     .C.s"A.B.Z......
    faa0:	0a968700 414203ef 20c540a2 083d0061     ......BA.@. a.=.
    fab0:	71cd003f 10911514 43005ab5 704c720c     ?..q.....Z.C.rLp
    fac0:	5ad04122 8d1df012 1514e810 700c1091     "A.Z...........p
    fad0:	44105aad 43005ab5 4122730c 5ad04282     .Z.D.Z.C.s"A.B.Z
    fae0:	14021d1e 14021d1d ed1b85a0 08278501     ..............'.
    faf0:	5ab38010 f18f4210 0443382f 046f09ca     ...Z.B../8C...o.
    fb00:	20003a00 712e8d36 21ca7114 0939200d     .:. 6..q.q.!. 9.
    fb10:	4430803f 00e00d56 41104022 c7d4f194     ?.0DV..."@.A....
    fb20:	c1a1c3e4 008046cb 8ea02074 008042c3     .....F..t ...B..
    fb30:	0e96120e aaa007af 0d218e20 46081060     ........ .!.`..F
    fb40:	31431c01 30431c02 30421c03 42005ab5     ..C1..C0..B0.Z.B
    fb50:	2440d8fe 5acd3041 c7c440c1 272fc2e6     ..@$A0.Z.@..../'
    fb60:	236f03bf 4708003f 008045cb 208c1f34     ..o#?..G.E..4.. 
    fb70:	f2258e83 9ec3278c 9f8227cc 00fe0000     ..%..'...'......
    fb80:	700cf43a 066f0c26 0b32702c 700c06ef     :..p&.o.,p2....p
    fb90:	244a8500 20807800 20a80105 180a0140     ..J$.x. ... @...
    fba0:	41c30015 1f440080 274f8140 208c1080     ...A..D.@.O'... 
    fbb0:	22468f83 a1000280 710cf41e 066f0bee     ..F".......q..o.
    fbc0:	0afa702c 710c06ef 244a8500 e00e77c0     ,p.....q..J$.w..
    fbd0:	010020a8 0015180a 008041c3 81001f44     . .......A..D...
    fbe0:	9f83278c 01402046 f406a100 20848100     .'..F @........ 
    fbf0:	a10007fe 70031e00 1f8c0080 262f5aa0     .......p.....Z/&
    fc00:	c6c603bf 4768c2e6 45089361 73104688     ......hGa..E.F.s
    fc10:	10cd25ca 25ca7530 4140104d 081a42c1     .%..0u.%M.@A.B..
    fc20:	40a10020 41e140a1 0020080e 40a142c1      ..@.@.A.. ..B.@
    fc30:	78e0c6c6 4528c2e4 062f0d3e 8e164648     ...x..(E>./.HF..
    fc40:	001f080d 00e00c26 ad078d07 78e0c6c4     ....&..........x
    fc50:	45cbc2e4 11f00080 ea1e8d40 41c38d01     ...E....@......A
    fc60:	20900080 00600d9e 854389c0 85818d28     ... ..`...C.(...
    fc70:	44c3716c b330007f 202370ac 40c10300     lq.D..0..p# ...@
    fc80:	85238d08 71048d40 6901ad08 6a09a503     ..#.@..q...i...j
    fc90:	c6c4ad00 07cf0f72 78e0c6c4 215fc0e6     ....r......x.._!
    fca0:	42c30603 1f480080 8581627d 44cb6262     ...B..H.}b..bb.D
    fcb0:	de14007f 05fe0a2b 854468c3 43cb642b     ....+....hD.+d.C
    fcc0:	ffff0000 22ca7271 a86002cd 03031801     ....qr."..`.....
    fcd0:	ba28a842 a84368c7 7404df0a 76edf002     B.(..hC....t...v
    fce0:	61998542 2a4189a2 2a41060c a8a00403     B..a..A*..A*....
    fcf0:	a861a882 2a418904 ae00020b 12c21e02     ..a...A*........
    fd00:	ae4140e1 78e0c4c6 c1a9c3f2 70121600     .@A....x.......p
    fd10:	1f440080 0614215f 2203218a a0022284     ..D._!...!."."..
    fd20:	40304608 008043d3 24001f34 00802f8f     .F0@.C..4..$./..
    fd30:	21ca1f58 272f26e2 236f003f f005003f     X..!.&/'?.o#?...
    fd40:	4002c180 86235ab9 49108601 04650893     ...@.Z#....I..e.
    fd50:	860170ad 081de819 86222030 008040c3     .p......0 "..@..
    fd60:	90001fac 00050923 008040c3 f00b1fa4     ....#....@......
    fd70:	008040c3 90001fa0 0005090f 008040c3     .@...........@..
    fd80:	80001f98 255f602d e5bf1280 4166f705     ....-`_%......fA
    fd90:	49196119 70c3f004 153b0080 c2808800     .a.I...p..;.....
    fda0:	204941c1 40020883 072f0812 ed054570     .AI ...@../.pE..
    fdb0:	20300d4d 8700d870 a70070a2 e0bfc020     M.0 p....p.. ...
    fdc0:	ffcd0780 205f4166 60380280 90228848     ....fA_ ..8`H.".
    fdd0:	0971ba80 a8488030 b0227724 0a1ff1b2     ..q.0.H.$w".....
    fde0:	87002030 2f812434 28840080 2000e907     0 ..4$./...(... 
    fdf0:	00802f90 1800120c c7d22043 0ce020ab     ./......C ... ..
    fe00:	266f700c 236f043f c7d2003f c1a3c3e4     .po&?.o#?.......
    fe10:	0602215f 41c34628 1f480080 8224623a     _!..(F.A..H.:b$.
    fe20:	e91b4508 82008201 081b706c bb9705fe     .E......lp......
    fe30:	82208201 790b787d 2678f205 71041000     .. .}x.y..x&...q
    fe40:	c0805ad8 ffef0e5a 430041c1 40c1c280     .Z..Z....A.C...@
    fe50:	06ef0fea 266f41a1 236f043f c7c4003f     .....Ao&?.o#?...
    fe60:	4660c2ec 40304740 70ed4110 008045cb     ..`F@G0@.A.p.E..
    fe70:	70cd2874 213279ef 00800f80 08a9120c     t(.p.y2!........
    fe80:	44200030 6a099548 009ce0cc 47db000d     0. DH..j.......G
    fe90:	1fa00080 008044cb 43c31f34 1fa40080     .....D..4..C....
    fea0:	008041c3 40c31fac 1f980080 10051400     .A.....@........
    feb0:	00091300 01081100 000b1000 311f1700     ...............1
    fec0:	850170cd 0b337bd0 702c0025 150c8502     .p...{3.%.,p....
    fed0:	60781012 0c0b7c10 85031484 0c134c10     ..x`.|.......L..
    fee0:	78100030 02050813 10012132 080bf005     0..x....2!......
    fef0:	233207c5 215f1001 e1bf0280 70a0f704     ..2#.._!.......p
    ff00:	f005e009 008070c3 e90c153b e80a8800     .....p..;.......
    ff10:	09117950 49120024 262f607e f5d3f088     Py..$..I~`/&....
    ff20:	71cdb5c8 78ef71e5 80b4084d 4022e518     ...q.q.xM....."@
    ff30:	42e04102 06ef0a7e ee0d43c0 f0077910     .A.B~....C...y..
    ff40:	72227104 1a007910 09f90003 7a108424     .q"r.y......$..z
    ff50:	78104002 78e0c6cc c1a3c3e4 008046cb     .@.x...x.....F..
    ff60:	86211288 8e4c8e70 69014508 2205a601     ..!.p.L..E.i..."
    ff70:	f20880fe 08fe702c 40a10020 f0104408     ....,p.. ..@.D..
    ff80:	08f2712c 40a10020 080d8601 6d040071     ,q.. ..@....q..m
    ff90:	ff4f0c9e 008040c3 888012ac f307262f     ..O..@....../&..
    ffa0:	208af40b 65190e0e 19006d04 0c820083     ... ...e.m......
    ffb0:	1e04ff6f 86251001 092b8601 c0800025     o.....%...+.%...
    ffc0:	ff0f0f6e 1de5c000 c0011018 10181de6     n...............
    ffd0:	1de7c002 25801018 1d001e0e 1e041003     .......%........
    ffe0:	788d1001 78e0c7c4 c1a6c3e2 45088160     ...x...x....`..E
    fff0:	8161c340 c3417404 c3428162 c3438163     @.a..tA.b.B.c.C.
   10000:	c3448164 c1808165 ff6f0ae2 2580c345     d.D.e.....o.E..%
   10010:	700c1ece 10431d00 78e0c7c2 46cbc2e4     ...p..C....x...F
   10020:	12880080 8e5a8621 69014508 00f40a0b     ....!.Z..E.i....
   10030:	1e04a601 712c1001 0020083a 8e3940a1     ......,q:. ..@9.
   10040:	00f10919 f007262f 2580f408 1d001e0e     ..../&.....%....
   10050:	1e041103 c6c41001 86418520 000d2180     ........ .A..!..
   10060:	090f9120 258000a5 1d001e4e c6c41043      ......%N...C...
   10070:	c1a9c3ea 008046cb 40101298 8e0880a0     .....F.....@....
   10080:	2f8f2000 03780000 00700851 87634130     . ./..x.Q.p.0Ac.
   10090:	87218742 248a8700 09a60e0d 24000a2f     B.!....$..../..$
   100a0:	87630404 87218742 08e68700 24400a2f     ..c.B.!...../.@$
   100b0:	8e283004 21002040 0131090d 228042a1     .0(.@ .!..1..B."
   100c0:	f009070a 00d1090b 03082280 2280f003     ........."....."
   100d0:	0af20f05 c180ff6f ff4f0966 8e288e14     ....o...f.O...(.
   100e0:	8e00e815 20022179 00002078 f40f7a0b     ....y!. x ...z..
   100f0:	00700937 093371ed 218a0130 7102080d     7.p..q3.0..!...q
   10100:	21002040 1e022540 091ff00d 70ed0070     @ .!@%......p..p
   10110:	01300917 080d218a 20407102 25402100     ..0..!...q@ .!@%
   10120:	0c461502 45cb0d4f 3ea80080 008040c3     ..F.O..E...>.@..
   10130:	0af63b40 41a10d6f 40e18626 c7caa527     @;..o..A&..@'...
   10140:	702cc2e2 ffef0f2e 42c34508 12880080     ..,p.....E.B....
   10150:	090d8a39 262f00f0 f205f007 0913790f     9...../&.....y..
   10160:	25800051 1d001e0e 1a041183 c6c20001     Q..%............
   10170:	42c3c0f1 12880080 71248221 0174091d     ...B....!.$q..t.
   10180:	218aa221 61190e0e 00831900 00011a04     !..!...a........
   10190:	00200812 00431a1c 7fe0c0d1 78e0700c     .. ...C......p.x
   101a0:	c1a9c3e4 0f8d2000 03600000 85004608     ..... ....`..F..
   101b0:	c0408620 21548501 c0410b82 c1808502      .@...T!..A.....
   101c0:	850dc042 850ec043 856fc044 0e1e40c1     B...C...D.o..@..
   101d0:	c345ffef 0f0e208a 8e00661e 0071082f     ..E.. ...f../.q.
   101e0:	43c3c286 3b3c0080 20568300 730c0e81     ...C..<;..V ...s
   101f0:	040c111c 08fd7104 1a0481b4 6b040310     .....q.........k
   10200:	0d6f0d0e 1e00c186 700c1003 a50ea50d     ..o........p....
   10210:	c7c4a50f 80044100 001819e8 19e98105     .....A..........
   10220:	81060018 001819ea 0ece2180 7fe0700c     .........!...p..
   10230:	00031900 4528c2e2 255a5ab3 16001281     ......(E.ZZ%....
   10240:	00807002 45081f34 6159700c ea169141     .p..4..E.pYaA...
   10250:	e8848907 a907710c 0003382f 042f0a6a     .....q../8..j./.
   10260:	10003d00 97fe2550 21ca702c 20780062     .=..P%..,p.!b.x 
   10270:	794b0002 006220ca 78e0c6c2 1800e805     ..Ky. b....x....
   10280:	00000f84 e90607df 0f821900 000c0000     ................
   10290:	1a00ea05 00000f82 eb060017 0f821b00     ................
   102a0:	00050000 00100c0d 0f821c00 00110000     ................
   102b0:	7ce070b4 0f821d00 000a0000 78e07ee0     .p.|.........~.x
   102c0:	0e56c2e2 450805ef e8064200 090b8d35     ..V....E.B..5...
   102d0:	710c013f c6c24040 8835c2e2 0929b9c1     ?..q@@....5...).
   102e0:	882d0051 88bde913 00c01005 0f5e70b5     Q.-..........p^.
   102f0:	25ca00e0 392f1061 382f0343 38000003     ...%a./9C./8...8
   10300:	c6c20040 054f0d8e 700cc6c2 78e0c6c2     @.....O....p...x
   10310:	c1a1c3ec 88164608 458847a8 41504070     .....F...G.Ep@PA
   10320:	003e0819 40c14230 42224142 44a14302     ..>.0B.@BA"B.C.D
   10330:	056f0dd6 c7cc45e1 056f0ade 414240c1     ..o..E....o..@BA
   10340:	43024222 0dc244a1 45e1056f 30842440     "B.C.D..o..E@$.0
   10350:	414240c1 43024222 056f0dae 952045e1     .@BA"B.C..o..E .
   10360:	31021402 0a014020 793d0024 c7ccb500     ...1 @..$.=y....
   10370:	06412042 0095090d 006040c3 7ee01a5c     B A......@`.\..~
   10380:	05950817 003041c3 090f0008 40c3000e     .....A0........@
   10390:	13d80060 40c37ee0 0d540060 78e07ee0     `....~.@`.T..~.x
   103a0:	41c3c0f1 12240080 702c8140 c0d15ace     ...A..$.@.,p.Z..
   103b0:	700c7fe0 c1a5c3e4 c0804508 086f0a06     ...p.....E....o.
   103c0:	0a22c680 2440082f 141334c0 382f3080     .."./.@$.4...0/8
   103d0:	c0430003 0000204a 71048620 0f813900     ..C.J .. ..q.9..
   103e0:	ac123c20 80f208f5 10501e04 70801600      <........P....p
   103f0:	1fe40080 013e080d 8548d8fa 5acdc180     ......>...H....Z
   10400:	008040c3 09ee13fc c180feaf 00422084     .@........... B.
   10410:	8042208c 8528f40d 008040c3 a0201224     . B...(..@..$. .
   10420:	702c8548 5ace40a1 40a1702c 700c5add     H.,p.@.Z,p.@.Z.p
   10430:	78e0c7c4 40c3c0f1 13fc0080 fe8f09b2     ...x...@........
   10440:	7fe0c0d1 78e0700c 088ec2e4 4508056f     .....p.x....o..E
   10450:	056f08aa 42004608 41c1710c 15725ab1     ..o..F.B.q.A.Zr.
   10460:	b9c61081 10421d72 1072e805 081100c0     ....r.B...r.....
   10470:	8d040012 0c62742c 704cff6f c6c4700c     ....,tb.o.Lp.p..
   10480:	0856c2e4 4508056f 056f0872 42004608     ..V.o..Er.o..F.B
   10490:	41c1710c 15725ab1 091f10c1 e8060012     .q.A.Zr.........
   104a0:	00c01072 00120813 742c8d04 ff6f0c2a     r.........,t*.o.
   104b0:	1572714c b9871081 1d72700c c6c41042     Lqr......pr.B...
   104c0:	008040c3 7fe0126c 78e09000 008040c3     .@..l......x.@..
   104d0:	7fe01274 78e08000 4520c0f1 00c11172     t......x.. Er...
   104e0:	0033091f 42c3d90c 126c0080 1504a203     ..3....B..l.....
   104f0:	e2100080 44c3766c bbfc007f c0d15ac0     ....lv.D.....Z..
   10500:	78e07ee0 008040c3 7fe01284 78e08000     .~.x.@.........x
   10510:	008040c3 7fe01270 78e08000 4328c2e6     .@..p......x..(C
   10520:	40c3e89e 126c0080 00c11011 10138890     ...@..l.........
   10530:	101500cf 88b400c2 806388d2 02002940     ..........c.@)..
   10540:	44cb7885 1b340080 2f40a400 ba081200     .x.D..4...@/....
   10550:	a40178c5 40617aa5 a4427b60 78e0c6c6     .x...za@`{B....x
   10560:	c1a1c3e4 88044508 2440702c 716c30c2     .....E..,p@$.0lq
   10570:	de225abf 1403e892 de213080 0080206c     .Z"......0!.l ..
   10580:	8403208c 091af40a 8d04ff6f 700ce886     . ......o......p
   10590:	00200852 70cd41a1 c7c440c1 4628c2e6     R. ..A.p.@....(F
   105a0:	42c3702c de3e007f 090f92a3 e20800f5     ,p.B..>.........
   105b0:	90240df9 12027124 47cb0000 126c0080     ..$.$q.....G..l.
   105c0:	b7a0a701 0c2e8a20 8e04072f 080b8702     .... .../.......
   105d0:	710c00b5 700c5aa2 5ad641c1 c6c640a1     ...q.Z.p.A.Z.@..
   105e0:	4528c2e6 46cb4708 126c0080 8fc3208c     ..(E.G.F..l.. ..
   105f0:	0f35f213 278c1430 f20f9002 10b50f3b     ..5.0..'....;...
   10600:	0d42702c 8d04072f 10801572 1d72b8c6     ,pB./...r.....r.
   10610:	a6e21002 8d04f00e 072f0d2a d8ffd9ff     ........*./.....
   10620:	f008a602 ff6f0a0e 41008d04 5acf40a1     ......o....A.@.Z
   10630:	41a1700c 86025ad5 78e0c6c6 c1a1c3ea     .p.A.Z.....x....
   10640:	46cb70ad de64007f 41104728 33421c03     .p.F..d.(G.A..B3
   10650:	2380200a 41229600 03ef0e66 0003382f     . .#.."Af.../8..
   10660:	71a5f645 91340df1 8f0474c5 2440d942     E..q..4..t..B.@$
   10670:	716c30c2 20155abf 14032350 10023081     .0lq.Z. P#...0..
   10680:	216c2080 b8c300c1 1c037825 8f043002     . l!....%x...0..
   10690:	2440d942 716c30c2 45cb5ac1 126c0080     B.@$.0lq.Z.E..l.
   106a0:	080b8502 710c00b5 8f045aa2 2440d976     .......q.Z..v.@$
   106b0:	716c30c2 10005abf 700c2103 10c33c2f     .0lq.Z...!.p/<..
   106c0:	30811403 7934796a 00433a2f 0f83392f     ...0jy4y/:C./9..
   106d0:	32000000 00413a00 10423401 008041c3     ...2.:A..4B..A..
   106e0:	a1401b40 00c33a2f a54641e1 85065ad7     @.@./:...AF..Z..
   106f0:	78e0c7ca 47cbc3ec 1f440080 b8e78700     ...x...G..D.....
   10700:	00220184 5aabc1a2 008040d3 70ad1f54     .."....Z.@..T..p
   10710:	228e2040 5aac78af 1e1871a5 78af1014     @ .".x.Z.q.....x
   10720:	809408f5 008046cb 1e001f8c 5ac81003     .....F.........Z
   10730:	204b8700 f2058480 b8838e00 8700ae00     ..K ............
   10740:	8440204b 5ac3f206 8e00e884 ae00b886     K @....Z........
   10750:	20ab8e00 20aa0660 21aa0e20 08fb0e20     ... `..  ..! ...
   10760:	5ac48041 f20f7014 e80b5ac3 70001600     A..Z.p...Z.....p
   10770:	1f780080 8e00e885 8180204b 8700f203     ..x.....K ......
   10780:	f2827014 dd805ab8 252f40e1 0d0f100c     .p...Z...@/%....
   10790:	c540107e b8838e00 0d11ae00 5ac3101e     ~.@............Z
   107a0:	8e00e884 ae00b886 113e0d11 5ac7c080     ..........>....Z
   107b0:	8e00e804 f26a7014 080dc000 700c00de     .....pj........p
   107c0:	c0005ad1 009e080d e8845ac3 5ad1710c     .Z.......Z...q.Z
   107d0:	086dc020 5ab5011e 45cb8e20 1f8d0080      .m....Z ..E....
   107e0:	02012185 1c05ae20 8d203043 30421c06     .!.. ...C0 ...B0
   107f0:	30031c07 09198d20 46080834 208c8d00     ...0 ...4..F... 
   10800:	f2068f03 208c8d00 f4078fc3 2440d8fe     ....... ......@$
   10810:	42c13141 8d005acd 0814080b e0c08d00     A1.B.Z..........
   10820:	8d00f789 8f43208c 8d00f205 8fc3208c     ..... C...... ..
   10830:	d8f8f406 31412440 5acd42c1 043f266f     ....@$A1.B.Zo&?.
   10840:	003f236f 702e5aab 2400220a 7eaf70ad     o#?..Z.p.".$.p.~
   10850:	1a1840c1 5aac2450 1af271a5 76c3a004     .@..P$.Z.q.....v
   10860:	120c0080 08eb78af 1e0080b4 87001442     .....x......B...
   10870:	0040206c 266fa700 100a05ff 10222100     l @...o&.....!".
   10880:	5ac62101 c7cc700c f1fe5aa0 c1a1c3ec     .!.Z.p...Z......
   10890:	4b504110 454846a8 28424030 1c038092     .APK.FHE0@B(....
   108a0:	f2203003 01100c13 01d00c09 01910c0f     .0 .............
   108b0:	30d02440 2440f003 082930d1 71ed0072     @$.0..@$.0).r..q
   108c0:	24408500 806130c2 7b604022 ee034102     ..@$.0a."@`{.A..
   108d0:	1403a600 e8863080 74a57752 f6b271e5     .....0..Rw.t.q..
   108e0:	78e0c7cc 0935c0e6 46280012 0929b961     ...x..5...(Fa.).
   108f0:	706c0072 42008080 8ce082a1 108b1500     r.lp...B........
   10900:	77717164 134e24ca a281f7c3 0beda2a0     dqqw.$N.........
   10910:	74448062 90530ed7 78e0c4c6 007f42c3     b.Dt..S....x.B..
   10920:	43c3deb4 deb8007f 0765758c 70acffef     ...C.....ue....p
   10930:	007f42c3 43c3dea8 deac007f 0751738c     .B.....C.....sQ.
   10940:	70acffef 42c3708c de98007f 007f43c3     ...p.p.B.....C..
   10950:	073dde9c 4580ffef 007f42c3 43c3dea4     ..=....E.B.....C
   10960:	dea8007f 0729728c 70acffef 007f42c3     .....r)....p.B..
   10970:	43c3de9c dea4007f 0715718c 70acffef     ...C.....q.....p
   10980:	702c700c 007f42c3 43c3deac deb4007f     .p,p.B.....C....
   10990:	06fd748c 4500ffef c1a1c0f1 42c3702c     .t.....E....,p.B
   109a0:	deb8007f 007f43c3 244adebc 0ee201c0     .....C....J$....
   109b0:	2440ffef c0003005 c0d17487 78e07ee0     ..@$.0...t...~.x
   109c0:	70adc2e4 008046cb 86001318 79028621     ...p.F......!..y
   109d0:	792fb922 00920909 ffcf0f0e 0def71a5     "./y.........q..
   109e0:	e6089234 78e0c6c4 42c3702c deb8007f     4......x,p.B....
   109f0:	007f43c3 768cdeb8 ffef0695 78e04520     .C.....v.... E.x
   10a00:	238ac1a1 714c0806 4183f00e 9121b161     ...#..Lq...Aa.!.
   10a10:	f0097704 0a6122ab 9421448b b4217724     .w..."a..D!.$w!.
   10a20:	e9fa9421 f008262f 7fe0f5f1 78e07487     !.../&.......t.x
   10a30:	4148c2e6 40688857 88f68875 88ac8894     ..HAW.h@u.......
   10a40:	bb08ba08 7b857f45 14022f40 46cb4620     ....E..{@/.. F.F
   10a50:	0aaa0000 726d702c 7200244a 7b45bdc3     ....,pmrJ$.r..E{
   10a60:	058020a8 00422353 004c224f 10b10c13     . ..S#B.O"L.....
   10a70:	104c2b00 72547e86 104126cf 0a0df206     .+L..~Tr.&A.....
   10a80:	2b000071 7e451042 7224bb22 422141c0     q..+B.E~".$r.A!B
   10a90:	06af0e1e 710c4301 732c7bbb 6d927978     .....C.q.{,sxy.m
   10aa0:	7a984200 22ab7e26 26ab0da1 c6c613e2     .B.z&~."...&....
   10ab0:	0e2020aa 0e2021aa f5fc7030 08002044     .  ..! .0p..D ..
   10ac0:	b8257fe0 2482c3ec 2456320e c1803840     ..%....$.2V$@8..
   10ad0:	000a2080 0025090b 4100c140 c082c040     . ....%.@..A@...
   10ae0:	08002056 00050907 42d3c040 05eb0080     V ......@..B....
   10af0:	46cb700c 12100080 20412240 5aa543c3     .p.F....@"A .C.Z
   10b00:	da1bb66b a160a621 ff6f0dbe 0da022ab     k...!.`...o.."..
   10b10:	007f40c3 41c3debc e114007f 41d37902     .@.....A.....y.A
   10b20:	e114007f 007f43c3 40d3e3b8 e3b8007f     .....C.....@....
   10b30:	007f42c3 2302e488 2202044f 2984040d     .B.....#O.."...)
   10b40:	2f440e01 ae291d0f 2d44792f aeea1d0d     ..D/..)./yD-....
   10b50:	052f0a96 79efaeab 052f0a9e 79af4022     ../....y../."@.y
   10b60:	052f0aa6 45cb4002 e488007f 036f09b2     ../..@.E......o.
   10b70:	22aa40a1 245604e1 d9203840 0f822205     .@."..V$@8 .."..
   10b80:	00002a54 04ef08ce 04e122ab 0e4ac082     T*......."....J.
   10b90:	d91004ef 007f40c3 41c3e4b8 ffff007f     .....@.....A....
   10ba0:	008042c3 43420000 70145ac9 002101ac     .B....BC.Z.p..!.
   10bb0:	700cd91c ff6f0d12 0da021ab 8e2b8e0a     ...p..o..!....+.
   10bc0:	008047cb 8e4912e0 00042100 87208761     .G....I..!..a. .
   10bd0:	ffef0e62 d91d40a1 0cee700c 21abff6f     b....@...p..o..!
   10be0:	40c30da0 c0a0007f 2022e805 007f0f80     ...@......" ....
   10bf0:	0c22c0a0 d8200000 31922440 000040d3     .."... .@$.1.@..
   10c00:	20ab0000 f0070da0 20abd827 20690da0     ... ....'.. ..i 
   10c10:	d8218040 20ab70ad 25ab0da0 20aa1ce0     @.!..p. ...%... 
   10c20:	21aa05e0 08fb05e0 e88a8041 f2857016     ...!....A....p..
   10c30:	0f802022 00000000 f27f7014 d9225ac2     " .......p...Z".
   10c40:	000040c3 21ab0000 e8060da0 0f802022     .@.....!...." ..
   10c50:	00000000 ff6f0c72 f004710c 068f0bde     ....r.o..q......
   10c60:	20aa70ad 21aa05e0 08fb05e0 e88a8041     .p. ...!....A...
   10c70:	201008c7 0f802022 00000000 001008bb     ... " ..........
   10c80:	262f5abb f459f347 803e2052 d823f255     .Z/&G.Y.R >.U.#.
   10c90:	0da020ab 8e0b8e2a 603b8741 0daa8e29     . ..*...A.;`)...
   10ca0:	870006af e8084508 5acc40a1 20abd85e     .....E...@.Z^.. 
   10cb0:	f02a0da0 ff6f0c12 40c3710c 00000000     ..*...o..q.@....
   10cc0:	2022e805 00000f80 700c0000 40c35aa1     .." .......p.Z.@
   10cd0:	2a540000 34031c05 20041a00 42005ab5     ..T*...4... .Z.B
   10ce0:	2440d8fe 5acd3141 1084160b 87418e6a     ..@$A1.Z....j.A.
   10cf0:	08828e29 87000020 70ad4110 4022e804     )... ....A.p.."@
   10d00:	452a5acc 20abd824 8e0a0da0 87418e6b     .Z*E$.. ....k.A.
   10d10:	631b8e29 06af0e2a 40c38700 00000000     )..c*......@....
   10d20:	2022e805 00000f80 d8250000 90310d37     .." ......%.7.1.
   10d30:	0da020ab d826f194 f347262f 0da020ab     . ....&./&G.. ..
   10d40:	0b2ef203 20aa068f 21aa05e0 08fb05e0     ....... ...!....
   10d50:	70148041 f15af55f 0ce020aa f007262f     A..p_.Z.. ../&..
   10d60:	d820f404 0ce020ab 20ab710c f1fe0a61     .. .. ...q. a...
   10d70:	710ec2f0 008041d3 47881204 44504568     ...q.A.....GhEPD
   10d80:	43104230 24021900 e8065ad2 0cfe4062     0B.C...$.Z..b@..
   10d90:	4142052f 70ad67bf d82ef005 20ab700e     /.BA.g.p.....p. 
   10da0:	20aa0da0 21aa05e0 08fb05e0 e88d8041     ... ...!....A...
   10db0:	000040c3 70140000 2022f272 00000f80     .@.....pr." ....
   10dc0:	70140000 5abbf26c f347262f 2052f468     ...pl..Z/&G.h.R 
   10dd0:	f266803e 406271cd 42824142 240a43e1     >.f..qb@BA.B.C.$
   10de0:	26ab0400 5aa51a61 e8d94508 26abd828     ...&a..Z.E..(..&
   10df0:	20ab1a61 5ab70da0 e8d14508 20ab710c     a.. ...Z.E...q. 
   10e00:	dc290a61 41424062 43e14282 056f0c52     a.).b@BA.B.CR.o.
   10e10:	1da024ab 0ab270ad 710cff6f 008046cb     .$...p..o..q.F..
   10e20:	8e001210 710ce806 0a6120ab 0aa120ab     .......q. a.. ..
   10e30:	d8ffd92a 0da021ab d82b5aba f347262f     *....!...Z+./&G.
   10e40:	0da020ab 4062f40c 42824142 240a43e1     . ....b@BA.B.C.$
   10e50:	5aa50400 e8844508 45085ab7 20abd82c     ...Z.E...Z.E,.. 
   10e60:	8e000da0 1100e884 e8852080 20abd85a     ......... ..Z.. 
   10e70:	700c0aa1 008041c3 202f1ea0 089b004c     ...p.A..../ L...
   10e80:	216f8011 8e00003f 710ce806 0a6120ab     ..o!?......q. a.
   10e90:	0aa120ab 20abd82d f1810da0 78afd93f     . ..-.. ....?..x
   10ea0:	0da021ab 78e0c6d0 0e3ac2ec 401004ef     .!.....x..:....@
   10eb0:	04ef0e56 42004508 41a14002 45085ab6     V....E.B.@.A.Z.E
   10ec0:	0e2ee88c 0e4e04cf 450804ef 40024200     ......N....E.B.@
   10ed0:	5ab641a1 e8394508 5ab340a1 2152204f     .A.Z.E9..@.ZO R!
   10ee0:	21502050 700e1600 1f340080 228f225a     P P!...p..4.Z"."
   10ef0:	2281205a 0dd267df 663e03af 09178d35     Z .".g....>f5...
   10f00:	4110017e 05af0a66 0a6240c1 40e105af     ~..Af....@b....@
   10f10:	4022f00b 0d2241c1 42a1ff6f 41e14022     .."@.A".o..B"@.A
   10f20:	ff6f0d16 40a142a1 5aae4102 40a1b601     ..o..B.@.A.Z...@
   10f30:	5aae4142 8d32b701 9621e987 71507a10     BA.Z..2...!..zPq
   10f40:	004920ca c6ccb513 40c3c2e8 1f440080     . I........@..D.
   10f50:	08378000 700e01ff 45cb5aab 1f540080     ..7....p.Z.E..T.
   10f60:	7fcf70cd 5aac40e1 10710f0b 5ac3b505     .p...@.Z..q....Z
   10f70:	9505e883 71c5e887 08eb78cf e51880b4     .......q.x......
   10f80:	1500f003 40021010 78e0c6c8 45cbc2e6     .......@...x...E
   10f90:	1e8c0080 70cd8d00 e80e70ed 04ef09d6     .......p.p......
   10fa0:	900078cd 71c58d20 b8c0781d 0af17acf     .x.. ..q.x...z..
   10fb0:	671f8064 c6c678ef 43c3c0f1 fe0046ff     d..g.x.....C.F..
   10fc0:	0000080e 7fe0c0d1 78e0700c c1a6c3ea     .........p.x....
   10fd0:	47684508 41304050 41005ab0 2023c083     .EhGP@0A.Z.A..# 
   10fe0:	3e2f0440 20231043 24400400 3f0030c0     @./>C.# ..@$.0.?
   10ff0:	c1831380 0060089a 1403c281 c1813080     ......`......0..
   11000:	30021c0a 40a18548 700c5ace 78e0c7ca     ...0H..@.Z.p...x
   11010:	08d2c2e2 710c062f 008042c3 a2001200     ..../..q.B......
   11020:	007f41c3 710cc9f8 20795acb 710c000d     .A.....q.Zy ...q
   11030:	007f41c3 5acac97c 00002079 c6c278a4     .A..|..Zy ...x..
   11040:	4648c2e8 0a824528 4708076f e7ff4010     ..HF(E..o..G.@..
   11050:	700cf41c 44cbdfff 1fe40080 0000001f     ...p...D........
   11060:	7a248c40 660bac40 2900712c 7074000b     @.$z@..f,q.)..tp
   11070:	717d702c ac207945 08617104 08e50213     ,p}qEy ..qa.....
   11080:	27128362 f02a1001 13c02742 00d5084d     b..'..*.B'..M...
   11090:	008045cb 0f1d1364 710e1470 14310f2b     .E..d...p..q+.1.
   110a0:	da084d1c 04af09ee 1d1441c1 f01610c3     .M.......A......
   110b0:	da084d38 04af09de 40c341c1 13840080     8M.......A.@....
   110c0:	00c31800 0f15f00a da0813f1 09c640a1     .............@..
   110d0:	41c104af 10c31d08 c6c84002 4628c2e6     ...A.....@....(F
   110e0:	076f08f6 47084508 f417e5ff 716c700c     ..o..E.G.....plq
   110f0:	7200244a 1f80240a 1fe40080 02c020a8     J$.r.$....... ..
   11100:	2b008c20 79a4000d 2179661a 71040001      ..+...y.fy!...q
   11110:	78e0aa20 2542f017 082b13c0 41c300d5      ..x..B%..+....A
   11120:	13640080 14700d0f 0d0f71ed e10c1411     ..d...p..q......
   11130:	e118f005 0d0ff003 da0a13d1 04af0956     ............V...
   11140:	40e140c1 78e0c6c6 4300c0f1 0b0fe807     .@.@...x...C....
   11150:	40600275 0000081e 40c3f00a 00000000     u.`@.......@....
   11160:	700c7014 0fbef204 406001ac 7ee0c0d1     .p.p......`@...~
   11170:	8a61c2ea 008045cb 120011f0 ad680091     ..a..E........h.
   11180:	40d38a62 20900080 2040ad60 46082103     b..@... `.@ .!.F
   11190:	076f0aa6 71eda563 0e53e8aa 700c1275     ..o.c..q..S.u..p
   111a0:	bee08d20 006042c3 46cb5d68 5dd40060      ....B`.h].F`..]
   111b0:	108126ca e91ba5c1 01750933 8543716c     .&......3.u.lqC.
   111c0:	18038d28 44c32002 b330007f 402270ac     (.... .D..0..p"@
   111d0:	03802023 8d00ade1 85438d28 ad007704     # ......(.C..w..
   111e0:	ad086901 a5036a01 70edf002 c6ca40e1     .i...j.....p.@..
   111f0:	4320c0f1 e8104100 001ce188 700c002d     .. C.A......-..p
   11200:	41c3f714 20900080 088ada08 406004af     ...A... ......`@
   11210:	f00c710c 000040c3 70140000 f206700c     .q...@.....p.p..
   11220:	0f024020 416001ac 7ee0c0d1 882dc2e4      @....`A...~..-.
   11230:	00300967 881470ad 0071085f 0aa6ddff     g.0..p.._.q.....
   11240:	0ac604cf 460804ef 710c4200 5ab641c1     .......F.B.q.A.Z
   11250:	5ab2e803 0a9ae8a1 0aba04cf 460804ef     ...Z...........F
   11260:	d8174200 5ab641c1 880de803 1600e895     .B...A.Z........
   11270:	00807000 08232080 dd800070 0f80081b     .p... #.p.......
   11280:	80050001 0f800813 00110008 0f80080b     ................
   11290:	2015000e 40a1ddff 78e0c6c4 4548c2e6     ... ...@...x..HE
   112a0:	0874086b 0a324608 0a5204cf 470804ef     k.t..F2...R....G
   112b0:	18012642 782f4200 5ab141e1 706c4200     B&...B/x.A.Z.Blp
   112c0:	4348e82a 1a412380 f016dcf0 008e2b44     *.HC.#A.....D+..
   112d0:	07c02b41 b9c06319 68324910 716465c8     A+...c...I2h.edq
   112e0:	00412801 03002105 b9c3b9e3 004120ca     .(A..!....... A.
   112f0:	10121b01 00811272 792ab9c6 21cae189     ....r.....*y...!
   11300:	0bcd0265 710c8064 40c1f005 05ef0d06     e...d..q...@....
   11310:	c6c642a1 c6c6700c c1a2c3ea 008042c3     .B...p.......B..
   11320:	82401200 7a604728 087f4608 6e0b0030     ..@.(G`z.F..0..n
   11330:	04b50835 700e6eb4 14432580 e0bf78af     5....n.p.%C..x..
   11340:	1600f70b 00807002 205f1f34 61590281     .....p..4._ ..Ya
   11350:	090d8928 0d8e009f 712c056f 08e17106     (.......o.,q.q..
   11360:	71a5a432 e69f71ad 096ef4b1 401004cf     2..q.q....n....@
   11370:	04ef098a 411074e5 263270cd 007f1f80     .....t.A.p2&....
   11380:	4102de10 5ab14222 8028e80a 5aad7940     ...A"B.Z..(.@y.Z
   11390:	68558f20 01002153 af007845 0edf71c5      .UhS!..Ex...q..
   113a0:	75e590f4 0e2ff093 09821611 708d030f     ...u../........p
   113b0:	8827e805 b9088886 6f027c25 6f456f24     ..'.....%|.o$oEo
   113c0:	27406f66 274011c4 b7801205 71ad5aaf     fo@'..@'.....Z.q
   113d0:	0e3df07d 70ad1831 04cf0922 04ef08fa     }.=.1..p".......
   113e0:	0eeb4608 71ad1030 87408721 05032040     .F..0..q!.@.@ ..
   113f0:	04801378 904e2642 0002220f 10002d00     x...B&N.."...-..
   11400:	7905b85f a740f5f6 f061a721 18540ebf     _..y..@.!.a...T.
   11410:	04cf08c6 04ef08e6 26424010 42001801     .........@B&...B
   11420:	4102782f 08a75ab1 40100030 1e002655     /x.A.Z..0..@U&..
   11430:	1008af00 6f232080 31822440 1009af01     ..... #o@$.1....
   11440:	c381208c 30842440 30452440 af824002     . ..@$.0@$E0.@..
   11450:	40025ab4 b7025ab0 5ab34002 038f086a     .Z.@.Z...@.Zj...
   11460:	b7048f26 20801072 b827b9a0 af067825     &...r.. ..'.%x..
   11470:	20011020 40027960 8f265aad 71ad6855      .. `y.@.Z&.Uh.q
   11480:	01002153 af067845 20801072 2080702c     S!..Ex..r.. ,p. 
   11490:	b8c62a41 f013af0a 008c2944 10016158     A*......D)..Xa..
   114a0:	b8c02483 64fa7842 bbc38a8b 2b00b802     .$..Bx.d.......+
   114b0:	78850000 8f0aaa0b 780a7124 20cae08a     ...x....$q.x... 
   114c0:	09d902a5 29418024 40a107c2 78e0c7ca     ....$.A)...@...x
   114d0:	008041c3 81201b6c 7fe0a020 78e0700c     .A..l. . ....p.x
   114e0:	008041c3 81201b70 7fe0a020 78e0700c     .A..p. . ....p.x
   114f0:	008041c3 81201b68 7fe0a020 78e0700c     .A..h. . ....p.x
   11500:	008041c3 81201b90 7fe0a020 78e0700c     .A.... . ....p.x
   11510:	008041c3 81201b9c 7fe0a020 78e0700c     .A.... . ....p.x
   11520:	008041c3 810e1b68 812f7fe0 008040c3     .A..h...../..@..
   11530:	7fe01bb0 78e08800 008041c3 704c1b68     .......x.A..h.Lp
   11540:	3f7843c3 a14f0000 a14ca14e 01411934     .Cx?..O.N.L.4.A.
   11550:	44cba160 33333f33 3dcc43c3 a181cccd     `..D3?33.C.=....
   11560:	43c3a162 66663f26 a164a163 414043c3     b..C&?ffc.d..C@A
   11570:	19400000 a18900c1 a148a14b a146a147     ..@.....K.H.G.F.
   11580:	a16aa145 700ca151 a1527fe0 008041c3     E.j.Q..p..R..A..
   11590:	700c1b68 7fe0a10f 78e0a10e 008041c3     h..p.......x.A..
   115a0:	a1001b6c 700c7fe0 008041c3 a1001b70     l......p.A..p...
   115b0:	700c7fe0 008041c3 a1001b68 700c7fe0     ...p.A..h......p
   115c0:	008041c3 a1001b90 700c7fe0 008041c3     .A.........p.A..
   115d0:	a1001b9c 700c7fe0 46cbc2f8 1b680080     .......p...F..h.
   115e0:	10011e48 443086a5 b8bf4310 1618b9bf     H.....0D.C......
   115f0:	161c1011 47481010 45304210 036f0ec2     ......HG.B0E..o.
   11600:	24caa6a6 275024c9 245017c1 0eb227c0     ...$.$P'..P$.'..
   11610:	4330036f 150927ca 25403201 3f4044d3     o.0C.'...2@%.D@?
   11620:	bfbf0000 04c13001 25802450 15023700     .....0..P$.%.7..
   11630:	00003100 036f0da6 00803001 ed0942c3     .1....o..0...B..
   11640:	43c37b42 b4253fe7 034f0892 034f0ce6     B{.C.?%...O...O.
   11650:	3e8042d3 30000000 30000482 31012481     .B.>...0...0.$.1
   11660:	244f0083 310027c1 35002482 31011041     ..O$.'.1.$.5A..1
   11670:	33020081 a6e5004f 1624a607 86031011     ...3O.....$.....
   11680:	30028621 31000440 31010000 1e0c2015     !..0@..1...1. ..
   11690:	86041540 04403002 00003100 20103101     @....0@..1...1. 
   116a0:	14001e10 68a1860b 8622a6ab 24403502     .......h.."..5@$
   116b0:	036f0e0e f6464330 24d53101 15401e0c     ..o.0CF..1.$..@.
   116c0:	0dfe40e1 41a2036f 000c00a2 8610a6e3     .@..o..A........
   116d0:	0091089b e8338611 11d40d63 10161638     ......3.c...8...
   116e0:	1017163c a0412640 a0002741 a62ea60f     <...@&A.A'......
   116f0:	10151628 089640a1 350103af 45082558     (....@.....5X%.E
   11700:	30003002 404041c3 0db60000 b8bf036f     .0.0.A@@....o...
   11710:	2640f647 2741a081 a60fa000 3500a62e     G.@&..A'.......5
   11720:	35001480 30012501 70ad0040 10411e40     ...5.%.0@..p@.A.
   11730:	a6aba60a 10411e48 e899f019 11f40d2f     ....H.A...../...
   11740:	a652714c 70ad860c a60c7104 a650a6ab     LqR....p.q....P.
   11750:	081b862d 862e0044 2100866f 23418001     -...D...o..!..A#
   11760:	a60f8000 a6aca62e 3102a651 0d522400     ........Q..1.$R.
   11770:	4162036f 3102f645 1e1024d0 40e11400     o.bAE..1.$.....@
   11780:	036f0d3e f6454102 1e40a6e4 0d171081     >.o..AE...@.....
   11790:	40c31994 00004140 10011e44 10011e30     ...@@A..D...0...
   117a0:	8600a60a 20013100 70003602 00003f80     .....1. .6.p.?..
   117b0:	10003700 00013101 a629700c 78e0c6d8     .7...1...p)....x
   117c0:	41c3c0f1 12200080 702c8140 c0d15ace     ...A.. .@.,p.Z..
   117d0:	700c7fe0 c1a5c3e4 c0804508 07af0de6     ...p.....E......
   117e0:	0e02c680 2440076f 141334c0 382f3080     ....o.@$.4...0/8
   117f0:	c0430003 0000204a 71048620 0f813900     ..C.J .. ..q.9..
   11800:	ac123c20 80f208f5 10501e04 70801600      <........P....p
   11810:	1fe40080 017e080d 8548d8f9 5acdc180     ......~...H....Z
   11820:	008040c3 0f2613e0 c180fdef 00422084     .@....&...... B.
   11830:	8042208c 8528f40d 008040c3 a0201220     . B...(..@.. . .
   11840:	702c8548 5ace40a1 40a1702c 700c5add     H.,p.@.Z,p.@.Z.p
   11850:	78e0c7c4 40c3c0f1 13e00080 fdcf0eea     ...x...@........
   11860:	7fe0c0d1 78e0700c f003702c 08017124     .....p.x,p..$q..
   11870:	781d0071 7fe0710c 78e07838 1863702c     q..x.q..8x.x,pc.
   11880:	18680042 7fe00042 00421867 47cbc2ee     B.h.B...g.B....G
   11890:	7fff0000 78f24310 46284250 00512040     .....C.xPB(F@ Q.
   118a0:	70ad4010 0c328600 3000036f 41e104c0     .@.p..2.o..0...A
   118b0:	21ca70f1 20cc000c 21ca840c 71a5044c     .p.!... ...!L..q
   118c0:	20541a02 90f20de1 c6ce74c5 4508c2e2     ..T .....t.....E
   118d0:	04af09e2 00c01005 0b8ee805 150504af     ................
   118e0:	c6c210c0 41c3c0f1 12340080 702c8140     .......A..4.@.,p
   118f0:	c0d15ace 700c7fe0 8028c2e2 40c34508     .Z.....p..(..E.@
   11900:	12340080 8548a020 40a1702c 702c5ace     ..4. .H.,p.@.Z,p
   11910:	5add40a1 c6c2700c 700c7fe0 4508c2e2     .@.Z.p.....p...E
   11920:	00801072 b8c6d9b1 10021d72 066f0afe     r.......r.....o.
   11930:	710c8d04 8d045aa2 066f0d02 710c702c     ...q.Z....o.,p.q
   11940:	8d045aa2 066f0c1e 710c702c 700c5aa2     .Z....o.,p.q.Z.p
   11950:	78e0c6c2 4508c2e2 00c01072 00320845     ...x...Er...E.2.
   11960:	0cbed91e 8d04066f 5aa2710c 0c368d04     ....o....q.Z..6.
   11970:	702c066f 5aa2710c 0c6a8d04 712c066f     o.,p.q.Z..j.o.,q
   11980:	5aa2710c 0cb68d04 712c066f 5aa2710c     .q.Z....o.,q.q.Z
   11990:	0bd28d04 712c066f 5aa2710c 10801572     ....o.,q.q.Zr...
   119a0:	01c1204f 1d72700c c6c21042 710c7fe0     O ...pr.B......q
   119b0:	008040c3 7fe01240 78e08000 4528c2e2     .@..@......x..(E
   119c0:	00c11172 00330915 7a604200 157240a1     r.....3..B`z.@r.
   119d0:	b8c61080 10021d72 78e0c6c2 7fe0d87f     ....r......x....
   119e0:	78e0b817 7fe0d87f 78e0b817 008043c3     ...x.......x.C..
   119f0:	218a36b0 b3260b1d 0406218a d925b327     .6.!..&..!..'.%.
   11a00:	704cb328 008041c3 1b121288 b34c0305     (.Lp.A........L.
   11a10:	ab5d700c b1407fe0 c1a1c3e4 7fc51e00     .p]...@.........
   11a20:	201a0080 88044508 2440702c 716c30c2     ... .E..,p@$.0lq
   11a30:	de225abf 1403e89c de213080 0080206c     .Z"......0!.l ..
   11a40:	8403208c 0c5af414 8d04feaf 1c03e890     . ....Z.........
   11a50:	8d043043 2440d954 716c30c2 710c5ac1     C0..T.@$.0lq.Z.q
   11a60:	700c5aa2 0020092e 70cd41a1 c7c440c1     .Z.p.. ..A.p.@..
   11a70:	45cbc0e6 36b00080 85818560 240585c2     ...E...6`......$
   11a80:	230510cb f40893be 44284648 a5004300     ...#....HF(D.C..
   11a90:	a542a521 efa895ea 2b424873 150c07cf     !.B.....sHB+....
   11aa0:	63fb110b 0bb37be7 499310e2 07cc2b42     ...c.{.....IB+..
   11ab0:	7b87639b 10e20ba3 2b424ad3 639b07cc     .c.{.....JB+...c
   11ac0:	0b977b87 8d1c10c2 005108af 7104950b     .{........Q....q
   11ad0:	9529b50b 09a37810 1d160003 1d1c1005     ..)..x..........
   11ae0:	f04b1003 10510f15 44284648 a5004300     ..K...Q.HF(D.C..
   11af0:	a542a521 10051d16 28427862 150e07c3     !.B.....bxB(....
   11b00:	6078110b 086b7867 499002e3 07c12842     ..x`gxk....IB(..
   11b10:	78276038 02e3085b 28424ad0 603807c1     8`'x[....JB(..8`
   11b20:	084f7827 41c302c3 12880080 78e29100     'xO....A.......x
   11b30:	07c32842 78676078 080d7810 8d5d0071     B(..x`gx.x..q.].
   11b40:	ad5d7144 082f784d b1e000b2 10031d1c     Dq].Mx/.........
   11b50:	10051d14 8d7cf019 706c7174 a500f410     ......|.tqlp....
   11b60:	a542a521 10451d18 b56bad7c 1d1df00d     !.B...E.|.k.....
   11b70:	6f091003 1d18b50a f0071005 10431d1c     ...o..........C.
   11b80:	b50a9508 700cb56c 78e0c4c6 710c7fe0     ....l..p...x...q
   11b90:	4628c2ec 04af0966 093e4508 411004af     ..(Ff....E>....A
   11ba0:	710c4100 40304222 47085ab1 4102d812     .A.q"B0@.Z.G...A
   11bb0:	5ab14222 d8134210 42224102 40105ab1     "B.Z.B...A"B.Z.@
   11bc0:	9fc3258c 9f8225cc 00800000 0d55f219     .%...%........U.
   11bd0:	40e110b5 064f0e5a 0e56e80d 4042066f     ...@Z.O...V.o.B@
   11be0:	0e4ee809 4002066f 8e04e805 feaf0a22     ..N.o..@...."...
   11bf0:	1672702c b8c61080 10021e72 8728f00b     ,pr.....r.....(.
   11c00:	40e17960 8fc3208c 8e04f205 feaf0a02     `y.@. ..........
   11c10:	42c3d980 12400080 41c1700c 5ad5a2a0     ...B..@..p.A...Z
   11c20:	008040c3 80001240 78e0c6cc 700cc0f1     .@..@......x...p
   11c30:	d87f5ad7 7fe0c0d1 78e0b817 c1a1c0f1     .Z.........x....
   11c40:	008041c3 9160122c c1808141 30c41c00     .A..,.`.A......0
   11c50:	74875ace 7fe0c0d1 78e0700c c1a1c3e2     .Z.t.....p.x....
   11c60:	dd248021 8131e912 008043c3 9140122c     !.$...1..C..,.@.
   11c70:	0a199320 70ad0060 8028b340 30841c00      ...`..p@.(....0
   11c80:	8048a321 5acec180 c7c240a1 700c7fe0     !.H....Z.@.....p
   11c90:	41c3c0f1 12280080 702c8140 c0d15ace     ...A..(.@.,p.Z..
   11ca0:	700c7fe0 8048c0f1 008041c3 a1401228     ...p..H..A..(.@.
   11cb0:	702c8048 c0d15ace 700c7fe0 700c7fe0     H.,p.Z.....p...p
   11cc0:	0816c2e4 460804af 04af0832 42004508     .......F2....E.B
   11cd0:	41a1d813 45cb5ab1 12640080 ee85a500     ...A.Z.E..d.....
   11ce0:	85205ab5 c6c45ad4 45cbc2e4 12500080     .Z ..Z.....E..P.
   11cf0:	10c1150c 0f724608 4020046f 08268e04     .....Fr.o. @..&.
   11d00:	702c066f 5aa2710c 700c9520 c6c4b525     o.,p.q.Z ..p%...
   11d10:	4608c2e4 90039042 008045cb 85241250     ...FB....E..P.$.
   11d20:	7845b810 8002218c 8f8221cc 00ff0000     ..Ex.!...!......
   11d30:	780ff410 062f0f9e 8e04702c 062f0fe6     ...x../.,p..../.
   11d40:	710c712c 0c925aa2 150c0020 f00810c0     ,q.q.Z.. .......
   11d50:	0fd2780f 702c062f 5aa2710c c6c4700c     .x../.,p.q.Z.p..
   11d60:	000040c3 7ee0ffff 008040c3 7fe01260     .@.....~.@..`...
   11d70:	78e08000 42c3c0f1 12500080 8904a201     ...x...B..P.....
   11d80:	e2084520 726cd978 007f44c3 5ac0d484      E..x.lr.D.....Z
   11d90:	7ee0c0d1 7fe0d87f 78e0b817 7fe0d87f     ...~.......x....
   11da0:	78e0b817 e88fc2e2 008043c3 8b491250     ...x.....C..P.I.
   11db0:	93a58b08 8381ba08 62ba7a05 7c604020     .........z.b @`|
   11dc0:	c6c2b340 c1a1c3e6 7fc51e00 201e0080     @.............. 
   11dd0:	88044508 2440702c 716c30c2 de225abf     .E..,p@$.0lq.Z".
   11de0:	1403e8ac de213080 0080206c 8403208c     .....0!.l ... ..
   11df0:	08aef424 8d04feaf 1c03e8a0 8d043043     $...........C0..
   11e00:	2440d954 716c30c2 710c5ac1 700c5aa2     T.@$.0lq.Z.q.Z.p
   11e10:	00200836 47cb41a1 12500080 10c0170c     6. ..A.G..P.....
   11e20:	0c5670cd b7c5046f 41c3d814 d3a0007f     .pV.o......A....
   11e30:	00200c2e af0c42a1 c7c640c1 000040c3     .. ..B...@...@..
   11e40:	7ee0ffff 4628c2ec 046f0eb2 0e8a4508     ...~..(F..o..E..
   11e50:	4110046f 710c4100 40304222 47085ab1     o..A.A.q"B0@.Z.G
   11e60:	4102d811 5ab14222 d8124210 42224102     ...A"B.Z.B...A"B
   11e70:	40105ab1 9fc3258c 9f8225cc 00800000     .Z.@.%...%......
   11e80:	0d79f220 40e110b5 064f0ba6 0ba2e80d      .y....@..O.....
   11e90:	4002066f 0b9ae809 4042066f 8e04e805     o..@....o.B@....
   11ea0:	fe6f0f6e 40c3702c 125c0080 046f0dba     n.o.,p.@..\...o.
   11eb0:	00c01000 10801672 1e72b8c6 f0171002     ....r.....r.....
   11ec0:	79608728 208c40e1 f2068fc3 0f428e04     (.`y.@. ......B.
   11ed0:	d980fe6f 10c01672 00130813 008040c3     o...r........@..
   11ee0:	0af6125c 10000020 42c300c0 12600080     \... ......B..`.
   11ef0:	41c1700c 5ad5a2a0 008040c3 80001260     .p.A...Z.@..`...
   11f00:	78e0c6cc 700cc0f1 d87f5ad7 7fe0c0d1     ...x...p.Z......
   11f10:	78e0b817 4508c2e2 00801072 b8c6702c     ...x...Er...,p..
   11f20:	10021d72 062f0f6e 8d048d04 062f0dba     r...n./......./.
   11f30:	41c3702c 12480080 1900700c c6c20005     ,p.A..H..p......
   11f40:	4508c2e2 00c01072 00320823 0f46712c     ...Er...#.2.,qF.
   11f50:	8d04062f 0d928d04 712c062f 008040c3     /......./.,q.@..
   11f60:	18001248 15720005 204f1080 700c01c1     H.....r...O ...p
   11f70:	10421d72 78e0c6c2 710c7fe0 008040c3     r.B....x...q.@..
   11f80:	7fe0124c 78e08000 45cbc2ea 12440080     L......x...E..D.
   11f90:	47089542 41306a01 ea18b502 2008202f     B..G.j0A..../ . 
   11fa0:	08115ab5 460820b1 7f604022 c6caa5c0     .Z... .F"@`.....
   11fb0:	4e108500 8059208c 7f60f785 a5c04022     ...N. Y...`."@..
   11fc0:	9502c6ca b5027704 78e0c6ca 7fe0d87f     .....w.....x....
   11fd0:	78e0b817 7fe0d87f 78e0b817 c1a1c3e4     ...x.......x....
   11fe0:	7fc51e00 201c0080 88044508 2440702c     ....... .E..,p@$
   11ff0:	716c30c2 de225abf 1403e89c de213080     .0lq.Z"......0!.
   12000:	0080206c 8403208c 0e96f414 8d04fe6f     l ... ......o...
   12010:	1c03e890 8d043043 2440d954 716c30c2     ....C0..T.@$.0lq
   12020:	710c5ac1 700c5aa2 00200812 70cd41a1     .Z.q.Z.p.. ..A.p
   12030:	c7c440c1 710c7fe0 4628c2ec 046f0cbe     .@.....q..(F..o.
   12040:	0c964508 4110046f 710c4100 40304222     .E..o..A.A.q"B0@
   12050:	47085ab1 4102d811 5ab14222 d8134210     .Z.G...A"B.Z.B..
   12060:	42224102 40105ab1 9fc3258c 9f8225cc     .A"B.Z.@.%...%..
   12070:	00800000 0d55f219 40e110b5 064f09b2     ......U....@..O.
   12080:	09aee80d 4002066f 09a6e809 4042066f     ....o..@....o.B@
   12090:	8e04e805 fe6f0d7a 1672702c b8c61080     ....z.o.,pr.....
   120a0:	10021e72 8728f00b 40e17960 8fc3208c     r.....(.`y.@. ..
   120b0:	8e04f205 fe6f0d5a 42c3d980 124c0080     ....Z.o....B..L.
   120c0:	41c1700c 5ad5a2a0 008040c3 8000124c     .p.A...Z.@..L...
   120d0:	78e0c6cc 700cc0f1 d87f5ad7 7fe0c0d1     ...x...p.Z......
   120e0:	78e0b817 c1a5c3e4 70811600 1fe40080     ...x.......p....
   120f0:	01be093d c0804508 5aa4c680 34c02440     =....E.....Z@$.4
   12100:	14135aa3 382f3080 c0430003 0000204a     .Z...0/8..C.J ..
   12110:	71048620 0f813900 ac123c20 80f208f5      ..q.9.. <......
   12120:	10501e04 d8fb8548 5acdc180 06ef0fc2     ..P.H......Z....
   12130:	c7c440a1 4608c2ea f2437014 b8e48e00     .@.....F.pC.....
   12140:	9602f43f 40d370ad 1e8c0080 70ed7104     ?....p.@.....q.p
   12150:	2008212f 00000007 100071e5 78ed2081     /!. .....q... .x
   12160:	00630841 080e70b5 7014044f 838220cc     A.c..p..O..p. ..
   12170:	9020f3f4 807e09e5 9042b9e4 79306a21     .. ...~...B.!j0y
   12180:	edecf206 04412139 f1e8e90a f21a7132     ....9!A.....2q..
   12190:	847e2909 2909f204 f5e0a07e f1de4508     .)~....)~....E..
   121a0:	272ff20f 236f007f 9503003f 28097104     ../'..o#?....q.(
   121b0:	70c30440 ffff0000 262fb603 c6ca007f     @..p....../&....
   121c0:	007f272f 003f236f b6039003 007f262f     /'..o#?...../&..
   121d0:	78e0c6ca 0f9ec2e2 4508040f 8d00e834     ...x.......E4...
   121e0:	007f0865 0f5240a1 0da6ffcf 702cff4f     e....@R.....O.,p
   121f0:	e80ab98b 06e221ab b8819500 21abb500     .....!.........!
   12200:	f01a06a2 704c9500 103c248a b500b881     ......Lp.$<.....
   12210:	07a122ab 076120aa 2004716c b8810302     ."... a.lq. ....
   12220:	7845780f 076120ab 076221ab 06a221ab     .xEx. a..!b..!..
   12230:	076123ab 000040c3 e8060000 0f802022     .#a..@......" ..
   12240:	00000000 78e0c6c2 0f2ac0f1 4100040f     .......x..*....A
   12250:	e903700c c0d19101 78e07ee0 0fbec2e2     .p.......~.x....
   12260:	080d040f 45080033 5accd8a0 c6c240a1     ....3..E...Z.@..
   12270:	4010c2ea 042f0efe 45084728 70b5d8ff     ...@../.(G.E...p
   12280:	8d20f230 f22eb9e0 047f272f 003f236f     0. ...../'..o#?.
   12290:	ff4f0cfe e8064608 76e226ab 08000000     ..O..F...&.v....
   122a0:	047f262f 20aab5e1 d9200422 b8c1b822     /&..... ". ."...
   122b0:	00002900 0a0f209a 03c12805 b8e18d00     .)... ...(......
   122c0:	000071c3 4020ffff f403b522 0e6ab503     .q.... @".....j.
   122d0:	40a1ffef 26abee05 000076a2 40020800     ...@...&.v.....@
   122e0:	c6ca780d 4508c2e6 70cd8007 8508e810     .x.....E...p....
   122f0:	40a1e80e 85285abc 79604708 0f1140a1     ...@.Z(..G`y.@..
   12300:	40e11020 7a608547 71cd41a1 c6c640c1      ..@G.`z.A.q.@..
   12310:	c1a3c3ea 88154708 b8c14150 00b008e7     .....G..PA......
   12320:	16004628 0080700d 24401f34 c28232c1     (F...p..4.@$.2..
   12330:	31832440 30842440 31452440 5ab440e1     @$.1@$.0@$E1.@.Z
   12340:	31021402 2140214f 21412150 0290205a     ...1O!@!P!A!Z ..
   12350:	0280215a 200072d1 651d2350 2111216c     Z!...r. P#.el!.!
   12360:	2831090f 108526ca 23841802 b5c1f002     ..1(.&.....#....
   12370:	08218f15 40a1017e 04cf0df2 04ef0dee     ..!.~..@........
   12380:	10024002 e8842100 e8339501 f03171cd     .@...!....3..q1.
   12390:	21011002 09419501 20080020 e91c004e     ...!..A. .. N...
   123a0:	40e1e81a 09225ab3 1402030f e88f3101     ...@.Z"......1..
   123b0:	714c8f76 0000000d 7144785b 000122ca     v.Lq....[xDq."..
   123c0:	00802904 83a508f5 091bbbe0 42a12831     .)..........1(.B
   123d0:	f00b4302 04ef0d96 0d9240a1 400204ef     .C.......@.....@
   123e0:	4202f007 082243a1 44e1feef 97134608     ...B.C"....D.F..
   123f0:	03800813 10431f12 1e00b7d3 00807043     ......C.....Cp..
   12400:	c7ca1f96 006041c3 42c3c4a0 bcc00060     .....A`....B`...
   12410:	455043c3 03b9d4dd 78e0ff4f 006041c3     .CPE....O..x.A`.
   12420:	42c3dee4 c8380060 ff4f0391 006041c3     ...B`.8...O..A`.
   12430:	42c3cba0 bcc00060 455043c3 0391d4dd     ...B`....CPE....
   12440:	78e0ff4f 45cbc2e2 975e0060 30001400     O..x...E`.^....0
   12450:	03410815 0ce020aa 5acc780f 1c004d1e     ..A.. ...x.Z.M..
   12460:	c6c23000 05cf0bca 78e0c6c2 41c3c0f1     .0.........x...A
   12470:	121c0080 702c8140 c0d15ace 700c7fe0     ....@.,p.Z.....p
   12480:	c1a5c3e4 c0804508 076f093a 0956c680     .....E..:.o...V.
   12490:	2440072f 141334c0 382f3080 c0430003     /.@$.4...0/8..C.
   124a0:	0000204a 71048620 0f813900 ac123c20     J .. ..q.9.. <..
   124b0:	80f208f5 10501e04 70801600 1fe40080     ......P....p....
   124c0:	00fe080d 8548d8fb 5acdc180 008040c3     ......H....Z.@..
   124d0:	0c7e1388 c180fdaf 00422084 8042208c     ..~...... B.. B.
   124e0:	8528f40d 008040c3 a020121c 702c8548     ..(..@.... .H.,p
   124f0:	5ace40a1 40a1702c 700c5add 78e0c7c4     .@.Z,p.@.Z.p...x
   12500:	41c3c0f1 1ff80080 40c39156 13880080     ...A....V..@....
   12510:	fdaf0c3a c0d1b157 700c7fe0 0d7ac2e4     :...W......p..z.
   12520:	4528066f 10710d23 0fc64608 0fe6040f     o.(E#.q..F......
   12530:	4508042f d8174200 5ab641a1 880de805     /..E.B...A.Z....
   12540:	d8c87014 40c1f402 0000c6c4 02494e49     .p.....@....INI.
   12550:	007fde98 00000004 008012f8 007fde9c     ................
   12560:	00000008 008012d0 00801300 007fdea4     ................
   12570:	00000004 00801308 007fdea8 00000004     ................
   12580:	00801310 007fdeac 00000008 008012c8     ................
   12590:	008012f0 007fdeb4 00000004 008012e8     ................
   125a0:	007fdeb8 00000004 008012d8 008011f0     ................
   125b0:	00000174 00000000 00000000 00000000     t...............
	...
   12620:	000000ff 00000000 00000000 00000023     ............#...
	...
   1268c:	00000006 007fa994 00000006 007fa954     ............T...
   1269c:	00000005 007fc90c 007fdebc 007fe114     ................
   126ac:	00000005 0060a87c 00000005 0060add4     ....|.`.......`.
   126bc:	00000005 0060ab60 00000005 0060b044     ....`.`.....D.`.
   126cc:	00000005 007fa944 00000005 0060ab8c     ....D.........`.
   126dc:	007fde98 007fde9c 007fde9c 007fdea4     ................
   126ec:	007fdea4 007fdea8 007fdea8 007fdeac     ................
   126fc:	007fdeac 007fdeb4 007fdeb4 007fdeb8     ................
   1270c:	007fdeb8 007fdeb8 007fdeb8 007fdebc     ................
   1271c:	0060c378 0060be34 0060c6ec 00000000     x.`.4.`...`.....
   1272c:	00000000 000e1001 fdf7fef8 0000fcf6     ................
   1273c:	00100e01 00060019 00070032 00080064     ........2...d...
   1274c:	000900c8 000a0190 0101000e 880c0901     ................
   1275c:	01011013 00002a71 000300fa 390b7d77     ....q*......w}.9
   1276c:	000201f4 398bb3fb 000103e8 3a0b7d77     .......9....w}.:
   1277c:	000007d0 3a8b7d77 00060019 00070032     ....w}.:....2...
   1278c:	00080064 000900c8 000a0190 3d01ccaf     d..............=
   1279c:	bdc2b307 3dc2b307 bd01ccaf 3f800000     .......=.......?
   127ac:	3fbac177 3f690df1 3e4a92b0 00000000     w..?..i?..J>....
	...
   127e0:	01902f69 0000012d 00000000 00000000     i/..-...........
   127f0:	00000a11 007fd0f8 007fd270 007fd090     ........p.......
   12800:	007fd30c 007fd0bc 007fd034 007fcffc     ........4.......
   12810:	007fd0c4 007fd09c 007fd26c 007fd08c     ........l.......
	...
   12830:	3d75c28f 00000000 00010000 00010001     ..u=............
	...
   1284c:	00010000 00000000 00000000 01902f69     ............i/..
   1285c:	0000012e 00000000 00000000 00000a12     ................
   1286c:	007fd6bc 007fd718 007fd65c 007fd7b4     ........\.......
   1287c:	007fd6ac 007fd620 007fd5f4 007fd6b4     .... ...........
   1288c:	007fd668 007fd714 007fd658 00000000     h.......X.......
	...
   128a8:	3d75c28f 00000000 00010000 00010001     ..u=............
	...
   128c4:	00010000 00000000 00000000 01902f69     ............i/..
   128d4:	0010012f 00000000 00000000 00000a13     /...............
   128e4:	007fd4a4 007fd524 007fd448 007fd5e4     ....$...H.......
   128f4:	007fd474 007fd3f0 007fd3c8 007fd47c     t...........|...
   12904:	007fd454 007fd51c 007fd440 00801250     T.......@...P...
	...
   12920:	3d75c28f 00000000 00010000 0001ffff     ..u=............
	...
   1293c:	00010000 00000000 00000000 01900869     ............i...
   1294c:	00100130 00000000 00000000 00000201     0...............
   1295c:	007fa7c8 007fa804 0060a140 007fa8b4     ........@.`.....
   1296c:	0060a14c 0060a6c8 0060a708 0060a158     L.`...`...`.X.`.
   1297c:	0060a4bc 0060a604 0060a134 008028c4     ..`...`.4.`..(..
   1298c:	008022cc 00000000 00000000 3e051eb8     .".............>
   1299c:	00000000 01900000 00010010 00000000     ................
   129ac:	00ff0000 00000001 00030100 00000000     ................
   129bc:	00000000 01902f69 00100131 00000000     ....i/..1.......
   129cc:	00000000 00000210 007fbc40 007fbcc0     ........@.......
   129dc:	007fbbac 007fbd1c 007fbbe4 007fbb60     ............`...
   129ec:	007fbb28 007fbbf0 007fbbb8 007fbc7c     (...........|...
   129fc:	007fbba0 00801b34 007fde34 00000000     ....4...4.......
   12a0c:	00000000 3f4ccccd 00000000 01900000     ......L?........
   12a1c:	000103e8 00000000 00ff0000 00000001     ................
   12a2c:	00030100 00000000 00000000 00000116     ................
   12a3c:	000001e9 00000000 00000000 00003419     .............4..
   12a4c:	00000000 00000004 00000000 00000000     ................
   12a5c:	007fcf34 007fceb4 007fcea0 00000000     4...............
   12a6c:	00000116 000001ea 00000000 00000000     ................
   12a7c:	00003418 00000000 00000004 00000000     .4..............
   12a8c:	00000000 007fbb14 007fba94 007fba80     ................
   12a9c:	00000000 00000116 000001eb 00000000     ................
   12aac:	00000000 0000341f 00000000 02000004     .....4..........
	...
   12ac4:	0060b85c 007fa444 0060b930 00000000     \.`.D...0.`.....
   12ad4:	00000212 000001ed 00000000 00000000     ................
   12ae4:	00003012 00000212 00000006 00000000     .0..............
   12af4:	00000000 007fd39c 007fd384 007fd370     ............p...
   12b04:	00000000 00000213 000001ee 00000000     ................
   12b14:	00000000 00003013 00000213 02000006     .....0..........
	...
   12b2c:	007fd36c 007fd33c 007fd31c 00000000     l...<...........
   12b3c:	00000211 000001ef 00000000 00000000     ................
   12b4c:	00002411 00000211 00000006 00000000     .$..............
   12b5c:	00000000 007fcff8 007fcfd8 007fcfc4     ................
	...
   12b74:	000001f0 00000000 00000000 00000041     ............A...
   12b84:	00000000 00000007 00000000 00000000     ................
   12b94:	00000000 0060adb0 00000000 00000000     ......`.........
   12ba4:	00000140 000001f1 00000000 00000000     @...............
   12bb4:	00000001 00000201 07000002 00000000     ................
	...
   12bcc:	007fdae4 00000000 00000000 00000140     ............@...
   12bdc:	000001f3 00000000 00000000 00000004     ................
   12bec:	00000210 07000002 00000000 00000000     ................
   12bfc:	00000000 007fdafc 00000000 00000000     ................
   12c0c:	00000140 000001f4 00000000 00000000     @...............
   12c1c:	00000010 00000210 0d000002 00000000     ................
	...
   12c34:	0060b5d4 00000000 00000000 00000140     ..`.........@...
   12c44:	000001f6 00000000 00000000 0000000a     ................
   12c54:	00000201 07000002 00000000 00000000     ................
   12c64:	00000000 007fdb0c 00000000 00000000     ................
   12c74:	00000140 000001f7 00000000 00000000     @...............
   12c84:	00000009 00000201 07000002 00000000     ................
	...
   12c9c:	0060b3fc 00000000 00000000 00000140     ..`.........@...
   12cac:	000001fc 00000000 00000000 0000000f     ................
   12cbc:	00000000 0a000002 00000000 00000000     ................
   12ccc:	00000000 0060b4a4 00000000 00000000     ......`.........
   12cdc:	001e0000 000001e0 00000000 00000000     ................
   12cec:	00004150 00000000 00000002 00000000     PA..............
	...
   12d04:	007fad94 00000000 00000000 00c80000     ................
   12d14:	000001e8 00000000 00000000 00003517     .............5..
   12d24:	00000000 00000003 00000000 00000000     ................
   12d34:	007fdbe0 007fdb60 007fdb4c 00000000     ....`...L.......
   12d44:	00320000 000001ec 00000000 00000000     ..2.............
   12d54:	00003516 00000000 00000004 00000000     .5..............
   12d64:	00000000 0060b7bc 007fd7c4 0060b848     ......`.....H.`.
   12d74:	00000000 00c80042 000001f0 00000000     ....B...........
   12d84:	00000000 00000140 00000000 00000002     ....@...........
	...
   12d9c:	007fabf4 007faa50 00000000 0000c88b     ....P...........
   12dac:	00041105 00032a54 00000006 00000000     ....T*..........
   12dbc:	00001555 00000000 00000000 00000000     U...............
	...

00012dd8 <_bhi_fw_len>:
   12dd8:	000064c8 000040e8 00004142 00004142     .d...@..BA..BA..
   12de8:	00004142 00004142 00004196 000041d2     BA..BA...A...A..
   12df8:	000041b4 00004196 00004142 00004142     .A...A..BA..BA..
   12e08:	000040f4 00004196 000041b4 00004202     .@...A...A...B..
   12e18:	000040f4 00004202 000041f6 000041f6     .@...B...A...A..
   12e28:	00004196 000040f4 0000417e 000041f6     .A...@..~A...A..
   12e38:	000041f6 000041f6 000041f6 00004370     .A...A...A..pC..
   12e48:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12e58:	00004196 00004370 00004142 00004142     .A..pC..BA..BA..
   12e68:	00004142 00004142 00004196 000041d2     BA..BA...A...A..
   12e78:	000041b4 00004196 00004142 00004142     .A...A..BA..BA..
   12e88:	000040f4 00004196 000041b4 00004202     .@...A...A...B..
   12e98:	000040f4 00004202 000041f6 000041f6     .@...B...A...A..
   12ea8:	00004196 000040f4 0000417e 000041f6     .A...@..~A...A..
   12eb8:	000041f6 000041f6 000041f6 00004370     .A...A...A..pC..
   12ec8:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12ed8:	00004196 00004370 00004370 00004370     .A..pC..pC..pC..
   12ee8:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12ef8:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12f08:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12f18:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12f28:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12f38:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12f48:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12f58:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12f68:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12f78:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12f88:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12f98:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12fa8:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12fb8:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12fc8:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12fd8:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12fe8:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   12ff8:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13008:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13018:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13028:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13038:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13048:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13058:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13068:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13078:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13088:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13098:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   130a8:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   130b8:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   130c8:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   130d8:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   130e8:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   130f8:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13108:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13118:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13128:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13138:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13148:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13158:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13168:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13178:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13188:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   13198:	00004370 00004370 00004370 00004370     pC..pC..pC..pC..
   131a8:	00004370 00004370 00004370 00004196     pC..pC..pC...A..
   131b8:	00004196 00004262 00004286 00004286     .A..bB...B...B..
   131c8:	00004286 00004196 00004196 00004262     .B...A...A..bB..

000131d8 <_fifoSizes>:
   131d8:	02080b01 01040303 0011040e 0000471e     .............G..
   131e8:	0000495c 0000495c 0000495c 0000495c     \I..\I..\I..\I..
   131f8:	0000495c 0000495c 0000495c 0000495c     \I..\I..\I..\I..
   13208:	0000495c 0000495c 0000495c 0000495c     \I..\I..\I..\I..
   13218:	0000495c 0000495c 0000495c 00004706     \I..\I..\I...G..
   13228:	0000495c 0000495c 0000495c 0000495c     \I..\I..\I..\I..
   13238:	0000495c 0000495c 0000495c 0000495c     \I..\I..\I..\I..
   13248:	0000495c 0000495c 0000495c 0000495c     \I..\I..\I..\I..
   13258:	0000495c 0000495c 0000495c 00004716     \I..\I..\I...G..
   13268:	0000495c 0000495c 0000495c 0000495c     \I..\I..\I..\I..
   13278:	0000495c 0000495c 0000495c 0000495c     \I..\I..\I..\I..
   13288:	0000495c 0000495c 0000495c 0000495c     \I..\I..\I..\I..
   13298:	0000495c 0000495c 0000495c 0000470e     \I..\I..\I...G..
   132a8:	00004726 000046ee 000046fe 000046f6     &G...F...F...F..
   132b8:	00000002 00000003 00000028 00000029     ........(...)...
   132c8:	00000004 00000005 00000006 00000007     ................
   132d8:	0000ffff 0000ffff 00000022 00000023     ........"...#...
   132e8:	0000ffff 0000ffff 0000ffff 0000ffff     ................
   132f8:	00000008 00000009 0000000a 0000000b     ................
   13308:	0000ffff 0000ffff 0000ffff 0000ffff     ................
   13318:	42000000 42000400 42000800 42000c00     ...B...B...B...B
   13328:	42001000 43000400 0b0a0908 00000d0c     ...B...C........
   13338:	00007026 00007022 00007022 00007084     &p.."p.."p...p..
   13348:	00007084 0000703c 0000702c 00007042     .p..<p..,p..Bp..
   13358:	00007072 00007248 00007228 00007228     rp..Hr..(r..(r..
   13368:	000072c2 0000723a 00007256 0000722c     .r..:r..Vr..,r..
   13378:	00007264 000072a6 00007300 00007342     dr...r...s..Bs..
   13388:	00007342 00007342 000072f2 0000730e     Bs..Bs...r...s..
   13398:	000072e4 0000731c 00007332 00007a36     .r...s..2s..6z..
   133a8:	00007a40 00007a4a 00007a54 00007a5e     @z..Jz..Tz..^z..
   133b8:	00007a8a 00007a94 00007a9e 00007aa8     .z...z...z...z..
   133c8:	00007ab2 42002000 42002400 43000800     .z... .B.$.B...C
   133d8:	001d1b1b 00000002 00000100 00000002     ................
   133e8:	00000200 00000003 00000004 6b636f73     ............sock
   133f8:	635f7465 63203a62 656e6e6f 73207463     et_cb: connect s
   13408:	65636375 0d217373 00000000 6b636f73     uccess!.....sock
   13418:	635f7465 63203a62 656e6e6f 65207463     et_cb: connect e
   13428:	726f7272 00000d21 6b636f73 635f7465     rror!...socket_c
   13438:	73203a62 20646e65 63637573 21737365     b: send success!
   13448:	0000000d 6b636f73 635f7465 72203a62     ....socket_cb: r
   13458:	20766365 63637573 21737365 0000000d     ecv success!....
   13468:	20504354 65696c43 5420746e 20747365     TCP Client Test 
   13478:	706d6f43 6574656c 00000d21 6b636f73     Complete!...sock
   13488:	635f7465 72203a62 20766365 6f727265     et_cb: recv erro
   13498:	000d2172 69666977 3a62635f 4d324d20     r!..wifi_cb: M2M
   134a8:	4649575f 45525f49 435f5053 535f4e4f     _WIFI_RESP_CON_S
   134b8:	45544154 4148435f 4445474e 4f43203a     TATE_CHANGED: CO
   134c8:	43454e4e 0d444554 00000000 69666977     NNECTED.....wifi
   134d8:	3a62635f 4d324d20 4649575f 45525f49     _cb: M2M_WIFI_RE
   134e8:	435f5053 535f4e4f 45544154 4148435f     SP_CON_STATE_CHA
   134f8:	4445474e 4944203a 4e4f4353 5443454e     NGED: DISCONNECT
   13508:	000d4445 7068636d 38373635 00000000     ED..mchp5678....
   13518:	7068636d 6d65645f 0000006f 69666977     mchp_demo...wifi
   13528:	3a62635f 4d324d20 4649575f 45525f49     _cb: M2M_WIFI_RE
   13538:	48445f51 435f5043 3a464e4f 20504920     Q_DHCP_CONF: IP 
   13548:	25207369 75252e75 2e75252e 0a0d7525     is %u.%u.%u.%u..
   13558:	00000000 64616552 20676e69 32454d42     ....Reading BME2
   13568:	68203038 66207361 656c6961 00000064     80 has failed...
   13578:	64616552 20676e69 4c4d4556 30383036     Reading VEML6080
   13588:	73616820 69616620 0064656c 74696e49      has failed.Init
   13598:	696c6169 676e697a 61655720 6c626172     ializing Wearabl
   135a8:	65442065 44206f6d 63697665 00000065     e Demo Device...
   135b8:	5f757063 71657266 0a64253d 00000000     cpu_freq=%d.....
   135c8:	6e69616d 326d203a 69775f6d 695f6966     main: m2m_wifi_i
   135d8:	2074696e 6c6c6163 72726520 2821726f     nit call error!(
   135e8:	0d296425 0000000a 6e69616d 6166203a     %d).....main: fa
   135f8:	64656c69 206f7420 61657263 54206574     iled to create T
   13608:	63205043 6e65696c 6f732074 74656b63     CP client socket
   13618:	72726520 0d21726f 00000000 69766e65      error!.....envi
   13628:	5f6e6f72 61746164 25203d20 25202c64     ron_data = %d, %
   13638:	25202c64 25202c64 00000a64 20636361     d, %d, %d...acc 
   13648:	61746164 25203d20 25202c64 25202c64     data = %d, %d, %
   13658:	00000a64                                d...

0001365c <ci_table>:
   1365c:	0004c996 00024414 0001220a 000083d6     .....D..."......
   1366c:	00004f1a 00001a5e                       .O..^...

00013674 <cc_rough>:
   13674:	00000000 000107ac 00020f58 00033e14     ........X....>..

00013684 <cc_coarse>:
   13684:	00000000 00001a5e 000034bc 00004f1a     ....^....4...O..
   13694:	00006978 000083d6 00009e34 0000b892     xi......4.......
   136a4:	0000d2f0 0000ed4e 000107ac 0001220a     ....N........"..
   136b4:	00013c68 000156c6 00017124 00018b82     h<...V..$q......

000136c4 <cc_fine>:
   136c4:	02a30000 07e90546 0d2f0a8c 12750fd2     ....F...../...u.
   136d4:	17bb1518 1d011a5e 22471fa4 278d24ea     ....^.....G".$.'

000136e4 <cc_accurate>:
   136e4:	00430000 00ca0087 0151010e 01d80195     ..C.......Q.....
   136f4:	025f021c 02e602a3 036d032a 03f403b1     .._.....*.m.....
   13704:	00000043                                C...

00013708 <_global_impure_ptr>:
   13708:	200000d0                                ... 

0001370c <__sf_fake_stdin>:
	...

0001372c <__sf_fake_stdout>:
	...

0001374c <__sf_fake_stderr>:
	...
   1376c:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
   1377c:	32313000 36353433 41393837 45444342     .0123456789ABCDE
   1378c:	31300046 35343332 39383736 64636261     F.0123456789abcd
   1379c:	00006665                                ef..

000137a0 <_init>:
   137a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   137a2:	46c0      	nop			; (mov r8, r8)
   137a4:	bcf8      	pop	{r3, r4, r5, r6, r7}
   137a6:	bc08      	pop	{r3}
   137a8:	469e      	mov	lr, r3
   137aa:	4770      	bx	lr

000137ac <__init_array_start>:
   137ac:	000000dd 	.word	0x000000dd

000137b0 <_fini>:
   137b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   137b2:	46c0      	nop			; (mov r8, r8)
   137b4:	bcf8      	pop	{r3, r4, r5, r6, r7}
   137b6:	bc08      	pop	{r3}
   137b8:	469e      	mov	lr, r3
   137ba:	4770      	bx	lr

000137bc <__fini_array_start>:
   137bc:	000000b5 	.word	0x000000b5
